// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x140849540 (sub_140849540)
//   - 0x14084B4C0 (_InterlockedIncrement_w_0)
//   - 0x14084D320 (sub_14084D320)
//   - 0x14084F6B0 (sub_14084F6B0)
//   - 0x140850F90 (sub_140850F90)
//   - 0x140853BE0 (sub_140853BE0)
//   - 0x140854340 (sub_140854340)
//   - 0x140854F30 (sub_140854F30)
//   - 0x140854F90 (sub_140854F90)
//   - 0x140855250 (sub_140855250)
//   - 0x1408560D0 (sub_1408560D0)
//   - 0x140857430 (sub_140857430)
//   - 0x140860580 (sub_140860580)
// Caller Depth: 1
// Callee/Ref Depth: 4
// Total Functions Found: 228
// ------------------------------------------------------------

// --- Function: sub_1402A59F0 (0x1402A59F0) ---
__int64 sub_1402A59F0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  unsigned __int64 v5; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1402A6440(a1, Buffer, v5);
  return a1;
}

// --- End Function: sub_1402A59F0 (0x1402A59F0) ---

// --- Function: __StarEngineModule__ (0x1402A5D20) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A5D20) ---

// --- Function: sub_1402A63B0 (0x1402A63B0) ---
_BYTE *__fastcall sub_1402A63B0(__int64 *a1, __int64 n0x1FF_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0x1FF; // rcx

  result = a1 + 3;
  if ( n0x1FF_1 )
  {
    allocSize = n0x1FF_1 + 1;
    if ( (unsigned __int64)(n0x1FF_1 + 1) <= 0x200 )
    {
      n0x1FF = 0x1FF;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149C78668 += allocSize;
      n0x1FF = n0x1FF_1;
    }
    a1[1] = n0x1FF;
    *a1 = n0x1FF_1;
    a1[2] = (__int64)result;
    result[n0x1FF_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0x1FF;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A63B0 (0x1402A63B0) ---

// --- Function: sub_1402A6440 (0x1402A6440) ---
__int64 __fastcall sub_1402A6440(__int64 a1, const void *a2, size_t Size)
{
  size_t Size_1; // r8
  __int64 v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  Size_1 = *(_QWORD *)(a1 + 8);
  if ( Size > Size_1 )
  {
    v7 = *(_QWORD *)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != a1 + 0x18 )
    {
      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - Size_1;
      sub_147715880(v7, (unsigned int)dword_149A5EC00);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x1FF;
    sub_1402A63B0(a1, Size);
  }
  memmove(*(void **)(a1 + 0x10), a2, Size);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = Size;
  *(_BYTE *)(Size + result) = 0;
  return result;
}

// --- End Function: sub_1402A6440 (0x1402A6440) ---

// --- Function: sub_1402A6590 (0x1402A6590) ---
__int64 __fastcall sub_1402A6590(__int64 a1)
{
  return sub_147715880(a1, (unsigned int)dword_149A5EC00);
}

// --- End Function: sub_1402A6590 (0x1402A6590) ---

// --- Function: sub_1402A65A0 (0x1402A65A0) ---
__int64 __fastcall sub_1402A65A0(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: sub_1402A65A0 (0x1402A65A0) ---

// --- Function: sub_1402A6BE0 (0x1402A6BE0) ---
void *sub_1402A6BE0()
{
  return &unk_149C78580;
}

// --- End Function: sub_1402A6BE0 (0x1402A6BE0) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8FF0) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  __int64 v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10(this);
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(_QWORD *)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8FF0) ---

// --- Function: sub_1402ABF30 (0x1402ABF30) ---
const void **__fastcall sub_1402ABF30(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  size_t Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  size_t v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  __int64 v17; // rbx

  Size_1 = (size_t)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = Size_1 + a2;
  v11 = (Size_1 + a2) | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
        v15 = 0;
      else
        v15 = (_QWORD *)sub_1402A65A0(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 0x28;
    if ( v6 + 0x28 < (unsigned __int64)(v6 + 1) )
      sub_1402E3880();
  }
  v14 = sub_1402A65A0(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v15[0xFFFFFFFF] = v14;
LABEL_15:
  Src[2] = (const void *)v10;
  v16 = (char *)v15 + Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, Size_1);
    memcpy((char *)v15 + Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = (__int64)*Src;
  memcpy(v15, *Src, Size_1);
  memcpy((char *)v15 + Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v17 - *(_QWORD *)(v17 - 8) - 8) <= 0x1F )
    {
      v17 = *(_QWORD *)(v17 - 8);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A6590(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402ABF30 (0x1402ABF30) ---

// --- Function: sub_1402B3D30 (0x1402B3D30) ---
_QWORD *__fastcall sub_1402B3D30(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1482B6D28;
  return a1;
}

// --- End Function: sub_1402B3D30 (0x1402B3D30) ---

// --- Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B7250) ---
bool __fastcall std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B7250) ---

// --- Function: _InterlockedIncrement_w (0x1402BBAA0) ---
__int64 __fastcall sub_1402BBAA0(__int64 a1)
{
  return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 8));
}

// --- End Function: _InterlockedIncrement_w (0x1402BBAA0) ---

// --- Function: LogTraceConditional (0x1402C36D0) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( qword_149C8E0F8 && qword_149C8DFE0 )
  {
    if ( qword_149C8DFF0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149C8DFF0 + 8LL))(
        qword_149C8DFF0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C36D0) ---

// --- Function: NtCurrentTeb_w (0x1402C8AD0) ---
__int64 sub_1402C8AD0()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C8AD0) ---

// --- Function: rw_lock_release_read_lock (0x1402D4E60) ---
// Releases a read lock on a read-write lock. If the current thread is the
// recursive owner, it decrements the recursive count. Otherwise, it atomically
// decrements the main lock state. If the lock state transitions to indicate no
// more readers and pending write locks, it dispatches to a contention handler.
__int64 __fastcall rw_lock_release_read_lock(__int64 p_rw_lock_state)
{
  __int64 result; // rax
  unsigned __int64 current_lock_value; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(result + 0x18)
    && (result = *(unsigned int *)(p_rw_lock_state + 0x14), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(p_rw_lock_state + 0x14) = result;
  }
  else
  {
    current_lock_value = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (current_lock_value & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
        return rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, current_lock_value);
    }
  }
  return result;
}

// --- End Function: rw_lock_release_read_lock (0x1402D4E60) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E3660) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E3660) ---

// --- Function: sub_1402E3880 (0x1402E3880) ---
void __noreturn sub_1402E3880()
{
  stdext::exception *v0; // rax
  _BYTE v1[24]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B3D30(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E3880 (0x1402E3880) ---

// --- Function: unknown_libname_9 (0x1402E4680) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E4680) ---

// --- Function: unknown_libname_10 (0x1402E46A0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E46A0) ---

// --- Function: sub_1402E6080 (0x1402E6080) ---
__int64 __fastcall sub_1402E6080(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 v5; // rdi

  *(_QWORD *)a2 = a1;
  v2 = a1 + 0x18;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_QWORD *)(a2 + 8) = a1 + 0x18;
  *(_DWORD *)(a2 + 0x18) = 1;
  if ( *(_DWORD *)(a1 + 0x28) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v2 + 0x14);
    return a2;
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)v2);
    if ( (v5 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v2, v5, (const char *)&p_Src, (const char *)&p_Src, 1);
    return a2;
  }
}

// --- End Function: sub_1402E6080 (0x1402E6080) ---

// --- Function: sub_1402E6730 (0x1402E6730) ---
__int64 __fastcall sub_1402E6730(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  int v4; // esi
  __int64 v6; // r8
  unsigned __int64 v7; // rax

  *(_QWORD *)a2 = a1;
  v2 = a1 + 0x18;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_QWORD *)(a2 + 8) = a1 + 0x18;
  *(_DWORD *)(a2 + 0x18) = 1;
  v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v4 )
  {
    ++*(_DWORD *)(v2 + 0x14);
    return a2;
  }
  else
  {
    v6 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v7 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( v7 )
      sub_1403E1120(v2, v7, v6, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v2 + 8) = v6;
    *(_DWORD *)(v2 + 0x10) = v4;
    return a2;
  }
}

// --- End Function: sub_1402E6730 (0x1402E6730) ---

// --- Function: fprintf (0x1402F9B00) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F9B00) ---

// --- Function: sub_1402FD830 (0x1402FD830) ---
void *__fastcall sub_1402FD830(_QWORD *a1, const void *a2, size_t Size)
{
  __int64 n0x16; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n0x16 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 0xF;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_1402A65A0(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    v10[0xFFFFFFFF] = v9;
    goto LABEL_17;
  }
  n0x16 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n0x16 = 0x16;
  if ( (unsigned __int64)(n0x16 + 1) >= 0x1000 )
  {
    allocSize = n0x16 + 0x28;
    if ( n0x16 + 0x28 < (unsigned __int64)(n0x16 + 1) )
      sub_1402E3880();
    goto LABEL_6;
  }
  if ( n0x16 == 0xFFFFFFFFFFFFFFFFuLL )
    v10 = 0;
  else
    v10 = (_QWORD *)sub_1402A65A0(n0x16 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n0x16;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FD830 (0x1402FD830) ---

// --- Function: sub_1402FFA40 (0x1402FFA40) ---
__int64 __fastcall sub_1402FFA40(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  if ( a4 < a5 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(a3 + 0x70 * a4 + 0x18))(
             *(_QWORD *)(a3 + 0x70 * a4),
             a1,
             a2,
             a4 - a5 + 1);
  else
    return 0;
}

// --- End Function: sub_1402FFA40 (0x1402FFA40) ---

// --- Function: sub_1402FFA80 (0x1402FFA80) ---
__int64 __fastcall sub_1402FFA80(int a1, int a2, int a3, __int64 a4, __int64 a5)
{
  char v6; // [rsp+40h] [rbp-18h] BYREF

  return sub_140301DB0((unsigned int)&v6, a1, a2, a3, a4, a5);
}

// --- End Function: sub_1402FFA80 (0x1402FFA80) ---

// --- Function: sub_1402FFF10 (0x1402FFF10) ---
__int64 **__fastcall sub_1402FFF10(__int64 **a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v6; // rcx
  __int64 *v7; // rbx
  __int64 n0x28; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 *v12; // rbp
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r8
  __int64 *v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // r9
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  __int64 *v24; // rdx
  __int64 *v25; // r9
  __int64 v26; // rsi
  __int64 v27; // rdi
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r10
  __int64 v30; // rax
  bool v31; // zf
  __int64 *v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rsi
  unsigned __int64 v35; // rdi
  unsigned __int64 v36; // r11
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 **result; // rax

  v6 = a2;
  v7 = &a2[(__int64)(a3 - (_QWORD)a2) >> 4];
  n0x28 = (__int64)(a3 - 8 - (_QWORD)a2) >> 3;
  if ( n0x28 <= 0x28 )
  {
    v14 = a3 - 8;
  }
  else
  {
    v9 = (n0x28 + 1) >> 3;
    v10 = 0x10 * v9;
    v11 = 8 * v9;
    v12 = &a2[v9];
    sub_1402FFE90(a2, v12, &a2[2 * v9]);
    sub_1402FFE90(&v7[v11 / 0xFFFFFFFFFFFFFFF8uLL], v7, &v7[(unsigned __int64)v11 / 8]);
    sub_1402FFE90(a3 - 8 - v10, a3 - 8 - v11, a3 - 8);
    v14 = v13;
    v6 = v12;
  }
  sub_1402FFE90(v6, v7, v14);
  v15 = v7 + 1;
  if ( a2 < v7 )
  {
    v16 = *v7;
    do
    {
      v17 = v7[0xFFFFFFFF];
      v18 = *(_QWORD *)(v16 + 8);
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 < v18 || v19 == v18 && *(_QWORD *)(v17 + 0x50) < *(_QWORD *)(v16 + 0x50) )
        break;
      if ( v18 < v19 || v18 == v19 && *(_QWORD *)(v16 + 0x50) < *(_QWORD *)(v17 + 0x50) )
        break;
      v7 += 0xFFFFFFFF;
      v16 = v17;
    }
    while ( a2 < v7 );
  }
  if ( (unsigned __int64)v15 < a3 )
  {
    v20 = *v7;
    v21 = *(_QWORD *)(*v7 + 8);
    do
    {
      v22 = *v15;
      v23 = *(_QWORD *)(*v15 + 8);
      if ( v23 < v21 || v23 == v21 && *(_QWORD *)(v22 + 0x50) < *(_QWORD *)(v20 + 0x50) )
        break;
      if ( v21 < v23 || v21 == v23 && *(_QWORD *)(v20 + 0x50) < *(_QWORD *)(v22 + 0x50) )
        break;
      ++v15;
    }
    while ( (unsigned __int64)v15 < a3 );
  }
  v24 = v15;
  v25 = v7;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( (unsigned __int64)v24 < a3 )
      {
        v26 = *v24;
        v27 = *v7;
        v28 = *(_QWORD *)(*v24 + 8);
        v29 = *(_QWORD *)(*v7 + 8);
        if ( v29 >= v28 && (v29 != v28 || *(_QWORD *)(v27 + 0x50) >= *(_QWORD *)(v26 + 0x50)) )
        {
          if ( v28 < v29 || v28 == v29 && *(_QWORD *)(v26 + 0x50) < *(_QWORD *)(v27 + 0x50) )
            break;
          if ( v15 != v24 )
          {
            v30 = *v15;
            *v15 = v26;
            *v24 = v30;
          }
          ++v15;
        }
        ++v24;
      }
      v31 = v25 == a2;
      if ( v25 <= a2 )
        goto LABEL_46;
      v32 = v25 + 0xFFFFFFFF;
      while ( 1 )
      {
        v33 = *v7;
        v34 = *v32;
        v35 = *(_QWORD *)(*v7 + 8);
        v36 = *(_QWORD *)(*v32 + 8);
        if ( v36 >= v35 && (v36 != v35 || *(_QWORD *)(v34 + 0x50) >= *(_QWORD *)(v33 + 0x50)) )
          break;
LABEL_44:
        v25 += 0xFFFFFFFF;
        v32 += 0xFFFFFFFF;
        if ( a2 >= v25 )
          goto LABEL_45;
      }
      if ( v35 >= v36 && (v35 != v36 || *(_QWORD *)(v33 + 0x50) >= *(_QWORD *)(v34 + 0x50)) )
      {
        v7 += 0xFFFFFFFF;
        if ( v7 != v32 )
        {
          v37 = *v7;
          *v7 = v34;
          *v32 = v37;
        }
        goto LABEL_44;
      }
LABEL_45:
      v31 = v25 == a2;
LABEL_46:
      if ( !v31 )
      {
        v25 += 0xFFFFFFFF;
        if ( v24 == (__int64 *)a3 )
        {
          v7 += 0xFFFFFFFF;
          if ( v25 != v7 )
          {
            v40 = *v25;
            *v25 = *v7;
            *v7 = v40;
          }
          v41 = v15[0xFFFFFFFF];
          v15 += 0xFFFFFFFF;
          v42 = *v7;
          *v7 = v41;
          *v15 = v42;
        }
        else
        {
          v43 = *v24;
          *v24++ = *v25;
          *v25 = v43;
        }
        continue;
      }
      break;
    }
    if ( v24 != (__int64 *)a3 )
    {
      if ( v15 != v24 )
      {
        v38 = *v7;
        *v7 = *v15;
        *v15 = v38;
      }
      ++v15;
      v39 = *v7;
      *v7++ = *v24;
      *v24++ = v39;
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v7;
  a1[1] = v15;
  return result;
}

// --- End Function: sub_1402FFF10 (0x1402FFF10) ---

// --- Function: sub_1403001D0 (0x1403001D0) ---
unsigned __int64 __fastcall sub_1403001D0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rdi
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r11
  __int64 v11; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 n2; // rax
  unsigned __int64 v15; // r11
  __int64 v16; // rcx
  __int64 v17; // r8
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v10 = 2 * v9;
      v11 = *(_QWORD *)(a1 + 0x10 * v9 + 0x10);
      v12 = *(_QWORD *)(a1 + 0x10 * v9 + 8);
      v13 = *(_QWORD *)(v11 + 8);
      if ( v13 < *(_QWORD *)(v12 + 8)
        || v13 == *(_QWORD *)(v12 + 8) && *(_QWORD *)(v11 + 0x50) < *(_QWORD *)(v12 + 0x50) )
      {
        n2 = 1;
      }
      else
      {
        n2 = 2;
      }
      v9 = v10 + n2;
      *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * (v10 + n2));
      a2 = v10 + n2;
    }
    while ( v10 + n2 < v5 );
  }
  if ( v9 == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v8 >= a2 )
  {
    result = *a4;
    *(_QWORD *)(a1 + 8 * a2) = *a4;
  }
  else
  {
    while ( 1 )
    {
      v15 = *a4;
      v16 = (a2 - 1) >> 1;
      v17 = *(_QWORD *)(a1 + 8 * v16);
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(*a4 + 8) )
      {
        if ( result != *(_QWORD *)(*a4 + 8) )
          break;
        result = *(_QWORD *)(v15 + 0x50);
        if ( *(_QWORD *)(v17 + 0x50) >= result )
          break;
      }
      *(_QWORD *)(a1 + 8 * a2) = v17;
      a2 = (a2 - 1) >> 1;
      if ( v8 >= v16 )
      {
        result = *a4;
        *(_QWORD *)(a1 + 8 * v16) = *a4;
        return result;
      }
    }
    *(_QWORD *)(a1 + 8 * a2) = v15;
  }
  return result;
}

// --- End Function: sub_1403001D0 (0x1403001D0) ---

// --- Function: sub_1403002C0 (0x1403002C0) ---
unsigned __int64 __fastcall sub_1403002C0(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4924924924924925LL) >> 0x40) >> 0x3F;
  v7 = ((__int64)v2 - *a1) / 0x70;
  if ( a2 < v7 )
  {
    v8 = v4 + 0x70 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 0x70 )
    {
      if ( *(_BYTE *)(i + 0x58) )
      {
        if ( *(_QWORD *)i )
          result = (*(__int64 (**)(void))(i + 0x40))();
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
    return result;
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4924924924924925LL) >> 0x40) >> 0x3F;
  v11 = v10 / 0x70;
  if ( a2 > v10 / 0x70 )
  {
    if ( a2 > 0x249249249249249LL )
      unknown_libname_10();
    v12 = v11 >> 1;
    if ( v11 <= 0x249249249249249LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x249249249249249LL )
          goto LABEL_29;
      }
      else
      {
        v13 = a2;
      }
      allocSize = 0x70 * v13;
      if ( 0x70 * v13 < 0x1000 )
      {
        if ( allocSize )
          v16 = sub_1402A65A0(allocSize);
        else
          v16 = 0;
LABEL_23:
        v17 = (_QWORD *)(v16 + 0x70 * v7);
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 0xE;
            --v18;
          }
          while ( v18 );
        }
        sub_1403009C0(*a1, a1[1], v16, a1);
        return sub_140302220(a1, v16, a2, v13);
      }
      if ( allocSize + 0x27 >= allocSize )
      {
        v15 = sub_1402A65A0(allocSize + 0x27);
        if ( !v15 )
          invalid_parameter_noinfo_noreturn();
        v16 = (v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
        *(_QWORD *)(v16 - 8) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402E3880();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 0xE;
  }
  a1[1] = v2;
  return result;
}

// --- End Function: sub_1403002C0 (0x1403002C0) ---

// --- Function: sub_1403005F0 (0x1403005F0) ---
__int64 __fastcall sub_1403005F0(char *a1, char *a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n0x100; // rax
  char *v7; // r15
  char *v8; // rdi
  char *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  char *v30; // rsi
  int v31; // [rsp+20h] [rbp-48h]
  char *v32; // [rsp+30h] [rbp-38h] BYREF
  char *v33; // [rsp+38h] [rbp-30h]
  __int64 v34; // [rsp+70h] [rbp+8h] BYREF

  n0x100 = (a2 - a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( v8 != v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 0x50) < *(_QWORD *)(*(_QWORD *)v8 + 0x50LL) )
          {
            n0x100 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i + 0xFFFFFFFF);
              i += 0xFFFFFFF8;
              n0x100 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n0x100 )
              {
                if ( *(_QWORD *)(v14 + 8) != n0x100 )
                  break;
                n0x100 = *(_QWORD *)(v17 + 0x50);
                if ( *(_QWORD *)(v14 + 0x50) >= (unsigned __int64)n0x100 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FFF10(&v32, v8, v7, a4);
      v9 = v32;
      v10 = v33;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((v32 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - v33) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1403005F0(v33, v7, a3, a4);
        v7 = v9;
      }
      else
      {
        sub_1403005F0(v8, v32, a3, a4);
        v8 = v10;
      }
      n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    v18 = (v7 - v8) >> 3;
    v19 = (v7 - v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 0x50) < *(_QWORD *)(v25 + 0x50) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 0x50) >= *(_QWORD *)(v21 + 0x50)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v30 = v7 + 0xFFFFFFF8;
      do
      {
        v34 = *(_QWORD *)v30;
        *(_QWORD *)v30 = *(_QWORD *)v8;
        LOBYTE(v31) = a4;
        sub_1403001D0(v8, 0, (v30 - v8) >> 3, &v34, v31);
        v30 += 0xFFFFFFF8;
        n0x100 = (unsigned __int64)&v30[8LL - (_QWORD)v8] & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n0x100 >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_1403005F0 (0x1403005F0) ---

// --- Function: sub_140300DE0 (0x140300DE0) ---
__int64 __fastcall sub_140300DE0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
      return 0xFFFFFFFFLL;
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAu;
    *(_BYTE *)(v6 + v5) = v9 + 0x30;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_140300DE0 (0x140300DE0) ---

// --- Function: sub_140300EA0 (0x140300EA0) ---
__int64 __fastcall sub_140300EA0(
        double *Buffer,
        size_t Size,
        __int64 a3,
        const void **a4,
        const void **a5,
        __int64 a6,
        char *p_])
{
  _BYTE *v7; // rdi
  size_t Size_1; // rbx
  char *v12; // rcx
  size_t Size_2; // rsi
  size_t Size_3; // rdi
  __int64 v15; // r14
  _BYTE *v16; // rsi
  char *v17; // rcx
  size_t Size_4; // rbp
  int v19; // eax
  int v20; // ecx
  __int64 result; // rax

  v7 = *a4;
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_1;
  while ( v7[Size_1] );
  if ( Size_1 + a3 >= Size )
    return 0xFFFFFFFFLL;
  v12 = (char *)Buffer + a3;
  Size_2 = Size - a3;
  if ( Size_1 )
  {
    if ( !v12 )
    {
LABEL_6:
      *errno() = 0x16;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v7 && Size_2 >= Size_1 )
    {
      memcpy(v12, *a4, Size_1);
    }
    else
    {
      memset(v12, 0, Size - a3);
      if ( !v7 )
        goto LABEL_6;
      if ( Size_2 < Size_1 )
      {
        *errno() = 0x22;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size_1 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  v15 = a3 + (int)Size_1;
  v16 = *a5;
  do
    ++Size_3;
  while ( v16[Size_3] );
  if ( Size_3 + v15 >= Size )
    return 0xFFFFFFFFLL;
  v17 = (char *)Buffer + v15;
  Size_4 = Size - v15;
  if ( !Size_3 )
    goto LABEL_28;
  if ( !v17 )
    goto LABEL_20;
  if ( v16 && Size_4 >= Size_3 )
  {
    memcpy(v17, *a5, Size_3);
  }
  else
  {
    memset(v17, 0, Size - v15);
    if ( !v16 )
    {
LABEL_20:
      *errno() = 0x16;
LABEL_27:
      invalid_parameter_noinfo();
      goto LABEL_28;
    }
    if ( Size_4 < Size_3 )
    {
      *errno() = 0x22;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( (Size_3 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v19 = sub_140301050(Buffer, Size, (int)v15 + (int)Size_3, a6, p_]);
  if ( v19 < 0 )
    return 0xFFFFFFFFLL;
  v20 = Size_3 + v19;
  result = (unsigned int)(Size_1 + Size_3 + v19);
  if ( v20 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_140300EA0 (0x140300EA0) ---

// --- Function: sub_140301050 (0x140301050) ---
__int64 __fastcall sub_140301050(double *Buffer, unsigned __int64 n0xF, __int64 a3, const void **a4, char *_)
{
  _BYTE *v5; // rsi
  size_t Size; // rbx
  char *v10; // rcx
  size_t Size_1; // rbp
  __int64 v12; // rcx
  size_t Size_2; // rdi
  _BYTE *v14; // rcx

  v5 = *a4;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( v5[Size] );
  if ( Size + a3 >= n0xF )
    return 0xFFFFFFFFLL;
  v10 = (char *)Buffer + a3;
  Size_1 = n0xF - a3;
  if ( !Size )
    goto LABEL_14;
  if ( !v10 )
    goto LABEL_6;
  if ( v5 && Size_1 >= Size )
  {
    memcpy(v10, v5, Size);
  }
  else
  {
    memset(v10, 0, n0xF - a3);
    if ( !v5 )
    {
LABEL_6:
      *errno() = 0x16;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( Size_1 < Size )
    {
      *errno() = 0x22;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v12 = a3 + (int)Size;
  if ( v12 + 1 >= n0xF )
    return 0xFFFFFFFFLL;
  Size_2 = n0xF - v12;
  v14 = (char *)Buffer + v12;
  if ( !v14 )
  {
LABEL_17:
    *errno() = 0x16;
    invalid_parameter_noinfo();
    return (unsigned int)(Size + 1);
  }
  if ( _ && Size_2 )
  {
    *v14 = *_;
    return (unsigned int)(Size + 1);
  }
  else
  {
    memset(v14, 0, Size_2);
    if ( !_ )
      goto LABEL_17;
    if ( !Size_2 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(Size + 1);
  }
}

// --- End Function: sub_140301050 (0x140301050) ---

// --- Function: sub_1403011A0 (0x1403011A0) ---
__int64 __fastcall sub_1403011A0(double *Buffer, unsigned __int64 n0xF, __int64 a3, __int64 p____EVT_COUNT__:, int *a5)
{
  unsigned __int64 n0xD; // rdi
  char *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r10
  int v13; // ecx
  int v14; // r9d
  __int64 v15; // rdi
  __int64 i; // r8
  __int64 v17; // r11
  int v18; // eax
  char *v19; // r8
  char *v20; // rax
  __int64 v21; // r10
  char v22; // cl
  char v23; // dl
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v10 = (char *)Buffer + a3;
  if ( !v10 )
    goto LABEL_3;
  if ( p____EVT_COUNT__: && n0xD >= 0xD )
  {
    *(double *)v10 = *(double *)p____EVT_COUNT__:;
    *((_DWORD *)v10 + 2) = *(_DWORD *)(p____EVT_COUNT__: + 8);
    v10[0xC] = *(_BYTE *)(p____EVT_COUNT__: + 0xC);
    goto LABEL_11;
  }
  memset(v10, 0, n0xF - a3);
  if ( p____EVT_COUNT__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v11 = n0xF - (a3 + 0xD);
  v12 = (__int64)Buffer + a3 + 0xD;
  v13 = *a5;
  if ( *a5 >= 0 )
  {
    v14 = 0;
  }
  else if ( v11 )
  {
    *(_BYTE *)v12 = 0x2D;
    v13 = -v13 & 0x7FFFFFFF;
    v14 = 1;
  }
  else
  {
    v14 = 0xFFFFFFFF;
  }
  v15 = v14;
  for ( i = v14; ; ++i )
  {
    v17 = v14;
    if ( v14 >= (int)v11 || i < 0 )
      break;
    ++v14;
    v18 = v13 % 0xA;
    v13 /= 0xA;
    *(_BYTE *)(i + v12) = v18 + 0x30;
    if ( !v13 )
    {
      if ( v15 < v17 )
      {
        v19 = (char *)(v17 + v12);
        v20 = (char *)(v15 + v12);
        v21 = -v12;
        do
        {
          v22 = *v19--;
          v23 = *v20;
          *v20++ = v22;
          v19[1] = v23;
        }
        while ( (__int64)&v20[v21] < (__int64)&v19[v21] );
      }
      result = (unsigned int)(v14 + 0xD);
      if ( v14 >= 0 )
        return result;
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1403011A0 (0x1403011A0) ---

// --- Function: sub_140301320 (0x140301320) ---
__int64 __fastcall sub_140301320(
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a3,
        __int64 p____@severity__:,
        __int64 *p_n0xF,
        char *___severity__:_,
        __int64 a7,
        char *p______tags__:[)
{
  int n0xF_1; // ebp
  unsigned __int64 n0xD; // rbx
  char *v13; // rcx
  int v14; // ebx
  __int64 v15; // rsi
  __int64 v16; // rcx
  unsigned int n0xF_2; // r9d
  __int64 v18; // r8
  __int64 v19; // r11
  unsigned int v20; // eax
  char *v21; // rdx
  __int64 v22; // r9
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  __int64 result; // rax

  n0xF_1 = n0xF;
  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v13 = (char *)Buffer + a3;
  if ( !v13 )
    goto LABEL_3;
  if ( p____@severity__: && n0xD >= 0xD )
  {
    *(double *)v13 = *(double *)p____@severity__:;
    *((_DWORD *)v13 + 2) = *(_DWORD *)(p____@severity__: + 8);
    v13[0xC] = *(_BYTE *)(p____@severity__: + 0xC);
    goto LABEL_11;
  }
  memset(v13, 0, n0xF - a3);
  if ( p____@severity__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v14 = 0;
  v15 = a3 + 0xD;
  v16 = 0;
  n0xF_2 = *(_DWORD *)p_n0xF;
  v18 = (__int64)Buffer + v15;
  while ( 1 )
  {
    v19 = v14;
    if ( v14 >= n0xF_1 - (int)v15 || v16 < 0 )
      break;
    ++v14;
    v20 = n0xF_2 % 0xA;
    n0xF_2 /= 0xAu;
    *(_BYTE *)(v16 + v18) = v20 + 0x30;
    ++v16;
    if ( !n0xF_2 )
    {
      if ( (int)v19 > 0 )
      {
        v21 = (char *)(v19 + v18);
        v22 = -v18;
        do
        {
          v23 = *v21--;
          v24 = *(_BYTE *)v18;
          *(_BYTE *)v18++ = v23;
          v21[1] = v24;
        }
        while ( v22 + v18 < (__int64)&v21[v22] );
      }
      if ( v14 >= 0 )
      {
        v25 = sub_1403014C0(
                (_DWORD)Buffer,
                n0xF_1,
                (int)v15 + v14,
                (_DWORD)___severity__:_,
                a7,
                (__int64)p______tags__:[);
        if ( v25 >= 0 )
        {
          v26 = v14 + v25;
          result = (unsigned int)(v14 + v25 + 0xD);
          if ( v26 < 0 )
            return 0xFFFFFFFFLL;
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_140301320 (0x140301320) ---

// --- Function: sub_140301AF0 (0x140301AF0) ---
_QWORD *__fastcall sub_140301AF0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __int64 p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __int64 p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)sub_1402A65A0(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)sub_1402A65A0(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    memset(&Src, 0, sizeof(Src));
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FD830(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402ABF30((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(_QWORD *)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = (__m256 *)p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = sub_1402A65A0(0x30u);
      *(_QWORD *)(v23 + 0x20) = 0;
      *(_QWORD *)(v23 + 0x28) = 0;
      *(__m256 *)(v23 + 0x10) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 0xF;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x10LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x28LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(_QWORD *)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
        if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A6590(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140301AF0 (0x140301AF0) ---

// --- Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x140302090) ---
void __fastcall std::vector<vraudio::AudioBuffer const *>::_Change_array(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  __int64 v6; // rcx

  v6 = *(_QWORD *)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_1402A6590(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x140302090) ---

// --- Function: sub_1403023E0 (0x1403023E0) ---
bool __fastcall sub_1403023E0(__int64 a1, _QWORD *a2, __int64 *a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  __int64 __Val_0___1; // r10
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // bp
  __int64 v18; // rdi
  __int64 v19; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v21; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v23; // rdi
  unsigned __int64 v24; // r9
  char v25; // al
  __int64 v26; // r8
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rax
  unsigned __int64 v30; // [rsp+20h] [rbp-48h]
  bool v32; // [rsp+80h] [rbp+18h]

  v7 = sub_1403031E0(*((unsigned int *)a3 + 9), a2, a3[3], a1);
  if ( v9 + v7 > v10 )
    return 0;
  v13 = *((unsigned int *)a3 + 8);
  v17 = 0;
  if ( (_DWORD)v13 != 1 )
  {
    v14 = sub_1403031E0(v13, v8, v9, v10);
    if ( v15 + v14 < v16 )
      v17 = 1;
  }
  v18 = a3[1];
  v19 = *a3;
  v32 = v17;
  if ( (v18 - *a3) / 0x70 != _Newcapacity )
  {
    if ( v19 != v18 )
    {
      do
      {
        if ( *(_BYTE *)(v19 + 0x58) && *(_QWORD *)v19 )
          (*(void (**)(void))(v19 + 0x40))();
        v19 += 0x70;
      }
      while ( v19 != v18 );
      a3[1] = *a3;
    }
    sub_1403002C0(a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v17 = 1;
    v32 = 1;
  }
  _Newcapacity_2 = 0;
  v21 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v23 = __Val_0___1 + 0x30;
    v24 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v30 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v17 )
    {
      v21 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v23 + 0x18)
        && *(_QWORD *)v23 )
      {
        if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_1 )
          __debugbreak();
        v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v23)(*(_QWORD *)(v23 - 0x30), *(_QWORD *)(v24 + v23 + *a3));
        v24 = v30;
        v17 = v25 == 0;
        v32 = v25 == 0;
      }
      ++_Newcapacity_1;
      v23 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v17 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v27 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v21 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v27 + 0x38)
          && *(_QWORD *)(v27 + 0x20) )
        {
          if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_2 )
            __debugbreak();
          v28 = v27 + v26 + *a3;
          if ( *(_BYTE *)(v28 + 0x58) )
          {
            if ( *(_QWORD *)v28 )
              (*(void (**)(void))(v28 + 0x40))();
          }
          v29 = (*(__int64 (__fastcall **)(_QWORD))(v27 + 0x38))(*(_QWORD *)(v27 - 0x10));
          v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v28 = v29;
          *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 - 8);
          *(_QWORD *)(v28 + 0x10) = *(_QWORD *)v27;
          *(_QWORD *)(v28 + 0x18) = *(_QWORD *)(v27 + 8);
          *(_QWORD *)(v28 + 0x20) = *(_QWORD *)(v27 + 0x10);
          *(_QWORD *)(v28 + 0x30) = *(_QWORD *)(v27 + 0x20);
          *(_QWORD *)(v28 + 0x28) = *(_QWORD *)(v27 + 0x18);
          *(_QWORD *)(v28 + 0x38) = *(_QWORD *)(v27 + 0x28);
          *(_QWORD *)(v28 + 0x40) = *(_QWORD *)(v27 + 0x30);
          *(_QWORD *)(v28 + 0x48) = *(_QWORD *)(v27 + 0x38);
          *(_QWORD *)(v28 + 0x50) = *(_QWORD *)(v27 + 0x40);
          *(_QWORD *)(v28 + 0x60) = *(_QWORD *)(v27 + 0x50);
          *(_QWORD *)(v28 + 0x68) = *(_QWORD *)(v27 + 0x58);
          *(_BYTE *)(v28 + 0x58) = 1;
          *(_BYTE *)(v28 + 0x59) = *(_BYTE *)(v27 + 0x49);
        }
        ++_Newcapacity_2;
        v27 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v17 = v32;
    }
    a3[3] = a1;
  }
  return v17;
}

// --- End Function: sub_1403023E0 (0x1403023E0) ---

// --- Function: sub_1403030E0 (0x1403030E0) ---
__int64 __fastcall sub_1403030E0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", v3 - 0x3E8 * v7) + 0x13);
}

// --- End Function: sub_1403030E0 (0x1403030E0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1403031A0) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149C78D00 )
    result = qword_149C78D00(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149C78D18 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149C78D20 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1403031A0) ---

// --- Function: sub_1403031E0 (0x1403031E0) ---
__int64 __fastcall sub_1403031E0(int a1)
{
  __int64 n0x3E8; // rax

  switch ( a1 )
  {
    case 2:
      n0x3E8 = 0x3E8;
      break;
    case 3:
      n0x3E8 = 0x1388;
      break;
    case 4:
      n0x3E8 = 0x3A98;
      break;
    case 5:
      n0x3E8 = 0x7530;
      break;
    case 6:
      n0x3E8 = 0xEA60;
      break;
    case 7:
      n0x3E8 = 0x493E0;
      break;
    case 8:
      n0x3E8 = 0xDBBA0;
      break;
    case 9:
      n0x3E8 = 0x1B7740;
      break;
    default:
      n0x3E8 = 0;
      break;
  }
  return n0x3E8;
}

// --- End Function: sub_1403031E0 (0x1403031E0) ---

// --- Function: sub_1403032F0 (0x1403032F0) ---
__int64 __fastcall sub_1403032F0(_WORD *a1, int a2, char a3)
{
  unsigned int n2_1; // r10d
  __int64 n2; // rax

  n2_1 = 0;
  switch ( a3 )
  {
    case 8:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x625C;
      n2 = 2;
      break;
    case 9:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x745C;
      n2 = 2;
      break;
    case 0xA:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x6E5C;
      n2 = 2;
      break;
    case 0xC:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x665C;
      n2 = 2;
      break;
    case 0xD:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x725C;
      n2 = 2;
      break;
    case 0x22:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x225C;
      n2 = 2;
      break;
    case 0x5C:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x5C5C;
      n2 = 2;
      break;
    default:
      if ( a2 > 0 )
      {
        *(_BYTE *)a1 = a3;
        n2_1 = 1;
      }
LABEL_18:
      n2 = n2_1;
      break;
  }
  return n2;
}

// --- End Function: sub_1403032F0 (0x1403032F0) ---

// --- Function: sub_140303440 (0x140303440) ---
__int64 __fastcall sub_140303440(_BYTE *a1, int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // r10
  int v8; // edx
  int v9; // ebp
  unsigned __int64 i; // rbx
  int v11; // r11d
  int v12; // r9d
  _WORD *v13; // r8
  __int64 v14; // rax
  unsigned int v15; // edx

  v4 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v4;
  while ( *(_BYTE *)(a3 + v4) );
  v8 = 0;
  v9 = 0;
  if ( a4 )
  {
    if ( a2 <= 0 )
    {
      v9 = 1;
    }
    else
    {
      *a1 = 0x22;
      v8 = 1;
    }
  }
  for ( i = 0; i < v4; ++i )
  {
    if ( v8 >= a2 )
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = a2 - v8;
      v13 = &a1[v8];
      switch ( *(_BYTE *)(i + a3) )
      {
        case 8:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x625C;
          v8 += 2;
          break;
        case 9:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x745C;
          v8 += 2;
          break;
        case 0xA:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x6E5C;
          v8 += 2;
          break;
        case 0xC:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x665C;
          v8 += 2;
          break;
        case 0xD:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x725C;
          v8 += 2;
          break;
        case 0x22:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x225C;
          v8 += 2;
          break;
        case 0x5C:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x5C5C;
          v8 += 2;
          break;
        default:
          if ( v12 > 0 )
          {
            *(_BYTE *)v13 = *(_BYTE *)(i + a3);
            v11 = 1;
          }
LABEL_26:
          v8 += v11;
          break;
      }
    }
  }
  if ( a4 )
  {
    if ( v8 < a2 )
    {
      v14 = v8;
      v15 = v8 + 1;
      if ( v9 )
        v15 = 0xFFFFFFFF;
      a1[v14] = 0x22;
      return v15;
    }
    v9 = 1;
  }
  if ( v9 )
    return 0xFFFFFFFF;
  return (unsigned int)v8;
}

// --- End Function: sub_140303440 (0x140303440) ---

// --- Function: sub_140304A70 (0x140304A70) ---
__int64 __fastcall sub_140304A70(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        __int64 a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  __int64 v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  unsigned int v87[2]; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149A5E708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149A5E720[0];
  }
  else
  {
    v17 = off_149A5E728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149A5E738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149A5E710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149A5E710 )
      {
        memcpy(Buffer, off_149A5E710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_140300EA0((double *)Buffer, Size, (int)Size_1 + 1LL, (const void **)v87, v21, (__int64)&off_149A5E710, "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149A5E710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149A5E710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149A5E710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149A5E710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149A5E730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149A5E730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149A5E730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149A5E730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149A5E710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  *(_QWORD *)v87 = v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149A5E710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149A5E710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149A5E710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = *(_QWORD *)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = v45 + 2;
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( Size_11 + v48 >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[v48];
  Size_12 = Size - v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140307B30(
          (_DWORD)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64)sub_1402FFA40);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149A5E710;
      *(_QWORD *)v87 = qword_149C789B0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149A5E710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_140300EA0(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149A5E718,
                        (const void **)(*(_QWORD *)v87 + Sizec),
                        (__int64)&off_149A5E710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149A5E710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149A5E710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149C78D18(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140304A70 (0x140304A70) ---

// --- Function: sub_140305570 (0x140305570) ---
__int64 __fastcall sub_140305570(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        char *a7,
        __int64 a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        __int64 a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_27; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  int n0xF_8; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  int n0xF_10; // ebp
  int n0xF_11; // r14d
  int n0xF_12; // r15d
  int n0xF_13; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_14; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_15; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_16; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_17; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_23; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_19; // edx
  int n0xF_20; // ecx
  bool v109; // r15
  int n0xF_21; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_24; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_25; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_26; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  __int64 *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  int n0xF_9; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  int n0xF_18; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_22; // [rsp+98h] [rbp-D0h]
  __int64 n0xF_5; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  __int64 v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, __int64, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 0x80;
  LODWORD(n0xF_5) = n4;
  v159 = a6;
  n0xF_22 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_27 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_140300DE0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_27 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_27;
  if ( n0xF_27 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_27 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149C78D28 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149C78D28(
              v162,
              v161,
              n4_1,
              v166,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149C78D20;
  v156 = v50;
  v51 = (a18 & 1) != 0 && ::n2 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_0 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149C78CF8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_9 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_95;
    }
    v53 = qword_149C78CF8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149C78CF8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_9 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_9 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_8 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_140301320(
            Buffer,
            n0xF_3,
            n0xF_2,
            (__int64)",\"@severity\":",
            &n0xF_5,
            ",\"severity\":\"",
            (__int64)&off_149A5E738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    LODWORD(n0xF_5) = n0xF_8;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149C789B0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_22 )
    {
LABEL_129:
      n0xF_3 = n0xF + 0x80;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_8 = n0xF_5;
      v62 = v160;
      v58 = v159;
      goto LABEL_131;
    }
    Size_7 = n0xF_22 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_22 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 0x22;
      }
      else
      {
LABEL_111:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_22 )
      goto LABEL_130;
    n2 = n0xF_22 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_8 = n0xF_5;
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_9 = n0xF_8;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149C789B0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_140301050(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_10 = n0xF_8;
    n0xF_11 = n0xF_6;
    v47 = 1;
    n0xF_12 = n0xF_2;
    n0xF_13 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_9 = n0xF_8;
LABEL_145:
  n0xF_10 = n0xF_8;
  n0xF_11 = n0xF_6;
  n0xF_12 = n0xF_2;
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_13;
      n0xF_9 = n0xF_8;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_9 = n0xF_10;
    n0xF_2 = n0xF_12 + 0xB;
    n0xF_6 = n0xF_11;
    n0xF_8 = n0xF_10;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_1403032F0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_14 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_14 = n0xF_2;
        n0xF_2 = n0xF_14;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_9 = n0xF_8;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_9 = n0xF_8;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_1403032F0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_15 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_15 = n0xF_2;
        n0xF_2 = n0xF_15;
      }
    }
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_209:
  n0xF_16 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140307B30((_DWORD)Buffer, n0xF, n0xF_2, v164, __Val_0___1, _Newcapacity, a11, 1, (__int64)sub_1402FFA80);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_16;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_17 = n0xF_29;
  v102 = 0;
  n0xF_5 = 0;
  v103 = 0;
  n0xF_23 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_23);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_8 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_18 = n0xF_8;
              n0xF_19 = n0xF_2;
              n0xF_20 = n0xF_8;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_21 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_19 = n0xF_2;
            n0xF_18 = n0xF_8;
            n0xF_20 = n0xF_8;
            n0xF_21 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_8 )
            {
LABEL_248:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_22 )
              {
                v105 = v160;
                n0xF_8 = n0xF_20;
                n0xF_2 = n0xF_19;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_255;
              }
              if ( n0xF_22 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 0x16;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_8 = n0xF_18;
                n0xF_2 = n0xF_21;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_8 = n0xF_18;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_21;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_21;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_8 && n0xF_2 + 1LL < n0xF_22 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_292;
                }
                if ( n0xF_22 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_23 = n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_8 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_20 = n0xF_8;
          n0xF_18 = n0xF_8;
          v47 = 1;
          n0xF_19 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_21 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_23 >= n0xF_17 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_24 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_24 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_25 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_25;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_8 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_22 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_22 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_315:
      n0xF_17 = n0xF_29;
      if ( (n0xF_23 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_17 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      n0xF_5 = ++n0xF_23;
      if ( n0xF_23 >= n0xF_17 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( (int)a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_8 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_8 )
  {
    v137 = sub_1403011A0(Buffer, n0xF_3, n0xF_2, (__int64)",\"EVT_COUNT\":", (int *)&a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149C78D30 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149C78D30(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_26 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_26 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (__int64 *)n0xF_26;
    v147 = v161;
    qword_149C78D20(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140305570 (0x140305570) ---

// --- Function: sub_140306C00 (0x140306C00) ---
void __fastcall sub_140306C00(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)sub_1402A65A0(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E3880();
      v8 = sub_1402A65A0(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_140306C00 (0x140306C00) ---

// --- Function: sub_140306CF0 (0x140306CF0) ---
char __fastcall sub_140306CF0(
        int n4_1,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 __Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // r14
  char result; // al
  unsigned __int64 n0x10; // rax
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v17; // r13
  char *v18; // r15
  __int64 v19; // r14
  const vraudio::AudioBuffer *__Val_0___2; // rdi
  unsigned __int8 v21; // si
  const vraudio::AudioBuffer *__Val_0___5; // r15
  __int64 *v23; // rax
  __int64 *v24; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v26; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v30; // r13
  __int64 (__fastcall *v31)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v32; // rax
  unsigned __int64 v33; // rcx
  __int64 *v34; // rdi
  _QWORD *v35; // r13
  bool v36; // zf
  _QWORD *v37; // rbx
  _QWORD *v38; // rax
  _BYTE *v39; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v42; // r9
  __int64 v43; // rcx
  __m256 *p_Src; // r14
  char *v45; // r14
  const vraudio::AudioBuffer *__Val_0___4; // r12
  unsigned __int64 n0xF; // r13
  __int64 p_Src_2; // r15
  _QWORD *v49; // r14
  _QWORD *v50; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v55; // rax
  __int64 *v56; // rcx
  __int64 v57; // rcx
  _QWORD *v58; // rbx
  __int64 v59; // rcx
  __int64 *v60; // r14
  __int64 p_Src_3; // rax
  __int64 *v62; // rax
  unsigned __int64 n0x400_3; // r15
  __int64 v64; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v68; // rax
  char *v69; // r11
  __int64 v70; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v72; // rdi
  int v73; // r13d
  __int64 v74; // rcx
  __int64 v75; // r9
  unsigned __int64 n0x400_4; // r8
  __int64 v77; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v82; // rax
  __int64 v83; // r15
  char *v84; // r14
  __int64 v85; // rax
  void *v86; // rsp
  __int64 (__fastcall *v87)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v88; // edx
  int v89; // r12d
  char v90; // cl
  int v91; // eax
  FILE *File; // rax
  int n2; // r8d
  FILE *File_1; // rax
  char v95; // al
  bool v96; // dl
  bool v97; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v99; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v104; // rax
  void *v105; // rsp
  char v106; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v109; // rsi
  _QWORD **v110; // rcx
  _QWORD *v111; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v113; // rdi
  __int64 v114; // rcx
  __int64 *v115; // rbx
  __int64 v116; // rcx
  int v117; // [rsp+90h] [rbp-10h]
  unsigned __int8 v118; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0x400_2; // [rsp+A8h] [rbp+8h]
  __int64 *v120; // [rsp+B0h] [rbp+10h]
  __int64 v121; // [rsp+B8h] [rbp+18h]
  int n4; // [rsp+C0h] [rbp+20h]
  __int64 v123; // [rsp+C8h] [rbp+28h] BYREF
  unsigned __int64 v124; // [rsp+D0h] [rbp+30h]
  char *v125; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  __int64 __Val_0___7; // [rsp+F0h] [rbp+50h]
  int v129[2]; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0__; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v131; // [rsp+108h] [rbp+68h] BYREF
  __int64 __Val_0___3; // [rsp+110h] [rbp+70h]
  __int64 v133; // [rsp+118h] [rbp+78h]
  void *v134; // [rsp+120h] [rbp+80h]
  __int64 v135; // [rsp+128h] [rbp+88h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+130h] [rbp+90h]
  _QWORD *v137; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___1; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v142; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v143; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v144; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v147[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v148[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v133 = a4;
  v134 = a3;
  v135 = a2;
  n4 = n4_1;
  __Val_0___7 = __Val_0___8;
  if ( qword_149C78C98 )
  {
    v12 = qword_149C78C98();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  *(_QWORD *)v129 = v12;
  if ( v11 )
  {
    result = sub_1403023E0(v12, v10, v11, __Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_149C78CF0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149C78CF0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149C78D60++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403030E0(Buffer, 0x20u, v12);
  v143 = (__int64 *)&v142;
  n0x10 = 0;
  v142 = 0;
  v15 = 0;
  v120 = 0;
  n0x400 = 0;
  n0x400_2 = 0;
  v17 = 0;
  v121 = 0;
  v18 = 0;
  n0x10_1 = 0;
  v19 = 0;
  v125 = 0;
  v123 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v72 = (char *)v148;
    goto LABEL_106;
  }
  __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___7;
  v21 = v118;
  __Val_0___3 = __Val_0___7;
  while ( 2 )
  {
    __Val_0___5 = __Val_0___2;
    if ( *((_BYTE *)__Val_0___2 + 0x59) && n0x10 < 0x10 )
    {
      v147[n0x10++] = __Val_0___2;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0__ = (unsigned __int64)__Val_0___2;
    if ( n0x400 < 0x400 )
    {
      v148[n0x400] = __Val_0___2;
LABEL_30:
      n0x400_2 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149A5E748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v23 = (__int64 *)sub_1402A65A0(0x18u);
        v15 = v23;
        v120 = v23;
        if ( v23 )
        {
          v24 = v23;
          *v23 = 0;
          n0x400_1 = 0;
          v23[1] = 0;
          v26 = (__int64)v23;
          v23[2] = 0;
        }
        else
        {
          v15 = 0;
          v24 = 0;
          n0x400_1 = 0;
          v120 = 0;
          v26 = 0;
        }
        sub_140306C00(v26, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v148;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v24[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v24[2] )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              (std::vector<vraudio::AudioBuffer const *> *)v15,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v24[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0x400_2;
        __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
        v19 = v123;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v15[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v15[2] )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          (std::vector<vraudio::AudioBuffer const *> *)v15,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0__);
      }
      else
      {
        *_Whereptr_1 = __Val_0___2;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v121 = *((_QWORD *)__Val_0___2 + 0xD) + v17;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___2 + 1) = sub_140301AF0(&v143, (__int64)__Val_0___2);
    v30 = v19;
    v31 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___2 + 7);
    v144 = v19++;
    v123 = v19;
    if ( !v31 )
    {
      v69 = v125;
      goto LABEL_98;
    }
    __Val_0__ = 0;
    v131 = 0;
    v32 = v31(*(_QWORD *)__Val_0___2, &v131, &__Val_0__);
    v33 = 0;
    v124 = 0;
    if ( !v131 )
      goto LABEL_94;
    v34 = v143;
    v35 = (_QWORD *)(v32 + 0x10);
    v137 = (_QWORD *)(v32 + 0x10);
    do
    {
      __Val_0___5 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      __Val_0___6 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      v36 = *v35 == 0;
      v123 = v19 + 1;
      v35[8] = v19;
      if ( v36 )
      {
        v58 = (_QWORD *)v35[0xFFFFFFFF];
        v60 = 0;
      }
      else
      {
        if ( !*v34 )
        {
          __asm { vzeroupper }
          v37 = (_QWORD *)sub_1402A65A0(0x10u);
          if ( v37 )
          {
            *v37 = 0;
            v37[1] = 0;
            v38 = (_QWORD *)sub_1402A65A0(0x30u);
            *v38 = v38;
            v38[1] = v38;
            *v37 = v38;
          }
          else
          {
            v37 = 0;
          }
          *v34 = (__int64)v37;
        }
        v39 = (_BYTE *)v35[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v39[Size_1] );
        __asm { vzeroupper }
        sub_1402FD830(&Src, v39, Size_1);
        v42 = (_BYTE *)*v35;
        do
          ++Size;
        while ( v42[Size] );
        v43 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402ABF30((const void **)&Src, Size, v21, v42, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v45 = (char *)p_Src + v43;
          memmove(v45, v42, Size);
          v45[Size] = 0;
        }
        __Val_0___4 = (const vraudio::AudioBuffer *)*v34;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(_QWORD *)Src.m256_f32;
        __Val_0___1 = __Val_0___4;
        v49 = *(_QWORD **)__Val_0___4;
        v50 = **(_QWORD ***)__Val_0___4;
        if ( v50 == *(_QWORD **)__Val_0___4 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v50[4];
          Buf1 = v50 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = (__m256 *)p_Src_2;
          if ( v50[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v50 = (_QWORD *)*v50;
        }
        while ( v50 != v49 );
        __Val_0___4 = __Val_0___1;
        if ( v50 == v49 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___4 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v55 = sub_1402A65A0(0x30u);
          *(_QWORD *)(v55 + 0x20) = 0;
          *(_QWORD *)(v55 + 0x28) = 0;
          *(__m256 *)(v55 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___4 + 1);
          v56 = (__int64 *)v49[1];
          *(_QWORD *)v55 = v49;
          *(_QWORD *)(v55 + 8) = v56;
          v49[1] = v55;
          *v56 = v55;
          v57 = *(_QWORD *)*v34;
          v58 = (_QWORD *)(*(_QWORD *)(v57 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v57 + 8) + 0x28LL) > 0xFu )
            v58 = (_QWORD *)*v58;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v59 = *(_QWORD *)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v59 = *(_QWORD *)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - v59 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A6590(v59);
          }
LABEL_66:
          v15 = v120;
          v60 = 0;
          v35 = v137;
          __Val_0___5 = __Val_0___6;
          v33 = v124;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v58 = v50 + 2;
        if ( v58[3] > 0xFu )
          v58 = (_QWORD *)*v58;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
          if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A6590(p_Src_2);
        v15 = v120;
        v60 = 0;
        v35 = v137;
        __Val_0___5 = __Val_0___6;
        v33 = v124;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___5 + 1) = v58;
      n0x400 = n0x400_2;
      __Val_0___1 = __Val_0___5;
      if ( n0x400_2 >= 0x400 )
      {
        if ( !byte_149A5E748 )
          goto LABEL_92;
        if ( !v15 )
        {
          __asm { vzeroupper }
          v62 = (__int64 *)sub_1402A65A0(0x18u);
          n0x400_3 = 0;
          v120 = v62;
          v15 = v62;
          if ( v62 )
          {
            *v62 = 0;
            v64 = (__int64)v62;
            v62[1] = 0;
            v62[2] = 0;
            v60 = v62;
          }
          else
          {
            v15 = 0;
            v120 = 0;
            v64 = 0;
          }
          sub_140306C00(v64, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v148;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v60[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v60[2] )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                (std::vector<vraudio::AudioBuffer const *> *)v15,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v60[1] += 8;
            }
            ++n0x400_3;
            ++__Val_0__1;
          }
          while ( n0x400_3 < 0x400 );
          n0x400 = n0x400_2;
          __Val_0___5 = __Val_0___6;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v15[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v15[2] )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            (std::vector<vraudio::AudioBuffer const *> *)v15,
            _Whereptr_3,
            &__Val_0___1);
        }
        else
        {
          *_Whereptr_3 = __Val_0___5;
          v15[1] += 8;
        }
        v33 = v124;
      }
      else
      {
        v148[n0x400_2] = __Val_0___5;
      }
      n0x400_2 = ++n0x400;
LABEL_92:
      ++v33;
      v68 = v35[0xB] + v121;
      v35 += 0xE;
      v19 = v123;
      v121 = v68;
      v124 = v33;
      v137 = v35;
    }
    while ( v33 < v131 );
    __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
    v30 = v144;
LABEL_94:
    if ( __Val_0__ > 1 )
      v30 = 0xFFFFFFFFFFFFFFFFuLL;
    v69 = &v125[__Val_0__];
    v125 += __Val_0__;
LABEL_98:
    __Val_0___2 = (const vraudio::AudioBuffer *)((char *)__Val_0___2 + 0x70);
    v70 = v121;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___5 + 0xA) = v30;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___3 = (__int64)__Val_0___2;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v17 = v70;
      continue;
    }
    break;
  }
  v18 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  v125 = v69;
  if ( !v15 )
    goto LABEL_105;
  if ( !((v15[1] - *v15) >> 3) )
    __debugbreak();
  v72 = (char *)*v15;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v125 = v69;
LABEL_106:
  __asm { vzeroupper }
  sub_1403005F0(v72, &v72[8 * n0x400], (__int64)(8 * n0x400) >> 3, v118);
  v73 = 0;
  v74 = 0;
  v75 = 0;
  for ( n0x400_4 = 0; n0x400_4 < n0x400; ++n0x400_4 )
  {
    v77 = *(_QWORD *)&v72[8 * n0x400_4];
    if ( v75 == *(_QWORD *)(v77 + 8) )
    {
      if ( ++v74 == 1 )
        *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 0x50LL) = v74;
    }
    else
    {
      v74 = 0;
      *(_QWORD *)(v77 + 0x50) = -(__int64)(*(_QWORD *)(v77 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v75 = *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = n0x8000_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
    n0x8000 = ::n0x8000;
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
    n0x100000 = ::n0x100000;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149A5E748 )
    p_n0x8000 = &n0x8000_1;
  if ( !n0x8000_0 )
    n0x8000_2 = (_QWORD)(v18 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v83 = 0;
  }
  else
  {
    v82 = sub_1402A65A0(n0x8000_2);
    v83 = v82;
    if ( v82 )
    {
      v84 = (char *)v82;
      goto LABEL_130;
    }
  }
  v85 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v85 = 0xFFFFFFFFFFFFFF0LL;
  v86 = alloca(v85 & 0xFFFFFFFFFFFFFFF0uLL);
  v84 = (char *)&v118;
LABEL_130:
  v87 = (__int64 (__fastcall *)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149C78D08;
  v88 = 1;
  *v84 = 0;
  v89 = 0;
  LODWORD(v123) = 0;
  LODWORD(v124) = 1;
  if ( v87 && qword_149C78D10 && byte_149A5E748 )
  {
    v88 = v87(*(_QWORD *)v129, (unsigned int)n4, v134, v135, v133, __Val_0___7, _Newcapacity, v147, n0x10_1, &a8);
    LODWORD(v124) = v88;
  }
  v90 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v91 = sub_140304A70(
            *(_QWORD *)&FileTime,
            *(__int64 *)v129,
            (__int64)String,
            n4,
            (__int64 *)v135,
            v134,
            v133,
            (_QWORD *)__Val_0___7,
            _Newcapacity,
            a7,
            v84,
            n0x8000_2,
            (int *)&v123,
            v88,
            &a8);
    v90 = a8;
    v89 = v91;
    v73 = v123;
  }
  if ( ::n2 == 1 && (v90 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v84);
    v90 = a8;
  }
  n2 = n2_0;
  if ( n2_0 == 1 && (v90 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(n2_0 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v84);
    n2 = n2_0;
  }
  v84[v89] = 0;
  v95 = a8;
  v96 = (a8 & 1) != 0 && ::n2 == 2;
  v97 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v96 || v97 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149A5E748 )
      p_n0x8000_1 = &n0x8000_1;
    v99 = qword_149C78D48;
    if ( !qword_149C78D48 )
      v99 = v121 + v89 + ((_QWORD)(v125 + 4) << 9);
    n0x8000_3 = v99 + 0x80;
    if ( *p_n0x8000_1 < v99 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = sub_1402A65A0(n0x8000_3);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v104 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v104 = 0xFFFFFFFFFFFFFF0LL;
    v105 = alloca(v104 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v118;
LABEL_166:
    v117 = v124;
    *(_BYTE *)Buffer_1 = 0;
    sub_140305570(
      *(_QWORD *)&FileTime,
      *(__int64 *)v129,
      Buffer,
      String,
      n4,
      (_QWORD *)v135,
      v134,
      v133,
      __Val_0___7,
      _Newcapacity,
      a7,
      (__int64)v72,
      n0x400_2,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v84[v73],
      v89 - v73,
      a8,
      v117);
    sub_1402A6590(Buffer_3);
    v95 = a8;
  }
  v106 = byte_149C789B8;
  if ( byte_149C789B8 )
  {
    if ( (v95 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v95 = a8;
      v106 = byte_149C789B8;
    }
    if ( v106 )
    {
      if ( (v95 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A6590(v83);
  v109 = v142;
  if ( v142 )
  {
    v110 = (_QWORD **)*v142;
    **(_QWORD **)(*v142 + 8) = 0;
    v111 = *v110;
    if ( *v110 )
    {
      do
      {
        n0xF_1 = v111[5];
        v113 = (_QWORD *)*v111;
        if ( n0xF_1 > 0xF )
        {
          v114 = v111[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v114 - *(_QWORD *)(v114 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v114 = *(_QWORD *)(v114 - 8);
          }
          sub_1402A6590(v114);
        }
        v111[4] = 0;
        v111[5] = 0xF;
        *((_BYTE *)v111 + 0x10) = 0;
        sub_1402A6590((__int64)v111);
        v111 = v113;
      }
      while ( v113 );
    }
    sub_1402A6590(*v109);
    result = sub_1402A6590((__int64)v109);
  }
  v115 = v120;
  if ( v120 )
  {
    v116 = *v120;
    if ( *v120 )
    {
      if ( ((v120[2] - v116) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v116 - *(_QWORD *)(v116 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v116 = *(_QWORD *)(v116 - 8);
      }
      sub_1402A6590(v116);
      *v115 = 0;
      v115[1] = 0;
      v115[2] = 0;
    }
    return sub_1402A6590((__int64)v115);
  }
  return result;
}

// --- End Function: sub_140306CF0 (0x140306CF0) ---

// --- Function: sub_140307B30 (0x140307B30) ---
__int64 __fastcall sub_140307B30(
        __int64 a1,
        __int64 a2,
        int a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        __int64 (__fastcall *a9)(__int64, __int64, __int64, __int64, __int64, _BYTE *))
{
  __int64 v9; // rbp
  int v11; // ecx
  int v12; // esi
  char n0x25; // r8
  __int64 v14; // r15
  char *v15; // rbx
  __int64 v17; // rcx
  char n0x24; // cl
  __int64 v19; // rdi
  _BYTE *v20; // r11
  unsigned __int64 n0x39; // rcx
  char *v22; // r10
  int n0x1F_2; // r8d
  signed __int64 n0x1F; // rdx
  __int64 v25; // r9
  int n0x1F_1; // eax
  __int64 n0x1F_3; // rcx
  int v28; // eax
  int v29; // edi
  _BYTE *v30; // rbp
  int n0x1F_5; // r9d
  __int64 n0x1F_6; // r8
  char *v33; // r11
  __int64 v34; // r10
  int n0x1F_4; // eax
  int v36; // eax
  int v37; // eax
  __int64 v38; // rax
  _BYTE *v40; // [rsp+28h] [rbp-90h]
  char String[4]; // [rsp+30h] [rbp-88h] BYREF
  int v42; // [rsp+34h] [rbp-84h]
  __int64 (__fastcall *v43)(__int64, __int64, __int64, __int64, __int64, _BYTE *); // [rsp+38h] [rbp-80h]
  __int64 v44; // [rsp+40h] [rbp-78h]
  _BYTE v45[32]; // [rsp+48h] [rbp-70h] BYREF

  v9 = a5;
  v11 = a3;
  v12 = a3;
  v44 = a5;
  n0x25 = *a4;
  v14 = 0;
  v43 = a9;
  v15 = a4;
  v42 = v11;
  if ( n0x25 )
  {
    do
    {
      v17 = 0x3FF6C0900000000LL;
      if ( n0x25 == 0x24 )
      {
        n0x24 = *++v15;
        v19 = 0;
        if ( n0x24 == 0x24 )
        {
LABEL_6:
          v19 = v14++;
        }
        else
        {
          while ( (unsigned __int8)(n0x24 - 0x30) <= 9u )
          {
            String[0] = n0x24;
            ++v15;
            v19 = atoi(String) + 0xA * v19;
            n0x24 = *v15;
            if ( *v15 == 0x24 )
              goto LABEL_6;
          }
          --v15;
        }
        v20 = 0;
        if ( v15[1] == 0x7B )
        {
          n0x39 = (unsigned __int8)v15[2];
          v22 = v15;
          v15 += 2;
          n0x1F_2 = 0;
          n0x1F = 0;
          if ( (_BYTE)n0x39 != 0x7D )
          {
            do
            {
              if ( n0x1F >= 0x1F
                || (unsigned __int8)n0x39 > 0x39u
                || (v25 = 0x3FF6C0900000000LL, !_bittest64(&v25, n0x39)) )
              {
                v15 = v22;
                goto LABEL_20;
              }
              ++v15;
              v45[n0x1F] = n0x39;
              ++n0x1F_2;
              ++n0x1F;
              n0x39 = (unsigned __int8)*v15;
            }
            while ( (_BYTE)n0x39 != 0x7D );
            if ( n0x1F_2 > 0 )
            {
              n0x1F_1 = 0x1F;
              if ( n0x1F_2 < 0x1F )
                n0x1F_1 = n0x1F_2;
              n0x1F_3 = n0x1F_1;
              if ( (unsigned __int64)n0x1F_1 >= 0x20 )
LABEL_55:
                _report_rangecheckfailure(n0x1F_3, n0x1F);
              v45[n0x1F_1] = 0;
              v20 = v45;
            }
          }
        }
LABEL_20:
        if ( v12 < (int)a2 )
        {
          v28 = v43(v12 + a1, a2 - v12, v9, v19 + a7, a6, v20);
          if ( v28 >= 0 )
            v12 += v28;
        }
        v29 = a2;
      }
      else if ( n0x25 == 0x25 )
      {
        v30 = 0;
        n0x1F_5 = 0;
        n0x1F_6 = 0;
        v33 = v15;
        v34 = 0;
        while ( 2 )
        {
          n0x1F = *++v15;
          switch ( (int)n0x1F )
          {
            case 0:
              v15 = v33 + 1;
              goto LABEL_39;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x42:
            case 0x44:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x59:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x62:
            case 0x68:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x71:
            case 0x72:
            case 0x74:
            case 0x76:
            case 0x77:
              v17 = 0x3FF6C0900000000LL;
              goto LABEL_28;
            case 0x25:
            case 0x41:
            case 0x43:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x53:
            case 0x58:
            case 0x5A:
            case 0x61:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x69:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x73:
            case 0x75:
            case 0x78:
              if ( n0x1F_5 <= 0 )
                goto LABEL_37;
              n0x1F_4 = 0x1F;
              if ( n0x1F_5 < 0x1F )
                n0x1F_4 = n0x1F_5;
              n0x1F_3 = n0x1F_4;
              if ( (unsigned __int64)n0x1F_4 >= 0x20 )
                goto LABEL_55;
              v45[n0x1F_4] = 0;
              v30 = v45;
LABEL_37:
              v34 = v14++;
LABEL_39:
              v29 = a2;
              if ( v12 >= (int)a2 )
              {
                v9 = v44;
              }
              else
              {
                v40 = v30;
                v9 = v44;
                v36 = v43(v12 + a1, a2 - v12, v44, v34 + a7, a6, v40);
                if ( v36 >= 0 )
                  v12 += v36;
              }
              break;
            default:
LABEL_28:
              if ( n0x1F_6 < 0x1F && (unsigned __int8)n0x1F <= 0x39u && _bittest64(&v17, n0x1F) )
              {
                ++n0x1F_5;
                v45[n0x1F_6++] = n0x1F;
              }
              continue;
          }
          break;
        }
      }
      else
      {
        v29 = a2;
        if ( a8 )
        {
          if ( v12 < (int)a2 )
          {
            v37 = sub_1403032F0((_WORD *)(v12 + a1), (int)a2 - v12, n0x25);
            if ( v37 >= 0 )
              v12 += v37;
          }
        }
        else if ( v12 < (int)a2 )
        {
          v38 = v12++;
          *(_BYTE *)(v38 + a1) = n0x25;
        }
      }
      n0x25 = *++v15;
    }
    while ( n0x25 );
    v11 = v42;
  }
  else
  {
    v29 = a2;
  }
  if ( v12 < v29 )
    *(_BYTE *)(v12 + a1) = 0;
  return (unsigned int)(v12 - v11);
}

// --- End Function: sub_140307B30 (0x140307B30) ---

// --- Function: swprintf (0x140308540) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A6BE0();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: swprintf (0x140308540) ---

// --- Function: unknown_libname_19 (0x140311130) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_19(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: unknown_libname_19 (0x140311130) ---

// --- Function: sub_1403113B0 (0x1403113B0) ---
bool __fastcall sub_1403113B0(__int64 *a1)
{
  __int64 v1; // r9
  __int64 v3; // rax
  __int64 v4; // r9
  __int16 v5; // r10

  v1 = *a1;
  if ( !*a1 )
    return 0;
  if ( (v1 & 0xF000000000000000uLL) == 0 )
    return *(_WORD *)((v1 & 0xFFFFFFFFFFFFLL) - 4) == HIWORD(v1);
  v3 = map_flag_to_mask(HIWORD(v1) & 0xF000);
  return *(_WORD *)((v4 & -v3 & 0xFFFFFFFFFFFFLL) + 2) == (v5 & 0xFFF);
}

// --- End Function: sub_1403113B0 (0x1403113B0) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x1403114B0) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  char v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = is_thread_privileged_or_bypass_mode()) != 0 )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || (unsigned __int8)sub_140395410(a1) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x1403114B0) ---

// --- Function: map_flag_to_mask (0x140327450) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140327450) ---

// --- Function: sub_140338A50 (0x140338A50) ---
__int64 __fastcall sub_140338A50(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *p_sub_1403E5B80)(); // rax

  sub_1403E74B0();
  if ( (dword_149C7904C & 0x100000) != 0 )
  {
    p_sub_1403E5B80 = sub_1403E5A20;
  }
  else
  {
    sub_1403E5DA0();
    p_sub_1403E5B80 = sub_1403E5B80;
  }
  off_149A5EC28[0] = p_sub_1403E5B80;
  return ((__int64 (__fastcall *)(_QWORD, __int64, __int64))p_sub_1403E5B80)(a1, a2, a3);
}

// --- End Function: sub_140338A50 (0x140338A50) ---

// --- Function: sub_140346BA0 (0x140346BA0) ---
unsigned __int64 __fastcall sub_140346BA0(unsigned __int64 *a1, _DWORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  unsigned __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _DWORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  _BYTE *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = (char *)a1[1];
  v4 = (char *)a1[2];
  if ( v2 == v4 )
  {
    v7 = 0x3FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*a1] >> 2;
    if ( v8 == 0x3FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = (__int64)&v4[-*a1] >> 2;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x3FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_DWORD *)sub_140394E70((__int64)a1, 4 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = (char *)a1[1];
    v16 = (_BYTE *)*a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 4;
      Size = a1[1] - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *a1 )
      sub_1403A6820((__int64)a1, *a1, (a1[2] - *a1) & 0xFFFFFFFFFFFFFFFCuLL);
    *a1 = (unsigned __int64)v13;
    result = (unsigned __int64)v17;
    a1[1] = (unsigned __int64)&v13[v11];
    a1[2] = (unsigned __int64)&v13[v12];
  }
  else
  {
    *(_DWORD *)v2 = *a2;
    result = a1[1];
    a1[1] = result + 4;
  }
  return result;
}

// --- End Function: sub_140346BA0 (0x140346BA0) ---

// --- Function: sub_140354250 (0x140354250) ---
char __fastcall sub_140354250(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9)
{
  __int64 v10; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-18h]
  __int64 n0xB0; // [rsp+90h] [rbp-10h]
  __int64 n0xA8; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  LODWORD(v10) = a6;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 1u, a5, v10, a7, a8);
}

// --- End Function: sub_140354250 (0x140354250) ---

// --- Function: sub_140394E70 (0x140394E70) ---
__int64 __fastcall sub_140394E70(__int64 a1, unsigned __int64 allocSize)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  unsigned __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  __int64 v11; // r9
  __int64 v12; // rdx
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v15; // eax
  unsigned __int64 v16; // rdx
  unsigned int v17; // edi
  _QWORD v18[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v19[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403B7230();
  n0x40 = (allocSize >> 8) + ((_BYTE)allocSize != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
      goto LABEL_7;
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 0x40LL;
      if ( n0x4000 >= 0x4000 )
        goto LABEL_2;
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
        n0x40_1 = 0xFFFFFFFFFFFFFFFFuLL;
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
          goto LABEL_2;
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    v11 = 1;
    v12 = n0x4000_2 & 0x3F;
    if ( n0x4000 >= (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << v12;
      n0x4000_2 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ;
          n0x4000_2 + 0x40 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL);
          v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = 0xFFFFFFFFFFFFFFFFuLL )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 0x40LL;
    }
    if ( n0x4000_2 < n0x4000 )
    {
      n0x4000_2 >>= 6;
      v12 = ((__int64)n0x4000 >> 0x3F) & 0x3F;
      v11 = (1LL << ((__int64)n0x4000 % 0x40)) - 1;
      v3[1].m256i_i64[n0x4000_2 + 1] |= v11;
    }
    if ( !v3->m256i_i64[0] )
    {
      v18[0] = 0x200000;
      v19[0] = v18;
      v18[1] = 0;
      v19[1] = v19;
      v15 = sub_140572D10(v19, v12, n0x4000_2, v11);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_140572D50((unsigned int)v19, 0x400000, v15, (unsigned int)&p_CigTemporaryAllocator, 0, 0);
    }
    v16 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v16 )
    {
      v17 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v16 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_140572BD0(v3, v3->m256i_i64[0] + v16, v17, 0);
      v3[1].m256i_i32[0] += v17;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(allocSize, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140394E70 (0x140394E70) ---

// --- Function: check_thread_list_contains_value (0x140395170) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 a1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8LL))(a1, &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140395170) ---

// --- Function: sub_140395230 (0x140395230) ---
bool __fastcall sub_140395230(unsigned __int64 a1)
{
  __int64 v2; // r9
  unsigned __int64 *v3; // r10
  unsigned __int64 *v4; // r8
  unsigned __int64 v5; // rcx
  unsigned __int64 *v6; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) != 1 )
    return 0;
  v3 = *(unsigned __int64 **)(v2 + 0x30);
  v4 = *(unsigned __int64 **)(v2 + 0x28);
  v5 = v3 - v4;
  while ( (__int64)v5 > 0 )
  {
    if ( v4[v5 >> 1] >= a1 )
    {
      v5 >>= 1;
    }
    else
    {
      v4 += (v5 >> 1) + 1;
      v5 += 0xFFFFFFFFFFFFFFFFuLL - (v5 >> 1);
    }
  }
  if ( v4 == v3 || (v6 = v4 + 1, a1 < *v4) )
    v6 = v4;
  if ( v4 == v6 )
    v4 = *(unsigned __int64 **)(v2 + 0x30);
  return v4 != v3;
}

// --- End Function: sub_140395230 (0x140395230) ---

// --- Function: validate_access_with_virtual_calls (0x1403952D0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  v3 = qword_149C8DFC0;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8LL))(a1, &v7);
  return v4(v3, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x1403952D0) ---

// --- Function: sub_140395410 (0x140395410) ---
char __fastcall sub_140395410(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rbx
  __int64 v2; // rax

  payload_ptr_state1 = *a1 & 0xFFFFFFFFFFFFLL;
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
      return sub_140395230(payload_ptr_state1);
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (unsigned __int8)is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls(payload_ptr_state1);
}

// --- End Function: sub_140395410 (0x140395410) ---

// --- Function: getModuleFunction (0x14039E810) ---
FARPROC __fastcall getModuleFunction(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: getModuleFunction (0x14039E810) ---

// --- Function: sub_1403A6820 (0x1403A6820) ---
__int64 __fastcall sub_1403A6820(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  __int64 v6; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // rcx
  unsigned __int64 n0x40; // rcx
  __int64 result; // rax
  unsigned __int64 v13; // rcx

  v5 = sub_1403B7230();
  v6 = v5;
  v7 = *(_QWORD *)v5;
  if ( !*(_QWORD *)v5 || a2 < v7 || a2 >= v7 + *(unsigned int *)(v5 + 0x20) )
    return sub_147715880(a2, (unsigned int)dword_149A5EC00);
  v8 = (a2 - v7) >> 8;
  v9 = (a3 >> 8) + v8 + ((_BYTE)a3 != 0);
  v10 = v9;
  if ( v9 >= (v8 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
    v10 = (v8 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
  n0x40 = v10 - v8;
  if ( (v8 & 0x3F) != 0 || n0x40 < 0x40 )
  {
    *(_QWORD *)(v5 + 8 * (v8 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v8 & 0x3F));
    v8 = (v8 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
  }
  for ( result = v8 + 0x40; v8 + 0x40 <= (v9 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v6 + 8 * (v13 >> 6) + 0x28) = 0 )
  {
    v13 = v8;
    v8 += 0x40LL;
  }
  if ( v8 < v9 )
  {
    result = v9;
    *(_QWORD *)(v6 + 8 * (v8 >> 6) + 0x28) &= ~((1LL << ((__int64)v9 % 0x40)) - 1);
  }
  return result;
}

// --- End Function: sub_1403A6820 (0x1403A6820) ---

// --- Function: sub_1403A6950 (0x1403A6950) ---
float *__fastcall sub_1403A6950(float *a1, unsigned int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // edx
  float v4; // xmm0_4
  float v5; // kr00_4

  v2 = (((a2 >> 1)
       & 0x55555555
       ^ (((a2 >> 1) & 0x55555555) >> 1))
      & 0x33333333
      ^ ((((a2 >> 1) & 0x55555555 ^ (((a2 >> 1) & 0x55555555) >> 1)) & 0x33333333) >> 2))
     & 0xF0F0F0F;
  v3 = (((a2
        & 0x55555555
        ^ ((a2 & 0x55555555) >> 1))
       & 0x33333333
       ^ (((a2 & 0x55555555 ^ ((a2 & 0x55555555) >> 1)) & 0x33333333) >> 2))
      & 0xF0F0F0F
      ^ ((((a2
          & 0x55555555
          ^ ((a2 & 0x55555555) >> 1))
         & 0x33333333
         ^ (((a2 & 0x55555555 ^ ((a2 & 0x55555555) >> 1)) & 0x33333333) >> 2))
        & 0xF0F0F0F) >> 4))
     & 0xFF00FF;
  v4 = (float)(unsigned __int16)(v3 ^ (v3 >> 8));
  *a1 = v4;
  v5 = (float)((unsigned __int8)(v2 ^ (v2 >> 4)) ^ (((v2 ^ (v2 >> 4)) & 0xFF00FF) >> 8));
  a1[1] = v5;
  return a1;
}

// --- End Function: sub_1403A6950 (0x1403A6950) ---

// --- Function: sub_1403B7230 (0x1403B7230) ---
__int64 sub_1403B7230()
{
  __int64 *v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(__int64 **)(NtCurrentTeb_w() + 0x10);
  result = *v0;
  if ( !*v0 )
  {
    v2 = (_QWORD *)sub_1402A65A0(0x828u);
    if ( v2 )
    {
      v2[3] = &p_Src;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *v0 = (__int64)v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 0xC0);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 0xC0) = v6 | 1;
      _tlregdtor(sub_1481CE000);
    }
    return *v0;
  }
  return result;
}

// --- End Function: sub_1403B7230 (0x1403B7230) ---

// --- Function: sub_1403BDEA0 (0x1403BDEA0) ---
__int64 __fastcall sub_1403BDEA0(int a1)
{
  return a1 ^ (a1 ^ ((a1 & 0xD5555555) + 0x2AAAAAAB)) & 0x55555555;
}

// --- End Function: sub_1403BDEA0 (0x1403BDEA0) ---

// --- Function: sub_1403BDEC0 (0x1403BDEC0) ---
__int64 __fastcall sub_1403BDEC0(int a1)
{
  return (a1 ^ ((a1 & 0xAAAAAAAA) + 0x55555556)) & 0x55555555 ^ ((a1 & 0xAAAAAAAA) + 0x55555556);
}

// --- End Function: sub_1403BDEC0 (0x1403BDEC0) ---

// --- Function: get_event_key_from_source_location (0x1403BF3E0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149C7B100;
  if ( !qword_149C7B100 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149C7B100 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BF3E0) ---

// --- Function: sub_1403C6E80 (0x1403C6E80) ---
__int64 __fastcall sub_1403C6E80(__int64 a1, unsigned int a2, __int64 a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return sub_1403C6EF0(a1, a2, a3);
  else
    return sub_1403C7160(a1, a2, a3);
}

// --- End Function: sub_1403C6E80 (0x1403C6E80) ---

// --- Function: sub_1403C6EF0 (0x1403C6EF0) ---
__int64 __fastcall sub_1403C6EF0(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_Src; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_Src_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149C8E038;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149C89AA0(
            &n0x1600,
            &word_149C7BF34,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_Src = &p_Src;
          HIWORD(n0x1600) = word_149C7BF34;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src);
          qword_149C89AE0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149C89AA8(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF38,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_Src_1 = &p_Src;
          HIWORD(n0x1600_1) = word_149C7BF38;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C6EF0 (0x1403C6EF0) ---

// --- Function: sub_1403C7160 (0x1403C7160) ---
__int64 __fastcall sub_1403C7160(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_Src; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_Src_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF2C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_Src = &p_Src;
        HIWORD(n0x1600) = word_149C7BF2C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a3);
        v15 = a2;
        qword_149C78FC8(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149C89AA8(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF30,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_Src_1 = &p_Src;
          HIWORD(n0x1600_1) = word_149C7BF30;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a3);
          v16[0] = v12;
          qword_149C78FC8(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C7160 (0x1403C7160) ---

// --- Function: rw_lock_acquire_read_lock_dispatch (0x1403CF2D0) ---
// Dispatches to either a profiled read lock acquisition function
// (`rw_lock_acquire_read_lock_profiled`) or a standard, unprofiled one
// (`rw_lock_acquire_read_lock_unprofiled`). The choice depends on a boolean flag
// (`is_profiled_mode`), a debug flag within the thread context (at offset `0x1C`),
// and the availability of the global environment (`gEnv`).
double __fastcall rw_lock_acquire_read_lock_dispatch(
        __int64 a1,
        signed __int64 a2,
        const char *a3,
        const char *a4,
        char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return rw_lock_acquire_read_lock_profiled(a1, a2, a3, a4);
  else
    return rw_lock_acquire_read_lock_unprofiled(a1, a2, a3, a4);
}

// --- End Function: rw_lock_acquire_read_lock_dispatch (0x1403CF2D0) ---

// --- Function: rw_lock_acquire_read_lock_profiled (0x1403CF350) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended, it retries. Upon successful acquisition,
// it logs detailed profiling information, including timestamps, lock name, lock
// owner, and caller, using a dedicated profiling system.
void __fastcall rw_lock_acquire_read_lock_profiled(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_Src; // rdx
  _BYTE v18[16]; // [rsp+30h] [rbp-29h] BYREF
  int n0x1600; // [rsp+40h] [rbp-19h] BYREF
  __int64 v20; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v22; // [rsp+50h] [rbp-9h]
  unsigned __int64 v23; // [rsp+58h] [rbp-1h]
  __int64 v24; // [rsp+60h] [rbp+7h]
  __int64 v25; // [rsp+68h] [rbp+Fh]
  char v26; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149C8E038;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 0xF8LL))(v4, v18, &v26);
  if ( (a2 & 0x200000) == 0 )
    return;
  v12 = (unsigned __int64)v11 << 0x20;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 0x124) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n0x1600 = 0x1600;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v20 = 1;
      n2 = 2;
      v22 = __rdtsc();
      qword_149C89AA0(
        &n0x1600,
        &word_149C7BF44,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      v15 = word_149C7BF44;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return;
  }
  *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n0x1600 = 0x1600;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v20 = 1;
  n2 = 2;
  v22 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_149C7BF48,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  v15 = word_149C7BF48;
LABEL_10:
  HIWORD(n0x1600) = v15;
  qword_149C89AE0("Lock: %s", a4);
  p_p_Src = &p_Src;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_Src = *(const ULONG_PTR **)(a1 + 8);
  qword_149C89AE0("LockOwner: %s", p_p_Src);
  qword_149C89AE0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 0xE8LL))(v4, v11);
  v23 = __rdtsc();
  qword_149C89AA8(&n0x1600);
}

// --- End Function: rw_lock_acquire_read_lock_profiled (0x1403CF350) ---

// --- Function: rw_lock_acquire_read_lock_unprofiled (0x1403CF580) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by a writer). It then attempts to atomically set the read lock flag using
// `_InterlockedCompareExchange64`. Upon successful acquisition, it logs basic
// information about the lock, its owner, and the caller. This version does not
// include detailed performance profiling.
void __fastcall rw_lock_acquire_read_lock_unprofiled(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_Src_1; // rdx
  int *p_n0x1600; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_Src; // rdx
  int v14; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v15[3]; // [rsp+34h] [rbp-65h] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v17; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v19; // [rsp+50h] [rbp-49h]
  unsigned __int64 v20; // [rsp+58h] [rbp-41h]
  __int64 v21; // [rsp+60h] [rbp-39h]
  __int64 v22; // [rsp+68h] [rbp-31h]
  int n0x1600; // [rsp+90h] [rbp-9h] BYREF
  __int64 v24; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v26; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+Fh]
  __int64 v28; // [rsp+B0h] [rbp+17h]
  __int64 v29; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x128LL))(qword_149C8E038, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n0x1600 = 0x1600;
        v24 = 1;
        n2 = 2;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v26 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF40,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(n0x1600) = word_149C7BF40;
        qword_149C89AE0("Lock: %s", a4);
        p_p_Src = &p_Src;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a3);
        v15[0] = v10;
        qword_149C78FC8(a1, v15, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n0x1600 = &n0x1600;
        v27 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return;
    }
    n0x1600_1 = 0x1600;
    v17 = 1;
    n2_1 = 2;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v19 = __rdtsc();
    qword_149C89AA0(
      &n0x1600_1,
      &word_149C7BF3C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(n0x1600_1) = word_149C7BF3C;
    qword_149C89AE0("Lock: %s", a4);
    p_p_Src_1 = &p_Src;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149C89AE0("LockOwner: %s", p_p_Src_1);
    qword_149C89AE0("Caller: %s", a3);
    v14 = v6;
    qword_149C78FC8(a1, &v14, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n0x1600 = &n0x1600_1;
    v20 = __rdtsc();
LABEL_13:
    qword_149C89AA8(p_n0x1600);
    goto LABEL_14;
  }
}

// --- End Function: rw_lock_acquire_read_lock_unprofiled (0x1403CF580) ---

// --- Function: rw_lock_handle_release_contention (0x1403CF7F0) ---
// Handles the release of a read-write lock when contention or specific lock flags
// are present. It continuously attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`. Depending on the resulting lock state, it may
// trigger further release operations (e.g., waking waiting threads via
// `qword_149B3B488`) or update thread context information related to lock
// ownership and counts.
__int64 __fastcall rw_lock_handle_release_contention(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v8 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
      break;
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
      return result;
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
    return qword_149C78FD0(a1, v4);
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v11,
      &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v7 & (v9 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(
             qword_149C8E038,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: rw_lock_handle_release_contention (0x1403CF7F0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403DAA60) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = n2_4;
  if ( !n2_4 )
  {
    v1 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
           qword_149C8DFD0,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    n2_4 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403DAA60) ---

// --- Function: sub_1403DF590 (0x1403DF590) ---
const ULONG_PTR *__fastcall sub_1403DF590(__int64 a1, __int64 a2)
{
  unsigned __int32 i; // edi
  unsigned int v4; // ebx
  signed __int32 v5; // eax
  const ULONG_PTR *p_Src; // rax
  int v7; // [rsp+50h] [rbp+8h] BYREF
  int v8; // [rsp+58h] [rbp+10h] BYREF
  __int64 v9; // [rsp+60h] [rbp+18h] BYREF
  __int64 v10; // [rsp+68h] [rbp+20h] BYREF

  for ( i = a2; ; i = v5 )
  {
    v4 = i & 0xFFFFFFFE;
    if ( (i & 0xFFFE) == 0 && (i & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v9,
        &v8);
      v4 = (unsigned __int16)v4;
      a2 = *(unsigned int *)(((((unsigned __int64)i >> 0x10) & (unsigned int)(v8 - 1)) << 9) + v9 + 0x124);
      if ( (_DWORD)a2 != 0xFFFFFFFF )
      {
        a2 = (unsigned int)((_DWORD)a2 << 0x10);
        v4 = a2 | (unsigned __int16)v4;
      }
    }
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, i);
    if ( i == v5 )
      break;
  }
  if ( (i & 0xFFFE) != 0 )
  {
    qword_149C78FD0(a1, a2);
  }
  else if ( (i & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v10,
      &v7);
    *(_DWORD *)(((HIWORD(i) & (unsigned __int64)(unsigned int)(v7 - 1)) << 9) + v10 + 0x11C) = (unsigned __int16)(HIWORD(i) + v7);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(qword_149C8E038);
  }
  p_Src = &::p_Src;
  *(_QWORD *)(a1 + 8) = &::p_Src;
  return p_Src;
}

// --- End Function: sub_1403DF590 (0x1403DF590) ---

// --- Function: sub_1403E1120 (0x1403E1120) ---
__int64 __fastcall sub_1403E1120(__int64 a1, unsigned __int64 a2, __int64 a3, const char *a4, const char *a5, char a6)
{
  if ( a6 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403E1120 (0x1403E1120) ---

// --- Function: rw_lock_acquire_write_lock_profiled (0x1403E11B0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended (e.g., by readers or another writer), it
// waits. Upon successful acquisition, it logs detailed profiling information,
// including timestamps, lock name, lock owner, and caller, using a dedicated
// profiling system. It also sets the lock owner pointer at `p_rw_lock_state + 8`.
__int64 __fastcall rw_lock_acquire_write_lock_profiled(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5)
{
  __int64 v5; // r15
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r14d
  const char *v12; // r13
  bool v13; // zf
  signed __int64 v14; // rax
  __int64 result; // rax
  unsigned __int64 v16; // rdx
  signed __int64 v17; // rax
  const ULONG_PTR *p_p_Src; // rdx
  signed __int64 v19; // rax
  const ULONG_PTR *p_p_Src_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-91h] BYREF
  __int64 v22; // [rsp+34h] [rbp-8Dh]
  int n2; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 v24; // [rsp+40h] [rbp-81h]
  unsigned __int64 v25; // [rsp+48h] [rbp-79h]
  __int64 v26; // [rsp+50h] [rbp-71h]
  __int64 v27; // [rsp+58h] [rbp-69h]
  int n0x1600_1; // [rsp+80h] [rbp-41h] BYREF
  __int64 v29; // [rsp+84h] [rbp-3Dh]
  int n2_1; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 v31; // [rsp+90h] [rbp-31h]
  unsigned __int64 v32; // [rsp+98h] [rbp-29h]
  __int64 v33; // [rsp+A0h] [rbp-21h]
  __int64 v34; // [rsp+A8h] [rbp-19h]
  _BYTE v35[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char v36; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 v37; // [rsp+130h] [rbp+6Fh]

  v37 = a3;
  v5 = qword_149C8E038;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v5 + 0xF8LL))(v5, v35, &v36);
  v12 = a5;
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v16 = (unsigned __int64)v11 << 0x30;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v10 + 0x124) = HIWORD(a2);
        v17 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v16 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v13 = a2 == v17;
        a2 = v17;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v22 = 1;
          n2 = 2;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v24 = __rdtsc();
          qword_149C89AA0(
            &n0x1600,
            &word_149C7BF54,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(n0x1600) = word_149C7BF54;
          qword_149C89AE0("Lock: %s", v12);
          p_p_Src = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src);
          qword_149C89AE0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v25 = __rdtsc();
          qword_149C89AA8(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
        v19 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v16, a2);
        v13 = a2 == v19;
        a2 = v19;
        if ( v13 )
        {
          n0x1600_1 = 0x1600;
          v29 = 1;
          n2_1 = 2;
          v32 = 0;
          v33 = 0;
          v34 = 0;
          v31 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF58,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600_1) = word_149C7BF58;
          qword_149C89AE0("Lock: %s", v12);
          p_p_Src_1 = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v32 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | 0x200000, a2);
    v13 = a2 == v14;
    a2 = v14;
  }
  while ( !v13 );
  result = v37;
  *(_QWORD *)(a1 + 8) = v37;
  return result;
}

// --- End Function: rw_lock_acquire_write_lock_profiled (0x1403E11B0) ---

// --- Function: rw_lock_acquire_write_lock_unprofiled (0x1403E1470) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by readers). It then attempts to atomically set the write lock flag or
// increment a write lock count using `_InterlockedCompareExchange64`. Upon
// successful acquisition, it logs basic information about the lock, its owner, and
// the caller. This version does not include detailed performance profiling. It
// also sets the lock owner pointer at `p_rw_lock_state + 8`.
signed __int64 __fastcall rw_lock_acquire_write_lock_unprofiled(
        __int64 a1,
        signed __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5)
{
  char v5; // r14
  signed __int64 v9; // rcx
  bool v10; // zf
  signed __int64 result; // rax
  const ULONG_PTR *p_p_Src; // rdx
  int v13; // esi
  signed __int64 v14; // rax
  const ULONG_PTR *p_p_Src_1; // rdx
  int v16; // [rsp+38h] [rbp-81h] BYREF
  _DWORD v17[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int n0x1600; // [rsp+48h] [rbp-71h] BYREF
  __int64 v19; // [rsp+4Ch] [rbp-6Dh]
  int n2; // [rsp+54h] [rbp-65h]
  unsigned __int64 v21; // [rsp+58h] [rbp-61h]
  unsigned __int64 v22; // [rsp+60h] [rbp-59h]
  __int64 v23; // [rsp+68h] [rbp-51h]
  __int64 v24; // [rsp+70h] [rbp-49h]
  int n0x1600_1; // [rsp+98h] [rbp-21h] BYREF
  __int64 v26; // [rsp+9Ch] [rbp-1Dh]
  int n2_1; // [rsp+A4h] [rbp-15h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-11h]
  unsigned __int64 v29; // [rsp+B0h] [rbp-9h]
  __int64 v30; // [rsp+B8h] [rbp-1h]
  __int64 v31; // [rsp+C0h] [rbp+7h]

  v5 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x128LL))(qword_149C8E038, a1);
      if ( (a2 & 0x2003FF) == 0 )
        break;
      if ( v5 )
      {
        n0x1600 = 0x1600;
        v19 = 1;
        n2 = 2;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v21 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF4C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(n0x1600) = word_149C7BF4C;
        qword_149C89AE0("Lock: %s", a5);
        p_p_Src = &p_Src;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a4);
        v16 = a2;
        qword_149C78FC8(a1, &v16, 4, 0xFFFFFFFFLL);
        a2 = *(_QWORD *)a1;
        v22 = __rdtsc();
        qword_149C89AA8(&n0x1600);
      }
      else
      {
        v13 = a2 + 0x400000;
        v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 + 0x400000, a2);
        v10 = a2 == v14;
        a2 = v14;
        if ( v10 )
        {
          v5 = 1;
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF50,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600_1) = word_149C7BF50;
          qword_149C89AE0("Lock: %s", a5);
          p_p_Src_1 = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a4);
          v17[0] = v13;
          qword_149C78FC8(a1, v17, 4, 0xFFFFFFFFLL);
          a2 = *(_QWORD *)a1;
          v29 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v9 = (a2 | 0x200000) - 0x400000;
    if ( !v5 )
      v9 = a2 | 0x200000;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v9, a2);
    v10 = a2 == result;
    a2 = result;
  }
  while ( !v10 );
  *(_QWORD *)(a1 + 8) = a3;
  return result;
}

// --- End Function: rw_lock_acquire_write_lock_unprofiled (0x1403E1470) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403E1740) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // rbx
  signed __int64 v4; // rdi
  signed __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v7; // r8
  int v8; // ecx
  __int64 v9; // r8
  unsigned __int64 v10; // rbx
  const ULONG_PTR *p_p_Src; // rax
  int v12; // [rsp+70h] [rbp+8h] BYREF
  int v13; // [rsp+78h] [rbp+10h] BYREF
  __int64 v14; // [rsp+80h] [rbp+18h] BYREF
  __int64 v15; // [rsp+88h] [rbp+20h] BYREF

  for ( i = a2; ; i = v5 )
  {
    v4 = i & 0xFFFFFFFFFFD003FFuLL;
    if ( (i & 0xFFFF00100000LL) != 0 )
    {
      v4 = i & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (i & 0xFFC003FF) == 0 && (i & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v15,
        &v13);
      v4 = i & 0xFFFFFFD003FFLL;
      a2 = *(unsigned int *)(((HIWORD(i) & (unsigned int)(v13 - 1)) << 9) + v15 + 0x124);
      if ( (_DWORD)a2 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)(unsigned int)a2 << 0x30;
    }
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v4, i);
    if ( i == v5 )
      break;
  }
  if ( (i & 0x3FF) != 0 )
  {
    if ( (i & 0x100000) != 0 )
      qword_149C78FD8(a1);
    if ( (i & 0xFFFF00000000LL) != 0 )
    {
      v6 = qword_149C8E038;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v14,
        &v12);
      v7 = v14 + ((WORD2(i) & (unsigned __int64)(unsigned int)(v12 - 1)) << 9);
      LODWORD(i) = *(_DWORD *)(v7 + 0x124);
      *(_DWORD *)(v7 + 0x11C) = (unsigned __int16)(WORD2(i) + v12);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xD8LL))(v6);
      while ( (_DWORD)i != 0xFFFFFFFF )
      {
        v8 = (unsigned __int16)(i + v12);
        v9 = v14 + ((unsigned __int64)((unsigned int)i & (v12 - 1)) << 9);
        LODWORD(i) = *(_DWORD *)(v9 + 0x124);
        *(_DWORD *)(v9 + 0x11C) = v8;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xD8LL))(v6);
      }
    }
  }
  else if ( (i & 0xFFC00000) != 0 )
  {
    qword_149C78FD0(a1, a2);
  }
  else if ( (i & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v14,
      &v12);
    v10 = HIWORD(i);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v10 & (v12 - 1)) << 9) + v14 + 0x11C) = (unsigned __int16)(v10 + v12);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(qword_149C8E038, (unsigned int)v10);
  }
  p_p_Src = &p_Src;
  *(_QWORD *)(a1 + 8) = &p_Src;
  return p_p_Src;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403E1740) ---

// --- Function: sub_1403E5A20 (0x1403E5A20) ---
unsigned __int64 __fastcall sub_1403E5A20(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r14
  __m128i v11; // xmm3
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // r15
  unsigned __int8 *v15; // rbx
  unsigned __int8 v16; // al
  unsigned __int64 result; // rax
  unsigned __int8 v18[16]; // [rsp+20h] [rbp-48h] BYREF

  _XMM5 = xmmword_1482CD8F0;
  v4 = 0;
  v6 = 0;
  v7 = a1;
  if ( (a3 & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
  {
    do
    {
      _XMM3 = *(__m128i *)(a2 + v6);
      __asm
      {
        vpcmpgtb xmm1, xmm5, xmm3
        vpcmpgtb xmm0, xmm3, xmm4
      }
      v11 = _mm_add_epi8((__m128i)(_XMM1 & _XMM0 & xmmword_1482CD840), _XMM3);
      v6 += 0x10LL;
      LODWORD(v7) = _mm_crc32_u64(_mm_crc32_u64(v7, v11.m128i_u64[0]), _mm_extract_epi64(v11, 1));
    }
    while ( v6 < (a3 & 0xFFFFFFFFFFFFFFF0uLL) );
  }
  v12 = 0;
  v13 = a3 - v6;
  if ( v13 )
  {
    v14 = a2 - (_QWORD)v18 + v6;
    do
    {
      v15 = &v18[v12];
      v16 = tolower(v18[v12 + v14]);
      ++v12;
      *v15 = v16;
    }
    while ( v12 < v13 );
  }
  result = (unsigned int)v7;
  if ( (v13 & 0xFFFFFFFFFFFFFFF8uLL) != 0 )
  {
    do
    {
      result = _mm_crc32_u64(result, *(_QWORD *)&v18[v4]);
      v4 += 8LL;
    }
    while ( v4 < (v13 & 0xFFFFFFFFFFFFFFF8uLL) );
  }
  if ( (v13 & 4) != 0 )
  {
    result = _mm_crc32_u32(result, *(_DWORD *)&v18[v4]);
    v4 += 4LL;
  }
  if ( (v13 & 2) != 0 )
  {
    result = _mm_crc32_u16(result, *(_WORD *)&v18[v4]);
    v4 += 2LL;
  }
  if ( (v13 & 1) != 0 )
    return _mm_crc32_u8(result, v18[v4]);
  return result;
}

// --- End Function: sub_1403E5A20 (0x1403E5A20) ---

// --- Function: sub_1403E5B80 (0x1403E5B80) ---
__int64 __fastcall sub_1403E5B80(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 i; // rdi
  int C; // ecx

  for ( i = a3; i; --i )
  {
    C = *a2++;
    a1 = dword_149C7B260[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403E5B80 (0x1403E5B80) ---

// --- Function: sub_1403E5DA0 (0x1403E5DA0) ---
__int64 sub_1403E5DA0()
{
  int n0xFF; // r10d
  _DWORD *v1; // r11
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  __int64 result; // rax
  int v13; // r9d
  signed int n0x1E; // r8d
  unsigned int v15; // eax

  n0xFF = 0;
  v1 = dword_149C7B260;
  do
  {
    v2 = ((n0xFF & 1) << 7) | 0x40;
    if ( (n0xFF & 2) == 0 )
      v2 = (n0xFF & 1) << 7;
    v3 = v2 | 0x20;
    if ( (n0xFF & 4) == 0 )
      v3 = v2;
    v4 = v3 | 0x10;
    if ( (n0xFF & 8) == 0 )
      v4 = v3;
    v5 = v4 | 8;
    if ( (n0xFF & 0x10) == 0 )
      v5 = v4;
    v6 = v5 | 4;
    if ( (n0xFF & 0x20) == 0 )
      v6 = v5;
    v7 = v6 | 2;
    if ( (n0xFF & 0x40) == 0 )
      v7 = v6;
    v8 = v7 | 1;
    if ( (((unsigned int)n0xFF >> 6) & 2) == 0 )
      v8 = v7;
    v9 = (((2
          * ((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41) >> 0x1F)
           & 0x1EDC6F41))
         ^ (((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41) >> 0x1F)
           & 0x1EDC6F41) >> 0x1F)
         & 0x1EDC6F41) >> 0x1F)
       & 0x1EDC6F41;
    v10 = (2
         * ((2
           * ((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41) >> 0x1F)
            & 0x1EDC6F41))
          ^ (((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41) >> 0x1F)
            & 0x1EDC6F41) >> 0x1F)
          & 0x1EDC6F41))
        ^ v9;
    v11 = (2 * ((2 * v10) ^ (v10 >> 0x1F) & 0x1EDC6F41))
        ^ (((2 * v10) ^ (v10 >> 0x1F) & 0x1EDC6F41) >> 0x1F)
        & 0x1EDC6F41;
    LODWORD(result) = (2 * v11) ^ (v11 >> 0x1F) & 0x1EDC6F41;
    v13 = 0;
    n0x1E = 0x1E;
    do
    {
      if ( (result & 1) != 0 )
        v13 |= 1 << (n0x1E + 1);
      v15 = (unsigned int)result >> 1;
      if ( (v15 & 1) != 0 )
        v13 |= 1 << n0x1E;
      result = v15 >> 1;
      n0x1E -= 2;
    }
    while ( n0x1E > (int)0xFFFFFFFE );
    *v1 = v13;
    ++n0xFF;
    ++v1;
  }
  while ( n0xFF <= 0xFF );
  return result;
}

// --- End Function: sub_1403E5DA0 (0x1403E5DA0) ---

// --- Function: sub_1403E74B0 (0x1403E74B0) ---
void sub_1403E74B0()
{
  __int64 n7; // rax
  __int64 Relationship; // rcx
  unsigned int v25; // r8d
  __int64 Relationship_1; // rcx
  __int64 Relationship_2; // rcx
  __int64 Relationship_3; // rcx
  __int64 v41; // rbx
  unsigned __int64 NodeNumber; // rcx
  unsigned __int64 size; // rcx
  void *v44; // rsp
  void *v45; // rsp
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *p_Buffer; // r15
  unsigned __int64 v47; // r12
  int v48; // r13d
  unsigned __int8 v49; // cl
  unsigned __int8 v50; // r14
  unsigned __int8 v51; // cl
  unsigned __int8 v52; // si
  unsigned __int8 v53; // cl
  unsigned __int8 v54; // di
  unsigned __int8 v55; // cl
  unsigned __int8 v56; // r10
  unsigned __int8 v57; // cl
  unsigned __int8 v58; // r9
  unsigned __int8 v59; // cl
  unsigned __int8 v60; // r8
  unsigned __int8 v61; // cl
  unsigned __int8 v62; // al
  __int64 v63; // rcx
  _BYTE *v64; // rax
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer; // [rsp+20h] [rbp+0h] BYREF

  if ( !byte_149C79026 )
  {
    _RAX = 1;
    __asm { cpuid }
    dword_149C79044 = _RAX;
    n7 = 7;
    dword_149C7904C = _RCX;
    dword_149C79048 = _RBX;
    dword_149C79118 = _RDX;
    __asm { cpuid }
    dword_149C7B12C = _RAX;
    _RAX = 0x80000007LL;
    dword_149C7B134 = _RCX;
    dword_149C7B130 = _RBX;
    dword_149C7B138 = _RDX;
    __asm { cpuid }
    dword_149C7B13C = _RAX;
    _RAX = 0x80000001LL;
    dword_149C7B144 = _RCX;
    dword_149C7B140 = _RBX;
    dword_149C7B148 = _RDX;
    __asm { cpuid }
    _RAX = 0x80000000LL;
    dword_149C7B14C = _RCX;
    dword_149C7B150 = _RDX;
    __asm { cpuid }
    LODWORD(Buffer.ProcessorMask) = 0xFFFFFFFF;
    v25 = _RAX;
    HIDWORD(Buffer.ProcessorMask) = _RBX;
    Buffer.Relationship = Relationship;
    *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
    if ( (unsigned int)_RAX > 0x80000002 )
    {
      _RAX = 0x80000002LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_1;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149C7B160 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000003 )
    {
      _RAX = 0x80000003LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_2;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149C7B170 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000004 )
    {
      _RAX = 0x80000004LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_3;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149C7B180 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    v41 = 0;
    Buffer.NumaNode.NodeNumber = 0;
    if ( GetLogicalProcessorInformation(0, &Buffer.NumaNode.NodeNumber) || GetLastError() != ERROR_INSUFFICIENT_BUFFER )
      __debugbreak();
    NodeNumber = Buffer.NumaNode.NodeNumber + 0xFLL;
    if ( NodeNumber <= Buffer.NumaNode.NodeNumber )
      NodeNumber = 0xFFFFFFFFFFFFFF0LL;
    size = NodeNumber & 0xFFFFFFFFFFFFFFF0uLL;
    v44 = alloca(size);
    v45 = alloca(size);
    p_Buffer = &Buffer;
    if ( !GetLogicalProcessorInformation(&Buffer, &Buffer.NumaNode.NodeNumber) )
      __debugbreak();
    v47 = (unsigned __int64)Buffer.NumaNode.NodeNumber >> 5;
    if ( v47 )
    {
      v48 = dword_149C7B128;
      do
      {
        if ( p_Buffer->Relationship == RelationProcessorCore )
        {
          v49 = (p_Buffer->ProcessorMask & 0x55) + (((unsigned __int8)p_Buffer->ProcessorMask >> 1) & 0x55);
          v50 = (v49 & 0x33) + ((v49 >> 2) & 0x33);
          v51 = (BYTE1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE1(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v52 = (v51 & 0x33) + ((v51 >> 2) & 0x33);
          v53 = (WORD1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE2(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v54 = (v53 & 0x33) + ((v53 >> 2) & 0x33);
          v55 = (BYTE3(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE3(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v56 = (v55 & 0x33) + ((v55 >> 2) & 0x33);
          v57 = (HIDWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE4(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v58 = (v57 & 0x33) + ((v57 >> 2) & 0x33);
          v59 = (((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) & 0x55)
              + (((unsigned __int8)((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) >> 1) & 0x55);
          v60 = (v59 & 0x33) + ((v59 >> 2) & 0x33);
          v61 = (HIWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE6(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v62 = (HIBYTE(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)HIBYTE(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v48 += (unsigned __int8)((v50 >> 4)
                                 + (v50 & 0xF)
                                 + (v52 >> 4)
                                 + (v52 & 0xF)
                                 + (v54 >> 4)
                                 + (v54 & 0xF)
                                 + (v56 >> 4)
                                 + (v56 & 0xF)
                                 + (v58 >> 4)
                                 + (v58 & 0xF)
                                 + (v60 >> 4)
                                 + (v60 & 0xF)
                                 + ((unsigned __int8)((v61 & 0x33) + ((v61 >> 2) & 0x33)) >> 4)
                                 + (((v61 & 0x33) + ((v61 >> 2) & 0x33)) & 0xF)
                                 + ((unsigned __int8)((v62 & 0x33) + ((v62 >> 2) & 0x33)) >> 4)
                                 + (((v62 & 0x33) + ((v62 >> 2) & 0x33)) & 0xF));
        }
        ++p_Buffer;
        --v47;
      }
      while ( v47 );
      dword_149C7B128 = v48;
    }
    v63 = 0;
    if ( (_BYTE)xmmword_149C7B160 )
    {
      do
      {
        for ( ; *((_BYTE *)&xmmword_149C7B160 + v41) == 0x20; ++v41 )
          ;
        *((_BYTE *)&xmmword_149C7B160 + v63) = *((_BYTE *)&xmmword_149C7B160 + v41);
        if ( *((_BYTE *)&xmmword_149C7B160 + v41) )
        {
          while ( 1 )
          {
            v64 = (char *)&xmmword_149C7B160 + v41;
            ++v63;
            ++v41;
            if ( *v64 == 0x20 )
              break;
            *((_BYTE *)&xmmword_149C7B160 + v63) = *((_BYTE *)&xmmword_149C7B160 + v41);
            if ( !*((_BYTE *)&xmmword_149C7B160 + v41) )
              goto LABEL_27;
          }
        }
        else
        {
LABEL_27:
          if ( v63 )
          {
            if ( *((_BYTE *)&xmmword_149C7B160 + v63 - 1) == 0x20 )
              *((_BYTE *)&xmmword_149C7B160 + v63 - 1) = 0;
          }
        }
      }
      while ( *((_BYTE *)&xmmword_149C7B160 + v41) );
    }
    byte_149C79026 = 1;
  }
}

// --- End Function: sub_1403E74B0 (0x1403E74B0) ---

// --- Function: sub_1403E8F30 (0x1403E8F30) ---
__int64 sub_1403E8F30()
{
  return sub_1402A65A0(1u);
}

// --- End Function: sub_1403E8F30 (0x1403E8F30) ---

// --- Function: sub_1403E8F70 (0x1403E8F70) ---
_QWORD *__fastcall sub_1403E8F70(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)sub_1402A65A0(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A6590(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)sub_1402A65A0(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E8F70 (0x1403E8F70) ---

// --- Function: sub_1403E9230 (0x1403E9230) ---
__int64 __fastcall sub_1403E9230(__int64 a1)
{
  return sub_1402A6590(a1);
}

// --- End Function: sub_1403E9230 (0x1403E9230) ---

// --- Function: sub_1403E9250 (0x1403E9250) ---
__int64 __fastcall sub_1403E9250(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_1402A6590(*(_QWORD *)(a1 + 0x10));
    return sub_1402A6590(a1);
  }
  return result;
}

// --- End Function: sub_1403E9250 (0x1403E9250) ---

// --- Function: sub_1403EB9C0 (0x1403EB9C0) ---
bool __fastcall sub_1403EB9C0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  signed __int64 v2; // r8
  int v3; // eax
  int v4; // edx

  if ( a1 == a2 )
    return 1;
  if ( !a1 || !a2 )
    return 0;
  v2 = a2 - a1;
  do
  {
    v3 = a1[v2];
    v4 = *a1 - v3;
    if ( v4 )
      break;
    ++a1;
  }
  while ( v3 );
  return !v4;
}

// --- End Function: sub_1403EB9C0 (0x1403EB9C0) ---

// --- Function: sub_1403EBA20 (0x1403EBA20) ---
bool __fastcall sub_1403EBA20(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403EBA20 (0x1403EBA20) ---

// --- Function: sub_1403EBBC0 (0x1403EBBC0) ---
char __fastcall sub_1403EBBC0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403EBBC0 (0x1403EBBC0) ---

// --- Function: sub_1403EF1F0 (0x1403EF1F0) ---
__int64 __fastcall sub_1403EF1F0(const char *p_null_1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  return sub_140303440(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EF1F0 (0x1403EF1F0) ---

// --- Function: sub_1403EF370 (0x1403EF370) ---
__int64 __fastcall sub_1403EF370(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  const char *p_null; // r8

  p_null = "null";
  LOBYTE(a4) = 1;
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140303440(a2, a3, p_null, a4);
}

// --- End Function: sub_1403EF370 (0x1403EF370) ---

// --- Function: sub_1403EF4D0 (0x1403EF4D0) ---
__int64 __fastcall sub_1403EF4D0(__int64 a1, __int64 a2, unsigned __int64 n0xC_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n0xC_1 > 0 )
  {
    if ( n0xC_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n0xC_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F91E0(a1, (unsigned int)n0xC + a2, n0xC_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F8B80(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F8DD0(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F8A30(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n0xC_1 )
    {
LABEL_46:
      if ( n0xC_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EF4D0 (0x1403EF4D0) ---

// --- Function: sub_1403EF740 (0x1403EF740) ---
__int64 __fastcall sub_1403EF740(const char *Val, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( Val )
    p_null = Val;
  if ( a5 )
    return sub_140303440(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EF740 (0x1403EF740) ---

// --- Function: sub_1403EF810 (0x1403EF810) ---
__int64 __fastcall sub_1403EF810(__int64 a1, void *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140303440(a2, Size_1, p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EF810 (0x1403EF810) ---

// --- Function: sub_1403EF930 (0x1403EF930) ---
// attributes: thunk
__int64 __fastcall sub_1403EF930(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1404F91E0(a1, a2, a3);
}

// --- End Function: sub_1403EF930 (0x1403EF930) ---

// --- Function: sub_140446700 (0x140446700) ---
char __fastcall sub_140446700(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int64 v11; // rax
  const char *p_null; // rdx
  __int64 v14; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v19; // [rsp+A0h] [rbp-70h]
  const char *p_Asset; // [rsp+A8h] [rbp-68h]
  __int64 v21; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EF810)(__int64, void *, size_t, __int64, char); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EF370)(__int64, __int64, __int64, __int64); // [rsp+C0h] [rbp-50h]
  __int64 v24; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_sub_1403EBA20)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v26; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E9250)(__int64); // [rsp+E0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E8F70)(_QWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v29; // [rsp+F0h] [rbp-20h]
  char v30; // [rsp+F8h] [rbp-18h]
  char v31; // [rsp+F9h] [rbp-17h]
  __int64 n0x18; // [rsp+100h] [rbp-10h]
  unsigned __int64 v33; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  p_Asset = "Asset";
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  v19 = a10;
  __Val_0___[9] = sub_1403E8F30;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v31 = 1;
  v21 = *a10;
  p_sub_1403EF810 = sub_1403EF810;
  p_sub_1403EF370 = sub_1403EF370;
  p_sub_1403EBA20 = sub_1403EBA20;
  p_sub_1403E9250 = sub_1403E9250;
  p_sub_1403E8F70 = sub_1403E8F70;
  v24 = 0;
  v26 = 0;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v30 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  do
    ++v11;
  while ( p_null[v11] );
  v33 = v11;
  LODWORD(v14) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 2u, a5, v14, a7, a8);
}

// --- End Function: sub_140446700 (0x140446700) ---

// --- Function: sub_1404B8EB0 (0x1404B8EB0) ---
_QWORD *sub_1404B8EB0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( !v0 )
  {
    sub_14053EF00("fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A65A0(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1481CF6E0);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B8EB0 (0x1404B8EB0) ---

// --- Function: getThreadLogContextSlot (0x1404C2CA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
int *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n0xF; // rax

  v0 = sub_1404B8EB0();
  v1 = v0;
  if ( !v0 )
    return &dword_149C83B90;
  n0xF = *v0;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (int *)&v1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404C2CA0) ---

// --- Function: sub_1404F8A30 (0x1404F8A30) ---
__int64 __fastcall sub_1404F8A30(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x28] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x28] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x29] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x29] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x2A] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x2A] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x2B] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x2B] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x2C] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x2C] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x2D] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x2D] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x2E] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x2E] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x2F] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x2F] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F8A30 (0x1404F8A30) ---

// --- Function: sub_1404F8B80 (0x1404F8B80) ---
__int64 __fastcall sub_1404F8B80(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x10] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x10] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x11] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x11] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x12] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x12] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x13] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x13] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x14] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x14] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x15] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x15] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x16] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x16] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x17] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x17] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[0x18] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[0x18] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[0x19] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[0x19] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0x1A] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0x1A] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0x1B] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0x1B] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0x1C] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0x1C] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0x1D] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0x1D] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0x1E] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0x1E] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0x1F] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0x1F] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F8B80 (0x1404F8B80) ---

// --- Function: sub_1404F8DD0 (0x1404F8DD0) ---
__int64 __fastcall sub_1404F8DD0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x20] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x20] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x21] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x21] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x22] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x22] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x23] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x23] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x24] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x24] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x25] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x25] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x26] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x26] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x27] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x27] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F8DD0 (0x1404F8DD0) ---

// --- Function: sub_1404F91E0 (0x1404F91E0) ---
__int64 __fastcall sub_1404F91E0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[5] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[6] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[7] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[8] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[9] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0xA] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0xA] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0xB] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0xB] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0xC] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0xC] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0xD] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0xD] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0xE] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0xE] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0xF] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0xF] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F91E0 (0x1404F91E0) ---

// --- Function: sub_1405099D0 (0x1405099D0) ---
__int64 __fastcall sub_1405099D0(_QWORD *a1, __int64 a2, __int64 a3)
{
  return sub_14035D730(a2, a3, 0, *a1);
}

// --- End Function: sub_1405099D0 (0x1405099D0) ---

// --- Function: sub_14051EB30 (0x14051EB30) ---
_QWORD *__fastcall sub_14051EB30(__int64 a1, _QWORD *a2)
{
  char v5; // [rsp+30h] [rbp+8h] BYREF

  if ( !sub_1403113B0((__int64 *)(a1 + 0x20)) )
    *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)gEnv + 0x7F8LL))(
                                          gEnv,
                                          &v5,
                                          a1);
  *a2 = *(_QWORD *)(a1 + 0x20);
  return a2;
}

// --- End Function: sub_14051EB30 (0x14051EB30) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x14053EF50) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x14053EF50) ---

// --- Function: sub_1405722D0 (0x1405722D0) ---
__int64 __fastcall sub_1405722D0(__int64 a1)
{
  int n0x270; // ecx
  int *v3; // r9
  __int64 n0xE3; // r10
  int v5; // edx
  int v6; // ecx
  int *v7; // r9
  __int64 n0x18C; // r10
  int v9; // edx
  int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx

  n0x270 = *(_DWORD *)(a1 + 0x9C8);
  *(_DWORD *)(a1 + 0x9C8) = n0x270 + 1;
  if ( n0x270 >= 0x270 )
  {
    if ( *(_BYTE *)a1 )
    {
      v3 = (int *)(a1 + 4);
      n0xE3 = 0xE3;
      do
      {
        v5 = *v3;
        v6 = v3[1];
        ++v3;
        v3[0xFFFFFFFF] = v3[0x18C]
                       ^ ((v6 & 1) != 0 ? 0x9908B0DF : 0)
                       ^ ((v3[0xFFFFFFFF] ^ (v6 ^ v5) & 0x7FFFFFFEu) >> 1);
        --n0xE3;
      }
      while ( n0xE3 );
      v7 = (int *)(a1 + 0x390);
      n0x18C = 0x18C;
      do
      {
        v9 = *v7;
        v10 = v7[1];
        ++v7;
        v7[0xFFFFFFFF] = v7[0xFFFFFF1C]
                       ^ ((v10 & 1) != 0 ? 0x9908B0DF : 0)
                       ^ ((v7[0xFFFFFFFF] ^ (v10 ^ v9) & 0x7FFFFFFEu) >> 1);
        --n0x18C;
      }
      while ( n0x18C );
      *(_DWORD *)(a1 + 0x9C0) = *(_DWORD *)(a1 + 0x634)
                              ^ ((*(_DWORD *)(a1 + 4) & 1) != 0 ? 0x9908B0DF : 0)
                              ^ ((*(_DWORD *)(a1 + 0x9C0) ^ (*(_DWORD *)(a1 + 4)
                                                           ^ *(_DWORD *)(a1 + 0x9C0))
                                                          & 0x7FFFFFFEu) >> 1);
    }
    *(_DWORD *)(a1 + 0x9C8) = 1;
    n0x270 = 0;
  }
  v11 = *(_DWORD *)(a1 + 4LL * n0x270 + 4);
  v12 = ((((v11 >> 0xB) ^ v11) & 0xFF3A58AD) << 7) ^ (v11 >> 0xB) ^ v11;
  return ((v12 & 0xFFFFDF8C) << 0xF) ^ v12 ^ ((((v12 & 0xFFFFDF8C) << 0xF) ^ v12) >> 0x12);
}

// --- End Function: sub_1405722D0 (0x1405722D0) ---

// --- Function: sub_140572410 (0x140572410) ---
__int64 __fastcall sub_140572410(__int64 a1, int a2)
{
  int v4; // r8d
  __int64 result; // rax
  __int64 n0x26F; // r9
  unsigned int v7; // edx
  int v8; // ecx

  memset((void *)(a1 + 4), 0, 0x9C0u);
  v4 = 1;
  *(_DWORD *)(a1 + 4) = a2;
  result = a1 + 8;
  n0x26F = 0x26F;
  do
  {
    v7 = *(_DWORD *)(result - 4);
    result += 4;
    v8 = v4 + 0x6C078965 * (*(_DWORD *)(result - 8) ^ (v7 >> 0x1E));
    ++v4;
    *(_DWORD *)(result - 4) = v8;
    --n0x26F;
  }
  while ( n0x26F );
  *(_DWORD *)(a1 + 0x9C8) = 0x270;
  return result;
}

// --- End Function: sub_140572410 (0x140572410) ---

// --- Function: sub_140572BD0 (0x140572BD0) ---
char __fastcall sub_140572BD0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149C88FE0;
  if ( !qword_149C88FE0 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E7220("kernel32.dll", "VirtualAlloc");
    qword_149C88FE0 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_140572EA0(a3);
  return 0;
}

// --- End Function: sub_140572BD0 (0x140572BD0) ---

// --- Function: sub_140572D10 (0x140572D10) ---
__int64 __fastcall sub_140572D10(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 0x1000 )
        return 0x1000;
      if ( ++v1 == v2 )
        return 0x1000;
    }
  }
  return 0x1000;
}

// --- End Function: sub_140572D10 (0x140572D10) ---

// --- Function: sub_140572D50 (0x140572D50) ---
__int64 __fastcall sub_140572D50(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149C88FE0;
  if ( !qword_149C88FE0 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E7220("kernel32.dll", "VirtualAlloc");
    qword_149C88FE0 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_140572D50 (0x140572D50) ---

// --- Function: sub_140573D50 (0x140573D50) ---
_QWORD *__fastcall sub_140573D50(_QWORD *a1, unsigned __int8 *Src)
{
  __int64 v3; // rdx
  unsigned __int64 v5; // rax
  unsigned __int8 *Src_1; // rdx
  unsigned __int8 v7; // r8
  unsigned __int8 v8; // dl
  _QWORD *result; // rax

  *a1 = 0;
  v3 = Src[7];
  if ( (v3 & 1) != 0 )
  {
    LOBYTE(v3) = (unsigned __int8)v3 >> 1;
    sub_140575250(a1, v3, 0);
    v5 = Src[7];
    if ( (v5 & 1) != 0 )
      Src_1 = (unsigned __int8 *)(*(_QWORD *)Src & 0xFFFFFFFFFFFFLL);
    else
      Src_1 = Src;
    if ( (*((_BYTE *)a1 + 7) & 1) != 0 )
      memmove((void *)(*a1 & 0xFFFFFFFFFFFFLL), Src_1, 4 * (v5 >> 1));
    else
      memmove(a1, Src_1, 4 * (v5 >> 1));
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)Src;
  }
  v7 = Src[6];
  *((_BYTE *)a1 + 6) ^= (*((_BYTE *)a1 + 6) ^ v7) & 1;
  v8 = Src[7];
  *((_BYTE *)a1 + 7) ^= (*((_BYTE *)a1 + 7) ^ v8) & 1;
  result = a1;
  *((_BYTE *)a1 + 6) = Src[6] ^ (Src[6] ^ v7) & 1;
  *((_BYTE *)a1 + 7) = Src[7] ^ (Src[7] ^ v8) & 1;
  return result;
}

// --- End Function: sub_140573D50 (0x140573D50) ---

// --- Function: sub_140573E20 (0x140573E20) ---
__int64 __fastcall sub_140573E20(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r10
  __int64 v4; // r8

  v3 = 0;
  *(_DWORD *)a1 = *(unsigned __int8 *)(a2 + 6) >> 1;
  *(_BYTE *)(a1 + 0x18) = *(_BYTE *)(a2 + 6) & 1;
  if ( *(_BYTE *)(a2 + 7) >= 2u )
    v3 = a3;
  if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
    v4 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFLL;
  else
    v4 = a2;
  *(_QWORD *)(a1 + 0x10) = v4 + 4 * ((v3 >> 5) - ((unsigned __int64)*(unsigned __int8 *)(a2 + 6) >> 1));
  if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
    a2 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 0x19) = v3 & 0x1F;
  return a1;
}

// --- End Function: sub_140573E20 (0x140573E20) ---

// --- Function: sub_140573EB0 (0x140573EB0) ---
__int64 __fastcall sub_140573EB0(unsigned int *a1, __int64 a2)
{
  unsigned __int64 v2; // r10
  unsigned __int64 v3; // r9

  v2 = *((_QWORD *)a1 + 1);
  v3 = *((_QWORD *)a1 + 2);
  *(_QWORD *)a2 = *((unsigned __int8 *)a1 + 0x19) + 0x20 * ((__int64)(v3 + 4LL * *a1 - v2) >> 2);
  if ( v2 <= v3 )
    *(_BYTE *)(a2 + 8) = ((**((_DWORD **)a1 + 2) >> (0x1F - *((_BYTE *)a1 + 0x19))) & 1) != *((_BYTE *)a1 + 0x18);
  else
    *(_BYTE *)(a2 + 8) = *((_BYTE *)a1 + 0x18) != 0;
  return a2;
}

// --- End Function: sub_140573EB0 (0x140573EB0) ---

// --- Function: sub_140573F30 (0x140573F30) ---
__m256i *__fastcall sub_140573F30(__m256i *a1, __m256i *a2, __int64 a3)
{
  __int64 v3; // rcx
  __m256i *result; // rax

  *a2 = *a1;
  v3 = a2->m256i_u8[0x19];
  a2->m256i_i64[2] += 4 * ((unsigned __int64)(a3 + v3) >> 5);
  result = a2;
  a2->m256i_i8[0x19] = (a3 + v3) & 0x1F;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140573F30 (0x140573F30) ---

// --- Function: sub_140573F60 (0x140573F60) ---
__int64 __fastcall sub_140573F60(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 result; // rax

  v2 = *(unsigned __int8 *)(a1 + 0x19);
  result = 4 * ((unsigned __int64)(a2 + v2) >> 5);
  *(_QWORD *)(a1 + 0x10) += result;
  *(_BYTE *)(a1 + 0x19) = (a2 + v2) & 0x1F;
  return result;
}

// --- End Function: sub_140573F60 (0x140573F60) ---

// --- Function: sub_140573F90 (0x140573F90) ---
char __fastcall sub_140573F90(_BYTE *a1, __int64 a2)
{
  char v4; // cl
  char result; // al

  if ( (a1[6] & 1) != 0 )
    sub_140574EB0();
  else
    sub_140574050(a1);
  v4 = a1[6];
  result = v4 & 0xFE;
  a1[6] = v4 & 0xFE ^ (*(_BYTE *)(a2 + 6) | v4) & 1;
  return result;
}

// --- End Function: sub_140573F90 (0x140573F90) ---

// --- Function: sub_140574050 (0x140574050) ---
__int64 __fastcall sub_140574050(_BYTE *a1, __int64 a2)
{
  unsigned __int8 v2; // al
  char v4; // r13
  unsigned __int8 v5; // al
  char v6; // r8
  unsigned __int8 v8; // di
  unsigned __int8 v9; // bp
  __int64 result; // rax
  __int64 v11; // r8
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  int v14; // r10d
  unsigned int v15; // ecx
  unsigned __int8 v16; // al
  unsigned int v17; // r8d
  int v18; // eax
  unsigned int v19; // r8d
  int v20; // eax
  int v21; // ebx
  __int64 v22; // [rsp+60h] [rbp+8h]
  __int64 v23; // [rsp+68h] [rbp+10h]

  v2 = *(_BYTE *)(a2 + 6);
  v4 = v2 & 1;
  v5 = v2 >> 1;
  v6 = a1[7] >> 1;
  if ( v6 )
  {
    v8 = a1[6] >> 1;
    if ( v8 >= v5 )
      v8 = v5;
    v9 = v5 + (*(_BYTE *)(a2 + 7) >> 1);
    if ( v9 < (unsigned __int8)(v6 + (a1[6] >> 1)) )
      v9 = v6 + (a1[6] >> 1);
  }
  else
  {
    v8 = v5;
    v9 = v5 + (*(_BYTE *)(a2 + 7) >> 1);
  }
  result = sub_140574630(a1);
  if ( v8 < v9 )
  {
    v11 = v8;
    v22 = v8;
    v23 = 0;
    do
    {
      v12 = (unsigned __int8)a1[6];
      if ( v8 < (unsigned __int8)((unsigned __int8)v12 >> 1)
        || (v13 = v12 >> 1, v8 >= v13 + ((unsigned __int8)a1[7] >> 1)) )
      {
        v14 = 0;
      }
      else if ( (a1[7] & 1) != 0 )
      {
        v14 = *(_DWORD *)((*(_QWORD *)a1 & 0xFFFFFFFFFFFFLL) + 4 * (v11 - v13));
      }
      else
      {
        v14 = *(_DWORD *)&a1[4 * (v11 - v13)];
      }
      v15 = *(unsigned __int8 *)(a2 + 6);
      v16 = (unsigned __int8)v15 >> 1;
      if ( v4 )
      {
        if ( v8 < v16 || (v17 = v15 >> 1, v8 >= (v15 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
        {
          v18 = 0xFFFFFFFF;
        }
        else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
        {
          v18 = ~*(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v17));
        }
        else
        {
          v18 = ~*(_DWORD *)(a2 + 4 * (v8 - (unsigned __int64)v17));
        }
      }
      else if ( v8 < v16 || (v19 = v15 >> 1, v8 >= (v15 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
      {
        v18 = 0;
      }
      else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
      {
        v18 = *(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v19));
      }
      else
      {
        v18 = *(_DWORD *)(a2 + 4 * (v8 - (unsigned __int64)v19));
      }
      v20 = v14 | v18;
      v21 = ~v20;
      if ( !v4 )
        v21 = v20;
      result = sub_140574550(a1);
      ++v8;
      v11 = ++v22;
      *(_DWORD *)(result + v23) = v21;
      v23 += 4;
    }
    while ( v8 < v9 );
  }
  return result;
}

// --- End Function: sub_140574050 (0x140574050) ---

// --- Function: sub_140574260 (0x140574260) ---
char __fastcall sub_140574260(__int64 a1, __int64 a2)
{
  unsigned __int8 n2; // dl
  unsigned int v5; // r11d
  unsigned int v6; // esi
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // al
  unsigned __int8 v9; // bp
  __int64 v10; // r8
  bool v11; // cf
  bool v12; // zf
  unsigned int v13; // r14d
  unsigned int v14; // r15d
  unsigned int v15; // r12d
  char v16; // cl
  unsigned int v17; // r13d
  unsigned __int8 v18; // bl
  char v19; // r11
  unsigned __int8 v20; // si
  unsigned int v21; // r9d
  int v22; // r9d
  unsigned int v23; // r9d
  unsigned int v24; // r11d
  int v25; // r8d
  unsigned int v26; // r11d

  n2 = *(_BYTE *)(a1 + 7);
  if ( (n2 >= 2u || (*(_BYTE *)(a1 + 6) & 1) != 0) && (*(_BYTE *)(a2 + 7) >= 2u || (*(_BYTE *)(a2 + 6) & 1) != 0) )
  {
    if ( n2 < 2u && (*(_BYTE *)(a1 + 6) & 1) != 0 )
      return 1;
    v5 = *(unsigned __int8 *)(a2 + 6);
    if ( (v5 & 1) != 0 && (*(_BYTE *)(a1 + 6) & 1) == 0 )
      return 0;
    v6 = *(unsigned __int8 *)(a2 + 7);
    v7 = (unsigned __int8)v5 >> 1;
    v8 = *(_BYTE *)(a1 + 6) >> 1;
    v9 = v8 + (n2 >> 1);
    if ( (unsigned __int8)(((unsigned __int8)v5 >> 1) + ((unsigned __int8)v6 >> 1)) >= v9 )
      v9 = v7 + ((unsigned __int8)v6 >> 1);
    if ( v8 >= v7 )
      v8 = (unsigned __int8)v5 >> 1;
    while ( 1 )
    {
      if ( v8 >= v7 && v8 < (v5 >> 1) + (v6 >> 1) )
      {
        v10 = (v6 & 1) != 0 ? *(_QWORD *)a2 & 0xFFFFFFFFFFFFLL : a2;
        if ( *(_DWORD *)(v10 + 4 * (v8 - (unsigned __int64)(v5 >> 1))) )
          break;
      }
      v11 = v8 < v9;
      v12 = v8 == v9;
      if ( v8 >= v9 )
        goto LABEL_22;
      ++v8;
    }
    v11 = v8 < v9;
    v12 = v8 == v9;
LABEL_22:
    if ( v12 )
      return 0;
    if ( !v11 )
      return 1;
    v13 = *(unsigned __int8 *)(a1 + 6);
    v14 = *(unsigned __int8 *)(a2 + 6);
    v15 = *(unsigned __int8 *)(a1 + 7);
    v16 = v13 & 1;
    v17 = *(unsigned __int8 *)(a2 + 7);
    v18 = (unsigned __int8)v13 >> 1;
    v19 = v14 & 1;
    v20 = (unsigned __int8)v14 >> 1;
    while ( 1 )
    {
      if ( v16 )
      {
        if ( v8 < v18 || (v21 = v13 >> 1, v8 >= (v13 >> 1) + (v15 >> 1)) )
          v22 = 0xFFFFFFFF;
        else
          v22 = (v15 & 1) != 0
              ? ~*(_DWORD *)((*(_QWORD *)a1 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v21))
              : ~*(_DWORD *)(a1 + 4 * (v8 - (unsigned __int64)v21));
      }
      else if ( v8 < v18 || (v23 = v13 >> 1, v8 >= (v13 >> 1) + (v15 >> 1)) )
      {
        v22 = 0;
      }
      else
      {
        v22 = (v15 & 1) != 0
            ? *(_DWORD *)((*(_QWORD *)a1 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v23))
            : *(_DWORD *)(a1 + 4 * (v8 - (unsigned __int64)v23));
      }
      if ( v19 )
      {
        if ( v8 < v20 || (v24 = v14 >> 1, v8 >= (v14 >> 1) + (v17 >> 1)) )
          v25 = 0xFFFFFFFF;
        else
          v25 = (v17 & 1) != 0
              ? ~*(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v24))
              : ~*(_DWORD *)(a2 + 4 * (v8 - (unsigned __int64)v24));
      }
      else if ( v8 < v20 || (v26 = v14 >> 1, v8 >= (v14 >> 1) + (v17 >> 1)) )
      {
        v25 = 0;
      }
      else
      {
        v25 = (v17 & 1) != 0
            ? *(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v26))
            : *(_DWORD *)(a2 + 4 * (v8 - (unsigned __int64)v26));
      }
      if ( (v22 & v25) != v25 )
        break;
      v16 = v13 & 1;
      ++v8;
      v19 = v14 & 1;
      if ( v8 >= v9 )
        return 1;
    }
  }
  return 0;
}

// --- End Function: sub_140574260 (0x140574260) ---

// --- Function: sub_140574550 (0x140574550) ---
__int64 __fastcall sub_140574550(__int64 a1)
{
  if ( (*(_BYTE *)(a1 + 7) & 1) != 0 )
    return *(_QWORD *)a1 & 0xFFFFFFFFFFFFLL;
  else
    return a1;
}

// --- End Function: sub_140574550 (0x140574550) ---

// --- Function: sub_140574630 (0x140574630) ---
char __fastcall sub_140574630(_BYTE *a1, unsigned __int8 a2, unsigned __int8 a3)
{
  _BYTE *v3; // r14
  _BYTE *v4; // rbx
  unsigned __int8 v5; // al
  char v6; // r9
  bool v7; // cf
  __int64 v8; // rdx
  unsigned __int8 v9; // bp
  unsigned __int8 v10; // si
  char result; // al

  v3 = a1 + 6;
  v4 = a1;
  v5 = a1[6] >> 1;
  v6 = a2;
  v7 = v5 < a2;
  v8 = a3;
  if ( v7 )
    v6 = a1[6] >> 1;
  v9 = a1[7] >> 1;
  v10 = (a1[6] >> 1) - v6;
  if ( a3 < (unsigned __int8)(v5 + v9) )
    v8 = (unsigned __int8)(v5 + v9);
  LOBYTE(v8) = v8 - v6;
  sub_140575250(a1, v8, v5);
  if ( (v4[7] & 1) != 0 )
    v4 = (_BYTE *)(*(_QWORD *)v4 & 0xFFFFFFFFFFFFLL);
  memmove(&v4[4 * v9 + 4 * (unsigned __int64)v10 + 0xFFFFFFFC * v9], v4, 4LL * v9);
  memset(v4, 0, 4LL * v10);
  result = (*v3 - 2 * v10) ^ (*v3 ^ (*v3 - 2 * v10)) & 1;
  *v3 = result;
  return result;
}

// --- End Function: sub_140574630 (0x140574630) ---

// --- Function: sub_140574720 (0x140574720) ---
char __fastcall sub_140574720(__int64 a1, unsigned __int64 a2)
{
  unsigned __int8 v2; // r8
  __int64 v3; // r9
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // r10
  unsigned __int8 v6; // dl
  int v7; // eax

  v2 = *(_BYTE *)(a1 + 6);
  v3 = a1;
  v4 = (a2 >> 5) - (v2 >> 1);
  v5 = 0x1F - (a2 & 0x1F);
  v6 = *(_BYTE *)(v3 + 7);
  if ( v4 >= (unsigned __int8)(v6 >> 1) )
    return v2 & 1;
  if ( (v6 & 1) != 0 )
    v3 = *(_QWORD *)v3 & 0xFFFFFFFFFFFFLL;
  v7 = *(_DWORD *)(v3 + 4LL * v4);
  return v2 & 1 ^ _bittest(&v7, v5);
}

// --- End Function: sub_140574720 (0x140574720) ---

// --- Function: sub_140574E40 (0x140574E40) ---
__int64 __fastcall sub_140574E40(__int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // r8
  unsigned __int8 v3; // r9
  unsigned __int8 v5; // dl
  __int64 i; // rcx
  unsigned int v7; // eax

  v1 = *(unsigned __int8 *)(a1 + 7);
  v2 = a1;
  v3 = (unsigned __int8)v1 >> 1;
  if ( !((unsigned __int8)v1 >> 1) )
    return 0;
  if ( (v1 & 1) != 0 )
    v2 = *(_QWORD *)a1 & 0xFFFFFFFFFFFFLL;
  v5 = 0;
  for ( i = v2 + 4 * (v1 >> 1); i != v2; i -= 4 )
  {
    if ( v5 )
      break;
    v7 = *(_DWORD *)(i - 4);
    --v3;
    if ( v7 )
    {
      _BitScanForward(&v7, v7);
      v5 = 0x20 - v7;
    }
  }
  return v5 + 0x20LL * v3;
}

// --- End Function: sub_140574E40 (0x140574E40) ---

// --- Function: sub_140574EB0 (0x140574EB0) ---
void __fastcall sub_140574EB0(__int64 a1, __int64 a2)
{
  unsigned __int8 v4; // di
  char v5; // r13
  unsigned __int8 v6; // r12
  __int64 v7; // r15
  __int64 v8; // rbp
  unsigned int v9; // ecx
  unsigned int v10; // r9d
  int v11; // r10d
  unsigned int v12; // ecx
  unsigned __int8 v13; // al
  unsigned int v14; // r9d
  int v15; // ebx
  unsigned int v16; // r9d

  v4 = *(_BYTE *)(a1 + 6) >> 1;
  v5 = *(_BYTE *)(a2 + 6) & 1;
  v6 = v4 + (*(_BYTE *)(a1 + 7) >> 1);
  if ( v4 < v6 )
  {
    v7 = 0;
    v8 = v4;
    do
    {
      v9 = *(unsigned __int8 *)(a1 + 6);
      if ( v4 < (unsigned __int8)((unsigned __int8)v9 >> 1)
        || (v10 = v9 >> 1, v4 >= (v9 >> 1) + (*(unsigned __int8 *)(a1 + 7) >> 1)) )
      {
        v11 = 0;
      }
      else if ( (*(_BYTE *)(a1 + 7) & 1) != 0 )
      {
        v11 = *(_DWORD *)((*(_QWORD *)a1 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - v10));
      }
      else
      {
        v11 = *(_DWORD *)(a1 + 4 * (v8 - v10));
      }
      v12 = *(unsigned __int8 *)(a2 + 6);
      v13 = (unsigned __int8)v12 >> 1;
      if ( v5 )
      {
        if ( v4 < v13 || (v14 = v12 >> 1, v4 >= (v12 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
        {
          v15 = 0xFFFFFFFF;
        }
        else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
        {
          v15 = ~*(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v4 - (unsigned __int64)v14));
        }
        else
        {
          v15 = ~*(_DWORD *)(a2 + 4 * (v4 - (unsigned __int64)v14));
        }
      }
      else if ( v4 < v13 || (v16 = v12 >> 1, v4 >= (v12 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
      {
        v15 = 0;
      }
      else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
      {
        v15 = *(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v4 - (unsigned __int64)v16));
      }
      else
      {
        v15 = *(_DWORD *)(a2 + 4 * (v4 - (unsigned __int64)v16));
      }
      ++v4;
      ++v8;
      *(_DWORD *)(sub_140574550(a1) + v7) = v11 & ~v15;
      v7 += 4;
    }
    while ( v4 < v6 );
  }
}

// --- End Function: sub_140574EB0 (0x140574EB0) ---

// --- Function: sub_140575060 (0x140575060) ---
__int64 __fastcall sub_140575060(_BYTE *a1, __int64 a2)
{
  __int64 result; // rax

  if ( (a1[6] & 1) != 0 )
    sub_140574050(a1, a2);
  else
    sub_140574EB0((__int64)a1, a2);
  result = *(unsigned __int8 *)(a2 + 6);
  LOBYTE(result) = ~(_BYTE)result | 0xFE;
  a1[6] &= result;
  return result;
}

// --- End Function: sub_140575060 (0x140575060) ---

// --- Function: sub_140575250 (0x140575250) ---
unsigned __int64 __fastcall sub_140575250(_BYTE *a1, unsigned __int8 a2, unsigned __int8 a3)
{
  bool v5; // r13
  char v6; // r12
  __int64 v7; // r14
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // r15
  unsigned __int8 v10; // r15
  unsigned __int64 allocSize; // rbp
  void *v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int8 v14; // al
  unsigned __int64 result; // rax

  v5 = a2 > 1u;
  v6 = a1[7] & 1;
  if ( v6 )
    v7 = *(_QWORD *)a1 & 0xFFFFFFFFFFFFLL;
  else
    v7 = (__int64)a1;
  v8 = a1[6] >> 1;
  v9 = a3;
  if ( a3 < v8 )
    v9 = v8;
  v10 = v9 - v8;
  if ( a2 <= 1u )
  {
    v13 = (unsigned __int64)a1;
  }
  else
  {
    allocSize = saturated_mul(a2, 4u);
    v12 = (void *)sub_1402A65A0(allocSize);
    v13 = (unsigned __int64)v12;
    if ( v12 )
      memset(v12, 0, allocSize);
    else
      v13 = 0;
  }
  v14 = a2;
  if ( (unsigned __int8)(a1[7] >> 1) < a2 )
    v14 = a1[7] >> 1;
  result = (unsigned __int64)memmove(
                               (void *)v13,
                               (const void *)(v7 + 4LL * v10),
                               4 * (v10 + (unsigned __int64)v14) - 4LL * v10);
  if ( v6 )
    result = sub_1402A6590(v7);
  if ( a2 <= 1u )
  {
    if ( !a2 )
      *(_DWORD *)a1 = 0;
  }
  else
  {
    result = v13 ^ (*(_QWORD *)a1 ^ v13) & 0xFFFF000000000000uLL;
    *(_QWORD *)a1 = result;
  }
  a1[7] = v5 | (2 * a2);
  return result;
}

// --- End Function: sub_140575250 (0x140575250) ---

// --- Function: LogFatalError (0x1405C60F0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149C8DEA0;
  if ( !qword_149C8DEA0 )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&qword_149C8DEA0);
    v1 = (__int64 (*)(void))qword_149C8DEA0;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149C8E0F8 || !qword_149C8DFE0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A6BE0();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149C8DFE0 + 0x118LL))(
                      qword_149C8DFE0,
                      &format_string_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C60F0) ---

// --- Function: unknown_libname_38 (0x1407EE850) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_38()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_38 (0x1407EE850) ---

// --- Function: sub_140844100 (0x140844100) ---
char __fastcall sub_140844100(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned __int16 v4; // ax
  int v5; // r8d
  int v6; // eax
  float v7; // ecx

  if ( *a2 == a2[1] )
  {
    v4 = 1;
  }
  else
  {
    v4 = *(_WORD *)(*a2 + 8 * a1 + 6);
    if ( !v4 )
      return v4;
  }
  v5 = v4;
  v6 = (v4 & 0x7FFF) << 0xD;
  LODWORD(v7) = v6 + 0x38000000;
  if ( (v6 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v7) = v6 + 0x70000000;
  }
  else if ( (v6 & 0xF800000) == 0 )
  {
    v7 = COERCE_FLOAT(v6 + 0x38800000) + -0.000061035156;
  }
  LOBYTE(v4) = sub_140574720(a3, (int)COERCE_FLOAT((v5 << 0x10) & 0x80000000 | LODWORD(v7)));
  return v4;
}

// --- End Function: sub_140844100 (0x140844100) ---

// --- Function: sub_140844BC0 (0x140844BC0) ---
unsigned __int64 __fastcall sub_140844BC0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v6; // rbx
  __int64 v7; // rdx
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r15
  __int64 v12; // rax
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // r12
  __int64 v15; // rsi
  __int64 v16; // rbx
  unsigned __int64 i; // rdi
  unsigned __int64 j; // rsi
  __int64 v19; // rbx
  __int64 v20; // rsi
  __int64 v21; // r8
  unsigned __int64 result; // rax

  v3 = a2;
  v6 = (a2 - *a1) / 0xF8;
  v7 = (a1[1] - *a1) / 0xF8;
  if ( v7 == 0x108421084210842LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0xF8;
  if ( v9 > 0x108421084210842LL - (v9 >> 1) )
    goto LABEL_30;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x108421084210842LL )
    goto LABEL_30;
  v11 = 0xF8 * v10;
  if ( 0xF8 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = sub_1402A65A0(0xF8 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_30:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_28;
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_13:
  v14 = v13 + 0xF8 * v6;
  sub_140849E50(v14, a3);
  v15 = a1[1];
  v16 = *a1;
  if ( v3 == v15 )
  {
    for ( i = v13; v16 != v15; v16 += 0xF8 )
    {
      sub_140849E50(i, v16);
      i += 0xF8LL;
    }
  }
  else
  {
    for ( j = v13; v16 != v3; v16 += 0xF8 )
    {
      sub_140849E50(j, v16);
      j += 0xF8LL;
    }
    v19 = a1[1];
    if ( v3 != v19 )
    {
      v20 = v14 - v3 + 0xF8;
      do
      {
        sub_140849E50(v20 + v3, v3);
        v3 += 0xF8;
      }
      while ( v3 != v19 );
    }
  }
  v21 = *a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(0xF8 * ((a1[2] - v21) / 0xF8)) < 0x1000 )
    {
LABEL_26:
      sub_1402A6590(v21);
      goto LABEL_27;
    }
    if ( (unsigned __int64)(v21 - *(_QWORD *)(v21 - 8) - 8) <= 0x1F )
    {
      v21 = *(_QWORD *)(v21 - 8);
      goto LABEL_26;
    }
LABEL_28:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_27:
  *a1 = v13;
  result = v14;
  a1[1] = v13 + 0xF8 * v8;
  a1[2] = v11 + v13;
  return result;
}

// --- End Function: sub_140844BC0 (0x140844BC0) ---

// --- Function: sub_140845070 (0x140845070) ---
unsigned __int64 __fastcall sub_140845070(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbx
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r15
  __int64 v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // r13
  __int64 v15; // rbp
  __int64 v16; // rbx
  unsigned __int64 i; // rdi
  _QWORD *v18; // rbx
  _QWORD *j; // rdi
  __int64 v20; // r8
  unsigned __int64 result; // rax

  v6 = (a2 - *a1) / 0x38;
  v7 = (a1[1] - *a1) / 0x38;
  if ( v7 == 0x492492492492492LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x38;
  if ( v9 > 0x492492492492492LL - (v9 >> 1) )
    goto LABEL_30;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x492492492492492LL )
    goto LABEL_30;
  v11 = 0x38 * v10;
  if ( 0x38 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = sub_1402A65A0(0x38 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_30:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_28;
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_13:
  v14 = v13 + 0x38 * v6;
  sub_140849F90(v14, a3);
  v15 = a1[1];
  v16 = *a1;
  if ( a2 == v15 )
  {
    for ( i = v13; v16 != v15; v16 += 0x38 )
    {
      sub_140849F90(i, v16);
      i += 0x38LL;
    }
  }
  else
  {
    sub_140845340(*a1, a2, v13, a1);
    sub_140845340(a2, a1[1], v14 + 0x38, a1);
  }
  v18 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( j = (_QWORD *)a1[1]; v18 != j; v18 += 7 )
    {
      if ( *v18 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v18 + 8LL))(*v18);
      *v18 = 0;
    }
    v20 = *a1;
    if ( (unsigned __int64)(0x38 * ((a1[2] - *a1) / 0x38)) < 0x1000 )
      goto LABEL_26;
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
LABEL_26:
      sub_1402A6590(v20);
      goto LABEL_27;
    }
LABEL_28:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_27:
  *a1 = v13;
  result = v14;
  a1[1] = v13 + 0x38 * v8;
  a1[2] = v11 + v13;
  return result;
}

// --- End Function: sub_140845070 (0x140845070) ---

// --- Function: sub_140845340 (0x140845340) ---
__int64 __fastcall sub_140845340(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx

  for ( i = a1; i != a2; i += 0x38 )
  {
    sub_140849F90(a3, i);
    a3 += 0x38;
  }
  return a3;
}

// --- End Function: sub_140845340 (0x140845340) ---

// --- Function: sub_1408453C0 (0x1408453C0) ---
unsigned __int64 __fastcall sub_1408453C0(__int64 *a1, _DWORD *a2, unsigned __int64 a3)
{
  __int64 v3; // r11
  __int64 v4; // rbp
  unsigned __int64 v5; // r9
  __int64 v7; // rbx
  __int64 v13; // rcx
  __int64 v14; // rcx

  v3 = a1[3];
  v4 = *a1;
  v5 = v3 & (a3 >> 7);
  v7 = 0;
  _XMM2 = a3 & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    _XMM1 = *(_OWORD *)(v5 + v4);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_1482B5BB0
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      return 0xFFFFFFFFFFFFFFFFuLL;
    v7 += 0x10;
    v5 = v3 & (v7 + v5);
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v13, _EAX);
    v14 = v3 & (v5 + v13);
    if ( **(_DWORD **)(a1[1] + 8 * v14) == *a2 )
      return v14;
    _EAX &= _EAX - 1;
    if ( !_EAX )
      goto LABEL_5;
  }
}

// --- End Function: sub_1408453C0 (0x1408453C0) ---

// --- Function: sub_1408454A0 (0x1408454A0) ---
char __fastcall sub_1408454A0(
        int n4_1,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10,
        __int64 a11)
{
  void *v11; // rsp
  __int64 v13; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  __int64 v18; // [rsp+A0h] [rbp-E0h]
  const char *p_Unnamed_ULong; // [rsp+A8h] [rbp-D8h]
  __int64 v20; // [rsp+B0h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1405099D0)(_QWORD *, __int64, __int64); // [rsp+B8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1405099D0_1)(_QWORD *, __int64, __int64); // [rsp+C0h] [rbp-C0h]
  __int64 v23; // [rsp+C8h] [rbp-B8h]
  bool (__fastcall *p_??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_pt)(_QWORD *, _QWORD *); // [rsp+D0h] [rbp-B0h]
  __int64 v25; // [rsp+D8h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E9230)(__int64); // [rsp+E0h] [rbp-A0h]
  __int64 (__fastcall *p_sub_1403E8F30)(); // [rsp+E8h] [rbp-98h]
  unsigned __int64 v28; // [rsp+F0h] [rbp-90h]
  __int16 v29; // [rsp+F8h] [rbp-88h]
  __int64 n8; // [rsp+100h] [rbp-80h]
  __int64 n0x15; // [rsp+108h] [rbp-78h]
  __int64 v32; // [rsp+110h] [rbp-70h]
  const char *p_Unnamed_UInt; // [rsp+118h] [rbp-68h]
  __int64 v34; // [rsp+120h] [rbp-60h]
  __int64 (__fastcall *p_sub_1405099B0)(); // [rsp+128h] [rbp-58h]
  __int64 (__fastcall *p_sub_1405099B0_1)(); // [rsp+130h] [rbp-50h]
  __int64 v37; // [rsp+138h] [rbp-48h]
  bool (__fastcall *p_unknown_libname)(_DWORD *, _DWORD *); // [rsp+140h] [rbp-40h]
  __int64 v39; // [rsp+148h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E9230_1)(__int64); // [rsp+150h] [rbp-30h]
  __int64 (__fastcall *p_sub_1403E8F30_1)(); // [rsp+158h] [rbp-28h]
  unsigned __int64 v42; // [rsp+160h] [rbp-20h]
  __int16 v43; // [rsp+168h] [rbp-18h]
  __int64 n4; // [rsp+170h] [rbp-10h]
  __int64 n0x15_1; // [rsp+178h] [rbp-8h]

  v11 = alloca(0x150);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  v18 = a10;
  p_Unnamed_ULong = "Unnamed_ULong";
  p_sub_1405099D0 = sub_1405099D0;
  p_sub_1405099D0_1 = sub_1405099D0;
  p_??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_pt = std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>;
  p_sub_1403E9230 = sub_1403E9230;
  p_sub_1403E8F30 = sub_1403E8F30;
  v32 = a11;
  p_Unnamed_UInt = "Unnamed_UInt";
  p_sub_1405099B0 = sub_1405099B0;
  p_sub_1405099B0_1 = sub_1405099B0;
  p_unknown_libname = unknown_libname_19;
  p_sub_1403E9230_1 = sub_1403E9230;
  p_sub_1403E8F30_1 = sub_1403E8F30;
  LODWORD(v13) = a6;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v29 = 0;
  v20 = 0;
  v23 = 0;
  v25 = 0;
  v28 = 0xFFFFFFFFFFFFFFFFuLL;
  n8 = 8;
  n0x15 = 0x15;
  v43 = 0;
  v34 = 0;
  v37 = 0;
  v39 = 0;
  v42 = 0xFFFFFFFFFFFFFFFFuLL;
  n4 = 4;
  n0x15_1 = 0x15;
  return sub_140306CF0(n4_1, a2, a3, a4, (__int64)__Val_0___, 3u, a5, v13, a7, a8);
}

// --- End Function: sub_1408454A0 (0x1408454A0) ---

// --- Function: sub_1408456C0 (0x1408456C0) ---
char __fastcall sub_1408456C0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        const char **a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        __int64 a22,
        __int64 a23,
        __int64 a24,
        __int64 a25,
        __int64 a26,
        __int64 a27,
        __int64 a28,
        __int64 a29,
        __int64 a30,
        __int64 a31,
        __int64 a32,
        __int64 a33,
        __int64 a34,
        __int64 a35,
        __int64 a36,
        __int64 a37,
        __int64 a38,
        __int64 a39,
        __int64 a40,
        __int64 a41,
        __int64 a42,
        __int64 a43,
        __int64 a44,
        __int64 a45,
        __int64 a46,
        __int64 a47,
        __int64 a48,
        __int64 a49)
{
  void *v53; // rsp
  unsigned __int64 v54; // rdx
  const char *p_null_1; // rcx
  const char *p_null; // rax
  __int64 v58; // [rsp+18h] [rbp-12A8h]
  _QWORD __Val_0___[11]; // [rsp+120h] [rbp-11A0h] BYREF
  __int16 n0x100; // [rsp+178h] [rbp-1148h]
  __int64 n0xB0; // [rsp+180h] [rbp-1140h]
  __int64 n0xA8; // [rsp+188h] [rbp-1138h]
  const char *p_null_2; // [rsp+190h] [rbp-1130h]
  const char *p_Unnamed_Text; // [rsp+198h] [rbp-1128h]
  __int64 v65; // [rsp+1A0h] [rbp-1120h]
  __int64 (__fastcall *p_sub_1403EF740)(const char *, _BYTE *, size_t, __int64, char); // [rsp+1A8h] [rbp-1118h]
  __int64 (__fastcall *p_sub_1403EF1F0)(const char *, _BYTE *, int); // [rsp+1B0h] [rbp-1110h]
  __int64 v68; // [rsp+1B8h] [rbp-1108h]
  bool (__fastcall *p_sub_1403EB9C0)(unsigned __int8 *, unsigned __int8 *); // [rsp+1C0h] [rbp-1100h]
  __int64 v70; // [rsp+1C8h] [rbp-10F8h]
  __int64 (__fastcall *p_sub_1403E9230)(__int64); // [rsp+1D0h] [rbp-10F0h]
  __int64 (__fastcall *p_sub_1403E8F30)(); // [rsp+1D8h] [rbp-10E8h]
  unsigned __int64 v73; // [rsp+1E0h] [rbp-10E0h]
  __int16 v74; // [rsp+1E8h] [rbp-10D8h]
  __int64 n8; // [rsp+1F0h] [rbp-10D0h]
  unsigned __int64 v76; // [rsp+1F8h] [rbp-10C8h]
  __int64 v77; // [rsp+200h] [rbp-10C0h] BYREF

  v53 = alloca(0x11F0);
  v54 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  p_null_1 = *a10;
  p_Unnamed_Text = "Unnamed_Text";
  p_null_2 = p_null_1;
  p_sub_1403EF740 = sub_1403EF740;
  p_sub_1403EF1F0 = sub_1403EF1F0;
  p_sub_1403EB9C0 = sub_1403EB9C0;
  p_sub_1403E9230 = sub_1403E9230;
  p_sub_1403E8F30 = sub_1403E8F30;
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  v74 = 0;
  v65 = 0;
  v68 = 0;
  v70 = 0;
  v73 = 0xFFFFFFFFFFFFFFFFuLL;
  n8 = 8;
  do
    ++v54;
  while ( p_null[v54] );
  v76 = v54 + 2;
  sub_140847BB0(
    (unsigned int)&v77,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26,
    a27,
    a28,
    a29,
    a30,
    a31,
    a32,
    a33,
    a34,
    a35,
    a36,
    a37,
    a38,
    a39,
    a40,
    a41,
    a42,
    a43,
    a44,
    a45,
    a46,
    a47,
    a48,
    a49);
  LODWORD(v58) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 0x29u, a5, v58, a7, a8);
}

// --- End Function: sub_1408456C0 (0x1408456C0) ---

// --- Function: sub_1408470D0 (0x1408470D0) ---
__int64 __fastcall sub_1408470D0(
        __int64 a1,
        const char **a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        __int64 a22,
        __int64 a23,
        __int64 a24,
        __int64 a25,
        __int64 a26,
        __int64 a27,
        __int64 a28,
        __int64 a29,
        __int64 a30,
        __int64 a31,
        __int64 a32,
        __int64 a33,
        __int64 a34)
{
  const char *p_null_1; // rax
  const char *p_null; // rdx
  unsigned __int64 v36; // rax

  p_null_1 = *a2;
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = "Unnamed_Text";
  *(_WORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0x30) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  *(_QWORD *)(a1 + 0x10) = 0;
  v36 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 8;
  do
    ++v36;
  while ( p_null[v36] );
  *(_QWORD *)(a1 + 0x68) = v36 + 2;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0xE8) = "Unnamed_ULong";
  *(_QWORD *)(a1 + 0x78) = "Unnamed_UInt";
  *(_QWORD *)(a1 + 0xF8) = sub_1405099D0;
  *(_WORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0x100) = sub_1405099D0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x110) = std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>;
  *(_QWORD *)(a1 + 0x88) = sub_1405099B0;
  *(_QWORD *)(a1 + 0x120) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x128) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_QWORD *)(a1 + 0x90) = sub_1405099B0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = unknown_libname_19;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9230;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 4;
  *(_QWORD *)(a1 + 0xD8) = 0x15;
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_WORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x140) = 8;
  *(_QWORD *)(a1 + 0x148) = 0x15;
  *(_QWORD *)(a1 + 0x158) = "Unnamed_UInt";
  *(_WORD *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = sub_1405099B0;
  *(_QWORD *)(a1 + 0x170) = sub_1405099B0;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = unknown_libname_19;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x190) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x198) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x1B0) = 4;
  *(_QWORD *)(a1 + 0x1B8) = 0x15;
  return sub_140846580(
           (int)a1 + 0x1C0,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34)
       + 4;
}

// --- End Function: sub_1408470D0 (0x1408470D0) ---

// --- Function: sub_1408477E0 (0x1408477E0) ---
__int64 __fastcall sub_1408477E0(
        __int64 a1,
        const char **a2,
        const char **a3,
        const char **a4,
        const char **a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        __int64 a22,
        __int64 a23,
        __int64 a24,
        __int64 a25,
        __int64 a26,
        __int64 a27,
        __int64 a28,
        __int64 a29,
        __int64 a30,
        __int64 a31,
        __int64 a32,
        __int64 a33,
        __int64 a34,
        __int64 a35,
        __int64 a36,
        __int64 a37)
{
  const char *p_null_2; // rax
  unsigned __int64 v39; // rdx
  const char *p_null; // r8
  const char *p_null_1; // r9
  unsigned __int64 v43; // rax
  const char *p_null_3; // r9
  const char *p_null_4; // rax
  bool v46; // zf
  unsigned __int64 v47; // rax
  const char *p_null_5; // rax

  p_null_2 = *a2;
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = "Unnamed_Text";
  *(_WORD *)(a1 + 0x58) = 0;
  v39 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  p_null = "null";
  *(_QWORD *)(a1 + 0x38) = 0;
  p_null_1 = "null";
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 8;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0x30) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  if ( p_null_2 )
    p_null_1 = p_null_2;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  v43 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v43;
  while ( p_null_1[v43] );
  p_null_3 = "null";
  *(_QWORD *)(a1 + 0x68) = v43 + 2;
  p_null_4 = *a3;
  v46 = *a3 == 0;
  *(_QWORD *)(a1 + 0x70) = *a3;
  *(_QWORD *)(a1 + 0x78) = "Unnamed_Text";
  if ( !v46 )
    p_null_3 = p_null_4;
  *(_WORD *)(a1 + 0xC8) = 0;
  v47 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x90) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9230;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 8;
  do
    ++v47;
  while ( p_null_3[v47] );
  *(_QWORD *)(a1 + 0xD8) = v47 + 2;
  p_null_5 = *a4;
  v46 = *a4 == 0;
  *(_QWORD *)(a1 + 0xE0) = *a4;
  *(_QWORD *)(a1 + 0xE8) = "Unnamed_Text";
  if ( !v46 )
    p_null = p_null_5;
  *(_WORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x100) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x128) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x140) = 8;
  do
    ++v39;
  while ( p_null[v39] );
  *(_QWORD *)(a1 + 0x148) = v39 + 2;
  return sub_1408470D0(
           a1 + 0x150,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37)
       + 3;
}

// --- End Function: sub_1408477E0 (0x1408477E0) ---

// --- Function: sub_140847BB0 (0x140847BB0) ---
__int64 __fastcall sub_140847BB0(
        __int64 a1,
        const char **a2,
        const char **a3,
        const char **a4,
        const char **a5,
        const char **a6,
        const char **a7,
        const char **a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        __int64 a22,
        __int64 a23,
        __int64 a24,
        __int64 a25,
        __int64 a26,
        __int64 a27,
        __int64 a28,
        __int64 a29,
        __int64 a30,
        __int64 a31,
        __int64 a32,
        __int64 a33,
        __int64 a34,
        __int64 a35,
        __int64 a36,
        __int64 a37,
        __int64 a38,
        __int64 a39,
        __int64 a40)
{
  const char *p_null_2; // rax
  unsigned __int64 v42; // rdx
  const char *p_null; // r8
  const char *p_null_1; // r9
  unsigned __int64 v46; // rax
  const char *p_null_3; // r9
  const char *p_null_4; // rax
  bool v49; // zf
  unsigned __int64 v50; // rax
  const char *p_null_5; // rax

  p_null_2 = *a2;
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = "Unnamed_Text";
  *(_WORD *)(a1 + 0x58) = 0;
  v42 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  p_null = "null";
  *(_QWORD *)(a1 + 0x38) = 0;
  p_null_1 = "null";
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 8;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0x30) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  if ( p_null_2 )
    p_null_1 = p_null_2;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  v46 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v46;
  while ( p_null_1[v46] );
  p_null_3 = "null";
  *(_QWORD *)(a1 + 0x68) = v46 + 2;
  p_null_4 = *a3;
  v49 = *a3 == 0;
  *(_QWORD *)(a1 + 0x70) = *a3;
  *(_QWORD *)(a1 + 0x78) = "Unnamed_Text";
  if ( !v49 )
    p_null_3 = p_null_4;
  *(_WORD *)(a1 + 0xC8) = 0;
  v50 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x90) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9230;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 8;
  do
    ++v50;
  while ( p_null_3[v50] );
  *(_QWORD *)(a1 + 0xD8) = v50 + 2;
  p_null_5 = *a4;
  v49 = *a4 == 0;
  *(_QWORD *)(a1 + 0xE0) = *a4;
  *(_QWORD *)(a1 + 0xE8) = "Unnamed_Text";
  if ( !v49 )
    p_null = p_null_5;
  *(_WORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x100) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x128) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x140) = 8;
  do
    ++v42;
  while ( p_null[v42] );
  *(_QWORD *)(a1 + 0x148) = v42 + 2;
  return sub_1408477E0(
           a1 + 0x150,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40)
       + 3;
}

// --- End Function: sub_140847BB0 (0x140847BB0) ---

// --- Function: sub_140848420 (0x140848420) ---
__int64 __fastcall sub_140848420(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // rbx
  __int64 v5; // rbp
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rbx
  __int64 v9; // rbp
  __int64 v10; // r14
  _QWORD *v11; // rdx
  _QWORD *v12; // rbx
  _QWORD *i; // rcx
  __int64 v14; // r15
  __int64 v15; // rax
  std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle> > *_Al; // r8
  _QWORD *v17; // rbx

  v2 = *(_QWORD **)(a1 + 8);
  if ( (unsigned __int64)v2 < *(_QWORD *)(a1 + 0x10) )
  {
    v5 = *a2;
    *v2 = 0;
    v2[1] = 0;
    v6 = sub_1402A65A0(0x18u);
    if ( v6 )
    {
      *(_DWORD *)(v6 + 8) = 1;
      *(_QWORD *)v6 = off_148341E50;
      *(_DWORD *)(v6 + 0xC) = 1;
      *(_QWORD *)(v6 + 0x10) = v5;
    }
    else
    {
      v6 = 0;
    }
    v2[1] = v6;
    *v2 = v5;
    *(_QWORD *)(a1 + 8) += 0x10LL;
    return *(_QWORD *)(a1 + 8) - 0x10LL;
  }
  v8 = ((__int64)v2 - *(_QWORD *)a1) >> 4;
  if ( !v8 )
  {
    v9 = 1;
    goto LABEL_10;
  }
  v9 = 2 * v8;
  if ( 2 * v8 )
  {
LABEL_10:
    v10 = sub_1402A65A0(0x10 * v9);
    goto LABEL_11;
  }
  v10 = 0;
LABEL_11:
  v11 = *(_QWORD **)(a1 + 8);
  v12 = (_QWORD *)v10;
  for ( i = *(_QWORD **)a1; i != v11; i += 2 )
  {
    *v12 = 0;
    v12[1] = 0;
    *v12 = *i;
    v12[1] = i[1];
    v12 += 2;
    *i = 0;
    i[1] = 0;
  }
  v14 = *a2;
  *v12 = 0;
  v12[1] = 0;
  v15 = sub_1402A65A0(0x18u);
  if ( v15 )
  {
    *(_DWORD *)(v15 + 8) = 1;
    *(_QWORD *)v15 = off_148341E50;
    *(_DWORD *)(v15 + 0xC) = 1;
    *(_QWORD *)(v15 + 0x10) = v14;
  }
  else
  {
    v15 = 0;
  }
  *v12 = v14;
  v12[1] = v15;
  v17 = v12 + 2;
  std::_Destroy_range<std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle>>>(
    *(std::shared_ptr<gte::ETManifoldMesh::Triangle> **)a1,
    *(std::shared_ptr<gte::ETManifoldMesh::Triangle> *const *)(a1 + 8),
    _Al);
  if ( *(_QWORD *)a1 )
    sub_1402A6590(*(_QWORD *)a1);
  result = (__int64)(v17 + 0xFFFFFFFE);
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 0x10) = v10 + 0x10 * v9;
  *(_QWORD *)(a1 + 8) = v17;
  return result;
}

// --- End Function: sub_140848420 (0x140848420) ---

// --- Function: sub_1408485B0 (0x1408485B0) ---
__int64 __fastcall sub_1408485B0(_QWORD *a1, __int64 a2)
{
  std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle> > *_Al; // r8
  char *v4; // rsi
  __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rcx
  char *v11; // r9
  int v15; // r8d
  bool v16; // zf
  int v17; // edx
  int v18; // eax
  bool v19; // r8
  char v20; // dl
  char *v21; // [rsp+28h] [rbp-20h] BYREF
  __int64 *v22; // [rsp+30h] [rbp-18h]

  sub_1408486F0(a1, &v21, a2);
  v4 = v21;
  if ( v21 == (char *)(a1[3] + *a1) )
    return 0;
  v6 = *v22;
  std::_Destroy_range<std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle>>>(
    *(std::shared_ptr<gte::ETManifoldMesh::Triangle> **)(*v22 + 0x10),
    *(std::shared_ptr<gte::ETManifoldMesh::Triangle> *const *)(*v22 + 0x18),
    _Al);
  v7 = *(_QWORD *)(v6 + 0x10);
  if ( v7 )
    sub_1402A6590(v7);
  v8 = *(_QWORD *)(v6 + 8);
  if ( v8 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x10LL))(v8);
  *(_QWORD *)(v6 + 8) = 0;
  sub_1402A6590(v6);
  --a1[2];
  _XMM2 = xmmword_1482B5BB0;
  __asm { vpcmpeqb xmm1, xmm2, xmmword ptr [rsi] }
  v11 = &v4[-*a1];
  __asm { vpmovmskb eax, xmm1 }
  __asm
  {
    vpcmpeqb xmm1, xmm2, xmmword ptr [rcx+r10]
    vpmovmskb ecx, xmm1
  }
  v19 = 0;
  if ( _ECX && _EAX )
  {
    _BitScanForward((unsigned int *)&v15, _EAX);
    v16 = !_BitScanReverse((unsigned int *)&v17, _ECX << 0x10);
    v18 = v16 ? 0x20 : 0x1F - v17;
    if ( (unsigned int)(v15 + v18) < 0x10 )
      v19 = 1;
  }
  v20 = 0xFE;
  if ( v19 )
    v20 = 0x80;
  *v4 = v20;
  *(_BYTE *)((a1[3] & 0xFLL) + ((unsigned __int64)(v11 + 0xFFFFFFF0) & a1[3]) + *a1 + 1) = v20;
  a1[6] += v19;
  return 1;
}

// --- End Function: sub_1408485B0 (0x1408485B0) ---

// --- Function: sub_1408486F0 (0x1408486F0) ---
_QWORD *__fastcall sub_1408486F0(__int64 *a1, _QWORD *a2, _DWORD *a3)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // r8
  __int64 v12; // rcx
  __int64 v16; // r11
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v21; // rdx

  v4 = a1[3];
  v7 = 0;
  v8 = (__PAIR128__((unsigned int)*a3, (unsigned int)*a3) * 0xDE5FB9D2630458E9uLL) >> 0x40;
  v9 = v4 & (v8 >> 7);
  _XMM2 = v8 & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v12 = *a1;
    _XMM1 = *(_OWORD *)(*a1 + v9);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_1482B5BB0
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = v4 + v12;
      return a2;
    }
    v7 += 0x10LL;
    v9 = v4 & (v7 + v9);
    if ( v7 > v4 )
      __debugbreak();
  }
  v16 = a1[1];
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v17, _EAX);
    v18 = v4 & (v9 + v17);
    if ( **(_DWORD **)(v16 + 8 * v18) == *a3 )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v12 = *a1;
      goto LABEL_7;
    }
  }
  v21 = v18 + *a1;
  a2[1] = v16 + 8 * v18;
  *a2 = v21;
  return a2;
}

// --- End Function: sub_1408486F0 (0x1408486F0) ---

// --- Function: sub_140849190 (0x140849190) ---
void __fastcall sub_140849190(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  if ( a2 )
  {
    v2 = a1 + 0x28;
    do
    {
      *(_DWORD *)(v2 + 0x21) = 0;
      *(_WORD *)(v2 + 0x25) = 0;
      *(_BYTE *)(v2 + 0x27) = 0;
      *(_QWORD *)(v2 - 0x28) = 0x5F138D352E5096AFLL;
      *(_QWORD *)(v2 - 0x20) = 0x5F138D352E5096AFLL;
      *(_QWORD *)(v2 - 0x18) = 0x5F138D352E5096AFLL;
      *(_QWORD *)(v2 - 0x10) = 0xDF138D352E5096AFuLL;
      *(_QWORD *)(v2 - 8) = 0xDF138D352E5096AFuLL;
      *(_QWORD *)v2 = 0xDF138D352E5096AFuLL;
      *(_QWORD *)(v2 + 8) = 0xFFFFFFFFFFFFFFFFuLL;
      *(_QWORD *)(v2 + 0x10) = 0xFFFFFFFFFFFFFFFFuLL;
      *(_QWORD *)(v2 + 0x18) = 0xFFFFFFFFFFFFFFFFuLL;
      *(_BYTE *)(v2 + 0x20) = 0;
      v2 += 0x50;
      --a2;
    }
    while ( a2 );
  }
}

// --- End Function: sub_140849190 (0x140849190) ---

// --- Function: sub_1408493A0 (0x1408493A0) ---
__int64 __fastcall sub_1408493A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  int v4; // esi
  __int64 v6; // r8
  unsigned __int64 v7; // rax

  v2 = a2 + 0x48;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 0x48;
  *(_BYTE *)(a1 + 0x10) = 1;
  v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v4 )
  {
    ++*(_DWORD *)(v2 + 0x14);
    return a1;
  }
  else
  {
    v6 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v7 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( v7 )
      sub_1403E1120(v2, v7, v6, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v2 + 8) = v6;
    *(_DWORD *)(v2 + 0x10) = v4;
    return a1;
  }
}

// --- End Function: sub_1408493A0 (0x1408493A0) ---

// --- Function: sub_140849440 (0x140849440) ---
_QWORD *__fastcall sub_140849440(_QWORD *a1, __int64 a2)
{
  char *v3; // rcx
  __int64 v4; // rax
  __int64 v6; // rdi
  __int64 v7; // rdi

  v3 = 0;
  v4 = (__int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2;
  if ( v4 )
  {
    v6 = 4 * v4;
    v3 = (char *)sub_1402A65A0(4 * v4);
  }
  else
  {
    v6 = 0;
  }
  *a1 = v3;
  a1[2] = &v3[v6];
  a1[1] = v3;
  v7 = *(_QWORD *)(a2 + 8);
  if ( *(_QWORD *)a2 == v7 )
    a1[1] = v3;
  else
    a1[1] = (char *)memmove(v3, *(const void **)a2, v7 - *(_QWORD *)a2) + 4 * ((v7 - a2) >> 2);
  return a1;
}

// --- End Function: sub_140849440 (0x140849440) ---

// --- Function: sub_140849540 (0x140849540) ---
__int64 __fastcall sub_140849540(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        _QWORD *a5,
        unsigned __int8 *Src,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        _DWORD *a10,
        char *a11)
{
  __int128 v11; // xmm6
  __int16 n0xFFFF; // ax
  _QWORD *v16; // rax
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // r15
  __int64 v20; // rcx
  __int64 v21; // rax
  void (__fastcall ***v22)(_QWORD); // r14
  __int64 v23; // rcx
  char v24; // r14
  __int64 v25; // rdi
  char v26; // r14
  __int64 v27; // rcx
  int v28; // ebx
  int *ThreadLogContextSlot; // rax
  char v30; // al
  __int64 v31; // rcx
  unsigned __int64 v32; // rbx
  __int128 v33; // xmm6
  _QWORD *i; // rdi
  __int128 v35; // kr00_16
  __int64 v36; // r8
  unsigned __int64 v37; // rax
  unsigned __int64 v38; // rdx
  __int64 v39; // r9
  __int64 result; // rax
  __int64 (__fastcall *v41)(__int64, __int128 *, __int16 *); // [rsp+50h] [rbp-B0h] BYREF
  __int16 v42[2]; // [rsp+58h] [rbp-A8h] BYREF
  int v43; // [rsp+5Ch] [rbp-A4h]
  _BYTE v44[8]; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v45; // [rsp+68h] [rbp-98h]
  __int64 v46; // [rsp+70h] [rbp-90h]
  __int64 v47; // [rsp+78h] [rbp-88h]
  __int64 v48; // [rsp+80h] [rbp-80h]
  __int64 v49; // [rsp+88h] [rbp-78h]
  int n0x900; // [rsp+90h] [rbp-70h] BYREF
  __int64 v51; // [rsp+94h] [rbp-6Ch]
  int v52; // [rsp+9Ch] [rbp-64h]
  unsigned __int64 v53; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v54; // [rsp+A8h] [rbp-58h]
  __int64 v55; // [rsp+B0h] [rbp-50h]
  __int64 v56; // [rsp+B8h] [rbp-48h]
  _QWORD v57[2]; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v58; // [rsp+F0h] [rbp-10h]
  __int128 v59; // [rsp+F8h] [rbp-8h] BYREF
  _QWORD v60[2]; // [rsp+108h] [rbp+8h] BYREF
  _QWORD v61[2]; // [rsp+118h] [rbp+18h] BYREF
  int n0xF5; // [rsp+128h] [rbp+28h] BYREF
  int n0x1C; // [rsp+12Ch] [rbp+2Ch]
  int n0x95; // [rsp+130h] [rbp+30h]
  int n0x7A; // [rsp+134h] [rbp+34h]
  int n0x31; // [rsp+138h] [rbp+38h]
  int n0xBC; // [rsp+13Ch] [rbp+3Ch]
  _QWORD v68[2]; // [rsp+140h] [rbp+40h] BYREF
  __int128 v69; // [rsp+150h] [rbp+50h]

  v69 = v11;
  *(_WORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x14) = 0;
  *(_DWORD *)(a1 + 0x1C) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  v45 = a7;
  v49 = a8;
  v48 = a9;
  *(_QWORD *)a1 = off_14833E5A8;
  *(_QWORD *)(a1 + 8) = off_14833E5A0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = &unk_1482B6E60;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_WORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = 0;
  *(_DWORD *)(a1 + 0xE8) = 0;
  v43 = a3;
  v41 = 0;
  sub_140573D50((_QWORD *)(a1 + 0xF0), Src);
  *(_DWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x100) = &p_Src;
  *(_DWORD *)(a1 + 0x108) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x10C) = 0;
  *(_QWORD *)(a1 + 0x110) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x130) = 0;
  *(_QWORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = 0;
  *(_QWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = &p_Src;
  *(_DWORD *)(a1 + 0x170) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x174) = 0;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = &p_Src;
  *(_DWORD *)(a1 + 0x1A0) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x1A4) = 0;
  *(_QWORD *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0;
  *(_QWORD *)(a1 + 0x1B8) = 0;
  *(_QWORD *)(a1 + 0x1C4) = 0;
  *(_QWORD *)(a1 + 0x1CC) = 0;
  *(_WORD *)(a1 + 0x1DC) = 0;
  *(_DWORD *)(a1 + 0x1C0) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x1D4) = 0x12345678;
  *(_DWORD *)(a1 + 0x1D8) = 0x41400000;
  *(_QWORD *)(a1 + 0x1E0) = 0;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F0) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x200) = 0;
  *(_QWORD *)(a1 + 0x208) = 0;
  *(_QWORD *)(a1 + 0x210) = 0;
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0;
  *(_QWORD *)(a1 + 0x228) = 0;
  *(_QWORD *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x238) = 0;
  *(_QWORD *)(a1 + 0x240) = 0;
  *(_QWORD *)(a1 + 0x248) = 0;
  *(_QWORD *)(a1 + 0x250) = 0;
  *(_QWORD *)(a1 + 0x258) = 0;
  *(_QWORD *)(a1 + 0x260) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = 0;
  *(_QWORD *)(a1 + 0x278) = 0;
  *(_QWORD *)(a1 + 0x280) = 0;
  *(_QWORD *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x290) = 0;
  *(_QWORD *)(a1 + 0x298) = 0;
  *(_QWORD *)(a1 + 0x2A0) = 0;
  *(_QWORD *)(a1 + 0x2A8) = 0;
  *(_QWORD *)(a1 + 0x2B0) = 0;
  *(_QWORD *)(a1 + 0x2B8) = 0;
  *(_QWORD *)(a1 + 0x2C0) = 0;
  *(_DWORD *)(a1 + 0x2C8) = 0;
  *(_QWORD *)(a1 + 0x2CC) = 0;
  *(_DWORD *)(a1 + 0x2D4) = 0;
  *(_BYTE *)(a1 + 0x2D8) = 0;
  *(_QWORD *)(a1 + 0x140) = a2;
  v47 = a2 & 0xFFFFFFFFFFFFLL;
  v41 = *(__int64 (__fastcall **)(__int64, __int128 *, __int16 *))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF = n0xFFFF_13;
  if ( n0xFFFF_13 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                          qword_149C8DFC8,
                          v44,
                          "IEntityRenderProxy");
    n0xFFFF_13 = n0xFFFF;
  }
  v42[0] = n0xFFFF;
  v16 = (_QWORD *)v41(a2 & 0xFFFFFFFFFFFFLL, &v59, v42);
  v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*v16 & 0xFFFFFFFFFFFFLL) + 0x5D8LL))(*v16 & 0xFFFFFFFFFFFFLL);
  v18 = *(_QWORD *)(a1 + 0x130);
  v19 = v17;
  if ( v18 != a4 )
  {
    if ( a4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)a4 + 8LL))(a4);
    v20 = *(_QWORD *)(a1 + 0x130);
    if ( v20 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x10LL))(v20);
    *(_QWORD *)(a1 + 0x130) = a4;
    v18 = a4;
  }
  if ( v18 )
  {
    v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x70LL))(v18);
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v21 + 0xB0LL))(v21) )
      *(_BYTE *)(a1 + 0xC1) = 1;
  }
  v22 = (void (__fastcall ***)(_QWORD))*a5;
  if ( *(_QWORD *)(a1 + 0x128) != *a5 )
  {
    if ( v22 )
      (**v22)(*a5);
    v23 = *(_QWORD *)(a1 + 0x128);
    if ( v23 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v23 + 8LL))(v23);
    *(_QWORD *)(a1 + 0x128) = v22;
  }
  *(_QWORD *)(a1 + 0x138) = *sub_14051EB30(v19, &v41);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x1D0LL))(v19) != a1 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v19 + 0x1D8LL))(v19, a1);
  sub_140850620(a1, a2, v19, v45);
  v24 = *a11;
  v25 = (*(__int64 (**)(void))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))();
  v26 = v24 & 2;
  if ( v26 )
    *(_WORD *)(a1 + 0x1DC) |= 1u;
  else
    *(_WORD *)(a1 + 0x1DC) &= ~1u;
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 0xBC));
  v27 = *(_QWORD *)(v25 + 0x10);
  v46 = a1;
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 0xBC));
  sub_14084B070(v27);
  if ( v26 && *(_QWORD *)(*(_QWORD *)(a1 + 0x120) + 0x18LL) == *(_QWORD *)(*(_QWORD *)(a1 + 0x120) + 0x20LL) )
    sub_140856FA0(v25, a1);
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0xBC), 0xFFFFFFFF) <= 1 )
  {
    sub_14084A700(a1);
    sub_1402A6590(a1);
  }
  if ( *(float *)(*(_QWORD *)(a1 + 0x120) + 0x70LL) <= 0.00000011920929 )
  {
    n0xF5 = 0xF5;
    v60[0] = &n0xF5;
    n0x1C = 0x1C;
    v60[1] = v68;
    n0x95 = 0x95;
    n0x7A = 0x7A;
    n0x31 = 0x31;
    n0xBC = 0xBC;
    v28 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)v60,
            (__int64)"Insufficient Texel Length",
            "Average texel length is too small, the UV layout of this mesh will need to be improved in order to work with Damage Maps!");
    if ( (v28 & 0xFFFFF) != 0 )
    {
      v57[1] = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x128) + 0x348LL))(*(_QWORD *)(a1 + 0x128));
      v57[0] = 0;
      v58 = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      n0xF5 = 0xF5;
      v61[0] = &n0xF5;
      n0x1C = 0x1C;
      v61[1] = v68;
      n0x95 = 0x95;
      v59 = 0;
      n0x7A = 0x7A;
      n0x31 = 0x31;
      n0xBC = 0xBC;
      sub_140446700(
        3,
        (__int64)v61,
        "Insufficient Texel Length",
        (__int64)"Average texel length is too small, the UV layout of this mesh will need to be improved in order to work"
                 " with Damage Maps!",
        2,
        v28,
        &v59,
        0,
        (__int64)ThreadLogContextSlot,
        v57);
      sub_1402A6590(v58);
    }
  }
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v47 + 0x728LL))(v47) )
    sub_14084CFF0(a1 + 8, (unsigned __int16)v43);
  v30 = *a11 & 1;
  n0x900 = 0x900;
  *(_BYTE *)(a1 + 0xC0) = v30;
  v51 = 0;
  v52 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v53 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFD0,
    "CDamageMap::MT_CalculateSurfaceArea",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x7B8);
  v31 = *(_QWORD *)(a1 + 0x120);
  v32 = 0;
  HIWORD(n0x900) = word_149D7FFD0;
  v33 = 0;
  for ( i = (_QWORD *)(v31 + 0x30); v32 < *(unsigned int *)(v31 + 0x4C); ++v32 )
  {
    if ( sub_140574720(a1 + 0xF0, v32) )
    {
      v35 = v33;
      *(float *)&v35 = *(float *)&v33 + *(float *)(*i + 8 * v32);
      v33 = v35;
    }
    v31 = *(_QWORD *)(a1 + 0x120);
  }
  *(float *)(a1 + 0xB8) = *(float *)&v33;
  v36 = *(_QWORD *)(a1 + 0x40);
  v37 = *(unsigned int *)(v31 + 0x4C);
  v38 = (*(_QWORD *)(a1 + 0x48) - v36) >> 4;
  if ( v37 <= v38 )
    *(_QWORD *)(a1 + 0x48) = v36 + 0x10 * v37;
  else
    sub_14084DAC0(a1 + 0x40, v37 - v38);
  v54 = __rdtsc();
  qword_149C89AA8(&n0x900);
  if ( v26 )
  {
    v39 = *(_QWORD *)(a1 + 0x120);
    if ( v39 )
    {
      if ( *(_DWORD *)(v39 + 0x58) == *a10 )
        sub_140859F10(a1, v49, v48);
    }
  }
  sub_14085CA50(a1);
  if ( *a5 )
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a5 + 8LL))(*a5);
  result = a1;
  *a5 = 0;
  return result;
}

// --- End Function: sub_140849540 (0x140849540) ---

// --- Function: sub_140849E50 (0x140849E50) ---
__int64 __fastcall sub_140849E50(__int64 a1, __int64 a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 0xC) = *(_DWORD *)(a2 + 0xC);
  *(_DWORD *)(a1 + 0x10) = *(_DWORD *)(a2 + 0x10);
  *(_DWORD *)(a1 + 0x14) = *(_DWORD *)(a2 + 0x14);
  *(_DWORD *)(a1 + 0x18) = *(_DWORD *)(a2 + 0x18);
  *(_DWORD *)(a1 + 0x1C) = *(_DWORD *)(a2 + 0x1C);
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x20);
  *(_DWORD *)(a1 + 0x24) = *(_DWORD *)(a2 + 0x24);
  *(_DWORD *)(a1 + 0x28) = *(_DWORD *)(a2 + 0x28);
  *(_DWORD *)(a1 + 0x2C) = *(_DWORD *)(a2 + 0x2C);
  *(double *)(a1 + 0x30) = *(double *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x38) = *(_DWORD *)(a2 + 0x38);
  *(_DWORD *)(a1 + 0x3C) = *(_DWORD *)(a2 + 0x3C);
  *(double *)(a1 + 0x40) = *(double *)(a2 + 0x40);
  *(_DWORD *)(a1 + 0x48) = *(_DWORD *)(a2 + 0x48);
  *(_QWORD *)(a1 + 0x50) = *(_QWORD *)(a2 + 0x50);
  *(_OWORD *)(a1 + 0x58) = *(_OWORD *)(a2 + 0x58);
  *(_OWORD *)(a1 + 0x68) = *(_OWORD *)(a2 + 0x68);
  *(_OWORD *)(a1 + 0x78) = *(_OWORD *)(a2 + 0x78);
  *(_OWORD *)(a1 + 0x88) = *(_OWORD *)(a2 + 0x88);
  *(_OWORD *)(a1 + 0x98) = *(_OWORD *)(a2 + 0x98);
  *(_OWORD *)(a1 + 0xA8) = *(_OWORD *)(a2 + 0xA8);
  *(_OWORD *)(a1 + 0xB8) = *(_OWORD *)(a2 + 0xB8);
  *(_OWORD *)(a1 + 0xC8) = *(_OWORD *)(a2 + 0xC8);
  *(_DWORD *)(a1 + 0xD8) = *(_DWORD *)(a2 + 0xD8);
  *(_QWORD *)(a1 + 0xE0) = *(_QWORD *)(a2 + 0xE0);
  *(_BYTE *)(a1 + 0xE8) = *(_BYTE *)(a2 + 0xE8);
  *(_DWORD *)(a1 + 0xEC) = *(_DWORD *)(a2 + 0xEC);
  *(_DWORD *)(a1 + 0xF0) = *(_DWORD *)(a2 + 0xF0);
  *(_DWORD *)(a1 + 0xF4) = *(_DWORD *)(a2 + 0xF4);
  return a1;
}

// --- End Function: sub_140849E50 (0x140849E50) ---

// --- Function: sub_140849F90 (0x140849F90) ---
__int64 __fastcall sub_140849F90(__int64 a1, __int64 a2)
{
  void (__fastcall ***v4)(_QWORD); // rcx

  v4 = *(void (__fastcall ****)(_QWORD))a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  if ( v4 )
    (**v4)(v4);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_DWORD *)(a1 + 0x24) = *(_DWORD *)(a2 + 0x24);
  *(_DWORD *)(a1 + 0x18) = *(_DWORD *)(a2 + 0x18);
  *(_DWORD *)(a1 + 0x1C) = *(_DWORD *)(a2 + 0x1C);
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x20);
  *(double *)(a1 + 0x28) = *(double *)(a2 + 0x28);
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x34) = *(_DWORD *)(a2 + 0x34);
  return a1;
}

// --- End Function: sub_140849F90 (0x140849F90) ---

// --- Function: sub_14084A000 (0x14084A000) ---
__int64 __fastcall sub_14084A000(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5)
{
  void (__fastcall ***v7)(_QWORD); // rcx
  __int64 result; // rax

  v7 = (void (__fastcall ***)(_QWORD))*a2;
  *(_QWORD *)a1 = *a2;
  if ( v7 )
    (**v7)(v7);
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a4;
  *(_DWORD *)(a1 + 0x24) = *(_DWORD *)(a5 + 0xC);
  *(_DWORD *)(a1 + 0x18) = *(_DWORD *)a5;
  *(_DWORD *)(a1 + 0x1C) = *(_DWORD *)(a5 + 4);
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a5 + 8);
  *(double *)(a1 + 0x28) = *(double *)(a5 + 0x10);
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a5 + 0x18);
  *(_DWORD *)(a1 + 0x34) = *(_DWORD *)(a5 + 0x1C);
  if ( *a2 )
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 8LL))(*a2);
  result = a1;
  *a2 = 0;
  return result;
}

// --- End Function: sub_14084A000 (0x14084A000) ---

// --- Function: sub_14084A460 (0x14084A460) ---
void *__fastcall sub_14084A460(__int64 *a1)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  void *result; // rax

  if ( a1[3] )
  {
    v2 = 0;
    do
    {
      if ( *(char *)(v2 + *a1) >= 0 )
      {
        v3 = *(_QWORD *)(a1[1] + 8 * v2);
        if ( (*(_BYTE *)(v3 + 0x17) & 1) != 0 && (*(_QWORD *)(v3 + 0x10) & 0xFFFFFFFFFFFFLL) != 0 )
          sub_1402A6590(*(_QWORD *)(v3 + 0x10) & 0xFFFFFFFFFFFFLL);
        sub_1402A6590(v3);
      }
      ++v2;
    }
    while ( v2 != a1[3] );
    sub_1402A6590(*a1);
    result = &unk_1482B6E60;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 0;
    a1[6] = 0;
    *a1 = (__int64)&unk_1482B6E60;
  }
  return result;
}

// --- End Function: sub_14084A460 (0x14084A460) ---

// --- Function: sub_14084A510 (0x14084A510) ---
__int64 __fastcall sub_14084A510(__int64 *a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    if ( (unsigned __int64)(0xF8 * ((a1[2] - v2) / 0xF8)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = *(_QWORD *)(v2 - 8);
    }
    sub_1402A6590(v2);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_14084A510 (0x14084A510) ---

// --- Function: sub_14084A590 (0x14084A590) ---
__int64 __fastcall sub_14084A590(__int64 *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rdi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 7 )
    {
      if ( *v1 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v1 + 8LL))(*v1);
      *v1 = 0;
    }
    v4 = *a1;
    if ( (unsigned __int64)(0x38 * ((a1[2] - *a1) / 0x38)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    result = sub_1402A6590(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_14084A590 (0x14084A590) ---

// --- Function: sub_14084A700 (0x14084A700) ---
__int64 __fastcall sub_14084A700(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  volatile signed __int32 *v6; // rdi
  __int64 v7; // rcx
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx

  *(_QWORD *)a1 = off_14833E5A8;
  sub_140853590();
  *(_QWORD *)(a1 + 0x218) = *(_QWORD *)(a1 + 0x210);
  *(_QWORD *)(a1 + 0x230) = *(_QWORD *)(a1 + 0x228);
  *(_QWORD *)(a1 + 0x1E8) = *(_QWORD *)(a1 + 0x1E0);
  *(_QWORD *)(a1 + 0x200) = *(_QWORD *)(a1 + 0x1F8);
  *(_QWORD *)(a1 + 0x28) = *(_QWORD *)(a1 + 0x20);
  sub_14084A910();
  v2 = *(_QWORD *)(a1 + 0x1A8);
  if ( v2 )
    sub_1402A6590(v2);
  sub_14084A590((__int64 *)(a1 + 0x178));
  sub_14084A510((__int64 *)(a1 + 0x148));
  v3 = *(_QWORD *)(a1 + 0x130);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x10LL))(v3);
  *(_QWORD *)(a1 + 0x130) = 0;
  v4 = *(_QWORD *)(a1 + 0x128);
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
  *(_QWORD *)(a1 + 0x128) = 0;
  v5 = *(_QWORD *)(a1 + 0x120);
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x10LL))(v5);
  *(_QWORD *)(a1 + 0x120) = 0;
  v6 = *(volatile signed __int32 **)(a1 + 0x118);
  if ( v6 )
  {
    if ( _InterlockedExchangeAdd(v6 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v6)(v6);
      if ( _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
    }
  }
  if ( (*(_BYTE *)(a1 + 0xF7) & 1) != 0 && (*(_QWORD *)(a1 + 0xF0) & 0xFFFFFFFFFFFFLL) != 0 )
    sub_1402A6590(*(_QWORD *)(a1 + 0xF0) & 0xFFFFFFFFFFFFLL);
  v7 = *(_QWORD *)(a1 + 0xC8);
  if ( v7 )
    sub_1402A6590(v7);
  result = (__int64)sub_14084A460((__int64 *)(a1 + 0x80));
  v9 = *(_QWORD *)(a1 + 0x58);
  if ( v9 )
    result = sub_1402A6590(v9);
  v10 = *(_QWORD *)(a1 + 0x40);
  if ( v10 )
    result = sub_1402A6590(v10);
  v11 = *(_QWORD *)(a1 + 0x20);
  if ( v11 )
    return sub_1402A6590(v11);
  return result;
}

// --- End Function: sub_14084A700 (0x14084A700) ---

// --- Function: sub_14084A910 (0x14084A910) ---
__int64 __fastcall sub_14084A910(__int64 *a1)
{
  __int64 v2; // rcx
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx

  v2 = a1[0x18];
  if ( v2 )
    result = sub_1402A6590(v2);
  v4 = a1[0x15];
  if ( v4 )
    result = sub_1402A6590(v4);
  v5 = a1[0xC];
  if ( v5 )
    result = sub_1402A6590(v5);
  v6 = a1[9];
  if ( v6 )
    result = sub_1402A6590(v6);
  v7 = a1[6];
  if ( v7 )
    result = sub_1402A6590(v7);
  v8 = a1[3];
  if ( v8 )
    result = sub_1402A6590(v8);
  if ( *a1 )
    return sub_1402A6590(*a1);
  return result;
}

// --- End Function: sub_14084A910 (0x14084A910) ---

// --- Function: sub_14084B070 (0x14084B070) ---
__int64 __fastcall sub_14084B070(__int64 a1, __int64 *a2, unsigned int a3)
{
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // r8
  volatile signed __int64 *v8; // rdi
  unsigned int v9; // esi
  int v10; // ebx
  __int64 v11; // r8
  unsigned __int64 v12; // rax
  __int64 v13; // rbx
  __int64 *v14; // r15
  __int64 v15; // rax
  __int64 v16; // rsi
  __int64 (__fastcall *p__InterlockedIncrement_w)(__int64); // rdx
  __int64 v18; // r8
  __int64 v19; // rdx
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rdx
  volatile signed __int64 *v22; // rcx
  int v23; // eax
  unsigned __int64 n0x200000; // rax
  volatile signed __int32 *v25; // rbx
  __int64 v26; // rcx
  volatile signed __int32 *v27; // rsi
  __int64 v28; // r14
  __int64 v29; // rsi
  __int64 v30; // rcx
  volatile signed __int32 *v31; // rbx
  int v32; // eax
  unsigned __int64 n0x200000_1; // rax
  __int64 v35; // [rsp+38h] [rbp-31h] BYREF
  __int64 v36; // [rsp+40h] [rbp-29h]
  volatile signed __int32 *v37; // [rsp+48h] [rbp-21h]
  _QWORD v38[2]; // [rsp+50h] [rbp-19h] BYREF
  __int64 v39; // [rsp+60h] [rbp-9h] BYREF
  __int64 v40; // [rsp+68h] [rbp-1h]
  char v41; // [rsp+70h] [rbp+7h]
  char v42[8]; // [rsp+78h] [rbp+Fh] BYREF
  _QWORD *v43; // [rsp+80h] [rbp+17h]
  unsigned int v44; // [rsp+D8h] [rbp+6Fh] BYREF
  unsigned int v45; // [rsp+E0h] [rbp+77h]
  __int64 v46; // [rsp+E8h] [rbp+7Fh] BYREF

  v45 = a3;
  if ( *(_QWORD *)(*a2 + 0x110) )
    sub_1408605C0();
  v5 = *(_QWORD *)(*a2 + 0x128);
  if ( v5 )
  {
    v6 = (*(__int64 (**)(void))(*(_QWORD *)v5 + 0x28LL))();
    v7 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v7;
    while ( *(_BYTE *)(v6 + v7) );
    v8 = (volatile signed __int64 *)(a1 + 0x38);
    v9 = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_149A5EC28[0])(0xFFFFFFFF, v6, v7);
    v10 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x48) == v10 )
    {
      ++*(_DWORD *)(a1 + 0x4C);
    }
    else
    {
      v11 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v12 = _InterlockedCompareExchange64(v8, 0x200000, 0);
      if ( v12 )
        sub_1403E1120((__int64)v8, v12, v11, "CDamageMapPool::AddDamageMap", "m_geometryDataLock", 1);
      else
        *(_QWORD *)(a1 + 0x40) = v11;
      *(_DWORD *)(a1 + 0x48) = v10;
    }
    v13 = *a2;
    v35 = v13;
    if ( v13 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v13 + 0xBC));
      v13 = v35;
    }
    v44 = v9;
    sub_1408486F0((__int64 *)a1, v38, &v44);
    if ( v38[0] == *(_QWORD *)a1 + *(_QWORD *)(a1 + 0x18) )
    {
      sub_140861F50(a1, v42, &v44);
      v14 = (__int64 *)(*v43 + 8LL);
      v15 = sub_1402A65A0(0x78u);
      v16 = v15;
      if ( v15 )
      {
        *(_QWORD *)v15 = off_1482B75A8;
        *(_QWORD *)v15 = off_14833E588;
        *(_DWORD *)(v15 + 0x48) = v44;
        *(_DWORD *)(v15 + 0x50) = v45;
        *(_DWORD *)(v15 + 8) = 0;
        *(_QWORD *)(v15 + 0x10) = 0;
        *(_QWORD *)(v15 + 0x18) = 0;
        *(_QWORD *)(v15 + 0x20) = 0;
        *(_QWORD *)(v15 + 0x28) = 0;
        *(_QWORD *)(v15 + 0x30) = 0;
        *(_QWORD *)(v15 + 0x38) = 0;
        *(_QWORD *)(v15 + 0x40) = 0;
        *(_DWORD *)(v15 + 0x4C) = 0;
        *(_QWORD *)(v15 + 0x54) = 0;
        *(_QWORD *)(v15 + 0x5C) = 0;
        *(_QWORD *)(v15 + 0x64) = 0;
        *(_QWORD *)(v15 + 0x6C) = 0;
        p__InterlockedIncrement_w = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 8LL);
        if ( p__InterlockedIncrement_w == InterlockedIncrement_w )
        {
          LODWORD(v46) = _InterlockedIncrement((volatile signed __int32 *)(v15 + 8));
          v13 = v35;
        }
        else
        {
          p__InterlockedIncrement_w(v15);
        }
      }
      else
      {
        v16 = 0;
      }
      if ( *v14 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)*v14 + 0x10LL))(*v14);
      *v14 = v16;
      v46 = v13;
      if ( v13 )
        _InterlockedIncrement((volatile signed __int32 *)(v13 + 0xBC));
      sub_14084B8D0(a1, &v46, v16);
    }
    else
    {
      v14 = (__int64 *)(*(_QWORD *)v38[1] + 8LL);
    }
    sub_140862390(&v35);
    sub_14084E4F0(a1, (void *)(*a2 + 0xF0));
    if ( v36 )
    {
      sub_1408493A0((__int64)&v39, v36);
      v18 = *(_QWORD *)(v39 + 8);
      v19 = *(_QWORD *)(v39 + 0x10);
      if ( v18 == v19 )
      {
        v20 = v45 * (unsigned __int64)v45;
        v21 = (v19 - v18) >> 2;
        if ( v20 <= v21 )
          *(_QWORD *)(v39 + 0x10) = v18 + 4 * v20;
        else
          sub_14084DC50(v39 + 8, v20 - v21);
      }
      v22 = (volatile signed __int64 *)v40;
      if ( v40 && v41 )
      {
        v23 = *(_DWORD *)(v40 + 0x14);
        if ( v23 )
        {
          *(_DWORD *)(v40 + 0x14) = v23 - 1;
        }
        else
        {
          *(_DWORD *)(v40 + 0x10) = 0xFFFFFFFF;
          n0x200000 = _InterlockedCompareExchange64(v22, 0, 0x200000);
          if ( n0x200000 == 0x200000 )
            *(_QWORD *)(v40 + 8) = &p_Src;
          else
            rw_lock_handle_write_release_contention(v40, n0x200000);
        }
      }
      v25 = v37;
      v26 = *a2;
      if ( v37 )
      {
        _InterlockedIncrement(v37 + 2);
        v25 = v37;
      }
      v27 = *(volatile signed __int32 **)(v26 + 0x118);
      *(_QWORD *)(v26 + 0x110) = v36;
      *(_QWORD *)(v26 + 0x118) = v25;
      if ( v27 )
      {
        if ( _InterlockedExchangeAdd(v27 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v27)(v27);
          if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v27 + 8LL))(v27);
        }
        v25 = v37;
      }
      v28 = *a2;
      v29 = *v14;
      if ( *(_QWORD *)(*a2 + 0x120) != *v14 )
      {
        if ( v29 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v29 + 8LL))(*v14);
        v30 = *(_QWORD *)(v28 + 0x120);
        if ( v30 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x10LL))(v30);
        *(_QWORD *)(v28 + 0x120) = v29;
      }
    }
    else
    {
      v25 = v37;
    }
    if ( v25 )
    {
      if ( _InterlockedExchangeAdd(v25 + 2, 0xFFFFFFFF) == 1 )
      {
        v31 = v37;
        (**(void (__fastcall ***)(volatile signed __int32 *))v37)(v37);
        if ( _InterlockedExchangeAdd(v31 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v37 + 8LL))(v37);
      }
    }
    if ( v8 )
    {
      v32 = *((_DWORD *)v8 + 5);
      if ( v32 )
      {
        *((_DWORD *)v8 + 5) = v32 - 1;
      }
      else
      {
        *((_DWORD *)v8 + 4) = 0xFFFFFFFF;
        n0x200000_1 = _InterlockedCompareExchange64(v8, 0, 0x200000);
        if ( n0x200000_1 == 0x200000 )
          *((_QWORD *)v8 + 1) = &p_Src;
        else
          rw_lock_handle_write_release_contention((__int64)v8, n0x200000_1);
      }
    }
  }
  return sub_140862390(a2);
}

// --- End Function: sub_14084B070 (0x14084B070) ---

// --- Function: _InterlockedIncrement_w_0 (0x14084B4C0) ---
void __fastcall sub_14084B4C0(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 0xBC));
}

// --- End Function: _InterlockedIncrement_w_0 (0x14084B4C0) ---

// --- Function: sub_14084B4D0 (0x14084B4D0) ---
double __fastcall sub_14084B4D0(_QWORD *a1, unsigned int a2, __int64 a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int128 v5; // xmm8
  __int64 v6; // rdi
  __int64 v9; // rsi
  __int128 v10; // xmm7
  __int128 v11; // xmm6
  __int64 v12; // rax
  float v13; // xmm0_4
  __int128 v14; // kr00_16
  __int128 v15; // kr00_16
  double v17; // kr00_8
  __m256i v18; // [rsp+20h] [rbp-98h] BYREF
  unsigned int v19[4]; // [rsp+40h] [rbp-78h] BYREF
  __int64 v20; // [rsp+50h] [rbp-68h]
  char v21; // [rsp+59h] [rbp-5Fh]
  __m256i v22; // [rsp+60h] [rbp-58h] BYREF
  __int128 v23; // [rsp+80h] [rbp-38h]
  __int128 v24; // [rsp+90h] [rbp-28h]
  __int128 v25; // [rsp+A0h] [rbp-18h]

  v6 = a1[0x24];
  v25 = v3;
  v24 = v4;
  v23 = v5;
  v9 = a2;
  if ( *(_QWORD *)(v6 + 0x30) == *(_QWORD *)(v6 + 0x38) || a1[8] == a1[9] )
    return 0.0;
  v10 = 0;
  v11 = 0;
  sub_140573E20((__int64)v19, a3, 0x20 * ((unsigned __int64)*(unsigned __int8 *)(a3 + 6) >> 1));
  sub_140573E20((__int64)&v18, a3, 0x20 * ((unsigned __int64)*(unsigned __int8 *)(a3 + 6) >> 1));
  v12 = sub_140574E40(a3);
  sub_140573F30(&v18, &v22, v12);
  while ( v20 != v22.m256i_i64[2] || v21 != v22.m256i_i8[0x19] )
  {
    sub_140573EB0(v19, (__int64)&v18);
    if ( v18.m256i_i8[8] == 1 && (unsigned __int64)*(unsigned int *)(a1[0x24] + 0x4CLL) > v18.m256i_i64[0] )
    {
      v13 = (float)(unsigned int)(0xFF * *(_DWORD *)(*(_QWORD *)(v6 + 0x30) + 8 * v18.m256i_i64[0] + 4));
      v14 = v11;
      *(float *)&v14 = *(float *)&v11 + v13;
      v11 = v14;
      v15 = v10;
      *(float *)&v15 = *(float *)&v10 + (float)*(int *)(a1[8] + 8 * (v9 + 2 * v18.m256i_i64[0]) + 4);
      v10 = v15;
    }
    sub_140573F60((__int64)v19, 1);
  }
  if ( *(float *)&v11 == 0.0 )
    return 0.0;
  HIDWORD(v17) = DWORD1(v10);
  *(float *)&v17 = *(float *)&v10 / *(float *)&v11;
  return v17;
}

// --- End Function: sub_14084B4D0 (0x14084B4D0) ---

// --- Function: sub_14084B650 (0x14084B650) ---
float *__fastcall sub_14084B650(float *a1, float *a2, float *a3, _DWORD *a4, float Y)
{
  __int128 v6; // kr00_16
  __int128 v9; // kr00_16
  __int128 v12; // xmm12
  __int128 v14; // kr00_16
  int v15; // xmm14_4
  __int128 v17; // kr00_16
  float v19; // xmm7_4
  float v22; // xmm9_4
  float v23; // xmm11_4
  float *result; // rax
  int v26; // [rsp+C0h] [rbp+8h]
  int v27; // [rsp+C8h] [rbp+10h]
  int v28; // [rsp+D0h] [rbp+18h]
  float v29; // [rsp+D8h] [rbp+20h]

  v26 = a4[3] & 0x7FFFFFFF;
  v6 = *((unsigned int *)a3 + 2);
  *(float *)&v6 = a3[2] - a2[2];
  _XMM3 = v6;
  v9 = *((unsigned int *)a3 + 3);
  *(float *)&v9 = a3[3] - a2[3];
  _XMM6 = v9;
  v12 = *((unsigned int *)a3 + 1);
  v14 = v12;
  *(float *)&v14 = *(float *)&v12 - a2[1];
  _XMM2 = v14;
  v15 = *a4 & 0x7FFFFFFF;
  v17 = *(unsigned int *)a3;
  *(float *)&v17 = *a3 - *a2;
  _XMM0 = v17;
  __asm { vmaxss  xmm0, xmm0, xmm4 }
  v19 = (float)((float)(1.6666666 / *(float *)&_XMM0) * *(float *)&v15) * *a2;
  __asm { vmaxss  xmm0, xmm2, xmm4 }
  __asm { vmaxss  xmm2, xmm3, xmm4 }
  v27 = a4[1] & 0x7FFFFFFF;
  v22 = (float)((float)(1.6666666 / *(float *)&_XMM0) * *(float *)&v27) * a2[1];
  v23 = (float)((float)(1.6666666 / *(float *)&_XMM2) * COERCE_FLOAT(a4[2] & 0x7FFFFFFF)) * a2[2];
  __asm { vmaxss  xmm1, xmm6, xmm4 }
  v28 = a4[2] & 0x7FFFFFFF;
  v29 = (float)((float)(1.6666666 / *(float *)&_XMM1) * *(float *)&v26) * a2[3];
  *(float *)&_XMM6 = (float)(powf(*a3, Y) * (float)(*(float *)&v15 + v19)) * 1.0471976;
  *a1 = *(float *)&_XMM6 - (float)((float)(powf(*a2, Y) * v19) * 1.0471976);
  *(float *)&_XMM6 = (float)(powf(*(float *)&v12, Y) * (float)(v22 + *(float *)&v27)) * 1.0471976;
  *(float *)&v17 = powf(a2[1], Y) * v22;
  *(float *)&_XMM0 = a3[2];
  a1[1] = *(float *)&_XMM6 - (float)(*(float *)&v17 * 1.0471976);
  *(float *)&_XMM6 = (float)(powf(*(float *)&_XMM0, Y) * (float)(v23 + *(float *)&v28)) * 1.0471976;
  *(float *)&v17 = powf(a2[2], Y) * v23;
  *(float *)&_XMM0 = a3[3];
  a1[2] = *(float *)&_XMM6 - (float)(*(float *)&v17 * 1.0471976);
  *(float *)&v17 = (float)(powf(*(float *)&_XMM0, Y) * (float)(v29 + *(float *)&v26)) * 1.0471976;
  *(float *)&_XMM0 = powf(a2[3], Y);
  result = a1;
  a1[3] = *(float *)&v17 - (float)((float)(*(float *)&_XMM0 * v29) * 1.0471976);
  return result;
}

// --- End Function: sub_14084B650 (0x14084B650) ---

// --- Function: sub_14084B8D0 (0x14084B8D0) ---
__int64 __fastcall sub_14084B8D0(__int64 a1, __int64 *a2, __int64 a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm9
  __int64 v5; // rax
  __int64 v6; // rsi
  char *v7; // r14
  __int64 v8; // r13
  char v9; // r12
  int *v10; // rax
  int *v11; // rbx
  int v12; // r15d
  unsigned int v13; // r15d
  __int64 v14; // rcx
  __int64 v15; // rax
  char v16; // al
  __int64 v17; // rdx
  __int64 v18; // rax
  _QWORD *v19; // rax
  unsigned int v20; // eax
  __int64 v21; // rdx
  __int64 v22; // rax
  unsigned int v23; // edi
  unsigned __int64 allocSize; // r12
  char *v25; // rdi
  __int64 v26; // rbx
  char *v27; // rbx
  int v28; // r12d
  unsigned int v29; // ebx
  __int128 n0x49742400; // xmm11
  __int128 v31; // xmm7
  float v32; // xmm8_4
  __int64 v34; // r13
  unsigned __int16 v35; // ax
  int v36; // eax
  float v37; // edi
  float v38; // edi
  double v39; // xmm0_8
  unsigned __int64 v40; // rdi
  float v42; // xmm2_4
  __int128 v43; // kr00_16
  __int64 v46; // rcx
  __int64 v47; // rax
  __int64 v48; // rbx
  int v49; // edi
  int *ThreadLogContextSlot; // rax
  float v51; // xmm0_4
  float v52; // xmm3_4
  int v53; // edi
  int *ThreadLogContextSlot_1; // rax
  __int128 n0x49742400_1; // kr00_16
  const void *v58; // rdi
  const void *v59; // rbx
  signed __int64 Size; // r15
  __int64 v61; // rax
  __int64 v62; // r12
  char *v63; // r12
  const void *v64; // rcx
  __int64 v66; // [rsp+20h] [rbp-E0h]
  int v67; // [rsp+28h] [rbp-D8h]
  float v68; // [rsp+50h] [rbp-B0h]
  __int64 v70; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v71; // [rsp+68h] [rbp-98h]
  __int64 v72; // [rsp+70h] [rbp-90h]
  __int64 v73; // [rsp+78h] [rbp-88h] BYREF
  __int64 *v74; // [rsp+80h] [rbp-80h] BYREF
  __int128 v75; // [rsp+88h] [rbp-78h] BYREF
  int n0x7A_1; // [rsp+98h] [rbp-68h]
  int n0xBC_1; // [rsp+9Ch] [rbp-64h]
  __int128 v78; // [rsp+A0h] [rbp-60h] BYREF
  int n0x7A; // [rsp+B0h] [rbp-50h]
  int n0xBC; // [rsp+B4h] [rbp-4Ch]
  __int64 v81; // [rsp+B8h] [rbp-48h] BYREF
  __int128 v82; // [rsp+E0h] [rbp-20h]
  __int128 v83; // [rsp+110h] [rbp+10h]

  v5 = *a2;
  v6 = a3 + 0x30;
  v7 = 0;
  v73 = a3;
  v8 = a3;
  v9 = 0;
  v10 = (int *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v5 + 0x128) + 0x5C0LL))(*(_QWORD *)(v5 + 0x128));
  v11 = v10;
  if ( !v10 )
    return sub_140862390(a2);
  v12 = *v10;
  if ( *v10 <= 0 )
    return sub_140862390(a2);
  *(_DWORD *)(v8 + 0x58) = v10[0xC];
  v13 = v12 * v12;
  v68 = 0.5;
  v14 = *(_QWORD *)(*a2 + 0x130);
  if ( v14 )
  {
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x70LL))(v14);
    v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0xB0LL))(v15);
    v17 = **(_QWORD **)(*a2 + 0x130);
    if ( v16 )
    {
      v18 = (*(__int64 (**)(void))(v17 + 0x70))();
      v19 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v18 + 0xB8LL))(v18, &v75);
      v20 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v19 + 0x10LL))(*v19);
      v9 = 1;
    }
    else
    {
      v22 = (*(__int64 (**)(void))(v17 + 0x70))();
      v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x10LL))(v22);
    }
    v23 = v20;
    if ( (v9 & 1) != 0 && (_QWORD)v75 )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v75 + 0x160LL))(v75);
  }
  else
  {
    v23 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*a2 + 0x128) + 0x3E0LL))(*(_QWORD *)(*a2 + 0x128));
  }
  *(_QWORD *)&v78 = *((_QWORD *)v11 + 1);
  if ( v23 > (unsigned __int64)((__int64)(*(_QWORD *)(v6 + 0x10) - *(_QWORD *)v6) >> 3) )
  {
    if ( v23 )
    {
      allocSize = 8LL * v23;
      v67 = 0;
      v66 = 0;
      v25 = (char *)sub_1402A65A0(allocSize);
    }
    else
    {
      v25 = 0;
      allocSize = 0;
    }
    v26 = *(_QWORD *)(v6 + 8);
    if ( *(_QWORD *)v6 == v26 )
      v27 = v25;
    else
      v27 = (char *)memmove(v25, *(const void **)v6, v26 - *(_QWORD *)v6) + 8 * ((v26 - v21) >> 3);
    if ( *(_QWORD *)v6 )
      sub_1402A6590(*(_QWORD *)v6);
    *(_QWORD *)v6 = v25;
    *(_QWORD *)(v6 + 0x10) = &v25[allocSize];
    *(_QWORD *)(v6 + 8) = v27;
  }
  LODWORD(v75) = 0;
  v28 = 0;
  v29 = 0;
  n0x49742400 = 0x49742400u;
  v31 = 0;
  v32 = 0.0;
  LODWORD(_XMM10) = 0;
  if ( v13 )
  {
    v34 = v78;
    v82 = v4;
    v83 = v3;
    do
    {
      v35 = *(_WORD *)(8 * v29 + 6 + v34);
      if ( v35 > LOWORD(v68) )
      {
        v36 = (v35 & 0x7FFF) << 0xD;
        LODWORD(v37) = v36 + 0x38000000;
        if ( (v36 & 0xF800000) == 0xF800000 )
        {
          LODWORD(v37) = v36 + 0x70000000;
        }
        else if ( (v36 & 0xF800000) == 0 )
        {
          v37 = COERCE_FLOAT(v36 + 0x38800000) + -0.000061035156;
        }
        LODWORD(v38) = (*(unsigned __int16 *)(8 * v29 + 6 + v34) << 0x10) & 0x80000000 | LODWORD(v37);
        v39 = sub_14084E870(v34, v29, v13, &v75, v66, v67);
        v40 = (unsigned int)(int)v38;
        if ( (__int64)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3 <= v40 )
          sub_140862690(v6, v40 + 1);
        _XMM1 = (unsigned int)v75;
        v42 = *((float *)&v75 + 1);
        v43 = v31;
        *(float *)&v43 = *(float *)&v31 + *(float *)&v39;
        v31 = v43;
        *(float *)(*(_QWORD *)v6 + 8 * v40) = *(float *)&v39 + *(float *)(*(_QWORD *)v6 + 8 * v40);
        __asm
        {
          vmaxss  xmm0, xmm1, xmm10
          vmaxss  xmm10, xmm0, xmm2
          vminss  xmm0, xmm1, xmm11
        }
        ++*(_DWORD *)(*(_QWORD *)v6 + 8 * v40 + 4);
        ++v28;
        __asm { vminss  xmm11, xmm0, xmm2 }
        v32 = (float)(*(float *)&_XMM1 + v32) + v42;
      }
      ++v29;
    }
    while ( v29 < v13 );
    v8 = v73;
    LODWORD(v75) = v28;
  }
  v46 = *(_QWORD *)(*a2 + 0x130);
  if ( v46 )
    v47 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v46 + 0x130LL))(v46);
  else
    v47 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*a2 + 0x128) + 0x28LL))(*(_QWORD *)(*a2 + 0x128));
  v48 = v47;
  if ( v32 <= 0.00000011920929 )
  {
    *(_QWORD *)&v78 = 0x1C000000F7LL;
    v73 = (__int64)&v78;
    v74 = &v81;
    *((_QWORD *)&v78 + 1) = 0x3100000095LL;
    n0x7A = 0x7A;
    n0xBC = 0xBC;
    v49 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)&v73,
            (__int64)"Invalid Total Texel Length",
            "Detected PBM with a total texel length of zero, this likely means the PBM was exported incorrectly or the da"
            "mage map UV is not setup correctly. Cannot calculate surface area!");
    if ( (v49 & 0xFFFFF) != 0 )
    {
      v70 = 0;
      v71 = v48;
      v72 = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      *(_QWORD *)&v75 = 0x1C000000F7LL;
      v73 = (__int64)&v75;
      v74 = (__int64 *)&v78;
      *((_QWORD *)&v75 + 1) = 0x3100000095LL;
      v78 = 0;
      n0x7A_1 = 0x7A;
      n0xBC_1 = 0xBC;
      sub_140446700(
        3,
        (__int64)&v73,
        "Invalid Total Texel Length",
        (__int64)"Detected PBM with a total texel length of zero, this likely means the PBM was exported incorrectly or t"
                 "he damage map UV is not setup correctly. Cannot calculate surface area!",
        2,
        v49,
        &v78,
        0,
        (__int64)ThreadLogContextSlot,
        &v70);
      sub_1402A6590(v72);
    }
    return sub_140862390(a2);
  }
  if ( v28 )
  {
    v51 = (float)(unsigned int)(2 * v28);
    v52 = v32 / v51;
    if ( (float)(v32 / v51) <= 0.00000011920929 )
    {
      v73 = 0x1C000000CALL;
      *(_QWORD *)&v78 = &v73;
      *((_QWORD *)&v78 + 1) = (char *)&v74 + 4;
      LODWORD(v74) = 0xBC;
      v53 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)&v78,
              (__int64)"Invalid Average Texel Length",
              "Detected PBM with an average texel length of zero, this likely means the PBM was exported incorrectly. Can"
              "not calculate surface area!");
      if ( (v53 & 0xFFFFF) != 0 )
      {
        v70 = 0;
        v71 = v48;
        v72 = 0;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v73 = 0x1C000000CALL;
        *(_QWORD *)&v78 = &v73;
        *((_QWORD *)&v78 + 1) = (char *)&v74 + 4;
        LODWORD(v74) = 0xBC;
        v75 = 0;
        sub_140446700(
          3,
          (__int64)&v78,
          "Invalid Average Texel Length",
          (__int64)"Detected PBM with an average texel length of zero, this likely means the PBM was exported incorrectly"
                   ". Cannot calculate surface area!",
          2,
          v53,
          &v75,
          0,
          (__int64)ThreadLogContextSlot_1,
          &v70);
        sub_1402A6590(v72);
      }
      return sub_140862390(a2);
    }
    n0x49742400_1 = n0x49742400;
    *(float *)&n0x49742400_1 = *(float *)&n0x49742400 - v52;
    _XMM2 = n0x49742400_1 & xmmword_1482B5EE0;
    __asm { vmaxss  xmm0, xmm2, xmm0 }
    *(float *)(v8 + 0x64) = *(float *)&_XMM0 / v52;
    *(float *)(v8 + 0x68) = *(float *)&_XMM10;
    *(float *)(v8 + 0x6C) = *(float *)&n0x49742400;
    *(float *)(v8 + 0x70) = v52;
  }
  v58 = *(const void **)(v6 + 8);
  v59 = *(const void **)v6;
  Size = (signed __int64)v58 - *(_QWORD *)v6;
  v61 = Size >> 3;
  if ( Size >> 3 )
  {
    v62 = 8 * v61;
    v7 = (char *)sub_1402A65A0(8 * v61);
  }
  else
  {
    v62 = 0;
  }
  v63 = &v7[v62];
  if ( v59 != v58 )
    memmove(v7, v59, Size);
  v64 = *(const void **)v6;
  *(_QWORD *)v6 = v7;
  *(_QWORD *)(v6 + 8) = v63;
  *(_QWORD *)(v6 + 0x10) = v63;
  if ( v64 )
    sub_1402A6590((__int64)v64);
  *(_DWORD *)(v8 + 0x54) = v75;
  *(float *)(v8 + 0x60) = *(float *)&v31;
  *(_DWORD *)(v8 + 0x4C) = (__int64)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3;
  return sub_140862390(a2);
}

// --- End Function: sub_14084B8D0 (0x14084B8D0) ---

// --- Function: sub_14084CAE0 (0x14084CAE0) ---
_QWORD *__fastcall sub_14084CAE0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, unsigned __int8 *Src)
{
  char n3; // di
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 v10; // rax
  __m256 v12; // [rsp+20h] [rbp-50h] BYREF
  __int128 v13; // [rsp+40h] [rbp-30h] BYREF
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h] BYREF
  __int64 v16; // [rsp+60h] [rbp-10h]
  __int64 v17; // [rsp+A8h] [rbp+38h] BYREF
  __int64 v18; // [rsp+B8h] [rbp+48h] BYREF

  LODWORD(v17) = 0;
  n3 = 0;
  v8 = sub_1402A65A0(0x60u);
  if ( v8 )
  {
    sub_140573D50(&v17, Src);
    v14 = 0;
    BYTE6(v17) = BYTE6(v17) & 0xFE | ((v17 & 0x1000000000000LL) == 0);
    v12 = (__m256)0LL;
    v13 = 0;
    __asm { vzeroupper }
    sub_140573D50(&v15, (unsigned __int8 *)&v17);
    v16 = 0;
    *(_QWORD *)v8 = 0;
    if ( *(_QWORD *)v12.m256_f32 )
      (***(void (__fastcall ****)(_QWORD))v12.m256_f32)(*(_QWORD *)v12.m256_f32);
    sub_140849440((_QWORD *)(v8 + 8), (__int64)&v12.m256_f32[2]);
    sub_140849440((_QWORD *)(v8 + 0x20), (__int64)&v13);
    sub_140573D50((_QWORD *)(v8 + 0x38), (unsigned __int8 *)&v15);
    n3 = 3;
    *(_QWORD *)(v8 + 0x40) = v16;
    *(_QWORD *)(v8 + 0x50) = &p_Src;
    *(_QWORD *)(v8 + 0x48) = 0;
    *(_DWORD *)(v8 + 0x58) = 0xFFFFFFFF;
    *(_DWORD *)(v8 + 0x5C) = 0;
  }
  else
  {
    v8 = 0;
  }
  v18 = v8;
  sub_140848420(a4 + 8, &v18);
  if ( (n3 & 2) != 0 )
  {
    n3 &= ~2u;
    if ( (v15 & 0x100000000000000LL) != 0 && (v15 & 0xFFFFFFFFFFFFLL) != 0 )
      sub_1402A6590(v15 & 0xFFFFFFFFFFFFLL);
    if ( (_QWORD)v13 )
      sub_1402A6590(v13);
    if ( *(_QWORD *)&v12.m256_f32[2] )
      sub_1402A6590(*(__int64 *)&v12.m256_f32[2]);
    if ( *(_QWORD *)v12.m256_f32 )
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)v12.m256_f32 + 8LL))(*(_QWORD *)v12.m256_f32);
  }
  if ( (n3 & 1) != 0 && (v17 & 0x100000000000000LL) != 0 && (v17 & 0xFFFFFFFFFFFFLL) != 0 )
    sub_1402A6590(v17 & 0xFFFFFFFFFFFFLL);
  v9 = *(_QWORD *)(a4 + 0x10);
  *a2 = 0;
  a2[1] = 0;
  v10 = *(_QWORD *)(v9 - 8);
  if ( v10 )
    _InterlockedIncrement((volatile signed __int32 *)(v10 + 8));
  *a2 = *(_QWORD *)(v9 - 0x10);
  a2[1] = *(_QWORD *)(v9 - 8);
  return a2;
}

// --- End Function: sub_14084CAE0 (0x14084CAE0) ---

// --- Function: sub_14084CFF0 (0x14084CFF0) ---
__int64 __fastcall sub_14084CFF0(__int64 a1, unsigned __int16 a2)
{
  __int16 v3; // r8
  unsigned __int16 v4; // r9
  unsigned int v5; // edi
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rbx
  char *v9; // rsi
  char *v10; // rbp
  __int64 *v11; // rdi
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // rcx
  char *v15; // rax
  _DWORD *v16; // rdi
  __int64 i; // rcx
  char v19; // [rsp+30h] [rbp-38h] BYREF

  v3 = (a2 >> ((a2 & 0xFF00) != 0 ? 8 : 0)) & 0xF0;
  v4 = (unsigned __int16)(a2 >> ((a2 & 0xFF00) != 0 ? 8 : 0)) >> (v3 != 0 ? 4 : 0);
  LOBYTE(v4) = (v3 != 0 ? 4 : 0)
             | ((v4 & 0xC) != 0 ? 2 : 0)
             | ((a2 & 0xFF00) != 0 ? 8 : 0)
             | (((v4 >> ((v4 & 0xC) != 0 ? 2 : 0)) & 2) != 0);
  *(_BYTE *)(a1 + 9) = v4;
  *(_BYTE *)(a1 + 8) = 2 * v4;
  v5 = ((1 << (2 * v4 + 1)) - 1) & 0x55555555;
  *(_DWORD *)(a1 + 0xC) = v5;
  *(_DWORD *)(a1 + 0x10) = v5 ^ (1 << (2 * v4));
  v6 = (v5 >> 5) + 1;
  v7 = 4 * v6;
  *(_DWORD *)(a1 + 0x14) = v6;
  v8 = (unsigned int)v6;
  v9 = (char *)sub_1402A65A0(4 * v6);
  v10 = &v9[v7];
  memset(v9, 0, 4 * v8);
  v11 = (__int64 *)(a1 + 0x18);
  if ( (char *)(a1 + 0x18) != &v19 )
  {
    v12 = *v11;
    *v11 = 0;
    v13 = *(_QWORD *)(a1 + 0x28);
    *(_QWORD *)(a1 + 0x28) = 0;
    v14 = *v11;
    *v11 = v12;
    *(_QWORD *)(a1 + 0x20) = v12;
    *(_QWORD *)(a1 + 0x28) = v13;
    if ( v14 )
      sub_1402A6590(v14);
    v15 = (char *)*v11;
    *v11 = (__int64)v9;
    v9 = v15;
    *(_QWORD *)(a1 + 0x20) = v10;
    *(_QWORD *)(a1 + 0x28) = v10;
  }
  if ( v9 )
    sub_1402A6590((__int64)v9);
  v16 = (_DWORD *)*v11;
  for ( i = (__int64)(*(_QWORD *)(a1 + 0x20) - (_QWORD)v16) >> 2; i; --i )
    *v16++ = 0;
  return (**(__int64 (__fastcall ***)(__int64))a1)(a1);
}

// --- End Function: sub_14084CFF0 (0x14084CFF0) ---

// --- Function: sub_14084D190 (0x14084D190) ---
unsigned int *__fastcall sub_14084D190(unsigned int *a1, unsigned __int16 *a2)
{
  int v4; // eax
  float v5; // ecx
  int v6; // r8d
  int v7; // eax
  unsigned int v8; // r9d
  float v9; // edx
  int v10; // eax
  unsigned int v11; // r8d
  float v12; // edx
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // r11d
  float v16; // edx
  unsigned int *result; // rax

  v4 = (a2[3] & 0x7FFF) << 0xD;
  LODWORD(v5) = v4 + 0x38000000;
  if ( (v4 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v5) = v4 + 0x70000000;
  }
  else if ( (v4 & 0xF800000) == 0 )
  {
    v5 = COERCE_FLOAT(v4 + 0x38800000) + -0.000061035156;
  }
  v6 = a2[2];
  v7 = (a2[2] & 0x7FFF) << 0xD;
  v8 = LODWORD(v5) | (a2[3] << 0x10) & 0x80000000;
  LODWORD(v9) = v7 + 0x38000000;
  if ( (v7 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v9) = v7 + 0x70000000;
  }
  else if ( (v7 & 0xF800000) == 0 )
  {
    v9 = COERCE_FLOAT(v7 + 0x38800000) + -0.000061035156;
  }
  v10 = (a2[1] & 0x7FFF) << 0xD;
  v11 = LODWORD(v9) | (v6 << 0x10) & 0x80000000;
  LODWORD(v12) = v10 + 0x38000000;
  if ( (v10 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v12) = v10 + 0x70000000;
  }
  else if ( (v10 & 0xF800000) == 0 )
  {
    v12 = COERCE_FLOAT(v10 + 0x38800000) + -0.000061035156;
  }
  v13 = *a2;
  v14 = (*a2 & 0x7FFF) << 0xD;
  v15 = LODWORD(v12) | (a2[1] << 0x10) & 0x80000000;
  LODWORD(v16) = v14 + 0x38000000;
  if ( (v14 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v16) = v14 + 0x70000000;
  }
  else if ( (v14 & 0xF800000) == 0 )
  {
    v16 = COERCE_FLOAT(v14 + 0x38800000) + -0.000061035156;
  }
  result = a1;
  a1[1] = v15;
  a1[2] = v11;
  *a1 = LODWORD(v16) | (v13 << 0x10) & 0x80000000;
  a1[3] = v8;
  return result;
}

// --- End Function: sub_14084D190 (0x14084D190) ---

// --- Function: sub_14084D320 (0x14084D320) ---
// attributes: thunk
__int64 sub_14084D320()
{
  return sub_1408560D0();
}

// --- End Function: sub_14084D320 (0x14084D320) ---

// --- Function: sub_14084DAC0 (0x14084DAC0) ---
unsigned __int64 __fastcall sub_14084DAC0(__int64 *a1, unsigned __int64 a2)
{
  _QWORD *v3; // rdx
  unsigned __int64 result; // rax
  __int64 v6; // rdx
  unsigned __int64 v7; // rbp
  __int64 v8; // r15
  char *v9; // r14
  __int64 v10; // r12
  const void *v11; // rdx
  char *v12; // r9
  unsigned __int64 v13; // r8
  _QWORD *v14; // rdx
  __int64 v15; // rcx
  char *v16; // rbx
  unsigned __int64 v17; // r8

  v3 = (_QWORD *)a1[1];
  result = (a1[2] - (__int64)v3) >> 4;
  if ( a2 <= result )
  {
    v17 = a2;
    if ( a2 )
    {
      result = 0;
      do
      {
        *v3 = 0;
        v3[1] = 0;
        v3 += 2;
        --v17;
      }
      while ( v17 );
    }
    a1[1] += 0x10 * a2;
  }
  else
  {
    v6 = ((__int64)v3 - *a1) >> 4;
    v7 = 2 * v6;
    if ( !v6 )
      v7 = 1;
    if ( v7 < v6 + a2 )
      v7 = v6 + a2;
    if ( v7 )
    {
      v8 = 0x10 * v7;
      v9 = (char *)sub_1402A65A0(0x10 * v7);
    }
    else
    {
      v9 = 0;
      v8 = 0;
    }
    v10 = a1[1];
    if ( *a1 == v10 )
    {
      v12 = v9;
    }
    else
    {
      v11 = (const void *)*a1;
      v12 = (char *)memmove(v9, v11, v10 - (_QWORD)v11) + ((v10 - (_QWORD)v11) & 0xFFFFFFFFFFFFFFF0uLL);
    }
    v13 = a2;
    v14 = v12;
    v15 = v8;
    if ( a2 )
    {
      do
      {
        *v14 = 0;
        v14[1] = 0;
        v14 += 2;
        --v13;
      }
      while ( v13 );
      v15 = 0x10 * v7;
    }
    v16 = &v12[0x10 * a2];
    if ( *a1 )
    {
      sub_1402A6590(*a1);
      v15 = v8;
    }
    result = (unsigned __int64)&v9[v15];
    *a1 = (__int64)v9;
    a1[2] = (__int64)&v9[v15];
    a1[1] = (__int64)v16;
  }
  return result;
}

// --- End Function: sub_14084DAC0 (0x14084DAC0) ---

// --- Function: sub_14084DC50 (0x14084DC50) ---
__int64 __fastcall sub_14084DC50(__int64 a1, unsigned __int64 a2)
{
  _DWORD *v2; // rax
  __int64 v5; // rax
  unsigned __int64 v6; // rbp
  char *v7; // rsi
  __int64 v8; // r15
  __int64 v9; // r14
  char *v10; // rdx
  unsigned __int64 v11; // rcx
  __int64 v12; // rax
  char *v13; // rax
  char *v14; // rdi
  __int64 result; // rax
  unsigned __int64 i; // rcx

  v2 = *(_DWORD **)(a1 + 8);
  if ( a2 <= (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v2) >> 2 )
  {
    for ( i = a2; i; --i )
      *v2++ = 0;
    result = 4 * a2;
    *(_QWORD *)(a1 + 8) += 4 * a2;
  }
  else
  {
    v5 = ((__int64)v2 - *(_QWORD *)a1) >> 2;
    v6 = 2 * v5;
    if ( !v5 )
      v6 = 1;
    if ( v6 < v5 + a2 )
      v6 = v5 + a2;
    v7 = 0;
    if ( v6 )
    {
      v8 = 4 * v6;
      v7 = (char *)sub_1402A65A0(4 * v6);
    }
    else
    {
      v8 = 0;
    }
    v9 = *(_QWORD *)(a1 + 8);
    if ( *(_QWORD *)a1 == v9 )
      v10 = v7;
    else
      v10 = (char *)memmove(v7, *(const void **)a1, v9 - *(_QWORD *)a1) + 4 * ((__int64)(v9 - a2) >> 2);
    v11 = a2;
    v12 = v8;
    if ( a2 )
    {
      v13 = v10 + 2;
      do
      {
        *(_DWORD *)(v13 + 0xFFFFFFFE) = 0;
        v13 += 4;
        --v11;
      }
      while ( v11 );
      v12 = 4 * v6;
    }
    v14 = &v10[4 * a2];
    if ( *(_QWORD *)a1 )
    {
      sub_1402A6590(*(_QWORD *)a1);
      v12 = v8;
    }
    result = (__int64)&v7[v12];
    *(_QWORD *)a1 = v7;
    *(_QWORD *)(a1 + 0x10) = result;
    *(_QWORD *)(a1 + 8) = v14;
  }
  return result;
}

// --- End Function: sub_14084DC50 (0x14084DC50) ---

// --- Function: sub_14084DDB0 (0x14084DDB0) ---
__int64 __fastcall sub_14084DDB0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rcx
  __int64 v5; // rdx
  unsigned __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // r12
  __int64 v9; // r8
  __int64 v10; // rbx
  __int64 v11; // r15
  __int64 v12; // rdx
  __int64 result; // rax

  v4 = a1[1];
  if ( a2 <= (a1[2] - v4) / 0x50 )
  {
    sub_140849190(v4, a2);
    result = 0x50 * a2;
    a1[1] += 0x50 * a2;
  }
  else
  {
    v5 = (v4 - *a1) / 0x50;
    v6 = 2 * v5;
    if ( !v5 )
      v6 = 1;
    if ( v6 < v5 + a2 )
      v6 = v5 + a2;
    v7 = 0;
    if ( v6 )
    {
      v8 = 0x50 * v6;
      v7 = sub_1402A65A0(0x50 * v6);
    }
    else
    {
      v8 = 0;
    }
    v9 = *a1;
    v10 = v7;
    v11 = v8;
    v12 = (a1[1] - *a1) / 0x50;
    if ( v12 > 0 )
    {
      do
      {
        *(__m256i *)v10 = *(__m256i *)v9;
        *(__m256i *)(v10 + 0x20) = *(__m256i *)(v9 + 0x20);
        *(_OWORD *)(v10 + 0x40) = *(_OWORD *)(v9 + 0x40);
        v10 += 0x50;
        v9 += 0x50;
        --v12;
      }
      while ( v12 > 0 );
      v11 = 0x50 * v6;
    }
    __asm { vzeroupper }
    sub_140849190(v10, a2);
    if ( *a1 )
    {
      sub_1402A6590(*a1);
      v11 = v8;
    }
    result = v11 + v7;
    *a1 = v7;
    a1[1] = v10 + 0x50 * a2;
    a1[2] = v11 + v7;
  }
  return result;
}

// --- End Function: sub_14084DDB0 (0x14084DDB0) ---

// --- Function: sub_14084E170 (0x14084E170) ---
unsigned __int64 __fastcall sub_14084E170(_QWORD *a1, float *a2, int a3, _DWORD *a4, unsigned __int64 *a5)
{
  float v5; // xmm2_4
  __int64 v6; // rax
  float v10; // xmm6_4
  __int64 v11; // r9
  double v12; // xmm1_8
  double v17; // xmm5_8
  double v18; // xmm3_8
  double v22; // xmm4_8
  double v25; // xmm3_8
  __int64 v29; // r9
  double v30; // xmm1_8
  double v35; // xmm5_8
  double v36; // xmm3_8
  double v40; // xmm4_8
  double v43; // xmm3_8
  __int64 v47; // r9
  double v48; // xmm1_8
  double v53; // xmm5_8
  double v54; // xmm3_8
  double v58; // xmm4_8
  double v61; // xmm3_8
  unsigned __int64 result; // rax
  __int64 v66; // r9
  double v67; // xmm1_8
  double v72; // xmm5_8
  double v73; // xmm3_8
  double v77; // xmm4_8
  double v80; // xmm3_8

  v6 = (unsigned int)a4[0xE];
  v10 = v5;
  if ( (_DWORD)v6 == 0xFFFFFFFF )
    return sub_140346BA0(a5, a4 + 0xC);
  v11 = *a1 + 0x50 * v6;
  if ( *(_BYTE *)(v11 + 0x48) )
  {
    v12 = *a2;
    _XMM0 = COERCE_UNSIGNED_INT64(v12 - *(double *)(v11 + 0x18));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)v11 - v12);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v17 = *(double *)&_XMM2 + *(double *)&_XMM1;
    v18 = a2[1];
    _XMM0 = COERCE_UNSIGNED_INT64(v18 - *(double *)(v11 + 0x20));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v11 + 8) - v18);
    v22 = a2[2];
    _XMM0 = COERCE_UNSIGNED_INT64(v22 - *(double *)(v11 + 0x28));
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v25 = *(double *)&_XMM2 + *(double *)&_XMM1;
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v11 + 0x10) - v22);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    if ( v25 * v25 + v17 * v17 + (*(double *)&_XMM2 + *(double *)&_XMM1) * (*(double *)&_XMM2 + *(double *)&_XMM1) <= (float)(v10 * v10) )
      sub_14084E170((_DWORD)a1, (_DWORD)a2, a3, v11, (__int64)a5);
  }
  v29 = *a1 + 0x50LL * (unsigned int)a4[0xF];
  if ( *(_BYTE *)(v29 + 0x48) )
  {
    v30 = *a2;
    _XMM0 = COERCE_UNSIGNED_INT64(v30 - *(double *)(v29 + 0x18));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)v29 - v30);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v35 = *(double *)&_XMM2 + *(double *)&_XMM1;
    v36 = a2[1];
    _XMM0 = COERCE_UNSIGNED_INT64(v36 - *(double *)(v29 + 0x20));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v29 + 8) - v36);
    v40 = a2[2];
    _XMM0 = COERCE_UNSIGNED_INT64(v40 - *(double *)(v29 + 0x28));
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v43 = *(double *)&_XMM2 + *(double *)&_XMM1;
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v29 + 0x10) - v40);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    if ( v43 * v43 + v35 * v35 + (*(double *)&_XMM2 + *(double *)&_XMM1) * (*(double *)&_XMM2 + *(double *)&_XMM1) <= (float)(v10 * v10) )
      sub_14084E170((_DWORD)a1, (_DWORD)a2, a3, v29, (__int64)a5);
  }
  v47 = *a1 + 0x50LL * (unsigned int)a4[0x10];
  if ( *(_BYTE *)(v47 + 0x48) )
  {
    v48 = *a2;
    _XMM0 = COERCE_UNSIGNED_INT64(v48 - *(double *)(v47 + 0x18));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)v47 - v48);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v53 = *(double *)&_XMM2 + *(double *)&_XMM1;
    v54 = a2[1];
    _XMM0 = COERCE_UNSIGNED_INT64(v54 - *(double *)(v47 + 0x20));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v47 + 8) - v54);
    v58 = a2[2];
    _XMM0 = COERCE_UNSIGNED_INT64(v58 - *(double *)(v47 + 0x28));
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v61 = *(double *)&_XMM2 + *(double *)&_XMM1;
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v47 + 0x10) - v58);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    if ( v61 * v61 + v53 * v53 + (*(double *)&_XMM2 + *(double *)&_XMM1) * (*(double *)&_XMM2 + *(double *)&_XMM1) <= (float)(v10 * v10) )
      sub_14084E170((_DWORD)a1, (_DWORD)a2, a3, v47, (__int64)a5);
  }
  result = (unsigned int)a4[0x11];
  v66 = *a1 + 0x50 * result;
  if ( *(_BYTE *)(v66 + 0x48) )
  {
    v67 = *a2;
    _XMM0 = COERCE_UNSIGNED_INT64(v67 - *(double *)(v66 + 0x18));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)v66 - v67);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v72 = *(double *)&_XMM2 + *(double *)&_XMM1;
    v73 = a2[1];
    _XMM0 = COERCE_UNSIGNED_INT64(v73 - *(double *)(v66 + 0x20));
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v66 + 8) - v73);
    v77 = a2[2];
    _XMM0 = COERCE_UNSIGNED_INT64(v77 - *(double *)(v66 + 0x28));
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    v80 = *(double *)&_XMM2 + *(double *)&_XMM1;
    __asm { vmaxsd  xmm2, xmm0, xmm7 }
    _XMM1 = COERCE_UNSIGNED_INT64(*(double *)(v66 + 0x10) - v77);
    __asm { vmaxsd  xmm1, xmm1, xmm7 }
    if ( v80 * v80 + v72 * v72 + (*(double *)&_XMM2 + *(double *)&_XMM1) * (*(double *)&_XMM2 + *(double *)&_XMM1) <= (float)(v10 * v10) )
      return sub_14084E170((_DWORD)a1, (_DWORD)a2, a3, v66, (__int64)a5);
  }
  return result;
}

// --- End Function: sub_14084E170 (0x14084E170) ---

// --- Function: sub_14084E4F0 (0x14084E4F0) ---
_QWORD *__fastcall sub_14084E4F0(__int64 a1, _QWORD *a2, unsigned int a3, __int64 a4, unsigned __int8 *Src)
{
  __int64 *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  volatile signed __int32 *v12; // rbx
  volatile signed __int32 *v13; // rbx
  __int64 *v14; // rax
  __int64 v15; // rcx
  __int64 v16; // rdx
  volatile signed __int32 *v17; // rbx
  volatile signed __int32 *v18; // rbx
  _BYTE v20[8]; // [rsp+30h] [rbp-48h] BYREF
  volatile signed __int32 *v21; // [rsp+38h] [rbp-40h]
  __int64 v22; // [rsp+40h] [rbp-38h] BYREF
  volatile signed __int32 *v23; // [rsp+48h] [rbp-30h]

  *a2 = 0;
  a2[1] = 0;
  v9 = (__int64 *)sub_140860D50(a1, v20, a4, Src);
  v10 = *v9;
  v11 = v9[1];
  *v9 = 0;
  v9[1] = 0;
  v12 = (volatile signed __int32 *)a2[1];
  *a2 = v10;
  a2[1] = v11;
  if ( v12 )
  {
    if ( _InterlockedExchangeAdd(v12 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v12)(v12);
      if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v12 + 8LL))(v12);
    }
  }
  v13 = v21;
  if ( v21 )
  {
    if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
      if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8LL))(v13);
    }
  }
  if ( !*a2 )
  {
    v14 = sub_14084CAE0(a1, &v22, a3, a4, Src);
    v15 = *v14;
    v16 = v14[1];
    *v14 = 0;
    v14[1] = 0;
    v17 = (volatile signed __int32 *)a2[1];
    *a2 = v15;
    a2[1] = v16;
    if ( v17 )
    {
      if ( _InterlockedExchangeAdd(v17 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v17)(v17);
        if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v17 + 8LL))(v17);
      }
    }
    v18 = v23;
    if ( v23 )
    {
      if ( _InterlockedExchangeAdd(v23 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
        if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8LL))(v18);
      }
    }
  }
  return a2;
}

// --- End Function: sub_14084E4F0 (0x14084E4F0) ---

// --- Function: sub_14084E720 (0x14084E720) ---
__int64 __fastcall sub_14084E720(__int64 a1, _DWORD *a2, int *a3, unsigned int n0x20)
{
  int v8; // r15d
  int *ThreadLogContextSlot; // rax
  __int64 v10; // rax
  int v11; // ecx
  unsigned int n0x20_1; // r8d
  __int64 v13; // rdx
  __int64 result; // rax
  int *p_n0xCA; // [rsp+50h] [rbp-38h] BYREF
  __int64 *v16; // [rsp+58h] [rbp-30h]
  __int128 v17; // [rsp+60h] [rbp-28h] BYREF
  int n0xCA; // [rsp+98h] [rbp+10h] BYREF
  int n0xBC; // [rsp+9Ch] [rbp+14h]
  __int64 v20; // [rsp+A0h] [rbp+18h] BYREF

  if ( n0x20 >= 0x20 )
  {
    p_n0xCA = &n0xCA;
    n0xCA = 0xCA;
    v16 = &v20;
    n0xBC = 0xBC;
    v8 = invokeGlobalCallbackAndMaskStatusBits(
           3,
           (__int64)&p_n0xCA,
           (__int64)"Data size too big",
           "Tried to access more than the allowed amount of data at a single time.");
    if ( (v8 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot = getThreadLogContextSlot();
      p_n0xCA = &n0xCA;
      v16 = &v20;
      n0xCA = 0xCA;
      v17 = 0;
      n0xBC = 0xBC;
      sub_140354250(
        3,
        (__int64)&p_n0xCA,
        "Data size too big",
        (__int64)"Tried to access more than the allowed amount of data at a single time.",
        1,
        v8,
        &v17,
        0,
        (__int64)ThreadLogContextSlot);
    }
  }
  v10 = (unsigned int)*a2;
  v11 = *a3;
  n0x20_1 = *a3 + n0x20;
  if ( n0x20_1 <= 0x20 )
    LODWORD(v13) = *(_DWORD *)(a1 + 4 * v10) >> v11;
  else
    v13 = *(_QWORD *)(a1 + 4 * v10) >> v11;
  *a3 = n0x20_1;
  result = (unsigned int)v13 & ((1 << n0x20) - 1);
  *a2 += n0x20_1 >> 5;
  *a3 &= 0x1Fu;
  return result;
}

// --- End Function: sub_14084E720 (0x14084E720) ---

// --- Function: sub_14084E870 (0x14084E870) ---
__m128 __fastcall sub_14084E870(__int64 a1, int a2, unsigned int a3, __int64 a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int128 v9; // xmm11
  __int128 v10; // xmm12
  __int128 v11; // xmm13
  __int128 v12; // xmm14
  unsigned int v17; // r12d
  unsigned int v18; // eax
  __int64 v19; // rbx
  unsigned int v20; // r14d
  __int16 v21; // dx
  float v22; // xmm12_4
  float v23; // xmm13_4
  float v24; // xmm14_4
  int v25; // ebx
  float v28; // xmm8_4
  float v29; // xmm9_4
  float v30; // xmm10_4
  __int64 v31; // rdx
  unsigned __int16 v32; // cx
  float v33; // xmm7_4
  __m128 v34; // kr00_16
  float v35; // xmm6_4
  float v36; // xmm5_4
  __m128 v37; // xmm1
  float v40; // xmm0_4
  float v41; // xmm2_4
  float v42; // xmm3_4
  __int64 v43; // rdx
  unsigned __int16 v44; // cx
  float v45; // xmm7_4
  __m128 v46; // kr00_16
  float v47; // xmm6_4
  float v48; // xmm5_4
  __m128 v49; // xmm1
  __int128 n0x3F800000; // kr00_16
  float v54; // [rsp+28h] [rbp-69h] BYREF
  float v55; // [rsp+2Ch] [rbp-65h]
  float v56; // [rsp+30h] [rbp-61h]
  float v57; // [rsp+34h] [rbp-5Dh]
  __int128 v58; // [rsp+38h] [rbp-59h]
  __int128 v59; // [rsp+48h] [rbp-49h]
  _OWORD v60[7]; // [rsp+58h] [rbp-39h]
  unsigned __int16 v61; // [rsp+F8h] [rbp+67h] BYREF
  __int16 v62; // [rsp+FAh] [rbp+69h]
  __int16 v63; // [rsp+FCh] [rbp+6Bh]
  __int16 v64; // [rsp+FEh] [rbp+6Dh]

  v60[6] = v4;
  v60[5] = v5;
  v60[4] = v6;
  v60[3] = v7;
  v60[2] = v8;
  v60[1] = v9;
  v60[0] = v10;
  v59 = v11;
  v58 = v12;
  v17 = sub_1403BDEA0(a2);
  v18 = sub_1403BDEC0(a2);
  v19 = (unsigned int)(8 * a2);
  v20 = v18;
  v61 = *(_WORD *)(v19 + a1);
  v21 = *(_WORD *)((unsigned int)(v19 + 2) + a1);
  v63 = *(_WORD *)((unsigned int)(v19 + 4) + a1);
  v62 = v21;
  v64 = *(_WORD *)((unsigned int)(v19 + 6) + a1);
  sub_14084D190((unsigned int *)&v54, &v61);
  v22 = v54;
  v23 = v55;
  v24 = v56;
  v25 = (int)v57;
  _XMM0 = 0;
  __asm { vunpcklps xmm0, xmm0, xmm0 }
  *(double *)a4 = *(double *)&_XMM0;
  v28 = v22;
  v29 = v23;
  v30 = v24;
  if ( v17 < a3 )
  {
    v31 = 8 * v17;
    v32 = *(_WORD *)(v31 + a1);
    v62 = *(_WORD *)((unsigned int)(v31 + 2) + a1);
    v61 = v32;
    v63 = *(_WORD *)((unsigned int)(v31 + 4) + a1);
    v64 = *(_WORD *)((unsigned int)(v31 + 6) + a1);
    sub_14084D190((unsigned int *)&v54, &v61);
    if ( (int)v57 == v25 )
    {
      v34 = (__m128)LODWORD(v54);
      v33 = v54 - v22;
      v35 = v55 - v23;
      v36 = v56 - v24;
      v34.m128_f32[0] = (float)((float)(v33 * v33) + (float)(v35 * v35)) + (float)(v36 * v36);
      v37 = _mm_sqrt_ps(_mm_shuffle_ps(v34, v34, 0));
      _XMM1 = _mm_shuffle_ps(v37, v37, 0xFF);
      __asm { vmaxss  xmm0, xmm1, cs:dword_1482BB398 }
      *(float *)a4 = _XMM1.m128_f32[0];
      v22 = v33 * (float)(1.0 / *(float *)&_XMM0);
      v23 = v35 * (float)(1.0 / *(float *)&_XMM0);
      v24 = v36 * (float)(1.0 / *(float *)&_XMM0);
    }
  }
  v40 = v28;
  v41 = v29;
  v42 = v30;
  if ( v20 < a3 )
  {
    v43 = 8 * v20;
    v44 = *(_WORD *)(v43 + a1);
    v62 = *(_WORD *)((unsigned int)(v43 + 2) + a1);
    v61 = v44;
    v63 = *(_WORD *)((unsigned int)(v43 + 4) + a1);
    v64 = *(_WORD *)((unsigned int)(v43 + 6) + a1);
    sub_14084D190((unsigned int *)&v54, &v61);
    v40 = v28;
    v41 = v29;
    v42 = v30;
    if ( (int)v57 == v25 )
    {
      v46 = (__m128)LODWORD(v54);
      v45 = v54 - v28;
      v47 = v55 - v29;
      v48 = v56 - v30;
      v46.m128_f32[0] = (float)((float)(v45 * v45) + (float)(v47 * v47)) + (float)(v48 * v48);
      v49 = _mm_sqrt_ps(_mm_shuffle_ps(v46, v46, 0));
      _XMM1 = _mm_shuffle_ps(v49, v49, 0xFF);
      __asm { vmaxss  xmm0, xmm1, cs:dword_1482BB398 }
      *(float *)(a4 + 4) = _XMM1.m128_f32[0];
      _XMM1.m128_f32[0] = 1.0 / *(float *)&_XMM0;
      v40 = (float)(1.0 / *(float *)&_XMM0) * v45;
      v41 = v47 * _XMM1.m128_f32[0];
      v42 = v48 * _XMM1.m128_f32[0];
    }
  }
  n0x3F800000 = 0x3F800000u;
  *(float *)&n0x3F800000 = (float)(1.0 - fabs((float)((float)(v41 * v23) + (float)(v40 * v22)) + (float)(v42 * v24)))
                         * (float)(*(float *)(a4 + 4) * *(float *)a4);
  return (__m128)n0x3F800000;
}

// --- End Function: sub_14084E870 (0x14084E870) ---

// --- Function: sub_14084F100 (0x14084F100) ---
unsigned __int64 sub_14084F100(__int64 *a1, int a2, ...)
{
  __int64 v2; // r15
  __int64 v3; // rbx
  _QWORD *v4; // r14
  int v6; // esi
  __int64 v7; // r8
  unsigned __int64 v8; // rax
  unsigned __int64 *v9; // r13
  const char *p_true_3; // rsi
  __int64 v11; // rbp
  const char *p_true; // r9
  const char *p_true_1; // r8
  const char *p_true_2; // rdx
  __int64 v15; // r12
  unsigned int *v16; // rax
  unsigned int *v17; // rdi
  unsigned __int64 v18; // r9
  __int64 v19; // r8
  int v20; // r14d
  _QWORD *v21; // r15
  __int64 v22; // rdx
  __int64 **v23; // r8
  __int64 v24; // rax
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // rbp
  unsigned __int64 v27; // rsi
  __int64 *v28; // rdx
  _QWORD *v29; // rcx
  __int64 *v30; // rax
  __int64 v31; // r8
  __int64 v32; // r8
  __int64 *v33; // rsi
  __int64 v34; // rcx
  __int64 v35; // rax
  int v36; // r9d
  __int64 v37; // r10
  __int64 v38; // rcx
  __int64 v39; // r11
  __int64 v40; // rdx
  _WORD *v41; // r8
  unsigned __int64 p_p_Src; // rax
  _QWORD *v43; // rdi
  __int64 v44; // r8
  __int64 v45; // rcx
  int v46; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v48; // [rsp+38h] [rbp-60h] BYREF
  unsigned __int64 *v49; // [rsp+40h] [rbp-58h]
  __int64 v50; // [rsp+A0h] [rbp+8h]
  int v51; // [rsp+A8h] [rbp+10h] BYREF
  _QWORD *v52; // [rsp+B0h] [rbp+18h] BYREF
  va_list va; // [rsp+B0h] [rbp+18h]
  __int64 v54; // [rsp+B8h] [rbp+20h]
  va_list va1; // [rsp+C0h] [rbp+28h] BYREF

  va_start(va1, a2);
  va_start(va, a2);
  v52 = va_arg(va1, _QWORD *);
  v54 = va_arg(va1, _QWORD);
  v51 = a2;
  v2 = v54;
  v3 = (__int64)(a1 + 7);
  v4 = v52;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v6 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v7 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v8 = _InterlockedCompareExchange64((volatile signed __int64 *)v3, 0x200000, 0);
    if ( v8 )
      sub_1403E1120(v3, v8, v7, "CDamageMapPool::LazyCreatePBMBuffers", "m_geometryDataLock", 1);
    else
      *(_QWORD *)(v3 + 8) = v7;
    *(_DWORD *)(v3 + 0x10) = v6;
  }
  sub_1408486F0(a1, &v48, &v51);
  v9 = v49;
  p_true_3 = "false";
  v11 = v48;
  if ( dword_149D7FE5C )
  {
    p_true = "false";
    p_true_1 = "false";
    if ( *v4 )
      p_true = "true";
    p_true_2 = "false";
    if ( *(_QWORD *)(*(_QWORD *)(*v49 + 8) + 0x18LL) == *(_QWORD *)(*(_QWORD *)(*v49 + 8) + 0x20LL) )
      p_true_1 = "true";
    if ( v48 != a1[3] + *a1 )
      p_true_2 = "true";
    LogTraceConditional("[Damage Map Pool] | found? %s, buffer empty? %s, rootStatObj? %s", p_true_2, p_true_1, p_true);
  }
  v15 = 0;
  if ( v11 != *a1 + a1[3]
    && *(_QWORD *)(*(_QWORD *)(*v9 + 8) + 0x18LL) == *(_QWORD *)(*(_QWORD *)(*v9 + 8) + 0x20LL)
    && *v4 )
  {
    v16 = (unsigned int *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 0x5C0LL))(*v4);
    v17 = v16;
    if ( dword_149D7FE5C )
    {
      if ( v16 )
      {
        v18 = *((_QWORD *)v16 + 2) - *((_QWORD *)v16 + 1);
        v19 = *v16;
      }
      else
      {
        v18 = 0xFFFFFFFFFFFFFFFFuLL;
        v19 = 0xFFFFFFFFLL;
      }
      if ( v16 )
        p_true_3 = "true";
      LogTraceConditional(
        "[Damage Map Pool] | node? %s, node resolution: %i, node texeldata size: %zu",
        p_true_3,
        v19,
        v18);
    }
    if ( v17 )
    {
      if ( (int)*v17 > 0 )
      {
        v20 = *v17 * *v17;
        v21 = *(_QWORD **)(*v9 + 8);
        v22 = v21[4];
        v23 = (__int64 **)(v21 + 4);
        v24 = v21[3];
        v25 = (v22 - v24) >> 3;
        if ( v20 <= v25 )
        {
          v33 = (__int64 *)(v24 + 8LL * v20);
        }
        else
        {
          v26 = v20 - v25;
          if ( v26 <= (v21[5] - v22) >> 3 )
          {
            v33 = (__int64 *)(v22 + 8 * v26);
          }
          else
          {
            v27 = 2 * v25;
            if ( !v25 )
              v27 = 1;
            if ( v27 < v20 )
              v27 = v20;
            if ( v27 )
            {
              v50 = 8 * v27;
              v15 = sub_1402A65A0(8 * v27);
              v23 = (__int64 **)(v21 + 4);
            }
            else
            {
              v50 = 0;
            }
            v28 = *v23;
            v29 = (_QWORD *)v15;
            v30 = (__int64 *)v21[3];
            v31 = v50;
            if ( v30 != v28 )
            {
              do
              {
                v32 = *v30++;
                *v29++ = v32;
              }
              while ( v30 != v28 );
              v31 = 8 * v27;
            }
            v33 = &v29[v26];
            v34 = v21[3];
            if ( v34 )
            {
              sub_1402A6590(v34);
              v31 = v50;
            }
            v35 = v31 + v15;
            v21[3] = v15;
            v23 = (__int64 **)(v21 + 4);
            v21[5] = v35;
          }
        }
        *v23 = v33;
        v36 = 0;
        v37 = *((_QWORD *)v17 + 1);
        v38 = *(_QWORD *)(*v9 + 8);
        v39 = *(_QWORD *)(v38 + 0x18);
        for ( *(_DWORD *)(v38 + 0x58) = v17[0xC]; v36 < v20; v41[3] = *(_WORD *)((unsigned int)(v40 + 6) + v37) )
        {
          v40 = (unsigned int)(8 * v36);
          v41 = (_WORD *)(v39 + 8LL * (unsigned int)v36);
          *v41 = *(_WORD *)(v40 + v37);
          ++v36;
          v41[1] = *(_WORD *)((unsigned int)(v40 + 2) + v37);
          v41[2] = *(_WORD *)((unsigned int)(v40 + 4) + v37);
        }
        v2 = v54;
      }
      v4 = v52;
    }
  }
  p_p_Src = *v9;
  if ( !*(_QWORD *)(*(_QWORD *)(*v9 + 8) + 0x10LL) )
  {
    v43 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD **, __int64))(*(_QWORD *)*v4 + 0x5C8LL))(
                      *v4,
                      (_QWORD **)va,
                      v2);
    v44 = *(_QWORD *)(*v9 + 8);
    v45 = *(_QWORD *)(v44 + 0x10);
    *(_QWORD *)(v44 + 0x10) = *v43;
    *v43 = v45;
    if ( v45 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v45 + 8LL))(v45);
    *v43 = 0;
    if ( v52 )
      (*(void (__fastcall **)(_QWORD *))(*v52 + 8LL))(v52);
    p_p_Src = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x538LL))(qword_149C8E018);
    *(_DWORD *)(*(_QWORD *)(*v9 + 8) + 0x5CLL) = p_p_Src;
  }
  if ( v3 )
  {
    v46 = *(_DWORD *)(v3 + 0x14);
    if ( v46 )
    {
      p_p_Src = (unsigned int)(v46 - 1);
      *(_DWORD *)(v3 + 0x14) = p_p_Src;
    }
    else
    {
      *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v3, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_Src = (unsigned __int64)&p_Src;
        *(_QWORD *)(v3 + 8) = &p_Src;
      }
      else
      {
        p_p_Src = (unsigned __int64)rw_lock_handle_write_release_contention(v3, n0x200000);
      }
    }
  }
  if ( *v4 )
    p_p_Src = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 8LL))(*v4);
  *v4 = 0;
  return p_p_Src;
}

// --- End Function: sub_14084F100 (0x14084F100) ---

// --- Function: sub_14084F6B0 (0x14084F6B0) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_14084F6B0(__int64 a1, __int64 a2, __int64 a3, double a4, char *a5, unsigned int *a6)
{
  __int128 v6; // xmm6
  volatile signed __int64 *v11; // rbx
  signed __int64 v12; // rdx
  unsigned __int64 n0x3E8; // rdi
  __int128 n0x3A83126F; // xmm2
  __int64 v15; // rax
  int v16; // edx
  float v20; // kr00_4
  float v21; // xmm9_4
  float v22; // kr00_4
  float v23; // xmm7_4
  float v24; // kr00_4
  float v25; // xmm6_4
  float v26; // kr00_4
  __int128 v27; // xmm0
  __m128 v29; // xmm1
  __int64 v32; // rax
  __int64 v33; // rdx
  float v46; // xmm9_4
  float v48; // xmm11_4
  float v50; // xmm12_4
  __m128 n0x3F800000; // kr00_16
  __m128 v53; // xmm6
  float v56; // xmm0_4
  float v58; // xmm9_4
  float v60; // xmm0_4
  float v62; // xmm2_4
  int v64; // edi
  __int64 v65; // r8
  unsigned __int64 v66; // rax
  int v67; // eax
  unsigned __int64 n0x200000; // rax
  volatile signed __int64 *v70; // [rsp+60h] [rbp-A8h]
  _QWORD v71[5]; // [rsp+70h] [rbp-98h] BYREF
  __int128 v72; // [rsp+98h] [rbp-70h]
  double v73; // [rsp+A8h] [rbp-60h]
  int v74; // [rsp+B0h] [rbp-58h]
  int v75; // [rsp+B4h] [rbp-54h]
  double v76; // [rsp+B8h] [rbp-50h]
  int v77; // [rsp+C0h] [rbp-48h]
  __int64 v78; // [rsp+C8h] [rbp-40h]
  __m128 v79; // [rsp+D0h] [rbp-38h]
  __m128 v80; // [rsp+E0h] [rbp-28h]
  float v81; // [rsp+F0h] [rbp-18h]
  float v82; // [rsp+F4h] [rbp-14h]
  float v83; // [rsp+F8h] [rbp-10h]
  float v84; // [rsp+FCh] [rbp-Ch]
  __int128 v85; // [rsp+100h] [rbp-8h]
  float v86; // [rsp+110h] [rbp+8h]
  float v87; // [rsp+114h] [rbp+Ch]
  __int128 v88; // [rsp+118h] [rbp+10h]
  float v89; // [rsp+128h] [rbp+20h]
  float v90; // [rsp+12Ch] [rbp+24h]
  float v91; // [rsp+130h] [rbp+28h]
  float v92; // [rsp+134h] [rbp+2Ch]
  float v93; // [rsp+138h] [rbp+30h]
  float v94; // [rsp+13Ch] [rbp+34h]
  float v95; // [rsp+140h] [rbp+38h]
  float v96; // [rsp+144h] [rbp+3Ch]
  float v97; // [rsp+148h] [rbp+40h]
  float v98; // [rsp+14Ch] [rbp+44h]
  float v99; // [rsp+150h] [rbp+48h]
  __int64 v100; // [rsp+158h] [rbp+50h]
  char v101; // [rsp+160h] [rbp+58h]
  float v102; // [rsp+164h] [rbp+5Ch]
  float v103; // [rsp+168h] [rbp+60h]
  float v104; // [rsp+16Ch] [rbp+64h]
  int n0x900; // [rsp+178h] [rbp+70h] BYREF
  __int64 v106; // [rsp+17Ch] [rbp+74h]
  int v107; // [rsp+184h] [rbp+7Ch]
  unsigned __int64 v108; // [rsp+188h] [rbp+80h]
  unsigned __int64 v109; // [rsp+190h] [rbp+88h]
  __int64 v110; // [rsp+198h] [rbp+90h]
  __int64 v111; // [rsp+1A0h] [rbp+98h]
  __int128 v112; // [rsp+228h] [rbp+120h]

  v112 = v6;
  v106 = 0;
  v107 = 0;
  v109 = 0;
  v110 = 0;
  v111 = 0;
  _XMM6 = *(_OWORD *)&a4;
  n0x900 = 0x900;
  v108 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFAC,
    "CDamageMap::MT_AddImpactLocal",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x14F);
  HIWORD(n0x900) = word_149D7FFAC;
  v11 = (volatile signed __int64 *)(a1 + 0x160);
  if ( *(_DWORD *)(a1 + 0x170) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x174);
  }
  else
  {
    v12 = _InterlockedIncrement64(v11);
    if ( (v12 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0x160, v12, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  n0x3E8 = (*(_QWORD *)(a1 + 0x150) - *(_QWORD *)(a1 + 0x148)) / 0xF8LL;
  rw_lock_release_read_lock(a1 + 0x160);
  if ( n0x3E8 < 0x3E8 )
  {
    n0x3A83126F = 0x3A83126Fu;
    *(__m256 *)&v71[1] = ymmword_1482EE6E0;
    v15 = *((_QWORD *)a5 + 9);
    v16 = *((_DWORD *)a5 + 0x17);
    v72 = xmmword_14832FC60;
    v88 = 0;
    v100 = v15;
    __asm
    {
      vcmpless xmm0, xmm2, xmm1
      vblendvps xmm1, xmm6, xmm1, xmm0
      vmaxss  xmm0, xmm1, xmm2
    }
    *(_QWORD *)&_XMM1 = *(_QWORD *)a2;
    v101 = *a5;
    v74 = *(_DWORD *)(a2 + 8);
    LODWORD(v15) = *(unsigned __int8 *)(a1 + 0xC0);
    v103 = *(float *)&_XMM0;
    *(_QWORD *)&_XMM0 = *(_QWORD *)a3;
    v75 = v15;
    LODWORD(v15) = *(_DWORD *)(a3 + 8);
    v76 = *(double *)&_XMM0;
    v86 = 0.0;
    v87 = 0.0;
    v89 = 0.0;
    v90 = 0.0;
    v102 = 0.0;
    v104 = 0.0;
    v73 = *(double *)&_XMM1;
    v77 = v15;
    __asm { vzeroupper }
    sub_140572410((__int64)&qword_149A6A5E0, v16);
    v20 = (float)(unsigned int)sub_1405722D0((__int64)&qword_149A6A5E0);
    v21 = v20 * 2.3283064e-10;
    v22 = (float)(unsigned int)sub_1405722D0((__int64)&qword_149A6A5E0);
    v23 = v22 * 2.3283064e-10;
    v24 = (float)(unsigned int)sub_1405722D0((__int64)&qword_149A6A5E0);
    v25 = v24 * 2.3283064e-10;
    v26 = (float)(unsigned int)sub_1405722D0((__int64)&qword_149A6A5E0);
    v27 = *(_OWORD *)(a5 + 4);
    _XMM8 = *(__m128 *)(a5 + 0x24);
    v95 = v26 * 2.3283064e-10;
    v29 = *(__m128 *)(a5 + 0x14);
    v97 = v23;
    v85 = v27;
    _XMM0 = *((unsigned int *)a5 + 0x11);
    v79 = v29;
    v96 = v25;
    v98 = v21;
    v80 = _XMM8;
    if ( *(float *)&_XMM0 >= 0.0 )
    {
      __asm { vminss  xmm0, xmm0, xmm7 }
      v99 = *(float *)&_XMM0;
    }
    else
    {
      v99 = 0.0;
    }
    v32 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))(qword_149C8E018);
    if ( *a5 == 2 )
      v33 = *(_QWORD *)(v32 + 0x78);
    else
      v33 = *(_QWORD *)(v32 + 0x80);
    _XMM1 = *((unsigned int *)a5 + 0xD);
    __asm
    {
      vcmpless xmm0, xmm1, xmm3
      vblendvps xmm0, xmm1, xmm2, xmm0
    }
    _XMM1 = *((unsigned int *)a5 + 0xE);
    _XMM2 = *((unsigned int *)a5 + 0xF);
    v81 = *(float *)&_XMM0;
    __asm
    {
      vcmpless xmm0, xmm1, xmm3
      vblendvps xmm0, xmm1, xmm4, xmm0
    }
    _XMM1 = *((unsigned int *)a5 + 0x10);
    v82 = *(float *)&_XMM0;
    __asm
    {
      vcmpless xmm0, xmm2, xmm3
      vblendvps xmm0, xmm2, xmm5, xmm0
    }
    v83 = *(float *)&_XMM0;
    __asm
    {
      vcmpless xmm0, xmm1, xmm3
      vblendvps xmm0, xmm1, xmm6, xmm0
    }
    v84 = *(float *)&_XMM0;
    LODWORD(v46) = _mm_shuffle_ps(_XMM8, _XMM8, 0x55).m128_u32[0];
    __asm { vmaxss  xmm0, xmm8, xmm9 }
    LODWORD(v48) = _mm_shuffle_ps(_XMM8, _XMM8, 0xAA).m128_u32[0];
    __asm { vmaxss  xmm1, xmm0, xmm11 }
    LODWORD(v50) = _mm_shuffle_ps(_XMM8, _XMM8, 0xFF).m128_u32[0];
    __asm { vmaxss  xmm0, xmm1, xmm12 }
    v78 = v33;
    if ( *(float *)&_XMM0 > 0.0 )
    {
      n0x3F800000 = (__m128)0x3F800000u;
      n0x3F800000.m128_f32[0] = 1.0 / *(float *)&_XMM0;
      v53 = _mm_shuffle_ps(n0x3F800000, n0x3F800000, 0);
      v80.m128_f32[0] = v53.m128_f32[0] * _XMM8.m128_f32[0];
      v80.m128_f32[1] = v53.m128_f32[0] * v46;
      v80.m128_f32[2] = v53.m128_f32[0] * v48;
      v80.m128_f32[3] = v53.m128_f32[0] * v50;
      v79 = _mm_mul_ps(v53, v79);
      *(float *)&v71[1] = v53.m128_f32[0];
      *((float *)&v71[3] + 1) = v53.m128_f32[0];
      *((float *)&v72 + 2) = v53.m128_f32[0];
    }
    _XMM0 = *a6;
    if ( *(float *)&_XMM0 >= 0.0 )
      __asm { vminss  xmm1, xmm0, xmm7 }
    else
      LODWORD(_XMM1) = 0;
    v56 = truncf(*(float *)&_XMM1 * 255.0);
    _XMM1 = a6[1];
    v58 = v56 * 0.0039215689;
    if ( *(float *)&_XMM1 >= 0.0 )
      __asm { vminss  xmm0, xmm1, xmm7 }
    else
      LODWORD(_XMM0) = 0;
    v60 = truncf(*(float *)&_XMM0 * 255.0);
    _XMM1 = a6[2];
    v62 = v60 * 0.0039215689;
    if ( *(float *)&_XMM1 >= 0.0 )
      __asm { vminss  xmm0, xmm1, xmm7 }
    else
      LODWORD(_XMM0) = 0;
    v91 = v58;
    v92 = v62;
    v93 = truncf(*(float *)&_XMM0 * 255.0) * 0.0039215689;
    v94 = 0.0;
    v70 = (volatile signed __int64 *)(a1 + 0x160);
    v64 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x170) == v64 )
    {
      ++*(_DWORD *)(a1 + 0x174);
    }
    else
    {
      v65 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v66 = _InterlockedCompareExchange64(v11, 0x200000, 0);
      if ( v66 )
        sub_1403E1120(a1 + 0x160, v66, v65, (const char *)&p_Src, (const char *)&p_Src, 1);
      else
        *(_QWORD *)(a1 + 0x168) = v65;
      *(_DWORD *)(a1 + 0x170) = v64;
    }
    if ( *(_QWORD *)(a1 + 0x150) == *(_QWORD *)(a1 + 0x158) )
    {
      sub_140844BC0((__int64 *)(a1 + 0x148), *(_QWORD *)(a1 + 0x150), (__int64)&v71[1]);
    }
    else
    {
      sub_140849E50(*(_QWORD *)(a1 + 0x150), (__int64)&v71[1]);
      *(_QWORD *)(a1 + 0x150) += 0xF8LL;
    }
    *(_WORD *)(a1 + 0x1DC) &= ~4u;
    v67 = *(_DWORD *)(a1 + 0x174);
    if ( v67 )
    {
      *(_DWORD *)(a1 + 0x174) = v67 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x170) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(v70, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(a1 + 0x168) = &p_Src;
      else
        rw_lock_handle_write_release_contention((__int64)v70, n0x200000);
    }
  }
  v109 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_14084F6B0 (0x14084F6B0) ---

// --- Function: sub_14084FD10 (0x14084FD10) ---
__int64 __fastcall sub_14084FD10(__int64 a1, double *a2, unsigned __int64 *a3, float a4, char *a5, unsigned int *a6)
{
  __int128 v9; // xmm11
  double v10; // xmm8_8
  double v11; // xmm10_8
  double v12; // kr00_8
  double v13; // xmm7_8
  double v14; // xmm6_8
  double v15; // xmm4_8
  double v16; // xmm5_8
  __int128 v17; // kr00_16
  double v18; // xmm6_8
  __int128 v20; // xmm9
  __int128 v24; // xmm10
  double v27; // xmm8_8
  double v28; // xmm7_8
  double v29; // xmm5_8
  double v30; // xmm6_8
  __int128 v31; // xmm0
  float v39; // [rsp+30h] [rbp-D0h] BYREF
  float v40; // [rsp+34h] [rbp-CCh]
  float v41; // [rsp+38h] [rbp-C8h]
  float v42; // [rsp+40h] [rbp-C0h] BYREF
  float v43; // [rsp+44h] [rbp-BCh]
  float v44; // [rsp+48h] [rbp-B8h]
  int n0x900; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v46; // [rsp+54h] [rbp-ACh]
  int v47; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v48; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v49; // [rsp+68h] [rbp-98h]
  __int64 v50; // [rsp+70h] [rbp-90h]
  __int64 v51; // [rsp+78h] [rbp-88h]
  double v52; // [rsp+A0h] [rbp-60h] BYREF
  double v53; // [rsp+A8h] [rbp-58h]
  double v54; // [rsp+B0h] [rbp-50h]
  double v55; // [rsp+B8h] [rbp-48h]
  double v56; // [rsp+C0h] [rbp-40h]
  double v57; // [rsp+C8h] [rbp-38h]
  double v58; // [rsp+D0h] [rbp-30h]
  double v59; // [rsp+D8h] [rbp-28h]

  n0x900 = 0x900;
  v46 = 0;
  v47 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v48 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFB0,
    "CDamageMap::MT_AddImpactZone",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x1BB);
  v42 = 0.0;
  v43 = 0.0;
  v44 = 0.0;
  v39 = 0.0;
  v40 = 0.0;
  v41 = 0.0;
  HIWORD(n0x900) = word_149D7FFB0;
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x140)) )
  {
    (*(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL)
                                                       + 0x1E8LL))(
      *(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL,
      &v52,
      2);
    v9 = a3[2];
    v10 = (*a2 - v56) * (1.0 / v59);
    v11 = (a2[2] - v58) * (1.0 / v59);
    v12 = (a2[1] - v57) * (1.0 / v59);
    v13 = v12 * v54 - v11 * v53 + v10 * v55;
    v14 = v11 * v52 - v10 * v54 + v12 * v55;
    v15 = v10 * v53 - v12 * v52 + v11 * v55;
    v16 = v54 * v14 - v53 * v15;
    *((_QWORD *)&v17 + 1) = 0;
    v18 = v53 * v13 - v52 * v14;
    *(double *)&v17 = v10 + v16 + v16;
    _XMM2 = v17;
    *((_QWORD *)&v17 + 1) = 0;
    v20 = *a3;
    *(double *)&v17 = (a2[1] - v57) * (1.0 / v59) + v52 * v15 - v54 * v13 + v52 * v15 - v54 * v13;
    _XMM1 = v17;
    __asm
    {
      vcvtsd2ss xmm3, xmm1, xmm1
      vcvtsd2ss xmm4, xmm2, xmm2
    }
    *(double *)&v17 = v11 + v18;
    v24 = a3[1];
    _XMM0 = COERCE_UNSIGNED_INT64(*(double *)&v17 + v18);
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    v44 = *(float *)&_XMM1;
    v43 = *(float *)&_XMM3;
    v27 = *(double *)&v24 * v54 - *(double *)&v9 * v53 + *(double *)&v20 * v55;
    v42 = *(float *)&_XMM4;
    v28 = *(double *)&v9 * v52 - *(double *)&v20 * v54 + *(double *)&v24 * v55;
    *(double *)&_XMM2 = *(double *)&v20 * v53 - *(double *)&v24 * v52;
    v29 = v54 * v28 - v53 * (*(double *)&_XMM2 + *(double *)&v9 * v55);
    v30 = v52 * (*(double *)&_XMM2 + *(double *)&v9 * v55) - v54 * v27;
    *((_QWORD *)&v17 + 1) = *((_QWORD *)&v24 + 1);
    *(double *)&v17 = *(double *)&v24 + v30;
    v31 = v17;
    *((_QWORD *)&v17 + 1) = *((_QWORD *)&v20 + 1);
    *(double *)&v17 = *(double *)&v20 + v29 + v29;
    _XMM2 = v17;
    *((_QWORD *)&v17 + 1) = *((_QWORD *)&v31 + 1);
    *(double *)&v17 = *(double *)&v31 + v30;
    _XMM1 = v17;
    __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
    *((_QWORD *)&v17 + 1) = *((_QWORD *)&v9 + 1);
    *(double *)&v17 = *(double *)&v9 + v53 * v27 - v52 * v28 + v53 * v27 - v52 * v28;
    _XMM0 = v17;
    __asm
    {
      vcvtsd2ss xmm3, xmm1, xmm1
      vcvtsd2ss xmm1, xmm0, xmm0
    }
    v41 = *(float *)&_XMM1;
    v39 = *(float *)&_XMM4;
    v40 = *(float *)&_XMM3;
  }
  sub_14084F6B0(a1, (__int64)&v42, (__int64)&v39, COERCE_DOUBLE((unsigned __int64)LODWORD(a4)), a5, a6);
  v49 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_14084FD10 (0x14084FD10) ---

// --- Function: sub_1408500C0 (0x1408500C0) ---
char __fastcall sub_1408500C0(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, char a6)
{
  __int128 v6; // xmm6
  __int128 v7; // xmm7
  __int128 v8; // xmm8
  __int128 v9; // xmm9
  __int128 v10; // xmm10
  __int128 v11; // xmm11
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rsi
  __int64 v19; // rcx
  void (__fastcall ***v20)(_QWORD); // rcx
  __int64 v21; // rax
  __int64 *v22; // rbx
  __int64 v23; // rcx
  bool v24; // zf
  __int64 *v25; // rcx
  void (__fastcall ***v26)(_QWORD); // rsi
  void (__fastcall ***v27)(_QWORD); // rcx
  void (__fastcall **v28)(_QWORD); // rax
  void (__fastcall ***v29)(_QWORD); // r13
  float v30; // xmm6_4
  float v31; // xmm7_4
  float v32; // xmm8_4
  float v33; // xmm9_4
  double v34; // xmm10_8
  float v35; // xmm11_4
  __int64 *v36; // rax
  __int64 v37; // r15
  int v38; // ecx
  int v39; // eax
  unsigned __int64 n0x200000; // rax
  void (__fastcall ***v41)(_QWORD); // [rsp+30h] [rbp-D0h]
  _QWORD v42[3]; // [rsp+38h] [rbp-C8h] BYREF
  float v43; // [rsp+50h] [rbp-B0h]
  float v44; // [rsp+54h] [rbp-ACh]
  float v45; // [rsp+58h] [rbp-A8h]
  float v46; // [rsp+5Ch] [rbp-A4h]
  double v47; // [rsp+60h] [rbp-A0h]
  int v48; // [rsp+68h] [rbp-98h]
  float v49; // [rsp+6Ch] [rbp-94h]
  __int64 *v50; // [rsp+70h] [rbp-90h]
  __int64 *v51[2]; // [rsp+78h] [rbp-88h] BYREF
  _DWORD *v52; // [rsp+88h] [rbp-78h]
  __int64 *v53[2]; // [rsp+98h] [rbp-68h] BYREF
  _DWORD *v54; // [rsp+A8h] [rbp-58h]
  __int128 v55; // [rsp+C0h] [rbp-40h]
  __int128 v56; // [rsp+D0h] [rbp-30h]
  __int128 v57; // [rsp+E0h] [rbp-20h]
  __int128 v58; // [rsp+F0h] [rbp-10h]
  __int128 v59; // [rsp+100h] [rbp+0h]
  __int128 v60; // [rsp+110h] [rbp+10h]
  void (__fastcall ***v61)(_QWORD); // [rsp+168h] [rbp+68h] BYREF

  if ( !*a4 )
  {
    *a4 = 0;
    return 0;
  }
  v16 = a1 + 0x178;
  if ( a6 )
  {
    sub_1402E6730(v16, (__int64)v51);
    v17 = v51[0][1];
    v18 = *v51[0];
    if ( *v51[0] == v17 )
      goto LABEL_12;
    do
    {
      if ( *(_QWORD *)v18 == *a4 && *(_QWORD *)(v18 + 0x10) != a2 )
        break;
      v18 += 0x38;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_12:
      v20 = (void (__fastcall ***)(_QWORD))*a4;
      v61 = v20;
      if ( v20 )
        (**v20)(v20);
      v21 = sub_14084A000((__int64)v42, &v61, a3, a2, a5);
      v22 = v51[0];
      v23 = v51[0][1];
      if ( v23 == v51[0][2] )
      {
        sub_140845070(v51[0], v51[0][1], v21);
      }
      else
      {
        sub_140849F90(v23, v21);
        v22[1] += 0x38;
      }
      if ( v42[0] )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v42[0] + 8LL))(v42[0]);
    }
    else
    {
      if ( sub_1403113B0((__int64 *)(v18 + 8)) )
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFLL) + 0x1D8LL))(
          *(_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFLL),
          0);
      v19 = a5;
      *(_QWORD *)(v18 + 0x10) = a2;
      *(_QWORD *)(v18 + 8) = a3;
      *(_DWORD *)(v18 + 0x18) = *(_DWORD *)v19;
      *(_DWORD *)(v18 + 0x1C) = *(_DWORD *)(v19 + 4);
      *(_DWORD *)(v18 + 0x20) = *(_DWORD *)(v19 + 8);
      *(_DWORD *)(v18 + 0x24) = *(_DWORD *)(v19 + 0xC);
      *(double *)(v18 + 0x28) = *(double *)(v19 + 0x10);
      *(_DWORD *)(v18 + 0x30) = *(_DWORD *)(v19 + 0x18);
      *(_DWORD *)(v18 + 0x34) = *(_DWORD *)(v19 + 0x1C);
    }
    v24 = (*v52)-- == 1;
    if ( !v24 )
      goto LABEL_40;
    v25 = v51[1];
  }
  else
  {
    v60 = v6;
    v59 = v7;
    v58 = v8;
    v57 = v9;
    v56 = v10;
    v55 = v11;
    sub_1402E6730(v16, (__int64)v53);
    v26 = (void (__fastcall ***)(_QWORD))*a4;
    v27 = (void (__fastcall ***)(_QWORD))*a4;
    if ( *a4 )
    {
      (**v26)(v27);
      v28 = *v26;
      v42[0] = v26;
      v29 = v26;
      (*v28)(v26);
      v27 = v26;
      v41 = v26;
    }
    else
    {
      v41 = 0;
      v29 = (void (__fastcall ***)(_QWORD))*a4;
      v42[0] = 0;
    }
    v42[1] = a3;
    v42[2] = a2;
    LODWORD(v61) = *(_DWORD *)(a5 + 0x18);
    v48 = (int)v61;
    v30 = *(float *)(a5 + 0xC);
    v31 = *(float *)a5;
    v32 = *(float *)(a5 + 4);
    v33 = *(float *)(a5 + 8);
    v34 = *(double *)(a5 + 0x10);
    v35 = *(float *)(a5 + 0x1C);
    v46 = v30;
    v43 = v31;
    v44 = v32;
    v45 = v33;
    v49 = v35;
    v47 = v34;
    if ( v27 )
      (*v27)[1](v27);
    v36 = v53[0];
    v50 = v53[0];
    v37 = v53[0][1];
    if ( v37 == v53[0][2] )
    {
      sub_140845070(v53[0], v53[0][1], (__int64)v42);
      v26 = (void (__fastcall ***)(_QWORD))v42[0];
    }
    else
    {
      *(_QWORD *)v37 = v29;
      if ( v29 )
      {
        (**v41)(v29);
        v36 = v50;
      }
      v38 = (int)v61;
      *(_QWORD *)(v37 + 8) = a3;
      *(_QWORD *)(v37 + 0x10) = a2;
      *(float *)(v37 + 0x24) = v30;
      *(float *)(v37 + 0x18) = v31;
      *(float *)(v37 + 0x1C) = v32;
      *(float *)(v37 + 0x20) = v33;
      *(double *)(v37 + 0x28) = v34;
      *(_DWORD *)(v37 + 0x30) = v38;
      *(float *)(v37 + 0x34) = v35;
      v36[1] += 0x38;
    }
    if ( v26 )
      (*v26)[1](v26);
    v24 = (*v54)-- == 1;
    if ( !v24 )
      goto LABEL_40;
    v25 = v53[1];
  }
  v39 = *((_DWORD *)v25 + 5);
  if ( v39 )
  {
    *((_DWORD *)v25 + 5) = v39 - 1;
  }
  else
  {
    *((_DWORD *)v25 + 4) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64(v25, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
      v25[1] = (__int64)&p_Src;
    else
      rw_lock_handle_write_release_contention((__int64)v25, n0x200000);
  }
LABEL_40:
  if ( *a4 )
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a4 + 8LL))(*a4);
  *a4 = 0;
  return 1;
}

// --- End Function: sub_1408500C0 (0x1408500C0) ---

// --- Function: sub_140850620 (0x140850620) ---
char __fastcall sub_140850620(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  void (__fastcall ****v7)(_QWORD); // rdi
  void (__fastcall ****v8)(_QWORD); // rsi
  void (__fastcall ***v9)(_QWORD); // rcx
  __int64 v11[3]; // [rsp+30h] [rbp-18h] BYREF
  void (__fastcall ***v12)(_QWORD); // [rsp+68h] [rbp+20h] BYREF

  if ( *(_QWORD *)a4 != *(_QWORD *)(a4 + 8) )
  {
    sub_14051EB30(a3, v11);
    v7 = *(void (__fastcall *****)(_QWORD))a4;
    v8 = *(void (__fastcall *****)(_QWORD))(a4 + 8);
    if ( v7 == v8 )
    {
LABEL_7:
      *(_DWORD *)(a1 + 0x1C0) = 0xFFFFFFFF;
      return 1;
    }
    while ( 1 )
    {
      v9 = *v7;
      v12 = v9;
      if ( v9 )
        (**v9)(v9);
      if ( !sub_1408500C0(a1, a2, v11[0], &v12, (__int64)(v7 + 1), 1) )
        break;
      v7 += 5;
      if ( v7 == v8 )
        goto LABEL_7;
    }
  }
  return 0;
}

// --- End Function: sub_140850620 (0x140850620) ---

// --- Function: sub_140850EF0 (0x140850EF0) ---
__int64 __fastcall sub_140850EF0(int *a1, unsigned int n2, int a3)
{
  int v3; // r10d
  int v7; // ebx
  int v8; // r11d
  unsigned int n2_1; // edx
  int v10; // eax
  int v11; // r8d
  unsigned int v12; // edx
  __int64 v13; // rbp
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  int v17; // r11d

  v3 = 0;
  v7 = 0;
  v8 = 0;
  n2_1 = 0;
  if ( n2 >= 2 )
  {
    v10 = *a1;
    v11 = a1[1];
    v12 = ((n2 - 2) >> 1) + 1;
    v13 = v12;
    n2_1 = 2 * v12;
    do
    {
      v14 = v10 * v10;
      v15 = v10 >> 1;
      v11 >>= 2;
      v3 += a3 * v14;
      v16 = v15 * v15;
      v10 = v15 >> 1;
      v7 += a3 * v16;
      --v13;
    }
    while ( v13 );
    *a1 = v10;
    a1[1] = v11;
  }
  if ( n2_1 < n2 )
  {
    v17 = *a1 * *a1;
    *a1 >>= 1;
    v8 = a3 * v17;
    a1[1] >>= 1;
  }
  return (unsigned int)(v8 + v7 + v3);
}

// --- End Function: sub_140850EF0 (0x140850EF0) ---

// --- Function: sub_140850F90 (0x140850F90) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_140850F90(int a1, __int64 a2, char n2, double a4, float a5, float a6, float a7, int a8)
{
  __int128 v8; // xmm6
  __int128 v9; // xmm7
  __int128 v10; // xmm8
  __int128 v11; // xmm9
  __int128 v12; // xmm10
  __int128 v13; // xmm11
  __int128 v14; // xmm12
  __int128 v15; // xmm13
  __int128 v16; // xmm14
  __int128 v17; // xmm15
  float v23; // xmm7_4
  __int64 v25; // rax
  float *v26; // rax
  int v27; // r9d
  float *v28; // rbx
  float v29; // xmm2_4
  float v30; // xmm3_4
  float v31; // xmm4_4
  float v32; // xmm5_4
  float v33; // xmm10_4
  float v34; // xmm11_4
  float v35; // xmm12_4
  float v36; // xmm13_4
  float v37; // xmm14_4
  float v38; // xmm15_4
  float v39; // xmm0_4
  float v42; // xmm14_4
  float v43; // xmm11_4
  float v44; // xmm12_4
  float v45; // xmm13_4
  float v46; // xmm0_4
  float v47; // xmm2_4
  __int128 v49; // kr00_16
  int v53; // [rsp+48h] [rbp-C0h] BYREF
  float v54; // [rsp+4Ch] [rbp-BCh]
  float v55; // [rsp+50h] [rbp-B8h]
  float v56; // [rsp+54h] [rbp-B4h]
  float v57; // [rsp+58h] [rbp-B0h]
  float v58; // [rsp+5Ch] [rbp-ACh]
  float v59; // [rsp+60h] [rbp-A8h]
  float v60; // [rsp+64h] [rbp-A4h]
  float v61; // [rsp+68h] [rbp-A0h]
  float v62; // [rsp+6Ch] [rbp-9Ch]
  float v63; // [rsp+70h] [rbp-98h]
  _QWORD v64[3]; // [rsp+74h] [rbp-94h]
  int v65; // [rsp+8Ch] [rbp-7Ch]
  __int64 v66; // [rsp+90h] [rbp-78h]
  float v67; // [rsp+98h] [rbp-70h]
  float v68; // [rsp+9Ch] [rbp-6Ch]
  float v69; // [rsp+A0h] [rbp-68h]
  int v70; // [rsp+A4h] [rbp-64h]
  int n0x900; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v72; // [rsp+ACh] [rbp-5Ch]
  int v73; // [rsp+B4h] [rbp-54h]
  unsigned __int64 v74; // [rsp+B8h] [rbp-50h]
  unsigned __int64 v75; // [rsp+C0h] [rbp-48h]
  __int64 v76; // [rsp+C8h] [rbp-40h]
  __int64 v77; // [rsp+D0h] [rbp-38h]
  __int128 v78; // [rsp+F8h] [rbp-10h]
  __int128 v79; // [rsp+108h] [rbp+0h]
  __int128 v80; // [rsp+118h] [rbp+10h]
  __int128 v81; // [rsp+128h] [rbp+20h]
  __int128 v82; // [rsp+138h] [rbp+30h]
  __int128 v83; // [rsp+148h] [rbp+40h]
  __int128 v84; // [rsp+158h] [rbp+50h]
  __int128 v85; // [rsp+168h] [rbp+60h]
  __int128 v86; // [rsp+178h] [rbp+70h]
  __int128 v87; // [rsp+188h] [rbp+80h]
  float v88; // [rsp+1D0h] [rbp+C8h]
  float v89; // [rsp+1D8h] [rbp+D0h]
  float v90; // [rsp+1E8h] [rbp+E0h]
  float v91; // [rsp+1F0h] [rbp+E8h]
  float v92; // [rsp+200h] [rbp+F8h]

  v87 = v8;
  v86 = v9;
  v85 = v10;
  v84 = v11;
  v83 = v12;
  v82 = v13;
  v81 = v14;
  v80 = v15;
  v79 = v16;
  v78 = v17;
  _XMM9 = *(_OWORD *)&a4;
  n0x900 = 0x900;
  v72 = 0;
  v73 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v74 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFA8,
    "CDamageMap::MT_CalculateWeaponDamage",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xEA);
  HIWORD(n0x900) = word_149D7FFA8;
  v66 = 0;
  LOBYTE(v53) = n2;
  v70 = a8;
  _XMM6 = LODWORD(a5);
  v23 = a6;
  *(_OWORD *)&v64[1] = xmmword_148341EA0;
  v65 = dword_149D7FEA0;
  v67 = 0.0;
  v68 = 0.0;
  v69 = 0.0;
  if ( n2 == 1 && (a6 < 0.001 || a5 < 0.001) )
  {
    __asm { vmaxss  xmm0, xmm6, xmm7 }
    v23 = *(float *)&_XMM0 * 0.5;
    *(float *)&_XMM6 = *(float *)&_XMM0 * 0.5;
  }
  v25 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))(qword_149C8E018);
  v26 = (float *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x10LL))(v25);
  v28 = v26;
  if ( n2 == 2 )
  {
    v29 = v26[0x2A];
    v30 = v26[0x2B];
    v31 = v26[0x2C];
    v32 = v26[0x2D];
    v33 = v26[0x30];
    v34 = v26[0x31];
    v35 = v26[0x32];
    v36 = v26[0x33];
    v37 = v26[0x36];
    v38 = v26[0x37];
    v89 = v26[0x38];
    v91 = v26[0x39];
    v90 = v26[0x3C];
    v92 = v26[0x3D];
    v88 = v26[0x3E];
    v39 = v26[0x3F];
  }
  else
  {
    v29 = v26[8];
    v30 = v26[9];
    v31 = v26[0xA];
    v32 = v26[0xB];
    v33 = v26[0xE];
    v34 = v26[0xF];
    v35 = v26[0x10];
    v36 = v26[0x11];
    v37 = v26[0x14];
    v38 = v26[0x15];
    v89 = v26[0x16];
    v91 = v26[0x17];
    v90 = v26[0x1A];
    v92 = v26[0x1B];
    v88 = v26[0x1C];
    v39 = v26[0x1D];
  }
  __asm { vcmpltss xmm1, xmm9, cs:dword_1482BB398 }
  __asm { vblendvps xmm9, xmm9, xmm0, xmm1 }
  v58 = v37 * *(float *)&_XMM9;
  v60 = *(float *)&_XMM9 * v89;
  v62 = *(float *)&_XMM9 * v90;
  *(float *)v64 = *(float *)&_XMM9 * v88;
  v59 = v38 * *(float *)&_XMM9;
  v61 = *(float *)&_XMM9 * v91;
  v63 = *(float *)&_XMM9 * v92;
  v42 = (float)(v29 * *(float *)&_XMM6) + (float)(v33 * v23);
  *((float *)v64 + 1) = *(float *)&_XMM9 * v39;
  v43 = (float)(v30 * *(float *)&_XMM6) + (float)(v34 * v23);
  v44 = (float)(v35 * v23) + (float)(v31 * *(float *)&_XMM6);
  v45 = (float)(v32 * *(float *)&_XMM6) + (float)(v36 * v23);
  v57 = v45;
  v54 = v42;
  v55 = v43;
  v56 = v44;
  if ( n2 != 2 )
  {
    v46 = powf(*(float *)&_XMM9, *(float *)&dword_149A71264);
    v47 = 1.0 / (float)(v46 * 3.1415927);
    v57 = (float)(v47 * v45) * *(float *)&dword_149A71260;
    v54 = (float)(v42 / (float)(v46 * 3.1415927)) * *(float *)&dword_149A71260;
    v55 = (float)(v47 * v43) * *(float *)&dword_149A71260;
    v56 = (float)(v47 * v44) * *(float *)&dword_149A71260;
  }
  sub_140854340(a1, a2, (unsigned int)&v53, v27, 0);
  if ( n2 == 1 )
  {
    *(float *)(a2 + 0x10) = v23 * v28[0x48];
    if ( a7 > 0.0 )
    {
      __asm { vmaxss  xmm2, xmm9, cs:dword_1482C3BC0 }
      v49 = LODWORD(a7);
      *(float *)&v49 = (float)((float)((float)(a7 * a7) * a7)
                             / (float)((float)(*(float *)&_XMM2 * *(float *)&_XMM2) * *(float *)&_XMM2))
                     * v28[0x49];
      _XMM3 = v49;
      __asm { vminss  xmm4, xmm3, xmm10 }
      *(__m128 *)(a2 + 4) = _mm_mul_ps(_mm_shuffle_ps(_XMM4, _XMM4, 0), *(__m128 *)(a2 + 4));
    }
  }
  v75 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return a2;
}

// --- End Function: sub_140850F90 (0x140850F90) ---

// --- Function: sub_140851510 (0x140851510) ---
__int64 __fastcall sub_140851510(__int64 a1, __int64 *a2)
{
  __int64 v4; // rdx
  __int64 v5; // rbx
  char v6; // r15
  char v7; // r14
  __int64 v8; // r13
  __int64 v9; // rdi
  __int64 v10; // rbx
  bool v11; // zf
  __int64 v12; // rcx
  int v13; // eax
  unsigned __int8 v14; // bl
  unsigned __int64 n0x200000; // rax
  int n0x900; // [rsp+30h] [rbp-59h] BYREF
  __int64 v18; // [rsp+34h] [rbp-55h]
  int v19; // [rsp+3Ch] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+40h] [rbp-49h]
  unsigned __int64 v21; // [rsp+48h] [rbp-41h]
  __int64 v22; // [rsp+50h] [rbp-39h]
  __int64 v23; // [rsp+58h] [rbp-31h]
  _QWORD v24[2]; // [rsp+80h] [rbp-9h] BYREF
  _DWORD *v25; // [rsp+90h] [rbp+7h]
  _QWORD *v26; // [rsp+A0h] [rbp+17h] BYREF
  __int64 v27; // [rsp+A8h] [rbp+1Fh]
  _DWORD *v28; // [rsp+B0h] [rbp+27h]

  n0x900 = 0x900;
  v18 = 0;
  v19 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v20 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFF4,
    "CDamageMap::MT_ComputeImpactsIntoDamageMap",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x94B);
  v4 = *a2;
  HIWORD(n0x900) = word_149D7FFF4;
  if ( *(_DWORD *)(v4 + 0x44) >= (unsigned int)dword_149C8E13C )
    goto LABEL_31;
  if ( *(_DWORD *)(a1 + 0x1C0) == 0xFFFFFFFF
    || (*(_BYTE *)(a1 + 0x1DC) & 2) != 0
    || *(_QWORD *)(*(_QWORD *)(a1 + 0x120) + 0x18LL) == *(_QWORD *)(*(_QWORD *)(a1 + 0x120) + 0x20LL)
    || *(_QWORD *)(v4 + 8) == *(_QWORD *)(v4 + 0x10) )
  {
    goto LABEL_32;
  }
  v5 = a1 + 0x148;
  v6 = 0;
  v7 = 0;
  sub_1402E6080(a1 + 0x148, (__int64)v24);
  v8 = *(_QWORD *)v24[0];
  v9 = *(_QWORD *)(v24[0] + 8LL);
  if ( *(_QWORD *)v24[0] != v9 )
  {
    v10 = *(_QWORD *)v24[0];
    do
    {
      if ( *(_QWORD *)(a1 + 0x1A8) != *(_QWORD *)(a1 + 0x1B0) )
      {
        v6 = 1;
        v7 |= sub_1408521D0(a1, v10, a2);
      }
      v10 += 0xF8;
    }
    while ( v10 != v9 );
    v5 = a1 + 0x148;
    *(_DWORD *)(*a2 + 0x44) = dword_149C8E13C;
  }
  v11 = (*v25)-- == 1;
  if ( v11 )
    rw_lock_release_read_lock(v24[1]);
  if ( v7 )
    *(_WORD *)(a1 + 0x1DC) |= 0x80u;
  else
    *(_WORD *)(a1 + 0x1DC) &= ~0x80u;
  if ( !v6 )
  {
    if ( v8 == v9 )
      goto LABEL_31;
LABEL_32:
    v14 = 0;
    goto LABEL_33;
  }
  *(_WORD *)(a1 + 0x1DC) |= 4u;
  if ( BYTE1(qword_149C8E516) )
  {
    if ( !byte_149C8E514 )
      goto LABEL_22;
LABEL_31:
    v14 = 1;
    goto LABEL_33;
  }
  if ( !BYTE2(qword_149C8E516) )
    goto LABEL_31;
LABEL_22:
  sub_1402E6730(v5, (__int64)&v26);
  if ( *v26 != v26[1] )
    v26[1] = *v26;
  v11 = (*v28)-- == 1;
  if ( !v11 )
    goto LABEL_31;
  v12 = v27;
  v13 = *(_DWORD *)(v27 + 0x14);
  if ( v13 )
  {
    v14 = 1;
    *(_DWORD *)(v27 + 0x14) = v13 - 1;
  }
  else
  {
    *(_DWORD *)(v27 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v12, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      v14 = 1;
      *(_QWORD *)(v12 + 8) = &p_Src;
    }
    else
    {
      rw_lock_handle_write_release_contention(v12, n0x200000);
      v14 = 1;
    }
  }
LABEL_33:
  v21 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return v14;
}

// --- End Function: sub_140851510 (0x140851510) ---

// --- Function: sub_1408521D0 (0x1408521D0) ---
__int64 __fastcall sub_1408521D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm8
  __int128 v4; // xmm9
  __int128 v5; // xmm12
  __int128 v6; // xmm13
  __int64 v7; // r12
  __int64 v8; // r13
  int v10; // r8d
  float v11; // xmm2_4
  float v12; // xmm3_4
  bool v13; // zf
  unsigned int v14; // r15d
  __m128 v15; // xmm4
  __int64 v16; // rbx
  unsigned int v17; // r14d
  __m128 v18; // xmm9
  __m128 v20; // kr00_16
  int n0xFF; // eax
  __int64 v22; // rcx
  __int64 v23; // rdi
  unsigned int v24; // edi
  float v25; // xmm3_4
  float v26; // kr00_4
  _DWORD *v27; // r9
  float v29; // xmm13_4
  __int64 v32; // r15
  unsigned __int64 v33; // rdi
  char *Src_1; // r14
  char *Src_4; // rcx
  unsigned __int64 v36; // rdx
  char *Src_5; // rax
  __int128 v39; // kr00_16
  __int128 v44; // kr00_16
  __int128 v49; // kr00_16
  __int64 v57; // r8
  __int64 v58; // rcx
  unsigned int n0x10; // ebx
  int v60; // eax
  __int64 v61; // rdi
  __int64 v62; // r15
  __int64 v63; // r10
  int v64; // eax
  float v65; // r8d
  int v66; // eax
  float v67; // ecx
  float v68; // r8d
  float v69; // r9d
  int v70; // eax
  float v71; // r11d
  int v72; // eax
  float v73; // r8d
  float v74; // r11d
  float v75; // edx
  int v76; // eax
  __int64 v77; // rax
  __m128 v78; // xmm7
  float v79; // xmm9_4
  float v80; // xmm8_4
  __m128 v81; // kr00_16
  float v84; // xmm1_4
  float v85; // xmm14_4
  float v86; // xmm15_4
  float v87; // xmm11_4
  float v88; // xmm12_4
  float v89; // xmm4_4
  float v90; // xmm9_4
  float v91; // xmm6_4
  float v92; // xmm4_4
  float v93; // xmm8_4
  float v94; // xmm10_4
  float v95; // xmm12_4
  float v96; // xmm6_4
  float v97; // xmm0_4
  float v98; // xmm11_4
  float v99; // xmm9_4
  float v100; // xmm4_4
  float v101; // xmm6_4
  __m128 v102; // kr00_16
  float *v103; // rax
  unsigned int v104; // edx
  int v106; // edx
  unsigned int n0xFF_5; // r10d
  int v108; // r14d
  unsigned int n0x11; // r11d
  int n0xFF_2; // r8d
  __m128 v112; // xmm5
  float v113; // xmm5_4
  int n0xFF_7; // ecx
  __int128 v118; // kr00_16
  __int128 n0x3F800000_1; // xmm0
  int n0xFF_3; // edx
  __int128 n0x3F800000; // kr00_16
  float v127; // xmm1_4
  int n0xFF_4; // edi
  int n0xFF_6; // eax
  int v132; // r13d
  __int128 v136; // kr00_16
  __int128 n0x3F800000_2; // xmm0
  __int128 n0x3F800000_3; // kr00_16
  int n0xFF_9; // eax
  __int128 v148; // kr00_16
  __int128 n0x3F800000_5; // xmm0
  int n0xFF_8; // ecx
  __int128 n0x3F800000_4; // kr00_16
  float v157; // xmm1_4
  int v158; // r10d
  int n0xFF_12; // edi
  int v160; // eax
  int v163; // ecx
  int n0xFF_10; // r13d
  int n0xFF_11; // r12d
  int v168; // r9d
  int n0xFF_13; // r14d
  bool v170; // cl
  bool v171; // al
  char n0xFF_14; // r8
  int v173; // edx
  __int64 v174; // rcx
  __int64 v175; // rcx
  int v176; // r8d
  int v177; // edx
  int v178; // eax
  int n0x11_1; // eax
  int n0x11_2; // eax
  char v181; // al
  char v182; // r15
  __int64 v183; // rcx
  __int64 v184; // rbx
  unsigned __int64 v185; // r14
  __int64 v186; // rdx
  __int64 v187; // r13
  char *Src_3; // r8
  int v189; // eax
  __int64 v190; // rcx
  _OWORD *v191; // rcx
  __int64 v192; // rax
  int v193; // r9d
  __int128 v194; // xmm0
  __int64 v195; // rcx
  __int64 v196; // r15
  _OWORD *v197; // r12
  unsigned __int64 v198; // r15
  _BYTE *v199; // rdi
  _BYTE *v200; // rdx
  _OWORD *v201; // rax
  __int64 v202; // rcx
  _OWORD *v203; // rdi
  unsigned __int8 v204; // bl
  float v206; // [rsp+3Ch] [rbp-CCh]
  int v207; // [rsp+3Ch] [rbp-CCh]
  float v208; // [rsp+40h] [rbp-C8h]
  int v209; // [rsp+40h] [rbp-C8h]
  int v210; // [rsp+44h] [rbp-C4h]
  int v211; // [rsp+48h] [rbp-C0h]
  int v212; // [rsp+4Ch] [rbp-BCh]
  void *Src; // [rsp+50h] [rbp-B8h] BYREF
  char *Src_2; // [rsp+58h] [rbp-B0h]
  char *Src_6; // [rsp+60h] [rbp-A8h]
  unsigned int v216; // [rsp+68h] [rbp-A0h]
  float v217; // [rsp+6Ch] [rbp-9Ch]
  float v218; // [rsp+70h] [rbp-98h]
  float v219; // [rsp+74h] [rbp-94h]
  unsigned int v220; // [rsp+78h] [rbp-90h]
  int v221; // [rsp+7Ch] [rbp-8Ch]
  float v222; // [rsp+80h] [rbp-88h]
  int v223; // [rsp+84h] [rbp-84h]
  unsigned int n0xFF_1; // [rsp+88h] [rbp-80h]
  float v225; // [rsp+8Ch] [rbp-7Ch]
  float v226; // [rsp+90h] [rbp-78h]
  int v227; // [rsp+94h] [rbp-74h]
  int n0x11_3; // [rsp+98h] [rbp-70h]
  __int64 v229; // [rsp+A0h] [rbp-68h] BYREF
  float v230; // [rsp+A8h] [rbp-60h]
  int v231; // [rsp+B0h] [rbp-58h]
  __int128 v232; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v233; // [rsp+C8h] [rbp-40h]
  __int64 v234; // [rsp+D0h] [rbp-38h]
  __int128 v235; // [rsp+D8h] [rbp-30h] BYREF
  __int64 v236; // [rsp+E8h] [rbp-20h]
  __int64 v237; // [rsp+F0h] [rbp-18h]
  __int64 v238; // [rsp+F8h] [rbp-10h]
  __int64 v239; // [rsp+100h] [rbp-8h]
  __int128 v240; // [rsp+108h] [rbp+0h]
  float v241[4]; // [rsp+118h] [rbp+10h] BYREF
  __int128 v242; // [rsp+128h] [rbp+20h]
  __int128 v243; // [rsp+138h] [rbp+30h]
  int n0x900; // [rsp+148h] [rbp+40h] BYREF
  __int64 v245; // [rsp+14Ch] [rbp+44h]
  int v246; // [rsp+154h] [rbp+4Ch]
  unsigned __int64 v247; // [rsp+158h] [rbp+50h]
  unsigned __int64 v248; // [rsp+160h] [rbp+58h]
  __int64 v249; // [rsp+168h] [rbp+60h]
  __int64 v250; // [rsp+170h] [rbp+68h]
  __m128 v251; // [rsp+198h] [rbp+90h]
  float v252; // [rsp+1A8h] [rbp+A0h] BYREF
  __int128 v253; // [rsp+1D8h] [rbp+D0h]
  __int128 v254; // [rsp+1E8h] [rbp+E0h]
  __int128 v255; // [rsp+218h] [rbp+110h]
  __int128 v256; // [rsp+228h] [rbp+120h]
  char v257; // [rsp+2A8h] [rbp+1A0h]
  __int64 v259; // [rsp+2B0h] [rbp+1A8h]
  unsigned int v261; // [rsp+2C0h] [rbp+1B8h]

  v256 = v3;
  v255 = v4;
  v7 = a3;
  v254 = v5;
  v8 = a2;
  v253 = v6;
  n0x900 = 0x900;
  v245 = 0;
  v246 = 0;
  v248 = 0;
  v249 = 0;
  v250 = 0;
  v247 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFF8,
    "CDamageMap::MT_DamageMapImpactRendering",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x9C3);
  v11 = *(float *)v8;
  v12 = *(float *)(v8 + 0x20);
  v13 = *(_BYTE *)(a1 + 0xC0) == 0;
  v14 = 0;
  v15 = *(__m128 *)(v8 + 0xB8);
  v16 = *(_QWORD *)(v8 + 0xE0);
  v17 = 0;
  v18 = *(__m128 *)(v8 + 0x68);
  _XMM8 = *(__m128 *)(v8 + 0x88);
  v229 = *(_QWORD *)(v8 + 0x30);
  v240 = *(_OWORD *)(v8 + 0x58);
  v243 = *(_OWORD *)(v8 + 0x78);
  v242 = *(_OWORD *)(v8 + 0xC8);
  v223 = *(_DWORD *)(v8 + 0xD8);
  v20 = (__m128)*(unsigned int *)(v8 + 0x10);
  v20.m128_f32[0] = *(float *)(v8 + 0x10) * *(float *)(v8 + 0x10);
  HIWORD(n0x900) = word_149D7FFF8;
  v230 = *(float *)(v8 + 0x38);
  n0xFF = 0;
  if ( v13 )
    n0xFF = 0xFF;
  v257 = 0;
  v22 = *(_QWORD *)(v8 + 0x50);
  n0xFF_1 = n0xFF;
  v239 = v16;
  v216 = 0;
  v261 = 0;
  v20.m128_f32[0] = (float)(v20.m128_f32[0] + (float)(v11 * v11)) + (float)(v12 * v12);
  v251 = _mm_sqrt_ps(_mm_shuffle_ps(v20, v20, 0));
  v227 = (int)(float)(v15.m128_f32[0] * 255.0);
  n0x11_3 = (int)(float)(_mm_shuffle_ps(v15, v15, 0xAA).m128_f32[0] * 255.0);
  if ( v22 )
  {
    v23 = *(_QWORD *)(a1 + 0x120);
    v24 = v23 ? *(_DWORD *)(v23 + 0x50) : 0;
    v261 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0xC8LL))(v22);
    v17 = v261;
    if ( v261 > v24 )
    {
      do
      {
        ++v14;
        v17 >>= 1;
      }
      while ( v17 > v24 );
      v216 = v14;
      v261 = v17;
    }
  }
  v25 = (float)v17;
  v26 = *(float *)(v8 + 0xD4) + *(float *)(v8 + 0xD0);
  v231 = (int)(float)((float)(*(float *)(v8 + 0xCC) + *(float *)(v8 + 0xC8)) * v25);
  v27 = *(_DWORD **)(a1 + 0xC8);
  _XMM12 = _mm_shuffle_ps(v18, v18, 0xAA);
  LODWORD(v29) = _mm_shuffle_ps(v18, v18, 0x55).m128_u32[0];
  __asm
  {
    vmaxss  xmm0, xmm12, xmm13
    vmaxss  xmm1, xmm0, xmm9
  }
  v221 = (int)(float)(v26 * v25);
  v232 = 0;
  v233 = 0;
  if ( v27 != *(_DWORD **)(a1 + 0xD0) )
    sub_14084E170((_QWORD *)(a1 + 0xC8), (float *)&v229, v10, v27, (unsigned __int64 *)&v232);
  Src = 0;
  Src_2 = 0;
  Src_6 = 0;
  v32 = (__int64)(*((_QWORD *)&v232 + 1) - v232) >> 2;
  v33 = (__int64)(*(_QWORD *)(a1 + 0x48) - *(_QWORD *)(a1 + 0x40)) >> 4;
  v234 = v32;
  if ( v33 )
  {
    if ( v33 > 0x1555555555555555LL )
      unknown_libname_38();
    Src_1 = (char *)sub_140394E70((__int64)&Src, 0xC * v33);
    Src_4 = Src_1;
    v36 = v33;
    do
    {
      *(_QWORD *)Src_4 = 0;
      *((_DWORD *)Src_4 + 2) = 0;
      Src_4 += 0xC;
      --v36;
    }
    while ( v36 );
    memmove(Src_1, Src, Src_2 - (_BYTE *)Src);
    if ( Src )
      sub_1403A6820((__int64)&Src, (unsigned __int64)Src, 0xC * ((Src_6 - (_BYTE *)Src) / 0xC));
    Src = Src_1;
    Src_5 = &Src_1[0xC * v33];
    Src_2 = Src_5;
    v17 = v261;
    LODWORD(v32) = v234;
    Src_6 = Src_5;
  }
  v39 = *(_OWORD *)&_XMM8 & xmmword_1482B5EE0;
  *(float *)&v39 = COERCE_FLOAT(_XMM8.m128_i32[0] & 0x7FFFFFFF) * 0.80000001;
  _XMM0 = v39;
  __asm { vmaxss  xmm0, xmm0, xmm6; X }
  *(float *)&_XMM0 = logf(*(float *)&_XMM0);
  _XMM15 = _XMM0;
  _XMM11 = _mm_shuffle_ps(_XMM8, _XMM8, 0x55);
  v44 = *(_OWORD *)&_XMM11 & xmmword_1482B5EE0;
  *(float *)&v44 = COERCE_FLOAT(_XMM11.m128_i32[0] & 0x7FFFFFFF) * 0.80000001;
  _XMM0 = v44;
  __asm { vmaxss  xmm0, xmm0, xmm6; X }
  *(float *)&_XMM0 = logf(*(float *)&_XMM0);
  _XMM14 = _XMM0;
  _XMM10 = _mm_shuffle_ps(_XMM8, _XMM8, 0xAA);
  v49 = *(_OWORD *)&_XMM10 & xmmword_1482B5EE0;
  *(float *)&v49 = COERCE_FLOAT(_XMM10.m128_i32[0] & 0x7FFFFFFF) * 0.80000001;
  _XMM0 = v49;
  __asm { vmaxss  xmm0, xmm0, xmm6; X }
  *(float *)&_XMM0 = logf(*(float *)&_XMM0);
  LODWORD(_XMM6) = 0;
  if ( *(float *)&_XMM0 >= 0.0 )
    __asm { vminss  xmm4, xmm0, xmm1 }
  else
    LODWORD(_XMM4) = 0;
  if ( *(float *)&_XMM14 >= 0.0 )
    __asm { vminss  xmm3, xmm14, xmm1 }
  else
    LODWORD(_XMM3) = 0;
  if ( *(float *)&_XMM15 >= 0.0 )
    __asm { vminss  xmm6, xmm15, xmm1 }
  v222 = (float)(*(float *)&_XMM6 + 1.0) * v18.m128_f32[0];
  v225 = (float)(*(float *)&_XMM3 + 1.0) * v29;
  v226 = (float)(*(float *)&_XMM4 + 1.0) * _XMM12.m128_f32[0];
  v217 = -1.25;
  if ( _XMM10.m128_f32[0] >= -1.25 )
  {
    __asm { vminss  xmm0, xmm10, xmm1 }
    v219 = *(float *)&_XMM0;
  }
  else
  {
    v219 = -1.25;
  }
  if ( _XMM11.m128_f32[0] >= -1.25 )
  {
    __asm { vminss  xmm0, xmm11, xmm1 }
    v218 = *(float *)&_XMM0;
  }
  else
  {
    v218 = -1.25;
  }
  if ( _XMM8.m128_f32[0] >= -1.25 )
  {
    __asm { vminss  xmm0, xmm8, xmm1 }
    v217 = *(float *)&_XMM0;
  }
  v220 = 0;
  if ( !(_DWORD)v32 )
    goto LABEL_187;
  v57 = 0;
  v237 = 0;
  v58 = a1 + 0xF0;
  do
  {
    n0x10 = 0;
    v60 = *(_DWORD *)(v232 + 4 * v57);
    v210 = v60;
    do
    {
      v61 = n0x10 + v60;
      v62 = (unsigned int)v61;
      if ( !sub_140844100(v61, (_QWORD *)(*(_QWORD *)(a1 + 0x120) + 0x18LL), v58) )
        goto LABEL_159;
      v63 = *(_QWORD *)(*(_QWORD *)(a1 + 0x120) + 0x18LL);
      v64 = (*(_WORD *)(v63 + 8 * v61 + 6) & 0x7FFF) << 0xD;
      LODWORD(v65) = v64 + 0x38000000;
      if ( (v64 & 0xF800000) == 0xF800000 )
      {
        LODWORD(v65) = v64 + 0x70000000;
      }
      else if ( (v64 & 0xF800000) == 0 )
      {
        v65 = COERCE_FLOAT(v64 + 0x38800000) + -0.000061035156;
      }
      v66 = (*(_WORD *)(v63 + 8 * v61 + 4) & 0x7FFF) << 0xD;
      LODWORD(v67) = LODWORD(v65) | (*(unsigned __int16 *)(v63 + 8 * v61 + 6) << 0x10) & 0x80000000;
      LODWORD(v68) = v66 + 0x38000000;
      if ( (v66 & 0xF800000) == 0xF800000 )
      {
        LODWORD(v68) = v66 + 0x70000000;
      }
      else if ( (v66 & 0xF800000) == 0 )
      {
        v68 = COERCE_FLOAT(v66 + 0x38800000) + -0.000061035156;
      }
      LODWORD(v69) = LODWORD(v68) | (*(unsigned __int16 *)(v63 + 8 * v61 + 4) << 0x10) & 0x80000000;
      v70 = (*(_WORD *)(v63 + 8 * v61 + 2) & 0x7FFF) << 0xD;
      LODWORD(v71) = v70 + 0x38000000;
      if ( (v70 & 0xF800000) == 0xF800000 )
      {
        LODWORD(v71) = v70 + 0x70000000;
      }
      else if ( (v70 & 0xF800000) == 0 )
      {
        v71 = COERCE_FLOAT(v70 + 0x38800000) + -0.000061035156;
      }
      v72 = (*(_WORD *)(v63 + 8 * v61) & 0x7FFF) << 0xD;
      LODWORD(v73) = LODWORD(v71) | (*(unsigned __int16 *)(v63 + 8 * v61 + 2) << 0x10) & 0x80000000;
      LODWORD(v74) = v72 + 0x38000000;
      if ( (v72 & 0xF800000) == 0xF800000 )
      {
        LODWORD(v74) = v72 + 0x70000000;
      }
      else if ( (v72 & 0xF800000) == 0 )
      {
        v74 = COERCE_FLOAT(v72 + 0x38800000) + -0.000061035156;
      }
      LODWORD(v75) = LODWORD(v74) | (*(unsigned __int16 *)(v63 + 8 * v61) << 0x10) & 0x80000000;
      v76 = (int)v67;
      if ( (int)v67 >= *(_DWORD *)(a1 + 0x1C0) )
      {
        sub_1403A6950(&v252, v61);
LABEL_159:
        v182 = v257;
        goto LABEL_160;
      }
      v238 = v76;
      v77 = *(_QWORD *)(a1 + 0x1A8) + 0x20LL * v76;
      v78 = (__m128)*(unsigned int *)(v77 + 4);
      v79 = *(float *)(v77 + 0xC);
      v80 = *(float *)(v77 + 8);
      v81 = v78;
      v81.m128_f32[0] = (float)((float)(v78.m128_f32[0] * v78.m128_f32[0]) + (float)(*(float *)v77 * *(float *)v77))
                      + (float)((float)(v80 * v80) + (float)(v79 * v79));
      _XMM3 = _mm_shuffle_ps(v81, v81, 0);
      __asm { vrsqrtps xmm5, xmm3 }
      _XMM5.m128_f32[0] = _mm_shuffle_ps(_XMM5, _XMM5, 0xFF).m128_f32[0];
      v84 = (float)(1.5 - (float)((float)((float)(_XMM5.m128_f32[0] * v81.m128_f32[0]) * _XMM5.m128_f32[0]) * 0.5))
          * _XMM5.m128_f32[0];
      v85 = v84 * *(float *)(v77 + 0x14);
      v86 = v84 * *(float *)(v77 + 0x1C);
      v87 = *(float *)v77 * v84;
      v88 = v78.m128_f32[0] * v84;
      v78.m128_f32[0] = v84 * *(float *)(v77 + 0x10);
      v89 = v79 * v84;
      v90 = v84 * *(float *)(v77 + 0x18);
      v206 = v89;
      v91 = (float)((float)(v88 * v69) - (float)((float)(v80 * v84) * v73)) + (float)(v89 * v75);
      v81.m128_f32[0] = (float)((float)((float)(v80 * v84) * v75) - (float)(v87 * v69)) + (float)(v89 * v73);
      v208 = v80 * v84;
      v92 = (float)((float)(v87 * v73) - (float)(v88 * v75)) + (float)(v89 * v69);
      v93 = (float)(v92 * v88) - (float)(v81.m128_f32[0] * (float)(v80 * v84));
      _XMM5.m128_f32[0] = v88;
      v94 = (float)(v91 * v208) - (float)(v92 * v87);
      v95 = (float)(v81.m128_f32[0] * v87) - (float)(v91 * v88);
      v96 = (float)(v90 * _XMM5.m128_f32[0]) - (float)(v85 * v208);
      v97 = v90 * v87;
      v98 = (float)(v85 * v87) - (float)(v78.m128_f32[0] * _XMM5.m128_f32[0]);
      v99 = (float)(v78.m128_f32[0] * v208) - v97;
      v100 = (float)(v78.m128_f32[0] * v206) - (float)(v86 * (float)(*(float *)v77 * v84));
      v78.m128_f32[0] = (float)((float)(v84 * *(float *)(v77 + 0x18)) * v206) - (float)(v86 * v208);
      v101 = (float)(*(float *)&v229
                   - (float)((float)((float)((float)(v93 + v93) + v75) + v100) + (float)((float)(v96 + v100) + v96)))
           * v251.m128_f32[3];
      v102 = (__m128)HIDWORD(v229);
      v102.m128_f32[0] = (float)(*((float *)&v229 + 1)
                               - (float)((float)((float)((float)(v94 + v94) + v73)
                                               + (float)((float)(v85 * v206) - (float)(v86 * _XMM5.m128_f32[0])))
                                       + (float)((float)(v99
                                                       + (float)((float)(v85 * v206) - (float)(v86 * _XMM5.m128_f32[0])))
                                               + v99)))
                       * v251.m128_f32[3];
      _XMM5.m128_f32[0] = (float)(v230
                                - (float)((float)((float)((float)(v95 + v95) + v69) + v78.m128_f32[0])
                                        + (float)((float)(v98 + v78.m128_f32[0]) + v98)))
                        * v251.m128_f32[3];
      v102.m128_f32[0] = (float)((float)(v102.m128_f32[0] * v102.m128_f32[0]) + (float)(v101 * v101))
                       + (float)(_XMM5.m128_f32[0] * _XMM5.m128_f32[0]);
      if ( v102.m128_f32[0] > 1.0 )
        goto LABEL_159;
      v103 = sub_1403A6950((float *)&v235, v61);
      v104 = (v231 + (int)*v103) % v17;
      LODWORD(v103) = v221 + (int)v103[1];
      LODWORD(v236) = v104;
      HIDWORD(v236) = (unsigned int)v103 % v17;
      sub_14085ADE0(v241, *(_QWORD *)(v8 + 0x50), v236, v216);
      _XMM2 = 0;
      v106 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v7 + 8LL) + 4 * v61);
      n0xFF_5 = BYTE1(v106);
      v108 = (unsigned __int8)v106;
      v212 = BYTE1(v106);
      v211 = BYTE2(v106);
      __asm { vroundss xmm2, xmm2, xmm1, 3 }
      v207 = (unsigned __int8)v106;
      n0x11 = BYTE2(v106);
      if ( (int)*(float *)&_XMM2 >= 0 )
      {
        n0xFF_2 = 0xFF;
        if ( (int)*(float *)&_XMM2 < 0xFF )
          n0xFF_2 = (int)*(float *)&_XMM2;
      }
      else
      {
        n0xFF_2 = 0;
      }
      v112 = _mm_sqrt_ps(_mm_shuffle_ps(v102, v102, 0));
      LODWORD(v113) = _mm_shuffle_ps(v112, v112, 0xFF).m128_u32[0];
      if ( COERCE_FLOAT(LODWORD(v217) & 0x7FFFFFFF) < 0.00000011920929 )
      {
        n0xFF_7 = 0;
        goto LABEL_78;
      }
      _XMM0 = (unsigned int)v240;
      __asm
      {
        vminss  xmm8, xmm0, [rsp+290h+var_218]
        vmaxss  xmm1, xmm0, [rsp+290h+var_218]
      }
      if ( (float)(*(float *)&_XMM1 - *(float *)&_XMM8) == 0.0 )
      {
        n0xFF_7 = 0;
        goto LABEL_78;
      }
      v118 = (unsigned int)v242;
      *(float *)&v118 = (float)((float)((float)((float)((float)(*(float *)&v242 + v241[0]) * 0.5) * *(float *)&v243)
                                      + v113)
                              - *(float *)&_XMM8)
                      / (float)(*(float *)&_XMM1 - *(float *)&_XMM8);
      _XMM2 = v118;
      if ( *(float *)&v118 >= 0.0 )
      {
        __asm { vminss  xmm0, xmm2, xmm7 }
        n0x3F800000 = 0x3F800000u;
        *(float *)&n0x3F800000 = (float)((float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573))
                                       * (float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573)))
                               * (float)((float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573))
                                       * (float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573)));
        n0x3F800000_1 = n0x3F800000;
        if ( *(float *)&n0x3F800000 < 0.0 )
        {
          LODWORD(_XMM1) = 0;
          goto LABEL_69;
        }
      }
      else
      {
        n0x3F800000_1 = 0x3F800000u;
      }
      __asm { vminss  xmm1, xmm0, xmm7 }
LABEL_69:
      _XMM2 = 0;
      __asm { vroundss xmm2, xmm2, xmm3, 3 }
      if ( (int)*(float *)&_XMM2 >= 0 )
      {
        n0xFF_3 = 0xFF;
        if ( (int)*(float *)&_XMM2 < 0xFF )
          n0xFF_3 = (int)*(float *)&_XMM2;
      }
      else
      {
        n0xFF_3 = 0;
      }
      v127 = (float)((float)(*(float *)&_XMM1 * COERCE_FLOAT(LODWORD(v217) & 0x7FFFFFFF)) * 255.0)
           - (float)(int)(float)((float)(*(float *)&_XMM1 * COERCE_FLOAT(LODWORD(v217) & 0x7FFFFFFF)) * 255.0);
      if ( v127 < 0.0 )
        v127 = 1.0 - COERCE_FLOAT(LODWORD(v127) & 0x7FFFFFFF);
      n0xFF_7 = (int)(float)((SLODWORD(v217) >> 0x1F) + 1 + ((LODWORD(v217) - 1) >> 0x1F))
              * (n0xFF_3 + (v127 >= *(float *)&v242));
LABEL_78:
      n0xFF_4 = n0xFF_5;
      _XMM2 = 0;
      __asm { vroundss xmm2, xmm2, xmm1, 3 }
      if ( n0xFF_2 >= (int)*(float *)&_XMM2 )
        n0xFF_2 = (int)*(float *)&_XMM2;
      if ( n0xFF_5 < n0xFF_1 )
        n0xFF_4 = n0xFF_1;
      n0xFF_6 = n0xFF_4;
      if ( n0xFF_4 >= n0xFF_7 )
        n0xFF_6 = n0xFF_7;
      v132 = n0xFF_6 + v108;
      if ( COERCE_FLOAT(LODWORD(v218) & 0x7FFFFFFF) >= 0.00000011920929 )
      {
        _XMM0 = LODWORD(v225);
        __asm
        {
          vminss  xmm8, xmm0, dword ptr [rbp+190h+var_190+4]
          vmaxss  xmm1, xmm0, dword ptr [rbp+190h+var_190+4]
        }
        if ( (float)(*(float *)&_XMM1 - *(float *)&_XMM8) != 0.0 )
        {
          v136 = DWORD1(v242);
          *(float *)&v136 = (float)((float)((float)((float)((float)(*((float *)&v242 + 1) + v241[1]) * 0.5)
                                                  * *((float *)&v243 + 1))
                                          + v113)
                                  - *(float *)&_XMM8)
                          / (float)(*(float *)&_XMM1 - *(float *)&_XMM8);
          _XMM2 = v136;
          if ( *(float *)&v136 < 0.0 )
          {
            n0x3F800000_2 = 0x3F800000u;
            goto LABEL_88;
          }
          __asm { vminss  xmm0, xmm2, xmm7 }
          n0x3F800000_3 = 0x3F800000u;
          *(float *)&n0x3F800000_3 = (float)((float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573))
                                           * (float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573)))
                                   * (float)((float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573))
                                           * (float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573)));
          n0x3F800000_2 = n0x3F800000_3;
          if ( *(float *)&n0x3F800000_3 >= 0.0 )
LABEL_88:
            __asm { vminss  xmm1, xmm0, xmm7 }
          _XMM2 = 0;
          __asm { vroundss xmm2, xmm2, xmm3, 3 }
        }
      }
      if ( COERCE_FLOAT(LODWORD(v219) & 0x7FFFFFFF) < 0.00000011920929 )
      {
        n0xFF_9 = 0;
        goto LABEL_108;
      }
      _XMM0 = DWORD2(v240);
      __asm
      {
        vminss  xmm8, xmm0, [rbp+190h+var_208]
        vmaxss  xmm1, xmm0, [rbp+190h+var_208]
      }
      if ( (float)(*(float *)&_XMM1 - *(float *)&_XMM8) == 0.0 )
      {
        n0xFF_9 = 0;
        goto LABEL_108;
      }
      v148 = DWORD2(v242);
      *(float *)&v148 = (float)((float)((float)((float)((float)(*((float *)&v242 + 2) + v241[2]) * 0.5)
                                              * *((float *)&v243 + 2))
                                      + v113)
                              - *(float *)&_XMM8)
                      / (float)(*(float *)&_XMM1 - *(float *)&_XMM8);
      _XMM2 = v148;
      if ( *(float *)&v148 >= 0.0 )
      {
        __asm { vminss  xmm0, xmm2, xmm7 }
        n0x3F800000_4 = 0x3F800000u;
        *(float *)&n0x3F800000_4 = (float)((float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573))
                                         * (float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573)))
                                 * (float)((float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573))
                                         * (float)(1.0 - (float)(*(float *)&_XMM0 * 0.71428573)));
        n0x3F800000_5 = n0x3F800000_4;
        if ( *(float *)&n0x3F800000_4 < 0.0 )
        {
          LODWORD(_XMM1) = 0;
          goto LABEL_99;
        }
      }
      else
      {
        n0x3F800000_5 = 0x3F800000u;
      }
      __asm { vminss  xmm1, xmm0, xmm7 }
LABEL_99:
      _XMM2 = 0;
      __asm { vroundss xmm2, xmm2, xmm3, 3 }
      if ( (int)*(float *)&_XMM2 >= 0 )
      {
        n0xFF_8 = 0xFF;
        if ( (int)*(float *)&_XMM2 < 0xFF )
          n0xFF_8 = (int)*(float *)&_XMM2;
      }
      else
      {
        n0xFF_8 = 0;
      }
      v157 = (float)((float)(*(float *)&_XMM1 * COERCE_FLOAT(LODWORD(v219) & 0x7FFFFFFF)) * 255.0)
           - (float)(int)(float)((float)(*(float *)&_XMM1 * COERCE_FLOAT(LODWORD(v219) & 0x7FFFFFFF)) * 255.0);
      if ( v157 < 0.0 )
        v157 = 1.0 - COERCE_FLOAT(LODWORD(v157) & 0x7FFFFFFF);
      n0xFF_9 = (int)(float)((SLODWORD(v219) >> 0x1F) + 1 + ((LODWORD(v219) - 1) >> 0x1F))
              * (n0xFF_8 + (v157 >= *((float *)&v242 + 2)));
LABEL_108:
      if ( n0xFF_4 >= n0xFF_9 )
        n0xFF_4 = n0xFF_9;
      v158 = n0xFF_2 + n0xFF_5;
      n0xFF_12 = n0x11 + n0xFF_4;
      v209 = v158;
      v160 = 0x19 - v132;
      _XMM2 = 0;
      if ( 0x19 - v132 <= 0 )
        v160 = 0;
      __asm { vroundss xmm2, xmm2, xmm1, 3 }
      v163 = -v160;
      if ( (int)*(float *)&_XMM2 >= -v160 )
      {
        v163 = v160;
        if ( (int)*(float *)&_XMM2 < v160 )
          v163 = (int)*(float *)&_XMM2;
      }
      n0xFF_10 = v163 + v132;
      _XMM0 = 0;
      if ( v108 >= v227 )
        __asm { vcvtsi2sd xmm0, xmm0, eax }
      __asm { vcvttsd2si r12d, xmm0 }
      _XMM0 = 0;
      if ( (int)n0x11 >= n0x11_3 )
        __asm { vcvtsi2sd xmm0, xmm0, eax }
      v168 = v108;
      __asm { vcvttsd2si r14d, xmm0 }
      v170 = v207 || n0x11 >= 0x11;
      v171 = n0xFF_10 < (int)0xFFFFFFFF && n0xFF_12 < (int)0xFFFFFFEF;
      if ( v170 )
      {
        if ( !v171 || *(_QWORD *)(a1 + 0x20) == *(_QWORD *)(a1 + 0x28) )
          goto LABEL_134;
        sub_14085F360(a1 + 8, n0x10 + v210, (unsigned int)*(unsigned __int8 *)(a1 + 0x10) - 2, 0);
        goto LABEL_133;
      }
      if ( !v171 )
      {
        sub_140860A50(a1 + 8, n0x10 + v210);
LABEL_133:
        v168 = v207;
        v158 = v209;
      }
LABEL_134:
      if ( n0xFF_10 >= n0xFF_11 )
      {
        n0xFF_14 = 0xFF;
        if ( n0xFF_10 < 0xFF )
          n0xFF_14 = n0xFF_10;
      }
      else
      {
        n0xFF_14 = n0xFF_11;
      }
      v173 = 0xFF - n0xFF_11;
      if ( v158 >= 0 )
      {
        if ( v158 < v173 )
          LOBYTE(v173) = v158;
      }
      else
      {
        LOBYTE(v173) = 0;
      }
      if ( n0xFF_12 >= n0xFF_13 )
      {
        LOBYTE(n0xFF_13) = 0xFF;
        if ( n0xFF_12 < 0xFF )
          LOBYTE(n0xFF_13) = n0xFF_12;
      }
      v7 = a3;
      v174 = *(_QWORD *)(*(_QWORD *)a3 + 8LL);
      *(_BYTE *)(v174 + 4 * v62) = n0xFF_14;
      *(_BYTE *)(v174 + 4 * v62 + 1) = v173;
      *(_BYTE *)(v174 + 4 * v62 + 2) = n0xFF_13;
      v175 = *(_QWORD *)(*(_QWORD *)a3 + 8LL);
      v176 = *(unsigned __int8 *)(v175 + 4 * v62) - v168;
      v177 = *(unsigned __int8 *)(v175 + 4 * v62 + 1) - v212;
      v178 = v168 - *(unsigned __int8 *)(v175 + 4 * v62);
      if ( v178 < 0 )
        v178 = *(unsigned __int8 *)(v175 + 4 * v62) - v168;
      if ( v178 >= 1 )
        goto LABEL_155;
      n0x11_1 = v212 - *(unsigned __int8 *)(v175 + 4 * v62 + 1);
      if ( v177 > 0 )
        n0x11_1 = *(unsigned __int8 *)(v175 + 4 * v62 + 1) - v212;
      if ( n0x11_1 >= 0x11 )
        goto LABEL_155;
      n0x11_2 = v211 - *(unsigned __int8 *)(v175 + 4 * v62 + 2);
      if ( *(unsigned __int8 *)(v175 + 4 * v62 + 2) - v211 > 0 )
        n0x11_2 = *(unsigned __int8 *)(v175 + 4 * v62 + 2) - v211;
      if ( n0x11_2 >= 0x11 )
LABEL_155:
        v181 = 1;
      else
        v181 = 0;
      v182 = v181 | v257;
      v257 |= v181;
      if ( Src != Src_2 )
      {
        v183 = 3 * v238;
        *((_BYTE *)Src + 4 * v183 + 8) = 1;
        *((_DWORD *)Src + v183) += v176;
        *((_DWORD *)Src + v183 + 1) += v177;
      }
      *(_DWORD *)(a1 + 0x74) += v176;
      *(_DWORD *)(a1 + 0x7C) += v177;
      v8 = a2;
LABEL_160:
      v17 = v261;
      v58 = a1 + 0xF0;
      v60 = v210;
      ++n0x10;
    }
    while ( n0x10 < 0x10 );
    v58 = a1 + 0xF0;
    v57 = v237 + 1;
    ++v220;
    ++v237;
  }
  while ( v220 < (unsigned int)v234 );
  v184 = v239;
  if ( !v182 )
  {
LABEL_187:
    v204 = 0;
    goto LABEL_188;
  }
  v185 = 0;
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 0x120) + 0x4CLL) )
  {
    v186 = 0;
    v187 = 0;
    v259 = 0;
    do
    {
      Src_3 = (char *)Src;
      if ( *((_BYTE *)Src + v187 + 8) )
      {
        v189 = *(_DWORD *)((char *)Src + v187);
        v190 = *(_QWORD *)(a1 + 0x40);
        *(_QWORD *)&v235 = v184;
        DWORD2(v235) = v185;
        *(_DWORD *)(v186 + v190 + 4) += v189;
        *(_DWORD *)(v186 + v190 + 0xC) += *(_DWORD *)&Src_3[v187 + 4];
        v191 = *(_OWORD **)(a1 + 0x60);
        v192 = *(_QWORD *)(a1 + 0x58);
        v193 = *(_DWORD *)&Src_3[v187];
        HIDWORD(v235) = v193;
        if ( (_OWORD *)v192 == v191 )
          goto LABEL_172;
        do
        {
          if ( *(_QWORD *)v192 == v184 && *(_DWORD *)(v192 + 8) == (_DWORD)v185 )
            break;
          v192 += 0x10;
        }
        while ( (_OWORD *)v192 != v191 );
        if ( (_OWORD *)v192 == v191 )
        {
LABEL_172:
          if ( (unsigned __int64)v191 >= *(_QWORD *)(a1 + 0x68) )
          {
            v195 = ((__int64)v191 - *(_QWORD *)(a1 + 0x58)) >> 4;
            if ( v195 )
            {
              v196 = 2 * v195;
              if ( !(2 * v195) )
              {
                v197 = 0;
                v198 = 0;
LABEL_179:
                v199 = *(_BYTE **)(a1 + 0x60);
                v200 = *(_BYTE **)(a1 + 0x58);
                if ( v200 == v199 )
                  v201 = v197;
                else
                  v201 = (char *)memmove(v197, v200, v199 - v200) + ((v199 - v200) & 0xFFFFFFFFFFFFFFF0uLL);
                *v201 = v235;
                v202 = *(_QWORD *)(a1 + 0x58);
                v203 = v201 + 1;
                if ( v202 )
                  sub_1402A6590(v202);
                v186 = v259;
                *(_QWORD *)(a1 + 0x68) = &v197[v198];
                *(_QWORD *)(a1 + 0x58) = v197;
                *(_QWORD *)(a1 + 0x60) = v203;
                goto LABEL_185;
              }
            }
            else
            {
              v196 = 1;
            }
            v198 = v196;
            v197 = (_OWORD *)sub_1402A65A0(v198 * 0x10);
            goto LABEL_179;
          }
          v194 = v235;
          *(_QWORD *)(a1 + 0x60) = v191 + 1;
          *v191 = v194;
        }
        else
        {
          *(_DWORD *)(v192 + 0xC) += v193;
        }
      }
LABEL_185:
      v186 += 0x10;
      ++v185;
      v259 = v186;
      v187 += 0xC;
    }
    while ( v185 < *(unsigned int *)(*(_QWORD *)(a1 + 0x120) + 0x4CLL) );
  }
  v204 = 1;
LABEL_188:
  if ( Src )
  {
    sub_1403A6820((__int64)&Src, (unsigned __int64)Src, 0xC * ((Src_6 - (_BYTE *)Src) / 0xC));
    Src = 0;
    Src_2 = 0;
    Src_6 = 0;
  }
  if ( (_QWORD)v232 )
  {
    sub_1403A6820((__int64)&v232, v232, (v233 - v232) & 0xFFFFFFFFFFFFFFFCuLL);
    v232 = 0;
    v233 = 0;
  }
  v248 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return v204;
}

// --- End Function: sub_1408521D0 (0x1408521D0) ---

// --- Function: sub_140853590 (0x140853590) ---
__int64 __fastcall sub_140853590(__int64 a1)
{
  __int64 v1; // rbx
  int v3; // edi
  __int64 v4; // r8
  unsigned __int64 v5; // rax
  int v6; // eax
  unsigned __int64 n0x200000; // rax
  int v8; // edi
  __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rbx
  __int16 n0xFFF; // r11
  unsigned __int64 v15; // r9
  unsigned __int64 v16; // r9
  __int64 v17; // rax
  __int64 v18; // r10
  __int64 v19; // rsi
  bool v20; // al
  __int64 v21; // rsi
  int event_key_from_source_location; // eax
  __int64 v23; // r9
  __int64 v24; // rax
  __int16 v25; // r10
  __int16 v26; // r11
  bool v27; // zf
  _QWORD *v28; // rbx
  _QWORD *v29; // rdi
  int v30; // eax
  unsigned __int64 n0x200000_1; // rax
  __int64 v32; // rdi
  int event_key_from_source_location_2; // eax
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 result; // rax
  __int64 *v37; // [rsp+30h] [rbp-89h]
  volatile signed __int64 *v38; // [rsp+38h] [rbp-81h]
  _QWORD *v39; // [rsp+50h] [rbp-69h]
  __int64 v40; // [rsp+58h] [rbp-61h]
  char *v41; // [rsp+70h] [rbp-49h] BYREF
  int event_key_from_source_location_1; // [rsp+78h] [rbp-41h]
  __int64 v43; // [rsp+80h] [rbp-39h]
  const char *p_struct_SEvtNotify_OnDamageMapFailed; // [rsp+88h] [rbp-31h]
  char v45; // [rsp+90h] [rbp-29h]
  void (__fastcall *__StarEngineModule_)(ULONG_PTR); // [rsp+98h] [rbp-21h]
  void (__fastcall *__StarEngineModule__1)(ULONG_PTR); // [rsp+A0h] [rbp-19h]
  char *v48; // [rsp+A8h] [rbp-11h] BYREF
  int event_key_from_source_location_3; // [rsp+B0h] [rbp-9h]
  __int64 v50; // [rsp+B8h] [rbp-1h]
  const char *p_struct_SEvtNotify_OnDamageMapFailed_1; // [rsp+C0h] [rbp+7h]
  char v52; // [rsp+C8h] [rbp+Fh]
  void (__fastcall *__StarEngineModule__2)(ULONG_PTR); // [rsp+D0h] [rbp+17h]
  void (__fastcall *__StarEngineModule__3)(ULONG_PTR); // [rsp+D8h] [rbp+1Fh]
  char v55; // [rsp+120h] [rbp+67h] BYREF
  unsigned __int64 v56; // [rsp+128h] [rbp+6Fh] BYREF
  unsigned __int64 v57; // [rsp+130h] [rbp+77h] BYREF

  v1 = a1 + 0x160;
  v39 = (_QWORD *)(a1 + 0x148);
  v40 = a1 + 0x160;
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v1 + 0x10) == v3 )
  {
    ++*(_DWORD *)(v1 + 0x14);
  }
  else
  {
    v4 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)v1, 0x200000, 0);
    if ( v5 )
      sub_1403E1120(v1, v5, v4, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v1 + 8) = v4;
    *(_DWORD *)(v1 + 0x10) = v3;
  }
  if ( *v39 != v39[1] )
    v39[1] = *v39;
  v6 = *(_DWORD *)(v40 + 0x14);
  if ( v6 )
  {
    *(_DWORD *)(v40 + 0x14) = v6 - 1;
  }
  else
  {
    *(_DWORD *)(v40 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v40, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
      *(_QWORD *)(v40 + 8) = &p_Src;
    else
      rw_lock_handle_write_release_contention(v40, n0x200000);
  }
  if ( sub_1403113B0((__int64 *)(a1 + 0x138)) )
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 0x138) & 0xFFFFFFFFFFFFLL) + 0x1D8LL))(
      *(_QWORD *)(*(_QWORD *)(a1 + 0x138) & 0xFFFFFFFFFFFFLL),
      0);
  v37 = (__int64 *)(a1 + 0x178);
  v38 = (volatile signed __int64 *)(a1 + 0x190);
  v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x1A0) == v8 )
  {
    ++*(_DWORD *)(a1 + 0x1A4);
  }
  else
  {
    v9 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v10 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0x190), 0x200000, 0);
    if ( v10 )
      sub_1403E1120(a1 + 0x190, v10, v9, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(a1 + 0x198) = v9;
    *(_DWORD *)(a1 + 0x1A0) = v8;
  }
  v11 = a1 + 0x178;
  v12 = *(_QWORD *)(a1 + 0x180);
  v13 = *v37;
  if ( *v37 != v12 )
  {
    n0xFFF = 0xFFF;
    do
    {
      v15 = *(_QWORD *)(v13 + 0x10);
      if ( v15 )
      {
        v16 = HIWORD(v15);
        if ( (v16 & 0xF000) != 0 )
        {
          v17 = map_flag_to_mask(0x2000u);
          v19 = v18 & ~(v17 - 1);
        }
        else
        {
          v19 = (*(_QWORD *)(v13 + 0x10) & 0xFFFFFFFFFFFFLL) - 6;
        }
        if ( *(_WORD *)(v19 + 2) == ((unsigned __int16)n0xFFF & (unsigned __int16)v16) )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v20 = is_thread_privileged_or_bypass_mode()) )
            v20 = 1;
          if ( (*(_WORD *)(v19 + 4) == 2 && v20 || sub_140395410((_QWORD *)(v13 + 0x10)))
            && *(_QWORD *)(v13 + 0x10) != *(_QWORD *)(a1 + 0x140) )
          {
            v21 = qword_149C8DFC0;
            v56 = *(_QWORD *)(v13 + 0x10);
            if ( is_entity_descriptor_valid_or_accessible(&v56) )
            {
              v41 = &v55;
              event_key_from_source_location = ::event_key_from_source_location_3;
              if ( !::event_key_from_source_location_3 )
                event_key_from_source_location = get_event_key_from_source_location(
                                                   &::event_key_from_source_location_3,
                                                   (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\IDamageMap.h",
                                                   0x2C);
              event_key_from_source_location_1 = event_key_from_source_location;
              v43 = 1;
              p_struct_SEvtNotify_OnDamageMapFailed = "struct SEvtNotify_OnDamageMapFailed";
              v45 = byte_149D7FF50;
              __StarEngineModule_ = _StarEngineModule__;
              __StarEngineModule__1 = _StarEngineModule__;
              (*(void (__fastcall **)(__int64, unsigned __int64, char **))(*(_QWORD *)v21 + 0x360LL))(v21, v56, &v41);
            }
          }
        }
      }
      v23 = *(_QWORD *)(v13 + 8);
      if ( v23 )
      {
        if ( (v23 & 0xF000000000000000uLL) != 0 )
        {
          v24 = map_flag_to_mask(HIWORD(v23) & 0xF000);
          v27 = *(_WORD *)((v23 & -v24 & 0xFFFFFFFFFFFFLL) + 2) == (unsigned __int16)(v26 & v25);
        }
        else
        {
          v27 = *(_WORD *)((v23 & 0xFFFFFFFFFFFFLL) - 4) == HIWORD(v23);
        }
        if ( v27 )
          (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v23 & 0xFFFFFFFFFFFFLL) + 0x1D8LL))(
            *(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL),
            0);
      }
      v13 += 0x38;
      n0xFFF = 0xFFF;
    }
    while ( v13 != v12 );
    v11 = a1 + 0x178;
  }
  v28 = *(_QWORD **)v11;
  v29 = *(_QWORD **)(v11 + 8);
  if ( *(_QWORD **)v11 != v29 )
  {
    do
    {
      if ( *v28 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v28 + 8LL))(*v28);
      *v28 = 0;
      v28 += 7;
    }
    while ( v28 != v29 );
    *(_QWORD *)(v11 + 8) = *(_QWORD *)v11;
  }
  v30 = *(_DWORD *)(a1 + 0x1A4);
  if ( v30 )
  {
    *(_DWORD *)(a1 + 0x1A4) = v30 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x1A0) = 0xFFFFFFFF;
    n0x200000_1 = _InterlockedCompareExchange64(v38, 0, 0x200000);
    if ( n0x200000_1 == 0x200000 )
      *(_QWORD *)(a1 + 0x198) = &p_Src;
    else
      rw_lock_handle_write_release_contention((__int64)v38, n0x200000_1);
  }
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x140)) )
  {
    v32 = qword_149C8DFC0;
    v57 = *(_QWORD *)(a1 + 0x140);
    if ( is_entity_descriptor_valid_or_accessible(&v57) )
    {
      v48 = &v55;
      event_key_from_source_location_2 = ::event_key_from_source_location_3;
      if ( !::event_key_from_source_location_3 )
        event_key_from_source_location_2 = get_event_key_from_source_location(
                                             &::event_key_from_source_location_3,
                                             (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\IDamageMap.h",
                                             0x2C);
      event_key_from_source_location_3 = event_key_from_source_location_2;
      v50 = 1;
      p_struct_SEvtNotify_OnDamageMapFailed_1 = "struct SEvtNotify_OnDamageMapFailed";
      v52 = byte_149D7FF50;
      __StarEngineModule__2 = _StarEngineModule__;
      __StarEngineModule__3 = _StarEngineModule__;
      (*(void (__fastcall **)(__int64, unsigned __int64, char **))(*(_QWORD *)v32 + 0x360LL))(v32, v57, &v48);
    }
  }
  v34 = *(_QWORD *)(a1 + 0x128);
  if ( v34 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 8LL))(v34);
  *(_QWORD *)(a1 + 0x128) = 0;
  v35 = *(_QWORD *)(a1 + 0x130);
  if ( v35 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 0x10LL))(v35);
  *(_QWORD *)(a1 + 0x130) = 0;
  result = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))(qword_149C8E018);
  if ( *(_QWORD *)(a1 + 0x110) )
    return sub_1408605C0(*(_QWORD *)(result + 0x10), a1);
  return result;
}

// --- End Function: sub_140853590 (0x140853590) ---

// --- Function: sub_140853A50 (0x140853A50) ---
__int64 __fastcall sub_140853A50(__int64 a1)
{
  __int64 v1; // r15
  signed __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // r9
  unsigned int v6; // esi
  __int64 v7; // r12
  __int64 v8; // r14
  __int64 v9; // rdx
  bool v10; // r10
  __int64 v11; // r11
  int v12; // ecx
  int v13; // eax

  v1 = *(_QWORD *)(a1 + 0x110);
  if ( *(_DWORD *)(v1 + 0x58) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v1 + 0x5C);
  }
  else
  {
    v3 = _InterlockedIncrement64((volatile signed __int64 *)(v1 + 0x48));
    if ( (v3 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v1 + 0x48, v3, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  if ( *(_QWORD *)(v1 + 8) != *(_QWORD *)(v1 + 0x10) )
  {
    v4 = *(_QWORD *)(a1 + 0x120);
    if ( v4 )
    {
      v5 = 0;
      v6 = *(_DWORD *)(v4 + 0x50) * *(_DWORD *)(v4 + 0x50);
      if ( v6 )
      {
        v7 = *(_QWORD *)(v4 + 0x20);
        v8 = *(_QWORD *)(v4 + 0x18);
        while ( 1 )
        {
          if ( v8 == v7 || *(_WORD *)(v8 + 8 * v5 + 6) )
          {
            v9 = *(_QWORD *)(v1 + 8);
            v10 = (float)*(unsigned __int8 *)(v9 + 4 * v5 + 1) >= 17.0
               || (float)*(unsigned __int8 *)(v9 + 4 * v5 + 2) >= 17.0;
            v11 = *(_QWORD *)(a1 + 0x20);
            v12 = v11 != *(_QWORD *)(a1 + 0x28)
               && ((1 << ((v5 + *(_BYTE *)(a1 + 0x18)) & 0x1F))
                 & *(_DWORD *)(v11 + 4 * ((unsigned __int64)(unsigned int)(v5 + *(_DWORD *)(a1 + 0x18)) >> 5))) != 0;
            v13 = *(_BYTE *)(v9 + 4 * v5) || v10;
            if ( v12 != v13 )
              break;
          }
          v5 = (unsigned int)(v5 + 1);
          if ( (unsigned int)v5 >= v6 )
            return rw_lock_release_read_lock(v1 + 0x48);
        }
        LogTraceConditional("CDamageMap | Damage map and tree do not share the same information!");
      }
    }
  }
  return rw_lock_release_read_lock(v1 + 0x48);
}

// --- End Function: sub_140853A50 (0x140853A50) ---

// --- Function: sub_140853BE0 (0x140853BE0) ---
__int64 __fastcall sub_140853BE0(__int64 a1, __int64 a2)
{
  volatile signed __int32 *v4; // rbx
  int v5; // edi
  unsigned int v6; // eax
  __int64 v7; // r14
  volatile signed __int64 *v8; // rdi
  int v9; // ebp
  __int64 v10; // r8
  unsigned __int64 v11; // rax
  int v12; // eax
  unsigned __int64 n0x200000; // rax
  int v14; // eax
  unsigned __int32 v15; // eax
  int n0x900; // [rsp+30h] [rbp-78h] BYREF
  __int64 v18; // [rsp+34h] [rbp-74h]
  int v19; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v20; // [rsp+40h] [rbp-68h]
  unsigned __int64 v21; // [rsp+48h] [rbp-60h]
  __int64 v22; // [rsp+50h] [rbp-58h]
  __int64 v23; // [rsp+58h] [rbp-50h]

  n0x900 = 0x900;
  v18 = 0;
  v19 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v20 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D80018,
    "CDamageMap::MT_DetachJoints",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xD8A);
  v4 = (volatile signed __int32 *)(a1 + 0xF8);
  HIWORD(n0x900) = word_149D80018;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x108) == v5 )
  {
    ++*(_DWORD *)(a1 + 0x10C);
  }
  else
  {
    v6 = _InterlockedCompareExchange(v4, 1, 0);
    if ( v6 )
      sub_1403C6E80(a1 + 0xF8, v6, (__int64)"CDamageMap::MT_DetachJoints", 1);
    else
      *(_QWORD *)(a1 + 0x100) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x108) = v5;
  }
  sub_140575060((_BYTE *)(a1 + 0xF0), a2);
  v7 = *(_QWORD *)(a1 + 0x110);
  v8 = (volatile signed __int64 *)(v7 + 0x48);
  v9 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v7 + 0x58) == v9 )
  {
    ++*(_DWORD *)(v7 + 0x5C);
  }
  else
  {
    v10 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v11 = _InterlockedCompareExchange64(v8, 0x200000, 0);
    if ( v11 )
      sub_1403E1120(v7 + 0x48, v11, v10, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v7 + 0x50) = v10;
    *(_DWORD *)(v7 + 0x58) = v9;
  }
  sub_140573F90((_BYTE *)(v7 + 0x38), a2);
  if ( v7 != 0xFFFFFFFFFFFFFFB8uLL )
  {
    v12 = *(_DWORD *)(v7 + 0x5C);
    if ( v12 )
    {
      *(_DWORD *)(v7 + 0x5C) = v12 - 1;
    }
    else
    {
      *(_DWORD *)(v7 + 0x58) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(v8, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v7 + 0x50) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v7 + 0x48, n0x200000);
    }
  }
  v14 = *(_DWORD *)(a1 + 0x10C);
  if ( v14 )
  {
    *(_DWORD *)(a1 + 0x10C) = v14 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x108) = 0xFFFFFFFF;
    v15 = _InterlockedCompareExchange(v4, 0, 1);
    if ( v15 == 1 )
      *(_QWORD *)(a1 + 0x100) = &p_Src;
    else
      sub_1403DF590(a1 + 0xF8, v15);
  }
  v21 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_140853BE0 (0x140853BE0) ---

// --- Function: sub_140853DF0 (0x140853DF0) ---
__int64 *__fastcall sub_140853DF0(__int64 a1, __int64 *a2, unsigned __int64 a3, bool a4, _QWORD *a5, _QWORD *a6)
{
  bool v6; // zf
  _QWORD *v8; // rsi
  _QWORD *v10; // r12
  _QWORD *v11; // r13
  bool v12; // al
  unsigned __int64 v13; // rcx
  __int64 v14; // r15
  int v15; // ebx
  int *ThreadLogContextSlot; // rax
  __int64 v17; // r15
  __int64 v18; // rbx
  __int64 v19; // rax
  __int64 (__fastcall *v20)(__int64, __int128 *, unsigned __int64, int **, __int64, __int128 *, _OWORD *, _BYTE *, int *, bool *, char, _BYTE); // r10
  __int64 v21; // rcx
  __int64 v22; // rax
  _QWORD *v23; // rax
  __int64 v24; // rcx
  _QWORD *v25; // rbx
  char *v26; // rbx
  char *v27; // rsi
  __int64 n0x10; // rbx
  _BYTE *v29; // rsi
  __int64 v30; // rcx
  __int64 v31; // rax
  char *v32; // rax
  bool v34[8]; // [rsp+60h] [rbp-A0h] BYREF
  int n0xCA; // [rsp+68h] [rbp-98h] BYREF
  int n0xBC; // [rsp+6Ch] [rbp-94h]
  __int64 v37; // [rsp+70h] [rbp-90h] BYREF
  __int128 v38; // [rsp+78h] [rbp-88h] BYREF
  char *v39; // [rsp+88h] [rbp-78h]
  int *p_n0xCA; // [rsp+90h] [rbp-70h] BYREF
  __int64 *v41; // [rsp+98h] [rbp-68h]
  __int128 v42; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v43; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v44; // [rsp+B8h] [rbp-48h]
  __int64 v45; // [rsp+C0h] [rbp-40h] BYREF
  _OWORD v46[24]; // [rsp+D0h] [rbp-30h] BYREF
  _BYTE v47[64]; // [rsp+250h] [rbp+150h] BYREF
  unsigned __int64 v48; // [rsp+2F0h] [rbp+1F0h] BYREF

  v48 = a3;
  v6 = *(_BYTE *)(a1 + 0xC1) == 0;
  v8 = a5;
  v10 = a6;
  v34[0] = a4;
  if ( v6 || (v45 = *(_QWORD *)(a1 + 0x140), a3 == v45) )
  {
    *a2 = a1;
    (**(void (__fastcall ***)(__int64))a1)(a1);
  }
  else
  {
    v11 = (_QWORD *)(a1 + 0x80);
    v12 = is_entity_descriptor_valid_or_accessible(&v48);
    v13 = v48 & 0xFFFFFFFFFFFFLL;
    if ( !v12 )
      v13 = 0;
    *(_QWORD *)&v42 = v13;
    sub_1402AFBB0(v11, &v43, &v42);
    v14 = v43;
    if ( v43 == *v11 + v11[3] )
    {
      n0xCA = 0xCA;
      p_n0xCA = &n0xCA;
      n0xBC = 0xBC;
      v41 = &v37;
      v15 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)&p_n0xCA,
              (__int64)"%s: Tried detaching an entity/character which wasn't attached",
              "CDamageMap::MT_DetachSubHierarchyCharacter");
      if ( (v15 & 0xFFFFF) != 0 )
      {
        ThreadLogContextSlot = getThreadLogContextSlot();
        p_n0xCA = &n0xCA;
        v41 = &v37;
        n0xCA = 0xCA;
        v42 = 0;
        n0xBC = 0xBC;
        sub_140354250(
          3,
          (__int64)&p_n0xCA,
          "%s: Tried detaching an entity/character which wasn't attached",
          (__int64)"CDamageMap::MT_DetachSubHierarchyCharacter",
          1,
          v15,
          &v42,
          0,
          (__int64)ThreadLogContextSlot);
      }
    }
    if ( v14 == *v11 + v11[3] )
    {
      *a2 = 0;
    }
    else
    {
      *(_WORD *)(a1 + 0x1DC) |= 2u;
      v17 = v44;
      if ( v8 )
      {
        v18 = *(_QWORD *)(*(_QWORD *)v44 + 8LL);
        if ( *v8 != v18 )
        {
          if ( v18 )
            (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v18 + 8LL))(*(_QWORD *)(*(_QWORD *)v44 + 8LL));
          if ( *v8 )
            (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v8 + 0x10LL))(*v8);
          *v8 = v18;
        }
      }
      if ( v10 )
        sub_140573D50(v10, (unsigned __int8 *)(*(_QWORD *)v17 + 0x10LL));
      sub_140853BE0(a1, *(_QWORD *)v17 + 0x10LL);
      v37 = 0;
      if ( v34[0] )
      {
        v19 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))(qword_149C8E018);
        if ( v19 )
        {
          v34[0] = *(_BYTE *)(a1 + 0xC0) != 0;
          v20 = *(__int64 (__fastcall **)(__int64, __int128 *, unsigned __int64, int **, __int64, __int128 *, _OWORD *, _BYTE *, int *, bool *, char, _BYTE))(*(_QWORD *)v19 + 0x28LL);
          v21 = v19;
          n0xCA = 0xDEAD00;
          memset(v46, 0, sizeof(v46));
          v38 = 0;
          v39 = 0;
          v22 = *(_QWORD *)v17 + 0x10LL;
          p_n0xCA = 0;
          v23 = (_QWORD *)v20(v21, &v42, v48, &p_n0xCA, v22, &v38, v46, v47, &n0xCA, v34, 1, 0);
          v24 = v37;
          v25 = v23;
          v37 = *v23;
          *v23 = v24;
          if ( v24 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 8LL))(v24);
          *v25 = 0;
          if ( (_QWORD)v42 )
            (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v42 + 8LL))(v42);
          v26 = (char *)v38;
          *(_QWORD *)&v42 = 0;
          if ( (_QWORD)v38 )
          {
            v27 = (char *)*((_QWORD *)&v38 + 1);
            if ( (_QWORD)v38 != *((_QWORD *)&v38 + 1) )
            {
              do
              {
                if ( *(_QWORD *)v26 )
                  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)v26 + 8LL))(*(_QWORD *)v26);
                *(_QWORD *)v26 = 0;
                v26 += 0x28;
              }
              while ( v26 != v27 );
              v26 = (char *)v38;
            }
            sub_1403A6820((__int64)&v38, (unsigned __int64)v26, 0x28 * ((v39 - v26) / 0x28));
            v38 = 0;
            v39 = 0;
          }
          n0x10 = 0x10;
          v29 = v47;
          do
          {
            v30 = *((_QWORD *)v29 + 0xFFFFFFFD);
            v29 += 0xFFFFFFE8;
            --n0x10;
            if ( v30 )
              sub_1402A6590(v30);
          }
          while ( n0x10 );
        }
      }
      sub_140861E10(v11, &p_n0xCA, &v43);
      v31 = v37;
      if ( v37 && v37 != a1 )
      {
        v32 = (char *)sub_1402A65A0(0x18u);
        if ( v32 )
        {
          *(_QWORD *)v32 = &v38;
          *((_QWORD *)v32 + 1) = &v37;
          *((_QWORD *)v32 + 2) = &v45;
          v39 = v32;
        }
        else
        {
          v39 = 0;
          v32 = 0;
        }
        *(_QWORD *)&v38 = sub_14084BF90;
        *((_QWORD *)&v38 + 1) = sub_14084C040;
        if ( sub_14084C040 == (__int64 (__fastcall *)())1 )
          sub_14084BF90(v48);
        else
          sub_14084AA30(v32, v48);
        if ( *((_QWORD *)&v38 + 1) >= 2u )
          (*((void (__fastcall **)(__int64, __int128 *))&v38 + 1))(2, &v38);
        v31 = v37;
      }
      *a2 = v31;
    }
  }
  return a2;
}

// --- End Function: sub_140853DF0 (0x140853DF0) ---

// --- Function: sub_140854340 (0x140854340) ---
__int64 __fastcall sub_140854340(__int64 a1, __int64 a2, __m256 *a3, float a4, unsigned int a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  __int128 v8; // xmm9
  __int128 v9; // xmm10
  __int128 v10; // xmm11
  __int128 v11; // xmm12
  __int128 v12; // xmm13
  __int128 v13; // xmm14
  __int128 v14; // xmm15
  __m256 v18; // ymm1
  __int64 v20; // rax
  __int128 n0x3F800000_1; // xmm3
  __int128 n0x3F800000; // kr00_16
  __int128 n0x3F800000_2; // xmm4
  unsigned int v27; // xmm7_4
  unsigned int v28; // xmm5_4
  __int128 n0x3F800000_4; // xmm15
  __int128 n0x3F800000_3; // kr00_16
  float v31; // xmm11_4
  float v32; // xmm12_4
  float v33; // xmm13_4
  float v34; // xmm14_4
  __m256i v40; // ymm1
  __int128 v41; // xmm3
  __int128 v42; // kr00_16
  __m256i v43; // ymm0
  __int128 v47; // kr00_16
  __int128 v50; // kr00_16
  __int128 v53; // kr00_16
  _DWORD v74[4]; // [rsp+30h] [rbp-D0h] BYREF
  __m256 v75; // [rsp+40h] [rbp-C0h] BYREF
  __m256 v76; // [rsp+60h] [rbp-A0h] BYREF
  __m256 v77; // [rsp+80h] [rbp-80h]
  __m256 v78; // [rsp+A0h] [rbp-60h] BYREF
  int n0x900; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v80; // [rsp+C4h] [rbp-3Ch]
  int v81; // [rsp+CCh] [rbp-34h]
  unsigned __int64 v82; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v83; // [rsp+D8h] [rbp-28h]
  __int64 v84; // [rsp+E0h] [rbp-20h]
  __int64 v85; // [rsp+E8h] [rbp-18h]
  _BYTE v86[64]; // [rsp+110h] [rbp+10h] BYREF
  __int128 v87; // [rsp+150h] [rbp+50h]
  __int128 v88; // [rsp+160h] [rbp+60h]
  __int128 v89; // [rsp+170h] [rbp+70h]
  __int128 v90; // [rsp+180h] [rbp+80h]
  __int128 v91; // [rsp+190h] [rbp+90h]
  __int128 v92; // [rsp+1A0h] [rbp+A0h]
  __int128 v93; // [rsp+1B0h] [rbp+B0h]
  __int128 v94; // [rsp+1C0h] [rbp+C0h]
  __int128 v95; // [rsp+1D0h] [rbp+D0h]
  __int128 v96; // [rsp+1E0h] [rbp+E0h]

  v96 = v5;
  v95 = v6;
  v94 = v7;
  v93 = v8;
  v92 = v9;
  v91 = v10;
  v90 = v11;
  v89 = v12;
  v88 = v13;
  v87 = v14;
  n0x900 = 0x900;
  v80 = 0;
  v81 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v82 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFA4,
    "CDamageMap::MT_ExpandImpactToMinimumRadius",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xAF);
  v18 = a3[1];
  v75 = *a3;
  v78 = a3[2];
  v77 = v78;
  HIWORD(n0x900) = word_149D7FFA4;
  v76 = v18;
  __asm { vzeroupper }
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x140)) )
    _XMM0 = *(unsigned __int64 *)((*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL)
                                                                                       + 0x1E8LL))(
                                    *(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL,
                                    v86,
                                    2)
                                + 0x38);
  else
    _XMM0 = 0x3FF0000000000000uLL;
  v20 = *(_QWORD *)(a1 + 0x120);
  __asm
  {
    vcvtsd2ss xmm0, xmm0, xmm0
    vmaxss  xmm2, xmm0, cs:dword_1482BB398
  }
  _XMM0 = (unsigned int)dword_149A71268;
  n0x3F800000 = 0x3F800000u;
  *(float *)&n0x3F800000 = 1.0 / *(float *)&_XMM2;
  n0x3F800000_1 = n0x3F800000;
  *(float *)&n0x3F800000 = (float)(1.0 / *(float *)&_XMM2) * v75.m256_f32[7];
  n0x3F800000_2 = n0x3F800000;
  n0x3F800000_3 = n0x3F800000_1;
  *(float *)&n0x3F800000_3 = *(float *)&n0x3F800000_1 * v76.m256_f32[0];
  n0x3F800000_4 = n0x3F800000_3;
  _XMM2 = a5;
  v75.m256_f32[5] = *(float *)&n0x3F800000_1 * v75.m256_f32[5];
  v27 = LODWORD(v75.m256_f32[5]);
  v75.m256_f32[6] = *(float *)&n0x3F800000_1 * v75.m256_f32[6];
  v28 = LODWORD(v75.m256_f32[6]);
  v75.m256_f32[7] = *(float *)&n0x3F800000_2;
  v76.m256_f32[0] = *(float *)&n0x3F800000_1 * v76.m256_f32[0];
  v76.m256_f32[1] = *(float *)&n0x3F800000_1 * v76.m256_f32[1];
  v31 = v76.m256_f32[1];
  v76.m256_f32[2] = *(float *)&n0x3F800000_1 * v76.m256_f32[2];
  v32 = v76.m256_f32[2];
  v76.m256_f32[3] = *(float *)&n0x3F800000_1 * v76.m256_f32[3];
  v33 = v76.m256_f32[3];
  v76.m256_f32[4] = *(float *)&n0x3F800000_1 * v76.m256_f32[4];
  v34 = v76.m256_f32[4];
  __asm
  {
    vcmpneqss xmm1, xmm2, xmm10
    vblendvps xmm2, xmm0, xmm2, xmm1
  }
  _XMM1 = *(unsigned int *)(v20 + 0x70);
  __asm { vmaxss  xmm0, xmm1, cs:dword_1482BB398 }
  v40 = (__m256i)v76;
  v42 = _XMM2;
  *(float *)&v42 = *(float *)&_XMM2 * *(float *)&_XMM0;
  v41 = v42;
  *(__m256 *)a2 = v75;
  v43 = (__m256i)v78;
  *(__m256i *)(a2 + 0x20) = v40;
  *(__m256i *)(a2 + 0x40) = v43;
  *(float *)&v42 = (float)(*(float *)&_XMM2 * *(float *)&_XMM0) - (float)(v34 - *(float *)&n0x3F800000_4);
  _XMM1 = v42;
  __asm { vmaxss  xmm9, xmm1, xmm10 }
  v47 = v41;
  *(float *)&v47 = *(float *)&v41 - (float)(v33 - *(float *)&n0x3F800000_2);
  _XMM2 = v47;
  __asm { vmaxss  xmm8, xmm2, xmm10 }
  v50 = v41;
  *(float *)&v50 = *(float *)&v41 - (float)(v32 - *(float *)&v28);
  _XMM1 = v50;
  __asm { vmaxss  xmm6, xmm1, xmm10 }
  v53 = v41;
  *(float *)&v53 = *(float *)&v41 - (float)(v31 - *(float *)&v27);
  _XMM2 = v53;
  __asm { vmaxss  xmm3, xmm2, xmm10 }
  _XMM0 = v27;
  __asm { vminss  xmm2, xmm0, xmm3 }
  *(float *)(a2 + 0x14) = *(float *)&v27 - *(float *)&_XMM2;
  _XMM1 = v28;
  __asm { vminss  xmm5, xmm4, xmm8 }
  LODWORD(_XMM0) = n0x3F800000_2;
  __asm { vminss  xmm4, xmm1, xmm6 }
  *(float *)(a2 + 0x18) = *(float *)&_XMM1 - *(float *)&_XMM4;
  *(float *)(a2 + 0x1C) = *(float *)&_XMM0 - *(float *)&_XMM5;
  __asm { vminss  xmm7, xmm15, xmm9 }
  *(float *)(a2 + 0x20) = *(float *)&n0x3F800000_4 - *(float *)&_XMM7;
  *(float *)(a2 + 0x24) = (float)(*(float *)&_XMM3 - *(float *)&_XMM2) + v31;
  *(float *)(a2 + 0x28) = (float)(*(float *)&_XMM6 - *(float *)&_XMM4) + v32;
  *(float *)(a2 + 0x2C) = (float)(*(float *)&_XMM8 - *(float *)&_XMM5) + v33;
  *(float *)(a2 + 0x30) = (float)(*(float *)&_XMM9 - *(float *)&_XMM7) + v34;
  _XMM2 = LODWORD(a4);
  _XMM0 = (unsigned int)dword_149A71264;
  __asm
  {
    vcmpneqss xmm1, xmm2, xmm10
    vblendvps xmm6, xmm0, xmm2, xmm1
  }
  __asm { vzeroupper }
  sub_14084B650(
    (unsigned int)&v78,
    (unsigned int)&v75.m256_f32[5],
    (unsigned int)&v76.m256_f32[1],
    (unsigned int)&v75.m256_f32[1],
    _XMM6);
  sub_14084B650((unsigned int)v74, a2 + 0x14, a2 + 0x24, a2 + 4, _XMM6);
  _XMM0 = v74[1];
  __asm { vmaxss  xmm2, xmm0, xmm9 }
  _XMM0 = v74[2];
  *(float *)&_XMM8 = v78.m256_f32[1] / *(float *)&_XMM2;
  __asm { vmaxss  xmm3, xmm0, xmm9 }
  _XMM0 = v74[3];
  *(float *)&v53 = v78.m256_f32[2] / *(float *)&_XMM3;
  __asm { vmaxss  xmm2, xmm0, xmm9 }
  _XMM0 = v74[0];
  *(float *)&_XMM6 = v78.m256_f32[3] / *(float *)&_XMM2;
  __asm { vmaxss  xmm2, xmm0, xmm9 }
  *(float *)(a2 + 4) = (float)(v78.m256_f32[0] / *(float *)&_XMM2) * *(float *)(a2 + 4);
  *(float *)(a2 + 8) = *(float *)&_XMM8 * *(float *)(a2 + 8);
  *(float *)(a2 + 0xC) = *(float *)&v53 * *(float *)(a2 + 0xC);
  *(float *)(a2 + 0x10) = *(float *)&_XMM6 * *(float *)(a2 + 0x10);
  v83 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return a2;
}

// --- End Function: sub_140854340 (0x140854340) ---

// --- Function: sub_140854780 (0x140854780) ---
__int64 *__fastcall sub_140854780(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        int a4,
        __int64 a5,
        _QWORD *a6,
        void *Src,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  __int64 v12; // rsi
  int v13; // r15d
  int v16; // ebp
  int v17; // r14d
  __int64 v18; // r8
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // r12
  int v21; // r14d
  __int64 v22; // r15
  __int16 n0xFFF; // r11
  __int64 v24; // r9
  unsigned __int64 v25; // r9
  unsigned __int64 v26; // r10
  unsigned __int64 v27; // r9
  __int64 v28; // r10
  __int64 v29; // rax
  __int64 v30; // r10
  __int64 v31; // rsi
  bool v32; // al
  __int64 v33; // rax
  _QWORD *v34; // r14
  __int64 v35; // rsi
  void (__fastcall ***v36)(_QWORD); // rcx
  __int64 v37; // rax
  __int64 v38; // rsi
  __int64 v39; // rbx
  __int64 *v40; // r15
  __int64 v41; // rsi
  const char *v42; // rax
  void (__fastcall ***v43)(_QWORD); // rcx
  bool v44; // zf
  __int64 v45; // rcx
  int v46; // eax
  _QWORD *v47; // rbx
  unsigned __int64 n0x200000_1; // rax
  _QWORD *v49; // rcx
  __int64 *v50; // rdx
  int *v51; // rax
  __int64 v52; // rcx
  int v53; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v56; // [rsp+60h] [rbp-68h] BYREF
  __int64 v57; // [rsp+68h] [rbp-60h] BYREF
  _QWORD *v58; // [rsp+70h] [rbp-58h]
  __int64 v59; // [rsp+78h] [rbp-50h]
  int *v60; // [rsp+80h] [rbp-48h]
  int v61; // [rsp+88h] [rbp-40h] BYREF
  unsigned __int64 v62; // [rsp+D0h] [rbp+8h] BYREF
  int v63; // [rsp+E8h] [rbp+20h]

  v63 = a4;
  v61 = 1;
  v12 = a1 + 0x30;
  v58 = (_QWORD *)(a1 + 0x18);
  v59 = a1 + 0x30;
  v60 = &v61;
  v13 = a4;
  v16 = 0xFFFFFFFF;
  v17 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v12 + 0x10) == v17 )
  {
    ++*(_DWORD *)(v12 + 0x14);
  }
  else
  {
    v18 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v19 = _InterlockedCompareExchange64((volatile signed __int64 *)v12, 0x200000, 0);
    if ( v19 )
      sub_1403E1120(v12, v19, v18, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v12 + 8) = v18;
    *(_DWORD *)(v12 + 0x10) = v17;
  }
  v20 = (__int64)(v58[1] - *v58) >> 3;
  v21 = 0;
  if ( !v20 )
  {
LABEL_27:
    v33 = sub_1402A65A0(0x2E0u);
    v34 = a6;
    v35 = v33;
    if ( v33 )
    {
      v36 = (void (__fastcall ***)(_QWORD))*a6;
      v57 = (__int64)v36;
      if ( v36 )
        (**v36)(v36);
      v37 = sub_140849540(v35, a3, v13, a5, &v57, (unsigned __int8 *)Src, a8, a9, a10, (_DWORD *)a11, (char *)a12);
      v56 = v37;
      v38 = v37;
      v39 = v37;
      if ( v37 )
        _InterlockedIncrement((volatile signed __int32 *)(v37 + 0xBC));
    }
    else
    {
      v39 = 0;
      v56 = 0;
      v38 = 0;
    }
    if ( v16 < 0 )
    {
      if ( dword_149D7FE5C )
        LogTraceConditional("[Damage Maps Mgr] | Appending new damage map");
      v49 = v58;
      v50 = (__int64 *)v58[1];
      if ( v50 == (__int64 *)v58[2] )
      {
        sub_140844E40(v58, v50, &v56);
      }
      else
      {
        *v50 = v39;
        if ( v39 )
          _InterlockedIncrement((volatile signed __int32 *)(v38 + 0xBC));
        v49[1] += 8LL;
      }
    }
    else
    {
      if ( dword_149D7FE5C )
        LogTraceConditional("[Damage Maps Mgr] | adding damage map to empty slot");
      v40 = (__int64 *)(*v58 + 8LL * v16);
      if ( v39 )
        _InterlockedIncrement((volatile signed __int32 *)(v39 + 0xBC));
      v41 = *v40;
      if ( *v40 && _InterlockedExchangeAdd((volatile signed __int32 *)(v41 + 0xBC), 0xFFFFFFFF) <= 1 )
      {
        sub_14084A700(v41);
        sub_1402A6590(v41);
      }
      *v40 = v39;
    }
    v51 = v60;
    *a2 = v39;
    v44 = (*v51)-- == 1;
    if ( v44 )
    {
      v52 = v59;
      v53 = *(_DWORD *)(v59 + 0x14);
      if ( v53 )
      {
        *(_DWORD *)(v59 + 0x14) = v53 - 1;
      }
      else
      {
        *(_DWORD *)(v59 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v52, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
          *(_QWORD *)(v52 + 8) = &p_Src;
        else
          rw_lock_handle_write_release_contention(v52, n0x200000);
      }
    }
    if ( *v34 )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v34 + 8LL))(*v34);
    *v34 = 0;
    return a2;
  }
  v22 = 0;
  n0xFFF = 0xFFF;
  while ( 1 )
  {
    v24 = *(_QWORD *)(v22 + *v58);
    if ( !v24 )
    {
      if ( v16 < 0 )
        v16 = v21;
      goto LABEL_25;
    }
    v25 = *(_QWORD *)(v24 + 0x140);
    v62 = v25;
    if ( v25 )
    {
      v26 = v25;
      v27 = HIWORD(v25);
      v28 = v26 & 0xFFFFFFFFFFFFLL;
      if ( (v27 & 0xF000) != 0 )
      {
        v29 = map_flag_to_mask(0x2000u);
        v31 = v30 & ~(v29 - 1);
      }
      else
      {
        v31 = v28 - 6;
      }
      if ( *(_WORD *)(v31 + 2) == ((unsigned __int16)n0xFFF & (unsigned __int16)v27) )
        break;
    }
LABEL_25:
    ++v21;
    v22 += 8;
    if ( v21 >= v20 )
    {
      v13 = v63;
      goto LABEL_27;
    }
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v32 = is_thread_privileged_or_bypass_mode()) )
    v32 = 1;
  if ( (*(_WORD *)(v31 + 4) != 2 || !v32) && !sub_140395410(&v62) || v62 != a3 )
  {
    n0xFFF = 0xFFF;
    goto LABEL_25;
  }
  if ( dword_149D7FE5C )
  {
    v42 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a3 & 0xFFFFFFFFFFFFLL) + 0x70LL))(a3 & 0xFFFFFFFFFFFFLL);
    LogTraceConditional("[Damage Maps Mgr] | Found existing damage map on entity %s", v42);
  }
  v43 = *(void (__fastcall ****)(_QWORD))(*v58 + 8LL * v21);
  *a2 = (__int64)v43;
  if ( v43 )
    (**v43)(v43);
  v44 = (*v60)-- == 1;
  if ( v44 )
  {
    v45 = v59;
    v46 = *(_DWORD *)(v59 + 0x14);
    if ( v46 )
    {
      *(_DWORD *)(v59 + 0x14) = v46 - 1;
    }
    else
    {
      *(_DWORD *)(v59 + 0x10) = 0xFFFFFFFF;
      n0x200000_1 = _InterlockedCompareExchange64((volatile signed __int64 *)v45, 0, 0x200000);
      if ( n0x200000_1 == 0x200000 )
        *(_QWORD *)(v45 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v45, n0x200000_1);
    }
  }
  v47 = a6;
  if ( *a6 )
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a6 + 8LL))(*a6);
  *v47 = 0;
  return a2;
}

// --- End Function: sub_140854780 (0x140854780) ---

// --- Function: sub_140854BE0 (0x140854BE0) ---
__int64 __fastcall sub_140854BE0(__int64 a1)
{
  unsigned int v2; // r9d
  __int128 *v3; // rdi
  __int64 v4; // rax
  unsigned int v5; // eax
  int v6; // ecx
  __int16 n0x20; // cx
  unsigned int v8; // r14d
  __int64 v9; // rbx
  int n2; // r10d
  unsigned int *v11; // r8
  unsigned int *v12; // rdx
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rcx
  __int128 v21; // [rsp+30h] [rbp-49h] BYREF
  __int64 v22; // [rsp+40h] [rbp-39h]
  unsigned int v23; // [rsp+48h] [rbp-31h]
  int v24; // [rsp+4Ch] [rbp-2Dh]
  int v25; // [rsp+50h] [rbp-29h]
  int n0x900; // [rsp+60h] [rbp-19h] BYREF
  __int64 v27; // [rsp+64h] [rbp-15h]
  int v28; // [rsp+6Ch] [rbp-Dh]
  unsigned __int64 v29; // [rsp+70h] [rbp-9h]
  unsigned __int64 v30; // [rsp+78h] [rbp-1h]
  __int64 v31; // [rsp+80h] [rbp+7h]
  __int64 v32; // [rsp+88h] [rbp+Fh]

  n0x900 = 0x900;
  v27 = 0;
  v28 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v29 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFF0,
    "CDamageMap::MT_GenerateAABBTree",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x935);
  v3 = (__int128 *)(a1 + 0xC8);
  HIWORD(n0x900) = word_149D7FFF0;
  if ( *(_QWORD *)(a1 + 0xC8) == *(_QWORD *)(a1 + 0xD0) )
  {
    v4 = *(_QWORD *)(a1 + 0x120);
    if ( v4 && (v5 = *(_DWORD *)(v4 + 0x50), _BitScanReverse((unsigned int *)&v6, v5), v5) )
      n0x20 = v6 ^ 0x1F;
    else
      n0x20 = 0x20;
    v22 = 0;
    v25 = (unsigned __int16)(0x1D - n0x20);
    v21 = 0;
    v23 = ((1 << (2 * (0x1D - n0x20) + 1)) - 1) & 0x55555555;
    v24 = v23 ^ (1 << (2 * (0x1D - n0x20)));
    sub_14084DDB0((__int64 *)&v21, v23);
    v8 = v24;
    v2 = 0;
    v9 = v21;
    if ( v24 )
    {
      n2 = 2;
      v11 = (unsigned int *)(v21 + 0x48);
      do
      {
        v12 = v11 + 0xFFFFFFFC;
        v11[0xFFFFFFFC] = n2 - 1;
        v11[0xFFFFFFFD] = n2;
        v11[0xFFFFFFFE] = n2 + 1;
        v11[0xFFFFFFFF] = n2 + 2;
        do
        {
          v13 = *v12++;
          *(_DWORD *)(v9 + 0x50 * v13 + 0x34) = v2;
        }
        while ( v12 != v11 );
        ++v2;
        v11 += 0x14;
        n2 += 4;
      }
      while ( v2 < v8 );
    }
    if ( v3 != &v21 )
    {
      v14 = *(_QWORD *)v3;
      *(_QWORD *)v3 = 0;
      v15 = *(_QWORD *)(a1 + 0xD8);
      *(_QWORD *)(a1 + 0xD8) = 0;
      v16 = *(_QWORD *)v3;
      *(_QWORD *)v3 = v14;
      *(_QWORD *)(a1 + 0xD0) = v14;
      *(_QWORD *)(a1 + 0xD8) = v15;
      if ( v16 )
        sub_1402A6590(v16);
      v17 = *(_QWORD *)v3;
      *(_QWORD *)v3 = v9;
      v9 = v17;
      *(_QWORD *)(a1 + 0xD0) = *((_QWORD *)&v21 + 1);
      *(_QWORD *)(a1 + 0xD8) = v22;
    }
    *(_DWORD *)(a1 + 0xE0) = v23;
    v18 = v25;
    *(_DWORD *)(a1 + 0xE4) = v8;
    *(_DWORD *)(a1 + 0xE8) = v18;
    if ( v9 )
      sub_1402A6590(v9);
    *(_WORD *)(a1 + 0x1DC) |= 2u;
  }
  if ( (*(_BYTE *)(a1 + 0x1DC) & 2) != 0 )
  {
    v19 = *(_QWORD *)(a1 + 0x120);
    if ( *(_QWORD *)(v19 + 0x18) != *(_QWORD *)(v19 + 0x20) && *(_QWORD *)(a1 + 0x1A8) != *(_QWORD *)(a1 + 0x1B0) )
    {
      sub_140860ED0(a1 + 0xC8, v19 + 0x18, a1 + 0x1A8, v2, 0x10, a1 + 0xF0);
      *(_WORD *)(a1 + 0x1DC) &= ~2u;
    }
  }
  v30 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_140854BE0 (0x140854BE0) ---

// --- Function: sub_140854F30 (0x140854F30) ---
void __fastcall sub_140854F30(__int64 a1, __int64 a2, double *a3, double *a4)
{
  __int64 v4; // rcx
  __int64 v7; // rax

  v4 = *(_QWORD *)(a1 + 0x128);
  if ( v4 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x5C0LL))(v4);
    if ( v7 )
    {
      *a3 = *(double *)(v7 + 0x20);
      *a4 = *(double *)(v7 + 0x28);
    }
  }
}

// --- End Function: sub_140854F30 (0x140854F30) ---

// --- Function: sub_140854F90 (0x140854F90) ---
_QWORD *__fastcall sub_140854F90(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x140);
  return a2;
}

// --- End Function: sub_140854F90 (0x140854F90) ---

// --- Function: sub_140855250 (0x140855250) ---
__m128 __fastcall sub_140855250(__int64 a1, __int64 a2)
{
  __int128 v3; // xmm6
  bool v6; // cf
  int v8; // ecx
  __int128 v9; // kr00_16
  float v10; // xmm0_4
  int n0x900; // [rsp+30h] [rbp-68h] BYREF
  __int64 v14; // [rsp+34h] [rbp-64h]
  int v15; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v16; // [rsp+40h] [rbp-58h]
  unsigned __int64 v17; // [rsp+48h] [rbp-50h]
  __int64 v18; // [rsp+50h] [rbp-48h]
  __int64 v19; // [rsp+58h] [rbp-40h]
  __int128 v20; // [rsp+80h] [rbp-18h]

  v20 = v3;
  n0x900 = 0x900;
  v14 = 0;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v16 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFD8,
    "CDamageMap::MT_GetOverallPercentageThicknessDamage",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x7E5);
  v6 = *(_BYTE *)(a2 + 7) < 2u;
  HIWORD(n0x900) = word_149D7FFD8;
  if ( v6 && (*(_BYTE *)(a2 + 6) & 1) != 0 )
  {
    _XMM6 = 0;
    v8 = *(_DWORD *)(*(_QWORD *)(a1 + 0x120) + 0x54LL);
    if ( v8 )
    {
      v9 = 0;
      v10 = (float)(unsigned int)(0xFF * v8);
      *(float *)&v9 = (float)*(int *)(a1 + 0x74) / v10;
      _XMM2 = v9;
      if ( *(float *)&v9 >= 0.0 )
        __asm { vminss  xmm6, xmm2, cs:Y }
    }
  }
  else
  {
    *(double *)&_XMM0 = sub_14084B4D0((_QWORD *)a1, 0, a2);
    _XMM6 = 0;
    if ( *(float *)&_XMM0 >= 0.0 )
      __asm { vminss  xmm6, xmm0, cs:Y }
  }
  v17 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return (__m128)_XMM6;
}

// --- End Function: sub_140855250 (0x140855250) ---

// --- Function: sub_1408560D0 (0x1408560D0) ---
__m128 __fastcall sub_1408560D0(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm6
  bool v5; // cf
  __int128 v6; // xmm6
  __int64 v7; // rax
  __int128 v8; // kr00_16
  int n0x900; // [rsp+38h] [rbp-69h] BYREF
  __int64 v11; // [rsp+3Ch] [rbp-65h]
  int v12; // [rsp+44h] [rbp-5Dh]
  unsigned __int64 v13; // [rsp+48h] [rbp-59h]
  unsigned __int64 v14; // [rsp+50h] [rbp-51h]
  __int64 v15; // [rsp+58h] [rbp-49h]
  __int64 v16; // [rsp+60h] [rbp-41h]
  __m256i v17; // [rsp+88h] [rbp-19h] BYREF
  unsigned int v18[4]; // [rsp+A8h] [rbp+7h] BYREF
  __int64 v19; // [rsp+B8h] [rbp+17h]
  char v20; // [rsp+C1h] [rbp+20h]
  __m256i v21; // [rsp+C8h] [rbp+27h] BYREF
  __int128 v22; // [rsp+E8h] [rbp+47h]

  v22 = v2;
  n0x900 = 0x900;
  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v13 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFD4,
    "CDamageMap::MT_GetSurfaceArea",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x7CC);
  v5 = *(_BYTE *)(a2 + 7) < 2u;
  HIWORD(n0x900) = word_149D7FFD4;
  if ( v5 && (*(_BYTE *)(a2 + 6) & 1) != 0 || sub_140574260(a2, a1 + 0xF0) )
  {
    v6 = *(unsigned int *)(a1 + 0xB8);
  }
  else
  {
    v6 = 0;
    if ( *(_QWORD *)(a1 + 0x120) )
    {
      sub_140573E20((__int64)v18, a2, 0x20 * ((unsigned __int64)*(unsigned __int8 *)(a2 + 6) >> 1));
      sub_140573E20((__int64)&v17, a2, 0x20 * ((unsigned __int64)*(unsigned __int8 *)(a2 + 6) >> 1));
      v7 = sub_140574E40(a2);
      sub_140573F30(&v17, &v21, v7);
      while ( v19 != v21.m256i_i64[2] || v20 != v21.m256i_i8[0x19] )
      {
        sub_140573EB0(v18, (__int64)&v17);
        if ( v17.m256i_i8[8] && (unsigned __int64)*(unsigned int *)(*(_QWORD *)(a1 + 0x120) + 0x4CLL) > v17.m256i_i64[0] )
        {
          if ( sub_140574720(a1 + 0xF0, v17.m256i_u64[0]) )
          {
            v8 = v6;
            *(float *)&v8 = *(float *)&v6
                          + *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x120) + 0x30LL) + 8 * v17.m256i_i64[0]);
            v6 = v8;
          }
        }
        sub_140573F60((__int64)v18, 1);
      }
    }
  }
  v14 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return (__m128)v6;
}

// --- End Function: sub_1408560D0 (0x1408560D0) ---

// --- Function: sub_1408562C0 (0x1408562C0) ---
char __fastcall sub_1408562C0(__int64 a1)
{
  int v2; // eax
  _QWORD *v3; // rax
  __int64 p_rw_lock_state; // rbx
  signed __int64 v5; // rdi
  _QWORD *v7; // [rsp+30h] [rbp-28h]

  v2 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149D8FAB8 + 0x808LL))(qword_149D8FAB8);
  if ( *(_QWORD *)(a1 + 0x18 * (v2 + 0x16LL)) != *(_QWORD *)(a1 + 0x18 * (v2 + 0x16LL) + 8) )
    return 1;
  v3 = (_QWORD *)(a1 + 0x148);
  p_rw_lock_state = a1 + 0x160;
  v7 = v3;
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state + 0x14);
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (v5 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(p_rw_lock_state, v5, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  if ( *v7 != v7[1] )
  {
    rw_lock_release_read_lock(p_rw_lock_state);
    return 1;
  }
  rw_lock_release_read_lock(p_rw_lock_state);
  return 0;
}

// --- End Function: sub_1408562C0 (0x1408562C0) ---

// --- Function: sub_140856FA0 (0x140856FA0) ---
void __fastcall sub_140856FA0(__int64 a1, __int64 a2)
{
  bool v2; // zf
  __int64 v5; // rdi
  bool v6; // si
  signed __int64 v7; // rdx
  bool v8; // si
  const char *p_true; // rdx
  char v10; // al
  char v11; // di
  const char *p_true_1; // r8
  const char *p_true_2; // rdx
  __int64 *v14; // r15
  signed __int32 v15; // ebp
  const char *v16; // rax
  void (__fastcall ***v17)(_QWORD); // rcx
  const void *v18; // rdi
  void (__fastcall ***v19)(_QWORD); // [rsp+30h] [rbp-288h] BYREF
  _QWORD *v20; // [rsp+38h] [rbp-280h]
  __int64 p_rw_lock_state; // [rsp+40h] [rbp-278h]
  int *v22; // [rsp+48h] [rbp-270h]
  int v23; // [rsp+50h] [rbp-268h] BYREF
  __int64 v24; // [rsp+60h] [rbp-258h] BYREF
  __int64 n0x1FF; // [rsp+68h] [rbp-250h]
  _BYTE *v26; // [rsp+70h] [rbp-248h]
  _BYTE v27[520]; // [rsp+78h] [rbp-240h] BYREF

  if ( a2 )
  {
    v2 = *(_QWORD *)(a2 + 0x128) == 0;
    v5 = a2 + 0x190;
    v20 = (_QWORD *)(a2 + 0x178);
    v22 = &v23;
    v6 = !v2;
    p_rw_lock_state = a2 + 0x190;
    v23 = 1;
    if ( *(_DWORD *)(a2 + 0x1A0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(v5 + 0x14);
    }
    else
    {
      v7 = _InterlockedIncrement64((volatile signed __int64 *)v5);
      if ( (v7 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(v5, v7, (const char *)&p_Src, (const char *)&p_Src, 1);
    }
    v8 = *v20 != v20[1] || v6;
    v2 = (*v22)-- == 1;
    if ( v2 )
      rw_lock_release_read_lock(p_rw_lock_state);
    if ( dword_149D7FE5C )
    {
      p_true = "false";
      if ( v8 )
        p_true = "true";
      LogTraceConditional("[Damage Maps Mgr] | has geometry to render %s", p_true);
    }
    if ( v8 )
    {
      v10 = sub_1408562C0(a2);
      v11 = v10;
      if ( dword_149D7FE5C )
      {
        p_true_1 = "false";
        if ( (*(_BYTE *)(a2 + 0x1DC) & 1) != 0 )
          p_true_1 = "true";
        p_true_2 = "false";
        if ( v10 )
          p_true_2 = "true";
        LogTraceConditional(
          "[Damage Maps Mgr] |\n"
          " has impacts to render? %s\n"
          " fresh snapshot? %s\n"
          " render every frame? %s\n"
          " forced creation? %s",
          p_true_2,
          p_true_1,
          "false",
          "false");
      }
      if ( v11 || (*(_BYTE *)(a2 + 0x1DC) & 1) != 0 )
      {
        v14 = *(__int64 **)(a1 + 0x10);
        _InterlockedIncrement((volatile signed __int32 *)(a2 + 0xBC));
        v15 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0x58), 1u);
        v27[0] = 0;
        v26 = v27;
        v24 = 0;
        n0x1FF = 0x1FF;
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a2 + 0x140)) )
        {
          v16 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a2 + 0x140) & 0xFFFFFFFFFFFFLL)
                                                                 + 0x70LL))(*(_QWORD *)(a2 + 0x140) & 0xFFFFFFFFFFFFLL);
          sub_1402A59F0((__int64)&v24, "$PBM_%s_%llx", v16, (unsigned int)(v15 + 1));
        }
        if ( !v24 )
          sub_1402A59F0((__int64)&v24, "PBM_%llx", (unsigned int)(v15 + 1));
        v17 = *(void (__fastcall ****)(_QWORD))(a2 + 0x128);
        v18 = v26;
        v19 = v17;
        if ( v17 )
          (**v17)(v17);
        sub_14084F100(v14, *(_DWORD *)(*(_QWORD *)(a2 + 0x120) + 0x48LL), &v19, v18);
        if ( v26 != v27 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
          sub_147715880(v26);
        }
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(a2 + 0xBC), 0xFFFFFFFF) <= 1 )
        {
          sub_14084A700(a2);
          sub_1402A6590(a2);
        }
        sub_14085D190(a2);
        sub_14085CA50(a2);
      }
    }
  }
}

// --- End Function: sub_140856FA0 (0x140856FA0) ---

// --- Function: sub_140857430 (0x140857430) ---
_BOOL8 __fastcall sub_140857430(__int64 a1)
{
  _DWORD *v2; // rdx
  _DWORD *v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rdi
  const ULONG_PTR *p_p_Src; // rsi
  int v7; // r15d
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rax
  unsigned int v13; // r8d
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rcx
  __int64 v16; // rcx
  unsigned int v17; // r12d
  int v18; // eax
  unsigned __int64 n0x200000; // rax
  __int16 *v20; // r14
  __int64 v21; // r15
  signed __int64 v22; // rdx
  signed __int64 v23; // rdx
  __int16 v24; // dx
  const char *p_true_28; // r14
  const char *p_true; // rax
  const char *p_true_10; // rcx
  const char *p_true_2; // rax
  const char *p_true_4; // rax
  const char *p_true_6; // rax
  const char *p_true_8; // rax
  bool v32; // zf
  signed __int64 v33; // rdx
  const char *p_true_12; // rax
  __int64 v35; // rcx
  __int64 v36; // rdx
  const char *p_true_14; // rax
  __int64 v38; // rax
  bool v39; // cl
  const char *p_true_16; // rax
  __int64 v41; // rcx
  __int64 v42; // rax
  __int64 v43; // rcx
  const char *p_true_18; // rax
  __int64 v45; // rcx
  const char *p_true_20; // rax
  __int64 v47; // rax
  const ULONG_PTR *p_p_Src_1; // rax
  __int64 v49; // rcx
  const char *p_true_22; // rax
  const ULONG_PTR *p_p_Src_3; // rax
  unsigned __int64 v52; // r9
  __int16 n0xFFF; // r11
  const char *p_true_24; // rax
  __int64 v55; // r10
  unsigned __int64 v56; // r9
  __int64 v57; // rax
  __int64 v58; // r10
  __int64 v59; // rdi
  bool v60; // al
  __int64 v61; // rcx
  unsigned __int64 v62; // r9
  bool v63; // cl
  __int64 v64; // r10
  unsigned __int64 v65; // r9
  __int64 v66; // rax
  __int64 v67; // r10
  __int64 v68; // rdi
  bool v69; // al
  const char *p_true_26; // rax
  int *ThreadLogContextSlot; // rax
  bool v72; // bl
  const char *v74; // [rsp+20h] [rbp-1F0h]
  const char *v75; // [rsp+28h] [rbp-1E8h]
  const char *v76; // [rsp+30h] [rbp-1E0h]
  const char *v77; // [rsp+38h] [rbp-1D8h]
  const char *v78; // [rsp+40h] [rbp-1D0h]
  const char *v79; // [rsp+48h] [rbp-1C8h]
  const char *v80; // [rsp+50h] [rbp-1C0h]
  const char *v81; // [rsp+58h] [rbp-1B8h]
  int v82; // [rsp+60h] [rbp-1B0h]
  int v83; // [rsp+68h] [rbp-1A8h]
  int v84; // [rsp+70h] [rbp-1A0h]
  int v85; // [rsp+78h] [rbp-198h]
  double v86; // [rsp+80h] [rbp-190h]
  int v87; // [rsp+88h] [rbp-188h]
  const char *v88; // [rsp+90h] [rbp-180h]
  int v89; // [rsp+98h] [rbp-178h]
  int v90; // [rsp+A0h] [rbp-170h]
  const char *v91; // [rsp+A8h] [rbp-168h]
  int v92; // [rsp+B0h] [rbp-160h]
  int v93; // [rsp+B8h] [rbp-158h]
  const char *v94; // [rsp+C0h] [rbp-150h]
  int v95; // [rsp+C8h] [rbp-148h]
  const char *v96; // [rsp+D0h] [rbp-140h]
  int v97; // [rsp+D8h] [rbp-138h]
  const char *v98; // [rsp+E0h] [rbp-130h]
  double v99; // [rsp+E8h] [rbp-128h]
  int v100; // [rsp+F0h] [rbp-120h]
  int v101; // [rsp+F8h] [rbp-118h]
  int v102; // [rsp+100h] [rbp-110h]
  int v103; // [rsp+108h] [rbp-108h]
  int v104; // [rsp+110h] [rbp-100h]
  const char *v105; // [rsp+118h] [rbp-F8h]
  int v106; // [rsp+120h] [rbp-F0h]
  int v107; // [rsp+128h] [rbp-E8h]
  const char *v108; // [rsp+130h] [rbp-E0h]
  const char *v109; // [rsp+138h] [rbp-D8h]
  const char *v110; // [rsp+140h] [rbp-D0h]
  const char *v111; // [rsp+148h] [rbp-C8h]
  const char *v112; // [rsp+150h] [rbp-C0h]
  int v113; // [rsp+158h] [rbp-B8h]
  unsigned int v114; // [rsp+190h] [rbp-80h] BYREF
  unsigned int v115; // [rsp+194h] [rbp-7Ch] BYREF
  int v116; // [rsp+198h] [rbp-78h] BYREF
  unsigned int v117; // [rsp+19Ch] [rbp-74h] BYREF
  int v118; // [rsp+1A0h] [rbp-70h]
  _DWORD v119[2]; // [rsp+1A8h] [rbp-68h] BYREF
  _DWORD v120[2]; // [rsp+1B0h] [rbp-60h] BYREF
  const char *p_false_1; // [rsp+1B8h] [rbp-58h] BYREF
  __int64 v122; // [rsp+1C0h] [rbp-50h] BYREF
  __int64 v123; // [rsp+1C8h] [rbp-48h] BYREF
  __int64 v124; // [rsp+1D0h] [rbp-40h] BYREF
  __int64 v125; // [rsp+1D8h] [rbp-38h]
  char v126; // [rsp+1E0h] [rbp-30h]
  const char *p_true_3; // [rsp+1E8h] [rbp-28h] BYREF
  const char *p_true_5; // [rsp+1F0h] [rbp-20h] BYREF
  const char *p_true_7; // [rsp+1F8h] [rbp-18h] BYREF
  const char *p_true_9; // [rsp+200h] [rbp-10h] BYREF
  const char *p_true_11; // [rsp+208h] [rbp-8h] BYREF
  __int64 v132; // [rsp+210h] [rbp+0h] BYREF
  const char *p_true_13; // [rsp+218h] [rbp+8h] BYREF
  __int64 v134; // [rsp+220h] [rbp+10h] BYREF
  const char *p_true_15; // [rsp+228h] [rbp+18h] BYREF
  const char *p_true_17; // [rsp+230h] [rbp+20h] BYREF
  __int64 v137; // [rsp+238h] [rbp+28h] BYREF
  const char *p_true_19; // [rsp+240h] [rbp+30h] BYREF
  const char *p_true_21; // [rsp+248h] [rbp+38h] BYREF
  const ULONG_PTR *p_p_Src_2; // [rsp+250h] [rbp+40h] BYREF
  const char *p_true_23; // [rsp+258h] [rbp+48h] BYREF
  const ULONG_PTR *p_p_Src_4; // [rsp+260h] [rbp+50h] BYREF
  const char *p_true_25; // [rsp+268h] [rbp+58h] BYREF
  const ULONG_PTR *p_p_Src_5; // [rsp+270h] [rbp+60h] BYREF
  const char *p_true_27; // [rsp+278h] [rbp+68h] BYREF
  const char *p_true_29; // [rsp+280h] [rbp+70h] BYREF
  const char *p_true_1; // [rsp+288h] [rbp+78h] BYREF
  _QWORD *v148; // [rsp+290h] [rbp+80h]
  __int64 p_rw_lock_state; // [rsp+298h] [rbp+88h]
  int *v150; // [rsp+2A0h] [rbp+90h]
  int v151; // [rsp+2A8h] [rbp+98h] BYREF
  _QWORD *v152; // [rsp+2B0h] [rbp+A0h]
  __int64 p_rw_lock_state_1; // [rsp+2B8h] [rbp+A8h]
  int *v154; // [rsp+2C0h] [rbp+B0h]
  int v155; // [rsp+2C8h] [rbp+B8h] BYREF
  int n0x900; // [rsp+2D0h] [rbp+C0h] BYREF
  __int64 v157; // [rsp+2D4h] [rbp+C4h]
  int v158; // [rsp+2DCh] [rbp+CCh]
  unsigned __int64 v159; // [rsp+2E0h] [rbp+D0h]
  unsigned __int64 v160; // [rsp+2E8h] [rbp+D8h]
  __int64 v161; // [rsp+2F0h] [rbp+E0h]
  __int64 v162; // [rsp+2F8h] [rbp+E8h]
  _QWORD v163[2]; // [rsp+320h] [rbp+110h] BYREF
  _QWORD v164[2]; // [rsp+330h] [rbp+120h] BYREF
  _OWORD v165[5]; // [rsp+340h] [rbp+130h] BYREF
  unsigned int v166; // [rsp+3A0h] [rbp+190h] BYREF
  unsigned int v167; // [rsp+3A8h] [rbp+198h] BYREF
  unsigned int v168; // [rsp+3B0h] [rbp+1A0h] BYREF
  float v169; // [rsp+3B8h] [rbp+1A8h] BYREF

  n0x900 = 0x900;
  v157 = 0;
  v158 = 0;
  v160 = 0;
  v161 = 0;
  v162 = 0;
  v159 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFEC,
    "CDamageMap::MT_ProcessDamageMap",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0x8CA);
  v2 = *(_DWORD **)(a1 + 0x48);
  v3 = *(_DWORD **)(a1 + 0x40);
  for ( HIWORD(n0x900) = word_149D7FFEC; v3 != v2; v3 += 4 )
  {
    *v3 = v3[1];
    v3[2] = v3[3];
  }
  *(_DWORD *)(a1 + 0x70) = *(_DWORD *)(a1 + 0x74);
  *(_DWORD *)(a1 + 0x78) = *(_DWORD *)(a1 + 0x7C);
  *(_QWORD *)(a1 + 0x60) = *(_QWORD *)(a1 + 0x58);
  v4 = *(_QWORD *)(a1 + 0x110);
  v124 = v4;
  v126 = 1;
  v5 = v4 + 0x48;
  v125 = v4 + 0x48;
  p_p_Src = &p_Src;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v4 + 0x58) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x5C);
  }
  else
  {
    v8 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v9 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
    if ( v9 )
      sub_1403E1120(v4 + 0x48, v9, v8, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v4 + 0x50) = v8;
    *(_DWORD *)(v4 + 0x58) = v7;
    v5 = v125;
  }
  v10 = *(_QWORD *)(v4 + 8);
  v11 = *(_QWORD *)(v4 + 0x10);
  if ( v10 == v11 )
  {
    v12 = *(_QWORD *)(a1 + 0x120);
    if ( v12 )
      v13 = *(_DWORD *)(v12 + 0x50);
    else
      v13 = 0;
    v14 = v13 * (unsigned __int64)v13;
    v15 = (v11 - v10) >> 2;
    if ( v14 <= v15 )
      *(_QWORD *)(v4 + 0x10) = v10 + 4 * v14;
    else
      sub_14084DC50(v4 + 8, v14 - v15);
  }
  v16 = *(_QWORD *)(a1 + 0x120);
  if ( v16 && *(_QWORD *)(v16 + 0x18) != *(_QWORD *)(v16 + 0x20) && *(_QWORD *)(v4 + 8) != *(_QWORD *)(v4 + 0x10) )
  {
    sub_140854BE0(a1);
    if ( (unsigned __int8)sub_140851510(a1, &v124) )
      *(_WORD *)(a1 + 0x1DC) |= 8u;
    else
      *(_WORD *)(a1 + 0x1DC) &= ~8u;
  }
  v17 = 0xFFFFFFFF;
  if ( v5 )
  {
    v18 = *(_DWORD *)(v5 + 0x14);
    if ( v18 )
    {
      *(_DWORD *)(v5 + 0x14) = v18 - 1;
    }
    else
    {
      *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v125 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v125, n0x200000);
    }
  }
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x140))
    && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL)
    && n4_8 == 4 )
  {
    sub_140853A50(a1);
  }
  v20 = (__int16 *)(a1 + 0x1DC);
  *(_DWORD *)(a1 + 0x1C4) = dword_149C8E13C;
  if ( (*(_BYTE *)(a1 + 0x1DC) & 8) != 0 )
  {
    *(_DWORD *)(a1 + 0x1C8) = dword_149C8E13C;
    goto LABEL_134;
  }
  if ( !dword_149D7FE5C )
    goto LABEL_134;
  v21 = *(_QWORD *)(a1 + 0x110);
  if ( *(_DWORD *)(v21 + 0x58) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v21 + 0x5C);
  }
  else
  {
    v22 = _InterlockedIncrement64((volatile signed __int64 *)(v21 + 0x48));
    if ( (v22 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v21 + 0x48, v22, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  v155 = 1;
  v152 = (_QWORD *)(a1 + 0x178);
  p_rw_lock_state_1 = a1 + 0x190;
  v154 = &v155;
  if ( *(_DWORD *)(a1 + 0x1A0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x1A4);
  }
  else
  {
    v23 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x190));
    if ( (v23 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0x190, v23, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  v119[0] = 0xCA;
  v163[0] = v119;
  v119[1] = 0xBC;
  v163[1] = v120;
  v118 = invokeGlobalCallbackAndMaskStatusBits(
           3,
           (__int64)v163,
           (__int64)"Damage Map failed Process",
           "Failed to process the damage map this frame. Current Damage Map state:\n"
           "Manager:\n"
           " valid = %s\n"
           "Entity:\n"
           " valid = %s\n"
           " Name = %s\n"
           "StatObj:\n"
           " valid = %s\n"
           " Name = %s\n"
           "CharInst:\n"
           " valid = %s\n"
           " Name = %s\n"
           "SharedPbmTex:\n"
           " valid = %s\n"
           " Res  = %lu\n"
           " BuffSize = %lu\n"
           " geom hash = %lu\n"
           " totalPixels = %lu\n"
           " surfaceArea = %f\n"
           " last Access Frame = %lu\n"
           "SharedDmgTex:\n"
           " valid = %s\n"
           " Dmg Buff Size = %lu\n"
           " gpu Dmg Buff Size = %lu\n"
           " free bones = %s\n"
           " last gpu transfer = %lu\n"
           " last impact Process = %lu\n"
           "LookUpTree:\n"
           " valid = %s\n"
           " Total Leaf Nodes = %lu\n"
           "Skinning:\n"
           " empty = %s\n"
           " size = %lu\n"
           "Snapshot tree:\n"
           " empty = %s\n"
           "Data:\n"
           " surfArea = %f\n"
           " Ref Count = %d\n"
           " Impact Count = %lu\n"
           " LastUsed = %lu\n"
           " LastSuccess = %lu\n"
           " LastProcessed = %lu\n"
           " RenderData Empty = %s\n"
           " skinningdataBoneCount = %lu\n"
           " deletionCount = %lu\n"
           " bFreshSnapshot = %s\n"
           " bRebuildAABBTree = %s\n"
           " bHasInitialisedQuadTree = %s\n"
           " bHasInitializedDamageTracking = %s\n"
           " bRequestSkinningTreerebuild = %s\n"
           " merge Hash = %lu",
           v74,
           v75,
           v76,
           v77,
           v78,
           v79,
           v80,
           v81,
           v82,
           v83,
           v84,
           v85,
           v86,
           v87,
           v88,
           v89,
           v90,
           v91,
           v92,
           v93,
           v94,
           v95,
           v96,
           v97,
           v98,
           v99,
           v100,
           v101,
           v102,
           v103,
           v104,
           v105,
           v106,
           v107,
           v108,
           v109,
           v110,
           v111,
           v112,
           v113);
  if ( (v118 & 0xFFFFF) != 0 )
  {
    v24 = *v20;
    p_true_28 = "false";
    p_true = "false";
    p_true_10 = "false";
    if ( (v24 & 0x40) != 0 )
      p_true = "true";
    p_true_1 = p_true;
    p_true_2 = "false";
    if ( (v24 & 0x20) != 0 )
      p_true_2 = "true";
    p_true_3 = p_true_2;
    p_true_4 = "false";
    if ( (v24 & 0x10) != 0 )
      p_true_4 = "true";
    p_true_5 = p_true_4;
    p_true_6 = "false";
    if ( (v24 & 2) != 0 )
      p_true_6 = "true";
    p_true_7 = p_true_6;
    p_true_8 = "false";
    if ( (v24 & 1) != 0 )
      p_true_8 = "true";
    p_true_9 = p_true_8;
    v32 = *v152 == v152[1];
    v148 = (_QWORD *)(a1 + 0x148);
    p_rw_lock_state = a1 + 0x160;
    if ( v32 )
      p_true_10 = "true";
    v150 = &v151;
    p_true_11 = p_true_10;
    v151 = 1;
    if ( *(_DWORD *)(a1 + 0x170) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0x174);
    }
    else
    {
      v33 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x160));
      if ( (v33 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(a1 + 0x160, v33, (const char *)&p_Src, (const char *)&p_Src, 1);
    }
    p_true_12 = "false";
    v35 = *(_QWORD *)(a1 + 0x1A8);
    if ( *(_QWORD *)(a1 + 0x20) == *(_QWORD *)(a1 + 0x28) )
      p_true_12 = "true";
    v132 = (v148[1] - *v148) / 0xF8LL;
    v36 = *(_QWORD *)(a1 + 0x1B0);
    p_true_13 = p_true_12;
    v134 = (v36 - v35) >> 5;
    p_true_14 = "false";
    if ( v35 == v36 )
      p_true_14 = "true";
    p_true_15 = p_true_14;
    v116 = *(_DWORD *)(a1 + 0xE0) - *(_DWORD *)(a1 + 0xE4);
    v38 = *(_QWORD *)(a1 + 0xC8);
    v39 = v38 != *(_QWORD *)(a1 + 0xD0) && *(_BYTE *)(v38 + 0x48);
    v32 = !v39;
    p_true_16 = "false";
    v41 = *(_QWORD *)(a1 + 0x110);
    if ( !v32 )
      p_true_16 = "true";
    p_true_17 = p_true_16;
    if ( v41 )
    {
      v166 = *(_DWORD *)(v21 + 0x44);
      v167 = *(_DWORD *)(v21 + 0x40);
      if ( *(_BYTE *)(v21 + 0x3F) < 2u && (*(_BYTE *)(v21 + 0x3E) & 1) != 0 )
      {
        p_false_1 = "true";
        goto LABEL_76;
      }
    }
    else
    {
      v166 = 0xFFFFFFFF;
      v167 = 0xFFFFFFFF;
    }
    p_false_1 = "false";
    if ( !v41 )
    {
      v122 = 0xFFFFFFFFFFFFFFFFuLL;
      v42 = 0xFFFFFFFFFFFFFFFFuLL;
      goto LABEL_78;
    }
LABEL_76:
    v122 = (__int64)(*(_QWORD *)(v21 + 0x28) - *(_QWORD *)(v21 + 0x20)) >> 2;
    v42 = (__int64)(*(_QWORD *)(v21 + 0x10) - *(_QWORD *)(v21 + 8)) >> 2;
LABEL_78:
    v32 = v41 == 0;
    v137 = v42;
    v43 = *(_QWORD *)(a1 + 0x120);
    p_true_18 = "false";
    if ( !v32 )
      p_true_18 = "true";
    p_true_19 = p_true_18;
    if ( v43 )
    {
      v168 = *(_DWORD *)(v43 + 0x5C);
      v169 = *(float *)(v43 + 0x60);
      v114 = *(_DWORD *)(v43 + 0x54);
      v115 = *(_DWORD *)(v43 + 0x48);
      v123 = (__int64)(*(_QWORD *)(v43 + 0x20) - *(_QWORD *)(v43 + 0x18)) >> 3;
      v17 = *(_DWORD *)(v43 + 0x50);
    }
    else
    {
      v169 = -1.0;
      v168 = 0xFFFFFFFF;
      v114 = 0xFFFFFFFF;
      v115 = 0xFFFFFFFF;
      v123 = 0xFFFFFFFFFFFFFFFFuLL;
    }
    v32 = v43 == 0;
    v117 = v17;
    v45 = *(_QWORD *)(a1 + 0x130);
    p_true_20 = "false";
    if ( !v32 )
      p_true_20 = "true";
    p_true_21 = p_true_20;
    if ( v45 )
    {
      v47 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 0x2E8LL))(v45);
      p_p_Src_1 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v47 + 0x348LL))(v47);
    }
    else
    {
      p_p_Src_1 = &p_Src;
    }
    v32 = *(_QWORD *)(a1 + 0x130) == 0;
    v49 = *(_QWORD *)(a1 + 0x128);
    p_p_Src_2 = p_p_Src_1;
    p_true_22 = "false";
    if ( !v32 )
      p_true_22 = "true";
    p_true_23 = p_true_22;
    if ( v49 )
      p_p_Src_3 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v49 + 0x358LL))(v49);
    else
      p_p_Src_3 = &p_Src;
    v32 = *(_QWORD *)(a1 + 0x128) == 0;
    v52 = *(_QWORD *)(a1 + 0x140);
    n0xFFF = 0xFFF;
    p_p_Src_4 = p_p_Src_3;
    p_true_24 = "false";
    if ( !v32 )
      p_true_24 = "true";
    p_true_25 = p_true_24;
    if ( v52 )
    {
      v55 = v52 & 0xFFFFFFFFFFFFLL;
      v56 = HIWORD(v52);
      if ( (v56 & 0xF000) != 0 )
      {
        v57 = map_flag_to_mask(0x2000u);
        v59 = v58 & ~(v57 - 1);
      }
      else
      {
        v59 = v55 - 6;
      }
      if ( *(_WORD *)(v59 + 2) == ((unsigned __int16)n0xFFF & (unsigned __int16)v56) )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v60 = is_thread_privileged_or_bypass_mode()) )
          v60 = 1;
        if ( *(_WORD *)(v59 + 4) == 2 && v60 || sub_140395410((_QWORD *)(a1 + 0x140)) )
        {
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x140)) )
            v61 = *(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL;
          else
            v61 = 0;
          p_p_Src = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v61 + 0x70LL))(v61);
        }
      }
    }
    v62 = *(_QWORD *)(a1 + 0x140);
    p_p_Src_5 = p_p_Src;
    if ( v62 )
    {
      v64 = v62 & 0xFFFFFFFFFFFFLL;
      v65 = HIWORD(v62);
      if ( (v65 & 0xF000) != 0 )
      {
        v66 = map_flag_to_mask(0x2000u);
        v68 = v67 & ~(v66 - 1);
      }
      else
      {
        v68 = v64 - 6;
      }
      if ( *(_WORD *)(v68 + 2) == (v65 & 0xFFF) )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v69 = is_thread_privileged_or_bypass_mode()) )
          v69 = 1;
        v63 = *(_WORD *)(v68 + 4) == 2 && v69 || sub_140395410((_QWORD *)(a1 + 0x140));
      }
      else
      {
        v63 = 0;
      }
    }
    else
    {
      v63 = 0;
    }
    p_true_26 = "false";
    if ( v63 )
      p_true_26 = "true";
    p_true_27 = p_true_26;
    if ( (*(__int64 (**)(void))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))() )
      p_true_28 = "true";
    p_true_29 = p_true_28;
    ThreadLogContextSlot = getThreadLogContextSlot();
    v120[0] = 0xCA;
    v164[0] = v120;
    v164[1] = &p_false_1;
    v165[0] = 0;
    v120[1] = 0xBC;
    sub_1408456C0(
      3,
      (__int64)v164,
      "Damage Map failed Process",
      (__int64)"Failed to process the damage map this frame. Current Damage Map state:\n"
               "Manager:\n"
               " valid = %s\n"
               "Entity:\n"
               " valid = %s\n"
               " Name = %s\n"
               "StatObj:\n"
               " valid = %s\n"
               " Name = %s\n"
               "CharInst:\n"
               " valid = %s\n"
               " Name = %s\n"
               "SharedPbmTex:\n"
               " valid = %s\n"
               " Res  = %lu\n"
               " BuffSize = %lu\n"
               " geom hash = %lu\n"
               " totalPixels = %lu\n"
               " surfaceArea = %f\n"
               " last Access Frame = %lu\n"
               "SharedDmgTex:\n"
               " valid = %s\n"
               " Dmg Buff Size = %lu\n"
               " gpu Dmg Buff Size = %lu\n"
               " free bones = %s\n"
               " last gpu transfer = %lu\n"
               " last impact Process = %lu\n"
               "LookUpTree:\n"
               " valid = %s\n"
               " Total Leaf Nodes = %lu\n"
               "Skinning:\n"
               " empty = %s\n"
               " size = %lu\n"
               "Snapshot tree:\n"
               " empty = %s\n"
               "Data:\n"
               " surfArea = %f\n"
               " Ref Count = %d\n"
               " Impact Count = %lu\n"
               " LastUsed = %lu\n"
               " LastSuccess = %lu\n"
               " LastProcessed = %lu\n"
               " RenderData Empty = %s\n"
               " skinningdataBoneCount = %lu\n"
               " deletionCount = %lu\n"
               " bFreshSnapshot = %s\n"
               " bRebuildAABBTree = %s\n"
               " bHasInitialisedQuadTree = %s\n"
               " bHasInitializedDamageTracking = %s\n"
               " bRequestSkinningTreerebuild = %s\n"
               " merge Hash = %lu",
      1,
      v118,
      v165,
      0,
      (__int64)ThreadLogContextSlot,
      &p_true_29,
      (__int64)&p_true_27,
      (__int64)&p_p_Src_5,
      (__int64)&p_true_25,
      (__int64)&p_p_Src_4,
      (__int64)&p_true_23,
      (__int64)&p_p_Src_2,
      (__int64)&p_true_21,
      (__int64)&v117,
      (__int64)&v123,
      (__int64)&v115,
      (__int64)&v114,
      (__int64)&v169,
      (__int64)&v168,
      (__int64)&p_true_19,
      (__int64)&v137,
      (__int64)&v122,
      (__int64)&p_false_1,
      (__int64)&v167,
      (__int64)&v166,
      (__int64)&p_true_17,
      (__int64)&v116,
      (__int64)&p_true_15,
      (__int64)&v134,
      (__int64)&p_true_13,
      a1 + 0xB8,
      a1 + 0xBC,
      (__int64)&v132,
      a1 + 0x1CC,
      a1 + 0x1C8,
      a1 + 0x1C4,
      (__int64)&p_true_11,
      a1 + 0x1C0,
      a1 + 0x1D0,
      (__int64)&p_true_9,
      (__int64)&p_true_7,
      (__int64)&p_true_5,
      (__int64)&p_true_3,
      (__int64)&p_true_1,
      a1 + 0x1D4);
    v32 = (*v150)-- == 1;
    if ( v32 )
      rw_lock_release_read_lock(p_rw_lock_state);
  }
  v32 = (*v154)-- == 1;
  if ( v32 )
    rw_lock_release_read_lock(p_rw_lock_state_1);
  rw_lock_release_read_lock(v21 + 0x48);
  v20 = (__int16 *)(a1 + 0x1DC);
LABEL_134:
  v72 = (*v20 & 8) == 0 || (*v20 & 2) != 0;
  v160 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return v72;
}

// --- End Function: sub_140857430 (0x140857430) ---

// --- Function: sub_140859F10 (0x140859F10) ---
__int64 __fastcall sub_140859F10(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rcx
  __int16 v7; // ax
  int v8; // eax
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rbp
  volatile signed __int64 *v12; // rbx
  int v13; // esi
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  int v16; // eax
  unsigned __int64 n0x200000; // rax
  _QWORD v19[3]; // [rsp+30h] [rbp-A8h] BYREF
  int v20; // [rsp+48h] [rbp-90h]
  __int64 v21; // [rsp+50h] [rbp-88h]
  int n0x900; // [rsp+60h] [rbp-78h] BYREF
  __int64 v23; // [rsp+64h] [rbp-74h]
  int v24; // [rsp+6Ch] [rbp-6Ch]
  unsigned __int64 v25; // [rsp+70h] [rbp-68h]
  unsigned __int64 v26; // [rsp+78h] [rbp-60h]
  __int64 v27; // [rsp+80h] [rbp-58h]
  __int64 v28; // [rsp+88h] [rbp-50h]

  n0x900 = 0x900;
  v23 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v25 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D80000,
    "CDamageMap::MT_RebuildDamageMapFromSnapshot_internal",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xC6C);
  v6 = *(_QWORD *)(a1 + 0x120);
  v7 = word_149D80000;
  *(_WORD *)(a1 + 0x1DC) |= 0x40u;
  HIWORD(n0x900) = v7;
  v19[0] = a2;
  v19[1] = v6 + 0x18;
  v19[2] = a1 + 0xF0;
  v8 = *(_DWORD *)(v6 + 0x50);
  v9 = *(_QWORD *)(a1 + 0x140);
  v20 = v8;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v9 & 0xFFFFFFFFFFFFLL);
  v11 = *(_QWORD *)(a1 + 0x110);
  v21 = v10;
  v12 = (volatile signed __int64 *)(v11 + 0x48);
  v13 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v11 + 0x58) == v13 )
  {
    ++*(_DWORD *)(v11 + 0x5C);
  }
  else
  {
    v14 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v15 = _InterlockedCompareExchange64(v12, 0x200000, 0);
    if ( v15 )
      sub_1403E1120(v11 + 0x48, v15, v14, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v11 + 0x50) = v14;
    *(_DWORD *)(v11 + 0x58) = v13;
  }
  sub_14085EDC0(v19, v11 + 8, a1 + 0x70, a3);
  *(_WORD *)(a1 + 0x1DC) |= 0x80u;
  if ( v11 != 0xFFFFFFFFFFFFFFB8uLL )
  {
    v16 = *(_DWORD *)(v11 + 0x5C);
    if ( v16 )
    {
      *(_DWORD *)(v11 + 0x5C) = v16 - 1;
    }
    else
    {
      *(_DWORD *)(v11 + 0x58) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(v12, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v11 + 0x50) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v11 + 0x48, n0x200000);
    }
  }
  sub_14085D190(a1);
  sub_14085CA50(a1);
  sub_140854BE0(a1);
  *(_WORD *)(a1 + 0x1DC) |= 1u;
  *(_BYTE *)(a1 + 0x2D8) = 1;
  *(_BYTE *)(*((unsigned int *)qword_149D8FAB8 + 0xA9) + a1 + 0x2D4) = 0;
  v26 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_140859F10 (0x140859F10) ---

// --- Function: sub_14085AB20 (0x14085AB20) ---
float *__fastcall sub_14085AB20(float *a1, __int64 a2, __int64 a3, __int64 a4, char a5, unsigned __int8 a6)
{
  int v7; // ecx
  int v8; // eax
  __int64 v9; // r8
  float v10; // xmm3_4
  float *result; // rax
  float v12; // xmm0_4
  int v13; // ecx

  if ( a5 )
  {
    v7 = a3 - 1;
    v8 = HIDWORD(a4);
    if ( (int)a4 < (int)a3 - 1 )
      v7 = a4;
    if ( SHIDWORD(a4) >= HIDWORD(a3) - 1 )
      v8 = HIDWORD(a3) - 1;
    v9 = ((unsigned int)a6 + 3) * (v7 + v8 * (_DWORD)a3);
  }
  else
  {
    v9 = 0;
  }
  if ( a6 )
    v10 = (float)*(unsigned __int8 *)((unsigned int)(v9 + 3) + a2) * 0.0039215689;
  else
    v10 = 0.5;
  result = a1;
  v12 = (float)*(unsigned __int8 *)((unsigned int)(v9 + 1) + a2);
  v13 = *(unsigned __int8 *)((unsigned int)(v9 + 2) + a2);
  *a1 = (float)*(unsigned __int8 *)(v9 + a2) * 0.0039215689;
  a1[1] = v12 * 0.0039215689;
  a1[2] = (float)v13 * 0.0039215689;
  a1[3] = v10;
  return result;
}

// --- End Function: sub_14085AB20 (0x14085AB20) ---

// --- Function: sub_14085AC00 (0x14085AC00) ---
__int64 __fastcall sub_14085AC00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, unsigned __int8 a6)
{
  int v8; // ecx
  int v9; // eax
  __int64 v10; // r8
  __int64 v11; // rsi
  __int64 v12; // r10
  int v13; // eax
  float v14; // r9d
  float v15; // xmm3_4
  int v16; // eax
  float v17; // edx
  int v18; // eax
  unsigned int v19; // r9d
  float v20; // ecx
  unsigned int v21; // r10d
  int v22; // ecx
  int v23; // eax
  float v24; // edx
  __int64 result; // rax

  if ( a5 )
  {
    v8 = a3 - 1;
    v9 = HIDWORD(a4);
    if ( (int)a4 < (int)a3 - 1 )
      v8 = a4;
    if ( SHIDWORD(a4) >= HIDWORD(a3) - 1 )
      v9 = HIDWORD(a3) - 1;
    v10 = ((unsigned int)a6 + 3) * (v8 + v9 * (_DWORD)a3);
  }
  else
  {
    v10 = 0;
  }
  v11 = (unsigned int)(v10 + 1);
  v12 = (unsigned int)(v10 + 2);
  if ( a6 )
  {
    v13 = (*(_WORD *)(a2 + 2LL * (unsigned int)(v10 + 3)) & 0x7FFF) << 0xD;
    LODWORD(v14) = v13 + 0x38000000;
    if ( (v13 & 0xF800000) == 0xF800000 )
    {
      LODWORD(v14) = v13 + 0x70000000;
    }
    else if ( (v13 & 0xF800000) == 0 )
    {
      v14 = COERCE_FLOAT(v13 + 0x38800000) + -0.000061035156;
    }
    LODWORD(v15) = LODWORD(v14) | (*(unsigned __int16 *)(a2 + 2LL * (unsigned int)(v10 + 3)) << 0x10) & 0x80000000;
  }
  else
  {
    v15 = 0.5;
  }
  v16 = (*(_WORD *)(a2 + 2 * v12) & 0x7FFF) << 0xD;
  LODWORD(v17) = v16 + 0x38000000;
  if ( (v16 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v17) = v16 + 0x70000000;
  }
  else if ( (v16 & 0xF800000) == 0 )
  {
    v17 = COERCE_FLOAT(v16 + 0x38800000) + -0.000061035156;
  }
  v18 = (*(_WORD *)(a2 + 2 * v11) & 0x7FFF) << 0xD;
  v19 = LODWORD(v17) | (*(unsigned __int16 *)(a2 + 2 * v12) << 0x10) & 0x80000000;
  LODWORD(v20) = v18 + 0x38000000;
  if ( (v18 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v20) = v18 + 0x70000000;
  }
  else if ( (v18 & 0xF800000) == 0 )
  {
    v20 = COERCE_FLOAT(v18 + 0x38800000) + -0.000061035156;
  }
  v21 = LODWORD(v20) | (*(unsigned __int16 *)(a2 + 2 * v11) << 0x10) & 0x80000000;
  v22 = *(unsigned __int16 *)(a2 + 2 * v10);
  v23 = (*(_WORD *)(a2 + 2 * v10) & 0x7FFF) << 0xD;
  LODWORD(v24) = v23 + 0x38000000;
  if ( (v23 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v24) = v23 + 0x70000000;
  }
  else if ( (v23 & 0xF800000) == 0 )
  {
    v24 = COERCE_FLOAT(v23 + 0x38800000) + -0.000061035156;
  }
  result = a1;
  *(_DWORD *)(a1 + 4) = v21;
  *(_DWORD *)(a1 + 8) = v19;
  *(_DWORD *)a1 = LODWORD(v24) | (v22 << 0x10) & 0x80000000;
  *(float *)(a1 + 0xC) = v15;
  return result;
}

// --- End Function: sub_14085AC00 (0x14085AC00) ---

// --- Function: sub_14085ADE0 (0x14085ADE0) ---
float *__fastcall sub_14085ADE0(float *a1, __int64 *a2, __int64 a3, unsigned int n2)
{
  __int64 v5; // rbx
  int v8; // r12d
  __int64 v9; // r15
  char v10; // bp
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rdi
  int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // r8
  __int64 v17; // rax
  float v18; // xmm0_4
  float v19; // kr00_4
  float v20; // xmm0_4
  float v21; // kr00_4
  char v22; // zf
  _OWORD *v23; // rax
  char v24; // zf
  char v25; // zf
  float v27[4]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v28; // [rsp+80h] [rbp+8h] BYREF
  __int64 v29; // [rsp+88h] [rbp+10h]
  __int64 v30; // [rsp+90h] [rbp+18h]

  v30 = a3;
  *a1 = 0.5;
  a1[1] = 0.5;
  v5 = a3;
  a1[2] = 0.5;
  a1[3] = 0.5;
  if ( !a2 )
    return a1;
  (*(void (__fastcall **)(__int64 *))(*a2 + 0xF8))(a2);
  v8 = (*(unsigned __int8 (__fastcall **)(__int64 *))(*a2 + 0x268))(a2);
  v28 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, float *))(*a2 + 0xE0))(a2, v27);
  v9 = 0;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E020 + 0x1C8LL))(qword_149C8E020);
  v11 = *a2;
  if ( v10 )
    v12 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD, _QWORD, unsigned int, _DWORD))(v11 + 0x2A8))(
            a2,
            (unsigned int)v5,
            HIDWORD(v30),
            0,
            n2,
            0);
  else
    v12 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(v11 + 0x2A0))(a2, 0);
  v13 = v12;
  switch ( v8 )
  {
    case 1:
      v25 = v10 == 0;
      if ( !v10 )
      {
        v13 = (unsigned int)sub_140850EF0((int *)&v28, n2, 3) + v12;
        v25 = 1;
      }
      v23 = sub_14085AB20(v27, v13, v28, v5, v25, 0);
      goto LABEL_22;
    case 2:
    case 3:
    case 0x36:
      v24 = v10 == 0;
      if ( !v10 )
      {
        v13 = (unsigned int)sub_140850EF0((int *)&v28, n2, 4) + v12;
        v24 = 1;
      }
      v23 = sub_14085AB20(v27, v13, v28, v5, v24, 1u);
      goto LABEL_22;
    case 0xF:
      v22 = v10 == 0;
      if ( !v10 )
      {
        v13 = (unsigned int)sub_140850EF0((int *)&v28, n2, 8) + v12;
        v22 = 1;
      }
      v23 = (_OWORD *)sub_14085AC00((__int64)v27, v13, v28, v5, v22, 1u);
LABEL_22:
      *(_OWORD *)a1 = *v23;
      break;
    case 0x10:
      if ( !v10 )
      {
        v13 = (unsigned int)sub_140850EF0((int *)&v28, n2, 0x10) + v12;
        v29 = v5;
        if ( (int)v5 >= (int)v28 - 1 )
          LODWORD(v5) = v28 - 1;
        v14 = HIDWORD(v29);
        if ( SHIDWORD(v29) >= HIDWORD(v28) - 1 )
          v14 = HIDWORD(v28) - 1;
        v9 = (unsigned int)(4 * (v5 + v14 * v28));
      }
      v15 = *(unsigned int *)(v13 + 4LL * (unsigned int)(v9 + 1));
      v16 = *(unsigned int *)(v13 + 4LL * (unsigned int)(v9 + 2));
      v17 = *(unsigned int *)(v13 + 4LL * (unsigned int)(v9 + 3));
      v18 = (float)*(unsigned int *)(v13 + 4 * v9);
      *a1 = v18;
      v19 = (float)v15;
      a1[1] = v19;
      v20 = (float)v16;
      v21 = (float)v17;
      a1[2] = v20;
      a1[3] = v21;
      break;
    default:
      return a1;
  }
  return a1;
}

// --- End Function: sub_14085ADE0 (0x14085ADE0) ---

// --- Function: sub_14085CA50 (0x14085CA50) ---
__int64 __fastcall sub_14085CA50(__int64 a1)
{
  unsigned int n4_1; // esi
  __int64 v3; // rbx
  __int64 v4; // r13
  volatile signed __int64 *p_rw_lock_state; // rdi
  __int64 v6; // r8
  signed __int64 v7; // rdx
  char *v8; // rcx
  __int64 v9; // rax
  __int64 n4; // r12
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // rdi
  char *v13; // rsi
  char *v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned int v16; // eax
  __int64 v17; // rdi
  __int64 v18; // r9
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // r11
  int v22; // r10d
  int v23; // eax
  float v24; // r9d
  float v25; // xmm0_4
  __int64 v26; // rax
  int v27; // ecx
  __int64 v28; // rax
  __int64 v29; // rcx
  int v30; // eax
  float v31; // r9d
  float v32; // xmm0_4
  __int64 v33; // rax
  int v34; // ecx
  __int64 v35; // rax
  int v36; // r9d
  int v37; // eax
  float v38; // edx
  float v39; // xmm0_4
  __int64 v40; // rax
  int v41; // ecx
  __int64 v42; // rcx
  int v43; // eax
  float v44; // edx
  float v45; // xmm0_4
  __int64 v46; // rax
  int v47; // ecx
  __int64 v48; // r10
  __int64 v49; // r11
  __int64 v50; // rcx
  int v51; // eax
  float v52; // edx
  float v53; // xmm0_4
  __int64 v54; // rax
  int v55; // ecx
  unsigned __int64 v56; // rbx
  __int64 v57; // rsi
  __int64 v58; // rdi
  __int64 v59; // rcx
  int v60; // edx
  int v61; // rax^4
  __int64 v62; // rcx
  __int64 v63; // rax
  void *Src[2]; // [rsp+30h] [rbp-69h] BYREF
  char *v66; // [rsp+40h] [rbp-59h]
  __int64 v67; // [rsp+48h] [rbp-51h]
  __int64 v68; // [rsp+58h] [rbp-41h] BYREF
  int v69; // [rsp+60h] [rbp-39h]
  int v70; // [rsp+64h] [rbp-35h]
  int n0x900; // [rsp+70h] [rbp-29h] BYREF
  __int64 v72; // [rsp+74h] [rbp-25h]
  int v73; // [rsp+7Ch] [rbp-1Dh]
  unsigned __int64 v74; // [rsp+80h] [rbp-19h]
  unsigned __int64 v75; // [rsp+88h] [rbp-11h]
  __int64 v76; // [rsp+90h] [rbp-9h]
  __int64 v77; // [rsp+98h] [rbp-1h]
  unsigned int v78; // [rsp+100h] [rbp+67h]

  n4_1 = 0;
  n0x900 = 0x900;
  v72 = 0;
  v73 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v74 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D80008,
    "CDamageMap::MT_UpdateSnapshotDamageTracking",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xCF2);
  v3 = *(_QWORD *)(a1 + 0x120);
  HIWORD(n0x900) = word_149D80008;
  if ( (*(_BYTE *)(a1 + 0x1DC) & 0x20) == 0 && *(_QWORD *)(v3 + 0x18) != *(_QWORD *)(v3 + 0x20) )
  {
    v4 = *(_QWORD *)(a1 + 0x110);
    p_rw_lock_state = (volatile signed __int64 *)(v4 + 0x48);
    if ( *(_DWORD *)(v4 + 0x58) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(v4 + 0x5C);
    }
    else
    {
      v7 = _InterlockedIncrement64(p_rw_lock_state);
      if ( (v7 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(v4 + 0x48, v7, (const char *)&p_Src, (const char *)&p_Src, 1);
    }
    if ( *(_QWORD *)(v4 + 8) == *(_QWORD *)(v4 + 0x10) )
      goto LABEL_86;
    v8 = 0;
    v9 = *(_QWORD *)(a1 + 0x120);
    n4 = (__int64)(*(_QWORD *)(v3 + 0x20) - *(_QWORD *)(v3 + 0x18)) >> 3;
    v11 = *(unsigned int *)(v9 + 0x4C);
    v12 = (__int64)(*(_QWORD *)(a1 + 0x48) - *(_QWORD *)(a1 + 0x40)) >> 4;
    v78 = *(_DWORD *)(v9 + 0x4C);
    v66 = 0;
    *(_OWORD *)Src = 0;
    if ( v12 )
    {
      if ( v12 > 0x1555555555555555LL )
        unknown_libname_38();
      v13 = (char *)sub_140394E70((__int64)Src, 0xC * v12);
      v14 = v13;
      v15 = v12;
      do
      {
        *(_QWORD *)v14 = 0;
        *((_DWORD *)v14 + 2) = 0;
        v14 += 0xC;
        --v15;
      }
      while ( v15 );
      memmove(v13, Src[0], (char *)Src[1] - (char *)Src[0]);
      if ( Src[0] )
        sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], 0xC * ((v66 - (char *)Src[0]) / 0xC));
      Src[0] = v13;
      v8 = &v13[0xC * v12];
      Src[1] = v8;
      v11 = v78;
      n4_1 = 0;
      v66 = v8;
    }
    if ( Src[0] == v8 )
    {
LABEL_83:
      if ( Src[0] )
      {
        sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], 0xC * ((v66 - (char *)Src[0]) / 0xC));
        *(_OWORD *)Src = 0;
        v66 = 0;
      }
      p_rw_lock_state = (volatile signed __int64 *)(v4 + 0x48);
LABEL_86:
      rw_lock_release_read_lock((__int64)p_rw_lock_state);
      goto LABEL_87;
    }
    if ( (unsigned int)n4 < 4 )
    {
      if ( !(_DWORD)n4 )
      {
LABEL_71:
        v56 = 0;
        if ( v11 )
        {
          v57 = 0;
          v58 = 0;
          do
          {
            if ( *((_BYTE *)Src[0] + v57 + 8) )
            {
              v59 = *(_QWORD *)(a1 + 0x40);
              v67 = *(_QWORD *)((char *)Src[0] + v57);
              v60 = v67;
              v61 = HIDWORD(v67);
              *(_DWORD *)(v58 + v59 + 4) += v67;
              *(_DWORD *)(v58 + v59 + 0xC) += v61;
              v62 = *(_QWORD *)(a1 + 0x60);
              v63 = *(_QWORD *)(a1 + 0x58);
              v68 = 0;
              v69 = v56;
              v70 = v60;
              if ( v63 == v62 )
                goto LABEL_80;
              do
              {
                if ( !*(_QWORD *)v63 && *(_DWORD *)(v63 + 8) == (_DWORD)v56 )
                  break;
                v63 += 0x10;
              }
              while ( v63 != v62 );
              if ( v63 == v62 )
LABEL_80:
                sub_140862290(a1 + 0x58, &v68, v6);
              else
                *(_DWORD *)(v63 + 0xC) += v60;
            }
            ++v56;
            v58 += 0x10;
            v57 += 0xC;
          }
          while ( v56 < v11 );
        }
        *(_WORD *)(a1 + 0x1DC) |= 0x20u;
        goto LABEL_83;
      }
      v6 = 0;
    }
    else
    {
      v6 = 0;
      v16 = ((unsigned int)(n4 - 4) >> 2) + 1;
      v17 = v16;
      n4_1 = 4 * v16;
      do
      {
        v18 = *(_QWORD *)(v3 + 0x18);
        v19 = 8 * v6;
        if ( v18 == *(_QWORD *)(v3 + 0x20) || (v20 = 8 * v6, *(_WORD *)(v19 + v18 + 6)) )
        {
          v22 = *(unsigned __int16 *)(v18 + v19 + 6);
          v20 = 8 * v6;
          v23 = (*(_WORD *)(v18 + v19 + 6) & 0x7FFF) << 0xD;
          LODWORD(v24) = v23 + 0x38000000;
          if ( (v23 & 0xF800000) == 0xF800000 )
          {
            LODWORD(v24) = v23 + 0x70000000;
          }
          else if ( (v23 & 0xF800000) == 0 )
          {
            v24 = COERCE_FLOAT(v23 + 0x38800000) + -0.000061035156;
          }
          v21 = 4 * v6;
          LODWORD(v25) = (v22 << 0x10) & 0x80000000 | LODWORD(v24);
          *((_BYTE *)Src[0] + 0xC * (unsigned __int16)(int)v25 + 8) = 1;
          v26 = *(_QWORD *)(v4 + 8);
          v27 = *(unsigned __int8 *)(4 * v6 + v26 + 1);
          if ( *(_BYTE *)(4 * v6 + v26) || *(_BYTE *)(4 * v6 + v26 + 1) )
          {
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v25) += *(unsigned __int8 *)(4 * v6 + v26);
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v25 + 1) += v27;
          }
        }
        else
        {
          v21 = 4 * v6;
        }
        v28 = *(_QWORD *)(v3 + 0x18);
        v29 = v28 + v20;
        if ( v28 == *(_QWORD *)(v3 + 0x20) || *(_WORD *)(v29 + 0xE) )
        {
          v30 = (*(_WORD *)(v29 + 0xE) & 0x7FFF) << 0xD;
          LODWORD(v31) = v30 + 0x38000000;
          if ( (v30 & 0xF800000) == 0xF800000 )
          {
            LODWORD(v31) = v30 + 0x70000000;
          }
          else if ( (v30 & 0xF800000) == 0 )
          {
            v31 = COERCE_FLOAT(v30 + 0x38800000) + -0.000061035156;
          }
          LODWORD(v32) = (*(unsigned __int16 *)(v29 + 0xE) << 0x10) & 0x80000000 | LODWORD(v31);
          *((_BYTE *)Src[0] + 0xC * (unsigned __int16)(int)v32 + 8) = 1;
          v33 = *(_QWORD *)(v4 + 8);
          v34 = *(unsigned __int8 *)(v33 + v21 + 5);
          if ( *(_BYTE *)(v33 + v21 + 4) || *(_BYTE *)(v33 + v21 + 5) )
          {
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v32) += *(unsigned __int8 *)(v33 + v21 + 4);
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v32 + 1) += v34;
          }
        }
        v35 = *(_QWORD *)(v3 + 0x18);
        if ( v35 == *(_QWORD *)(v3 + 0x20) || *(_WORD *)(v35 + v20 + 0x16) )
        {
          v36 = *(unsigned __int16 *)(v35 + v20 + 0x16);
          v37 = (*(_WORD *)(v35 + v20 + 0x16) & 0x7FFF) << 0xD;
          LODWORD(v38) = v37 + 0x38000000;
          if ( (v37 & 0xF800000) == 0xF800000 )
          {
            LODWORD(v38) = v37 + 0x70000000;
          }
          else if ( (v37 & 0xF800000) == 0 )
          {
            v38 = COERCE_FLOAT(v37 + 0x38800000) + -0.000061035156;
          }
          LODWORD(v39) = (v36 << 0x10) & 0x80000000 | LODWORD(v38);
          *((_BYTE *)Src[0] + 0xC * (unsigned __int16)(int)v39 + 8) = 1;
          v40 = *(_QWORD *)(v4 + 8);
          v41 = *(unsigned __int8 *)(v40 + 4 * v6 + 9);
          if ( *(_BYTE *)(v40 + 4 * v6 + 8) || *(_BYTE *)(v40 + 4 * v6 + 9) )
          {
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v39) += *(unsigned __int8 *)(v40 + 4 * v6 + 8);
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v39 + 1) += v41;
          }
        }
        v42 = *(_QWORD *)(v3 + 0x18);
        if ( v42 == *(_QWORD *)(v3 + 0x20) || *(_WORD *)(v42 + 8 * v6 + 0x1E) )
        {
          v43 = (*(_WORD *)(v42 + 8 * v6 + 0x1E) & 0x7FFF) << 0xD;
          LODWORD(v44) = v43 + 0x38000000;
          if ( (v43 & 0xF800000) == 0xF800000 )
          {
            LODWORD(v44) = v43 + 0x70000000;
          }
          else if ( (v43 & 0xF800000) == 0 )
          {
            v44 = COERCE_FLOAT(v43 + 0x38800000) + -0.000061035156;
          }
          LODWORD(v45) = (*(unsigned __int16 *)(v42 + 8 * v6 + 0x1E) << 0x10) & 0x80000000 | LODWORD(v44);
          *((_BYTE *)Src[0] + 0xC * (unsigned __int16)(int)v45 + 8) = 1;
          v46 = *(_QWORD *)(v4 + 8);
          v47 = *(unsigned __int8 *)(v46 + 4 * v6 + 0xD);
          if ( *(_BYTE *)(v46 + 4 * v6 + 0xC) || *(_BYTE *)(v46 + 4 * v6 + 0xD) )
          {
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v45) += *(unsigned __int8 *)(v46 + 4 * v6 + 0xC);
            *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v45 + 1) += v47;
          }
        }
        v6 += 4;
        --v17;
      }
      while ( v17 );
      if ( n4_1 >= (unsigned int)n4 )
        goto LABEL_71;
    }
    v48 = 4 * v6;
    v49 = (unsigned int)n4 - n4_1;
    v6 *= 8;
    do
    {
      v50 = *(_QWORD *)(v3 + 0x18);
      if ( v50 == *(_QWORD *)(v3 + 0x20) || *(_WORD *)(v50 + v6 + 6) )
      {
        v51 = (*(_WORD *)(v50 + v6 + 6) & 0x7FFF) << 0xD;
        LODWORD(v52) = v51 + 0x38000000;
        if ( (v51 & 0xF800000) == 0xF800000 )
        {
          LODWORD(v52) = v51 + 0x70000000;
        }
        else if ( (v51 & 0xF800000) == 0 )
        {
          v52 = COERCE_FLOAT(v51 + 0x38800000) + -0.000061035156;
        }
        LODWORD(v53) = (*(unsigned __int16 *)(v50 + v6 + 6) << 0x10) & 0x80000000 | LODWORD(v52);
        *((_BYTE *)Src[0] + 0xC * (unsigned __int16)(int)v53 + 8) = 1;
        v54 = *(_QWORD *)(v4 + 8);
        v55 = *(unsigned __int8 *)(v48 + v54 + 1);
        if ( *(_BYTE *)(v48 + v54) || *(_BYTE *)(v48 + v54 + 1) )
        {
          *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v53) += *(unsigned __int8 *)(v48 + v54);
          *((_DWORD *)Src[0] + 3 * (unsigned __int16)(int)v53 + 1) += v55;
        }
      }
      v6 += 8;
      v48 += 4;
      --v49;
    }
    while ( v49 );
    goto LABEL_71;
  }
LABEL_87:
  v75 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_14085CA50 (0x14085CA50) ---

// --- Function: sub_14085D190 (0x14085D190) ---
__int64 __fastcall sub_14085D190(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // r13
  signed __int64 v4; // rdx
  __int64 v5; // rax
  __int64 v6; // rbp
  __int64 v7; // r14
  unsigned int v8; // r11d
  __int64 v9; // rbp
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 v12; // rax
  _DWORD *v13; // rax
  unsigned int v14; // r10d
  int i; // r9d
  int n0x900; // [rsp+30h] [rbp-78h] BYREF
  __int64 v18; // [rsp+34h] [rbp-74h]
  int v19; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v20; // [rsp+40h] [rbp-68h]
  unsigned __int64 v21; // [rsp+48h] [rbp-60h]
  __int64 v22; // [rsp+50h] [rbp-58h]
  __int64 v23; // [rsp+58h] [rbp-50h]

  n0x900 = 0x900;
  v18 = 0;
  v19 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v20 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D80004,
    "CDamageMap::MT_UpdateSnapshotQuadTreeFromBuffer",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xCC7);
  v2 = *(_QWORD *)(a1 + 0x120);
  HIWORD(n0x900) = word_149D80004;
  if ( *(_QWORD *)(v2 + 0x18) != *(_QWORD *)(v2 + 0x20)
    && *(_QWORD *)(a1 + 0x20) != *(_QWORD *)(a1 + 0x28)
    && (*(_BYTE *)(a1 + 0x1DC) & 0x10) == 0 )
  {
    v3 = *(_QWORD *)(a1 + 0x110);
    if ( *(_DWORD *)(v3 + 0x58) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(v3 + 0x5C);
    }
    else
    {
      v4 = _InterlockedIncrement64((volatile signed __int64 *)(v3 + 0x48));
      if ( (v4 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(v3 + 0x48, v4, (const char *)&p_Src, (const char *)&p_Src, 1);
    }
    v5 = *(_QWORD *)(v3 + 8);
    v6 = *(_QWORD *)(v3 + 0x10);
    if ( v5 != v6 )
    {
      v7 = *(_QWORD *)(a1 + 0x120);
      v8 = 0;
      v9 = (v6 - v5) >> 2;
      if ( (_DWORD)v9 )
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v12 = *(_QWORD *)(v7 + 0x18);
          if ( v12 == *(_QWORD *)(v7 + 0x20) || *(_WORD *)(v10 + v12 + 6) )
          {
            if ( *(unsigned __int8 *)(v11 + *(_QWORD *)(v3 + 8))
               + *(unsigned __int8 *)(v11 + *(_QWORD *)(v3 + 8) + 1)
               + *(unsigned __int8 *)(v11 + *(_QWORD *)(v3 + 8) + 2) )
            {
              v13 = *(_DWORD **)(a1 + 0x20);
              if ( v13 != *(_DWORD **)(a1 + 0x28) )
              {
                *v13 |= 1u;
                v14 = 0;
                for ( i = *(unsigned __int8 *)(a1 + 0x10) - 2; i >= 0; i -= 2 )
                {
                  v14 = ((v8 >> i) & 3) + 4 * v14 + 1;
                  *(_DWORD *)(*(_QWORD *)(a1 + 0x20) + 4 * ((unsigned __int64)v14 >> 5)) |= 1 << (v14 & 0x1F);
                }
              }
            }
          }
          ++v8;
          v10 += 8;
          v11 += 4;
        }
        while ( v8 < (unsigned int)v9 );
      }
      *(_WORD *)(a1 + 0x1DC) |= 0x10u;
    }
    rw_lock_release_read_lock(v3 + 0x48);
  }
  v21 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_14085D190 (0x14085D190) ---

// --- Function: sub_14085EDC0 (0x14085EDC0) ---
__int64 __fastcall sub_14085EDC0(__int64 *a1, __int64 *a2, __int64 a3, _DWORD *a4)
{
  int v4; // r14d
  _DWORD *v5; // rdi
  __int64 *v7; // r13
  __int64 *v8; // r12
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  unsigned __int64 v14; // rcx
  __int64 n0x10; // rax
  int n2; // ecx
  float n0x10_1; // kr00_4
  __int64 v18; // rdx
  unsigned __int64 v19; // r9
  unsigned int n0x10_5; // r11d
  unsigned int v21; // ebx
  __int64 v22; // r8
  __int64 n0x10_4; // rax
  __int64 n0x10_2; // r15
  unsigned int v25; // esi
  int v26; // r12d
  __int64 v27; // r10
  int v28; // edi
  __int64 v29; // rdx
  int v30; // r8d
  __int64 v31; // r9
  unsigned int v32; // edx
  __int64 v33; // rdi
  int v34; // r15d
  int v35; // edi
  unsigned int n0x20; // ebx
  int v37; // eax
  unsigned int v38; // ecx
  __int64 v39; // rcx
  __int64 v40; // rbx
  int v41; // ebx
  int *ThreadLogContextSlot; // rax
  unsigned int v43; // r14d
  __int64 v44; // rdx
  __int64 v45; // rdi
  unsigned __int8 v46; // dl
  int v47; // ecx
  unsigned __int64 v48; // r13
  int v49; // ebx
  int v50; // eax
  unsigned __int64 v51; // rsi
  __int64 v52; // rax
  __int64 v53; // rbx
  unsigned int v55; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v56; // [rsp+64h] [rbp-9Ch] BYREF
  int v57; // [rsp+68h] [rbp-98h]
  unsigned __int64 v58; // [rsp+70h] [rbp-90h] BYREF
  unsigned int n0x10_6; // [rsp+78h] [rbp-88h]
  _BYTE v60[12]; // [rsp+7Ch] [rbp-84h]
  int v61; // [rsp+88h] [rbp-78h]
  unsigned int v62; // [rsp+8Ch] [rbp-74h]
  int v63; // [rsp+90h] [rbp-70h]
  _DWORD v64[2]; // [rsp+98h] [rbp-68h] BYREF
  _DWORD v65[2]; // [rsp+A0h] [rbp-60h] BYREF
  char v66; // [rsp+A8h] [rbp-58h] BYREF
  __int128 v67; // [rsp+B0h] [rbp-50h]
  __int64 v68; // [rsp+C0h] [rbp-40h]
  __int64 v69; // [rsp+C8h] [rbp-38h]
  unsigned __int64 v70; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v71; // [rsp+D8h] [rbp-28h]
  __int128 v72; // [rsp+E0h] [rbp-20h] BYREF
  __int64 n0x10_3; // [rsp+F0h] [rbp-10h]
  int n0x900; // [rsp+100h] [rbp+0h] BYREF
  __int64 v75; // [rsp+104h] [rbp+4h]
  int v76; // [rsp+10Ch] [rbp+Ch]
  unsigned __int64 v77; // [rsp+110h] [rbp+10h]
  unsigned __int64 v78; // [rsp+118h] [rbp+18h]
  __int64 v79; // [rsp+120h] [rbp+20h]
  __int64 v80; // [rsp+128h] [rbp+28h]
  _QWORD v81[2]; // [rsp+150h] [rbp+50h] BYREF
  _QWORD v82[2]; // [rsp+160h] [rbp+60h] BYREF
  __int128 v83[5]; // [rsp+170h] [rbp+70h] BYREF
  _DWORD *v87; // [rsp+1E8h] [rbp+E8h]

  v87 = a4;
  v4 = 0;
  n0x900 = 0x900;
  v75 = 0;
  v5 = a4;
  v76 = 0;
  v78 = 0;
  v7 = a2;
  v79 = 0;
  v8 = a1;
  v80 = 0;
  v77 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FF78,
    "DamageMapUtils::RebuildDamageMapFromSnapshot",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\Common\\DamageMapUtils.inl",
    0x22C);
  HIWORD(n0x900) = word_149D7FF78;
  v9 = *((unsigned int *)v8 + 6);
  *(_DWORD *)(a3 + 4) = 0;
  v10 = (v9 >> 2) * (v9 >> 2);
  v11 = v9 * v9;
  *(_DWORD *)(a3 + 0xC) = 0;
  v12 = *v7;
  v13 = v7[1];
  v70 = v10;
  if ( v12 == v13 )
  {
    v14 = (v13 - v12) >> 2;
    if ( v11 <= v14 )
      v7[1] = v12 + 4 * v11;
    else
      sub_14084DC50((__int64)v7, v11 - v14);
  }
  n0x10 = *((unsigned int *)v8 + 6);
  n2 = 2;
  v58 = 0;
  if ( (unsigned int)n0x10 < 0x10 )
    n2 = 0;
  v71 = v10;
  v18 = 0;
  v19 = 0;
  n0x10_6 = 0;
  n0x10_5 = 0;
  *(_DWORD *)&v60[8] = 0;
  n0x10_1 = (float)n0x10;
  v21 = 2 * ((LODWORD(n0x10_1) >> 0x17) - n2) - 0xFE;
  *(_QWORD *)v60 = v21;
  v61 = 2 * n2;
  do
  {
    v22 = *v8;
    v69 = v22;
    n0x10_4 = *(_QWORD *)(v18 + v22);
    n0x10_2 = *(_QWORD *)(v18 + v22 + 8);
    if ( n0x10_4 != n0x10_2 )
    {
      v25 = 0;
      LODWORD(n0x10_2) = 0x20 * ((n0x10_2 - n0x10_4) >> 2);
      v62 = n0x10_5 << v21;
      if ( (unsigned int)n0x10_2 > 0x14 )
      {
        v26 = (n0x10_5 & ((1 << v61) - 1)) << v21;
        v63 = v26;
        do
        {
          v27 = *(_QWORD *)(v18 + v22);
          v28 = 0;
          *(_QWORD *)((char *)&v67 + 4) = 0x100000000LL;
          if ( (unsigned int)(v4 + 1) <= 0x20 )
            LODWORD(v29) = *(_DWORD *)(v27 + 4LL * v25) >> v4;
          else
            v29 = *(_QWORD *)(v27 + 4LL * v25) >> v4;
          v30 = ((_BYTE)v4 + 1) & 0x1F;
          v31 = v25 + ((unsigned int)(v4 + 1) >> 5);
          BYTE12(v67) = v29 & 1;
          if ( (v29 & 1) != 0 )
          {
            v32 = v30 + 3;
            if ( (unsigned int)(v30 + 3) <= 0x20 )
              LODWORD(v33) = *(_DWORD *)(v27 + 4 * v31) >> v30;
            else
              v33 = *(_QWORD *)(v27 + 4 * v31) >> v30;
            v28 = v33 & 7;
            DWORD1(v67) = v28;
            DWORD2(v67) = 1 << (2 * v28);
            v34 = n0x10_2 - 4;
          }
          else
          {
            v32 = v30 + 1;
            v34 = n0x10_2 - 2;
          }
          v55 = v32 & 0x1F;
          v35 = 2 * v28;
          v56 = v31 + (v32 >> 5);
          n0x20 = v21 - v35;
          LODWORD(n0x10_2) = v34 - n0x20;
          v37 = sub_14084E720(v27, &v56, (int *)&v55, n0x20);
          v19 = v58;
          v38 = v26 | ((((1 << n0x20) - 1) & v37) << v35);
          LODWORD(v67) = v38;
          v72 = v67;
          if ( v58 < v38 )
          {
            v39 = v38 - (unsigned int)v58;
            v40 = (unsigned int)v39;
            memset((void *)(*v7 + 4 * v58), 0, 4 * v39);
            v19 = v40 + v58;
            v58 += v40;
          }
          if ( (unsigned int)n0x10_2 < 0x10 )
            break;
          if ( v19 <= (unsigned int)v72 )
          {
            v43 = v55 + 0x10;
            v44 = *(_QWORD *)(*(_QWORD *)&v60[4] + v69);
            if ( v55 + 0x10 <= 0x20 )
              v45 = (unsigned int)(*(_DWORD *)(v44 + 4LL * v56) >> v55);
            else
              v45 = *(_QWORD *)(v44 + 4LL * v56) >> v55;
            v68 = v45;
            v25 = (v43 >> 5) + v56;
            n0x10_2 = (unsigned int)(n0x10_2 - 0x10);
            v55 = v25;
            n0x10_3 = n0x10_2;
            v4 = v43 & 0x1F;
            v46 = (0x10 * BYTE1(v45)) ^ BYTE1(v45) & 0xF;
            LOBYTE(v57) = v45;
            BYTE1(v57) = v46;
            v47 = DWORD2(v72);
            HIWORD(v57) = (unsigned __int8)(((unsigned __int16)v45 >> 0xC) | (0x10 * ((unsigned __int16)v45 >> 0xC)));
            v48 = (unsigned int)(v19 + DWORD2(v72));
            if ( v19 < v48 )
            {
              v49 = v57;
              do
              {
                if ( sub_140844100(v19, (_QWORD *)a1[1], a1[2]) )
                  *(_DWORD *)(*a2 + 4 * v58) = v49;
                v50 = (unsigned __int16)v45 | ((_DWORD)v58++ << 0x10);
                v19 = v58;
                *v87 ^= v50;
              }
              while ( v19 < v48 );
              v47 = DWORD2(v72);
              v25 = v55;
              LOBYTE(v45) = v68;
              LODWORD(n0x10_2) = n0x10_3;
              v46 = BYTE1(v57);
              v26 = v63;
            }
            v7 = a2;
            *(_DWORD *)(a3 + 4) += v47 * (unsigned __int8)v45;
            *(_DWORD *)(a3 + 0xC) += v47 * v46;
          }
          else if ( (_QWORD)v72 == v62 )
          {
            v25 = v56;
            v4 = v55;
          }
          else
          {
            v64[0] = 0xCA;
            v81[0] = v64;
            v64[1] = 0xBC;
            v81[1] = v65;
            v41 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)v81,
                    (__int64)"Previous index is larger than current",
                    "Encountered a morton index that is smaller than the previous written pixel.\n"
                    "nPrevMorton : '$$' | CurrMorton : '$$'");
            if ( (v41 & 0xFFFFF) != 0 )
            {
              ThreadLogContextSlot = getThreadLogContextSlot();
              v65[0] = 0xCA;
              v82[0] = v65;
              v65[1] = 0xBC;
              v82[1] = &v66;
              v83[0] = 0;
              sub_1408454A0(
                3,
                (__int64)v82,
                "Previous index is larger than current",
                (__int64)"Encountered a morton index that is smaller than the previous written pixel.\n"
                         "nPrevMorton : '$$' | CurrMorton : '$$'",
                1,
                v41,
                v83,
                0,
                (__int64)ThreadLogContextSlot,
                (__int64)&v58,
                (__int64)&v72);
            }
            v19 = v58;
            v25 = v56;
            v4 = v55;
          }
          v18 = *(_QWORD *)&v60[4];
          v22 = v69;
          v21 = *(_DWORD *)v60;
        }
        while ( (unsigned int)n0x10_2 > 0x14 );
        v5 = v87;
        v8 = a1;
      }
      v51 = v71;
      if ( v19 < v71 )
      {
        v52 = (unsigned int)(v71 - v19);
        if ( (_DWORD)v71 != (_DWORD)v19 )
        {
          v53 = (unsigned int)v52;
          if ( (unsigned int)v52 < v70 )
          {
            memset((void *)(*v7 + 4 * v19), 0, 4 * v52);
            v19 = v53 + v58;
            v58 += v53;
          }
        }
      }
      v18 = *(_QWORD *)&v60[4];
      v4 = 0;
      n0x10_5 = n0x10_6;
      v21 = *(_DWORD *)v60;
      v71 = v70 + v51;
    }
    ++n0x10_5;
    v18 += 0x18;
    ++v5;
    n0x10_6 = n0x10_5;
    *(_QWORD *)&v60[4] = v18;
    v87 = v5;
  }
  while ( n0x10_5 < 0x10 );
  v78 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_14085EDC0 (0x14085EDC0) ---

// --- Function: sub_14085F360 (0x14085F360) ---
char __fastcall sub_14085F360(__int64 a1, __int64 a2, int a3, int a4)
{
  unsigned int v5; // edi
  unsigned int v6; // eax

  v5 = (((unsigned int)a2 >> a3) & 3) + 4 * a4 + 1;
  if ( !a3 )
    goto LABEL_6;
  if ( (unsigned __int8)sub_14085F360(a1, a2, (unsigned int)(a3 - 2), v5) )
  {
    v6 = 4 * v5;
    if ( v6 < v6 + 4 )
    {
      while ( ((1 << (v6 & 0x1F)) & *(_DWORD *)(*(_QWORD *)(a1 + 0x18) + 4 * ((unsigned __int64)v6 >> 5))) == 0 )
      {
        if ( ++v6 >= 4 * v5 + 4 )
          goto LABEL_6;
      }
      return 0;
    }
LABEL_6:
    *(_DWORD *)(*(_QWORD *)(a1 + 0x18) + 4 * ((unsigned __int64)v5 >> 5)) &= ~(1 << (v5 & 0x1F));
    return 1;
  }
  return 0;
}

// --- End Function: sub_14085F360 (0x14085F360) ---

// --- Function: sub_140860580 (0x140860580) ---
__int64 __fastcall sub_140860580(__int64 a1)
{
  signed __int32 v2; // eax
  bool v3; // cc
  __int64 result; // rax

  v2 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0xBC), 0xFFFFFFFF);
  v3 = v2 <= 1;
  result = (unsigned int)(v2 - 1);
  if ( v3 )
  {
    if ( a1 )
    {
      sub_14084A700();
      return sub_1402A6590(a1);
    }
  }
  return result;
}

// --- End Function: sub_140860580 (0x140860580) ---

// --- Function: sub_1408605C0 (0x1408605C0) ---
char __fastcall sub_1408605C0(__int64 a1, _QWORD *a2)
{
  const ULONG_PTR *n0x200000; // rax
  __int64 v5; // rax
  volatile signed __int32 *v6; // rsi
  __int64 v7; // r13
  volatile signed __int64 *v8; // r14
  int v9; // ebx
  __int64 v10; // r8
  unsigned __int64 v11; // rax
  __int64 v12; // rdx
  const ULONG_PTR *n0x200000_1; // rcx
  const ULONG_PTR *n0x200000_2; // rdi
  int v15; // eax
  ULONG_PTR v16; // rax
  unsigned __int64 v17; // r15
  volatile signed __int32 *v18; // rbx
  int v19; // eax
  __int64 *v20; // rdi
  __int64 v21; // r15
  __int64 v22; // rax
  __int64 v23; // rcx
  volatile signed __int32 *v24; // rbx
  volatile signed __int32 *v25; // rbx
  volatile signed __int32 *v26; // rbx
  volatile signed __int64 *v27; // rbx
  int v28; // edi
  __int64 v29; // r8
  unsigned __int64 v30; // rdx
  int v31; // eax
  _QWORD v33[2]; // [rsp+30h] [rbp-48h] BYREF
  _UNKNOWN *retaddr; // [rsp+78h] [rbp+0h] BYREF
  int v35; // [rsp+88h] [rbp+10h] BYREF
  __int64 v36; // [rsp+90h] [rbp+18h]

  n0x200000 = (const ULONG_PTR *)&retaddr;
  if ( !a2[0x22] )
    return (char)n0x200000;
  v5 = a2[0x23];
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 8));
  v6 = (volatile signed __int32 *)a2[0x23];
  v7 = a2[0x22];
  a2[0x22] = 0;
  a2[0x23] = 0;
  if ( v6 )
  {
    if ( _InterlockedExchangeAdd(v6 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v6)(v6);
      if ( _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
    }
  }
  v8 = (volatile signed __int64 *)(a1 + 0x38);
  v35 = *(_DWORD *)(a2[0x24] + 0x48LL);
  v9 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x48) == v9 )
  {
    ++*(_DWORD *)(a1 + 0x4C);
  }
  else
  {
    v10 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v11 = _InterlockedCompareExchange64(v8, 0x200000, 0);
    if ( v11 )
      sub_1403E1120(a1 + 0x38, v11, v10, "CDamageMapPool::RemoveDamageMap", "m_geometryDataLock", 1);
    else
      *(_QWORD *)(a1 + 0x40) = v10;
    *(_DWORD *)(a1 + 0x48) = v9;
  }
  sub_1408486F0((__int64 *)a1, v33, &v35);
  n0x200000 = (const ULONG_PTR *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 0x18));
  if ( (const ULONG_PTR *)v33[0] != n0x200000 )
  {
    v12 = *(_QWORD *)v33[1];
    v36 = v12;
    n0x200000_1 = *(const ULONG_PTR **)(v12 + 0x10);
    n0x200000 = *(const ULONG_PTR **)(v12 + 0x18);
    n0x200000_2 = n0x200000_1;
    if ( n0x200000_1 != n0x200000 )
    {
      while ( *n0x200000_2 != v7 )
      {
        n0x200000_2 += 2;
        if ( n0x200000_2 == n0x200000 )
          goto LABEL_18;
      }
      v16 = n0x200000_2[1];
      if ( v16 && *(_DWORD *)(v16 + 8) == 2 )
      {
        v17 = *(_QWORD *)(v12 + 0x18);
        if ( ((v17 - (_QWORD)n0x200000_1) & 0xFFFFFFFFFFFFFFF0uLL) == 0x10 )
        {
          v18 = v6;
          v6 = 0;
          if ( v18 )
          {
            if ( _InterlockedExchangeAdd(v18 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
              if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8LL))(v18);
            }
          }
          LOBYTE(n0x200000) = sub_1408485B0((_QWORD *)a1, (__int64)&v35);
        }
        else
        {
          v20 = (__int64 *)(n0x200000_2 + 2);
          if ( (unsigned __int64)v20 < v17 )
          {
            v21 = (__int64)(v17 - (_QWORD)v20) >> 4;
            if ( v21 > 0 )
            {
              do
              {
                v22 = *v20;
                v23 = v20[1];
                *v20 = 0;
                v20[1] = 0;
                v24 = (volatile signed __int32 *)v20[0xFFFFFFFF];
                v20[0xFFFFFFFE] = v22;
                v20[0xFFFFFFFF] = v23;
                if ( v24 )
                {
                  if ( _InterlockedExchangeAdd(v24 + 2, 0xFFFFFFFF) == 1 )
                  {
                    (**(void (__fastcall ***)(volatile signed __int32 *))v24)(v24);
                    if ( _InterlockedExchangeAdd(v24 + 3, 0xFFFFFFFF) == 1 )
                      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v24 + 8LL))(v24);
                  }
                }
                --v21;
                v20 += 2;
              }
              while ( v21 > 0 );
              v12 = v36;
            }
          }
          n0x200000 = (const ULONG_PTR *)(*(_QWORD *)(v12 + 0x18) - 0x10LL);
          *(_QWORD *)(v12 + 0x18) = n0x200000;
          v25 = (volatile signed __int32 *)n0x200000[1];
          if ( v25 )
          {
            LODWORD(n0x200000) = _InterlockedExchangeAdd(v25 + 2, 0xFFFFFFFF);
            if ( (_DWORD)n0x200000 == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v25)(v25);
              LODWORD(n0x200000) = _InterlockedExchangeAdd(v25 + 3, 0xFFFFFFFF);
              if ( (_DWORD)n0x200000 == 1 )
                LOBYTE(n0x200000) = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v25 + 8LL))(v25);
            }
          }
          v26 = v6;
          v6 = 0;
          if ( v26 )
          {
            LODWORD(n0x200000) = _InterlockedExchangeAdd(v26 + 2, 0xFFFFFFFF);
            if ( (_DWORD)n0x200000 == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v26)(v26);
              LODWORD(n0x200000) = _InterlockedExchangeAdd(v26 + 3, 0xFFFFFFFF);
              if ( (_DWORD)n0x200000 == 1 )
                LOBYTE(n0x200000) = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v26 + 8LL))(v26);
            }
          }
        }
      }
      else
      {
        v27 = (volatile signed __int64 *)(v7 + 0x48);
        v28 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
        if ( *(_DWORD *)(v7 + 0x58) == v28 )
        {
          ++*(_DWORD *)(v7 + 0x5C);
        }
        else
        {
          v29 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
          v30 = _InterlockedCompareExchange64(v27, 0x200000, 0);
          if ( v30 )
            sub_1403E1120(v7 + 0x48, v30, v29, (const char *)&p_Src, (const char *)&p_Src, 1);
          else
            *(_QWORD *)(v7 + 0x50) = v29;
          *(_DWORD *)(v7 + 0x58) = v28;
        }
        LOBYTE(n0x200000) = sub_140573F90((_BYTE *)(v7 + 0x38), (__int64)(a2 + 0x1E));
        if ( v7 != 0xFFFFFFFFFFFFFFB8uLL )
        {
          v31 = *(_DWORD *)(v7 + 0x5C);
          if ( v31 )
          {
            LODWORD(n0x200000) = v31 - 1;
            *(_DWORD *)(v7 + 0x5C) = (_DWORD)n0x200000;
          }
          else
          {
            *(_DWORD *)(v7 + 0x58) = 0xFFFFFFFF;
            n0x200000 = (const ULONG_PTR *)_InterlockedCompareExchange64(v27, 0, 0x200000);
            if ( n0x200000 == (const ULONG_PTR *)0x200000 )
              *(_QWORD *)(v7 + 0x50) = &p_Src;
            else
              LOBYTE(n0x200000) = (unsigned __int8)rw_lock_handle_write_release_contention(
                                                     v7 + 0x48,
                                                     (unsigned __int64)n0x200000);
          }
        }
      }
      if ( a1 == 0xFFFFFFFFFFFFFFC8uLL )
        goto LABEL_65;
      v19 = *(_DWORD *)(a1 + 0x4C);
      if ( v19 )
      {
        LODWORD(n0x200000) = v19 - 1;
        *(_DWORD *)(a1 + 0x4C) = (_DWORD)n0x200000;
        goto LABEL_65;
      }
      *(_DWORD *)(a1 + 0x48) = 0xFFFFFFFF;
      n0x200000 = (const ULONG_PTR *)_InterlockedCompareExchange64(v8, 0, 0x200000);
      if ( n0x200000 == (const ULONG_PTR *)0x200000 )
      {
        *(_QWORD *)(a1 + 0x40) = &p_Src;
        goto LABEL_65;
      }
LABEL_64:
      LOBYTE(n0x200000) = (unsigned __int8)rw_lock_handle_write_release_contention(
                                             (__int64)v8,
                                             (unsigned __int64)n0x200000);
      goto LABEL_65;
    }
  }
LABEL_18:
  if ( a1 != 0xFFFFFFFFFFFFFFC8uLL )
  {
    v15 = *(_DWORD *)(a1 + 0x4C);
    if ( !v15 )
    {
      *(_DWORD *)(a1 + 0x48) = 0xFFFFFFFF;
      n0x200000 = (const ULONG_PTR *)_InterlockedCompareExchange64(v8, 0, 0x200000);
      if ( n0x200000 == (const ULONG_PTR *)0x200000 )
      {
        n0x200000 = &p_Src;
        *(_QWORD *)(a1 + 0x40) = &p_Src;
        goto LABEL_65;
      }
      goto LABEL_64;
    }
    LODWORD(n0x200000) = v15 - 1;
    *(_DWORD *)(a1 + 0x4C) = (_DWORD)n0x200000;
  }
LABEL_65:
  if ( v6 )
  {
    LODWORD(n0x200000) = _InterlockedExchangeAdd(v6 + 2, 0xFFFFFFFF);
    if ( (_DWORD)n0x200000 == 1 )
    {
      LOBYTE(n0x200000) = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v6)(v6);
      if ( _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
        LOBYTE(n0x200000) = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
    }
  }
  return (char)n0x200000;
}

// --- End Function: sub_1408605C0 (0x1408605C0) ---

// --- Function: sub_140860A50 (0x140860A50) ---
unsigned __int64 __fastcall sub_140860A50(__int64 a1, unsigned int a2)
{
  unsigned __int64 result; // rax
  unsigned int v4; // r9d
  int i; // r8d
  _DWORD *v6; // rdx

  result = *(_QWORD *)(a1 + 0x18);
  if ( result != *(_QWORD *)(a1 + 0x20) )
  {
    *(_DWORD *)result |= 1u;
    v4 = 0;
    for ( i = *(unsigned __int8 *)(a1 + 8) - 2; i >= 0; i -= 2 )
    {
      v4 = ((a2 >> i) & 3) + 4 * v4 + 1;
      v6 = (_DWORD *)(*(_QWORD *)(a1 + 0x18) + 4 * ((unsigned __int64)v4 >> 5));
      result = (unsigned int)(1 << (v4 & 0x1F));
      *v6 |= result;
    }
  }
  return result;
}

// --- End Function: sub_140860A50 (0x140860A50) ---

// --- Function: sub_140860D50 (0x140860D50) ---
__int64 *__fastcall sub_140860D50(__int64 a1, __int64 *a2, __int64 a3, unsigned __int8 *Src)
{
  __int64 *v4; // rdi
  __int64 *v5; // r15
  __int64 v8; // rbp
  __int64 v9; // rbx
  __int64 v10; // rax
  int v11; // esi
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  int v14; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v17; // rax
  int v18; // eax
  unsigned __int64 n0x200000_1; // rax

  v4 = *(__int64 **)(a3 + 8);
  v5 = *(__int64 **)(a3 + 0x10);
  if ( v4 == v5 )
  {
LABEL_16:
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    while ( 1 )
    {
      v8 = *v4;
      v9 = *v4 + 0x48;
      v10 = NtCurrentTeb_w();
      v11 = *(_DWORD *)(v10 + 0x18);
      if ( *(_DWORD *)(v9 + 0x10) == v11 )
      {
        ++*(_DWORD *)(v9 + 0x14);
      }
      else
      {
        v12 = *(_QWORD *)(v10 + 0x20);
        v13 = _InterlockedCompareExchange64((volatile signed __int64 *)v9, 0x200000, 0);
        if ( v13 )
          sub_1403E1120(v9, v13, v12, (const char *)&p_Src, (const char *)&p_Src, 1);
        else
          *(_QWORD *)(v9 + 8) = v12;
        *(_DWORD *)(v9 + 0x10) = v11;
      }
      if ( sub_140574260(v8 + 0x38, (__int64)Src) )
        break;
      if ( v9 )
      {
        v14 = *(_DWORD *)(v9 + 0x14);
        if ( v14 )
        {
          *(_DWORD *)(v9 + 0x14) = v14 - 1;
        }
        else
        {
          *(_DWORD *)(v9 + 0x10) = 0xFFFFFFFF;
          n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v9, 0, 0x200000);
          if ( n0x200000 == 0x200000 )
            *(_QWORD *)(v9 + 8) = &p_Src;
          else
            rw_lock_handle_write_release_contention(v9, n0x200000);
        }
      }
      v4 += 2;
      if ( v4 == v5 )
        goto LABEL_16;
    }
    sub_140575060((_BYTE *)(v8 + 0x38), (__int64)Src);
    v17 = v4[1];
    *a2 = 0;
    a2[1] = 0;
    if ( v17 )
      _InterlockedIncrement((volatile signed __int32 *)(v17 + 8));
    *a2 = *v4;
    a2[1] = v4[1];
    if ( v9 )
    {
      v18 = *(_DWORD *)(v9 + 0x14);
      if ( v18 )
      {
        *(_DWORD *)(v9 + 0x14) = v18 - 1;
      }
      else
      {
        *(_DWORD *)(v9 + 0x10) = 0xFFFFFFFF;
        n0x200000_1 = _InterlockedCompareExchange64((volatile signed __int64 *)v9, 0, 0x200000);
        if ( n0x200000_1 == 0x200000 )
          *(_QWORD *)(v9 + 8) = &p_Src;
        else
          rw_lock_handle_write_release_contention(v9, n0x200000_1);
      }
    }
  }
  return a2;
}

// --- End Function: sub_140860D50 (0x140860D50) ---

// --- Function: sub_140860ED0 (0x140860ED0) ---
__int64 __fastcall sub_140860ED0(__int64 *a1, _QWORD *a2, _QWORD *a3, float a4, unsigned __int16 n0x10, __int64 a6)
{
  _QWORD *v7; // r8
  __int64 *v8; // rdx
  unsigned int v9; // r14d
  __int64 v10; // r13
  int n0x10_1; // eax
  char v12; // r12
  int v13; // ebp
  unsigned __int16 n0x10_2; // si
  int v21; // eax
  float v22; // r8d
  float v23; // xmm6_4
  float v24; // kr00_4
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // r8
  __m128 v27; // kr00_16
  __int64 v36; // rax
  __int64 v37; // rcx
  float v39; // [rsp+20h] [rbp-128h]
  float v40; // [rsp+24h] [rbp-124h]
  float v41; // [rsp+28h] [rbp-120h]
  float v42; // [rsp+2Ch] [rbp-11Ch]
  float v43; // [rsp+38h] [rbp-110h]
  float v44; // [rsp+3Ch] [rbp-10Ch]
  unsigned int v45; // [rsp+40h] [rbp-108h]
  unsigned __int64 v46; // [rsp+50h] [rbp-F8h]
  unsigned int v47; // [rsp+58h] [rbp-F0h]

  v7 = a2;
  v45 = 0;
  v8 = a1;
  v9 = 0;
  v10 = (__int64)(a3[1] - *a3) >> 5;
  v47 = *((_DWORD *)a1 + 6) - *((_DWORD *)a1 + 7);
  if ( !v47 )
    return sub_1408615F0(v8);
  n0x10_1 = n0x10;
  do
  {
    v12 = 0;
    v13 = v9 * n0x10_1;
    n0x10_2 = 0;
    v40 = 3.4028235e38;
    v41 = 3.4028235e38;
    v42 = 3.4028235e38;
    v43 = -3.4028235e38;
    v39 = -3.4028235e38;
    v44 = -3.4028235e38;
    LODWORD(_XMM2) = 0x7F7FFFFF;
    LODWORD(_XMM5) = 0x7F7FFFFF;
    LODWORD(_XMM4) = 0x7F7FFFFF;
    LODWORD(_XMM9) = 0xFF7FFFFF;
    LODWORD(_XMM6) = 0xFF7FFFFF;
    LODWORD(_XMM10) = 0xFF7FFFFF;
    if ( !n0x10 )
      goto LABEL_21;
    do
    {
      v46 = *(_QWORD *)(*v7 + 8LL * (v13 + (unsigned int)n0x10_2));
      if ( !HIWORD(v46) )
        goto LABEL_18;
      v21 = (HIWORD(v46) & 0x7FFF) << 0xD;
      LODWORD(v22) = v21 + 0x38000000;
      if ( (v21 & 0xF800000) == 0xF800000 )
      {
        LODWORD(v22) = v21 + 0x70000000;
      }
      else if ( (v21 & 0xF800000) == 0 )
      {
        v22 = COERCE_FLOAT(v21 + 0x38800000) + -0.000061035156;
      }
      LODWORD(v23) = LODWORD(v22) | (HIWORD(v46) << 0x10) & 0x80000000;
      v24 = (float)(unsigned int)v10;
      if ( v23 < v24 )
      {
        if ( sub_140574720(a6, (unsigned int)(int)v23) )
        {
          v25 = 0;
          if ( v23 >= 9.223372e18 )
          {
            v23 = v23 - 9.223372e18;
            if ( v23 < 9.223372e18 )
              v25 = 0x8000000000000000uLL;
          }
          v26 = *a3 + 0x20 * (v25 + (unsigned int)(int)v23);
          v27 = (__m128)*(unsigned int *)(v26 + 4);
          v27.m128_f32[0] = (float)((float)(v27.m128_f32[0] * v27.m128_f32[0]) + (float)(*(float *)v26 * *(float *)v26))
                          + (float)((float)(*(float *)(v26 + 8) * *(float *)(v26 + 8))
                                  + (float)(*(float *)(v26 + 0xC) * *(float *)(v26 + 0xC)));
          _XMM3 = _mm_shuffle_ps(v27, v27, 0);
          __asm { vrsqrtps xmm5, xmm3 }
          _mm_shuffle_ps(_XMM5, _XMM5, 0xFF);
          _XMM9 = LODWORD(v43);
          __asm { vmaxss  xmm9, xmm9, xmm5 }
          _XMM6 = LODWORD(v39);
          _XMM10 = LODWORD(v44);
          __asm { vmaxss  xmm6, xmm6, xmm4 }
          _XMM2 = LODWORD(v40);
          __asm { vminss  xmm2, xmm2, xmm5 }
          _XMM5 = LODWORD(v41);
          __asm { vminss  xmm5, xmm5, xmm4 }
          _XMM4 = LODWORD(v42);
          __asm
          {
            vminss  xmm4, xmm4, xmm1
            vmaxss  xmm10, xmm10, xmm1
          }
          v42 = *(float *)&_XMM4;
          v43 = *(float *)&_XMM9;
          v39 = *(float *)&_XMM6;
          v44 = *(float *)&_XMM10;
          v40 = *(float *)&_XMM2;
          v41 = *(float *)&_XMM5;
          v12 = 1;
          goto LABEL_17;
        }
        *(float *)&_XMM2 = v40;
        *(float *)&_XMM5 = v41;
        *(float *)&_XMM4 = v42;
      }
      *(float *)&_XMM6 = v39;
LABEL_17:
      v7 = a2;
LABEL_18:
      ++n0x10_2;
    }
    while ( n0x10_2 < n0x10 );
    v9 = v45;
    v8 = a1;
    if ( v12 )
    {
      v36 = *a1;
      v37 = 0xALL * (v45 + *((_DWORD *)a1 + 7));
      *(double *)(v36 + 8 * v37) = (float)(*(float *)&_XMM2 - a4);
      *(double *)(v36 + 8 * v37 + 8) = (float)(*(float *)&_XMM5 - a4);
      *(double *)(v36 + 8 * v37 + 0x10) = (float)(*(float *)&_XMM4 - a4);
      *(double *)(v36 + 8 * v37 + 0x18) = (float)(*(float *)&_XMM9 + a4);
      *(double *)(v36 + 8 * v37 + 0x20) = (float)(*(float *)&_XMM6 + a4);
      *(double *)(v36 + 8 * v37 + 0x28) = (float)(*(float *)&_XMM10 + a4);
      *(_DWORD *)(v36 + 8 * v37 + 0x30) = v13;
      *(_BYTE *)(v36 + 8 * v37 + 0x48) = 1;
      goto LABEL_22;
    }
LABEL_21:
    *(_BYTE *)(*v8 + 0x50LL * (v9 + *((_DWORD *)v8 + 7)) + 0x48) = 0;
LABEL_22:
    ++v9;
    n0x10_1 = n0x10;
    v45 = v9;
  }
  while ( v9 < v47 );
  return sub_1408615F0(v8);
}

// --- End Function: sub_140860ED0 (0x140860ED0) ---

// --- Function: sub_1408615F0 (0x1408615F0) ---
char __fastcall sub_1408615F0(__int64 *a1)
{
  __int64 i; // rcx
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 n4; // rax
  __int64 n4_1; // r10
  unsigned __int64 v7; // r11
  __int64 v8; // rdx
  __int64 v9; // r9
  __int64 v10; // rax
  unsigned __int64 *v11; // rcx
  __int64 v24; // r9
  __int64 v25; // rax
  unsigned __int64 *v26; // rcx
  __int64 v39; // r9
  __int64 v40; // rax
  unsigned __int64 *v41; // rcx
  __int64 v54; // r9
  double *v55; // rcx
  __int64 v68; // rdx
  __int64 v69; // r9
  unsigned __int64 *v70; // rcx

  for ( i = 0; (unsigned int)i < *((_DWORD *)a1 + 7); *(_BYTE *)(v3 + 8 * v4 + 0x48) = 0 )
  {
    v3 = *a1;
    v4 = 0xA * i;
    i = (unsigned int)(i + 1);
    *(_QWORD *)(v3 + 8 * v4) = 0x5F138D352E5096AFLL;
    *(_QWORD *)(v3 + 8 * v4 + 8) = 0x5F138D352E5096AFLL;
    *(_QWORD *)(v3 + 8 * v4 + 0x10) = 0x5F138D352E5096AFLL;
    *(_QWORD *)(v3 + 8 * v4 + 0x18) = 0xDF138D352E5096AFuLL;
    *(_QWORD *)(v3 + 8 * v4 + 0x20) = 0xDF138D352E5096AFuLL;
    *(_QWORD *)(v3 + 8 * v4 + 0x28) = 0xDF138D352E5096AFuLL;
  }
  LODWORD(n4) = *((_DWORD *)a1 + 6) - 1;
  n4_1 = (int)n4;
  if ( (int)n4 >= 4LL )
  {
    v7 = ((unsigned __int64)((int)n4 - 4LL) >> 2) + 1;
    v8 = 0x50LL * (int)n4;
    n4_1 = (int)n4 - 4 * v7;
    do
    {
      v9 = *a1;
      v10 = *(unsigned int *)(*a1 + v8 + 0x34);
      if ( (_DWORD)v10 != 0xFFFFFFFF && *(_BYTE *)(v9 + v8 + 0x48) )
      {
        v11 = (unsigned __int64 *)(v9 + 0x50 * v10);
        _XMM0 = *v11;
        __asm { vminsd  xmm1, xmm0, qword ptr [r9+rdx] }
        *v11 = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v9 + v8 + 8);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+8] }
        v11[1] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v9 + v8 + 0x10);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+10h] }
        v11[2] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v9 + v8 + 0x18);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+18h] }
        v11[3] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v9 + v8 + 0x20);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+20h] }
        v11[4] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v9 + v8 + 0x28);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+28h] }
        v11[5] = *(unsigned __int64 *)&_XMM1;
        *((_BYTE *)v11 + 0x48) |= *(double *)v11 <= *((double *)v11 + 3);
      }
      v24 = *a1;
      v25 = *(unsigned int *)(*a1 + v8 - 0x1C);
      if ( (_DWORD)v25 != 0xFFFFFFFF && *(_BYTE *)(v24 + v8 - 8) )
      {
        v26 = (unsigned __int64 *)(v24 + 0x50 * v25);
        _XMM0 = *v26;
        __asm { vminsd  xmm1, xmm0, qword ptr [r9+rdx-50h] }
        *v26 = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v24 + v8 - 0x48);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+8] }
        v26[1] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v24 + v8 - 0x40);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+10h] }
        v26[2] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v24 + v8 - 0x38);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+18h] }
        v26[3] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v24 + v8 - 0x30);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+20h] }
        v26[4] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v24 + v8 - 0x28);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+28h] }
        v26[5] = *(unsigned __int64 *)&_XMM1;
        *((_BYTE *)v26 + 0x48) |= *(double *)v26 <= *((double *)v26 + 3);
      }
      v39 = *a1;
      v40 = *(unsigned int *)(*a1 + v8 - 0x6C);
      if ( (_DWORD)v40 != 0xFFFFFFFF && *(_BYTE *)(v39 + v8 - 0x58) )
      {
        v41 = (unsigned __int64 *)(v39 + 0x50 * v40);
        _XMM0 = *v41;
        __asm { vminsd  xmm1, xmm0, qword ptr [r9+rdx-0A0h] }
        *v41 = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v39 + v8 - 0x98);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+8] }
        v41[1] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v39 + v8 - 0x90);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+10h] }
        v41[2] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v39 + v8 - 0x88);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+18h] }
        v41[3] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v39 + v8 - 0x80);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+20h] }
        v41[4] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v39 + v8 - 0x78);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+28h] }
        v41[5] = *(unsigned __int64 *)&_XMM1;
        *((_BYTE *)v41 + 0x48) |= *(double *)v41 <= *((double *)v41 + 3);
      }
      v54 = *a1;
      n4 = *(unsigned int *)(*a1 + v8 - 0xBC);
      if ( (_DWORD)n4 != 0xFFFFFFFF && *(_BYTE *)(v54 + v8 - 0xA8) )
      {
        v55 = (double *)(v54 + 0x50 * n4);
        _XMM0 = *(unsigned __int64 *)v55;
        __asm { vminsd  xmm1, xmm0, qword ptr [r9+rdx-0F0h] }
        *v55 = *(double *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v54 + v8 - 0xE8);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+8] }
        v55[1] = *(double *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v54 + v8 - 0xE0);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+10h] }
        v55[2] = *(double *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v54 + v8 - 0xD8);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+18h] }
        v55[3] = *(double *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v54 + v8 - 0xD0);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+20h] }
        v55[4] = *(double *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v54 + v8 - 0xC8);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+28h] }
        v55[5] = *(double *)&_XMM1;
        LOBYTE(n4) = *v55 <= v55[3];
        *((_BYTE *)v55 + 0x48) |= n4;
      }
      v8 -= 0x140;
      --v7;
    }
    while ( v7 );
  }
  if ( n4_1 > 0 )
  {
    v68 = 0x50 * n4_1;
    do
    {
      v69 = *a1;
      n4 = *(unsigned int *)(*a1 + v68 + 0x34);
      if ( (_DWORD)n4 != 0xFFFFFFFF && *(_BYTE *)(v69 + v68 + 0x48) )
      {
        v70 = (unsigned __int64 *)(v69 + 0x50 * n4);
        _XMM0 = *v70;
        __asm { vminsd  xmm1, xmm0, qword ptr [r9+rdx] }
        *v70 = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v69 + v68 + 8);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+8] }
        v70[1] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v69 + v68 + 0x10);
        __asm { vminsd  xmm1, xmm0, qword ptr [rcx+10h] }
        v70[2] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v69 + v68 + 0x18);
        __asm { vmaxsd  xmm2, xmm0, qword ptr [rcx+18h] }
        v70[3] = *(unsigned __int64 *)&_XMM2;
        _XMM0 = *(unsigned __int64 *)(v69 + v68 + 0x20);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+20h] }
        v70[4] = *(unsigned __int64 *)&_XMM1;
        _XMM0 = *(unsigned __int64 *)(v69 + v68 + 0x28);
        __asm { vmaxsd  xmm1, xmm0, qword ptr [rcx+28h] }
        v70[5] = *(unsigned __int64 *)&_XMM1;
        LOBYTE(n4) = *(double *)&_XMM2 >= *(double *)v70;
        *((_BYTE *)v70 + 0x48) |= n4;
      }
      --n4_1;
      v68 -= 0x50;
    }
    while ( n4_1 > 0 );
  }
  return n4;
}

// --- End Function: sub_1408615F0 (0x1408615F0) ---

// --- Function: sub_140861BF0 (0x140861BF0) ---
unsigned __int64 __fastcall sub_140861BF0(__int64 a1)
{
  __int128 *v1; // rdx
  __int64 v3; // r8
  __int128 *v4; // rcx
  __int128 *v5; // rax
  unsigned __int64 v9; // r8
  __int64 v10; // r10
  unsigned __int64 v11; // rdi
  __int128 *v12; // r11
  unsigned __int128 v14; // rax
  unsigned __int64 v15; // rbx
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  __int64 v21; // rsi
  unsigned __int64 v22; // rdx
  __int64 v23; // rsi
  char v24; // bl
  bool v25; // zf
  __int64 v26; // rcx
  __int64 v27; // rax
  _QWORD *v28; // rdx
  unsigned __int64 result; // rax

  v1 = *(__int128 **)a1;
  v3 = *(_QWORD *)(a1 + 0x18);
  v4 = v1;
  v5 = (__int128 *)((char *)v1 + v3 + 1);
  if ( v1 != v5 )
  {
    _XMM3 = 0;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm3, xmmword ptr [rcx]
        vpandn  xmm1, xmm0, xmm4
      }
      *v4++ = _XMM1 | xmmword_1482B5BB0;
    }
    while ( v4 != v5 );
  }
  *v5 = *v1;
  *((_BYTE *)v1 + v3) = 0xFF;
  v9 = *(_QWORD *)(a1 + 0x18);
  v10 = 0;
  if ( v9 )
  {
    v11 = 0xFFFFFFFFFFFFFFF0uLL;
    do
    {
      v12 = *(__int128 **)a1;
      if ( *(_BYTE *)(*(_QWORD *)a1 + v10) == 0xFE )
      {
        _XMM1 = xmmword_1482B5BC0;
        v14 = **(unsigned int **)(*(_QWORD *)(a1 + 8) + 8 * v10) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
        v15 = *((_QWORD *)&v14 + 1) + v14;
        v16 = 0;
        v17 = v9 & (v15 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r11+rcx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v16 += 0x10;
          v17 = v9 & (v16 + v17);
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r11+rcx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v21, _EAX);
        v22 = *(_QWORD *)(a1 + 0x18) & (v15 >> 7);
        v23 = v9 & (v17 + v21);
        v24 = v15 & 0x7F;
        if ( (*(_QWORD *)(a1 + 0x18) & ((v10 - v22) ^ (v23 - v22)) & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
        {
          v25 = *((_BYTE *)v12 + v23) == 0x80;
          *((_BYTE *)v12 + v23) = v24;
          *(_BYTE *)((*(_QWORD *)(a1 + 0x18) & 0xFLL) + (*(_QWORD *)(a1 + 0x18) & (v23 - 0x10)) + *(_QWORD *)a1 + 1) = v24;
          if ( v25 )
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v23) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v10);
            *(_BYTE *)(v10 + *(_QWORD *)a1) = 0x80;
            *(_BYTE *)((*(_QWORD *)(a1 + 0x18) & 0xFLL) + (v11 & *(_QWORD *)(a1 + 0x18)) + *(_QWORD *)a1 + 1) = 0x80;
          }
          else
          {
            v26 = *(_QWORD *)(a1 + 8);
            v27 = *(_QWORD *)(v26 + 8 * v10);
            v28 = (_QWORD *)(v26 + 8 * v10--);
            --v11;
            *v28 = *(_QWORD *)(v26 + 8 * v23);
            *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v23) = v27;
          }
        }
        else
        {
          *(_BYTE *)(*(_QWORD *)a1 + v10) = v24;
          *(_BYTE *)((*(_QWORD *)(a1 + 0x18) & 0xFLL) + (*(_QWORD *)(a1 + 0x18) & v11) + *(_QWORD *)a1 + 1) = v24;
        }
      }
      v9 = *(_QWORD *)(a1 + 0x18);
      ++v10;
      ++v11;
    }
    while ( v10 != v9 );
  }
  result = v9 - *(_QWORD *)(a1 + 0x10) - (v9 >> 3);
  *(_QWORD *)(a1 + 0x30) = result;
  return result;
}

// --- End Function: sub_140861BF0 (0x140861BF0) ---

// --- Function: sub_140861F50 (0x140861F50) ---
__int64 __fastcall sub_140861F50(__int64 *a1, __int64 a2, unsigned int *a3)
{
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // rdx
  __int64 v7; // rdi
  __int64 *v8; // rbx
  __int64 v9; // rdx
  char v10; // r14
  __int64 v11; // rcx
  __int64 v12; // rcx
  char v13; // r14
  __int64 v14; // rcx
  __int128 v15; // rdi
  volatile signed __int32 *v16; // rbx
  __int128 v18; // [rsp+30h] [rbp-68h]
  unsigned int v19; // [rsp+50h] [rbp-48h] BYREF
  __m256 v20; // [rsp+58h] [rbp-40h]

  v19 = *a3;
  v5 = (__PAIR128__(v19, v19) * 0xDE5FB9D2630458E9uLL) >> 0x40;
  v20 = (__m256)0LL;
  __asm { vzeroupper }
  v6 = sub_1408453C0(a1, &v19, v5);
  if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
  {
    v7 = sub_140862160(a1, v5);
    v8 = (__int64 *)(a1[1] + 8 * v7);
    v9 = sub_1402A65A0(0x28u);
    v10 = v5 & 0x7F;
    *(_DWORD *)v9 = v19;
    *(_QWORD *)(v9 + 8) = *(_QWORD *)v20.m256_f32;
    *(_QWORD *)v20.m256_f32 = 0;
    *(_QWORD *)(v9 + 0x18) = 0;
    *(_QWORD *)(v9 + 0x20) = 0;
    *(_QWORD *)(v9 + 0x10) = 0;
    *(_QWORD *)(v9 + 0x10) = *(_QWORD *)&v20.m256_f32[2];
    *(_QWORD *)&v20.m256_f32[2] = 0;
    v11 = *(_QWORD *)(v9 + 0x18);
    *(_QWORD *)(v9 + 0x18) = *(_QWORD *)&v20.m256_f32[4];
    *(_QWORD *)&v20.m256_f32[4] = v11;
    v12 = *(_QWORD *)(v9 + 0x20);
    *(_QWORD *)(v9 + 0x20) = *(_QWORD *)&v20.m256_f32[6];
    *(_QWORD *)&v20.m256_f32[6] = v12;
    *v8 = v9;
    *(_BYTE *)(v7 + *a1) = v10;
    *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v7 - 0x10)) + *a1 + 1) = v10;
    v13 = 1;
    *(_QWORD *)&v18 = v7 + *a1;
    v14 = a1[1] + 8 * v7;
  }
  else
  {
    *(_QWORD *)&v18 = v6 + *a1;
    v13 = 0;
    v14 = a1[1] + 8 * v6;
  }
  v15 = *(_OWORD *)&v20.m256_f32[2];
  *((_QWORD *)&v18 + 1) = v14;
  if ( *(_QWORD *)&v20.m256_f32[2] != *(_QWORD *)&v20.m256_f32[4] )
  {
    do
    {
      v16 = *(volatile signed __int32 **)(v15 + 8);
      if ( v16 )
      {
        if ( _InterlockedExchangeAdd(v16 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v16)(v16);
          if ( _InterlockedExchangeAdd(v16 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v16 + 8LL))(v16);
        }
      }
      *(_QWORD *)&v15 = v15 + 0x10;
    }
    while ( (_QWORD)v15 != *((_QWORD *)&v15 + 1) );
    *(_QWORD *)&v15 = *(_QWORD *)&v20.m256_f32[2];
  }
  if ( (_QWORD)v15 )
    sub_1402A6590(v15);
  if ( *(_QWORD *)v20.m256_f32 )
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)v20.m256_f32 + 0x10LL))(*(_QWORD *)v20.m256_f32);
  *(_OWORD *)a2 = v18;
  *(_BYTE *)(a2 + 0x10) = v13;
  return a2;
}

// --- End Function: sub_140861F50 (0x140861F50) ---

// --- Function: sub_140862160 (0x140862160) ---
__int64 __fastcall sub_140862160(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = xmmword_1482B5BC0;
  v4 = 0;
  v5 = a2 >> 7;
  v6 = 0;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 0x10;
    v9 = v7 & (v6 + v9);
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = v7 & (v9 + v13);
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_140861BF0((__int64)a1);
LABEL_11:
        v18 = a1[3];
        v19 = 0;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 0x10;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = v18 & (v20 + _RAX);
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1;
    }
    sub_1408623F0(a1, v17, v8);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_140862160 (0x140862160) ---

// --- Function: sub_140862290 (0x140862290) ---
_OWORD *__fastcall sub_140862290(__int64 *a1, _OWORD *a2)
{
  _OWORD *v4; // rcx
  _OWORD *result; // rax
  __int64 v6; // rcx
  __int64 v7; // rsi
  _OWORD *v8; // rdi
  unsigned __int64 v9; // rsi
  __int64 v10; // rbp
  const void *v11; // rdx
  _OWORD *v12; // rax
  _OWORD *v13; // rbp

  v4 = (_OWORD *)a1[1];
  if ( (unsigned __int64)v4 < a1[2] )
  {
    result = v4 + 1;
    a1[1] = (__int64)(v4 + 1);
    *v4 = *a2;
    return result;
  }
  v6 = ((__int64)v4 - *a1) >> 4;
  if ( !v6 )
  {
    v7 = 1;
    goto LABEL_7;
  }
  v7 = 2 * v6;
  if ( 2 * v6 )
  {
LABEL_7:
    v9 = v7;
    v8 = (_OWORD *)sub_1402A65A0(v9 * 0x10);
    goto LABEL_8;
  }
  v8 = 0;
  v9 = 0;
LABEL_8:
  v10 = a1[1];
  if ( *a1 == v10 )
  {
    v12 = v8;
  }
  else
  {
    v11 = (const void *)*a1;
    v12 = (char *)memmove(v8, v11, v10 - (_QWORD)v11) + ((v10 - (_QWORD)v11) & 0xFFFFFFFFFFFFFFF0uLL);
  }
  *v12 = *a2;
  v13 = v12 + 1;
  if ( *a1 )
    sub_1402A6590(*a1);
  result = &v8[v9];
  *a1 = (__int64)v8;
  a1[1] = (__int64)v13;
  a1[2] = (__int64)&v8[v9];
  return result;
}

// --- End Function: sub_140862290 (0x140862290) ---

// --- Function: sub_140862390 (0x140862390) ---
__int64 __fastcall sub_140862390(__int64 *a1)
{
  __int64 v1; // rdi
  signed __int32 v3; // eax
  bool v4; // zf
  bool v5; // sf
  bool v6; // of
  __int64 result; // rax

  v1 = *a1;
  if ( *a1
    && (v3 = _InterlockedExchangeAdd((volatile signed __int32 *)(v1 + 0xBC), 0xFFFFFFFF),
        v6 = __OFSUB__(v3, 1),
        v4 = v3 == 1,
        v5 = v3 - 1 < 0,
        result = (unsigned int)(v3 - 1),
        v5 ^ v6 | v4) )
  {
    sub_14084A700(v1);
    result = sub_1402A6590(v1);
    *a1 = 0;
  }
  else
  {
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_140862390 (0x140862390) ---

// --- Function: sub_1408623F0 (0x1408623F0) ---
__int64 __fastcall sub_1408623F0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // r15
  __int64 v5; // r14
  unsigned __int64 v7; // rbx
  void *v8; // rax
  __int64 v9; // r9
  __int64 result; // rax
  __int64 v11; // r10
  unsigned __int128 v13; // rax
  unsigned __int64 v14; // rbx
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v20; // r8
  char v21; // bl
  __int64 v22; // r8

  v2 = *a1;
  v3 = a1[1];
  v5 = a1[3];
  v7 = (a2 + 0x18) & 0xFFFFFFFFFFFFFFF8uLL;
  v8 = (void *)sub_1402A65A0(v7 + 8 * a2);
  *a1 = (__int64)v8;
  a1[1] = (__int64)v8 + v7;
  memset(v8, 0xFFFFFF80, a2 + 0x10);
  v9 = 0;
  *(_BYTE *)(a2 + *a1) = 0xFF;
  result = a2 >> 3;
  a1[3] = a2;
  a1[6] = a2 - (a2 >> 3) - a1[2];
  if ( v5 )
  {
    do
    {
      if ( *(char *)(v9 + v2) >= 0 )
      {
        v11 = a1[3];
        _XMM1 = xmmword_1482B5BC0;
        v13 = **(unsigned int **)(v3 + 8 * v9) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
        v14 = *((_QWORD *)&v13 + 1) + v13;
        v15 = 0;
        v16 = v11 & (v14 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r11+rcx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v15 += 0x10;
          v16 = v11 & (v15 + v16);
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r11+rcx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v20, _EAX);
        v21 = v14 & 0x7F;
        v22 = v11 & (v16 + v20);
        *(_BYTE *)(*a1 + v22) = v21;
        *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v22 - 0x10)) + *a1 + 1) = v21;
        *(_QWORD *)(a1[1] + 8 * v22) = *(_QWORD *)(v3 + 8 * v9);
      }
      ++v9;
    }
    while ( v9 != v5 );
    return sub_1402A6590(v2);
  }
  return result;
}

// --- End Function: sub_1408623F0 (0x1408623F0) ---

// --- Function: sub_140862690 (0x140862690) ---
__int64 __fastcall sub_140862690(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r8
  const void *v4; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rbp
  __int64 v8; // r12
  char *v9; // r14
  __int64 v10; // r15
  char *v11; // r8
  unsigned __int64 v12; // rcx
  _QWORD *v13; // rax
  __int64 v14; // rdx
  char *v15; // rbx
  __int64 result; // rax
  unsigned __int64 v17; // rax

  v2 = *(_QWORD **)(a1 + 8);
  v4 = *(const void **)a1;
  v5 = ((__int64)v2 - *(_QWORD *)a1) >> 3;
  if ( a2 <= v5 )
  {
    result = (__int64)v4 + 8 * a2;
    *(_QWORD *)(a1 + 8) = result;
  }
  else
  {
    v6 = a2 - v5;
    if ( a2 - v5 <= (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v2) >> 3 )
    {
      v17 = a2 - v5;
      if ( v6 )
      {
        do
        {
          *v2++ = 0;
          --v17;
        }
        while ( v17 );
      }
      result = 8 * v6;
      *(_QWORD *)(a1 + 8) += 8 * v6;
    }
    else
    {
      v7 = 2 * v5;
      if ( !v5 )
        v7 = 1;
      if ( v7 < a2 )
        v7 = a2;
      if ( v7 )
      {
        v8 = 8 * v7;
        v9 = (char *)sub_1402A65A0(8 * v7);
      }
      else
      {
        v9 = 0;
        v8 = 0;
      }
      v10 = *(_QWORD *)(a1 + 8);
      if ( *(_QWORD *)a1 == v10 )
        v11 = v9;
      else
        v11 = (char *)memmove(v9, *(const void **)a1, v10 - *(_QWORD *)a1) + 8 * ((__int64)(v10 - a2) >> 3);
      v12 = v6;
      v13 = v11;
      v14 = v8;
      if ( v6 )
      {
        do
        {
          *v13++ = 0;
          --v12;
        }
        while ( v12 );
        v14 = 8 * v7;
      }
      v15 = &v11[8 * v6];
      if ( *(_QWORD *)a1 )
      {
        sub_1402A6590(*(_QWORD *)a1);
        v14 = v8;
      }
      result = (__int64)&v9[v14];
      *(_QWORD *)a1 = v9;
      *(_QWORD *)(a1 + 8) = v15;
      *(_QWORD *)(a1 + 0x10) = &v9[v14];
    }
  }
  return result;
}

// --- End Function: sub_140862690 (0x140862690) ---

// --- Function: sub_147712830 (0x147712830) ---
__int64 __fastcall sub_147712830(__int64 a1)
{
  return sub_147712840(a1, 0);
}

// --- End Function: sub_147712830 (0x147712830) ---

// --- Function: sub_147712840 (0x147712840) ---
void __fastcall sub_147712840(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  char *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_1518433EC + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_1518433EC + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = (char *)&unk_151842250
           + 0x20 * *(_QWORD *)((unsigned int)dword_1518433EC + (a1 & 0xFFFFFFFFFE000000uLL) + 8);
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor(sub_14828DCE0);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = (char *)&unk_151842250 + 0x20 * n0x28;
      }
      sub_1477145F0(v5, v4, 0xFFFFFFFFLL);
    }
    else
    {
      sub_147712980(&qword_151842240, a1);
    }
  }
}

// --- End Function: sub_147712840 (0x147712840) ---

// --- Function: sub_147715880 (0x147715880) ---
__int64 __fastcall sub_147715880(const void *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( qword_149C8E0F8 && qword_149C8DF28 && a1 == (const void *)qword_149C8DF28 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149C3E3B8
      || (result = qword_149C3E3B8 + 0x8000000000LL, (unsigned __int64)a1 >= qword_149C3E3B8 + 0x8000000000LL) )
    {
      if ( (unsigned __int64)a1 >= qword_149C3E398 && (unsigned __int64)a1 < qword_149C3E398 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      return sub_147712830(a1);
    }
  }
  return result;
}

// --- End Function: sub_147715880 (0x147715880) ---

// --- Function: allocWithProfilerInfo (0x147715930) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  unsigned __int8 v5; // bl
  __int64 v6; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1475EE1F0();
    v5 = sub_14056F960(v4);
    v6 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_147712FD0(v6 + allocSize, profilerInfo, v5);
    if ( result )
      return result;
    sub_1477151F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147715930) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14814323E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14814323E) ---

// --- Function: __alloca_probe (0x148144150) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x148144150) ---

// --- Function: __security_check_cookie (0x1481441B0) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x1481441B0) ---

// --- Function: __report_gsfailure (0x1481443AC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151877A00 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1518779F0 = 0xC0000409;
  dword_1518779F4 = 1;
  dword_151877A08 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1481443AC) ---

// --- Function: memcpy (0x148192BDB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x148192BDB) ---

// --- Function: memmove (0x148192BE1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148192BE1) ---

// --- Function: memset (0x148192BE7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148192BE7) ---

// --- Function: memcmp (0x148192C05) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148192C05) ---

// --- Function: powf (0x148192CEF) ---
// attributes: thunk
float __cdecl powf(float X, float Y)
{
  return __imp_powf(X, Y);
}

// --- End Function: powf (0x148192CEF) ---

// --- Function: logf (0x148192D13) ---
// attributes: thunk
float __cdecl logf(float X)
{
  return __imp_logf(X);
}

// --- End Function: logf (0x148192D13) ---

