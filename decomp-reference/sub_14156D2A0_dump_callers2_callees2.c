// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x14156D2A0 (sub_14156D2A0)
// Caller Depth: 2
// Callee/Ref Depth: 2
// Total Functions Found: 65
// ------------------------------------------------------------

// --- Function: __StarEngineModule__ (0x1402A16B0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A16B0) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !off_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !off_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 ptr_to_free_29,
        __int64 _Newcapacity_1,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 _Newcapacity; // r13
  char result; // al
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  unsigned __int64 v18; // r15
  _QWORD *ptr_to_free_25; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_16; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 ptr_to_free_17; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, unsigned __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *ptr_to_free_20; // r14
  __int64 *p_ptr_to_free_1; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  const vraudio::AudioBuffer *ptr_to_free_18; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *ptr_to_free_1; // r15
  _QWORD *v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *ptr_to_free; // rcx
  __m256 *ptr_to_free_10; // rax
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_21; // rax
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_22; // r14
  __int64 ptr_to_free_23; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  char *v64; // r10
  char *v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 ptr_to_free_11; // rax
  const void *ptr_to_free_3; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  FILE *Stream; // rax
  int n2; // r8d
  FILE *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 ptr_to_free_12; // rax
  const void *ptr_to_free_2; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  FILE *Stream_2; // rax
  FILE *Stream_3; // rax
  const void **ptr_to_free_7; // rsi
  _QWORD **v104; // rcx
  _QWORD *ptr_to_free_5; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *ptr_to_free_6; // rdi
  _QWORD *ptr_to_free_4; // rcx
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_9; // rbx
  _QWORD *ptr_to_free_8; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_14; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  char *v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *ptr_to_free_28; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 ptr_to_free_26; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *ptr_to_free_27; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  const vraudio::AudioBuffer *ptr_to_free_19; // [rsp+128h] [rbp+88h] BYREF
  __int64 *p_ptr_to_free; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *ptr_to_free_24; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **ptr_to_free_13; // [rsp+158h] [rbp+B8h] BYREF
  unsigned __int64 v136; // [rsp+160h] [rbp+C0h]
  unsigned __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  ptr_to_free_28 = (_QWORD *)ptr_to_free_29;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  _Newcapacity = _Newcapacity_1;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, ptr_to_free_29, _Newcapacity_1);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  ptr_to_free_13 = 0;
  ptr_to_free_15 = 0;
  p_ptr_to_free = (__int64 *)&ptr_to_free_13;
  n0x400 = 0;
  ptr_to_free_14 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !_Newcapacity_1 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  ptr_to_free_25 = ptr_to_free_28;
  v20 = v112;
  ptr_to_free_27 = ptr_to_free_28;
  while ( 2 )
  {
    v21 = *((_BYTE *)ptr_to_free_25 + 0x59) == 0;
    ptr_to_free_24 = ptr_to_free_25;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = ptr_to_free_25;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    ptr_to_free_26 = (unsigned __int64)ptr_to_free_25;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = ptr_to_free_25;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !ptr_to_free_15 )
      {
        __asm { vzeroupper }
        ptr_to_free_14 = (std::vector<vraudio::AudioBuffer const *> *)allocWithoutProfiling(0x18u);
        ptr_to_free_15 = ptr_to_free_14;
        if ( ptr_to_free_14 )
        {
          ptr_to_free_16 = ptr_to_free_14;
          *(_QWORD *)ptr_to_free_14 = 0;
          n0x400_1 = 0;
          *((_QWORD *)ptr_to_free_15 + 1) = 0;
          ptr_to_free_17 = (__int64)ptr_to_free_15;
          *((_QWORD *)ptr_to_free_15 + 2) = 0;
        }
        else
        {
          ptr_to_free_15 = 0;
          ptr_to_free_16 = 0;
          n0x400_1 = 0;
          ptr_to_free_14 = 0;
          ptr_to_free_17 = 0;
        }
        sub_140302260(ptr_to_free_17, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v141;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_16 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)ptr_to_free_16 + 2) )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              ptr_to_free_15,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)ptr_to_free_16 + 1) += 8LL;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        ptr_to_free_25 = ptr_to_free_27;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_15 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)ptr_to_free_15 + 2) )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          ptr_to_free_15,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&ptr_to_free_26);
      }
      else
      {
        *_Whereptr_1 = (const vraudio::AudioBuffer *)ptr_to_free_25;
        *((_QWORD *)ptr_to_free_15 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    ptr_to_free_25[1] = sub_1402FD110(&p_ptr_to_free, ptr_to_free_25);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, unsigned __int64))ptr_to_free_25[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    ptr_to_free_26 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*ptr_to_free_25, &v124, &ptr_to_free_26, v28);
    ptr_to_free_20 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    p_ptr_to_free_1 = p_ptr_to_free;
    do
    {
      ptr_to_free_24 = ptr_to_free_20;
      ptr_to_free_20[0xA] = v18;
      v21 = ptr_to_free_20[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)ptr_to_free_20[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*p_ptr_to_free_1 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)allocWithoutProfiling(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)allocWithoutProfiling(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *p_ptr_to_free_1 = (__int64)v33;
        }
        v35 = (_BYTE *)ptr_to_free_20[1];
        Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&v138, 0, sizeof(v138));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)ptr_to_free_20[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        ptr_to_free_18 = (const vraudio::AudioBuffer *)*p_ptr_to_free_1;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        ptr_to_free_1 = *(__m256 **)v138.m256_f32;
        ptr_to_free_19 = ptr_to_free_18;
        v45 = *(_QWORD **)ptr_to_free_18;
        v46 = **(_QWORD ***)ptr_to_free_18;
        if ( v46 == *(_QWORD **)ptr_to_free_18 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = ptr_to_free_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        ptr_to_free_18 = ptr_to_free_19;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *((_QWORD *)ptr_to_free_18 + 1) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = allocWithoutProfiling(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 0x20) = 0;
          *(_QWORD *)(v51 + 0x28) = 0;
          *(__m256 *)(v51 + 0x10) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*((_QWORD *)ptr_to_free_18 + 1);
          v53 = (__int64 *)v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = v51;
          *v53 = v51;
          v54 = *(_QWORD *)*p_ptr_to_free_1;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 0x28LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            ptr_to_free = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              ptr_to_free = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)ptr_to_free - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(ptr_to_free);
          }
          ptr_to_free_15 = ptr_to_free_14;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            ptr_to_free_10 = ptr_to_free_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              ptr_to_free_1 = *(__m256 **)&ptr_to_free_1[0xFFFFFFFF].m256_f32[6];
              if ( (unsigned __int64)((char *)ptr_to_free_10 - (char *)ptr_to_free_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(ptr_to_free_1);
          }
          ptr_to_free_15 = ptr_to_free_14;
          n0x400_2 = 0;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
        }
      }
      ptr_to_free_20[1] = v55;
      n0x400 = n0xF;
      ptr_to_free_19 = (const vraudio::AudioBuffer *)ptr_to_free_20;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !ptr_to_free_15 )
        {
          __asm { vzeroupper }
          ptr_to_free_21 = (std::vector<vraudio::AudioBuffer const *> *)allocWithoutProfiling(0x18u);
          ptr_to_free_15 = ptr_to_free_21;
          ptr_to_free_14 = ptr_to_free_21;
          if ( ptr_to_free_21 )
          {
            *(_QWORD *)ptr_to_free_21 = 0;
            ptr_to_free_22 = ptr_to_free_21;
            *((_QWORD *)ptr_to_free_21 + 1) = 0;
            ptr_to_free_23 = (__int64)ptr_to_free_21;
            *((_QWORD *)ptr_to_free_21 + 2) = 0;
          }
          else
          {
            ptr_to_free_15 = 0;
            ptr_to_free_14 = 0;
            ptr_to_free_22 = 0;
            ptr_to_free_23 = 0;
          }
          sub_140302260(ptr_to_free_23, _Newcapacity_1);
          __Val_0__1 = (const vraudio::AudioBuffer **)v141;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_22 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)ptr_to_free_22 + 2) )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                ptr_to_free_15,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)ptr_to_free_22 + 1) += 8LL;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          ptr_to_free_20 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_15 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)ptr_to_free_15 + 2) )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            ptr_to_free_15,
            _Whereptr_3,
            &ptr_to_free_19);
        }
        else
        {
          *_Whereptr_3 = (const vraudio::AudioBuffer *)ptr_to_free_20;
          *((_QWORD *)ptr_to_free_15 + 1) += 8LL;
        }
      }
      else
      {
        v141[n0xF] = ptr_to_free_20;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      ptr_to_free_20 += 0xD;
      a13 = v30;
      *(_QWORD *)v116 = ptr_to_free_20;
    }
    while ( v30 < v124 );
    ptr_to_free_25 = ptr_to_free_27;
LABEL_94:
    v28 = v137;
    _Newcapacity = _Newcapacity_1;
    if ( ptr_to_free_26 > 1 )
    {
      v28 = 0xFFFFFFFFFFFFFFFFuLL;
    }
    v64 = &v117[ptr_to_free_26];
    v117 += ptr_to_free_26;
LABEL_98:
    ptr_to_free_25 += 0xD;
    ptr_to_free_27 = ptr_to_free_25;
    ptr_to_free_24[0xA] = v28;
    if ( ++v132 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  v117 = v64;
  if ( !ptr_to_free_15 )
  {
    goto LABEL_106;
  }
  if ( !((__int64)(*((_QWORD *)ptr_to_free_15 + 1) - *(_QWORD *)ptr_to_free_15) >> 3) )
  {
    __debugbreak();
  }
  i = *(char **)ptr_to_free_15;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 0x50LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 0x50LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 0x50) = -(__int64)(*(_QWORD *)(v71 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (_QWORD)(v65 + 1) << 0xA;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    ptr_to_free_3 = 0;
  }
  else
  {
    ptr_to_free_11 = allocWithoutProfiling(Size);
    ptr_to_free_3 = (const void *)ptr_to_free_11;
    if ( ptr_to_free_11 )
    {
      Buffer_1 = (char *)ptr_to_free_11;
      goto LABEL_131;
    }
  }
  v79 = Size + 0xF;
  if ( Size + 0xF < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && off_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, ptr_to_free_28, _Newcapacity_1, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            ptr_to_free_28,
            _Newcapacity_1,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    fprintf(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    fprintf(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((_QWORD)&v117[2 * (_QWORD)v117 + 0x20 + n0xF] << 7);
    }
    n0x8000_2 = v93 + 0x80;
    if ( *p_n0x8000_1 < v93 + 0x80 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      ptr_to_free_2 = 0;
    }
    else
    {
      ptr_to_free_12 = allocWithoutProfiling(n0x8000_2);
      ptr_to_free_2 = (const void *)ptr_to_free_12;
      if ( ptr_to_free_12 )
      {
        Buffer_2 = (double *)ptr_to_free_12;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 0xF;
    if ( n0x8000_2 + 0xF < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      ptr_to_free_28,
      _Newcapacity_1,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 0x80,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(ptr_to_free_2);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  free_memory_wrapper(ptr_to_free_3);
  ptr_to_free_7 = ptr_to_free_13;
  if ( ptr_to_free_13 )
  {
    v104 = (_QWORD **)*ptr_to_free_13;
    **((_QWORD **)*ptr_to_free_13 + 1) = 0;
    ptr_to_free_5 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = ptr_to_free_5[5];
        ptr_to_free_6 = (_QWORD *)*ptr_to_free_5;
        if ( n0xF_2 > 0xF )
        {
          ptr_to_free_4 = (_QWORD *)ptr_to_free_5[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)ptr_to_free_4 - ptr_to_free_4[0xFFFFFFFF] - 8 > 0x1F )
            {
              goto LABEL_191;
            }
            ptr_to_free_4 = (_QWORD *)ptr_to_free_4[0xFFFFFFFF];
          }
          free_memory_wrapper(ptr_to_free_4);
        }
        ptr_to_free_5[4] = 0;
        ptr_to_free_5[5] = 0xF;
        *((_BYTE *)ptr_to_free_5 + 0x10) = 0;
        free_memory_wrapper(ptr_to_free_5);
        ptr_to_free_5 = ptr_to_free_6;
      }
      while ( ptr_to_free_6 );
    }
    free_memory_wrapper(*ptr_to_free_7);
    free_memory_wrapper(ptr_to_free_7);
  }
  ptr_to_free_9 = ptr_to_free_14;
  if ( ptr_to_free_14 )
  {
    ptr_to_free_8 = *(_QWORD **)ptr_to_free_14;
    if ( *(_QWORD *)ptr_to_free_14 )
    {
      if ( ((*((_QWORD *)ptr_to_free_14 + 2) - (_QWORD)ptr_to_free_8) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)ptr_to_free_8 - ptr_to_free_8[0xFFFFFFFF] - 8 > 0x1F )
        {
LABEL_191:
          invalid_parameter_noinfo_noreturn();
        }
        ptr_to_free_8 = (_QWORD *)ptr_to_free_8[0xFFFFFFFF];
      }
      free_memory_wrapper(ptr_to_free_8);
      *(_QWORD *)ptr_to_free_9 = 0;
      *((_QWORD *)ptr_to_free_9 + 1) = 0;
      *((_QWORD *)ptr_to_free_9 + 2) = 0;
    }
    free_memory_wrapper(ptr_to_free_9);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: j_DestroyStringObject (0x140309E80) ---
// attributes: thunk
void __fastcall j_DestroyStringObject(_QWORD *ppStringObjectData)
{
  DestroyStringObject(ppStringObjectData);
}

// --- End Function: j_DestroyStringObject (0x140309E80) ---

// --- Function: is_valid_handle_typeA (0x14030C820) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *packed_handle_ptr)
{
  __int64 packed_handle_value; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 metadata_type; // cx

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_metadata_ptr = get_handle_metadata_ptr(packed_handle_value & 0xFFFFFFFFFFFFLL);
  metadata_type = *(_WORD *)(handle_metadata_ptr + 4);
  if ( metadata_type == 4 || *(_WORD *)(handle_metadata_ptr + 2) != (HIWORD(packed_handle_value) & 0xFFF) )
  {
    return 0;
  }
  if ( metadata_type != 2 || *(_QWORD *)get_tls_data_offset_784() )
  {
    return check_handle_access_by_state(packed_handle_ptr) != 0;
  }
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030C820) ---

// --- Function: is_valid_handle_typeB (0x14030C8B0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *packed_handle_ptr)
{
  unsigned __int64 packed_handle_value; // r9
  __int64 handle_ptr; // r10
  unsigned __int64 handle_flags; // r9
  __int64 mask_from_flag; // rax
  __int64 handle_ptr_copy; // r10
  __int64 metadata_ptr; // rbx
  bool is_thread_state_ok; // al

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_ptr = packed_handle_value & 0xFFFFFFFFFFFFLL;
  handle_flags = HIWORD(packed_handle_value);
  if ( (handle_flags & 0xF000) != 0 )
  {
    mask_from_flag = map_flag_to_mask(0x2000u);
    metadata_ptr = handle_ptr_copy & ~(mask_from_flag - 1);
  }
  else
  {
    metadata_ptr = handle_ptr - 6;
  }
  if ( *(_WORD *)(metadata_ptr + 2) != (handle_flags & 0xFFF) )
  {
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (is_thread_state_ok = is_thread_flag_57_or_38_set()) )
  {
    is_thread_state_ok = 1;
  }
  return *(_WORD *)(metadata_ptr + 4) == 2 && is_thread_state_ok
      || check_handle_access_by_state_extended(packed_handle_ptr) != 0;
}

// --- End Function: is_valid_handle_typeB (0x14030C8B0) ---

// --- Function: check_handle_access_by_state (0x14031DD70) ---
// Checks access permissions for the provided packed handle. Retrieves handle
// metadata using `get_handle_metadata`. Validates access based on the state field
// (metadata + 4): - State 0: Returns false (invalid). - State 1: Checks if the
// handle's payload exists in a thread-local list using
// `check_thread_list_contains_value`. - State 2: Returns true if specific thread
// flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3: Checks thread
// state and compares the payload value against a constant using
// `check_thread_state_and_value_not_equal`. - Other states: Return false.
char __fastcall check_handle_access_by_state(_QWORD *packed_handle_ptr)
{
  __int64 handle_value; // rbx
  __int64 metadata_ptr; // rax
  _QWORD *payload_ptr; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  handle_value = *packed_handle_ptr & 0xFFFFFFFFFFFFLL;
  metadata_ptr = get_handle_metadata_ptr(handle_value);
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    payload_ptr_state1 = get_handle_payload_ptr(handle_value);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( *(_WORD *)(metadata_ptr + 4) == 3 )
    {
      payload_ptr = (_QWORD *)get_handle_payload_ptr(handle_value);
      return check_thread_state_and_value_not_equal(payload_ptr);
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  payload_ptr_state2 = get_handle_payload_ptr(handle_value);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: check_handle_access_by_state (0x14031DD70) ---

// --- Function: IEntity::GetTransformComponent (0x140330BC0) ---
// “Component pointer” fetch.
// 
// Inside every Cry/Star‑Engine object the first 0×40 bytes
// are the base IEntity header.
// 
// Offset +0×40 traditionally stores a pointer to that
// entity’s first CComponentTransform (or derived) instance.
__int64 __fastcall IEntity::GetTransformComponent(__int64 this)
{
  return *(_QWORD *)(this + 0x40);
}

// --- End Function: IEntity::GetTransformComponent (0x140330BC0) ---

// --- Function: sub_14034F0C0 (0x14034F0C0) ---
char __fastcall sub_14034F0C0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        _QWORD *arg48)
{
  __int64 a8; // [rsp+18h] [rbp-E8h]
  __int64 a5[11]; // [rsp+30h] [rbp-D0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-78h]
  __int64 n0xB0; // [rsp+90h] [rbp-70h]
  _QWORD *v15; // [rsp+98h] [rbp-68h]
  uint64_t **p_EntityId; // [rsp+A0h] [rbp-60h]
  __int64 v17; // [rsp+A8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6A60)(__int64, __int64, __int64); // [rsp+B0h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E6420)(__int64, _BYTE *, unsigned __int64); // [rsp+B8h] [rbp-48h]
  __int64 v20; // [rsp+C0h] [rbp-40h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+C8h] [rbp-38h]
  __int64 v22; // [rsp+D0h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+D8h] [rbp-28h]
  __int64 (__fastcall *p_sub_1403E00D0)(__int64); // [rsp+E0h] [rbp-20h]
  unsigned __int64 v25; // [rsp+E8h] [rbp-18h]
  char v26; // [rsp+F0h] [rbp-10h]
  char v27; // [rsp+F1h] [rbp-Fh]
  __int64 n0x18; // [rsp+F8h] [rbp-8h]

  a5[0] = arg40;
  n0x100 = 0x100;
  a5[1] = (__int64)"TraceContext";
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v15 = arg48;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  a5[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  p_EntityId = "EntityId";
  v27 = 1;
  v17 = *arg48;
  p_sub_1403E6A60 = sub_1403E6A60;
  p_sub_1403E6420 = sub_1403E6420;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w;
  p_sub_1403E00D0 = sub_1403E00D0;
  LODWORD(a8) = a6;
  v20 = 0;
  v22 = 0;
  v25 = 0xFFFFFFFFFFFFFFFFuLL;
  v26 = 0;
  n0x18 = 0x18;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 2, a7, a8, a9, a10);
}

// --- End Function: sub_14034F0C0 (0x14034F0C0) ---

// --- Function: sub_1403577C0 (0x1403577C0) ---
void **__fastcall sub_1403577C0(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149808ABC + 4;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
    {
      memcpy(*a1, *a2, Size);
    }
  }
  return a1;
}

// --- End Function: sub_1403577C0 (0x1403577C0) ---

// --- Function: CreateStringObjectFromString (0x140357920) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **__fastcall CreateStringObjectFromString(void **ppStringObjectData, _BYTE *pszInputString)
{
  unsigned __int64 inputStringLength; // rbx
  _DWORD *pAllocatedBuffer; // rax

  *ppStringObjectData = (char *)&qword_149808ABC + 4;
  if ( !pszInputString )
  {
    return ppStringObjectData;
  }
  inputStringLength = 0xFFFFFFFFFFFFFFFFuLL;
  do
  {
    ++inputStringLength;
  }
  while ( pszInputString[inputStringLength] );
  if ( (_DWORD)inputStringLength )
  {
    pAllocatedBuffer = (_DWORD *)allocWithProfilerInfo((int)inputStringLength + 9LL, 0);
    *ppStringObjectData = pAllocatedBuffer + 2;
    *pAllocatedBuffer = inputStringLength;
    pAllocatedBuffer[1] = inputStringLength;
    *((_BYTE *)*ppStringObjectData + (int)inputStringLength) = 0;
    if ( *ppStringObjectData != pszInputString )
    {
      memcpy(*ppStringObjectData, pszInputString, (int)inputStringLength);
    }
  }
  return ppStringObjectData;
}

// --- End Function: CreateStringObjectFromString (0x140357920) ---

// --- Function: sub_1403588A0 (0x1403588A0) ---
_BYTE *__fastcall sub_1403588A0(_BYTE *a1, char a2)
{
  *a1 = a2;
  return a1;
}

// --- End Function: sub_1403588A0 (0x1403588A0) ---

// --- Function: sub_14036D0B0 (0x14036D0B0) ---
__int64 __fastcall sub_14036D0B0(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx

  v1 = *(volatile signed __int32 **)(a1 + 0x18);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
      {
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
      }
    }
  }
  v4 = *(volatile signed __int32 **)(a1 + 8);
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
      {
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
      }
    }
  }
  return result;
}

// --- End Function: sub_14036D0B0 (0x14036D0B0) ---

// --- Function: DestroyStringObject (0x14036D270) ---
// Deallocates the memory buffer associated with a string object created by
// `CreateStringObjectFromString`.  It accesses metadata stored 8 bytes before the
// provided data pointer to get the allocation base pointer required by the
// deallocation function `sub_14739AF10`.  @param ppStringObjectData Pointer to the
// variable holding the pointer to the string object's data.
void __fastcall DestroyStringObject(_QWORD *ppStringObjectData)
{
  int *pStringMetadata; // rcx

  pStringMetadata = (int *)(*ppStringObjectData - 8LL);
  if ( pStringMetadata[1] > 0 )
  {
    sub_14739AF10(pStringMetadata);
  }
}

// --- End Function: DestroyStringObject (0x14036D270) ---

// --- Function: check_thread_list_contains_value (0x14038E3B0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 thread_data; // rbx
  unsigned __int64 *v3; // rax
  char *list_begin_1; // r10
  char *list_begin; // rcx
  unsigned __int64 search_value; // rdx
  unsigned __int64 search_range_count; // r8
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) )
  {
    return 0;
  }
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &vf_output_temp);
  list_begin_1 = *(char **)(thread_data + 0x18);
  list_begin = *(char **)(thread_data + 0x10);
  search_value = *v3;
  search_range_count = (list_begin_1 - list_begin) >> 4;
  while ( search_range_count )
  {
    if ( *(_QWORD *)&list_begin[0x10 * (search_range_count >> 1)] >= search_value )
    {
      search_range_count >>= 1;
    }
    else
    {
      list_begin += 0x10 * (search_range_count >> 1) + 0x10;
      search_range_count += 0xFFFFFFFFFFFFFFFFuLL - (search_range_count >> 1);
    }
  }
  if ( list_begin == list_begin_1 )
  {
    return 0;
  }
  if ( search_value < *(_QWORD *)list_begin )
  {
    list_begin = *(char **)(thread_data + 0x18);
  }
  return list_begin != list_begin_1;
}

// --- End Function: check_thread_list_contains_value (0x14038E3B0) ---

// --- Function: check_thread_state_and_value_not_equal (0x14038E470) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *value_ptr)
{
  __int64 thread_data; // rax

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
  return thread_data && *(_DWORD *)(thread_data + 8) == 1 && *value_ptr != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x14038E470) ---

// --- Function: validate_access_with_virtual_calls (0x14038E4B0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 thread_data; // rax
  __int64 global_validator_object; // rdi
  __int64 (__fastcall *global_validator_vtable)(__int64, _QWORD); // rbx
  _QWORD *value_from_object_ptr; // rax
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_tls_data_offset_784() )
  {
    return 1;
  }
  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) || !is_illegal_entity_access_check_enabled() )
  {
    return 1;
  }
  global_validator_object = ::global_validator_object;
  global_validator_vtable = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::global_validator_object + 0x3D8LL);
  value_from_object_ptr = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                                      payload_ptr_state2,
                                      &vf_output_temp);
  return global_validator_vtable(global_validator_object, *value_from_object_ptr);
}

// --- End Function: validate_access_with_virtual_calls (0x14038E4B0) ---

// --- Function: check_indirect_handle_access_by_state (0x14038E530) ---
// Checks access permissions for a handle stored indirectly. Takes a pointer `a1`
// to a structure containing a primary packed handle. Extracts the primary handle
// `v1 = *a1 & 0xFFFFFFFFFFFFLL`. Retrieves metadata for `v1` using
// `get_handle_metadata`. Validates access based on the state field (metadata + 4):
// - State 0: Returns false. - State 1: Extracts payload handle from `*(v1 + 8)`
// and calls `check_thread_list_contains_value`. - State 2: Extracts payload handle
// from `*(v1 + 8)`; returns true if thread flags set, otherwise calls
// `validate_access_with_virtual_calls` on payload handle. - State 3: Extracts
// payload handle from `*(v1 + 8)`; checks thread state and compares payload handle
// value against 0x13374770CLL. - Other states: Return false.
char __fastcall check_indirect_handle_access_by_state(_QWORD *packed_handle_owner_ptr)
{
  __int64 primary_handle_value; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  primary_handle_value = *packed_handle_owner_ptr & 0xFFFFFFFFFFFFLL;
  metadata_ptr = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
                   global_validator_object,
                   primary_handle_value,
                   0);
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( *(_WORD *)(metadata_ptr + 4) == 3 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *(_QWORD *)(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL);
  }
}

// --- End Function: check_indirect_handle_access_by_state (0x14038E530) ---

// --- Function: sub_14039FB00 (0x14039FB00) ---
__int64 __fastcall sub_14039FB00(_QWORD *a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = (volatile signed __int32 *)a1[1];
  result = 0;
  *a1 = 0;
  a1[1] = 0;
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
      {
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
      }
    }
  }
  return result;
}

// --- End Function: sub_14039FB00 (0x14039FB00) ---

// --- Function: get_handle_payload_ptr (0x1403AC8D0) ---
// Retrieves the QWORD value at offset +8 from the structure pointed to by
// `metadata_or_object_ptr` and returns its lower 48 bits (masked with
// 0xFFFFFFFFFFFF). This likely extracts an embedded payload pointer or handle.
__int64 __fastcall get_handle_payload_ptr(__int64 metadata_or_object_ptr)
{
  return *(_QWORD *)(metadata_or_object_ptr + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: get_handle_payload_ptr (0x1403AC8D0) ---

// --- Function: sub_1403AC900 (0x1403AC900) ---
_QWORD *__fastcall sub_1403AC900(unsigned __int64 *a1, _QWORD *a2)
{
  if ( is_valid_handle_typeB(a1) )
  {
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1403AC900 (0x1403AC900) ---

// --- Function: get_handle_metadata_ptr (0x1403B0A30) ---
// Retrieves a pointer to the metadata structure associated with the given handle.
// Calls the virtual function at offset +296 on the global object
// `global_validator_object`, passing the handle.
__int64 __fastcall get_handle_metadata_ptr(__int64 handle_value)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
           global_validator_object,
           handle_value,
           0);
}

// --- End Function: get_handle_metadata_ptr (0x1403B0A30) ---

// --- Function: get_event_key_from_source_location (0x1403B78D0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(
        _DWORD *out_event_key_ptr,
        __int64 source_file_path,
        __int64 source_line_number)
{
  FARPROC get_event_key_func_ptr; // rbx
  HMODULE current_module_handle; // rax
  HMODULE hModule; // rax
  __int64 event_key_func_ptr; // rax

  get_event_key_func_ptr = (FARPROC)_GetEventKey___0;
  if ( !_GetEventKey___0 )
  {
    current_module_handle = GetModuleHandleA(0);
    get_event_key_func_ptr = GetProcAddress(current_module_handle, "__GetEventKey__");
    if ( !get_event_key_func_ptr )
    {
      hModule = LoadLibraryA(0);
      if ( hModule )
      {
        get_event_key_func_ptr = GetProcAddress(hModule, "__GetEventKey__");
      }
    }
    _GetEventKey___0 = (__int64)get_event_key_func_ptr;
  }
  event_key_func_ptr = ((__int64 (__fastcall *)(__int64, __int64))get_event_key_func_ptr)(
                         source_file_path,
                         source_line_number);
  *out_event_key_ptr = event_key_func_ptr;
  return event_key_func_ptr;
}

// --- End Function: get_event_key_from_source_location (0x1403B78D0) ---

// --- Function: sub_1403BB9F0 (0x1403BB9F0) ---
bool __fastcall sub_1403BB9F0(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BB9F0 (0x1403BB9F0) ---

// --- Function: allocWithoutProfiling_w (0x1403DFFB0) ---
__int64 allocWithoutProfiling_w()
{
  return allocWithoutProfiling(1u);
}

// --- End Function: allocWithoutProfiling_w (0x1403DFFB0) ---

// --- Function: sub_1403E00D0 (0x1403E00D0) ---
__int64 __fastcall sub_1403E00D0(__int64 a1)
{
  __int64 result; // rax

  result = allocWithoutProfiling(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 0x10) = *(double *)(a1 + 0x10);
  }
  return result;
}

// --- End Function: sub_1403E00D0 (0x1403E00D0) ---

// --- Function: free_memory_wrapper_w_1 (0x1403E02C0) ---
void __fastcall free_memory_wrapper_w_1(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w_1 (0x1403E02C0) ---

// --- Function: free_memory_wrapper_w (0x1403E0310) ---
void __fastcall free_memory_wrapper_w(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w (0x1403E0310) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---

// --- Function: sub_1403E2C50 (0x1403E2C50) ---
char __fastcall sub_1403E2C50(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1403E2C50 (0x1403E2C50) ---

// --- Function: sub_1403E6420 (0x1403E6420) ---
__int64 __fastcall sub_1403E6420(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 0x10) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 0x22;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      v6 = sub_1403570D0((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FC400((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
  {
    return 0xFFFFFFFFLL;
  }
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
  {
    return 0xFFFFFFFFLL;
  }
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 0x22;
    }
    else
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403E6420 (0x1403E6420) ---

// --- Function: sub_1403E6700 (0x1403E6700) ---
__int64 __fastcall sub_1403E6700(__int64 a1, __int64 a2, unsigned __int64 n12)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n12 > 0 )
  {
    if ( n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n12 <= 0xC )
      {
        goto LABEL_52;
      }
    }
    v8 = sub_1404EEAB0((unsigned __int8 *)a1, (_BYTE *)((unsigned int)n0xC + a2), n12 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v10 = sub_1404EE450((unsigned __int8 *)a1, (_BYTE *)(n0xC + a2), n12 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v12 = sub_1404EE6A0((unsigned __int8 *)a1, (_BYTE *)(n0xC + a2), n12 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v14 = sub_1404EE300((unsigned __int8 *)a1, (_BYTE *)(n0xC + a2), n12 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n12 )
    {
LABEL_46:
      if ( n12 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
  {
    return 0xFFFFFFFF;
  }
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403E6700 (0x1403E6700) ---

// --- Function: sub_1403E6A60 (0x1403E6A60) ---
__int64 __fastcall sub_1403E6A60(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 0x10) )
  {
    return sub_1403570D0(a2, a3, 0, v3);
  }
  else
  {
    return sub_1402FC400(a2, a3, 0, v3);
  }
}

// --- End Function: sub_1403E6A60 (0x1403E6A60) ---

// --- Function: sub_1403E6C00 (0x1403E6C00) ---
// attributes: thunk
__int64 __fastcall sub_1403E6C00(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404EEAB0(a1, a2, n0x21);
}

// --- End Function: sub_1403E6C00 (0x1403E6C00) ---

// --- Function: sub_14044FC50 (0x14044FC50) ---
void **__fastcall sub_14044FC50(void **ppStringObjectData, const void **a2, int a3)
{
  void **ppStringObjectData_1; // rax

  sub_1403577C0(ppStringObjectData, a2);
  ppStringObjectData_1 = ppStringObjectData;
  *((_DWORD *)ppStringObjectData + 2) = a3;
  return ppStringObjectData_1;
}

// --- End Function: sub_14044FC50 (0x14044FC50) ---

// --- Function: sub_1404AE300 (0x1404AE300) ---
_QWORD *sub_1404AE300()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  if ( !v0 )
  {
    sub_140535CF0((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithoutProfiling(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_147E52AF0);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404AE300 (0x1404AE300) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 0xF;
  }
  return (__int64 *)&tls_log_structure_1[0x16 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: is_thread_flag_57_or_38_set (0x140535D40) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 thread_data_ptr_offset_16; // rcx

  thread_data_ptr_offset_16 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  if ( thread_data_ptr_offset_16 )
  {
    return *(_BYTE *)(thread_data_ptr_offset_16 + 0x39) != 0;
  }
  else
  {
    return *(_BYTE *)(get_tls_data_offset_784() + 0x26) != 0;
  }
}

// --- End Function: is_thread_flag_57_or_38_set (0x140535D40) ---

// --- Function: sub_140593A60 (0x140593A60) ---
_QWORD *__fastcall sub_140593A60(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_140593A60 (0x140593A60) ---

// --- Function: sub_140593C00 (0x140593C00) ---
__m128 __fastcall sub_140593C00(double _XMM0_8)
{
  __int128 v4; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v4 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v4 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v4;
}

// --- End Function: sub_140593C00 (0x140593C00) ---

// --- Function: sub_1405BD4A0 (0x1405BD4A0) ---
__int64 sub_1405BD4A0(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_14981D3D8 && CSystem )
  {
    if ( a3 )
    {
      return (*(__int64 (__fastcall **)(Parameter *, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)CSystem + 0x158LL))(
               CSystem,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
    }
  }
  return result;
}

// --- End Function: sub_1405BD4A0 (0x1405BD4A0) ---

// --- Function: sub_1411B0760 (0x1411B0760) ---
__int64 __fastcall sub_1411B0760(_BYTE *a1, unsigned __int8 *a2)
{
  __int64 result; // rax

  result = *a2;
  *a1 = result;
  return result;
}

// --- End Function: sub_1411B0760 (0x1411B0760) ---

// --- Function: sub_141332A30 (0x141332A30) ---
__int64 __fastcall sub_141332A30(__int64 global_validator_object, __int64 a2, __int64 a3)
{
  int event_key_from_source_location; // eax
  __int64 v7; // [rsp+20h] [rbp-38h] BYREF
  int event_key_from_source_location_1; // [rsp+28h] [rbp-30h]
  __int64 v9; // [rsp+30h] [rbp-28h]
  void (__fastcall *__StarEngineModule_)(ULONG_PTR); // [rsp+38h] [rbp-20h]
  __int64 (__fastcall *p_sub_1411B0760)(_BYTE *, unsigned __int8 *); // [rsp+40h] [rbp-18h]

  event_key_from_source_location = event_key_from_source_location_129;
  v7 = a3;
  if ( !event_key_from_source_location_129 )
  {
    event_key_from_source_location = get_event_key_from_source_location(
                                       &event_key_from_source_location_129,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/LawSystem/LawEvents.h",
                                       0x110);
  }
  event_key_from_source_location_1 = event_key_from_source_location;
  v9 = 1;
  __StarEngineModule_ = _StarEngineModule__;
  p_sub_1411B0760 = sub_1411B0760;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)global_validator_object + 0x358LL))(
           global_validator_object,
           a2,
           &v7);
}

// --- End Function: sub_141332A30 (0x141332A30) ---

// --- Function: sub_1414F7D10 (0x1414F7D10) ---
__int64 __fastcall sub_1414F7D10(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  sub_1403577C0((void **)a1, (const void **)a2);
  result = *(unsigned int *)(a2 + 8);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_1414F7D10 (0x1414F7D10) ---

// --- Function: sub_1414F8170 (0x1414F8170) ---
__int64 __fastcall sub_1414F8170(__int64 a1, _QWORD *a2)
{
  unsigned __int8 (__fastcall ***v4)(_QWORD, _QWORD); // rcx
  bool v5; // al

  if ( (*(_BYTE *)(a1 + 0x1A) & 1) == 0 )
  {
    v4 = (unsigned __int8 (__fastcall ***)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 0x10) & 0xFFFFFFFFFFFFLL);
    v5 = !v4 || (**v4)(v4, *(_WORD *)(a1 + 0x18) & 0x3FFF);
    *(_BYTE *)(a1 + 0x1A) &= ~1u;
    *(_BYTE *)(a1 + 0x1A) |= v5;
  }
  sub_1402F9BE0((_QWORD *)(a1 + 8), a2);
  return a1;
}

// --- End Function: sub_1414F8170 (0x1414F8170) ---

// --- Function: sub_1414F9D60 (0x1414F9D60) ---
_QWORD *__fastcall sub_1414F9D60(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_105; // ax
  __int16 n0xFFFF_105_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( is_valid_handle_typeB(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x338LL);
    n0xFFFF_105 = ::n0xFFFF_105;
    if ( ::n0xFFFF_105 == (__int16)0xFFFF )
    {
      n0xFFFF_105 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                       + 0x10LL))(
                                global_dispatcher_ptr,
                                &v8,
                                "IWallet");
      ::n0xFFFF_105 = n0xFFFF_105;
    }
    n0xFFFF_105_1 = n0xFFFF_105;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_105_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_1414F9D60 (0x1414F9D60) ---

// --- Function: sub_1414FD270 (0x1414FD270) ---
_QWORD *__fastcall sub_1414FD270(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_106; // ax
  __int16 n0xFFFF_106_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( is_valid_handle_typeB(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x338LL);
    n0xFFFF_106 = ::n0xFFFF_106;
    if ( ::n0xFFFF_106 == (__int16)0xFFFF )
    {
      n0xFFFF_106 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                       + 0x10LL))(
                                global_dispatcher_ptr,
                                &v8,
                                "ISCPlayerPUSpawningComponent");
      ::n0xFFFF_106 = n0xFFFF_106;
    }
    n0xFFFF_106_1 = n0xFFFF_106;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_106_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_1414FD270 (0x1414FD270) ---

// --- Function: sub_14151DCB0 (0x14151DCB0) ---
bool __fastcall sub_14151DCB0(__int64 a1, __int64 a2)
{
  __int64 gameContext2; // rax
  __int64 gameContext2_1; // r14
  __int64 p_finalCallbackFunc_1; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 n4_1; // dx
  __int64 v9; // rax
  __int16 v10; // rbx^6
  __int64 v11; // rsi
  __int64 handle_metadata_ptr_1; // rax
  __int16 n4; // cx
  __int64 v14; // rdx
  __int64 v15; // rbx
  __int64 v16; // rcx
  float v17; // xmm1_4
  float v18; // kr00_4
  __int64 v19; // rax
  _QWORD *CurrentTicks; // rax
  bool result; // al
  __int64 p_finalCallbackFunc; // [rsp+50h] [rbp+8h] BYREF
  __int64 v23; // [rsp+58h] [rbp+10h] BYREF
  __int64 finalCallbackFunc; // [rsp+60h] [rbp+18h] BYREF

  v23 = *(_QWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)qword_14981D260 + 0x38LL))(qword_14981D260, 0);
  gameContext2 = sub_1417C24D0();
  gameContext2_1 = gameContext2;
  if ( gameContext2 )
  {
    LawComponent::ComputeFine(gameContext2, &p_finalCallbackFunc, *(_DWORD *)(a1 + 0xC40));
    *(_QWORD *)(a2 + 0x18) = *LawComponent::ComputeFine(
                                gameContext2_1,
                                &finalCallbackFunc,
                                *(_DWORD *)(a1 + 0xC40) + *(_DWORD *)(a1 + 0xC44));
    *(_QWORD *)(a2 + 0x10) = *sub_140593A60((_QWORD *)(a2 + 0x18), &finalCallbackFunc, &p_finalCallbackFunc);
  }
  if ( *(__int64 *)(a1 + 0xC38) > 0 )
  {
    *(_QWORD *)a2 = *sub_140593A60(&v23, &p_finalCallbackFunc, (_QWORD *)(a1 + 0xC38));
  }
  p_finalCallbackFunc_1 = *(_QWORD *)(a1 + 0x260);
  p_finalCallbackFunc = p_finalCallbackFunc_1;
  if ( p_finalCallbackFunc_1 )
  {
    handle_metadata_ptr = get_handle_metadata_ptr(p_finalCallbackFunc_1 & 0xFFFFFFFFFFFFLL);
    n4_1 = *(_WORD *)(handle_metadata_ptr + 4);
    if ( n4_1 != 4
      && *(_WORD *)(handle_metadata_ptr + 2) == (HIWORD(p_finalCallbackFunc_1) & 0xFFF)
      && (n4_1 == 2 && !*(_QWORD *)get_tls_data_offset_784()
       || check_indirect_handle_access_by_state(&p_finalCallbackFunc)) )
    {
      v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(p_finalCallbackFunc_1 & 0xFFFFFFFFFFFFLL) + 0x640LL))(p_finalCallbackFunc_1 & 0xFFFFFFFFFFFFLL);
      if ( v9 )
      {
        sub_1414F9D60(v9, &p_finalCallbackFunc);
        v10 = HIWORD(p_finalCallbackFunc);
        if ( p_finalCallbackFunc )
        {
          v11 = p_finalCallbackFunc & 0xFFFFFFFFFFFFLL;
          handle_metadata_ptr_1 = get_handle_metadata_ptr(p_finalCallbackFunc & 0xFFFFFFFFFFFFLL);
          n4 = *(_WORD *)(handle_metadata_ptr_1 + 4);
          if ( n4 != 4
            && *(_WORD *)(handle_metadata_ptr_1 + 2) == (v10 & 0xFFF)
            && (n4 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_handle_access_by_state(&p_finalCallbackFunc)) )
          {
            LOBYTE(v14) = 3;
            v15 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 0x570LL))(v11, v14);
            v16 = *(_QWORD *)(sub_1417C24D0() + 0x28);
            if ( v16 && (v17 = *(float *)(v16 + 0x4C), v17 > 0.0) && v15 > 0 )
            {
              v18 = (float)v15;
              v19 = (unsigned int)(int)(float)((float)(v18 / v17) * 600000000.0);
            }
            else
            {
              v19 = 0;
            }
            *(_QWORD *)(a2 + 8) = v19;
            *(_QWORD *)(a2 + 0x28) = v15;
          }
        }
      }
    }
  }
  CurrentTicks = g_GameTimer_GetCurrentTicks((_QWORD *)a2, &p_finalCallbackFunc, (_QWORD *)(a2 + 8));
  result = sub_140593B00(CurrentTicks, (_QWORD *)(a2 + 0x18));
  *(_BYTE *)(a2 + 0x20) = result;
  return result;
}

// --- End Function: sub_14151DCB0 (0x14151DCB0) ---

// --- Function: sub_141527750 (0x141527750) ---
void __fastcall sub_141527750(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(__int64, __int64 *, __int64); // rbx
  __int64 v5; // rax
  __int16 v6; // rbx^6
  __int64 v7; // rdi
  __int64 handle_metadata_ptr; // rax
  __int16 n4_1; // cx
  __int16 v10; // rbx^6
  _QWORD *v11; // rdi
  __int64 handle_metadata_ptr_1; // rax
  __int16 n4; // cx
  __int64 v14; // [rsp+48h] [rbp+10h] BYREF
  __int64 v15; // [rsp+50h] [rbp+18h] BYREF
  __int64 v16; // [rsp+58h] [rbp+20h] BYREF

  if ( byte_14981D4A0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 0x20LL))(a1, &v14);
    v2 = v14;
    if ( v14
      || ((*(int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) <= 1
        ? (v2 = v14)
        : (v3 = qword_14981D350,
           v4 = *(__int64 (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)qword_14981D350 + 0x40LL),
           v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x10LL))(a1, 1),
           v2 = *(_QWORD *)v4(v3, &v15, v5),
           v14 = v2),
          v2) )
    {
      sub_14041F510(&v15, v2);
      v6 = HIWORD(v15);
      if ( v15 )
      {
        v7 = v15 & 0xFFFFFFFFFFFFLL;
        handle_metadata_ptr = get_handle_metadata_ptr(v15 & 0xFFFFFFFFFFFFLL);
        n4_1 = *(_WORD *)(handle_metadata_ptr + 4);
        if ( n4_1 != 4
          && *(_WORD *)(handle_metadata_ptr + 2) == (v6 & 0xFFF)
          && (n4_1 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_indirect_handle_access_by_state(&v15)) )
        {
          (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v7 + 0x5B8LL))(v7, &v15);
          if ( AssetMeta::HasActorSubresource(&v15) )
          {
            sub_1413264C0(&v16, *(_QWORD *)((v15 & 0xFFFFFFFFFFFFLL) + 8));
            v10 = HIWORD(v16);
            if ( v16 )
            {
              v11 = (_QWORD *)(v16 & 0xFFFFFFFFFFFFLL);
              handle_metadata_ptr_1 = get_handle_metadata_ptr(v16 & 0xFFFFFFFFFFFFLL);
              n4 = *(_WORD *)(handle_metadata_ptr_1 + 4);
              if ( n4 != 4
                && *(_WORD *)(handle_metadata_ptr_1 + 2) == (v10 & 0xFFF)
                && (n4 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_handle_access_by_state(&v16)) )
              {
                if ( v11 )
                {
                  sub_14156D2A0(v11, 1);
                }
              }
            }
          }
        }
      }
    }
    else
    {
      (*(void (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_14981D2D0 + 0x70LL))(
        qword_14981D2D0,
        "law.setPrisonSpawn: Invalid player invoker!");
    }
  }
}

// --- End Function: sub_141527750 (0x141527750) ---

// --- Function: sub_141535570 (0x141535570) ---
__int64 __fastcall sub_141535570(__int64 a1)
{
  __int64 v1; // rdi
  int v3; // ebx
  unsigned __int32 v4; // eax
  char *v5; // rbx
  unsigned int v6; // r14d
  char *v7; // r15
  __int64 v8; // rax
  __int64 v9; // rsi
  bool v10; // al
  int v11; // ecx
  __int64 result; // rax
  unsigned __int32 v13; // eax
  __int64 v14; // [rsp+50h] [rbp+8h]

  v1 = a1 + 0xF8;
  v14 = a1 + 0xF8;
  v3 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( *(_DWORD *)(v1 + 4) == v3 )
  {
    ++*(_DWORD *)(v1 + 8);
  }
  else
  {
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 1, 0);
    if ( v4 )
    {
      sub_1403BF290((volatile signed __int32 *)v1, v4, (__int64)"CJurisdictionRoomExtension::GetPrisonerPopulation", 1);
    }
    *(_DWORD *)(v1 + 4) = v3;
  }
  v5 = *(char **)(a1 + 0x108);
  v6 = 0;
  if ( v5 != *(char **)(a1 + 0x110) )
  {
    v7 = v5 + 8;
    do
    {
      if ( !*(_QWORD *)v5 )
      {
        goto LABEL_20;
      }
      v8 = HIWORD(*(_QWORD *)v5);
      v9 = (v8 & 0xF000) != 0 ? *(_QWORD *)v5 & 0xFFFFFF000000LL : (*(_QWORD *)v5 & 0xFFFFFFFFFFFFLL) - 6;
      if ( *(_WORD *)(v9 + 2) != (v8 & 0xFFF) )
      {
        goto LABEL_20;
      }
      if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v10 = is_thread_flag_57_or_38_set()) )
      {
        v10 = 1;
      }
      if ( *(_WORD *)(v9 + 4) == 2 && v10 || check_handle_access_by_state_extended(v5) )
      {
        ++v6;
        v5 += 8;
        v7 += 8;
      }
      else
      {
LABEL_20:
        memmove(v5, v7, *(_QWORD *)(a1 + 0x110) - (_QWORD)v7);
        *(_QWORD *)(a1 + 0x110) -= 8LL;
      }
    }
    while ( v5 != *(char **)(a1 + 0x110) );
    v1 = v14;
  }
  v11 = *(_DWORD *)(v1 + 8);
  if ( v11 )
  {
    result = v6;
    *(_DWORD *)(v1 + 8) = v11 - 1;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = 0xFFFFFFFF;
    v13 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v13 != 1 )
    {
      sub_1403D6A80((volatile signed __int32 *)v1, v13);
    }
    return v6;
  }
  return result;
}

// --- End Function: sub_141535570 (0x141535570) ---

// --- Function: sub_14154CAA0 (0x14154CAA0) ---
char __fastcall sub_14154CAA0(__int64 a1, _QWORD *a2)
{
  char result; // al
  __int64 v4; // r8
  int v5; // [rsp+38h] [rbp+10h] BYREF
  unsigned __int64 v6; // [rsp+40h] [rbp+18h] BYREF

  (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)global_validator_object + 0x120LL))(
    global_validator_object,
    &v6,
    *a2);
  result = is_valid_handle_typeB(&v6);
  if ( result )
  {
    LOBYTE(v4) = 1;
    (*(void (__fastcall **)(unsigned __int64, int *, __int64))(*(_QWORD *)(v6 & 0xFFFFFFFFFFFFLL) + 0x5E8LL))(
      v6 & 0xFFFFFFFFFFFFLL,
      &v5,
      v4);
    if ( (unsigned __int8)sub_1403B6270((__int64)&v5, a1 + 0xCA8) )
    {
      sub_141562E00(a1);
    }
    return sub_14036EF50(&v5);
  }
  return result;
}

// --- End Function: sub_14154CAA0 (0x14154CAA0) ---

// --- Function: sub_14154D9E0 (0x14154D9E0) ---
__int64 __fastcall sub_14154D9E0(char *crime, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rbp
  __int64 v6; // rcx
  __int128 v7; // xmm0
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 *v10; // rax
  __int64 v11; // rax
  __int64 v12; // [rsp+20h] [rbp-58h] BYREF
  __int128 v13; // [rsp+28h] [rbp-50h] BYREF
  __int128 v14; // [rsp+38h] [rbp-40h] BYREF
  __int64 v15; // [rsp+48h] [rbp-30h]

  result = sub_1417C24D0();
  v5 = result;
  if ( result )
  {
    if ( *(_BYTE *)(a2 + 0x28) == 1 )
    {
      v6 = *(_QWORD *)(result + 0x28);
      if ( v6 && (v7 = *(_OWORD *)(v6 + 0x280), v15 = *(_QWORD *)(v6 + 0x290), v14 = v7, v15) )
      {
        sub_1403AB5F0((__int64)&v14, (__int64)&v13);
      }
      else
      {
        v13 = 0;
      }
      if ( v13 == *(_OWORD *)a2 )
      {
        sub_14156D2A0(crime, 1);
        sub_141571BD0(crime);
        if ( sub_141550580((__int64)crime) )
        {
          v8 = *((_QWORD *)crime + 0x4C);
          v12 = v8;
          if ( AssetMeta::HasActorSubresource(&v12) )
          {
            v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x640LL))(v8 & 0xFFFFFFFFFFFFLL);
            if ( v9 )
            {
              v10 = sub_1414FD270(v9, &v12);
              v11 = sub_1403305F0(v10);
              if ( v11 )
              {
                (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 0x580LL))(v11, 3);
              }
            }
          }
        }
      }
    }
    result = sub_1415340D0(v5, (_QWORD *)a2);
    if ( result )
    {
      sub_14156F9E0((__int64)crime, result, (_QWORD *)(a2 + 0x20), *(_BYTE *)(a2 + 0x28));
      return sub_141563B60(crime);
    }
  }
  return result;
}

// --- End Function: sub_14154D9E0 (0x14154D9E0) ---

// --- Function: sub_141550390 (0x141550390) ---
char sub_141550390()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax

  if ( !dword_1499CBB00
    && (v0 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 0xA0LL))(qword_14981D298),
        (v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 0x180LL))(v0)) != 0)
    && (v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x28LL))(v1)) != 0
    && (v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x788LL))(v2)) != 0 )
  {
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 0x7C0LL))(v3, 2);
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_141550390 (0x141550390) ---

// --- Function: sub_141550580 (0x141550580) ---
char __fastcall sub_141550580(__int64 a1)
{
  __int64 v1; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 n4; // dx
  __int64 v4; // rax
  __int64 *v5; // rbx
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_QWORD *)(a1 + 0x260);
  v7 = v1;
  if ( v1
    && (handle_metadata_ptr = get_handle_metadata_ptr(v1 & 0xFFFFFFFFFFFFLL),
        n4 = *(_WORD *)(handle_metadata_ptr + 4),
        n4 != 4)
    && *(_WORD *)(handle_metadata_ptr + 2) == (HIWORD(v1) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_indirect_handle_access_by_state(&v7))
    && (v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v1 & 0xFFFFFFFFFFFFLL) + 0x640LL))(v1 & 0xFFFFFFFFFFFFLL)) != 0
    && (v5 = sub_1414FD270(v4, &v7), is_valid_handle_typeA(v5))
    && (*v5 & 0xFFFFFFFFFFFFLL) != 0 )
  {
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*v5 & 0xFFFFFFFFFFFFLL) + 0x5E0LL))(*v5 & 0xFFFFFFFFFFFFLL);
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_141550580 (0x141550580) ---

// --- Function: sub_14155B130 (0x14155B130) ---
__int64 __fastcall sub_14155B130(__int64 a1, __int64 a2, char a3, __int64 a4)
{
  _QWORD *v14; // rax
  _QWORD *v15; // rax
  int v19; // ecx
  double _XMM0; // kr00_8
  __int128 v24; // xmm0
  __int64 v25; // rax
  __int64 result; // rax
  double v27; // xmm1_8
  int v28; // ebx
  __int64 v29; // rax
  __m256 v30; // [rsp+20h] [rbp-89h] BYREF
  char v31; // [rsp+40h] [rbp-69h]
  __int64 v32; // [rsp+48h] [rbp-61h]
  __int64 v33; // [rsp+50h] [rbp-59h] BYREF
  _BYTE v34[4]; // [rsp+60h] [rbp-49h] BYREF
  int v35; // [rsp+64h] [rbp-45h]
  int v36; // [rsp+68h] [rbp-41h]
  int v37; // [rsp+6Ch] [rbp-3Dh]
  int v38; // [rsp+70h] [rbp-39h]
  int v39; // [rsp+74h] [rbp-35h]
  __int64 v40; // [rsp+78h] [rbp-31h]
  int v41; // [rsp+80h] [rbp-29h]
  int v42; // [rsp+84h] [rbp-25h]
  int v43; // [rsp+88h] [rbp-21h]
  int v44; // [rsp+8Ch] [rbp-1Dh]
  int v45; // [rsp+90h] [rbp-19h]
  int v46; // [rsp+94h] [rbp-15h]
  __int128 v47; // [rsp+98h] [rbp-11h]
  double v48; // [rsp+C0h] [rbp+17h]

  v31 = 0;
  v32 = 0;
  v30 = (__m256)0LL;
  __asm { vzeroupper }
  sub_14151DCB0(a2, (__int64)&v30);
  v36 = 0;
  v40 = 0;
  v42 = 0;
  v34[0] = a3;
  v35 = v32;
  v47 = 0;
  if ( *(__int64 *)&v30.m256_f32[6] > 0 )
  {
    v36 = 0x64LL * *(_QWORD *)&v30.m256_f32[2] / *(_QWORD *)&v30.m256_f32[6];
  }
  _XMM0 = sub_140593C00(0.0);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  v37 = (int)*(float *)&_XMM1;
  _XMM0 = sub_140593C00(*(double *)_XMM0.m128_u64);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  v38 = (int)*(float *)&_XMM1;
  _XMM0 = sub_140593C00(*(double *)_XMM0.m128_u64);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  v39 = (int)*(float *)&_XMM1;
  if ( *(int *)(a1 + 0xA8) > 0 )
  {
    if ( *(_BYTE *)(a1 + 0x48) )
    {
      v14 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)qword_14981D260 + 0x38LL))(
                        qword_14981D260,
                        0);
      v15 = sub_140593A60(v14, &v33, (_QWORD *)(a1 + 0x10));
      sub_1414F8170(a1 + 0x80, v15);
    }
    _XMM0 = sub_140593C00(*(double *)_XMM0.m128_u64);
    __asm { vcvtsd2ss xmm2, xmm0, xmm0 }
    LODWORD(v40) = (int)(float)(*(float *)&_XMM2 / (float)*(int *)(a1 + 0xA8));
    _XMM0 = sub_140593C00(*(double *)_XMM0.m128_u64);
    v19 = *(_DWORD *)(a1 + 0xA8);
    __asm { vcvtsd2ss xmm2, xmm0, xmm0 }
    v42 = (int)(float)(*(float *)&_XMM2 / (float)v19);
    HIDWORD(v40) = v19;
  }
  *(_QWORD *)&_XMM0 = *(unsigned int *)(a1 + 0x128);
  *(float *)&_XMM0 = *(float *)(a1 + 0x128) * 100.0;
  v41 = *(_DWORD *)(a1 + 0xC8);
  v43 = *(_DWORD *)(a1 + 0xE8);
  v44 = *(_DWORD *)(a1 + 0x108);
  v45 = (int)*(float *)&_XMM0;
  _XMM0 = sub_140593C00(_XMM0);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  v24 = *(_OWORD *)(a1 + 0x20);
  v46 = (int)*(float *)&_XMM1;
  v47 = v24;
  v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 0x250LL))(qword_14981D298);
  result = (*(__int64 (__fastcall **)(__int64, _QWORD, _BYTE *))(*(_QWORD *)v25 + 0x70LL))(
             v25,
             *(_QWORD *)(a2 + 8),
             v34);
  if ( a4 )
  {
    if ( *(_QWORD *)(a4 + 0xA0) )
    {
      v27 = *(double *)(a4 + 0xA0);
    }
    else
    {
      v27 = *(double *)(a4 + 0x88);
    }
    v48 = v27;
    result = *(_QWORD *)&v27;
    if ( v27 != 0.0 )
    {
      if ( *(_BYTE *)(*(_QWORD *)&v27 + 0x168LL) )
      {
        v28 = sub_141535570(a4);
        v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 0x250LL))(qword_14981D298);
        return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v29 + 0x78LL))(
                 v29,
                 *(_QWORD *)(a2 + 8),
                 0,
                 (unsigned int)(v28 - 1));
      }
    }
  }
  return result;
}

// --- End Function: sub_14155B130 (0x14155B130) ---

// --- Function: sub_141562E00 (0x141562E00) ---
char __fastcall sub_141562E00(__int64 a1)
{
  __int64 handle_metadata_ptr; // rax
  __int64 n0xE2_1; // rbx
  __int16 n2; // dx
  __int64 *v5; // rbx
  __int64 v6; // rbx
  int v7; // esi
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rdx
  int v12; // ebx
  __int64 *ThreadLogContextSlot; // rax
  __int64 v15; // [rsp+28h] [rbp-51h]
  __int64 v16; // [rsp+50h] [rbp-29h] BYREF
  __int64 *p_n0xE2; // [rsp+58h] [rbp-21h] BYREF
  __int64 *p_n0xE2_1; // [rsp+60h] [rbp-19h]
  __int128 v19; // [rsp+68h] [rbp-11h] BYREF
  __m256 v20; // [rsp+78h] [rbp-1h] BYREF
  char v21; // [rsp+98h] [rbp+1Fh]
  __int64 v22; // [rsp+A0h] [rbp+27h]
  __int64 n0xE2; // [rsp+E8h] [rbp+6Fh] BYREF
  __int64 n0xE2_2; // [rsp+F0h] [rbp+77h] BYREF
  __int64 v25; // [rsp+F8h] [rbp+7Fh] BYREF

  if ( !*(_BYTE *)(a1 + 0x371) )
  {
    goto LABEL_16;
  }
  LOBYTE(handle_metadata_ptr) = sub_141550580(a1);
  if ( !(_BYTE)handle_metadata_ptr )
  {
    goto LABEL_4;
  }
  v20 = (__m256)0LL;
  v21 = 0;
  v22 = 0;
  __asm { vzeroupper }
  LOBYTE(handle_metadata_ptr) = sub_14151DCB0(a1, (__int64)&v20);
  if ( v21 )
  {
LABEL_16:
    n0xE2 = 0xE2;
    p_n0xE2 = &n0xE2;
    p_n0xE2_1 = &n0xE2_2;
    v12 = invokeGlobalCallbackAndMaskStatusBits(
            6,
            (__int64)&p_n0xE2,
            (__int64)"[CLawComponent::ProcessForPrisonRelease]",
            "Player $$ is eligible for prison release");
    if ( (v12 & 0xFFFFF) != 0 )
    {
      sub_1403AC900((unsigned __int64 *)(a1 + 8), &n0xE2_2);
      *(_QWORD *)&v20.m256_f32[2] = n0xE2_2;
      *(_QWORD *)v20.m256_f32 = 0;
      LOBYTE(v20.m256_f32[4]) = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      n0xE2 = 0xE2;
      p_n0xE2 = &n0xE2;
      p_n0xE2_1 = &n0xE2_2;
      LODWORD(v15) = v12;
      v19 = 0;
      sub_14034F0C0(
        6,
        (__int64)&p_n0xE2,
        "[CLawComponent::ProcessForPrisonRelease]",
        (__int64)"Player $$ is eligible for prison release",
        1,
        v15,
        &v19,
        0,
        (__int64)ThreadLogContextSlot,
        &v20);
    }
    LOBYTE(handle_metadata_ptr) = sub_14156D2A0((_QWORD *)a1, 4);
  }
  else
  {
LABEL_4:
    n0xE2_1 = *(_QWORD *)(a1 + 0x260);
    n0xE2 = n0xE2_1;
    if ( n0xE2_1 )
    {
      handle_metadata_ptr = get_handle_metadata_ptr(n0xE2_1 & 0xFFFFFFFFFFFFLL);
      n2 = *(_WORD *)(handle_metadata_ptr + 4);
      if ( n2 != 4 && *(_WORD *)(handle_metadata_ptr + 2) == (HIWORD(n0xE2_1) & 0xFFF) )
      {
        if ( n2 == 2 && !*(_QWORD *)get_tls_data_offset_784()
          || (LOBYTE(handle_metadata_ptr) = check_indirect_handle_access_by_state(&n0xE2), (_BYTE)handle_metadata_ptr) )
        {
          handle_metadata_ptr = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(n0xE2_1 & 0xFFFFFFFFFFFFLL) + 0x640LL))(n0xE2_1 & 0xFFFFFFFFFFFFLL);
          if ( handle_metadata_ptr )
          {
            v5 = sub_1414FD270(handle_metadata_ptr, &v16);
            LOBYTE(handle_metadata_ptr) = is_valid_handle_typeA(v5);
            if ( (_BYTE)handle_metadata_ptr )
            {
              v6 = *v5 & 0xFFFFFFFFFFFFLL;
              if ( v6 )
              {
                n0xE2_2 = 0xE2;
                p_n0xE2 = &n0xE2_2;
                p_n0xE2_1 = &v25;
                v7 = invokeGlobalCallbackAndMaskStatusBits(
                       6,
                       (__int64)&p_n0xE2,
                       (__int64)"[CLawComponent::ProcessForPrisonRelease]",
                       "Returning Player $$ to prison");
                if ( (v7 & 0xFFFFF) != 0 )
                {
                  sub_1403AC900((unsigned __int64 *)(a1 + 8), &v25);
                  *(_QWORD *)&v20.m256_f32[2] = v25;
                  *(_QWORD *)v20.m256_f32 = 0;
                  LOBYTE(v20.m256_f32[4]) = 0;
                  ThreadLogContextSlot_1 = getThreadLogContextSlot();
                  n0xE2_2 = 0xE2;
                  p_n0xE2 = &n0xE2_2;
                  p_n0xE2_1 = &v25;
                  LODWORD(v15) = v7;
                  v19 = 0;
                  sub_14034F0C0(
                    6,
                    (__int64)&p_n0xE2,
                    "[CLawComponent::ProcessForPrisonRelease]",
                    (__int64)"Returning Player $$ to prison",
                    1,
                    v15,
                    &v19,
                    0,
                    (__int64)ThreadLogContextSlot_1,
                    &v20);
                }
                (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x618LL))(v6);
                LOBYTE(v9) = 6;
                (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x5B8LL))(v6, v9);
                LODWORD(n0xE2) = 0x1000000;
                sub_1414FE4F0(global_validator_object, a1, &n0xE2);
                LOBYTE(v10) = 1;
                (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x5D0LL))(v6, v10);
                LOBYTE(v11) = 1;
                LOBYTE(handle_metadata_ptr) = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x5C8LL))(
                                                v6,
                                                v11);
              }
            }
          }
        }
      }
    }
  }
  return handle_metadata_ptr;
}

// --- End Function: sub_141562E00 (0x141562E00) ---

// --- Function: sub_14156D2A0 (0x14156D2A0) ---
char __fastcall sub_14156D2A0(_QWORD *a1, char n4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 global_validator_object; // rbx
  _BYTE *v7; // rax
  __int64 handle_metadata_ptr; // rax
  unsigned __int64 ppStringObjectData__2; // rbx
  __int16 n2_1; // dx
  __int64 handle_metadata_ptr_1; // r15
  unsigned __int64 ppStringObjectData__3; // rbx
  __int64 handle_metadata_ptr_2; // rax
  __int16 n4_1; // dx
  __int64 v15; // rbx
  char *p_Exiting_Prison_System; // rdx
  __int64 v17; // rax
  __int64 (__fastcall *v18)(__int64, __int64 *, __int64, __int64, unsigned __int64 *, unsigned __int64 **); // rdi
  __int64 v19; // rdx
  __int64 v20; // rax
  __int64 v21; // r8
  _QWORD *v22; // rax
  __int16 v23; // rbx^6
  unsigned __int64 v24; // rdi
  __int16 n2; // cx
  int v26; // ebx
  __int64 *ThreadLogContextSlot; // rax
  __int64 v28; // rdx
  unsigned __int64 ppStringObjectData__1; // rbx
  unsigned int v30; // eax
  __int64 global_validator_object_1; // r14
  __int64 v32; // rsi
  __int64 handle_metadata_ptr_3; // rax
  __int16 n4_2; // dx
  __int64 v35; // rbx
  int event_key_from_source_location_128; // eax
  __int64 v38; // [rsp+28h] [rbp-81h]
  unsigned __int64 ppStringObjectData_; // [rsp+50h] [rbp-59h] BYREF
  _BYTE v40[8]; // [rsp+58h] [rbp-51h] BYREF
  __int64 v41; // [rsp+60h] [rbp-49h] BYREF
  unsigned __int64 *ppStringObjectData_2; // [rsp+68h] [rbp-41h]
  __int64 n0x10; // [rsp+70h] [rbp-39h]
  void (__fastcall *p_DestroyStringObject)(_QWORD *); // [rsp+78h] [rbp-31h]
  __int64 (__fastcall *p_sub_1414F7D10)(); // [rsp+80h] [rbp-29h]
  __int64 v46; // [rsp+88h] [rbp-21h]
  __int128 ppStringObjectData; // [rsp+90h] [rbp-19h] BYREF
  _QWORD v48[2]; // [rsp+A0h] [rbp-9h] BYREF
  unsigned __int64 *ppStringObjectData_1; // [rsp+B0h] [rbp+7h] BYREF
  _BYTE *v50; // [rsp+B8h] [rbp+Fh]

  if ( !*(_BYTE *)(IEntity::GetTransformComponent((__int64)a1) + 0x18) )
  {
    if ( is_valid_handle_typeA(a1 + 0x41) )
    {
      v5 = a1[0x41] & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      v5 = 0;
    }
    LOBYTE(v4) = n4 == 4;
    sub_14155B130(a1 + 0x103, a1, v4, v5);
  }
  global_validator_object = ::global_validator_object;
  v7 = sub_1403588A0(v40, n4);
  LOBYTE(handle_metadata_ptr) = sub_141332A30(global_validator_object, a1, v7);
  ppStringObjectData__2 = a1[0x4C];
  ppStringObjectData_ = ppStringObjectData__2;
  if ( ppStringObjectData__2 )
  {
    handle_metadata_ptr = get_handle_metadata_ptr(ppStringObjectData__2 & 0xFFFFFFFFFFFFLL);
    n2_1 = *(_WORD *)(handle_metadata_ptr + 4);
    if ( n2_1 != 4 && *(_WORD *)(handle_metadata_ptr + 2) == (HIWORD(ppStringObjectData__2) & 0xFFF) )
    {
      if ( n2_1 == 2 && !*(_QWORD *)get_tls_data_offset_784()
        || (LOBYTE(handle_metadata_ptr) = check_indirect_handle_access_by_state(&ppStringObjectData_),
            (_BYTE)handle_metadata_ptr) )
      {
        handle_metadata_ptr = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(ppStringObjectData__2
                                                                                      & 0xFFFFFFFFFFFFLL)
                                                                          + 0x640LL))(ppStringObjectData__2 & 0xFFFFFFFFFFFFLL);
        handle_metadata_ptr_1 = handle_metadata_ptr;
        if ( handle_metadata_ptr )
        {
          ppStringObjectData__3 = *sub_1414F9D60(handle_metadata_ptr, &ppStringObjectData_1);
          ppStringObjectData_ = ppStringObjectData__3;
          if ( ppStringObjectData__3 )
          {
            handle_metadata_ptr_2 = get_handle_metadata_ptr(ppStringObjectData__3 & 0xFFFFFFFFFFFFLL);
            n4_1 = *(_WORD *)(handle_metadata_ptr_2 + 4);
            if ( n4_1 != 4
              && *(_WORD *)(handle_metadata_ptr_2 + 2) == (HIWORD(ppStringObjectData__3) & 0xFFF)
              && (n4_1 == 2 && !*(_QWORD *)get_tls_data_offset_784()
               || check_handle_access_by_state(&ppStringObjectData_)) )
            {
              v15 = ppStringObjectData__3 & 0xFFFFFFFFFFFFLL;
              p_Exiting_Prison_System = "Hacked away Merit";
              v17 = *(_QWORD *)v15;
              ppStringObjectData_1 = 0;
              v50 = 0;
              v18 = *(__int64 (__fastcall **)(__int64, __int64 *, __int64, __int64, unsigned __int64 *, unsigned __int64 **))(v17 + 0x578);
              if ( n4 == 4 )
              {
                p_Exiting_Prison_System = "Exiting Prison System";
              }
              CreateStringObjectFromString((void **)&ppStringObjectData_, p_Exiting_Prison_System);
              LOBYTE(v19) = 3;
              v20 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v15 + 0x570LL))(v15, v19);
              LOBYTE(v21) = 3;
              v22 = (_QWORD *)v18(v15, &v41, v21, -v20, &ppStringObjectData_, &ppStringObjectData_1);
              sub_14039FB00(v22);
              sub_14036D0B0((__int64)&v41);
              DestroyStringObject(&ppStringObjectData_);
            }
          }
          LOBYTE(handle_metadata_ptr) = (unsigned __int8)sub_1414FD270(handle_metadata_ptr_1, &ppStringObjectData_);
          v23 = HIWORD(ppStringObjectData_);
          if ( ppStringObjectData_ )
          {
            v24 = ppStringObjectData_ & 0xFFFFFFFFFFFFLL;
            handle_metadata_ptr = get_handle_metadata_ptr(ppStringObjectData_ & 0xFFFFFFFFFFFFLL);
            n2 = *(_WORD *)(handle_metadata_ptr + 4);
            if ( n2 != 4 && *(_WORD *)(handle_metadata_ptr + 2) == (v23 & 0xFFF) )
            {
              if ( n2 == 2 && (handle_metadata_ptr = get_tls_data_offset_784(), !*(_QWORD *)handle_metadata_ptr)
                || (LOBYTE(handle_metadata_ptr) = check_handle_access_by_state(&ppStringObjectData_),
                    (_BYTE)handle_metadata_ptr) )
              {
                if ( n4 == 4 )
                {
                  LOBYTE(handle_metadata_ptr) = sub_141550390(a1);
                  if ( (_BYTE)handle_metadata_ptr )
                  {
                    ppStringObjectData_ = 0xE2;
                    ppStringObjectData_1 = &ppStringObjectData_;
                    v50 = v40;
                    v26 = invokeGlobalCallbackAndMaskStatusBits(
                            6,
                            (__int64)&ppStringObjectData_1,
                            (__int64)"[CLawComponent::ReleaseFromPrison]",
                            "Releasing plyer $$ from Prison");
                    if ( (v26 & 0xFFFFF) != 0 )
                    {
                      sub_1403AC900(a1 + 1, &ppStringObjectData_1);
                      ppStringObjectData_2 = ppStringObjectData_1;
                      v41 = 0;
                      LOBYTE(n0x10) = 0;
                      ThreadLogContextSlot = getThreadLogContextSlot();
                      ppStringObjectData_ = 0xE2;
                      v48[0] = &ppStringObjectData_;
                      v48[1] = v40;
                      LODWORD(v38) = v26;
                      ppStringObjectData = 0;
                      sub_14034F0C0(
                        6,
                        (unsigned int)v48,
                        (unsigned int)"[CLawComponent::ReleaseFromPrison]",
                        (unsigned int)"Releasing plyer $$ from Prison",
                        1,
                        v38,
                        &ppStringObjectData,
                        0,
                        (__int64)ThreadLogContextSlot,
                        (__int64)&v41);
                    }
                    if ( sub_141550580((__int64)a1) )
                    {
                      LOBYTE(v28) = 4;
                      (*(void (__fastcall **)(unsigned __int64, __int64))(*(_QWORD *)v24 + 0x5B8LL))(v24, v28);
                    }
                    else
                    {
                      sub_1405BD4A0(
                        0xAu,
                        2u,
                        "[%s] Error: Trying to exit prison, but spawn is not set to prison.",
                        "CLawComponent::ReleaseFromPrison");
                    }
                    ppStringObjectData__1 = *sub_1414F9D60(handle_metadata_ptr_1, &ppStringObjectData_1);
                    ppStringObjectData_ = ppStringObjectData__1;
                    if ( is_valid_handle_typeA((__int64 *)&ppStringObjectData_) && !sub_1403BB9F0(a1 + 0x192) )
                    {
                      v30 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v24 + 0x570LL))(v24);
                      global_validator_object_1 = ::global_validator_object;
                      v32 = sub_14044FC50(&ppStringObjectData, a1 + 0x192, v30);
                      if ( ppStringObjectData__1
                        && (handle_metadata_ptr_3 = get_handle_metadata_ptr(ppStringObjectData__1 & 0xFFFFFFFFFFFFLL),
                            n4_2 = *(_WORD *)(handle_metadata_ptr_3 + 4),
                            n4_2 != 4)
                        && *(_WORD *)(handle_metadata_ptr_3 + 2) == (HIWORD(ppStringObjectData__1) & 0xFFF)
                        && (n4_2 == 2 && !*(_QWORD *)get_tls_data_offset_784()
                         || check_handle_access_by_state(&ppStringObjectData_)) )
                      {
                        v35 = ppStringObjectData__1 & 0xFFFFFFFFFFFFLL;
                      }
                      else
                      {
                        v35 = 0;
                      }
                      event_key_from_source_location_128 = ::event_key_from_source_location_128;
                      v41 = v32;
                      if ( !::event_key_from_source_location_128 )
                      {
                        event_key_from_source_location_128 = get_event_key_from_source_location(
                                                               &::event_key_from_source_location_128,
                                                               (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommo"
                                                                        "n\\IGameDll\\IWallet.h",
                                                               0x1E);
                      }
                      LODWORD(ppStringObjectData_2) = event_key_from_source_location_128;
                      n0x10 = 0x10;
                      p_DestroyStringObject = j_DestroyStringObject;
                      p_sub_1414F7D10 = sub_1414F7D10;
                      (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)global_validator_object_1
                                                                          + 0x358LL))(
                        global_validator_object_1,
                        v35,
                        &v41);
                      DestroyStringObject(&ppStringObjectData);
                    }
                    LOBYTE(handle_metadata_ptr) = (*(__int64 (__fastcall **)(unsigned __int64, _QWORD))(*(_QWORD *)v24 + 0x5C8LL))(
                                                    v24,
                                                    0);
                  }
                }
                else if ( n4 == 1 )
                {
                  v41 = 0;
                  LOBYTE(ppStringObjectData_2) = 0;
                  n0x10 = 0xFFFFFFFFFFFFFFFFuLL;
                  p_DestroyStringObject = 0;
                  LODWORD(p_sub_1414F7D10) = 0;
                  v46 = 0;
                  LOBYTE(handle_metadata_ptr) = (*(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v24 + 0x5B0LL))(
                                                  v24,
                                                  &v41);
                }
              }
            }
          }
        }
      }
    }
  }
  return handle_metadata_ptr;
}

// --- End Function: sub_14156D2A0 (0x14156D2A0) ---

// --- Function: sub_141572970 (0x141572970) ---
char __fastcall sub_141572970(__int64 a1)
{
  _WORD *handle_metadata_ptr; // rax
  _WORD *handle_metadata_ptr_1; // rbx
  __int64 (__fastcall *v3)(_WORD *, char *, __int16 *); // rdi
  __int16 n0xFFFF_104; // cx
  __int64 v5; // rbx
  _QWORD *v6; // rdi
  __int16 n2; // cx
  __int16 n0xFFFF_104_1; // [rsp+40h] [rbp+8h] BYREF
  char v10; // [rsp+48h] [rbp+10h] BYREF
  __int64 v11; // [rsp+50h] [rbp+18h] BYREF
  char v12; // [rsp+58h] [rbp+20h] BYREF

  handle_metadata_ptr = (_WORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)global_validator_object
                                                                            + 0x118LL))(
                                   global_validator_object,
                                   *(_QWORD *)(a1 + 0x100));
  handle_metadata_ptr_1 = handle_metadata_ptr;
  if ( handle_metadata_ptr )
  {
    v3 = *(__int64 (__fastcall **)(_WORD *, char *, __int16 *))(*(_QWORD *)handle_metadata_ptr + 0x338LL);
    n0xFFFF_104 = ::n0xFFFF_104;
    if ( ::n0xFFFF_104 == (__int16)0xFFFF )
    {
      n0xFFFF_104 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                       + 0x10LL))(
                                global_dispatcher_ptr,
                                &v10,
                                "LawComponent");
      ::n0xFFFF_104 = n0xFFFF_104;
    }
    n0xFFFF_104_1 = n0xFFFF_104;
    handle_metadata_ptr = (_WORD *)v3(handle_metadata_ptr_1, &v12, &n0xFFFF_104_1);
    v5 = *(_QWORD *)handle_metadata_ptr;
    v11 = v5;
    if ( v5 )
    {
      v6 = (_QWORD *)(v5 & 0xFFFFFFFFFFFFLL);
      handle_metadata_ptr = (_WORD *)get_handle_metadata_ptr(v5 & 0xFFFFFFFFFFFFLL);
      n2 = handle_metadata_ptr[2];
      if ( n2 != 4 && handle_metadata_ptr[1] == (HIWORD(v5) & 0xFFF) )
      {
        if ( n2 == 2 && (handle_metadata_ptr = (_WORD *)get_tls_data_offset_784(), !*(_QWORD *)handle_metadata_ptr)
          || (LOBYTE(handle_metadata_ptr) = check_handle_access_by_state(&v11), (_BYTE)handle_metadata_ptr) )
        {
          if ( v6 )
          {
            LOBYTE(handle_metadata_ptr) = sub_14156D2A0(v6, 1);
          }
        }
      }
    }
  }
  return (char)handle_metadata_ptr;
}

// --- End Function: sub_141572970 (0x141572970) ---

// --- Function: sub_141573650 (0x141573650) ---
char __fastcall sub_141573650(__int64 a1)
{
  __int64 v2; // rbx
  signed __int64 v3; // rdx
  char result; // al
  __int64 *v5; // rbx
  __int64 v6; // rdx
  char v7; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF

  v7 = *(_BYTE *)(a1 + 0x140);
  v2 = j_psub_140333BA0();
  if ( *(_DWORD *)(v2 + 8) == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
  {
    ++*(_DWORD *)(v2 + 0xC);
  }
  else
  {
    v3 = _InterlockedIncrement64((volatile signed __int64 *)v2);
    if ( (v3 & 0x200000) != 0 )
    {
      sub_1403C6C70(
        (volatile signed __int64 *)v2,
        v3,
        (__int64)"SCigEventDispatcher::QueueEvent",
        (__int64)"SCigEventSystemWithLinks::GetLinkUnlinkLock()",
        1);
    }
  }
  sub_1414FF2B0(a1 + 0x6A0, &v7);
  result = sub_1402D0950(v2);
  if ( *(_BYTE *)(a1 + 0x140) )
  {
    v5 = (__int64 *)sub_141326410(&v8, *(_QWORD *)(a1 + 0x100));
    result = is_valid_handle_typeA(v5);
    if ( result )
    {
      result = 0xFF;
      if ( (*v5 & 0xFFFFFFFFFFFFLL) != 0 )
      {
        LOBYTE(v6) = 4;
        return sub_14156D2A0(*v5 & 0xFFFFFFFFFFFFLL, v6);
      }
    }
  }
  return result;
}

// --- End Function: sub_141573650 (0x141573650) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(FH4 *pCZoneSystem)
{
  if ( pCZoneSystem )
  {
    if ( qword_14981D3D8 && ::pCZoneSystem && pCZoneSystem == ::pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)pCZoneSystem < pCZoneSystem_1
      || (unsigned __int64)pCZoneSystem >= pCZoneSystem_1 + 0x8000000000LL )
    {
      if ( (unsigned __int64)pCZoneSystem >= pCZoneSystem_0
        && (unsigned __int64)pCZoneSystem < pCZoneSystem_0 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", pCZoneSystem);
      }
      sub_147397F30((__int64)pCZoneSystem);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: allocWithProfilerInfo (0x14739AFC0) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char tls_byte_at_offset_3401; // al
  __int64 profileSize; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    tls_byte_at_offset_3401 = get_tls_byte_at_offset_3401();
    sub_140566BA0(tls_byte_at_offset_3401);
    profileSize = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1473986B0(profileSize + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x14739AFC0) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 0x10);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = 0xC0000409;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memcpy (0x147E162BB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x147E162BB) ---

