// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146AD0C50 (sub_146AD0C50)
// Caller Depth: 0
// Callee/Ref Depth: 4
// Total Functions Found: 95
// ------------------------------------------------------------

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
void __fastcall sub_1402A3D30(const void *a1)
{
  sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402D2790 (0x1402D2790) ---
unsigned __int64 __fastcall sub_1402D2790(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 0x10) == *(_DWORD *)(result + 0x18) && (result = *(unsigned int *)(a1 + 0x14), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 0x14) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CB820((volatile signed __int64 *)a1, v3);
    }
  }
  return result;
}

// --- End Function: sub_1402D2790 (0x1402D2790) ---

// --- Function: sub_1402FBEC0 (0x1402FBEC0) ---
__int64 __fastcall sub_1402FBEC0(unsigned __int8 *a1)
{
  return *a1;
}

// --- End Function: sub_1402FBEC0 (0x1402FBEC0) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_140360130 (0x140360130) ---
_DWORD *__fastcall sub_140360130(_DWORD *a1)
{
  *a1 = 0xF0000000;
  return a1;
}

// --- End Function: sub_140360130 (0x140360130) ---

// --- Function: sub_140361E00 (0x140361E00) ---
_QWORD *__fastcall sub_140361E00(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

// --- End Function: sub_140361E00 (0x140361E00) ---

// --- Function: sub_1403729F0 (0x1403729F0) ---
__int64 __fastcall sub_1403729F0(_DWORD *a1)
{
  __int64 result; // rax

  if ( *a1 != 0xF0000000 )
    return (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149B4FBF8 + 0xF8LL))(qword_149B4FBF8, a1);
  return result;
}

// --- End Function: sub_1403729F0 (0x1403729F0) ---

// --- Function: assignCStringToStringStructure (0x140377FA0) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **a1, _BYTE *a2)
{
  unsigned __int64 Size; // rax

  if ( a2 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DE230(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DE230(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x140377FA0) ---

// --- Function: sub_14038DCA0 (0x14038DCA0) ---
signed __int64 __fastcall sub_14038DCA0(__int64 a1, unsigned __int8 *a2, int a3)
{
  unsigned __int64 v4; // rdi
  signed __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  char n5; // si
  int v9; // r15d
  __int64 v10; // rbp
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // r12
  __int64 v12; // rcx
  __int64 v13; // rax
  __int128 n0x3EA2F983_1; // xmm3
  __int128 n0x3EA2F983; // kr00_16
  __int128 n0x3EA2F983_3; // xmm4
  __int128 n0x3EA2F983_2; // kr00_16
  __int128 n0x3EA2F983_5; // xmm5
  __int128 n0x3EA2F983_4; // kr00_16
  __int128 n0x3EA2F983_6; // kr00_16
  __int128 n0x3EA2F983_7; // kr00_16
  __int128 n0x3EA2F983_8; // kr00_16
  int v23; // eax
  _DWORD *v30; // rdx
  __int64 v31; // rax
  int v35; // r8d
  int v38; // r9d
  int v41; // eax
  unsigned __int64 n0x200000; // rax
  __int64 n0x3EA2F983_9; // [rsp+30h] [rbp-78h]
  float v44; // [rsp+38h] [rbp-70h]

  v4 = a3;
  p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1405178F0((__int64)a2);
  _XMM6 = 0;
  if ( *(float *)p_p_p_p_p_p_p_p_p_p_p_p_Source != 0.0
    || *(float *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 4) != 0.0
    || *(float *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 8) != 0.0 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1402FBEC0(a2);
    n5 = p_p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( (_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = NtCurrentTeb_w();
      v9 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18);
      if ( *(_DWORD *)(a1 + 0x10) == v9 )
      {
        ++*(_DWORD *)(a1 + 0x14);
      }
      else
      {
        v10 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0x200000, 0);
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = p_p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( p_p_p_p_p_p_p_p_p_p_p_p_Source )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && gEnv )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1403DCDF0(
                                               a1,
                                               p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
                                               v10,
                                               "SLinkedGlow::AddGlow",
                                               "m_lock");
          else
            p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1403DD0B0(
                                               a1,
                                               p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
                                               v10,
                                               "SLinkedGlow::AddGlow",
                                               "m_lock");
        }
        else
        {
          *(_QWORD *)(a1 + 8) = v10;
        }
        *(_DWORD *)(a1 + 0x10) = v9;
      }
      if ( (_DWORD)v4 )
      {
        if ( (v4 & 0x80000000) != 0LL )
          goto LABEL_38;
        v12 = *(_QWORD *)(a1 + 0x38) - *(_QWORD *)(a1 + 0x30);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)((unsigned __int128)(v12 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F;
        if ( v4 >= v12 / 0xC )
          goto LABEL_38;
      }
      v13 = sub_1405178F0((__int64)a2);
      v44 = *(float *)(v13 + 8);
      n0x3EA2F983_9 = *(_QWORD *)v13;
      if ( ((n5 - 1) & 0xFD) != 0 )
      {
        n0x3EA2F983_5 = LODWORD(v44);
        n0x3EA2F983_3 = HIDWORD(n0x3EA2F983_9);
        n0x3EA2F983_1 = (unsigned int)n0x3EA2F983_9;
      }
      else
      {
        n0x3EA2F983 = 0x3EA2F983u;
        *(float *)&n0x3EA2F983 = 0.31830987 * *(float *)&n0x3EA2F983_9;
        n0x3EA2F983_1 = n0x3EA2F983;
        n0x3EA2F983_2 = 0x3EA2F983u;
        *(float *)&n0x3EA2F983_2 = 0.31830987 * *((float *)&n0x3EA2F983_9 + 1);
        n0x3EA2F983_3 = n0x3EA2F983_2;
        n0x3EA2F983_4 = 0x3EA2F983u;
        *(float *)&n0x3EA2F983_4 = 0.31830987 * v44;
        n0x3EA2F983_5 = n0x3EA2F983_4;
      }
      if ( n5 == 5 )
      {
        n0x3EA2F983_6 = n0x3EA2F983_1;
        *(float *)&n0x3EA2F983_6 = *(float *)&n0x3EA2F983_1 * 0.001;
        n0x3EA2F983_1 = n0x3EA2F983_6;
        n0x3EA2F983_7 = n0x3EA2F983_3;
        *(float *)&n0x3EA2F983_7 = *(float *)&n0x3EA2F983_3 * 0.001;
        n0x3EA2F983_3 = n0x3EA2F983_7;
        n0x3EA2F983_8 = n0x3EA2F983_5;
        *(float *)&n0x3EA2F983_8 = *(float *)&n0x3EA2F983_5 * 0.001;
        n0x3EA2F983_5 = n0x3EA2F983_8;
      }
      v23 = dword_149B3E070;
      if ( (dword_149B3E070 & 1) == 0 )
      {
        v23 = dword_149B3E070 | 1;
        *(float *)&dword_149B3E06C = 4194303.5;
        dword_149B3E070 |= 1u;
      }
      if ( (v23 & 2) == 0 )
      {
        *(float *)&dword_149B3E074 = -4194303.5;
        dword_149B3E070 = v23 | 2;
      }
      __asm
      {
        vmaxss  xmm0, xmm3, xmm2
        vminss  xmm9, xmm0, xmm7
        vmaxss  xmm0, xmm5, xmm2
        vmaxss  xmm1, xmm4, xmm2
      }
      __asm
      {
        vminss  xmm5, xmm0, xmm7
        vminss  xmm8, xmm1, xmm7
      }
      if ( (unsigned __int8)(n5 - 1) <= 1u )
      {
        if ( !(_DWORD)v4 )
        {
          v30 = (_DWORD *)(a1 + 0x18);
          goto LABEL_34;
        }
        v31 = *(_QWORD *)(a1 + 0x30);
      }
      else
      {
        if ( !(_DWORD)v4 )
        {
          v30 = (_DWORD *)(a1 + 0x24);
LABEL_34:
          _XMM3 = 0xBF000000;
          __asm
          {
            vcmpless xmm0, xmm6, xmm8
            vblendvps xmm1, xmm3, xmm4, xmm0
          }
          v35 = v30[1] + (int)(float)(*(float *)&_XMM1 + (float)(*(float *)&_XMM8 * 512.0));
          __asm
          {
            vcmpless xmm0, xmm6, xmm5
            vblendvps xmm1, xmm3, xmm4, xmm0
          }
          v38 = v30[2] + (int)(float)(*(float *)&_XMM1 + (float)(*(float *)&_XMM5 * 512.0));
          __asm
          {
            vcmpless xmm0, xmm6, xmm9
            vblendvps xmm1, xmm3, xmm4, xmm0
          }
          p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)(int)(float)(*(float *)&_XMM1
                                                                    + (float)(*(float *)&_XMM9 * 512.0));
          *v30 += p_p_p_p_p_p_p_p_p_p_p_p_Source;
          v30[1] = v35;
          v30[2] = v38;
          if ( (float)((float)(int)*v30 * 0.001953125) < 0.0
            || (float)((float)v35 * 0.001953125) < 0.0
            || (float)((float)v38 * 0.001953125) < 0.0 )
          {
            *(_QWORD *)v30 = 0;
            v30[2] = 0;
          }
LABEL_38:
          if ( a1 )
          {
            v41 = *(_DWORD *)(a1 + 0x14);
            if ( v41 )
            {
              p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)(v41 - 1);
              *(_DWORD *)(a1 + 0x14) = p_p_p_p_p_p_p_p_p_p_p_p_Source;
            }
            else
            {
              *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
              n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0, 0x200000);
              if ( n0x200000 == 0x200000 )
              {
                p_p_p_p_p_p_p_p_p_p_p_p_Source = (signed __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
                *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
              }
              else
              {
                return (signed __int64)sub_1403DD380(a1, n0x200000);
              }
            }
          }
          return p_p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        v31 = *(_QWORD *)(a1 + 0x48);
      }
      v30 = (_DWORD *)(v31 + 0xC * v4);
      goto LABEL_34;
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14038DCA0 (0x14038DCA0) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = pEntitySystem;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 + 0xFFFFFFFA;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_1403AC7D0 (0x1403AC7D0) ---
_QWORD *__fastcall sub_1403AC7D0(__int64 a1, _QWORD *a2, unsigned __int16 a3)
{
  __int64 v3; // rsi
  void (__fastcall *v5)(__int64, _QWORD *, __int64); // rbx
  __int64 v6; // rax
  _QWORD *result; // rax

  v3 = *(_QWORD *)(a1 + 0x30);
  if ( v3 )
  {
    v5 = *(void (__fastcall **)(__int64, _QWORD *, __int64))(*(_QWORD *)v3 + 0x168LL);
    v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)pEngineComponentScheduler + 0x20LL))(
           pEngineComponentScheduler,
           a3);
    v5(v3, a2, v6);
    return a2;
  }
  else
  {
    result = a2;
    *a2 = 0;
  }
  return result;
}

// --- End Function: sub_1403AC7D0 (0x1403AC7D0) ---

// --- Function: sub_1403AF7A0 (0x1403AF7A0) ---
__int64 __fastcall sub_1403AF7A0(__int64 a1, __int64 a2)
{
  __int64 (__fastcall ***v4)(_QWORD, __int64); // rax
  __int64 v5; // rax

  v4 = (__int64 (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0
                                                                                     + 0x240LL))(qword_149B4FCA0);
  v5 = (**v4)(v4, a1);
  if ( v5 )
  {
    *(_OWORD *)a2 = *(_OWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  return a2;
}

// --- End Function: sub_1403AF7A0 (0x1403AF7A0) ---

// --- Function: sub_1403AFA40 (0x1403AFA40) ---
__int64 __fastcall sub_1403AFA40(__int64 a1)
{
  __int64 result; // rax

  result = 0;
  if ( *(_DWORD *)(a1 + 0x60) != 0xFFFFFFFF )
    return a1;
  return result;
}

// --- End Function: sub_1403AFA40 (0x1403AFA40) ---

// --- Function: sub_1403B0540 (0x1403B0540) ---
__int64 __fastcall sub_1403B0540(__int64 a1)
{
  return *(unsigned int *)(a1 + 0x60);
}

// --- End Function: sub_1403B0540 (0x1403B0540) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
           pEntitySystem,
           a1,
           0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403BA880 (0x1403BA880) ---
__int64 __fastcall sub_1403BA880(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  __int64 v7; // rax
  unsigned __int32 v8; // esi
  __int64 v9; // rax

  result = *(unsigned int *)(a1 + 0x60);
  if ( (_DWORD)result == 0xFFFFFFFF )
  {
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pSystem + 0x770LL))(pSystem);
    v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 0x30LL))(v7, a2);
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x60), v8, 0xFFFFFFFF) == 0xFFFFFFFF )
    {
      sub_1403BA9D0(a1, a3);
    }
    else
    {
      v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pSystem + 0x770LL))(pSystem);
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + 0x38LL))(v9, v8);
    }
    return *(unsigned int *)(a1 + 0x60);
  }
  return result;
}

// --- End Function: sub_1403BA880 (0x1403BA880) ---

// --- Function: sub_1403BFA30 (0x1403BFA30) ---
bool __fastcall sub_1403BFA30(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BFA30 (0x1403BFA30) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && gEnv )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149B4FCF8;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        isProfileFunctionsInitialized(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403CB300 (0x1403CB300) ---
double __fastcall sub_1403CB300(__int64 a1, signed __int64 a2, const char *a3, const char *a4, char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && gEnv )
    return sub_1403CB380(a1, a2, a3, a4);
  else
    return sub_1403CB5B0(a1, a2, a3, a4);
}

// --- End Function: sub_1403CB300 (0x1403CB300) ---

// --- Function: sub_1403CB380 (0x1403CB380) ---
double __fastcall sub_1403CB380(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  _BYTE v19[16]; // [rsp+30h] [rbp-29h] BYREF
  int n0x1600; // [rsp+40h] [rbp-19h] BYREF
  __int64 v21; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v23; // [rsp+50h] [rbp-9h]
  unsigned __int64 v24; // [rsp+58h] [rbp-1h]
  __int64 v25; // [rsp+60h] [rbp+7h]
  __int64 v26; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 0xF8LL))(v4, v19, &v27);
  if ( (a2 & 0x200000) == 0 )
    return result;
  v12 = (unsigned __int64)v11 << 0x20;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 0x124) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n0x1600 = 0x1600;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v21 = 1;
      n2 = 2;
      v23 = __rdtsc();
      isProfileFunctionsInitialized(
        &n0x1600,
        &word_149B3E384,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      v15 = word_149B3E384;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n0x1600 = 0x1600;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  n2 = 2;
  v23 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x1600,
    &word_149B3E388,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  v15 = word_149B3E388;
LABEL_10:
  HIWORD(n0x1600) = v15;
  qword_149B4B8B0("Lock: %s", a4);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
  qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
  qword_149B4B8B0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 0xE8LL))(v4, v11);
  v24 = __rdtsc();
  return qword_149B4B878(&n0x1600);
}

// --- End Function: sub_1403CB380 (0x1403CB380) ---

// --- Function: sub_1403CB5B0 (0x1403CB5B0) ---
double __fastcall sub_1403CB5B0(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int *p_n0x1600; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  int v15; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v16[3]; // [rsp+34h] [rbp-65h] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v18; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+50h] [rbp-49h]
  unsigned __int64 v21; // [rsp+58h] [rbp-41h]
  __int64 v22; // [rsp+60h] [rbp-39h]
  __int64 v23; // [rsp+68h] [rbp-31h]
  int n0x1600; // [rsp+90h] [rbp-9h] BYREF
  __int64 v25; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v27; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v28; // [rsp+A8h] [rbp+Fh]
  __int64 v29; // [rsp+B0h] [rbp+17h]
  __int64 v30; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 0x128LL))(qword_149B4FCF8, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n0x1600 = 0x1600;
        v25 = 1;
        n2 = 2;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v27 = __rdtsc();
        isProfileFunctionsInitialized(
          &n0x1600,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(n0x1600) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", a4);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v16[0] = v10;
        qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n0x1600 = &n0x1600;
        v28 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return result;
    }
    n0x1600_1 = 0x1600;
    v18 = 1;
    n2_1 = 2;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v20 = __rdtsc();
    isProfileFunctionsInitialized(
      &n0x1600_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(n0x1600_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", a4);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
    qword_149B4B8B0("Caller: %s", a3);
    v15 = v6;
    qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n0x1600 = &n0x1600_1;
    v21 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_n0x1600);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: sub_1403CB5B0 (0x1403CB5B0) ---

// --- Function: sub_1403CB820 (0x1403CB820) ---
__int64 __fastcall sub_1403CB820(volatile signed __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // rdx
  unsigned int v5; // r8d
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v8 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
      break;
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
      return result;
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
    return qword_149B3B488(a1);
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
      qword_149B4FCF8,
      &v11,
      &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v7 & (v9 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FCF8 + 0xD8LL))(
             qword_149B4FCF8,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: sub_1403CB820 (0x1403CB820) ---

// --- Function: sub_1403CE5A0 (0x1403CE5A0) ---
void __fastcall sub_1403CE5A0(char **a1)
{
  char *v1; // rax
  size_t Size; // rdi
  char *v4; // r9
  signed __int64 Size_2; // r9
  char *v6; // rbx
  size_t Size_1; // rcx
  char *v8; // rbp
  _DWORD *v9; // rax
  bool v10; // zf
  char *v11; // [rsp+30h] [rbp+8h] BYREF

  v1 = *a1;
  Size = *((int *)*a1 + 0xFFFFFFFE);
  v4 = &(*a1)[Size + 0xFFFFFFFF];
  if ( v4 >= *a1 )
  {
    while ( *v4 != 0x2E )
    {
      if ( *v4 != 0x2F && *v4 != 0x3A && *v4 != 0x5C && --v4 >= v1 )
        continue;
      return;
    }
    Size_2 = v4 - v1;
    v6 = (char *)&qword_149B3B33C + 4;
    if ( *((_DWORD *)*a1 + 0xFFFFFFFE) )
    {
      Size_1 = *((int *)*a1 + 0xFFFFFFFE);
      v8 = v1;
      if ( Size_2 != 0xFFFFFFFFFFFFFFFFuLL )
        Size_1 = Size_2;
      if ( Size_1 <= Size )
        Size = Size_1;
      if ( Size )
      {
        v9 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
        v6 = (char *)(v9 + 2);
        *v9 = Size;
        v9[1] = Size;
        v6[Size] = 0;
        v1 = *a1;
        if ( v6 != v8 )
        {
          memcpy(v6, v8, Size);
          v1 = *a1;
        }
      }
    }
    *a1 = v6;
    v10 = *((_DWORD *)v1 + 0xFFFFFFFE) == 0;
    v11 = v1;
    if ( !v10 )
    {
      sub_1403E9810(&v11, 0, 0x20);
      v1 = v11;
    }
    if ( *((int *)v1 + 0xFFFFFFFF) > 0 )
      sub_147605980(v1 + 0xFFFFFFF8);
  }
}

// --- End Function: sub_1403CE5A0 (0x1403CE5A0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 0xC0LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 0x10) & (unsigned int)(v9 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
      qword_149B4FCF8,
      &v11,
      &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 0xD8LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && gEnv )
    return sub_1403DCDF0(a1, a2, a3, a4, a5);
  else
    return sub_1403DD0B0(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: sub_1403DCDF0 (0x1403DCDF0) ---
__int64 __fastcall sub_1403DCDF0(__int64 a1, unsigned __int64 a2, __int64 a3, const char *a4, const char *a5)
{
  __int64 v5; // r15
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r14d
  const char *v12; // r13
  bool v13; // zf
  signed __int64 v14; // rax
  __int64 result; // rax
  unsigned __int64 v16; // rdx
  signed __int64 v17; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int64 v19; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-91h] BYREF
  __int64 v22; // [rsp+34h] [rbp-8Dh]
  int n2; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 v24; // [rsp+40h] [rbp-81h]
  unsigned __int64 v25; // [rsp+48h] [rbp-79h]
  __int64 v26; // [rsp+50h] [rbp-71h]
  __int64 v27; // [rsp+58h] [rbp-69h]
  int n0x1600_1; // [rsp+80h] [rbp-41h] BYREF
  __int64 v29; // [rsp+84h] [rbp-3Dh]
  int n2_1; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 v31; // [rsp+90h] [rbp-31h]
  unsigned __int64 v32; // [rsp+98h] [rbp-29h]
  __int64 v33; // [rsp+A0h] [rbp-21h]
  __int64 v34; // [rsp+A8h] [rbp-19h]
  _BYTE v35[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char v36; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 v37; // [rsp+130h] [rbp+6Fh]

  v37 = a3;
  v5 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v5 + 0xF8LL))(v5, v35, &v36);
  v12 = a5;
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v16 = (unsigned __int64)v11 << 0x30;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v10 + 0x124) = HIWORD(a2);
        v17 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v16 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v13 = a2 == v17;
        a2 = v17;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v22 = 1;
          n2 = 2;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v24 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E394,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(n0x1600) = word_149B3E394;
          qword_149B4B8B0("Lock: %s", v12);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v25 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
        v19 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v16, a2);
        v13 = a2 == v19;
        a2 = v19;
        if ( v13 )
        {
          n0x1600_1 = 0x1600;
          v29 = 1;
          n2_1 = 2;
          v32 = 0;
          v33 = 0;
          v34 = 0;
          v31 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E398,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600_1) = word_149B3E398;
          qword_149B4B8B0("Lock: %s", v12);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v32 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | 0x200000, a2);
    v13 = a2 == v14;
    a2 = v14;
  }
  while ( !v13 );
  result = v37;
  *(_QWORD *)(a1 + 8) = v37;
  return result;
}

// --- End Function: sub_1403DCDF0 (0x1403DCDF0) ---

// --- Function: sub_1403DD0B0 (0x1403DD0B0) ---
signed __int64 __fastcall sub_1403DD0B0(__int64 a1, signed __int64 a2, __int64 a3, const char *a4, const char *a5)
{
  char v5; // r14
  signed __int64 v9; // rcx
  bool v10; // zf
  signed __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int v13; // esi
  signed __int64 v14; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int v16; // [rsp+38h] [rbp-81h] BYREF
  _DWORD v17[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int n0x1600; // [rsp+48h] [rbp-71h] BYREF
  __int64 v19; // [rsp+4Ch] [rbp-6Dh]
  int n2; // [rsp+54h] [rbp-65h]
  unsigned __int64 v21; // [rsp+58h] [rbp-61h]
  unsigned __int64 v22; // [rsp+60h] [rbp-59h]
  __int64 v23; // [rsp+68h] [rbp-51h]
  __int64 v24; // [rsp+70h] [rbp-49h]
  int n0x1600_1; // [rsp+98h] [rbp-21h] BYREF
  __int64 v26; // [rsp+9Ch] [rbp-1Dh]
  int n2_1; // [rsp+A4h] [rbp-15h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-11h]
  unsigned __int64 v29; // [rsp+B0h] [rbp-9h]
  __int64 v30; // [rsp+B8h] [rbp-1h]
  __int64 v31; // [rsp+C0h] [rbp+7h]

  v5 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 0x128LL))(qword_149B4FCF8, a1);
      if ( (a2 & 0x2003FF) == 0 )
        break;
      if ( v5 )
      {
        n0x1600 = 0x1600;
        v19 = 1;
        n2 = 2;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v21 = __rdtsc();
        isProfileFunctionsInitialized(
          &n0x1600,
          &word_149B3E38C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(n0x1600) = word_149B3E38C;
        qword_149B4B8B0("Lock: %s", a5);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a4);
        v16 = a2;
        qword_149B3B480(a1, &v16, 4, 0xFFFFFFFFLL);
        a2 = *(_QWORD *)a1;
        v22 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v13 = a2 + 0x400000;
        v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 + 0x400000, a2);
        v10 = a2 == v14;
        a2 = v14;
        if ( v10 )
        {
          v5 = 1;
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E390,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600_1) = word_149B3E390;
          qword_149B4B8B0("Lock: %s", a5);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a4);
          v17[0] = v13;
          qword_149B3B480(a1, v17, 4, 0xFFFFFFFFLL);
          a2 = *(_QWORD *)a1;
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v9 = (a2 | 0x200000) - 0x400000;
    if ( !v5 )
      v9 = a2 | 0x200000;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v9, a2);
    v10 = a2 == result;
    a2 = result;
  }
  while ( !v10 );
  *(_QWORD *)(a1 + 8) = a3;
  return result;
}

// --- End Function: sub_1403DD0B0 (0x1403DD0B0) ---

// --- Function: sub_1403DD380 (0x1403DD380) ---
const ULONG_PTR *__fastcall sub_1403DD380(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // r8
  int v9; // ecx
  __int64 v10; // r8
  unsigned __int64 v11; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v14 - 1)) << 9) + v16 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    v6 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
      qword_149B3B490(a1);
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v7 = qword_149B4FCF8;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v15,
        &v13);
      v8 = v15 + ((WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1)) << 9);
      LODWORD(a2) = *(_DWORD *)(v8 + 0x124);
      *(_DWORD *)(v8 + 0x11C) = (unsigned __int16)(WORD2(a2) + v13);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0xD8LL))(v7);
      while ( (_DWORD)a2 != 0xFFFFFFFF )
      {
        v9 = (unsigned __int16)(a2 + v13);
        v10 = v15 + ((unsigned __int64)((unsigned int)a2 & (v13 - 1)) << 9);
        LODWORD(a2) = *(_DWORD *)(v10 + 0x124);
        *(_DWORD *)(v10 + 0x11C) = v9;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0xD8LL))(v7);
      }
    }
  }
  else if ( (a2 & 0xFFC00000) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
      qword_149B4FCF8,
      &v15,
      &v13);
    v11 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v11 & (v13 - 1)) << 9) + v15 + 0x11C) = (unsigned __int16)(v11 + v13);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FCF8 + 0xD8LL))(qword_149B4FCF8, (unsigned int)v11);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DD380 (0x1403DD380) ---

// --- Function: sub_1403DE230 (0x1403DE230) ---
void *__fastcall sub_1403DE230(void **a1, void *a2, size_t Size)
{
  _BYTE *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = *a1;
  if ( Size > *((int *)v5 + 0xFFFFFFFF) )
  {
    v7 = (int *)(v5 + 0xFFFFFFF8);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = (char *)&qword_149B3B33C + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, Size);
  *((_DWORD *)*a1 + 0xFFFFFFFE) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403DE230 (0x1403DE230) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 + 0xFFFFFFFE);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 + 0xFFFFFFFE) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 + 0xFFFFFFFF) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 + 0xFFFFFFFE) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 + 0xFFFFFFFE)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 + 0xFFFFFFFE));
  memset(&(*a1)[*((int *)v3 + 0xFFFFFFFE)], Val_1, Size);
  if ( *((int *)v3 + 0xFFFFFFFF) > 0 )
    sub_147605980(v3 + 0xFFFFFFF8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1404B6410 (0x1404B6410) ---
_QWORD *__fastcall sub_1404B6410(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  __int64 v4; // rdi
  signed __int64 v6; // rdx

  v2 = *(_QWORD *)(a1 + 0x70);
  *a2 = v2;
  if ( v2 )
  {
    v4 = *(_QWORD *)(v2 + 0x98);
    if ( v4 )
    {
      if ( *(_DWORD *)(v4 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v4 + 0x14);
        return a2;
      }
      v6 = _InterlockedIncrement64((volatile signed __int64 *)v4);
      if ( (v6 & 0x200000) != 0 )
        sub_1403CB300(
          v4,
          v6,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          1);
    }
  }
  return a2;
}

// --- End Function: sub_1404B6410 (0x1404B6410) ---

// --- Function: sub_1404EAD00 (0x1404EAD00) ---
unsigned __int64 __fastcall sub_1404EAD00(__int64 *a1)
{
  __int64 v1; // rcx
  __int64 v2; // rcx
  unsigned __int64 result; // rax

  v1 = *a1;
  if ( v1 )
  {
    v2 = *(_QWORD *)(v1 + 0x98);
    if ( v2 )
      return sub_1402D2790(v2);
  }
  return result;
}

// --- End Function: sub_1404EAD00 (0x1404EAD00) ---

// --- Function: sub_1404F1B30 (0x1404F1B30) ---
void __fastcall sub_1404F1B30(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 0x10) = a2;
}

// --- End Function: sub_1404F1B30 (0x1404F1B30) ---

// --- Function: sub_140505130 (0x140505130) ---
_BYTE *__fastcall sub_140505130(__int64 a1, float a2)
{
  _BYTE *result; // rax
  float v4[6]; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+48h] [rbp+10h] BYREF

  v4[0] = 0.0;
  v4[1] = 0.0;
  v4[2] = 0.0;
  v4[3] = a2 * 3.5449078;
  result = sub_140518140((__int64)v4, &v5);
  *(_DWORD *)(a1 + 0xD) = *(_DWORD *)result;
  return result;
}

// --- End Function: sub_140505130 (0x140505130) ---

// --- Function: sub_140505190 (0x140505190) ---
void __fastcall sub_140505190(__int64 a1, _BYTE *a2, char a3)
{
  *a2 = a3;
}

// --- End Function: sub_140505190 (0x140505190) ---

// --- Function: sub_1405051A0 (0x1405051A0) ---
void __fastcall sub_1405051A0(__int64 a1, char *a2, float a3)
{
  int n0x7FFFFFFE; // ecx
  char n0x7FFFFFFE_1; // al

  if ( (float)(a3 * 255.0) < 2147483600.0 )
  {
    n0x7FFFFFFE = (int)(float)((float)(a3 * 255.0) + 0.5);
    if ( n0x7FFFFFFE < 0 )
    {
      *a2 = 0;
      return;
    }
  }
  else
  {
    n0x7FFFFFFE = 0x7FFFFFFE;
  }
  n0x7FFFFFFE_1 = 0xFF;
  if ( (unsigned int)n0x7FFFFFFE < 0xFF )
    n0x7FFFFFFE_1 = n0x7FFFFFFE;
  *a2 = n0x7FFFFFFE_1;
}

// --- End Function: sub_1405051A0 (0x1405051A0) ---

// --- Function: sub_14050FBD0 (0x14050FBD0) ---
__int64 __fastcall sub_14050FBD0(__int64 a1, __int64 a2)
{
  int v2; // xmm0_4
  int v3; // xmm1_4
  int v4; // xmm3_4
  __int64 result; // rax

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a1 + 0xC);
  *(_BYTE *)a2 = *(_BYTE *)a1;
  result = a2;
  *(float *)(a2 + 4) = COERCE_FLOAT(v2 ^ 0x80000000);
  *(float *)(a2 + 8) = COERCE_FLOAT(v3 ^ 0x80000000);
  *(float *)(a2 + 0xC) = COERCE_FLOAT(v4 ^ 0x80000000);
  return result;
}

// --- End Function: sub_14050FBD0 (0x14050FBD0) ---

// --- Function: sub_1405178F0 (0x1405178F0) ---
__int64 __fastcall sub_1405178F0(__int64 a1)
{
  return a1 + 4;
}

// --- End Function: sub_1405178F0 (0x1405178F0) ---

// --- Function: sub_140518140 (0x140518140) ---
_BYTE *__fastcall sub_140518140(__int64 a1, _BYTE *a2)
{
  __int128 v2; // xmm1
  __int128 v3; // kr00_16
  __int128 n0x3EFA2A1C_1; // xmm3
  __int128 n0x3EFA2A1C; // kr00_16
  __int128 n0x3EFA2A1C_3; // xmm10
  __int128 n0x3EFA2A1C_2; // kr00_16
  __int128 n0x3EFA2A1C_5; // xmm11
  __int128 n0x3EFA2A1C_4; // kr00_16
  __int128 v11; // kr00_16
  int v14; // ecx
  __int128 v20; // kr00_16
  int v22; // r8d
  __int128 v28; // kr00_16
  int v30; // eax
  __int128 v35; // kr00_16
  _BYTE *result; // rax

  v3 = *(unsigned int *)(a1 + 0xC);
  *(float *)&v3 = *(float *)(a1 + 0xC) * 0.28209481;
  v2 = v3;
  n0x3EFA2A1C = 0x3EFA2A1Cu;
  *(float *)&n0x3EFA2A1C = 0.48860252 * *(float *)a1;
  n0x3EFA2A1C_1 = n0x3EFA2A1C;
  n0x3EFA2A1C_2 = 0x3EFA2A1Cu;
  *(float *)&n0x3EFA2A1C_2 = 0.48860252 * *(float *)(a1 + 4);
  n0x3EFA2A1C_3 = n0x3EFA2A1C_2;
  n0x3EFA2A1C_4 = 0x3EFA2A1Cu;
  *(float *)&n0x3EFA2A1C_4 = 0.48860252 * *(float *)(a1 + 8);
  n0x3EFA2A1C_5 = n0x3EFA2A1C_4;
  v11 = v2;
  *(float *)&v11 = *(float *)&v2 + 0.0019607844;
  _XMM2 = v11;
  LODWORD(_XMM0) = 0;
  if ( (float)(*(float *)&v2 + 0.0019607844) >= 0.0 )
    __asm { vminss  xmm0, xmm2, xmm5 }
  LODWORD(_XMM4) = 0xBF800000;
  v14 = (int)(float)(*(float *)&_XMM0 * 255.0);
  if ( *(float *)&n0x3EFA2A1C_1 >= -1.0 )
    __asm { vminss  xmm0, xmm3, xmm5 }
  else
    LODWORD(_XMM0) = 0xBF800000;
  _XMM2 = 0x80000000;
  __asm
  {
    vandnps xmm3, xmm3, xmm0
    vroundps xmm1, xmm3, 0
  }
  v20 = _XMM3;
  *(float *)&v20 = *(float *)&_XMM3 - *(float *)&_XMM1;
  _XMM3 = v20;
  __asm { vcmpeqss xmm3, xmm3, dword ptr cs:xmmword_14819FFB0 }
  v22 = (int)COERCE_FLOAT(
               COERCE_UNSIGNED_INT(COERCE_FLOAT(_XMM3 & 0x3F800000) + *(float *)&_XMM1)
             | COERCE_UNSIGNED_INT(*(float *)&_XMM0 * 127.0) & 0x80000000);
  if ( *(float *)&n0x3EFA2A1C_3 >= -1.0 )
    __asm { vminss  xmm0, xmm10, xmm5 }
  else
    LODWORD(_XMM0) = 0xBF800000;
  _XMM2 = 0x80000000;
  __asm
  {
    vandnps xmm3, xmm3, xmm0
    vroundps xmm1, xmm3, 0
  }
  v28 = _XMM3;
  *(float *)&v28 = *(float *)&_XMM3 - *(float *)&_XMM1;
  _XMM3 = v28;
  __asm { vcmpeqss xmm3, xmm3, dword ptr cs:xmmword_14819FFB0 }
  v30 = (int)COERCE_FLOAT(
               COERCE_UNSIGNED_INT(COERCE_FLOAT(_XMM3 & 0x3F800000) + *(float *)&_XMM1)
             | COERCE_UNSIGNED_INT(*(float *)&_XMM0 * 127.0) & 0x80000000);
  if ( *(float *)&n0x3EFA2A1C_5 >= -1.0 )
    __asm { vminss  xmm4, xmm11, xmm5 }
  _XMM2 = 0x80000000;
  __asm
  {
    vandnps xmm3, xmm3, xmm0
    vroundps xmm1, xmm3, 0
  }
  v35 = _XMM3;
  *(float *)&v35 = *(float *)&_XMM3 - *(float *)&_XMM1;
  _XMM3 = v35;
  __asm { vcmpeqss xmm3, xmm3, dword ptr cs:xmmword_14819FFB0 }
  a2[1] = v30;
  a2[2] = (int)COERCE_FLOAT(
                 COERCE_UNSIGNED_INT(COERCE_FLOAT(_XMM3 & 0x3F800000) + *(float *)&_XMM1)
               | COERCE_UNSIGNED_INT(*(float *)&_XMM4 * 127.0) & 0x80000000);
  result = a2;
  *a2 = v22;
  a2[3] = v14;
  return result;
}

// --- End Function: sub_140518140 (0x140518140) ---

// --- Function: sub_14051D540 (0x14051D540) ---
__int64 __fastcall sub_14051D540(__int64 a1, char a2, __int64 a3)
{
  __int64 result; // rax

  result = *(unsigned int *)(a3 + 8);
  *(double *)(a1 + 4) = *(double *)a3;
  *(_DWORD *)(a1 + 0xC) = result;
  *(_BYTE *)a1 = a2;
  return result;
}

// --- End Function: sub_14051D540 (0x14051D540) ---

// --- Function: sub_14051ED90 (0x14051ED90) ---
void __fastcall sub_14051ED90(__int64 a1, __int64 a2)
{
  volatile signed __int16 **v2; // rsi
  volatile signed __int16 *v3; // rcx
  unsigned int v4; // ebx
  volatile signed __int16 *v5; // rcx
  unsigned int v6; // ebx
  volatile signed __int16 *v7; // rbx
  volatile signed __int16 *v8; // rcx
  volatile signed __int16 *v9; // rbx
  volatile signed __int16 *v10; // [rsp+40h] [rbp+18h] BYREF

  v2 = (volatile signed __int16 **)(a1 + 8);
  if ( a2 || (v3 = *v2) == 0 )
  {
    (*(void (__fastcall **)(__int64, volatile signed __int16 **, __int64))(*(_QWORD *)pSystem + 0x928LL))(
      pSystem,
      &v10,
      a2);
    v5 = *v2;
    if ( *v2 && v10 != v5 )
    {
      v6 = *((_DWORD *)v5 + 1);
      if ( _InterlockedExchangeAdd16(v5, 0xFFFFu) == 1 )
        sub_1402A3D30((const void *)v5);
      *v2 = 0;
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)pSystem + 0x930LL))(pSystem, v6);
    }
    v7 = v10;
    if ( *v2 != v10 )
    {
      if ( v10 )
        _InterlockedIncrement16(v10);
      v8 = *v2;
      if ( *v2 && _InterlockedExchangeAdd16(v8, 0xFFFFu) == 1 )
        sub_1402A3D30((const void *)v8);
      *v2 = v7;
    }
    v9 = v10;
    if ( v10 && _InterlockedExchangeAdd16(v10, 0xFFFFu) == 1 )
      sub_1402A3D30((const void *)v9);
  }
  else
  {
    v4 = *((_DWORD *)v3 + 1);
    if ( _InterlockedExchangeAdd16(v3, 0xFFFFu) == 1 )
      sub_1402A3D30((const void *)v3);
    *v2 = 0;
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)pSystem + 0x930LL))(pSystem, v4);
  }
}

// --- End Function: sub_14051ED90 (0x14051ED90) ---

// --- Function: sub_14051EF10 (0x14051EF10) ---
__int64 __fastcall sub_14051EF10(_BYTE *a1, _BYTE *a2)
{
  __int64 result; // rax

  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  result = (unsigned __int8)a2[3];
  a1[3] = result;
  return result;
}

// --- End Function: sub_14051EF10 (0x14051EF10) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14189E9B0 (0x14189E9B0) ---
__m128 __fastcall sub_14189E9B0(__int64 a1)
{
  float v1; // xmm5_4
  __m128 result; // xmm0
  __m128 v3; // kr00_16
  __m128 v4; // xmm3
  __m128 v5; // kr00_16
  __m128 v6; // xmm4
  __m128 v7; // xmm0

  v1 = *(float *)(a1 + 0xC);
  if ( *(float *)a1 <= v1 )
  {
    v3 = (__m128)*(unsigned int *)(a1 + 4);
    v3.m128_f32[0] = (float)((float)(*(float *)(a1 + 4) * *(float *)(a1 + 4)) + (float)(*(float *)a1 * *(float *)a1))
                   + (float)(*(float *)(a1 + 8) * *(float *)(a1 + 8));
    v4 = v3;
    v5 = (__m128)*(unsigned int *)(a1 + 0x10);
    v6 = _mm_sqrt_ps(_mm_shuffle_ps(v4, v4, 0));
    v5.m128_f32[0] = (float)((float)(*(float *)(a1 + 0x10) * *(float *)(a1 + 0x10)) + (float)(v1 * v1))
                   + (float)(*(float *)(a1 + 0x14) * *(float *)(a1 + 0x14));
    v7 = _mm_sqrt_ps(_mm_shuffle_ps(v5, v5, 0));
    _XMM0 = _mm_shuffle_ps(v7, v7, 0xFF);
    _mm_shuffle_ps(v6, v6, 0xFF);
    __asm { vmaxss  xmm0, xmm0, xmm4 }
  }
  else
  {
    return (__m128)0LL;
  }
  return result;
}

// --- End Function: sub_14189E9B0 (0x14189E9B0) ---

// --- Function: sub_146A7D0E0 (0x146A7D0E0) ---
char __fastcall sub_146A7D0E0(__int64 a1, __int64 a2, unsigned int a3)
{
  char result; // al
  int v7; // ebx
  __int64 v8; // rcx
  signed __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rdi
  __int64 v12; // rax

  result = sub_14030EC00((unsigned __int64 *)(a1 - 0x70));
  if ( result && (*(_QWORD *)(a1 - 0x70) & 0xFFFFFFFFFFFFLL) != 0 )
  {
    v7 = 0;
    v8 = sub_14030EC00((unsigned __int64 *)(a1 - 0x70)) ? *(_QWORD *)(a1 - 0x70) & 0xFFFFFFFFFFFFLL : 0LL;
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x58LL))(v8);
    if ( !result )
    {
      if ( *(_DWORD *)(a1 + 0x1C8) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(a1 + 0x1CC);
      }
      else
      {
        v9 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x1B8));
        if ( (v9 & 0x200000) != 0 )
          sub_1403CB300(a1 + 0x1B8, v9, "CRenderProxy::AddGlowForSlot", "m_SlotsLock", 1);
      }
      if ( (__int64)(*(_QWORD *)(a1 + 0x70) - *(_QWORD *)(a1 + 0x68)) >> 3 )
      {
        do
        {
          v10 = sub_146ABEF00(a1 - 0x78, v7);
          v11 = v10;
          if ( v10 )
          {
            if ( (unsigned int)sub_146AB6C80(v10, a1 - 0x78) != 0xFFFFFFFF )
            {
              v12 = sub_1403AFA40(v11 + 0xE0);
              sub_14038DCA0(v12, a2, a3);
            }
          }
          ++v7;
        }
        while ( v7 < (unsigned __int64)((__int64)(*(_QWORD *)(a1 + 0x70) - *(_QWORD *)(a1 + 0x68)) >> 3) );
      }
      return sub_1402D2790(a1 + 0x1B8);
    }
  }
  return result;
}

// --- End Function: sub_146A7D0E0 (0x146A7D0E0) ---

// --- Function: sub_146A88AF0 (0x146A88AF0) ---
double __fastcall sub_146A88AF0(__int64 a1)
{
  __m128 v2; // xmm11
  signed __int64 v5; // rdi
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // r15
  __int128 n0x58635FA9; // xmm9
  __int64 v12; // rax
  __int64 v13; // rdi
  __int64 v14; // rcx
  float *v15; // rax
  __m128 v18; // xmm0
  float v21; // xmm7_4
  float v22; // xmm5_4
  float v23; // xmm4_4
  float v24; // xmm12_4
  float v25; // xmm10_4
  float v26; // xmm0_4
  float v27; // xmm14_4
  float v28; // xmm11_4
  float v29; // xmm6_4
  float v30; // xmm5_4
  float v31; // xmm4_4
  float v32; // xmm9_4
  float v33; // xmm7_4
  float v34; // xmm8_4
  float v35; // xmm3_4
  float v36; // xmm0_4
  float v37; // xmm12_4
  float v38; // xmm14_4
  __m128 v39; // kr00_16
  float v40; // xmm11_4
  __m128 v41; // xmm9
  float v42; // xmm10_4
  float v43; // xmm8_4
  float v44; // xmm13_4
  float v45; // xmm4_4
  float v46; // xmm7_4
  float v47; // xmm6_4
  float v48; // xmm4_4
  __m128 v49; // kr00_16
  __m128 v50; // xmm5
  __m128 v51; // kr00_16
  float v52; // xmm4_4
  __m128 v53; // xmm3
  __m128 v54; // kr00_16
  float v55; // xmm6_4
  __m128 v56; // kr00_16
  __m128 v57; // xmm5
  __m128 v58; // kr00_16
  __m128 v59; // xmm4
  __m128 v60; // xmm1
  __m128 v61; // kr00_16
  __m128 v62; // kr00_16
  __m128 v63; // xmm2
  __m128 v64; // kr00_16
  __m128 v65; // kr00_16
  float v68; // xmm12_4
  volatile signed __int64 *v69; // rdi
  int v70; // esi
  __int64 v71; // r8
  unsigned __int64 v72; // rax
  __m128 v74; // kr00_16
  __m128 v75; // xmm4
  __m128 v76; // kr00_16
  __m128 v77; // xmm0
  int v80; // eax
  unsigned __int64 n0x200000; // rax
  __m128 v83; // [rsp+30h] [rbp-D0h] BYREF
  float v84; // [rsp+40h] [rbp-C0h]
  float v85; // [rsp+44h] [rbp-BCh]
  _BYTE v86[24]; // [rsp+48h] [rbp-B8h]
  float v87; // [rsp+60h] [rbp-A0h]
  float v88; // [rsp+64h] [rbp-9Ch]
  __m128 v89; // [rsp+70h] [rbp-90h]
  __int128 v90; // [rsp+80h] [rbp-80h]
  int n0xF00; // [rsp+90h] [rbp-70h] BYREF
  __int64 v92; // [rsp+94h] [rbp-6Ch]
  int v93; // [rsp+9Ch] [rbp-64h]
  unsigned __int64 v94; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v95; // [rsp+A8h] [rbp-58h]
  __int64 v96; // [rsp+B0h] [rbp-50h]
  __int64 v97; // [rsp+B8h] [rbp-48h]
  __int128 v98; // [rsp+E0h] [rbp-20h]
  __m128 v99; // [rsp+F0h] [rbp-10h]
  __m128 v100; // [rsp+100h] [rbp+0h]
  __int64 p_n0xB[4]; // [rsp+110h] [rbp+10h] BYREF
  float v102; // [rsp+228h] [rbp+128h]
  float v103; // [rsp+230h] [rbp+130h]
  float v104; // [rsp+238h] [rbp+138h] BYREF

  n0xF00 = 0xF00;
  v93 = 0;
  v95 = 0;
  v96 = 0;
  v97 = 0;
  v92 = 1;
  v94 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0xF00,
    &word_1515B11FC,
    "CRenderProxy::CalcLocalBounds",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\RenderProxy.cpp",
    0x5A5);
  HIWORD(n0xF00) = word_1515B11FC;
  if ( (*(_DWORD *)(a1 + 0x194) & 4) == 0 )
  {
    v2 = (__m128)0xD8635FA9;
    LODWORD(_XMM7) = 0xD8635FA9;
    _XMM13 = 0;
    *(float *)&v86[0x14] = -9.9999999e14;
    v104 = 0.0;
    *(_OWORD *)&v86[4] = xmmword_148490550;
    if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0x244);
    }
    else
    {
      v5 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
      if ( (v5 & 0x200000) != 0 )
        sub_1403CB300(a1 + 0x230, v5, "CRenderProxy::CalcLocalBounds", "m_SlotsLock", 1);
      LODWORD(_XMM7) = *(_DWORD *)&v86[0x14];
    }
    v6 = 0;
    v7 = (__int64)(*(_QWORD *)(a1 + 0xE8) - *(_QWORD *)(a1 + 0xE0)) >> 3;
    if ( !v7 )
      goto LABEL_20;
    n0x58635FA9 = 0x58635FA9u;
    _XMM10 = (__m128)*(unsigned int *)&v86[0x10];
    _XMM8 = (__m128)*(unsigned int *)&v86[0xC];
    _XMM6 = *(unsigned int *)&v86[4];
    v103 = 9.9999999e14;
    *(float *)v86 = 9.9999999e14;
    v100 = (__m128)*(unsigned int *)&v86[0x10];
    v99 = (__m128)*(unsigned int *)&v86[0xC];
    v90 = *(unsigned int *)&v86[8];
    v98 = *(unsigned int *)&v86[4];
    do
    {
      v12 = *(_QWORD *)(a1 + 0xE0);
      v13 = *(_QWORD *)(v12 + 8 * v6);
      if ( v13 )
      {
        if ( (*(_BYTE *)(v13 + 0xD8) & 1) != 0 )
        {
          v14 = *(_QWORD *)(v12 + 8 * v6);
          v83 = (__m128)xmmword_148232290;
          v84 = v2.m128_f32[0];
          v85 = v2.m128_f32[0];
          if ( (unsigned __int8)sub_146AB72B0(v14, &v83, &v104) )
          {
            sub_14030EC00((unsigned __int64 *)(a1 + 8));
            if ( *(_QWORD *)v13 )
            {
              v15 = (float *)sub_146AC04D0(a1, (__int64)p_n0xB, v6, 0, 2);
              if ( v83.m128_f32[0] <= v83.m128_f32[3] )
              {
                v21 = *v15;
                v22 = v15[1];
                v23 = v15[2];
                v24 = v22 * (float)(v23 + v23);
                v25 = *v15 * (float)(v23 + v23);
                v87 = 1.0 - (float)((float)(v21 + v21) * v21);
                v102 = (float)(v22 + v22) * v22;
                v26 = v15[3];
                v27 = (float)(v21 + v21) * v26;
                v28 = (float)(v22 + v22) * v26;
                v29 = (float)(v22 + v22) * v21;
                v30 = (float)(v23 + v23) * v23;
                v31 = v26 * (float)(v23 + v23);
                v32 = (float)(v83.m128_f32[3] - v83.m128_f32[0]) * 0.5;
                v33 = (float)(v84 - v83.m128_f32[1]) * 0.5;
                v34 = (float)(v85 - v83.m128_f32[2]) * 0.5;
                v35 = v87;
                v88 = (float)((float)((float)(fabs((float)(1.0 - v102) - v30) * v32) + (float)(fabs(v29 - v31) * v33))
                            + (float)(fabs(v25 + v28) * v34))
                    * v15[7];
                v87 = (float)((float)((float)(fabs(v31 + v29) * v32) + (float)(fabs(v87 - v30) * v33))
                            + (float)(fabs(v24 - v27) * v34))
                    * v15[7];
                v36 = v24 + v27;
                v37 = v15[7];
                v38 = v15[1];
                v39 = (__m128)LODWORD(v84);
                v40 = (float)((float)((float)(fabs(v25 - v28) * v32)
                                    + (float)(COERCE_FLOAT(LODWORD(v36) & 0x7FFFFFFF) * v33))
                            + (float)(fabs(v35 - v102) * v34))
                    * v37;
                v39.m128_f32[0] = (float)(v84 + v83.m128_f32[1]) * 0.5;
                v41 = v39;
                v42 = (float)(v85 + v83.m128_f32[2]) * 0.5;
                v43 = (float)(v83.m128_f32[3] + v83.m128_f32[0]) * 0.5;
                v44 = v15[2];
                v45 = v15[3];
                v46 = (float)((float)(v38 * v42) - (float)(v39.m128_f32[0] * v44)) + (float)(v43 * v45);
                v47 = (float)((float)(v43 * v44) - (float)(*v15 * v42)) + (float)(v39.m128_f32[0] * v45);
                v48 = (float)((float)(*v15 * v39.m128_f32[0]) - (float)(v38 * v43)) + (float)(v42 * v45);
                v49 = (__m128)LODWORD(v38);
                v49.m128_f32[0] = (float)(v38 * v48) - (float)(v47 * v44);
                v50 = v49;
                v51 = (__m128)*(unsigned int *)v15;
                v52 = (float)(v46 * v44) - (float)(*v15 * v48);
                v51.m128_f32[0] = (float)(*v15 * v47) - (float)(v38 * v46);
                v53 = v51;
                v54 = v50;
                v55 = (float)((float)((float)(v50.m128_f32[0] + v43) + v50.m128_f32[0]) * v37) + v15[4];
                v54.m128_f32[0] = v55 + v88;
                _XMM14 = v54;
                v56 = v41;
                v56.m128_f32[0] = v41.m128_f32[0] + v52;
                n0x58635FA9 = LODWORD(v103);
                v56.m128_f32[0] = (float)((float)(v56.m128_f32[0] + v52) * v37) + v15[5];
                v57 = v56;
                v58 = v53;
                v58.m128_f32[0] = (float)((float)((float)(v53.m128_f32[0] + v42) + v53.m128_f32[0]) * v37) + v15[6];
                v59 = v58;
                v61 = v57;
                v61.m128_f32[0] = v57.m128_f32[0] - v87;
                v60 = v61;
                v62 = v57;
                v62.m128_f32[0] = v57.m128_f32[0] + v87;
                _XMM12 = v62;
                v64 = v59;
                v64.m128_f32[0] = v59.m128_f32[0] - v40;
                v63 = v64;
                v65 = v59;
                v65.m128_f32[0] = v59.m128_f32[0] + v40;
                _XMM13 = v65;
                v2 = (__m128)0xD8635FA9;
                v83.m128_f32[0] = v55 - v88;
                v83.m128_f32[2] = v63.m128_f32[0];
                v85 = v65.m128_f32[0];
                _XMM15 = v63;
                v83.m128_f32[1] = v60.m128_f32[0];
                v83.m128_f32[3] = _XMM14.m128_f32[0];
                v84 = _XMM12.m128_f32[0];
                v18 = v60;
              }
              else
              {
                v83 = (__m128)xmmword_148232290;
                _XMM14 = _mm_shuffle_ps(v83, v83, 0xFF);
                _XMM15 = _mm_shuffle_ps(v83, v83, 0xAA);
                v18 = _mm_shuffle_ps(v83, v83, 0x55);
                v84 = v2.m128_f32[0];
                v85 = v2.m128_f32[0];
                _XMM12 = v2;
                _XMM13 = v2;
              }
            }
            else
            {
              _XMM13 = (__m128)LODWORD(v85);
              _XMM12 = (__m128)LODWORD(v84);
              _XMM14 = (__m128)v83.m128_u32[3];
              _XMM15 = (__m128)v83.m128_u32[2];
              v18 = (__m128)v83.m128_u32[1];
            }
            v89 = v18;
            sub_14030EC00((unsigned __int64 *)(a1 + 8));
            _XMM0 = v89;
            __asm { vminss  xmm6, xmm0, xmm6 }
            __asm { vminss  xmm9, xmm9, xmm8 }
            __asm { vminss  xmm0, xmm15, xmm0 }
            __asm
            {
              vmaxss  xmm8, xmm14, xmm8
              vmaxss  xmm10, xmm12, xmm10
              vmaxss  xmm7, xmm13, xmm7
            }
            *(float *)&v86[8] = *(float *)&_XMM0;
            v90 = _XMM0;
            v103 = *(float *)&n0x58635FA9;
            *(float *)v86 = *(float *)&n0x58635FA9;
            *(float *)&v86[4] = *(float *)&_XMM6;
            *(float *)&v86[0xC] = _XMM8.m128_f32[0];
            *(float *)&v86[0x10] = _XMM10.m128_f32[0];
            *(float *)&v86[0x14] = *(float *)&_XMM7;
            v98 = _XMM6;
            v99 = _XMM8;
            v100 = _XMM10;
          }
        }
      }
      ++v6;
    }
    while ( v6 < v7 );
    _XMM13 = 0;
    if ( *(float *)&n0x58635FA9 <= _XMM8.m128_f32[0] )
    {
      v68 = *(float *)&v90;
    }
    else
    {
LABEL_20:
      _XMM6 = xmmword_148C315C0;
      LODWORD(n0x58635FA9) = 0x80000000;
      LODWORD(_XMM7) = 0;
      *(float *)&v86[0x14] = 0.0;
      *(float *)v86 = -0.0;
      *(_OWORD *)&v86[4] = xmmword_148C315C0;
      _XMM10 = _mm_shuffle_ps(*(__m128 *)&v86[4], *(__m128 *)&v86[4], 0xFF);
      _XMM8 = _mm_shuffle_ps(*(__m128 *)&v86[4], *(__m128 *)&v86[4], 0xAA);
      LODWORD(v68) = _mm_shuffle_ps(*(__m128 *)&v86[4], *(__m128 *)&v86[4], 0x55).m128_u32[0];
    }
    v69 = (volatile signed __int64 *)(a1 + 0x100);
    v70 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x110) == v70 )
    {
      ++*(_DWORD *)(a1 + 0x114);
    }
    else
    {
      v71 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v72 = _InterlockedCompareExchange64(v69, 0x200000, 0);
      if ( v72 )
        sub_1403DCD60(a1 + 0x100, v72, v71, "CRenderProxy::CalcLocalBounds", "localBBoxLock", 1);
      else
        *(_QWORD *)(a1 + 0x108) = v71;
      LODWORD(_XMM7) = *(_DWORD *)&v86[0x14];
      _XMM10 = (__m128)*(unsigned int *)&v86[0x10];
      _XMM8 = (__m128)*(unsigned int *)&v86[0xC];
      v68 = *(float *)&v86[8];
      _XMM6 = *(unsigned int *)&v86[4];
      LODWORD(n0x58635FA9) = *(_DWORD *)v86;
      *(_DWORD *)(a1 + 0x110) = v70;
    }
    __asm { vunpcklps xmm1, xmm10, xmm7 }
    *(_OWORD *)(a1 + 0x118) = *(_OWORD *)v86;
    *(double *)(a1 + 0x128) = *(double *)&_XMM1;
    *(double *)&v86[0x10] = *(double *)&_XMM1;
    if ( *(float *)&n0x58635FA9 <= _XMM8.m128_f32[0] )
    {
      v74 = (__m128)_XMM6;
      v74.m128_f32[0] = (float)((float)(*(float *)&_XMM6 * *(float *)&_XMM6)
                              + (float)(*(float *)&n0x58635FA9 * *(float *)&n0x58635FA9))
                      + (float)(v68 * v68);
      v75 = _mm_sqrt_ps(_mm_shuffle_ps(v74, v74, 0));
      v76 = _XMM8;
      v76.m128_f32[0] = (float)((float)(_XMM8.m128_f32[0] * _XMM8.m128_f32[0])
                              + (float)(_XMM10.m128_f32[0] * _XMM10.m128_f32[0]))
                      + (float)(*(float *)&_XMM7 * *(float *)&_XMM7);
      v77 = _mm_sqrt_ps(_mm_shuffle_ps(v76, v76, 0));
      _XMM0 = _mm_shuffle_ps(v77, v77, 0xFF);
      _mm_shuffle_ps(v75, v75, 0xFF);
      __asm { vmaxss  xmm13, xmm0, xmm4 }
    }
    __asm { vmaxss  xmm0, xmm13, [rbp+110h+arg_18] }
    *(float *)(a1 + 0x130) = *(float *)&_XMM0;
    if ( a1 != 0xFFFFFFFFFFFFFF00uLL )
    {
      v80 = *(_DWORD *)(a1 + 0x114);
      if ( v80 )
      {
        *(_DWORD *)(a1 + 0x114) = v80 - 1;
      }
      else
      {
        *(_DWORD *)(a1 + 0x110) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64(v69, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
          *(_QWORD *)(a1 + 0x108) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        else
          sub_1403DD380(a1 + 0x100, n0x200000);
      }
    }
    *(_DWORD *)(a1 + 0x194) |= 2u;
    sub_1402D2790(a1 + 0x230);
  }
  v95 = __rdtsc();
  return qword_149B4B878(&n0xF00);
}

// --- End Function: sub_146A88AF0 (0x146A88AF0) ---

// --- Function: sub_146A8E3B0 (0x146A8E3B0) ---
char __fastcall sub_146A8E3B0(__int64 a1, __int64 a2)
{
  __int64 v5; // rax
  __int64 v6; // r13
  unsigned int v7; // r15d
  int v8; // edi
  __int64 v9; // rax
  __int64 *v10; // rbx
  volatile signed __int32 *v11; // rsi
  __int64 **v12; // r8
  __int64 *v13; // rdx
  signed __int32 v14; // eax
  signed __int32 v15; // ett
  __int64 v16; // rcx
  char v17; // al
  __int64 v18; // rcx
  __int64 v19; // rax
  __int64 v20; // rdi
  char v21; // al
  __int64 v22; // rax
  char v23; // di
  int v24; // eax
  __int64 *v25; // rcx
  int n3; // eax
  __int64 *v27; // rcx
  int v28; // ebx
  __int64 v29; // [rsp+20h] [rbp-40h] BYREF
  __int64 v30; // [rsp+28h] [rbp-38h] BYREF
  __int64 v31; // [rsp+30h] [rbp-30h] BYREF
  __int64 v32; // [rsp+38h] [rbp-28h] BYREF
  __int64 v33; // [rsp+40h] [rbp-20h] BYREF
  __int64 v34; // [rsp+48h] [rbp-18h]
  _BYTE v35[8]; // [rsp+50h] [rbp-10h] BYREF
  __int64 v36; // [rsp+58h] [rbp-8h]
  int v37; // [rsp+A8h] [rbp+48h]
  __int64 v38; // [rsp+B0h] [rbp+50h] BYREF
  unsigned __int64 v39; // [rsp+B8h] [rbp+58h] BYREF

  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a2 + 0x168LL))(a2, &v32);
  if ( v32 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x98LL))(v32) )
    {
      if ( !v32 )
        return 1;
      (*(void (**)(void))(*(_QWORD *)v32 + 0x10LL))();
      return 1;
    }
    if ( v32 )
      (*(void (**)(void))(*(_QWORD *)v32 + 0x10LL))();
  }
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 0x50LL))(a2);
  v34 = v5;
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = 0;
  v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x70LL))(v5);
  v8 = v37;
  if ( v37 <= 0 )
    return 0;
  while ( 1 )
  {
    v9 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x60LL))(v6, v7);
    if ( v9 )
      break;
LABEL_62:
    if ( (int)++v7 >= v8 )
      return 0;
  }
  v10 = 0;
  v11 = 0;
  v12 = (__int64 **)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v9 + 0x158LL))(v9, v35);
  v13 = v12[1];
  if ( v13 )
  {
    v14 = *((_DWORD *)v13 + 2);
    if ( v14 )
    {
      while ( 1 )
      {
        v15 = v14;
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)v13 + 2, v14 + 1, v14);
        if ( v15 == v14 )
          break;
        if ( !v14 )
          goto LABEL_16;
      }
      v10 = *v12;
      v11 = (volatile signed __int32 *)v12[1];
    }
  }
LABEL_16:
  v16 = v36;
  if ( v36 && _InterlockedExchangeAdd((volatile signed __int32 *)(v36 + 0xC), 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(__int64, __int64 *, __int64 **))(*(_QWORD *)v16 + 8LL))(v16, v13, v12);
  if ( !v10 )
  {
LABEL_58:
    if ( v11 && _InterlockedExchangeAdd(v11 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *, __int64, __int64 **))v11)(v11, (__int64)v13, v12);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
    }
    goto LABEL_62;
  }
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 **))(*v10 + 0x70))(v10, &v29, v12);
  if ( v29 )
  {
    v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x98LL))(v29);
    v18 = v29;
    if ( v17 )
      goto LABEL_64;
    if ( v29 )
      (*(void (**)(void))(*(_QWORD *)v29 + 0x10LL))();
  }
  v19 = *v10;
  v29 = 0;
  v20 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, __int64 *))(v19 + 0xA0))(v10, &v33);
  if ( v33 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v33 + 8LL))(v33);
  v33 = 0;
  if ( !v20 )
  {
LABEL_32:
    v22 = (*(__int64 (__fastcall **)(__int64 *))(*v10 + 0xA8))(v10);
    if ( v22 )
    {
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v22 + 0x18LL))(v22, &v31);
      if ( v31 )
      {
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v31 + 0xF8LL))(v31, &v38);
        if ( v38 )
        {
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v38 + 0x98LL))(v38) )
          {
            if ( v38 )
              (*(void (**)(void))(*(_QWORD *)v38 + 0x10LL))();
            v38 = v20;
            if ( v31 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 8LL))(v31);
            goto LABEL_70;
          }
          if ( v38 )
            (*(void (**)(void))(*(_QWORD *)v38 + 0x10LL))();
        }
        v38 = v20;
        if ( v31 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 8LL))(v31);
      }
      v31 = v20;
    }
    v23 = 0;
    v24 = (*(__int64 (__fastcall **)(__int64 *))(*v10 + 8))(v10);
    v25 = 0;
    if ( v24 == 1 )
      v25 = v10;
    if ( v25 )
    {
      if ( (*(__int64 (__fastcall **)(__int64 *))(*v25 + 0xE0))(v25) && (unsigned __int8)sub_146A8E3B0(a1) )
        v23 = 1;
    }
    else
    {
      n3 = (*(__int64 (__fastcall **)(__int64 *))(*v10 + 8))(v10);
      v27 = 0;
      if ( n3 == 3 )
        v27 = v10;
      if ( !v27
        || ((*(void (__fastcall **)(__int64 *, unsigned __int64 *))(*v27 + 0xF0))(v27, &v39), !sub_14030EC00(&v39))
        || (v28 = 0,
            (*(int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v39 & 0xFFFFFFFFFFFFLL) + 0x490LL))(v39 & 0xFFFFFFFFFFFFLL) <= 0) )
      {
LABEL_57:
        v8 = v37;
        goto LABEL_58;
      }
      do
      {
        if ( (*(__int64 (__fastcall **)(unsigned __int64, _QWORD))(*(_QWORD *)(v39 & 0xFFFFFFFFFFFFLL) + 0x4F8LL))(
               v39 & 0xFFFFFFFFFFFFLL,
               (unsigned int)v28) )
        {
          v23 |= sub_146A8E3B0(a1);
        }
        ++v28;
      }
      while ( v28 < (*(int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v39 & 0xFFFFFFFFFFFFLL) + 0x490LL))(v39 & 0xFFFFFFFFFFFFLL) );
      v6 = v34;
    }
    if ( v23 )
      goto LABEL_70;
    goto LABEL_57;
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v20 + 0x228LL))(v20, &v30);
  if ( !v30 )
  {
LABEL_31:
    v20 = 0;
    v30 = 0;
    goto LABEL_32;
  }
  v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x98LL))(v30);
  v18 = v30;
  if ( !v21 )
  {
    if ( v30 )
      (*(void (**)(void))(*(_QWORD *)v30 + 0x10LL))();
    goto LABEL_31;
  }
LABEL_64:
  if ( v18 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x10LL))(v18);
LABEL_70:
  if ( v11 )
  {
    if ( _InterlockedExchangeAdd(v11 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
    }
  }
  return 1;
}

// --- End Function: sub_146A8E3B0 (0x146A8E3B0) ---

// --- Function: sub_146AB6C80 (0x146AB6C80) ---
__int64 __fastcall sub_146AB6C80(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rcx
  unsigned int v6; // ebp
  void (__fastcall ***v7)(_QWORD); // rax
  void (__fastcall ***v8)(_QWORD); // rbx
  __int64 v9; // rcx
  __int64 v10; // rax
  unsigned int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rdx

  if ( !*(_QWORD *)(a1 + 0x58) && !*(_QWORD *)(a1 + 0x80) )
    return 0xFFFFFFFFLL;
  result = sub_1403B0540(a1 + 0xE0);
  if ( (_DWORD)result == 0xFFFFFFFF )
  {
    v5 = *(_QWORD *)(a1 + 0x58);
    v6 = 1;
    if ( v5 )
    {
      v7 = (void (__fastcall ***)(_QWORD))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x30LL))(v5);
      v8 = v7;
      if ( v7 )
      {
        (**v7)(v7);
        v6 = ((__int64 (__fastcall *)(_QWORD))(*v8)[0x7B])(v8);
        (*v8)[1](v8);
      }
    }
    else
    {
      v9 = *(_QWORD *)(a1 + 0x80);
      if ( v9 )
      {
        v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x2E8LL))(v9);
        if ( v10 )
        {
          v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x3E0LL))(v10);
        }
        else
        {
          v12 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x80) + 0x70LL))(*(_QWORD *)(a1 + 0x80));
          v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x10LL))(v12);
        }
        v6 = v11;
      }
    }
    v13 = a2 + 0x78;
    if ( !a2 )
      v13 = 0;
    return sub_1403BA880(a1 + 0xE0, v13, v6);
  }
  return result;
}

// --- End Function: sub_146AB6C80 (0x146AB6C80) ---

// --- Function: sub_146AB72B0 (0x146AB72B0) ---
char __fastcall sub_146AB72B0(_QWORD *a1, float *a2, float *a3)
{
  __int64 v5; // rcx
  __int64 v7; // rax
  unsigned int *v8; // rax
  __int64 v22; // rcx
  __int128 n0x3F000000; // xmm3
  __int128 n0x3F000000_1; // xmm4
  __int64 v35; // rcx
  __int64 v36; // rax
  unsigned int *v39; // rax
  __int128 n0x3FC00000_1; // xmm2
  __int128 n0x3FC00000; // kr00_16
  __int128 n0x3DCCCCCD_1; // xmm2
  __int128 n0x3DCCCCCD; // kr00_16
  __int128 n0x3DCCCCCD_3; // xmm3
  __int128 n0x3DCCCCCD_2; // kr00_16
  __int128 n0x3DCCCCCD_5; // xmm4
  __int128 n0x3DCCCCCD_4; // kr00_16
  __int64 v68; // rcx
  __int64 v69; // rax
  __m128 v70; // [rsp+20h] [rbp-28h] BYREF
  unsigned int n0x3F000000_3; // [rsp+30h] [rbp-18h]
  unsigned int n0x3F000000_2; // [rsp+34h] [rbp-14h]

  v5 = a1[0xB];
  if ( v5 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x30LL))(v5);
    if ( v7 )
    {
      v8 = (unsigned int *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x280LL))(v7);
      _XMM0 = *(unsigned int *)a2;
      __asm { vminss  xmm1, xmm0, dword ptr [rax] }
      *a2 = *(float *)&_XMM1;
      _XMM0 = v8[1];
      __asm { vminss  xmm1, xmm0, dword ptr [rbx+4] }
      a2[1] = *(float *)&_XMM1;
      _XMM0 = v8[2];
      __asm { vminss  xmm1, xmm0, dword ptr [rbx+8] }
      a2[2] = *(float *)&_XMM1;
      _XMM0 = v8[3];
      __asm { vmaxss  xmm1, xmm0, dword ptr [rbx+0Ch] }
      a2[3] = *(float *)&_XMM1;
      _XMM0 = v8[4];
      __asm { vmaxss  xmm1, xmm0, dword ptr [rbx+10h] }
      a2[4] = *(float *)&_XMM1;
      _XMM0 = v8[5];
      __asm { vmaxss  xmm1, xmm0, dword ptr [rbx+14h] }
      a2[5] = *(float *)&_XMM1;
      return 1;
    }
    return 0;
  }
  v22 = a1[0xD];
  if ( !v22 )
  {
    v35 = a1[0x10];
    if ( v35 )
    {
      v36 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v35 + 0xB0LL))(v35);
      sub_14189E9B0(v36);
      _XMM1 = *(unsigned int *)a3;
      __asm { vmaxss  xmm0, xmm1, xmm0 }
      *a3 = *(float *)&_XMM0;
      v39 = (unsigned int *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)a1[0x10] + 0xB8LL))(a1[0x10]);
      _XMM0 = *(unsigned int *)a2;
      __asm { vminss  xmm1, xmm0, dword ptr [rax] }
      *a2 = *(float *)&_XMM1;
      _XMM0 = v39[1];
      __asm { vminss  xmm1, xmm0, dword ptr [rbx+4] }
      a2[1] = *(float *)&_XMM1;
      _XMM0 = v39[2];
      __asm { vminss  xmm1, xmm0, dword ptr [rbx+8] }
      a2[2] = *(float *)&_XMM1;
      _XMM0 = *((unsigned int *)a2 + 3);
      __asm { vmaxss  xmm1, xmm0, dword ptr [rax+0Ch] }
      a2[3] = *(float *)&_XMM1;
      _XMM0 = v39[4];
      __asm { vmaxss  xmm1, xmm0, dword ptr [rbx+10h] }
      a2[4] = *(float *)&_XMM1;
      _XMM0 = v39[5];
      __asm { vmaxss  xmm1, xmm0, dword ptr [rbx+14h] }
      a2[5] = *(float *)&_XMM1;
      return 1;
    }
    if ( a1[0x11] )
    {
      n0x3FC00000 = (unsigned int)n0x3FC00000_0;
      *(float *)&n0x3FC00000 = *(float *)&n0x3FC00000_0 - 0.1;
      n0x3FC00000_1 = n0x3FC00000;
      __asm { vminss  xmm1, xmm2, dword ptr [rdx] }
      *a2 = *(float *)&_XMM1;
      _XMM0 = *((unsigned int *)a2 + 1);
      __asm { vminss  xmm1, xmm0, xmm3 }
      a2[1] = *(float *)&_XMM1;
      _XMM0 = *((unsigned int *)a2 + 2);
      __asm { vminss  xmm1, xmm0, xmm4 }
      a2[2] = *(float *)&_XMM1;
      n0x3DCCCCCD = 0x3DCCCCCDu;
      *(float *)&n0x3DCCCCCD = *(float *)&n0x3FC00000_0 + 0.1;
      n0x3DCCCCCD_1 = n0x3DCCCCCD;
      __asm { vmaxss  xmm1, xmm2, dword ptr [rdx+0Ch] }
      n0x3DCCCCCD_2 = 0x3DCCCCCDu;
      *(float *)&n0x3DCCCCCD_2 = *((float *)&n0x3FC00000_0 + 1) + 0.1;
      n0x3DCCCCCD_3 = n0x3DCCCCCD_2;
      n0x3DCCCCCD_4 = 0x3DCCCCCDu;
      *(float *)&n0x3DCCCCCD_4 = *(float *)&dword_149924778 + 0.1;
      n0x3DCCCCCD_5 = n0x3DCCCCCD_4;
      a2[3] = *(float *)&_XMM1;
      __asm { vmaxss  xmm0, xmm3, dword ptr [rdx+10h] }
      a2[4] = *(float *)&_XMM0;
      __asm { vmaxss  xmm1, xmm4, dword ptr [rdx+14h] }
      a2[5] = *(float *)&_XMM1;
      return 1;
    }
    v68 = a1[0x12];
    if ( v68 )
    {
      v69 = (*(__int64 (__fastcall **)(__int64, __m128 *))(*(_QWORD *)v68 + 0x60LL))(v68, &v70);
      *(_OWORD *)a2 = *(_OWORD *)v69;
      *((double *)a2 + 2) = *(double *)(v69 + 0x10);
      return 1;
    }
    return 0;
  }
  (*(void (__fastcall **)(__int64, __m128 *))(*(_QWORD *)v22 + 0x68LL))(v22, &v70);
  if ( v70.m128_f32[0] <= v70.m128_f32[3] )
  {
    n0x3F000000_1 = n0x3F000000_2;
    n0x3F000000 = n0x3F000000_3;
  }
  else
  {
    n0x3F000000 = 0x3F000000u;
    v70 = (__m128)xmmword_1485449E0;
    n0x3F000000_1 = 0x3F000000u;
    _mm_shuffle_ps(v70, v70, 0xFF);
  }
  _XMM0 = *(unsigned int *)a2;
  __asm { vminss  xmm1, xmm0, xmm1 }
  *a2 = *(float *)&_XMM1;
  _XMM0 = *((unsigned int *)a2 + 1);
  __asm { vminss  xmm1, xmm0, dword ptr [rsp+48h+var_28+4] }
  a2[1] = *(float *)&_XMM1;
  _XMM0 = *((unsigned int *)a2 + 2);
  __asm { vminss  xmm1, xmm0, dword ptr [rsp+48h+var_28+8] }
  a2[2] = *(float *)&_XMM1;
  _XMM0 = *((unsigned int *)a2 + 3);
  __asm { vmaxss  xmm1, xmm0, xmm2 }
  a2[3] = *(float *)&_XMM1;
  __asm { vmaxss  xmm0, xmm3, dword ptr [rbx+10h] }
  a2[4] = *(float *)&_XMM0;
  __asm { vmaxss  xmm1, xmm4, dword ptr [rbx+14h] }
  a2[5] = *(float *)&_XMM1;
  return 1;
}

// --- End Function: sub_146AB72B0 (0x146AB72B0) ---

// --- Function: sub_146ABEF00 (0x146ABEF00) ---
__int64 __fastcall sub_146ABEF00(__int64 a1, int a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  signed __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rdi

  v2 = a2;
  v3 = a1 + 0x230;
  if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)v3);
    if ( (v5 & 0x200000) != 0 )
      sub_1403CB300(v3, v5, "CRenderProxy::GetSlot", "m_SlotsLock", 1);
  }
  if ( (int)v2 < 0 || (v6 = *(_QWORD *)(a1 + 0xE0), (int)v2 >= (int)((*(_QWORD *)(a1 + 0xE8) - v6) >> 3)) )
    v7 = 0;
  else
    v7 = *(_QWORD *)(v6 + 8 * v2);
  sub_1402D2790(v3);
  return v7;
}

// --- End Function: sub_146ABEF00 (0x146ABEF00) ---

// --- Function: sub_146AC04D0 (0x146AC04D0) ---
__int64 __fastcall sub_146AC04D0(__int64 a1, __int64 p_n0xB, int a3, char a4, int n2)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  __int128 v8; // xmm9
  __int128 v9; // xmm10
  __int128 v10; // xmm11
  __int128 v11; // xmm12
  __int128 v12; // xmm13
  __int128 v13; // xmm14
  __int128 v14; // xmm15
  float v18; // xmm7_4
  float v19; // xmm13_4
  float v20; // xmm9_4
  float v21; // xmm11_4
  __int64 v22; // r14
  int v23; // ebx
  unsigned int v24; // esi
  signed __int64 v25; // rdx
  __int64 v26; // r8
  __int64 *v27; // r8
  __int64 *v28; // rdx
  __int64 v29; // rax
  float v30; // xmm14_4
  float v31; // xmm10_4
  int n0x3F800000; // xmm1_4
  float v34; // xmm4_4
  float v35; // xmm2_4
  __int64 v36; // rcx
  float v37; // xmm8_4
  float v38; // xmm3_4
  float v39; // xmm5_4
  __int32 v40; // eax
  __m128 v41; // xmm12
  float v42; // xmm6_4
  float v43; // xmm5_4
  float v44; // xmm4_4
  __int128 v45; // kr00_16
  __m128 v46; // kr00_16
  int epi32; // esi
  __int64 v49; // rax
  __m128 _Al__204_1; // xmm0
  __m128 v51; // xmm2
  float v52; // xmm1_4
  __int64 v53; // rcx
  __int64 v54; // rax
  __int64 v55; // r15
  __int64 v56; // rbx
  float v57; // xmm15_4
  __m128 v58; // xmm13
  float v59; // xmm14_4
  float v60; // xmm11_4
  float v61; // xmm10_4
  float v62; // xmm12_4
  __m128 v63; // kr00_16
  __m128 v66; // xmm1
  float v67; // xmm7_4
  float v68; // xmm5_4
  __m128 v69; // kr00_16
  __m128 v70; // xmm6
  float v73; // xmm8_4
  float v74; // xmm7_4
  __m128 v75; // xmm6
  __m128 v76; // kr00_16
  float v77; // xmm10_4
  float v78; // xmm14_4
  __m128 v79; // kr00_16
  float v80; // xmm15_4
  __m128 v81; // xmm2
  __m128 v82; // kr00_16
  float v83; // xmm13_4
  float v84; // xmm11_4
  float v85; // xmm12_4
  __m128 v86; // xmm1
  __m128 v87; // kr00_16
  __m128 v88; // xmm3
  __m128 v89; // kr00_16
  __m128 v90; // xmm3
  float v91; // xmm2_4
  float v92; // xmm1_4
  __m128 v93; // kr00_16
  __m128 v94; // xmm3
  float v95; // xmm10_4
  float v96; // xmm9_4
  float v97; // xmm8_4
  float v98; // xmm6_4
  float v99; // xmm7_4
  float v100; // xmm5_4
  float v101; // xmm4_4
  float v102; // xmm9_4
  float v103; // xmm7_4
  float v104; // xmm2_4
  float v105; // xmm10_4
  float v106; // xmm6_4
  float v107; // xmm12_4
  float v109; // xmm10_4
  __int64 p_n0xB_1; // rax
  __int64 v111; // rcx
  __int64 *v112; // rcx
  __int64 v113; // rax
  unsigned __int64 *v114; // rax
  float v131; // [rsp+38h] [rbp-D0h]
  float v132; // [rsp+38h] [rbp-D0h]
  float v133; // [rsp+3Ch] [rbp-CCh]
  float v134; // [rsp+3Ch] [rbp-CCh]
  float v135; // [rsp+40h] [rbp-C8h]
  float v136; // [rsp+40h] [rbp-C8h]
  float v137; // [rsp+44h] [rbp-C4h]
  float v138; // [rsp+44h] [rbp-C4h]
  float v139; // [rsp+48h] [rbp-C0h]
  float v140; // [rsp+48h] [rbp-C0h]
  float v141; // [rsp+4Ch] [rbp-BCh]
  float v142; // [rsp+4Ch] [rbp-BCh]
  float v143; // [rsp+50h] [rbp-B8h]
  float v144; // [rsp+50h] [rbp-B8h]
  float v145; // [rsp+54h] [rbp-B4h]
  float v146; // [rsp+54h] [rbp-B4h]
  float v147; // [rsp+58h] [rbp-B0h]
  float v148; // [rsp+5Ch] [rbp-ACh]
  float v149; // [rsp+5Ch] [rbp-ACh]
  float v150; // [rsp+60h] [rbp-A8h]
  float v151; // [rsp+60h] [rbp-A8h]
  float v152; // [rsp+64h] [rbp-A4h]
  float v153; // [rsp+64h] [rbp-A4h]
  float v154; // [rsp+68h] [rbp-A0h]
  float v155; // [rsp+68h] [rbp-A0h]
  float v156; // [rsp+6Ch] [rbp-9Ch]
  float v157; // [rsp+70h] [rbp-98h]
  float v158; // [rsp+74h] [rbp-94h]
  float v159; // [rsp+78h] [rbp-90h]
  float v160; // [rsp+7Ch] [rbp-8Ch]
  float v161; // [rsp+80h] [rbp-88h]
  float v162; // [rsp+84h] [rbp-84h]
  float v163; // [rsp+88h] [rbp-80h]
  float v164; // [rsp+8Ch] [rbp-7Ch]
  float v165; // [rsp+90h] [rbp-78h]
  float v166; // [rsp+94h] [rbp-74h]
  float v167; // [rsp+98h] [rbp-70h]
  float v168; // [rsp+9Ch] [rbp-6Ch]
  float v169; // [rsp+A0h] [rbp-68h]
  float v170; // [rsp+A4h] [rbp-64h]
  float v171; // [rsp+A8h] [rbp-60h]
  float v172; // [rsp+ACh] [rbp-5Ch]
  float v173; // [rsp+B0h] [rbp-58h]
  float v174; // [rsp+B4h] [rbp-54h]
  float v175; // [rsp+B8h] [rbp-50h]
  double v176; // [rsp+C0h] [rbp-48h] BYREF
  double v177; // [rsp+C8h] [rbp-40h]
  __m128 _Al__204; // [rsp+D0h] [rbp-38h]
  double v179; // [rsp+E0h] [rbp-28h]
  double v180; // [rsp+E8h] [rbp-20h]
  double v181; // [rsp+F0h] [rbp-18h]
  double v182; // [rsp+F8h] [rbp-10h]
  __m128 v183; // [rsp+108h] [rbp+0h] BYREF
  unsigned __int64 v184; // [rsp+118h] [rbp+10h]
  _QWORD v185[3]; // [rsp+150h] [rbp+48h]
  __int128 v186; // [rsp+168h] [rbp+60h]
  __int128 v187; // [rsp+178h] [rbp+70h]
  __int128 v188; // [rsp+188h] [rbp+80h]
  __int128 v189; // [rsp+198h] [rbp+90h]
  __int128 v190; // [rsp+1A8h] [rbp+A0h]
  __int128 v191; // [rsp+1B8h] [rbp+B0h]
  __int128 v192; // [rsp+1C8h] [rbp+C0h]
  __int128 v193; // [rsp+1D8h] [rbp+D0h]
  __int128 v194; // [rsp+1E8h] [rbp+E0h]
  float v195; // [rsp+238h] [rbp+130h]
  float v196; // [rsp+238h] [rbp+130h]

  v194 = v5;
  v193 = v6;
  v192 = v7;
  v191 = v8;
  v190 = v9;
  v189 = v10;
  v188 = v11;
  v187 = v12;
  v186 = v13;
  v18 = 0.0;
  v19 = 0.0;
  v20 = 0.0;
  v176 = 0.0;
  v147 = 1.0;
  v177 = 0.0078125;
  v133 = 0.0;
  v21 = 1.0;
  _Al__204 = (__m128)Al__204;
  if ( a3 >= 0 )
  {
    v22 = a1 + 0x230;
    v23 = ((unsigned int)a3 >> 0x11) & 0x3FFF;
    v24 = a3 & 0x1FFFF;
    if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(v22 + 0x14);
    }
    else
    {
      v25 = _InterlockedIncrement64((volatile signed __int64 *)v22);
      if ( (v25 & 0x200000) != 0 )
        sub_1403CB300(v22, v25, "CRenderProxy::GetSlotLocalTransform", "m_SlotsLock", 1);
      v19 = *((float *)&v176 + 1);
      v20 = *(float *)&v177;
      v21 = *((float *)&v177 + 1);
      v133 = *(float *)&v176;
    }
    v26 = *(_QWORD *)(a1 + 0xE0);
    if ( v24 >= (unsigned __int64)((*(_QWORD *)(a1 + 0xE8) - v26) >> 3) || (v27 = *(__int64 **)(v26 + 8LL * v24)) == 0 )
    {
      v109 = _Al__204.m128_f32[1];
      _XMM8 = _Al__204.m128_u32[0];
      v107 = _Al__204.m128_f32[2];
      v106 = _Al__204.m128_f32[3];
      __asm { vunpcklps xmm14, xmm8, xmm10 }
      epi32 = _Al__204.m128_i32[2];
      goto LABEL_44;
    }
    v28 = (__int64 *)v27[0xA];
    *(_OWORD *)&v185[1] = v14;
    if ( !v28 || a4 )
    {
      v49 = *v27;
      if ( *v27 )
      {
        v21 = *(float *)(v49 + 0xC);
        v19 = *(float *)(v49 + 4);
        v20 = *(float *)(v49 + 8);
        _Al__204_1 = (__m128)*(unsigned __int64 *)(v49 + 0x10);
        epi32 = *(_DWORD *)(v49 + 0x18);
        v51 = (__m128)*(unsigned int *)(v49 + 0x1C);
        v52 = *(float *)v49;
        v142 = v21;
      }
      else
      {
        _Al__204_1 = (__m128)Al__204;
        v51 = _mm_shuffle_ps(_Al__204_1, _Al__204_1, 0xFF);
        epi32 = _mm_extract_epi32((__m128i)Al__204, 2);
        v142 = 1.0;
        v21 = 1.0;
        v19 = 0.0;
        v20 = 0.0;
        v52 = 0.0;
      }
      __asm { vextractps [rbp+110h+arg_10], xmm0, 1 }
      *(_QWORD *)&_XMM14 = _Al__204_1.m128_u64[0];
      _Al__204.m128_u64[0] = _Al__204_1.m128_u64[0];
      v132 = _Al__204.m128_f32[0];
      v133 = v52;
      v183 = v51;
      v137 = *(float *)&epi32;
    }
    else
    {
      v29 = *v27;
      if ( *v27 )
      {
        v30 = *(float *)(v29 + 0x1C);
        v21 = *(float *)(v29 + 0xC);
        v19 = *(float *)(v29 + 4);
        v31 = *(float *)v29;
        v20 = *(float *)(v29 + 8);
        v18 = *(float *)(v29 + 0x18);
        v184 = *(_QWORD *)(v29 + 0x10);
        _XMM15 = (unsigned int)v184;
        n0x3F800000 = LODWORD(v30);
        LODWORD(v34) = _mm_shuffle_ps((__m128)v184, (__m128)v184, 0x55).m128_u32[0];
      }
      else
      {
        _XMM15 = 0;
        v34 = 0.0;
        v21 = 1.0;
        v19 = 0.0;
        v31 = 0.0;
        v20 = 0.0;
        v30 = 1.0;
        n0x3F800000 = 0x3F800000;
      }
      v137 = v18;
      v195 = v34;
      v172 = v19;
      v173 = v31;
      v174 = v21;
      v134 = v31;
      v175 = v31;
      v156 = v20;
      v165 = v20;
      v157 = v19;
      v166 = v19;
      v158 = v21;
      v167 = v21;
      v159 = v19;
      v168 = v19;
      v160 = v31;
      v169 = v31;
      v161 = v20;
      v170 = v20;
      v162 = v21;
      v171 = v21;
      v163 = v21;
      v148 = v21;
      v164 = v31;
      v150 = v31;
      v143 = v19;
      v152 = v19;
      v145 = v20;
      v154 = v20;
      v35 = v20;
      do
      {
        v36 = *v28;
        if ( *v28 )
        {
          v37 = *(float *)(v36 + 4);
          v38 = *(float *)(v36 + 8);
          v39 = *(float *)v36;
          v40 = *(_DWORD *)(v36 + 0x18);
          v41 = (__m128)*(unsigned int *)(v36 + 0x1C);
          v131 = *(float *)(v36 + 0xC);
          _Al__204.m128_u64[0] = *(_QWORD *)(v36 + 0x10);
          v141 = v37;
          v139 = v38;
          v135 = v39;
          _Al__204.m128_i32[2] = v40;
        }
        else
        {
          v19 = v172;
          v31 = v173;
          v21 = v174;
          v134 = v175;
          v156 = v165;
          v157 = v166;
          v158 = v167;
          v159 = v168;
          v160 = v169;
          v161 = v170;
          v162 = v171;
          v163 = v148;
          v164 = v150;
          v143 = v152;
          v131 = 1.0;
          v37 = 0.0;
          v38 = 0.0;
          v39 = 0.0;
          _Al__204 = (__m128)Al__204;
          v145 = v154;
          v141 = 0.0;
          v139 = 0.0;
          v135 = 0.0;
          v20 = v35;
          v30 = *(float *)&n0x3F800000;
          v41 = _mm_shuffle_ps(_Al__204, _Al__204, 0xFF);
        }
        v28 = (__int64 *)v28[0xA];
        v42 = (float)((float)(v37 * v18) - (float)(v38 * v34)) + (float)(*(float *)&_XMM15 * v131);
        v43 = (float)((float)(v38 * *(float *)&_XMM15) - (float)(v18 * v39)) + (float)(v34 * v131);
        v44 = (float)((float)(v34 * v135) - (float)(v37 * *(float *)&_XMM15)) + (float)(v18 * v131);
        v31 = (float)((float)((float)(v141 * v20) - (float)(v139 * v19)) + (float)(v31 * v131)) + (float)(v21 * v135);
        v19 = (float)((float)((float)(v139 * v134) - (float)(v135 * v156)) + (float)(v131 * v157))
            + (float)(v141 * v158);
        v20 = (float)((float)((float)(v135 * v159) - (float)(v141 * v160)) + (float)(v131 * v161))
            + (float)(v139 * v162);
        v21 = (float)((float)((float)(v131 * v163) - (float)(v135 * v164)) - (float)(v141 * v143))
            - (float)(v139 * v145);
        v45 = _XMM15;
        *(float *)&v45 = (float)((float)((float)(*(float *)&_XMM15 + (float)((float)(v37 * v44) - (float)(v43 * v139)))
                                       + (float)((float)(v37 * v44) - (float)(v43 * v139)))
                               * v41.m128_f32[0])
                       + _Al__204.m128_f32[0];
        _XMM15 = v45;
        v34 = (float)((float)((float)((float)((float)(v42 * v139) - (float)(v44 * v135)) + v195)
                            + (float)((float)(v42 * v139) - (float)(v44 * v135)))
                    * v41.m128_f32[0])
            + _Al__204.m128_f32[1];
        v18 = (float)((float)((float)((float)((float)(v43 * v135) - (float)(v42 * v141)) + v137)
                            + (float)((float)(v43 * v135) - (float)(v42 * v141)))
                    * v41.m128_f32[0])
            + _Al__204.m128_f32[2];
        v137 = v18;
        v195 = v34;
        v172 = v19;
        v173 = v31;
        v174 = v21;
        v134 = v31;
        v175 = v31;
        v156 = v20;
        v46 = v41;
        v30 = v41.m128_f32[0] * v30;
        v46.m128_f32[0] = v30;
        v35 = v20;
        v165 = v20;
        v157 = v19;
        v166 = v19;
        v158 = v21;
        v167 = v21;
        v159 = v19;
        v168 = v19;
        v160 = v31;
        v169 = v31;
        v161 = v20;
        v170 = v20;
        v162 = v21;
        v171 = v21;
        v163 = v21;
        v148 = v21;
        v164 = v31;
        v150 = v31;
        v143 = v19;
        v152 = v19;
        v145 = v20;
        v154 = v20;
        n0x3F800000 = LODWORD(v30);
      }
      while ( v28 );
      v183 = v46;
      __asm { vunpcklps xmm14, xmm15, xmm4 }
      v132 = *(float *)&_XMM15;
      v142 = v21;
      v133 = v31;
      epi32 = LODWORD(v18);
    }
    v53 = v27[0xB];
    v146 = v19;
    v144 = v20;
    if ( !v53
      || (v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x30LL))(v53), (v55 = v54) == 0)
      || !v23
      || (*(int (__fastcall **)(__int64))(*(_QWORD *)v54 + 0x3D8LL))(v54) < v23 )
    {
      v107 = v137;
      v109 = v195;
      *(float *)&_XMM8 = v132;
      v106 = v183.m128_f32[0];
      goto LABEL_44;
    }
    v56 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v55 + 0x3F8LL))(v55, (unsigned int)(v23 - 1));
    v57 = *(float *)(v56 + 0x14);
    v58 = (__m128)*(unsigned int *)(v56 + 0x10);
    v59 = *(float *)(v56 + 0x30);
    v60 = *(float *)(v56 + 0x38);
    v61 = *(float *)(v56 + 0x18);
    v62 = *(float *)(v56 + 0x34);
    v149 = powf(
             fabs(
               (float)((float)((float)((float)((float)((float)(v58.m128_f32[0] * *(float *)(v56 + 0x24)) * v60)
                                             + (float)((float)(v57 * *(float *)(v56 + 0x28)) * v59))
                                     + (float)((float)(v61 * *(float *)(v56 + 0x20)) * v62))
                             - (float)((float)(v61 * *(float *)(v56 + 0x24)) * v59))
                     - (float)((float)(v58.m128_f32[0] * *(float *)(v56 + 0x28)) * v62))
             - (float)((float)(v57 * *(float *)(v56 + 0x20)) * v60)),
             0.33333334);
    v63 = v58;
    v63.m128_f32[0] = (float)((float)(v58.m128_f32[0] * v58.m128_f32[0]) + (float)(v57 * v57))
                    + (float)((float)(v61 * v61) + 1.1754944e-38);
    _XMM2 = _mm_shuffle_ps(v63, v63, 0);
    __asm { vrsqrtps xmm3, xmm2 }
    _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
    v66 = (__m128)*(unsigned __int64 *)(v56 + 0x10);
    _XMM3.m128_f32[0] = (float)(1.5
                              - (float)((float)((float)(_XMM3.m128_f32[0] * v63.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
                      * _XMM3.m128_f32[0];
    v151 = v66.m128_f32[0] * _XMM3.m128_f32[0];
    v155 = _mm_shuffle_ps(v66, v66, 0x55).m128_f32[0] * _XMM3.m128_f32[0];
    v153 = _XMM3.m128_f32[0] * v61;
    v67 = (float)(v61 * v62) - (float)(v57 * v60);
    v68 = (float)(v59 * v57) - (float)(v58.m128_f32[0] * v62);
    v69 = v58;
    v69.m128_f32[0] = (float)(v58.m128_f32[0] * v60) - (float)(v61 * v59);
    v70 = v69;
    v69.m128_f32[0] = (float)((float)(v69.m128_f32[0] * v69.m128_f32[0]) + (float)(v67 * v67))
                    + (float)((float)(v68 * v68) + 1.1754944e-38);
    _XMM0 = _mm_shuffle_ps(v69, v69, 0);
    __asm { vrsqrtps xmm4, xmm0 }
    _XMM4.m128_f32[0] = _mm_shuffle_ps(_XMM4, _XMM4, 0xFF).m128_f32[0];
    v66.m128_f32[0] = (float)(1.5
                            - (float)((float)((float)(_XMM4.m128_f32[0] * v69.m128_f32[0]) * _XMM4.m128_f32[0]) * 0.5))
                    * _XMM4.m128_f32[0];
    v73 = v67 * v66.m128_f32[0];
    v74 = _XMM3.m128_f32[0] * v61;
    v76 = v70;
    v76.m128_f32[0] = v70.m128_f32[0] * v66.m128_f32[0];
    v75 = v76;
    v77 = v68 * v66.m128_f32[0];
    v78 = (float)(v155 * (float)(v68 * v66.m128_f32[0])) - (float)(v153 * v76.m128_f32[0]);
    v79 = (__m128)LODWORD(v151);
    v80 = (float)(v153 * v73) - (float)(v151 * (float)(v68 * v66.m128_f32[0]));
    v79.m128_f32[0] = (float)(v151 * v75.m128_f32[0]) - (float)(v155 * v73);
    v81 = v79;
    v82 = (__m128)LODWORD(v151);
    v82.m128_f32[0] = (float)(v151 + v75.m128_f32[0]) + v81.m128_f32[0];
    v83 = 0.0;
    v84 = 0.0;
    v85 = 0.0;
    v140 = 0.0;
    v136 = 0.0;
    if ( v82.m128_f32[0] <= 0.0 )
    {
      if ( v151 < v75.m128_f32[0] || v151 < v81.m128_f32[0] )
      {
        if ( v75.m128_f32[0] < v151 || v75.m128_f32[0] < v81.m128_f32[0] )
        {
          if ( v81.m128_f32[0] < v151 || v81.m128_f32[0] < v75.m128_f32[0] )
            goto LABEL_41;
          v93 = v81;
          v93.m128_f32[0] = (float)((float)(v81.m128_f32[0] - v151) - v75.m128_f32[0]) + 1.0;
          v94 = _mm_sqrt_ps(_mm_shuffle_ps(v93, v93, 0));
          v94.m128_f32[0] = _mm_shuffle_ps(v94, v94, 0xFF).m128_f32[0];
          v91 = 0.5 / v94.m128_f32[0];
          v147 = (float)(v73 - v155) * (float)(0.5 / v94.m128_f32[0]);
          v84 = (float)(v80 + v77) * (float)(0.5 / v94.m128_f32[0]);
          v92 = v74 + v78;
          v85 = v94.m128_f32[0] * 0.5;
        }
        else
        {
          v89 = v75;
          v89.m128_f32[0] = (float)((float)(v75.m128_f32[0] - v81.m128_f32[0]) - v151) + 1.0;
          v90 = _mm_sqrt_ps(_mm_shuffle_ps(v89, v89, 0));
          v90.m128_f32[0] = _mm_shuffle_ps(v90, v90, 0xFF).m128_f32[0];
          v91 = 0.5 / v90.m128_f32[0];
          v147 = (float)(v74 - v78) * (float)(0.5 / v90.m128_f32[0]);
          v85 = (float)(v80 + v77) * (float)(0.5 / v90.m128_f32[0]);
          v92 = v155 + v73;
          v84 = v90.m128_f32[0] * 0.5;
        }
        v83 = v92 * v91;
      }
      else
      {
        v87 = (__m128)LODWORD(v151);
        v87.m128_f32[0] = (float)((float)(v151 - v75.m128_f32[0]) - v81.m128_f32[0]) + 1.0;
        v88 = _mm_sqrt_ps(_mm_shuffle_ps(v87, v87, 0));
        v88.m128_f32[0] = _mm_shuffle_ps(v88, v88, 0xFF).m128_f32[0];
        v147 = (float)(v80 - v77) * (float)(0.5 / v88.m128_f32[0]);
        v85 = (float)(v74 + v78) * (float)(0.5 / v88.m128_f32[0]);
        v83 = v88.m128_f32[0] * 0.5;
        v84 = (float)(v155 + v73) * (float)(0.5 / v88.m128_f32[0]);
      }
    }
    else
    {
      v82.m128_f32[0] = v82.m128_f32[0] + 1.0;
      v86 = _mm_sqrt_ps(_mm_shuffle_ps(v82, v82, 0));
      v86.m128_f32[0] = _mm_shuffle_ps(v86, v86, 0xFF).m128_f32[0];
      v147 = v86.m128_f32[0] * 0.5;
      v83 = (float)(v80 - v77) * (float)(0.5 / v86.m128_f32[0]);
      v85 = (float)(v73 - v155) * (float)(0.5 / v86.m128_f32[0]);
      v84 = (float)(v74 - v78) * (float)(0.5 / v86.m128_f32[0]);
    }
    v136 = v85;
    v140 = v84;
LABEL_41:
    v95 = v133;
    v96 = *(float *)(v56 + 0x3C);
    v97 = *(float *)(v56 + 0x2C);
    v98 = *(float *)(v56 + 0x1C);
    v99 = (float)((float)(v146 * v96) - (float)(v144 * v97)) + (float)(v142 * v98);
    v100 = (float)((float)(v144 * v98) - (float)(v133 * v96)) + (float)(v142 * v97);
    v101 = (float)((float)(v133 * v97) - (float)(v146 * v98)) + (float)(v142 * v96);
    v102 = v133 * v84;
    v196 = (float)((float)((float)((float)((float)(v144 * v99) - (float)(v133 * v101)) + v97)
                         + (float)((float)(v144 * v99) - (float)(v133 * v101)))
                 * v183.m128_f32[0])
         + v195;
    v138 = (float)((float)((float)((float)((float)(v133 * v100) - (float)(v146 * v99)) + *(float *)(v56 + 0x3C))
                         + (float)((float)(v133 * v100) - (float)(v146 * v99)))
                 * v183.m128_f32[0])
         + v137;
    v103 = v133 * v85;
    v133 = (float)((float)((float)(v146 * v136) - (float)(v144 * v140)) + (float)(v142 * v83)) + (float)(v147 * v133);
    v104 = v102 - (float)(v146 * v83);
    v105 = v95 * v83;
    v19 = (float)((float)((float)(v144 * v83) - v103) + (float)(v142 * v140)) + (float)(v146 * v147);
    v20 = (float)(v104 + (float)(v142 * v136)) + (float)(v144 * v147);
    v106 = v183.m128_f32[0] * v149;
    v21 = (float)((float)((float)(v142 * v147) - v105) - (float)(v146 * v84)) - (float)(v144 * v85);
    v107 = v138;
    _XMM8 = COERCE_UNSIGNED_INT(
              (float)((float)((float)((float)((float)(v146 * v101) - (float)(v144 * v100)) + *(float *)(v56 + 0x1C))
                            + (float)((float)(v146 * v101) - (float)(v144 * v100)))
                    * v183.m128_f32[0])
            + v132);
    v109 = v196;
    __asm { vunpcklps xmm14, xmm8, xmm10 }
    epi32 = LODWORD(v138);
LABEL_44:
    sub_1402D2790(v22);
    v18 = v133;
    goto LABEL_46;
  }
  v109 = _Al__204.m128_f32[1];
  _XMM8 = _Al__204.m128_u32[0];
  v107 = _Al__204.m128_f32[2];
  v106 = _Al__204.m128_f32[3];
  __asm { vunpcklps xmm14, xmm8, xmm10 }
  epi32 = _Al__204.m128_i32[2];
LABEL_46:
  if ( n2 )
  {
    p_n0xB_1 = p_n0xB;
    if ( n2 == 2 )
    {
      *(float *)(p_n0xB + 0xC) = v21;
      *(float *)p_n0xB = v18;
      *(float *)(p_n0xB + 4) = v19;
      *(float *)(p_n0xB + 8) = v20;
      *(double *)(p_n0xB + 0x10) = *(double *)&_XMM14;
      *(_DWORD *)(p_n0xB + 0x18) = epi32;
      *(float *)(p_n0xB + 0x1C) = v106;
    }
    else
    {
      *(_DWORD *)(p_n0xB + 0xC) = 0x3F800000;
      *(_QWORD *)p_n0xB = 0;
      *(_DWORD *)(p_n0xB + 8) = 0;
      *(_QWORD *)(p_n0xB + 0x10) = 0;
      *(_DWORD *)(p_n0xB + 0x18) = 0;
      *(_DWORD *)(p_n0xB + 0x1C) = 0x3F800000;
    }
  }
  else
  {
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v111 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v111 = 0;
    v112 = *(__int64 **)(v111 + 0x2B0);
    v113 = *v112;
    v176 = v18;
    v177 = v19;
    *(double *)_Al__204.m128_u64 = v20;
    *(double *)&_Al__204.m128_u64[1] = v21;
    v179 = *(float *)&_XMM8;
    v180 = v109;
    v181 = v107;
    v182 = v106;
    v114 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64 *, __m128 *, double *))(v113 + 0x140))(
                                 v112,
                                 &v183,
                                 &v176);
    _XMM0 = *v114;
    __asm { vcvtpd2ps xmm0, xmm0 }
    *(float *)p_n0xB = *(float *)&_XMM0;
    _XMM1 = v114[1];
    __asm { vcvtpd2ps xmm1, xmm1 }
    *(float *)(p_n0xB + 4) = *(float *)&_XMM1;
    _XMM0 = v114[2];
    __asm { vcvtpd2ps xmm0, xmm0 }
    *(float *)(p_n0xB + 8) = *(float *)&_XMM0;
    _XMM1 = v114[3];
    __asm { vcvtpd2ps xmm1, xmm1 }
    *(float *)(p_n0xB + 0xC) = *(float *)&_XMM1;
    _XMM0 = v114[4];
    __asm { vcvtpd2ps xmm0, xmm0 }
    *(float *)(p_n0xB + 0x10) = *(float *)&_XMM0;
    _XMM1 = v114[5];
    __asm { vcvtpd2ps xmm1, xmm1 }
    *(float *)(p_n0xB + 0x14) = *(float *)&_XMM1;
    _XMM0 = v114[6];
    __asm { vcvtpd2ps xmm0, xmm0 }
    *(float *)(p_n0xB + 0x18) = *(float *)&_XMM0;
    _XMM1 = v114[7];
    __asm { vcvtpd2ps xmm1, xmm1 }
    *(float *)(p_n0xB + 0x1C) = *(float *)&_XMM1;
    return p_n0xB;
  }
  return p_n0xB_1;
}

// --- End Function: sub_146AC04D0 (0x146AC04D0) ---

// --- Function: sub_146AD0C50 (0x146AD0C50) ---
__int64 __fastcall sub_146AD0C50(__int64 a1)
{
  __int64 v2; // r15
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // r14
  __int64 v9; // rsi
  __int64 *v10; // rbx
  __int64 v11; // rax
  __int64 *v12; // rax
  __int64 v13; // rcx
  __int64 v17; // rbx
  int v18; // eax
  __int16 v19; // ax
  __int64 v20; // rcx
  __int64 v21; // rax
  float v22; // xmm1_4
  float v23; // xmm0_4
  double v24; // xmm0_8
  double v25; // xmm1_8
  double v26; // xmm2_8
  double v27; // xmm3_8
  double v28; // xmm4_8
  double v29; // xmm5_8
  int v30; // eax
  float v31; // xmm0_4
  int v32; // eax
  __int64 v33; // rcx
  __int64 v34; // r9
  __int64 v35; // rbx
  void (__fastcall *v36)(__int64, _QWORD, __int64, _QWORD *); // rsi
  __int64 v37; // rcx
  unsigned int v38; // eax
  _QWORD v40[2]; // [rsp+38h] [rbp-D0h] BYREF
  __int128 v41; // [rsp+48h] [rbp-C0h]
  double v42; // [rsp+58h] [rbp-B0h]
  double v43; // [rsp+60h] [rbp-A8h]
  __int128 v44; // [rsp+68h] [rbp-A0h]
  __int128 v45; // [rsp+78h] [rbp-90h]
  __int128 v46; // [rsp+88h] [rbp-80h]
  double v47; // [rsp+98h] [rbp-70h]
  __int128 v48; // [rsp+A0h] [rbp-68h]
  double v49; // [rsp+B0h] [rbp-58h]
  float v50; // [rsp+B8h] [rbp-50h]
  __int64 v51; // [rsp+BCh] [rbp-4Ch]
  __int64 v52; // [rsp+C8h] [rbp-40h]
  int v53; // [rsp+D0h] [rbp-38h]
  __int64 v54; // [rsp+D8h] [rbp-30h]
  int v55; // [rsp+E0h] [rbp-28h] BYREF
  __int16 v56; // [rsp+E4h] [rbp-24h]
  char v57; // [rsp+E6h] [rbp-22h]
  __int64 v58; // [rsp+E8h] [rbp-20h]
  _BYTE v59[64]; // [rsp+110h] [rbp+8h] BYREF

  v2 = 0;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v3 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v3 = 0;
  v4 = *(_QWORD *)(a1 + 0x160);
  v5 = *(_QWORD *)(v3 + 0x138);
  if ( v4 != v5 )
  {
    v4 = *(_QWORD *)(v3 + 0x138);
    if ( v5 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
    v6 = *(_QWORD *)(a1 + 0x160);
    if ( v6 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x10LL))(v6);
    *(_QWORD *)(a1 + 0x160) = v4;
  }
  if ( v4 )
  {
    v7 = *(_QWORD *)(a1 + 0xE0);
    v8 = 0;
    if ( (*(_QWORD *)(a1 + 0xE8) - v7) >> 3 )
    {
      while ( 1 )
      {
        v9 = *(_QWORD *)(v7 + 8 * v8);
        if ( v9 )
          break;
LABEL_22:
        v7 = *(_QWORD *)(a1 + 0xE0);
        if ( ++v8 >= (unsigned __int64)((*(_QWORD *)(a1 + 0xE8) - v7) >> 3) )
          goto LABEL_23;
      }
      v10 = *(__int64 **)(a1 + 0x160);
      if ( v10 )
      {
        v11 = *v10;
      }
      else
      {
        v12 = *(__int64 **)(v9 + 0xC0);
        if ( !v12 )
        {
LABEL_18:
          v13 = *(_QWORD *)(v9 + 0x58);
          if ( v13 )
            (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v13 + 0x20LL))(v13, v10);
          if ( v10 )
            (*(void (__fastcall **)(__int64 *))(*v10 + 0x10))(v10);
          goto LABEL_22;
        }
        v10 = *(__int64 **)(v9 + 0xC0);
        v11 = *v12;
      }
      (*(void (__fastcall **)(__int64 *))(v11 + 8))(v10);
      goto LABEL_18;
    }
  }
LABEL_23:
  sub_146B0AA80(a1);
  sub_146B09E30(a1);
  sub_146A88AF0(a1);
  _XMM1 = 0;
  __asm
  {
    vmovupd [rsp+170h+var_138+8], xmm1
    vmovupd xmm1, cs:xmmword_1481AA7F0
    vmovupd xmmword ptr [rsp+170h+var_108+8], xmm1
  }
  v43 = 1.0;
  _XMM0 = 0;
  v51 = 0;
  v17 = a1 + 0x78;
  v52 = 0;
  if ( !a1 )
    v17 = 0;
  v53 = 0;
  v40[1] = v17;
  LOWORD(v40[0]) = 0xD3F3;
  v48 = 0;
  v42 = 0.0;
  v50 = 0.0;
  __asm { vmovupd [rsp+170h+var_118+8], xmm0 }
  v46 = 0;
  v47 = 0.0;
  v49 = 0.0;
  v54 = 0;
  sub_140360130(&v55);
  v57 = 0;
  v56 = 0xFFFE;
  v18 = *(_DWORD *)(v17 + 8);
  v58 = 0;
  if ( (v18 & 0x800) != 0 )
  {
    v19 = 0xFFFD;
  }
  else
  {
    if ( (v18 & 0x4000) == 0 )
      goto LABEL_30;
    v19 = 0xFFFC;
  }
  v56 = v19;
LABEL_30:
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v20 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v20 = 0;
  v21 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v20 + 0x1E8LL))(v20, v59, 2);
  v41 = *(_OWORD *)v21;
  v42 = *(double *)(v21 + 0x10);
  v43 = *(double *)(v21 + 0x18);
  v44 = *(_OWORD *)(v21 + 0x20);
  *(_QWORD *)&v45 = *(_QWORD *)(v21 + 0x30);
  v22 = *(float *)(a1 + 0x124);
  *((_QWORD *)&v45 + 1) = *(_QWORD *)(v21 + 0x38);
  v23 = *(float *)(a1 + 0x118);
  if ( v23 <= v22 )
  {
    v26 = *(float *)(a1 + 0x11C);
    v27 = *(float *)(a1 + 0x120);
    v28 = *(float *)(a1 + 0x128);
    v29 = *(float *)(a1 + 0x12C);
    v24 = v23;
    v25 = v22;
  }
  else
  {
    v24 = 1.0e150;
    v25 = -1.0e150;
    v26 = 1.0e150;
    v27 = 1.0e150;
    v28 = -1.0e150;
    v29 = -1.0e150;
  }
  v30 = *(unsigned __int8 *)(a1 + 0x8D);
  *(double *)&v46 = v24;
  *((double *)&v46 + 1) = v26;
  v47 = v27;
  *(double *)&v48 = v25;
  *((double *)&v48 + 1) = v28;
  v49 = v29;
  if ( (_BYTE)v30 == 0xFF )
    v31 = 10.0;
  else
    v31 = (float)v30 * 0.0099999998;
  v32 = *(_DWORD *)(a1 + 0x80);
  v58 = a1 + 0xA0;
  v50 = v31;
  LODWORD(v51) = 0x13;
  HIDWORD(v51) = v32;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v33 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v33 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v33 + 0x50LL))(v33) )
  {
    LOBYTE(v34) = 1;
    (*(void (__fastcall **)(__int64, __int64, __int64, __int64, char))(*(_QWORD *)qword_149B4FBE8 + 0x468LL))(
      qword_149B4FBE8,
      0xD3F3,
      a1 + 0xA0,
      v34,
      1);
  }
  v35 = qword_149B4FBE8;
  v36 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)qword_149B4FBE8 + 0x350LL);
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v37 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v37 = 0;
  v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x658LL))(v37);
  v36(v35, v38, a1 + 0x88, v40);
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v2 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  if ( *(_BYTE *)(v2 + 0xD) >= 4u )
  {
    *(_DWORD *)(a1 + 0x194) |= 0x100u;
    sub_146B0A630(a1);
  }
  sub_146AD1330(a1);
  return sub_1403729F0(&v55);
}

// --- End Function: sub_146AD0C50 (0x146AD0C50) ---

// --- Function: sub_146AD1330 (0x146AD1330) ---
char __fastcall sub_146AD1330(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int128 v4; // xmm9
  __int128 v5; // xmm10
  __int64 v7; // rax
  __int64 v8; // r12
  __int64 v9; // rdx
  unsigned int v10; // r14d
  signed __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 i; // rsi
  __int64 v14; // rdi
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 n0x19; // rax
  __int128 v21; // kr00_16
  float v25; // xmm8_4
  int v26; // r14d
  int v27; // r15d
  int v28; // r13d
  float *v29; // rax
  __int64 v30; // rsi
  __int64 v31; // rax
  int v32; // r8d
  __int64 *v34; // [rsp+40h] [rbp-C0h] BYREF
  float v35; // [rsp+48h] [rbp-B8h] BYREF
  float v36; // [rsp+4Ch] [rbp-B4h] BYREF
  float v37; // [rsp+50h] [rbp-B0h] BYREF
  unsigned int v38; // [rsp+54h] [rbp-ACh] BYREF
  int v39; // [rsp+58h] [rbp-A8h] BYREF
  float v40; // [rsp+5Ch] [rbp-A4h] BYREF
  float v41; // [rsp+60h] [rbp-A0h] BYREF
  float v42; // [rsp+64h] [rbp-9Ch] BYREF
  float v43; // [rsp+68h] [rbp-98h] BYREF
  float v44; // [rsp+6Ch] [rbp-94h]
  float v45; // [rsp+70h] [rbp-90h]
  float v46; // [rsp+78h] [rbp-88h] BYREF
  float v47; // [rsp+7Ch] [rbp-84h]
  float v48; // [rsp+80h] [rbp-80h]
  float v49; // [rsp+88h] [rbp-78h] BYREF
  float v50; // [rsp+8Ch] [rbp-74h]
  float v51; // [rsp+90h] [rbp-70h]
  char v52[4]; // [rsp+98h] [rbp-68h] BYREF
  _BYTE v53[4]; // [rsp+9Ch] [rbp-64h] BYREF
  _BYTE v54[8]; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int64 v55; // [rsp+A8h] [rbp-58h] BYREF
  float v56[4]; // [rsp+B0h] [rbp-50h] BYREF
  float v57[4]; // [rsp+C0h] [rbp-40h] BYREF
  unsigned int v58[4]; // [rsp+D0h] [rbp-30h] BYREF
  _BYTE v59[16]; // [rsp+E0h] [rbp-20h] BYREF
  __int128 v60; // [rsp+F0h] [rbp-10h]
  __int128 v61; // [rsp+100h] [rbp+0h]
  __int128 v62; // [rsp+110h] [rbp+10h]
  __int128 v63; // [rsp+120h] [rbp+20h]
  __int128 v64; // [rsp+130h] [rbp+30h]
  char v65; // [rsp+190h] [rbp+90h] BYREF
  unsigned __int8 v66; // [rsp+198h] [rbp+98h] BYREF
  unsigned __int8 v67; // [rsp+1A0h] [rbp+A0h] BYREF
  float v68; // [rsp+1A8h] [rbp+A8h] BYREF

  v55 = *(_QWORD *)(a1 + 8);
  LOBYTE(v7) = sub_14030EC00(&v55);
  if ( (_BYTE)v7 )
  {
    v7 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v55 & 0xFFFFFFFFFFFFLL) + 0x380LL))(v55 & 0xFFFFFFFFFFFFLL);
    v8 = v7;
    if ( v7 )
    {
      LOBYTE(v7) = (unsigned __int8)sub_1403AC7D0(v7, &v34, *(_WORD *)(a1 + 0x10));
      if ( v34 )
      {
        v64 = v1;
        v63 = v2;
        v62 = v3;
        v36 = 0.0;
        v9 = *v34;
        v61 = v4;
        v60 = v5;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, float *))(v9 + 0xE0))(v34, "Wear", &v36) )
          sub_1405051A0(a1 + 0x134, (char *)(a1 + 0x134), v36);
        v37 = 0.0;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xE0))(v34, "Dirt", &v37) )
          sub_140505130(a1 + 0x134);
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xF8))(
               v34,
               "Interference",
               &v68) )
        {
          sub_140505190(a1 + 0x134, (_BYTE *)(a1 + 0x136), SLOBYTE(v68));
        }
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, int *, char *))(*v34 + 0xF8))(v34, &dword_1481CDBA8, v52) )
          sub_140505190(a1 + 0x134, (_BYTE *)(a1 + 0x135), v52[0]);
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, _BYTE *))(*v34 + 0xF8))(v34, "LodRatio", v53) )
          sub_146AF9A10(a1, v53[0]);
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, _BYTE *))(*v34 + 0xF8))(
               v34,
               "ViewDistRatio",
               v54) )
        {
          sub_146AFDC90(a1, v54[0]);
        }
        v38 = 0xFFFFFFFF;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, unsigned int *))(*v34 + 0x100))(
               v34,
               "MinSpec",
               &v38) )
        {
          v10 = v38;
          *(_DWORD *)(a1 + 0x80) = (v38 << 0x18) ^ (*(_DWORD *)(a1 + 0x80) ^ (v38 << 0x18)) & 0xF8FFFFFF;
          if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
          {
            ++*(_DWORD *)(a1 + 0x244);
          }
          else
          {
            v11 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
            if ( (v11 & 0x200000) != 0 )
              sub_1403CB300(a1 + 0x230, v11, "CRenderProxy::SetMinSpec", "m_SlotsLock", 1);
          }
          v12 = *(_QWORD *)(a1 + 0xE0);
          for ( i = 0; i < (*(_QWORD *)(a1 + 0xE8) - v12) >> 3; ++i )
          {
            v14 = *(_QWORD *)(v12 + 8 * i);
            if ( v14 )
            {
              v15 = *(_QWORD *)(v14 + 0x90);
              if ( v15 )
                (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v15 + 0x180LL))(v15, v10);
              v16 = *(_QWORD *)(v14 + 0x88);
              if ( v16 )
                (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 0x180LL))(v16, v10);
            }
            v12 = *(_QWORD *)(a1 + 0xE0);
          }
          sub_1402D2790(a1 + 0x230);
        }
        v65 = 0;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, char *))(*v34 + 0x90))(
               v34,
               "LinkedGlowInProbes",
               &v65) )
        {
          *(_BYTE *)(a1 + 0x19D) = v65;
        }
        v66 = 0;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, unsigned __int8 *))(*v34 + 0x90))(
               v34,
               "Holographic",
               &v66) )
        {
          sub_146AF7AB0(a1, v66);
        }
        v39 = 0;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, int *))(*v34 + 0x100))(
               v34,
               "DissolveOpacity",
               &v39) )
        {
          n0x19 = a1 + 0x91;
          if ( !a1 )
            n0x19 = 0x19;
          *(_BYTE *)n0x19 = 0xFF - v39;
        }
        v43 = 0.0;
        v44 = 0.0;
        v45 = 0.0;
        (*(void (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xB8))(v34, "ObjectTintColor", &v43);
        v40 = 0.0;
        (*(void (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xE0))(v34, "ObjectTintStrength", &v40);
        LOBYTE(v68) = (int)(float)(255.0 * v43);
        BYTE1(v68) = (int)(float)(255.0 * v44);
        BYTE2(v68) = (int)(float)(255.0 * v45);
        HIBYTE(v68) = (int)(float)(255.0 * v40);
        sub_14051EF10((_BYTE *)(a1 + 0x148), &v68);
        v67 = 1;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, unsigned __int8 *))(*v34 + 0x90))(
               v34,
               "AllowBakedRendering",
               &v67) )
        {
          sub_146AF7910(a1, v67);
        }
        v41 = 1.0;
        if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xE0))(v34, "Alpha", &v41) )
        {
          _XMM0 = LODWORD(v41);
          if ( v41 >= 0.0 )
            __asm { vminss  xmm1, xmm0, xmm10 }
          else
            _XMM1 = 0;
          v21 = _XMM1;
          *(float *)&v21 = *(float *)&_XMM1 * 255.0;
          _XMM3 = v21;
          *(float *)&v21 = (float)(*(float *)&_XMM1 * 255.0) + 0.5;
          _XMM2 = v21;
          __asm
          {
            vcmpltss xmm0, xmm3, xmm6
            vblendvps xmm1, xmm2, xmm1, xmm0
          }
          *(_BYTE *)(a1 + 0x19C) = (int)*(float *)&_XMM1;
        }
        v42 = 0.0;
        v46 = 0.0;
        v47 = 0.0;
        v48 = 0.0;
        (*(void (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xB8))(v34, "GlowColor", &v46);
        (*(void (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xE0))(v34, "GlowAmount", &v42);
        v25 = v42;
        v26 = (int)(float)(255.0 * v46);
        v27 = (int)(float)(255.0 * v47);
        v28 = (int)(float)(255.0 * v48);
        v29 = (float *)sub_1405178F0(a1 + 0x1EC);
        if ( *v29 == 0.0 && v29[1] == 0.0 && v29[2] == 0.0 )
        {
          v30 = a1 + 0x78;
        }
        else
        {
          v30 = a1 + 0x78;
          v31 = sub_14050FBD0(a1 + 0x1EC, (__int64)v59);
          sub_146A7D0E0(a1 + 0x78, v31, 0);
          v56[0] = 0.0;
          v56[1] = 0.0;
          v56[2] = 0.0;
          sub_14051D540(a1 + 0x1EC, 5, (__int64)v56);
        }
        if ( v25 > 0.0 )
        {
          v57[0] = (float)((float)(unsigned __int8)v26 * 0.0039215689) * v25;
          v57[2] = v25 * (float)((float)(unsigned __int8)v28 * 0.0039215689);
          *(float *)(a1 + 0x1E8) = v25;
          v57[1] = (float)((float)(unsigned __int8)v27 * 0.0039215689) * v25;
          *(_BYTE *)(a1 + 0x1E4) = v26;
          *(_BYTE *)(a1 + 0x1E5) = v27;
          *(_BYTE *)(a1 + 0x1E6) = v28;
          *(_BYTE *)(a1 + 0x1E7) = 0xFF;
          sub_14051D540(a1 + 0x1EC, 5, (__int64)v57);
          sub_146A7D0E0(v30, a1 + 0x1EC, 0);
        }
        v35 = 0.0;
        (*(void (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xE0))(v34, "SilhouetteAlpha", &v35);
        if ( v35 > 0.0 )
        {
          v49 = 0.0;
          v50 = 0.0;
          v51 = 0.0;
          v68 = 0.0;
          (*(void (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xB8))(v34, "SilhouetteColor", &v49);
          (*(void (__fastcall **)(__int64 *, const char *, float *))(*v34 + 0xE0))(v34, "SilhouetteOccludedAlpha", &v68);
          *(float *)v58 = (float)(unsigned __int8)(int)(float)(255.0 * v49) * 0.0039215689;
          *(float *)&v58[1] = (float)(unsigned __int8)(int)(float)(255.0 * v50) * 0.0039215689;
          *(float *)&v58[2] = (float)(unsigned __int8)(int)(float)(255.0 * v51) * 0.0039215689;
          *(float *)&v58[3] = (float)(unsigned __int8)(int)(float)(255.0 * v35) * 0.0039215689;
          sub_146AF8D00(a1, (unsigned int)v58, v32, 0, 0x3F800000, 1, 1);
        }
        LOBYTE(v7) = sub_146AD1B50(a1, v8, &v34);
        if ( v34 )
          LOBYTE(v7) = (*(__int64 (__fastcall **)(__int64 *))(*v34 + 0x28))(v34);
      }
    }
  }
  return v7;
}

// --- End Function: sub_146AD1330 (0x146AD1330) ---

// --- Function: sub_146AD1B50 (0x146AD1B50) ---
unsigned __int64 __fastcall sub_146AD1B50(__int64 a1, __int64 a2, _QWORD *a3)
{
  unsigned __int64 v6; // rbx
  __int64 (__fastcall *v7)(unsigned __int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v9; // rbx
  __int64 v10; // rax
  __int16 n4_1; // dx
  __int64 v12; // rbx
  _QWORD *v13; // rax
  unsigned __int64 v14; // rdi
  __int64 (__fastcall *v15)(unsigned __int64, _BYTE *, __int16 *); // rsi
  __int16 n0xFFFF_311; // ax
  __int64 v17; // rdi
  __int64 v18; // rax
  __int16 n4; // dx
  __int64 v20; // rax
  __int64 v21; // rdi
  __int64 (__fastcall *v22)(__int64, __int64); // rbx
  __int64 v23; // rax
  _BYTE *v24; // rax
  signed __int64 v25; // rdx
  _BYTE *v26; // rax
  __int16 n0xFFFF_1; // [rsp+30h] [rbp-79h] BYREF
  __int16 n0xFFFF_311_1; // [rsp+32h] [rbp-77h] BYREF
  unsigned __int64 v30; // [rsp+38h] [rbp-71h] BYREF
  _BYTE v31[2]; // [rsp+40h] [rbp-69h] BYREF
  _BYTE v32[6]; // [rsp+42h] [rbp-67h] BYREF
  __int64 v33; // [rsp+48h] [rbp-61h] BYREF
  __int64 v34; // [rsp+50h] [rbp-59h] BYREF
  __int64 v35; // [rsp+58h] [rbp-51h] BYREF
  _BYTE v36[8]; // [rsp+60h] [rbp-49h] BYREF
  _BYTE v37[8]; // [rsp+68h] [rbp-41h] BYREF
  _BYTE v38[8]; // [rsp+70h] [rbp-39h] BYREF
  _BYTE v39[8]; // [rsp+78h] [rbp-31h] BYREF
  __int128 v40; // [rsp+80h] [rbp-29h] BYREF
  double v41; // [rsp+90h] [rbp-19h]
  __int128 v42; // [rsp+98h] [rbp-11h] BYREF
  double v43; // [rsp+A8h] [rbp-1h]
  _BYTE v44[16]; // [rsp+B0h] [rbp+7h] BYREF

  sub_140361E00(&v40);
  v30 = *(_QWORD *)(a2 + 0xC8);
  if ( sub_14030EC00(&v30) )
  {
    v6 = v30 & 0xFFFFFFFFFFFFLL;
    v7 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v30 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_33;
    if ( n0xFFFF_33 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                    + 0x10LL))(
                            pEngineComponentScheduler,
                            v31,
                            "IEntityComponentObjectContainer");
      n0xFFFF_33 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    v9 = *(_QWORD *)v7(v6, v36, &n0xFFFF_1);
    v34 = v9;
    if ( v9 )
    {
      v10 = sub_1403B4B50(v9 & 0xFFFFFFFFFFFFLL);
      n4_1 = *(_WORD *)(v10 + 4);
      if ( n4_1 != 4
        && *(_WORD *)(v10 + 2) == (HIWORD(v9) & 0xFFF)
        && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v34)) )
      {
        v12 = v9 & 0xFFFFFFFFFFFFLL;
        sub_1404B6410(v12, &v33);
        if ( v33 )
        {
          v13 = (_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)(v30 & 0xFFFFFFFFFFFFLL)
                                                                               + 8LL))(
                            v30 & 0xFFFFFFFFFFFFLL,
                            v37);
          if ( *(_QWORD *)(v33 + 0x10) != *v13 )
            v30 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)pEntitySystem + 0x120LL))(
                               pEntitySystem,
                               v38);
          if ( sub_14030EC00(&v30) )
          {
            v14 = v30 & 0xFFFFFFFFFFFFLL;
            v15 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v30 & 0xFFFFFFFFFFFFLL)
                                                                                 + 0x340LL);
            n0xFFFF_311 = ::n0xFFFF_311;
            if ( ::n0xFFFF_311 == (__int16)0xFFFF )
            {
              n0xFFFF_311 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                                + 0x10LL))(
                                        pEngineComponentScheduler,
                                        v32,
                                        "IEntityComponentObjectContainerModifier");
              ::n0xFFFF_311 = n0xFFFF_311;
            }
            n0xFFFF_311_1 = n0xFFFF_311;
            v17 = *(_QWORD *)v15(v14, v39, &n0xFFFF_311_1);
            v35 = v17;
            if ( v17 )
            {
              v18 = sub_1403B4B50(v17 & 0xFFFFFFFFFFFFLL);
              n4 = *(_WORD *)(v18 + 4);
              if ( n4 != 4
                && *(_WORD *)(v18 + 2) == (HIWORD(v17) & 0xFFF)
                && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v35)) )
              {
                v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v17 & 0xFFFFFFFFFFFFLL) + 0x570LL))(v17 & 0xFFFFFFFFFFFFLL);
                v40 = *(_OWORD *)v20;
                v41 = *(double *)(v20 + 0x10);
              }
            }
          }
        }
        sub_1404EAD00(&v33);
        (*(void (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v12 + 0x610LL))(v12, &v42);
        if ( v43 != 0.0 )
        {
          v40 = v42;
          v41 = v43;
        }
      }
    }
  }
  if ( v41 == 0.0 )
  {
    assignCStringToStringStructure((void **)(a1 + 0x170), &p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  else
  {
    v21 = qword_149B4FC58;
    v22 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC58 + 0x48LL);
    v23 = sub_1403AF7A0((__int64)&v40, (__int64)v44);
    v24 = (_BYTE *)v22(v21, v23);
    assignCStringToStringStructure((void **)(a1 + 0x170), v24);
    sub_1403CE5A0((char **)(a1 + 0x170));
  }
  if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x244);
  }
  else
  {
    v25 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
    if ( (v25 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x230, v25, "CRenderProxy::InitializeTintPalette", "m_SlotsLock", 1);
  }
  assignCStringToStringStructure((void **)(a1 + 0x178), &p_p_p_p_p_p_p_p_p_p_p_Source);
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a3 + 0x118LL))(*a3, "Palette") )
  {
    v26 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a3 + 0x110LL))(*a3, "Palette");
    assignCStringToStringStructure((void **)(a1 + 0x178), v26);
  }
  sub_146B0E070((_QWORD *)a1);
  return sub_1402D2790(a1 + 0x230);
}

// --- End Function: sub_146AD1B50 (0x146AD1B50) ---

// --- Function: sub_146AEB290 (0x146AEB290) ---
void __fastcall sub_146AEB290(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rbx
  int v4; // edx
  unsigned int v5; // r8d
  unsigned int v6; // eax
  int v7; // r8d
  unsigned int v8; // eax
  int v9; // eax
  __int64 v10; // rdx

  v2 = *(_DWORD **)(a2 + 0x90);
  if ( v2 || (v2 = *(_DWORD **)(a2 + 0x88)) != 0 )
  {
    v4 = *(_DWORD *)(a1 + 0x194);
    v5 = v2[2] | 0x10000000;
    if ( (v4 & 0x40000) == 0 )
      v5 = v2[2] & 0xEFFFFFFF;
    v6 = v5;
    v7 = v5 | 0x200000;
    v8 = v6 & 0xFFDFFFFF;
    if ( (v4 & 0x100000) == 0 )
      v7 = v8;
    v9 = *(_DWORD *)(a1 + 0x80);
    v10 = v7 & 0xFFE7CFFF;
    if ( (v9 & 0x183000) != 0 )
      v10 = v9 ^ (v9 ^ v7) & 0xFFE7CFFF;
    (*(void (__fastcall **)(_DWORD *, __int64))(*(_QWORD *)v2 + 0x1A0LL))(v2, v10);
    (*(void (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)v2 + 0x198LL))(v2, *(unsigned __int8 *)(a1 + 0x8D));
    (*(void (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)v2 + 0xD8LL))(v2, *(unsigned __int8 *)(a1 + 0x8E));
    (*(void (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)v2 + 0xE0LL))(v2, *(unsigned __int8 *)(a1 + 0x8F));
  }
}

// --- End Function: sub_146AEB290 (0x146AEB290) ---

// --- Function: sub_146AF7910 (0x146AF7910) ---
unsigned __int64 __fastcall sub_146AF7910(__int64 a1, char a2)
{
  __int64 v2; // rbx
  unsigned int v4; // r8d
  int v6; // edi
  unsigned __int32 v7; // eax
  unsigned __int64 v8; // rdi
  unsigned int *v9; // rcx
  __int64 v10; // rdx
  int v11; // eax
  unsigned __int32 v12; // eax
  signed __int64 v13; // rbp
  __int64 v14; // rcx
  __int64 v15; // rdx

  v2 = a1 + 0x218;
  v4 = *(_DWORD *)(a1 + 0x194) | 0x100000;
  if ( !a2 )
    v4 = *(_DWORD *)(a1 + 0x194) & 0xFFEFFFFF;
  *(_DWORD *)(a1 + 0x194) = v4;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v6 )
  {
    ++*(_DWORD *)(v2 + 0x14);
  }
  else
  {
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 1, 0);
    if ( v7 )
      sub_1403C33A0(v2, v7, "CRenderProxy::SetAllowBakedRenderingFlag", 1);
    else
      *(_QWORD *)(v2 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v2 + 0x10) = v6;
  }
  v8 = 0;
  v9 = (unsigned int *)(a1 + 0x78);
  if ( !a1 )
    v9 = 0;
  v10 = v9[2];
  if ( a2 )
    LODWORD(v10) = v10 | 0x200000;
  else
    LODWORD(v10) = v10 & 0xFFDFFFFF;
  (*(void (__fastcall **)(unsigned int *, __int64))(*(_QWORD *)v9 + 0x1A0LL))(v9, v10);
  v11 = *(_DWORD *)(v2 + 0x14);
  if ( v11 )
  {
    *(_DWORD *)(v2 + 0x14) = v11 - 1;
  }
  else
  {
    *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
    v12 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 0, 1);
    if ( v12 == 1 )
      *(_QWORD *)(v2 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(v2, v12);
  }
  if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x244);
  }
  else
  {
    v13 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
    if ( (v13 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x230, v13, "CRenderProxy::SetAllowBakedRenderingFlag", "m_SlotsLock", 1);
  }
  v14 = *(_QWORD *)(a1 + 0xE0);
  if ( (*(_QWORD *)(a1 + 0xE8) - v14) >> 3 )
  {
    do
    {
      v15 = *(_QWORD *)(v14 + 8 * v8);
      if ( v15 )
        sub_146AEB290(a1, v15);
      v14 = *(_QWORD *)(a1 + 0xE0);
      ++v8;
    }
    while ( v8 < (*(_QWORD *)(a1 + 0xE8) - v14) >> 3 );
  }
  return sub_1402D2790(a1 + 0x230);
}

// --- End Function: sub_146AF7910 (0x146AF7910) ---

// --- Function: sub_146AF7AB0 (0x146AF7AB0) ---
unsigned __int64 __fastcall sub_146AF7AB0(__int64 a1, char a2)
{
  unsigned int v4; // r8d
  unsigned __int64 v5; // rbx
  unsigned int *v6; // rcx
  __int64 v7; // rdx
  signed __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdx

  v4 = *(_DWORD *)(a1 + 0x194) | 0x40000;
  if ( !a2 )
    v4 = *(_DWORD *)(a1 + 0x194) & 0xFFFBFFFF;
  v5 = 0;
  *(_DWORD *)(a1 + 0x194) = v4;
  v6 = (unsigned int *)(a1 + 0x78);
  if ( !a1 )
    v6 = 0;
  if ( v6 )
  {
    v7 = v6[2];
    if ( a2 )
      LODWORD(v7) = v7 | 0x10000000;
    else
      LODWORD(v7) = v7 & 0xEFFFFFFF;
    (*(void (__fastcall **)(unsigned int *, __int64))(*(_QWORD *)v6 + 0x1A0LL))(v6, v7);
  }
  if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x244);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
    if ( (v8 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x230, v8, "CRenderProxy::SetAsHolographicObject", "m_SlotsLock", 1);
  }
  v9 = *(_QWORD *)(a1 + 0xE0);
  if ( (*(_QWORD *)(a1 + 0xE8) - v9) >> 3 )
  {
    do
    {
      v10 = *(_QWORD *)(v9 + 8 * v5);
      if ( v10 )
        sub_146AEB290(a1, v10);
      v9 = *(_QWORD *)(a1 + 0xE0);
      ++v5;
    }
    while ( v5 < (*(_QWORD *)(a1 + 0xE8) - v9) >> 3 );
  }
  return sub_1402D2790(a1 + 0x230);
}

// --- End Function: sub_146AF7AB0 (0x146AF7AB0) ---

// --- Function: sub_146AF8D00 (0x146AF8D00) ---
void __fastcall sub_146AF8D00(__int64 a1, float *a2, float a3, char a4, int n0x3F800000, char a6, char a7)
{
  __int64 v7; // r15
  char v9; // bp
  float *v10; // rsi
  signed __int64 v12; // rdx
  __int64 v13; // rdi
  __int64 v14; // rbx
  __int64 v15; // rsi
  __int64 v16; // r14
  __int64 v17; // rax
  unsigned int v18; // esi
  unsigned int v19; // ebp
  float v20; // xmm3_4
  float v21; // xmm4_4
  float v22; // xmm2_4
  float v23; // xmm1_4
  bool v24; // al
  char v25; // bl
  float v26[4]; // [rsp+30h] [rbp-78h] BYREF
  char v27; // [rsp+40h] [rbp-68h]
  float v28; // [rsp+44h] [rbp-64h]
  int n0x3F800000_1; // [rsp+48h] [rbp-60h]
  __int128 v30; // [rsp+4Ch] [rbp-5Ch]

  v7 = a1 + 0x148;
  v9 = a4;
  v10 = a2;
  if ( _bittest((const signed __int32 *)(a1 + 0x194), 0xEu) )
  {
    sub_14051ED90(v7, 0);
    sub_1404F1B30(v7, 0);
    *(_DWORD *)(a1 + 0x194) &= ~0x4000u;
    if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0x244);
    }
    else
    {
      v12 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
      if ( (v12 & 0x200000) != 0 )
        sub_1403CB300(a1 + 0x230, v12, "CRenderProxy::ClearHUDSubObjectSilhouettesParams", "m_SlotsLock", 1);
    }
    v13 = *(_QWORD *)(a1 + 0xE8);
    v14 = *(_QWORD *)(a1 + 0xE0);
    if ( v14 != v13 )
    {
      do
      {
        if ( *(_QWORD *)v14 )
        {
          v15 = *(_QWORD *)(*(_QWORD *)v14 + 0x80LL);
          if ( v15 )
          {
            if ( (*(unsigned int (__fastcall **)(_QWORD))(*(_QWORD *)v15 + 0x128LL))(*(_QWORD *)(*(_QWORD *)v14 + 0x80LL)) == 0x55AA55AA )
            {
              v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x30LL))(v15);
              if ( v16 )
              {
                v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x70LL))(v15);
                v18 = 0;
                v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x10LL))(v17);
                if ( v19 )
                {
                  do
                    (*(void (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v16 + 0x390LL))(
                      v16,
                      v18++,
                      0,
                      0);
                  while ( v18 < v19 );
                }
              }
            }
          }
        }
        v14 += 8;
      }
      while ( v14 != v13 );
      v10 = a2;
      v9 = a4;
    }
    sub_1402D2790(a1 + 0x230);
  }
  v20 = *v10;
  v21 = v10[1];
  v22 = v10[2];
  v23 = v10[3];
  v30 = 0;
  v28 = a3;
  v27 = v9;
  n0x3F800000_1 = n0x3F800000;
  v26[0] = v20;
  v26[1] = v21;
  v26[2] = v22;
  v26[3] = v23;
  if ( a7 )
  {
    v24 = v20 == 0.0 && v21 == 0.0 && v22 == 0.0 && v23 == 0.0;
    v25 = a6;
    v7 = a1 + 0x148;
    if ( v24 )
      v25 = 0;
  }
  else
  {
    v25 = a6;
  }
  sub_14051ED90(v7, (__int64)v26);
  sub_1404F1B30(v7, v25);
}

// --- End Function: sub_146AF8D00 (0x146AF8D00) ---

// --- Function: sub_146AF9A10 (0x146AF9A10) ---
unsigned __int64 __fastcall sub_146AF9A10(__int64 a1, int n0xFF_1)
{
  unsigned __int64 v2; // rdi
  __int64 v3; // r14
  char n0xFF_2; // al
  int n0xFF; // r8d
  signed __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rbx
  __int64 v11; // rcx
  __int64 v12; // rcx

  v2 = 0;
  v3 = a1 + 0x230;
  n0xFF_2 = 0xFF;
  n0xFF = n0xFF_1;
  if ( n0xFF_1 <= 0 )
    n0xFF = 0;
  if ( n0xFF < 0xFF )
    n0xFF_2 = n0xFF;
  *(_BYTE *)(a1 + 0x8E) = n0xFF_2;
  if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)v3);
    if ( (v8 & 0x200000) != 0 )
      sub_1403CB300(v3, v8, "CRenderProxy::SetLodRatio", "m_SlotsLock", 1);
  }
  v9 = *(_QWORD *)(a1 + 0xE0);
  if ( (*(_QWORD *)(a1 + 0xE8) - v9) >> 3 )
  {
    do
    {
      v10 = *(_QWORD *)(v9 + 8 * v2);
      if ( v10 )
      {
        v11 = *(_QWORD *)(v10 + 0x90);
        if ( v11 )
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v11 + 0xD8LL))(v11, (unsigned int)n0xFF_1);
        v12 = *(_QWORD *)(v10 + 0x88);
        if ( v12 )
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v12 + 0xD8LL))(v12, (unsigned int)n0xFF_1);
      }
      v9 = *(_QWORD *)(a1 + 0xE0);
      ++v2;
    }
    while ( v2 < (*(_QWORD *)(a1 + 0xE8) - v9) >> 3 );
  }
  return sub_1402D2790(v3);
}

// --- End Function: sub_146AF9A10 (0x146AF9A10) ---

// --- Function: sub_146AFB540 (0x146AFB540) ---
unsigned __int64 __fastcall sub_146AFB540(__int64 a1, unsigned int a2)
{
  int v3; // esi
  int n0xFFFFFF; // eax
  int v6; // ecx
  __int64 n0xFFFE; // r8
  volatile signed __int64 *v8; // rsi
  signed __int64 v9; // rdx
  __int64 *v10; // rdi
  __int64 *i; // rbx
  __int64 v12; // rax
  __int64 v13; // rcx

  v3 = *(_DWORD *)(a1 + 8) & 0x4800;
  n0xFFFFFF = *(_DWORD *)(a1 + 0x10) & 0xFFFFFF;
  *(_DWORD *)(a1 + 8) = a2;
  if ( n0xFFFFFF != 0xFFFFFF )
  {
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149B4FBE8 + 0x380LL))(
      qword_149B4FBE8,
      a1 + 0x10,
      a2);
    v6 = *(_DWORD *)(a1 + 8);
    if ( (v6 & 0x4800) != v3 )
    {
      n0xFFFE = 0xFFFE;
      if ( (v6 & 0x800) != 0 )
      {
        n0xFFFE = 0xFFFD;
      }
      else if ( (v6 & 0x4000) != 0 )
      {
        n0xFFFE = 0xFFFC;
      }
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x3D8LL))(
        qword_149B4FBE8,
        a1 + 0x10,
        n0xFFFE);
    }
  }
  v8 = (volatile signed __int64 *)(a1 + 0x1B8);
  if ( *(_DWORD *)(a1 + 0x1C8) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x1CC);
  }
  else
  {
    v9 = _InterlockedIncrement64(v8);
    if ( (v9 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x1B8, v9, "CRenderProxy::SetChildRndFlags", "m_SlotsLock", 1);
  }
  v10 = *(__int64 **)(a1 + 0x70);
  for ( i = *(__int64 **)(a1 + 0x68); i != v10; ++i )
  {
    v12 = *i;
    if ( *i )
    {
      if ( (*(_BYTE *)(v12 + 0xD8) & 1) != 0 )
      {
        v13 = *(_QWORD *)(v12 + 0x90);
        if ( v13 )
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 0x1A0LL))(v13, a2);
      }
    }
  }
  return sub_1402D2790((__int64)v8);
}

// --- End Function: sub_146AFB540 (0x146AFB540) ---

// --- Function: sub_146AFDC90 (0x146AFDC90) ---
unsigned __int64 __fastcall sub_146AFDC90(__int64 a1, int n0xFF_1)
{
  unsigned __int64 v4; // rdi
  int n0xFF; // r8d
  signed __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 v10; // rcx

  v4 = 0;
  if ( n0xFF_1 >= 0 )
  {
    n0xFF = 0xFF;
    if ( n0xFF_1 < 0xFF )
      n0xFF = n0xFF_1;
  }
  else
  {
    n0xFF = 0;
  }
  if ( *(unsigned __int8 *)(a1 + 0x8D) != n0xFF )
  {
    *(_BYTE *)(a1 + 0x8D) = n0xFF;
    if ( (*(_DWORD *)(a1 + 0x88) & 0xFFFFFF) != 0xFFFFFF )
      (*(void (**)(void))(*(_QWORD *)qword_149B4FBE8 + 0x388LL))();
  }
  if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x244);
  }
  else
  {
    v6 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
    if ( (v6 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x230, v6, "CRenderProxy::SetViewDistRatio", "m_SlotsLock", 1);
  }
  v7 = *(_QWORD *)(a1 + 0xE0);
  if ( (*(_QWORD *)(a1 + 0xE8) - v7) >> 3 )
  {
    do
    {
      v8 = *(_QWORD *)(v7 + 8 * v4);
      if ( v8 )
      {
        v9 = *(_QWORD *)(v8 + 0x90);
        if ( v9 )
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + 0x198LL))(v9, (unsigned int)n0xFF_1);
        v10 = *(_QWORD *)(v8 + 0x88);
        if ( v10 )
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v10 + 0x198LL))(v10, (unsigned int)n0xFF_1);
      }
      v7 = *(_QWORD *)(a1 + 0xE0);
      ++v4;
    }
    while ( v4 < (*(_QWORD *)(a1 + 0xE8) - v7) >> 3 );
  }
  if ( (*(_DWORD *)(a1 + 0x88) & 0xFFFFFF) != 0xFFFFFF )
    (*(void (**)(void))(*(_QWORD *)qword_149B4FBE8 + 0x388LL))();
  return sub_1402D2790(a1 + 0x230);
}

// --- End Function: sub_146AFDC90 (0x146AFDC90) ---

// --- Function: sub_146B09E30 (0x146B09E30) ---
unsigned __int64 __fastcall sub_146B09E30(__int64 a1)
{
  __int64 v2; // rcx
  int v3; // eax
  int v4; // edx
  int v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // edx
  int v8; // edx
  unsigned int v9; // edx
  int v10; // eax
  unsigned int v11; // edx
  unsigned int v12; // eax

  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v2 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v2 = 0;
  v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x28LL))(v2);
  v4 = *(_DWORD *)(a1 + 0x80);
  v5 = v3;
  *(_DWORD *)(a1 + 0x190) = v3;
  v6 = v4 & 0xFFFFFFF7;
  v7 = v4 | 8;
  if ( (v3 & 0x80000) == 0 )
    v7 = v6;
  sub_146AFB540(a1 + 0x78, v7);
  v8 = *(_DWORD *)(a1 + 0x80);
  if ( (v5 & 0x100) != 0 )
  {
    v9 = v8 | 0x800;
  }
  else
  {
    v9 = v8 & 0xFFFFB7FF;
    if ( (v5 & 0x10000) != 0 )
      v9 = *(_DWORD *)(a1 + 0x80) | 0x4000;
  }
  sub_146AFB540(a1 + 0x78, v9);
  v10 = *(_DWORD *)(a1 + 0x80);
  v11 = v10 | 0x40000;
  v12 = v10 & 0xFFFBFFFF;
  if ( (v5 & 0x80000004) == 0 )
    v11 = v12;
  return sub_146AFB540(a1 + 0x78, v11);
}

// --- End Function: sub_146B09E30 (0x146B09E30) ---

// --- Function: sub_146B0A630 (0x146B0A630) ---
double __fastcall sub_146B0A630(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int64 v4; // r14
  void (__fastcall *v6)(__int64, __int64, double *, _QWORD); // rbp
  volatile signed __int64 *v7; // rbx
  signed __int64 v8; // rdx
  __m128 v9; // xmm6
  double v10; // xmm7_8
  double v11; // xmm8_8
  float v12; // xmm1_4
  double v13; // xmm2_8
  double v14; // xmm0_8
  double v15; // xmm3_8
  double v16; // xmm1_8
  double v17; // xmm4_8
  double v18; // xmm5_8
  __int64 v19; // r14
  void (__fastcall *v20)(__int64, __int64, double *); // rbp
  signed __int64 v21; // rsi
  __m128 v22; // xmm6
  float v23; // xmm1_4
  double v24; // xmm0_8
  double v25; // xmm2_8
  double v26; // xmm1_8
  double v27; // xmm3_8
  __int64 v28; // rbx
  __int64 v29; // rdx
  __int64 v31; // [rsp+40h] [rbp-C8h]
  double v32[6]; // [rsp+48h] [rbp-C0h] BYREF
  double v33[8]; // [rsp+78h] [rbp-90h] BYREF
  __int64 v34; // [rsp+B8h] [rbp-50h]
  __int128 v35; // [rsp+C0h] [rbp-48h]
  __int128 v36; // [rsp+D0h] [rbp-38h]
  __int128 v37; // [rsp+E0h] [rbp-28h]

  v4 = qword_149B4FBE8;
  v37 = v1;
  v36 = v2;
  v35 = v3;
  v6 = *(void (__fastcall **)(__int64, __int64, double *, _QWORD))(*(_QWORD *)qword_149B4FBE8 + 0x378LL);
  if ( (*(_DWORD *)(a1 + 0x194) & 2) == 0 )
    sub_146A88AF0(a1);
  v7 = (volatile signed __int64 *)(a1 + 0x100);
  if ( *(_DWORD *)(a1 + 0x110) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x114);
  }
  else
  {
    v8 = _InterlockedIncrement64(v7);
    if ( (v8 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x100, v8, "CRenderProxy::GetLocalBounds", "localBBoxLock", 1);
  }
  v9 = *(__m128 *)(a1 + 0x118);
  v31 = *(_QWORD *)(a1 + 0x128);
  sub_1402D2790(a1 + 0x100);
  v10 = 1.0e150;
  v11 = -1.0e150;
  v12 = _mm_shuffle_ps(v9, v9, 0xFF).m128_f32[0];
  if ( v9.m128_f32[0] <= v12 )
  {
    v13 = v9.m128_f32[0];
    v15 = _mm_shuffle_ps(v9, v9, 0xAA).m128_f32[0];
    v14 = _mm_shuffle_ps(v9, v9, 0x55).m128_f32[0];
    v16 = v12;
    v17 = *(float *)&v31;
    v18 = *((float *)&v31 + 1);
  }
  else
  {
    v13 = 1.0e150;
    v14 = 1.0e150;
    v15 = 1.0e150;
    v16 = -1.0e150;
    v17 = -1.0e150;
    v18 = -1.0e150;
  }
  v32[0] = v13;
  v32[1] = v14;
  v32[2] = v15;
  v32[3] = v16;
  v32[4] = v17;
  v32[5] = v18;
  v6(v4, a1 + 0x88, v32, 0);
  v19 = qword_149B4FBE8;
  v20 = *(void (__fastcall **)(__int64, __int64, double *))(*(_QWORD *)qword_149B4FBE8 + 0x3F0LL);
  if ( (*(_DWORD *)(a1 + 0x194) & 2) == 0 )
    sub_146A88AF0(a1);
  if ( *(_DWORD *)(a1 + 0x110) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x114);
  }
  else
  {
    v21 = _InterlockedIncrement64(v7);
    if ( (v21 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x100, v21, "CRenderProxy::GetLocalBounds", "localBBoxLock", 1);
  }
  v22 = *(__m128 *)(a1 + 0x118);
  v34 = *(_QWORD *)(a1 + 0x128);
  sub_1402D2790(a1 + 0x100);
  v23 = _mm_shuffle_ps(v22, v22, 0xFF).m128_f32[0];
  if ( v22.m128_f32[0] <= v23 )
  {
    v11 = v23;
    v10 = v22.m128_f32[0];
    v25 = _mm_shuffle_ps(v22, v22, 0xAA).m128_f32[0];
    v26 = *(float *)&v34;
    v24 = _mm_shuffle_ps(v22, v22, 0x55).m128_f32[0];
    v27 = *((float *)&v34 + 1);
  }
  else
  {
    v24 = 1.0e150;
    v25 = 1.0e150;
    v26 = -1.0e150;
    v27 = -1.0e150;
  }
  v33[0] = v10;
  v33[1] = v24;
  v33[2] = v25;
  v33[3] = v11;
  v33[4] = v26;
  v33[5] = v27;
  v28 = 0;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v29 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v29 = 0;
  v20(v19, v29 + 0x2A8, v33);
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v28 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  return sub_146B83C10(v28, (_WORD *)a1, 0, 1);
}

// --- End Function: sub_146B0A630 (0x146B0A630) ---

// --- Function: sub_146B0AA80 (0x146B0AA80) ---
__int64 __fastcall sub_146B0AA80(__int64 a1)
{
  __int64 v2; // rbx
  signed __int64 v4; // rdx
  __int64 v5; // rbp
  unsigned __int64 v6; // r15
  _QWORD *v7; // rdi
  __int64 *v8; // rbx
  char v9; // al
  __int64 *v10; // rcx
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rdx
  __int64 v14; // rcx
  char v15; // al
  __int64 v16; // rax
  __int64 *v17; // [rsp+60h] [rbp+8h] BYREF
  __int64 *v18; // [rsp+68h] [rbp+10h] BYREF

  *(_BYTE *)(a1 + 0x90) &= ~1u;
  v2 = *(_QWORD *)(a1 + 0x160);
  if ( v2 )
  {
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v2 + 8LL))(*(_QWORD *)(a1 + 0x160));
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x98LL))(v2) )
    {
      *(_BYTE *)(a1 + 0x90) |= 1u;
      return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x10LL))(v2);
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x10LL))(v2);
  }
  if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x244);
  }
  else
  {
    v4 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
    if ( (v4 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x230, v4, "CRenderProxy::UpdateMaterialFlags", "m_SlotsLock", 1);
  }
  v5 = 0;
  v6 = (__int64)(*(_QWORD *)(a1 + 0xE8) - *(_QWORD *)(a1 + 0xE0)) >> 3;
  if ( !v6 )
    return sub_1402D2790(a1 + 0x230);
  while ( 1 )
  {
    v7 = *(_QWORD **)(*(_QWORD *)(a1 + 0xE0) + 8 * v5);
    if ( v7 )
    {
      v8 = (__int64 *)v7[0x18];
      if ( v8 )
      {
        (*(void (__fastcall **)(_QWORD))(*v8 + 8))(v7[0x18]);
        v9 = (*(__int64 (__fastcall **)(__int64 *))(*v8 + 0x98))(v8);
        v10 = v8;
        if ( v9 )
        {
          *(_BYTE *)(a1 + 0x90) |= 1u;
          v16 = *v8;
          goto LABEL_34;
        }
        (*(void (__fastcall **)(__int64 *))(*v8 + 0x10))(v8);
      }
      v11 = v7[0xB];
      if ( v11 )
      {
        (*(void (__fastcall **)(__int64, __int64 **))(*(_QWORD *)v11 + 0x38LL))(v11, &v17);
        if ( v17 )
        {
          v12 = (*(__int64 (__fastcall **)(__int64 *))(*v17 + 0x98))(v17);
          v10 = v17;
          if ( v12 )
            goto LABEL_32;
          if ( v17 )
            (*(void (**)(void))(*v17 + 0x10))();
        }
        v17 = 0;
      }
      v13 = v7[0x10];
      if ( v13 && sub_146A8E3B0(a1, v13) )
      {
        *(_BYTE *)(a1 + 0x90) |= 1u;
        return sub_1402D2790(a1 + 0x230);
      }
      v14 = v7[0x12];
      if ( v14 )
        break;
    }
LABEL_28:
    if ( ++v5 >= v6 )
      return sub_1402D2790(a1 + 0x230);
  }
  (*(void (__fastcall **)(__int64, __int64 **))(*(_QWORD *)v14 + 0x130LL))(v14, &v18);
  if ( !v18 )
  {
LABEL_27:
    v18 = 0;
    goto LABEL_28;
  }
  v15 = (*(__int64 (__fastcall **)(__int64 *))(*v18 + 0x98))(v18);
  v10 = v18;
  if ( !v15 )
  {
    if ( v18 )
      (*(void (**)(void))(*v18 + 0x10))();
    goto LABEL_27;
  }
LABEL_32:
  *(_BYTE *)(a1 + 0x90) |= 1u;
  if ( !v10 )
    return sub_1402D2790(a1 + 0x230);
  v16 = *v10;
LABEL_34:
  (*(void (__fastcall **)(__int64 *))(v16 + 0x10))(v10);
  return sub_1402D2790(a1 + 0x230);
}

// --- End Function: sub_146B0AA80 (0x146B0AA80) ---

// --- Function: sub_146B0E070 (0x146B0E070) ---
_QWORD *__fastcall sub_146B0E070(_QWORD *a1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbx
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  _QWORD *result; // rax
  __int64 v7; // rcx
  _QWORD *v8; // rbx
  __int64 v9; // [rsp+30h] [rbp+8h] BYREF

  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( sub_1403BFA30(a1 + 0x2F) )
  {
    v3 = a1[0x2C];
    if ( v3 )
    {
      v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x1D8LL))(v3);
      if ( v4 )
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x18LL))(v4);
    }
  }
  else
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)a1[0x2F];
  }
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pSystem + 0x830LL))(pSystem);
  result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const ULONG_PTR *, _QWORD))(*(_QWORD *)v5 + 0x28LL))(
                       v5,
                       &v9,
                       p_p_p_p_p_p_p_p_p_p_p_p_Source,
                       a1[0x2E]);
  v7 = a1[0x2D];
  v8 = result;
  a1[0x2D] = *result;
  *result = v7;
  if ( v7 )
    result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x10LL))(v7);
  *v8 = 0;
  if ( v9 )
    return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x10LL))(v9);
  return result;
}

// --- End Function: sub_146B0E070 (0x146B0E070) ---

// --- Function: sub_146B11430 (0x146B11430) ---
__int64 __fastcall sub_146B11430(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int8 (__fastcall *v2)(__int64, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+30h] [rbp+8h] BYREF
  char v6; // [rsp+38h] [rbp+10h] BYREF

  v1 = a1;
  v2 = *(unsigned __int8 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a1 + 8LL);
  n0xFFFF = n0xFFFF_33;
  if ( n0xFFFF_33 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v6,
                          "IEntityComponentObjectContainer");
    n0xFFFF_33 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  if ( !v2(v1, &n0xFFFF_1) )
    return 0;
  return v1;
}

// --- End Function: sub_146B11430 (0x146B11430) ---

// --- Function: sub_146B114A0 (0x146B114A0) ---
__int64 __fastcall sub_146B114A0(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int8 (__fastcall *v2)(__int64, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+30h] [rbp+8h] BYREF
  char v6; // [rsp+38h] [rbp+10h] BYREF

  v1 = a1;
  v2 = *(unsigned __int8 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a1 + 8LL);
  n0xFFFF = n0xFFFF_48;
  if ( n0xFFFF_48 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v6,
                          "IEntityComponentUIPrimitiveRenderNode");
    n0xFFFF_48 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  if ( !v2(v1, &n0xFFFF_1) )
    return 0;
  return v1;
}

// --- End Function: sub_146B114A0 (0x146B114A0) ---

// --- Function: sub_146B11510 (0x146B11510) ---
__int64 __fastcall sub_146B11510(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int8 (__fastcall *v2)(__int64, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+30h] [rbp+8h] BYREF
  char v6; // [rsp+38h] [rbp+10h] BYREF

  v1 = a1;
  v2 = *(unsigned __int8 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a1 + 8LL);
  n0xFFFF = n0xFFFF_49;
  if ( n0xFFFF_49 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v6,
                          "IEntityComponentUIRenderToTexture");
    n0xFFFF_49 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  if ( !v2(v1, &n0xFFFF_1) )
    return 0;
  return v1;
}

// --- End Function: sub_146B11510 (0x146B11510) ---

// --- Function: sub_146B11580 (0x146B11580) ---
__int64 __fastcall sub_146B11580(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int8 (__fastcall *v2)(__int64, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+30h] [rbp+8h] BYREF
  char v6; // [rsp+38h] [rbp+10h] BYREF

  v1 = a1;
  v2 = *(unsigned __int8 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a1 + 8LL);
  n0xFFFF = n0xFFFF_37;
  if ( n0xFFFF_37 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v6,
                          "RenderProxy");
    n0xFFFF_37 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  if ( !v2(v1, &n0xFFFF_1) )
    return 0;
  return v1;
}

// --- End Function: sub_146B11580 (0x146B11580) ---

// --- Function: sub_146B5FDF0 (0x146B5FDF0) ---
char __fastcall sub_146B5FDF0(__int64 a1)
{
  unsigned __int64 v2; // rax
  _BYTE *v3; // rdi
  unsigned __int64 *v4; // r14
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rcx
  __int64 v9; // rbp
  __int64 *v10; // r14
  _BYTE *v13; // rsi
  __int64 v14; // rax
  int v15; // eax
  char n4; // cl
  signed __int64 v17; // rdx
  _DWORD v19[4]; // [rsp+30h] [rbp-68h] BYREF
  double v20; // [rsp+40h] [rbp-58h]
  char n4_1; // [rsp+48h] [rbp-50h]
  unsigned __int64 v22; // [rsp+A0h] [rbp+8h] BYREF

  if ( *(_BYTE *)(a1 + 0xD) >= 4u )
  {
    v3 = (_BYTE *)(a1 + 0xD);
  }
  else
  {
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 0x318))
      && (v2 = *(_QWORD *)(a1 + 0x318) & 0xFFFFFFFFFFFFLL, *(_BYTE *)(v2 + 0xD) >= 4u)
      || (LOBYTE(v2) = sub_14030EC00((unsigned __int64 *)(a1 + 0x318)), !(_BYTE)v2) )
    {
      *(_DWORD *)(a1 + 8) |= 0x200u;
      return v2;
    }
    v3 = (_BYTE *)(a1 + 0xD);
  }
  v4 = (unsigned __int64 *)(a1 + 0x330);
  if ( *(_BYTE *)(a1 + 0xD) < 5u )
  {
    v5 = *(_QWORD *)(*v4 + 0xC0);
    v22 = *(_QWORD *)(a1 + 0x318);
    v6 = sub_146B4BCC0(&v22, v5);
    v7 = v6;
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 0xD) >= 4u && *v3 < 4u )
      {
        v2 = NtCurrentTeb_w();
        if ( !*(_BYTE *)(v2 + 0x12D) )
        {
          *(_DWORD *)(a1 + 8) |= 0x200u;
          return v2;
        }
      }
      sub_146B7C900(v7, a1);
      sub_146B7C0F0(v7, a1);
      v3 = (_BYTE *)(a1 + 0xD);
    }
  }
  v2 = *v4;
  v8 = *(unsigned int *)(a1 + 0x2F0);
  v9 = qword_1515B1A08;
  v10 = *(__int64 **)(*v4 + 0xC0);
  _XMM6 = *(unsigned __int64 *)(v2 + 0x18);
  __asm { vcvtpd2ps xmm6, xmm6 }
  if ( (_DWORD)v8 != 0xFFFFFFFF )
  {
    v13 = (_BYTE *)(*(_QWORD *)(qword_1515B1A08 + 0x120) + 0xC0 * v8);
    if ( (v13[0xBC] & 1) != 0 )
    {
      v14 = *v10;
      v19[2] = *(_DWORD *)(a1 + 0x2F0);
      v19[0] = 3;
      v15 = (*(__int64 (__fastcall **)(__int64 *))(v14 + 0x1F8))(v10);
      n4 = v13[0xB1];
      v19[3] = v15;
      v20 = *(float *)&_XMM6;
      if ( n4 == 4 )
      {
        n4 = v13[0xB2];
        if ( n4 == 4 )
        {
          n4 = 4;
          if ( v13[0xB3] != 4 )
            n4 = v13[0xB3];
        }
      }
      n4_1 = n4;
      if ( *(_DWORD *)(v9 + 0x18) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v9 + 0x1C);
      }
      else
      {
        v17 = _InterlockedIncrement64((volatile signed __int64 *)(v9 + 8));
        if ( (v17 & 0x200000) != 0 )
          sub_1403CB300(
            v9 + 8,
            v17,
            "CEntityAggregateManager::OnAggregateCompleteRadiusChanged",
            "m_UpdateQueueLock",
            1);
      }
      sub_146B66700(v9, v10, v19);
      LOBYTE(v2) = sub_1402D2790(v9 + 8);
      v3 = (_BYTE *)(a1 + 0xD);
    }
  }
  if ( *v3 < 5u )
  {
    v22 = *(_QWORD *)(a1 + 0x328);
    if ( sub_14030EC00(&v22) )
      v2 = v22 & 0xFFFFFFFFFFFFLL;
    else
      v2 = 0;
    if ( v2 == a1 )
      LOBYTE(v2) = sub_146B74B20(a1, 0x80);
  }
  return v2;
}

// --- End Function: sub_146B5FDF0 (0x146B5FDF0) ---

// --- Function: sub_146B60DD0 (0x146B60DD0) ---
void __fastcall sub_146B60DD0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v5; // rsi
  __int64 v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rcx
  unsigned __int64 v11; // [rsp+30h] [rbp+8h] BYREF

  if ( *(_BYTE *)(a1 + 0xD) >= 4u
    || (!sub_14030EC00((unsigned __int64 *)(a1 + 0x318))
     || *(_BYTE *)((*(_QWORD *)(a1 + 0x318) & 0xFFFFFFFFFFFFLL) + 0xD) < 4u)
    && sub_14030EC00((unsigned __int64 *)(a1 + 0x318)) )
  {
    v5 = a1 + 0x330;
    if ( *(_BYTE *)(a1 + 0xD) < 5u )
    {
      v6 = *(_QWORD *)(*(_QWORD *)v5 + 0xC0LL);
      v11 = *(_QWORD *)(a1 + 0x318);
      v7 = sub_146B4BCC0(&v11, v6);
      if ( v7 )
        sub_146B7C900(v7, a1);
    }
    v8 = *(unsigned int *)(a1 + 0x2F0);
    if ( (_DWORD)v8 != 0xFFFFFFFF )
    {
      _XMM0 = *(unsigned __int64 *)(*(_QWORD *)v5 + 0x20LL);
      __asm { vcvtpd2ps xmm0, xmm0 }
      *(double *)(0xC0 * v8 + *(_QWORD *)(qword_1515B1A08 + 0x120) + 0x60) = *(float *)&_XMM0;
    }
  }
  else
  {
    v2 = *(unsigned int *)(a1 + 0x2F0);
    if ( (_DWORD)v2 != 0xFFFFFFFF )
    {
      _XMM0 = *(unsigned __int64 *)(*(_QWORD *)(a1 + 0x330) + 0x20LL);
      __asm { vcvtpd2ps xmm0, xmm0 }
      *(double *)(0xC0 * v2 + *(_QWORD *)(qword_1515B1A08 + 0x120) + 0x60) = *(float *)&_XMM0;
    }
  }
}

// --- End Function: sub_146B60DD0 (0x146B60DD0) ---

// --- Function: sub_146B7BC70 (0x146B7BC70) ---
__int64 __fastcall sub_146B7BC70(__int64 a1, double a2, int a3)
{
  __int128 v3; // xmm6
  __int64 v6; // rbx
  double v7; // xmm0_8
  double v8; // xmm0_8
  unsigned __int8 v9; // bl
  int n0xF00; // [rsp+30h] [rbp-68h] BYREF
  __int64 v12; // [rsp+34h] [rbp-64h]
  int v13; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v14; // [rsp+40h] [rbp-58h]
  unsigned __int64 v15; // [rsp+48h] [rbp-50h]
  __int64 v16; // [rsp+50h] [rbp-48h]
  __int64 v17; // [rsp+58h] [rbp-40h]
  __int128 v18; // [rsp+80h] [rbp-18h]

  n0xF00 = 0xF00;
  v12 = 1;
  v13 = 0;
  v18 = v3;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0xF00,
    &word_1515B1BF4,
    "CEntity::UpdateAggregateRadius_CheckCompleteRadiusChanges",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\Entity_AggregateRadius.cpp",
    0x174);
  v6 = *(_QWORD *)(a1 + 0x330);
  HIWORD(n0xF00) = word_1515B1BF4;
  if ( a3 + 0x80000000 <= 0x7FFFFFFD )
  {
    v7 = *(double *)(v6 + 0x30);
    if ( *(_DWORD *)(v6 + 0x40) == a3 )
    {
      if ( a2 < v7 )
      {
        sub_146B7E050(a1);
        goto LABEL_8;
      }
    }
    else
    {
      if ( a2 <= v7 )
        goto LABEL_8;
      *(_DWORD *)(v6 + 0x40) = a3;
    }
    *(double *)(v6 + 0x30) = a2;
  }
LABEL_8:
  v8 = *(double *)(v6 + 0x18);
  if ( *(_DWORD *)(v6 + 0x28) != a3 )
  {
    if ( a2 <= v8 )
    {
      v9 = 0;
      goto LABEL_15;
    }
    *(_DWORD *)(v6 + 0x28) = a3;
    goto LABEL_13;
  }
  if ( a2 >= v8 )
  {
LABEL_13:
    *(double *)(v6 + 0x18) = a2;
    v9 = 1;
    goto LABEL_15;
  }
  sub_146B7BB30(a1);
  v9 = 1;
LABEL_15:
  v15 = __rdtsc();
  qword_149B4B878(&n0xF00);
  return v9;
}

// --- End Function: sub_146B7BC70 (0x146B7BC70) ---

// --- Function: sub_146B7BDA0 (0x146B7BDA0) ---
__int64 __fastcall sub_146B7BDA0(__int64 a1, double a2, int a3)
{
  __int128 v3; // xmm6
  __int64 v6; // rbx
  double v7; // xmm0_8
  double v8; // xmm0_8
  unsigned __int8 v9; // bl
  int n0xF00; // [rsp+30h] [rbp-68h] BYREF
  __int64 v12; // [rsp+34h] [rbp-64h]
  int v13; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v14; // [rsp+40h] [rbp-58h]
  unsigned __int64 v15; // [rsp+48h] [rbp-50h]
  __int64 v16; // [rsp+50h] [rbp-48h]
  __int64 v17; // [rsp+58h] [rbp-40h]
  __int128 v18; // [rsp+80h] [rbp-18h]

  n0xF00 = 0xF00;
  v12 = 1;
  v13 = 0;
  v18 = v3;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0xF00,
    &word_1515B1BF0,
    "CEntity::UpdateAggregateRadius_CheckRenderingRadiusChanges",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\Entity_AggregateRadius.cpp",
    0x140);
  v6 = *(_QWORD *)(a1 + 0x330);
  HIWORD(n0xF00) = word_1515B1BF0;
  if ( a3 + 0x80000000 <= 0x7FFFFFFD )
  {
    v7 = *(double *)(v6 + 0x38);
    if ( *(_DWORD *)(v6 + 0x44) == a3 )
    {
      if ( a2 < v7 )
      {
        sub_146B7E050(a1);
        goto LABEL_8;
      }
    }
    else
    {
      if ( a2 <= v7 )
        goto LABEL_8;
      *(_DWORD *)(v6 + 0x44) = a3;
    }
    *(double *)(v6 + 0x38) = a2;
  }
LABEL_8:
  v8 = *(double *)(v6 + 0x20);
  if ( *(_DWORD *)(v6 + 0x2C) != a3 )
  {
    if ( a2 <= v8 )
    {
      v9 = 0;
      goto LABEL_15;
    }
    *(_DWORD *)(v6 + 0x2C) = a3;
    goto LABEL_13;
  }
  if ( a2 >= v8 )
  {
LABEL_13:
    *(double *)(v6 + 0x20) = a2;
    v9 = 1;
    goto LABEL_15;
  }
  sub_146B7E3B0(a1);
  v9 = 1;
LABEL_15:
  v15 = __rdtsc();
  qword_149B4B878(&n0xF00);
  return v9;
}

// --- End Function: sub_146B7BDA0 (0x146B7BDA0) ---

// --- Function: sub_146B7D1B0 (0x146B7D1B0) ---
// local variable allocation has failed, the output may be wrong!
double __fastcall sub_146B7D1B0(__int64 a1, double a2)
{
  __int128 v2; // xmm6
  bool v3; // cf
  __int64 v5; // rbx
  float v6; // xmm6_4
  signed __int64 v7; // rdx
  signed __int64 v8; // rdx
  int v9; // esi
  unsigned __int32 v10; // eax
  __int128 v11; // kr00_16
  int v14; // eax
  unsigned __int32 v15; // eax
  double result; // xmm0_8
  int n0xF00; // [rsp+30h] [rbp-68h] BYREF
  __int64 v18; // [rsp+34h] [rbp-64h]
  int v19; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v20; // [rsp+40h] [rbp-58h]
  unsigned __int64 v21; // [rsp+48h] [rbp-50h]
  __int64 v22; // [rsp+50h] [rbp-48h]
  __int64 v23; // [rsp+58h] [rbp-40h]
  __int128 v24; // [rsp+80h] [rbp-18h]

  v3 = *(_BYTE *)(a1 + 0xD) < 5u;
  v5 = *(_QWORD *)(a1 + 0x330);
  v24 = v2;
  v6 = *(float *)&a2;
  if ( v3 )
  {
    n0xF00 = 0xF00;
    v19 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v18 = 1;
    v20 = __rdtsc();
    isProfileFunctionsInitialized(
      &n0xF00,
      &word_1515B1BFC,
      "CEntity::UpdateAggregateRadius_OnEntityCompleteRadiusChanged",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\Entity_AggregateRadius.cpp",
      0x1C8);
    HIWORD(n0xF00) = word_1515B1BFC;
    if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149AC4C0C;
    }
    else
    {
      v7 = _InterlockedIncrement64(&qword_149AC4BF8);
      if ( (v7 & 0x200000) != 0 )
        sub_1403CB300(
          (__int64)&qword_149AC4BF8,
          v7,
          "CEntity::UpdateAggregateRadius_OnEntityCompleteRadiusChanged",
          "s_aggregateHierarchyLock",
          1);
    }
    if ( dword_149AC4BF0 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149AC4BF4;
    }
    else
    {
      v8 = _InterlockedIncrement64(&qword_149AC4BE0);
      if ( (v8 & 0x200000) != 0 )
        sub_1403CB300(
          (__int64)&qword_149AC4BE0,
          v8,
          "CEntity::UpdateAggregateRadius_OnEntityCompleteRadiusChanged",
          "CEntityAggregateRadius::s_aggregateRadiusHierarchyLock",
          1);
    }
    v9 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v5 + 0x10) == v9 )
    {
      ++*(_DWORD *)(v5 + 0x14);
    }
    else
    {
      v10 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 1, 0);
      if ( v10 )
        sub_1403C33A0(v5, v10, "CEntity::UpdateAggregateRadius_OnEntityCompleteRadiusChanged", 1);
      else
        *(_QWORD *)(v5 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v5 + 0x10) = v9;
    }
    *((double *)&v11 + 1) = *(&a2 + 1);
    *(double *)&v11 = *(float *)&a2 * *(double *)(v5 + 0xA0);
    _XMM1 = v11;
    __asm { vminsd  xmm1, xmm1, cs:qword_1481B6B30 }
    *(float *)(v5 + 0x98) = v6;
    if ( (unsigned __int8)sub_146B7BC70(a1, *(double *)&_XMM1, 0xFFFFFFFE) )
      sub_146B5FDF0(a1);
    v14 = *(_DWORD *)(v5 + 0x14);
    if ( v14 )
    {
      *(_DWORD *)(v5 + 0x14) = v14 - 1;
    }
    else
    {
      *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
      v15 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 0, 1);
      if ( v15 == 1 )
        *(_QWORD *)(v5 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DB1F0(v5, v15);
    }
    sub_1402D2790((__int64)&qword_149AC4BE0);
    sub_1402D2790((__int64)&qword_149AC4BF8);
    v21 = __rdtsc();
    return qword_149B4B878(&n0xF00);
  }
  return result;
}

// --- End Function: sub_146B7D1B0 (0x146B7D1B0) ---

// --- Function: sub_146B7DE00 (0x146B7DE00) ---
double __fastcall sub_146B7DE00(__int64 a1, float a2)
{
  __int128 v2; // xmm6
  bool v3; // cf
  __int64 v5; // rbx
  signed __int64 v6; // rdx
  signed __int64 v7; // rdx
  int v8; // esi
  unsigned __int32 v9; // eax
  double v10; // kr00_8
  int v11; // eax
  unsigned __int32 v12; // eax
  double result; // xmm0_8
  int n0xF00; // [rsp+30h] [rbp-68h] BYREF
  __int64 v15; // [rsp+34h] [rbp-64h]
  int v16; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v17; // [rsp+40h] [rbp-58h]
  unsigned __int64 v18; // [rsp+48h] [rbp-50h]
  __int64 v19; // [rsp+50h] [rbp-48h]
  __int64 v20; // [rsp+58h] [rbp-40h]
  __int128 v21; // [rsp+80h] [rbp-18h]

  v3 = *(_BYTE *)(a1 + 0xD) < 5u;
  v5 = *(_QWORD *)(a1 + 0x330);
  v21 = v2;
  if ( v3 )
  {
    n0xF00 = 0xF00;
    v16 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v15 = 1;
    v17 = __rdtsc();
    isProfileFunctionsInitialized(
      &n0xF00,
      &word_1515B1BF8,
      "CEntity::UpdateAggregateRadius_OnEntityRenderingRadiusChanged",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\Entity_AggregateRadius.cpp",
      0x1AD);
    HIWORD(n0xF00) = word_1515B1BF8;
    if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149AC4C0C;
    }
    else
    {
      v6 = _InterlockedIncrement64(&qword_149AC4BF8);
      if ( (v6 & 0x200000) != 0 )
        sub_1403CB300(
          (__int64)&qword_149AC4BF8,
          v6,
          "CEntity::UpdateAggregateRadius_OnEntityRenderingRadiusChanged",
          "s_aggregateHierarchyLock",
          1);
    }
    if ( dword_149AC4BF0 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149AC4BF4;
    }
    else
    {
      v7 = _InterlockedIncrement64(&qword_149AC4BE0);
      if ( (v7 & 0x200000) != 0 )
        sub_1403CB300(
          (__int64)&qword_149AC4BE0,
          v7,
          "CEntity::UpdateAggregateRadius_OnEntityRenderingRadiusChanged",
          "CEntityAggregateRadius::s_aggregateRadiusHierarchyLock",
          1);
    }
    v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v5 + 0x10) == v8 )
    {
      ++*(_DWORD *)(v5 + 0x14);
    }
    else
    {
      v9 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 1, 0);
      if ( v9 )
        sub_1403C33A0(v5, v9, "CEntity::UpdateAggregateRadius_OnEntityRenderingRadiusChanged", 1);
      else
        *(_QWORD *)(v5 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v5 + 0x10) = v8;
    }
    v10 = a2 * *(double *)(v5 + 0xA0);
    *(float *)(v5 + 0x9C) = a2;
    if ( (unsigned __int8)sub_146B7BDA0(a1, v10, 0xFFFFFFFE) )
      sub_146B60DD0(a1);
    v11 = *(_DWORD *)(v5 + 0x14);
    if ( v11 )
    {
      *(_DWORD *)(v5 + 0x14) = v11 - 1;
    }
    else
    {
      *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
      v12 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 0, 1);
      if ( v12 == 1 )
        *(_QWORD *)(v5 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DB1F0(v5, v12);
    }
    sub_1402D2790((__int64)&qword_149AC4BE0);
    sub_1402D2790((__int64)&qword_149AC4BF8);
    v18 = __rdtsc();
    return qword_149B4B878(&n0xF00);
  }
  return result;
}

// --- End Function: sub_146B7DE00 (0x146B7DE00) ---

// --- Function: sub_146B83A40 (0x146B83A40) ---
double __fastcall sub_146B83A40(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm6
  _QWORD *v4; // rsi
  _QWORD *v6; // rbx
  float i; // xmm6_4
  float v8; // xmm0_4
  __int64 v9; // rcx
  double v10; // xmm0_8
  __int64 v11; // rax
  double v12; // xmm1_8
  double v14[6]; // [rsp+20h] [rbp-58h] BYREF
  __int128 v15; // [rsp+50h] [rbp-28h]

  v15 = v2;
  *(_WORD *)(a1 + 0x124) = 0xFFFF;
  v4 = *(_QWORD **)(a1 + 0x248);
  v6 = *(_QWORD **)(a1 + 0x240);
  for ( i = 0.0; v6 != v4; ++v6 )
  {
    v8 = (*(float (__fastcall **)(__int64))(*(_QWORD *)(*v6 & 0xFFFFFFFFFFFFLL) + 0x38LL))(*v6 & 0xFFFFFFFFFFFFLL);
    if ( v8 > i )
    {
      i = v8;
      *(_WORD *)(a1 + 0x124) = *(_WORD *)((*v6 & 0xFFFFFFFFFFFFLL) + 0x10);
    }
  }
  v9 = *(unsigned __int16 *)(a1 + 0x2EC);
  v10 = i;
  if ( (_WORD)v9 != 0xFFFF )
    *(double *)(*(_QWORD *)(0xC0LL * *(unsigned int *)((*(_QWORD *)(a1 + 0x320) & 0xFFFFFFFFFFFFLL) + 0x2F0)
                          + *(_QWORD *)(qword_1515B1A08 + 0x120)
                          + 8)
              + 0x38 * v9
              + 0x10) = i;
  *(float *)(a1 + 0x120) = i;
  v11 = *(_QWORD *)qword_149B4FBE8;
  if ( COERCE_FLOAT(LODWORD(i) ^ 0x80000000) <= i )
  {
    v12 = COERCE_FLOAT(LODWORD(i) ^ 0x80000000);
  }
  else
  {
    v12 = 1.0e150;
    v10 = -1.0e150;
  }
  v14[0] = v12;
  v14[1] = v12;
  v14[2] = v12;
  v14[3] = v10;
  v14[4] = v10;
  v14[5] = v10;
  (*(void (__fastcall **)(__int64, __int64, double *, __int64))(v11 + 0x378))(qword_149B4FBE8, a1 + 0x2A8, v14, a2);
  return sub_146B7D1B0(a1, COERCE_DOUBLE((unsigned __int64)*(_DWORD *)(a1 + 0x120)));
}

// --- End Function: sub_146B83A40 (0x146B83A40) ---

// --- Function: sub_146B83BB0 (0x146B83BB0) ---
__int64 __fastcall sub_146B83BB0(__int64 a1, float a2)
{
  __int64 v2; // r9
  __int64 n0xFFFF; // rax

  v2 = *(unsigned __int16 *)(a1 + 0x2EC);
  n0xFFFF = 0xFFFF;
  if ( (_WORD)v2 != 0xFFFF )
  {
    n0xFFFF = *(_QWORD *)(0xC0LL * *(unsigned int *)((*(_QWORD *)(a1 + 0x320) & 0xFFFFFFFFFFFFLL) + 0x2F0)
                        + *(_QWORD *)(qword_1515B1A08 + 0x120)
                        + 8);
    *(double *)(n0xFFFF + 0x38 * v2 + 8) = a2;
  }
  return n0xFFFF;
}

// --- End Function: sub_146B83BB0 (0x146B83BB0) ---

// --- Function: sub_146B83C10 (0x146B83C10) ---
double __fastcall sub_146B83C10(__int64 a1, _WORD *a2, __int64 a3, char a4)
{
  double result; // xmm0_8
  __int128 v5; // xmm6
  double v10; // xmm0_8
  bool v11; // cf
  __int64 v12; // rcx
  __int64 v13; // rbx
  __int16 v14; // bx
  __int64 v15; // rax
  _WORD *v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rax
  float v19; // xmm6_4
  float v20; // xmm0_4
  float v21; // xmm0_4
  float v22; // xmm1_4
  __int16 v23; // r9
  __int64 v24; // rcx
  double v25; // xmm1_8
  __int64 v26; // rax
  double v27; // xmm0_8
  double v28[6]; // [rsp+38h] [rbp-59h] BYREF
  _DWORD v29[2]; // [rsp+68h] [rbp-29h] BYREF
  __int64 v30; // [rsp+70h] [rbp-21h]
  unsigned __int64 v31; // [rsp+78h] [rbp-19h]
  unsigned __int64 v32; // [rsp+80h] [rbp-11h]
  __int64 v33; // [rsp+88h] [rbp-9h]
  __int64 v34; // [rsp+90h] [rbp-1h]
  _QWORD v35[3]; // [rsp+B0h] [rbp+1Fh]

  if ( *(_BYTE *)(a1 + 0xD) < 5u )
  {
    v30 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v29[0] = 0x1000;
    v31 = __rdtsc();
    v29[1] = *(_DWORD *)(a1 + 0x2D8);
    v10 = isProfileFunctionsInitialized(
            v29,
            &word_1515B1BE0,
            "CEntity::UpdateEntityRadius_OnComponentChange",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\Entity.cpp",
            0x1659);
    v11 = *(_BYTE *)(a1 + 0xD) < 4u;
    HIWORD(v29[0]) = word_1515B1BE0;
    if ( !v11 )
    {
      v12 = *(unsigned int *)((*(_QWORD *)(a1 + 0x320) & 0xFFFFFFFFFFFFLL) + 0x2F0);
      if ( (_DWORD)v12 != 0xFFFFFFFF && a2[0x31] != 0xFFFF )
      {
        v13 = *(_QWORD *)(0xC0 * v12 + *(_QWORD *)(qword_1515B1A08 + 0x120)) + 0x20LL * (unsigned __int16)a2[0x31];
        *(float *)&v10 = (*(float (__fastcall **)(_WORD *))(*(_QWORD *)a2 + 0x38LL))(a2);
        *(float *)(v13 + 8) = *(float *)&v10;
      }
    }
    if ( !a4 )
      goto LABEL_29;
    v14 = a2[8];
    *(_OWORD *)&v35[1] = v5;
    v15 = sub_146B11580((__int64)a2);
    v16 = a2;
    if ( !v15 )
    {
      v17 = sub_146B11430((__int64)a2);
      if ( v17 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x588LL))(v17);
        goto LABEL_14;
      }
      v18 = sub_146B11510((__int64)a2);
      v16 = a2;
      if ( !v18 )
      {
        if ( !sub_146B114A0((__int64)a2) )
        {
LABEL_19:
          v21 = (*(float (__fastcall **)(_WORD *))(*(_QWORD *)a2 + 0x38LL))(a2);
          v22 = *(float *)(a1 + 0x120);
          v23 = a2[8];
          if ( v21 <= v22 )
          {
            if ( *(_WORD *)(a1 + 0x124) == v23 && v21 < v22 )
              sub_146B83A40(a1, a3);
          }
          else
          {
            v24 = *(unsigned __int16 *)(a1 + 0x2EC);
            v25 = v21;
            if ( (_WORD)v24 != 0xFFFF )
              *(double *)(*(_QWORD *)(0xC0LL * *(unsigned int *)((*(_QWORD *)(a1 + 0x320) & 0xFFFFFFFFFFFFLL) + 0x2F0)
                                    + *(_QWORD *)(qword_1515B1A08 + 0x120)
                                    + 8)
                        + 0x38 * v24
                        + 0x10) = v21;
            *(float *)(a1 + 0x120) = v21;
            *(_WORD *)(a1 + 0x124) = v23;
            v26 = *(_QWORD *)qword_149B4FBE8;
            if ( COERCE_FLOAT(LODWORD(v21) ^ 0x80000000) <= v21 )
            {
              v27 = COERCE_FLOAT(LODWORD(v21) ^ 0x80000000);
            }
            else
            {
              v27 = 1.0e150;
              v25 = -1.0e150;
            }
            v28[0] = v27;
            v28[1] = v27;
            v28[2] = v27;
            v28[3] = v25;
            v28[4] = v25;
            v28[5] = v25;
            (*(void (__fastcall **)(__int64, __int64, double *, _QWORD))(v26 + 0x378))(
              qword_149B4FBE8,
              a1 + 0x2A8,
              v28,
              0);
            sub_146B7D1B0(a1, COERCE_DOUBLE((unsigned __int64)*(_DWORD *)(a1 + 0x120)));
          }
LABEL_29:
          v32 = __rdtsc();
          return qword_149B4B878(v29);
        }
        v16 = a2;
      }
    }
    v10 = (*(double (__fastcall **)(_WORD *))(*(_QWORD *)a2 + 0x38LL))(v16);
LABEL_14:
    v19 = *(float *)&v10;
    v20 = *(float *)(a1 + 0x11C);
    if ( v19 <= v20 )
    {
      if ( *(_WORD *)(a1 + 0x126) == v14 && v19 < v20 )
        sub_146B83F60(a1);
    }
    else
    {
      sub_146B83BB0(a1, v19);
      *(_WORD *)(a1 + 0x126) = v14;
      *(float *)(a1 + 0x11C) = v19;
      sub_146B7DE00(a1, v19);
    }
    goto LABEL_19;
  }
  return result;
}

// --- End Function: sub_146B83C10 (0x146B83C10) ---

// --- Function: sub_146B83F60 (0x146B83F60) ---
double __fastcall sub_146B83F60(__int64 a1)
{
  float v1; // xmm0_4
  __int128 v2; // xmm6
  _QWORD *v4; // rdi
  _QWORD *v5; // r14
  float v6; // xmm6_4
  __int64 v7; // rsi
  __int64 (__fastcall *v8)(__int64, __int16 *); // rbx
  __int16 n0xFFFF; // ax
  char v10; // al
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 *v13; // rcx
  unsigned __int8 (__fastcall *v14)(__int64, __int16 *); // rsi
  __int16 n0xFFFF_2; // ax
  __int64 v16; // rbx
  __int64 (__fastcall *v17)(__int64, __int16 *); // rsi
  __int16 n0xFFFF_4; // ax
  char v19; // al
  __int64 v20; // rcx
  _BYTE v22[2]; // [rsp+20h] [rbp-68h] BYREF
  _BYTE v23[14]; // [rsp+22h] [rbp-66h] BYREF
  __int128 v24; // [rsp+30h] [rbp-58h]
  __int16 n0xFFFF_1; // [rsp+90h] [rbp+8h] BYREF
  __int16 n0xFFFF_3; // [rsp+98h] [rbp+10h] BYREF
  __int16 n0xFFFF_5; // [rsp+A0h] [rbp+18h] BYREF
  char v28; // [rsp+A8h] [rbp+20h] BYREF

  v24 = v2;
  *(_WORD *)(a1 + 0x126) = 0xFFFF;
  v4 = *(_QWORD **)(a1 + 0x240);
  v5 = *(_QWORD **)(a1 + 0x248);
  v6 = 0.0;
  if ( v4 != v5 )
  {
    while ( 1 )
    {
      v7 = *v4 & 0xFFFFFFFFFFFFLL;
      v8 = *(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)v7 + 8LL);
      n0xFFFF = n0xFFFF_37;
      if ( n0xFFFF_37 == (__int16)0xFFFF )
      {
        n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                     + 0x10LL))(
                              pEngineComponentScheduler,
                              &v28,
                              "RenderProxy");
        n0xFFFF_37 = n0xFFFF;
      }
      n0xFFFF_1 = n0xFFFF;
      v10 = v8(v7, &n0xFFFF_1);
      v11 = *v4 & 0xFFFFFFFFFFFFLL;
      if ( !v10 )
        v7 = 0;
      v12 = *(_QWORD *)v11;
      if ( v7 )
      {
        v13 = (__int64 *)(*v4 & 0xFFFFFFFFFFFFLL);
        goto LABEL_22;
      }
      v14 = *(unsigned __int8 (__fastcall **)(__int64, __int16 *))(v12 + 8);
      n0xFFFF_2 = n0xFFFF_33;
      if ( n0xFFFF_33 == (__int16)0xFFFF )
      {
        n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                        + 0x10LL))(
                                pEngineComponentScheduler,
                                v22,
                                "IEntityComponentObjectContainer");
        n0xFFFF_33 = n0xFFFF_2;
      }
      n0xFFFF_3 = n0xFFFF_2;
      if ( !v14(v11, &n0xFFFF_3) )
        v11 = 0;
      if ( v11 )
        break;
      v16 = *v4 & 0xFFFFFFFFFFFFLL;
      v17 = *(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)v16 + 8LL);
      n0xFFFF_4 = n0xFFFF_49;
      if ( n0xFFFF_49 == (__int16)0xFFFF )
      {
        n0xFFFF_4 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                        + 0x10LL))(
                                pEngineComponentScheduler,
                                v23,
                                "IEntityComponentUIRenderToTexture");
        n0xFFFF_49 = n0xFFFF_4;
      }
      n0xFFFF_5 = n0xFFFF_4;
      v19 = v17(v16, &n0xFFFF_5);
      v13 = (__int64 *)(*v4 & 0xFFFFFFFFFFFFLL);
      if ( !v19 )
        v16 = 0;
      if ( v16 )
        goto LABEL_21;
      if ( sub_146B114A0((__int64)v13) )
      {
        v13 = (__int64 *)(*v4 & 0xFFFFFFFFFFFFLL);
LABEL_21:
        v12 = *v13;
LABEL_22:
        v1 = (*(float (__fastcall **)(__int64 *))(v12 + 0x38))(v13);
LABEL_23:
        if ( v1 > v6 )
        {
          v6 = v1;
          *(_WORD *)(a1 + 0x126) = *(_WORD *)((*v4 & 0xFFFFFFFFFFFFLL) + 0x10);
          *(float *)(a1 + 0x11C) = v1;
        }
      }
      if ( ++v4 == v5 )
        goto LABEL_26;
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x588LL))(v11);
    goto LABEL_23;
  }
LABEL_26:
  v20 = *(unsigned __int16 *)(a1 + 0x2EC);
  if ( (_WORD)v20 != 0xFFFF )
    *(double *)(*(_QWORD *)(0xC0LL * *(unsigned int *)((*(_QWORD *)(a1 + 0x320) & 0xFFFFFFFFFFFFLL) + 0x2F0)
                          + *(_QWORD *)(qword_1515B1A08 + 0x120)
                          + 8)
              + 0x38 * v20
              + 8) = v6;
  return sub_146B7DE00(a1, v6);
}

// --- End Function: sub_146B83F60 (0x146B83F60) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: powf (0x14808223F) ---
// attributes: thunk
float __cdecl powf(float X, float Y)
{
  return __imp_powf(X, Y);
}

// --- End Function: powf (0x14808223F) ---

