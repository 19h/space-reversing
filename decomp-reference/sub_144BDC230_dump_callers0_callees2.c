// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x144BDC230 (sub_144BDC230)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 69
// ------------------------------------------------------------

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: allocWithoutProfiling (0x1402A1E30) ---
__int64 __fastcall allocWithoutProfiling(unsigned __int64 size)
{
  return allocWithProfilerInfo(size, 0);
}

// --- End Function: allocWithoutProfiling (0x1402A1E30) ---

// --- Function: sub_1402A4BA0 (0x1402A4BA0) ---
char *__fastcall sub_1402A4BA0(__int64 *a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  _QWORD *v12; // rsi
  void *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  char *v16; // rbp
  size_t Size; // r8
  _BYTE *ptr_to_free; // rcx
  char *result; // rax

  v4 = (__int64)&a2[-*a1] >> 3;
  v5 = 0x1FFFFFFFFFFFFFFFLL;
  v6 = (a1[1] - *a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v9 = (a1[2] - *a1) >> 3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    v5 = v11 + v9;
    if ( v11 + v9 < v10 )
    {
      v5 = v6 + 1;
    }
  }
  v12 = (_QWORD *)sub_1402DFE40((__int64)a1, v5);
  v12[v4] = *a3;
  v13 = v12;
  v14 = (_BYTE *)a1[1];
  v15 = (_BYTE *)*a1;
  v16 = (char *)&v12[v4];
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = v16 + 8;
    Size = a1[1] - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  ptr_to_free = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)ptr_to_free) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)&ptr_to_free[-*((_QWORD *)ptr_to_free - 1) - 8] > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      ptr_to_free = (_BYTE *)*((_QWORD *)ptr_to_free - 1);
    }
    free_memory_wrapper(ptr_to_free);
  }
  *a1 = (__int64)v12;
  result = v16;
  a1[1] = (__int64)&v12[v10];
  a1[2] = (__int64)&v12[v5];
  return result;
}

// --- End Function: sub_1402A4BA0 (0x1402A4BA0) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1402C7FC0 (0x1402C7FC0) ---
__int64 __fastcall sub_1402C7FC0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
    {
      break;
    }
    v4 = 0;
    if ( (int)result < 0 )
    {
      v4 = a1;
    }
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402C7FC0 (0x1402C7FC0) ---

// --- Function: sub_1402D09F0 (0x1402D09F0) ---
__int64 __fastcall sub_1402D09F0(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
    {
      break;
    }
    ++a4;
    if ( (a1 & 1) != 0 )
    {
      a3 |= 1 << (a2 - v4);
    }
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D09F0 (0x1402D09F0) ---

// --- Function: sub_1402DE890 (0x1402DE890) ---
__int64 __fastcall sub_1402DE890(__int64 **a1, __int64 a2, __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 24) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
    {
      *v4 = a3;
    }
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
    {
      v4[2] = a3;
    }
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 24LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 24) )
      {
        v13 = *(_QWORD **)(v9 + 16);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 16) = *v13;
          if ( !*(_BYTE *)(*v13 + 25LL) )
          {
            *(_QWORD *)(*v13 + 8LL) = v9;
          }
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
            {
              *v14 = v13;
            }
            else
            {
              v14[2] = v13;
            }
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 16LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 25) )
        {
          *(_QWORD *)(v17 + 8) = v15;
        }
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
          {
            v18[2] = v16;
          }
          else
          {
            *v18 = v16;
          }
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 24) )
      {
        v19 = *(_QWORD *)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = *(_QWORD *)(v19 + 16);
          v20 = *(_QWORD *)(v19 + 16);
          if ( !*(_BYTE *)(v20 + 25) )
          {
            *(_QWORD *)(v20 + 8) = v9;
          }
          *(_QWORD *)(v19 + 8) = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(__int64 **)(v9 + 8);
            if ( v9 == v21[2] )
            {
              v21[2] = v19;
            }
            else
            {
              *v21 = v19;
            }
          }
          *(_QWORD *)(v19 + 16) = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 25LL) )
        {
          *(_QWORD *)(*v16 + 8LL) = v15;
        }
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
          {
            *v22 = v16;
          }
          else
          {
            v22[2] = v16;
          }
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v11 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 24) = 1;
  return a3;
}

// --- End Function: sub_1402DE890 (0x1402DE890) ---

// --- Function: unknown_libname_7 (0x1402DEE80) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402DEE80) ---

// --- Function: unknown_libname_10 (0x1402DFC60) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402DFC60) ---

// --- Function: sub_1402DFCB0 (0x1402DFCB0) ---
__int64 __fastcall sub_1402DFCB0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
    {
      break;
    }
    v5 = v4 + 32;
    if ( (unsigned __int8)(v4 - 65) > 0x19u )
    {
      v5 = v4;
    }
    v6 = sub_1402D09F0(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402C7FC0(79764919, 1, (v6 << 25) ^ (unsigned int)((unsigned __int64)(v6 << 24) >> 31) & 0x4C11DB7);
    v8 = sub_1402D09F0(v7 >> 1, 32, v7 << 31, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402DFCB0 (0x1402DFCB0) ---

// --- Function: sub_1402DFE40 (0x1402DFE40) ---
unsigned __int64 __fastcall sub_1402DFE40(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 size; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  unsigned __int64 result; // rax

  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_10;
  }
  size = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( size )
    {
      return allocWithoutProfiling(size);
    }
    else
    {
      return 0;
    }
  }
  if ( size + 39 < size )
  {
LABEL_10:
    sub_1402DEE40();
  }
  v3 = allocWithoutProfiling(size + 39);
  v4 = v3;
  if ( !v3 )
  {
    invalid_parameter_noinfo_noreturn();
  }
  result = (v3 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(result - 8) = v4;
  return result;
}

// --- End Function: sub_1402DFE40 (0x1402DFE40) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !qword_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !qword_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 ptr_to_free_29,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 v13; // r13
  char result; // al
  __int64 *ptr_to_free_15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  __int64 v18; // r15
  _QWORD *ptr_to_free_25; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  __int64 *ptr_to_free_16; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 ptr_to_free_17; // rcx
  _QWORD *v25; // rbx
  _BYTE *v26; // rdx
  _BYTE *v27; // rdx
  __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *ptr_to_free_20; // r14
  __int64 *p_ptr_to_free_1; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  __int64 ptr_to_free_18; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *ptr_to_free_1; // r15
  _QWORD **v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *ptr_to_free; // rcx
  __m256 *ptr_to_free_10; // rax
  __int64 *ptr_to_free_21; // rax
  __int64 *ptr_to_free_22; // r14
  __int64 ptr_to_free_23; // rcx
  _QWORD *v61; // rbx
  _BYTE *v62; // rdx
  _BYTE *v63; // rdx
  __int64 v64; // r10
  __int64 v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 ptr_to_free_11; // rax
  const void *ptr_to_free_3; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  Stream *Stream; // rax
  int n2; // r8d
  Stream *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 ptr_to_free_12; // rax
  const void *ptr_to_free_2; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  Stream *Stream_2; // rax
  Stream *Stream_3; // rax
  const void **ptr_to_free_7; // rsi
  _QWORD **v104; // rcx
  _QWORD *ptr_to_free_5; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *ptr_to_free_6; // rdi
  _QWORD *ptr_to_free_4; // rcx
  __int64 *ptr_to_free_9; // rbx
  _QWORD *ptr_to_free_8; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  __int64 *ptr_to_free_14; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  __int64 v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *ptr_to_free_28; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 ptr_to_free_26; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *ptr_to_free_27; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  _QWORD *ptr_to_free_19; // [rsp+128h] [rbp+88h] BYREF
  __int64 *p_p_ptr_to_free; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *ptr_to_free_24; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **ptr_to_free_13; // [rsp+158h] [rbp+B8h] BYREF
  __int64 v136; // [rsp+160h] [rbp+C0h]
  __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  ptr_to_free_28 = (_QWORD *)ptr_to_free_29;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v13 = a6;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, ptr_to_free_29, a6);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  ptr_to_free_13 = 0;
  ptr_to_free_15 = 0;
  p_p_ptr_to_free = (__int64 *)&ptr_to_free_13;
  n0x400 = 0;
  ptr_to_free_14 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !a6 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  ptr_to_free_25 = ptr_to_free_28;
  v20 = v112;
  ptr_to_free_27 = ptr_to_free_28;
  while ( 2 )
  {
    v21 = *((_BYTE *)ptr_to_free_25 + 89) == 0;
    ptr_to_free_24 = ptr_to_free_25;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = ptr_to_free_25;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    ptr_to_free_26 = (unsigned __int64)ptr_to_free_25;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = ptr_to_free_25;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !ptr_to_free_15 )
      {
        __asm { vzeroupper }
        ptr_to_free_14 = (__int64 *)allocWithoutProfiling(0x18u);
        ptr_to_free_15 = ptr_to_free_14;
        if ( ptr_to_free_14 )
        {
          ptr_to_free_16 = ptr_to_free_14;
          *ptr_to_free_14 = 0;
          n0x400_1 = 0;
          ptr_to_free_15[1] = 0;
          ptr_to_free_17 = (__int64)ptr_to_free_15;
          ptr_to_free_15[2] = 0;
        }
        else
        {
          ptr_to_free_15 = 0;
          ptr_to_free_16 = 0;
          n0x400_1 = 0;
          ptr_to_free_14 = 0;
          ptr_to_free_17 = 0;
        }
        sub_140302260(ptr_to_free_17, v13);
        v25 = v141;
        do
        {
          v26 = (_BYTE *)ptr_to_free_16[1];
          if ( v26 == (_BYTE *)ptr_to_free_16[2] )
          {
            sub_1402A47D0(ptr_to_free_15, v26, v25);
          }
          else
          {
            *(_QWORD *)v26 = *v25;
            ptr_to_free_16[1] += 8;
          }
          ++n0x400_1;
          ++v25;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        ptr_to_free_25 = ptr_to_free_27;
      }
      v27 = (_BYTE *)ptr_to_free_15[1];
      if ( v27 == (_BYTE *)ptr_to_free_15[2] )
      {
        __asm { vzeroupper }
        sub_1402A47D0(ptr_to_free_15, v27, &ptr_to_free_26);
      }
      else
      {
        *(_QWORD *)v27 = ptr_to_free_25;
        ptr_to_free_15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    ptr_to_free_25[1] = sub_1402FD110(&p_p_ptr_to_free, (__int64)ptr_to_free_25);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64))ptr_to_free_25[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    ptr_to_free_26 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*ptr_to_free_25, &v124, &ptr_to_free_26, v28);
    ptr_to_free_20 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    p_ptr_to_free_1 = p_p_ptr_to_free;
    do
    {
      ptr_to_free_24 = ptr_to_free_20;
      ptr_to_free_20[10] = v18;
      v21 = ptr_to_free_20[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)ptr_to_free_20[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*p_ptr_to_free_1 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)allocWithoutProfiling(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)allocWithoutProfiling(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *p_ptr_to_free_1 = (__int64)v33;
        }
        v35 = (_BYTE *)ptr_to_free_20[1];
        Size_2 = -1;
        memset(&v138, 0, sizeof(v138));
        Size_1 = -1;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)ptr_to_free_20[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        ptr_to_free_18 = *p_ptr_to_free_1;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        ptr_to_free_1 = *(__m256 **)v138.m256_f32;
        ptr_to_free_19 = (_QWORD *)ptr_to_free_18;
        v45 = *(_QWORD ***)ptr_to_free_18;
        v46 = **(_QWORD ***)ptr_to_free_18;
        if ( v46 == *(_QWORD **)ptr_to_free_18 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = ptr_to_free_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        ptr_to_free_18 = (__int64)ptr_to_free_19;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *(_QWORD *)(ptr_to_free_18 + 8) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = allocWithoutProfiling(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 32) = 0;
          *(_QWORD *)(v51 + 40) = 0;
          *(__m256 *)(v51 + 16) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*(_QWORD *)(ptr_to_free_18 + 8);
          v53 = v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = (_QWORD *)v51;
          *v53 = v51;
          v54 = *(_QWORD *)*p_ptr_to_free_1;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 40LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            ptr_to_free = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              ptr_to_free = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)ptr_to_free - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(ptr_to_free);
          }
          ptr_to_free_15 = ptr_to_free_14;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            ptr_to_free_10 = ptr_to_free_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              ptr_to_free_1 = *(__m256 **)&ptr_to_free_1[-1].m256_f32[6];
              if ( (unsigned __int64)((char *)ptr_to_free_10 - (char *)ptr_to_free_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(ptr_to_free_1);
          }
          ptr_to_free_15 = ptr_to_free_14;
          n0x400_2 = 0;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
        }
      }
      ptr_to_free_20[1] = v55;
      n0x400 = n0xF;
      ptr_to_free_19 = ptr_to_free_20;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !ptr_to_free_15 )
        {
          __asm { vzeroupper }
          ptr_to_free_21 = (__int64 *)allocWithoutProfiling(0x18u);
          ptr_to_free_15 = ptr_to_free_21;
          ptr_to_free_14 = ptr_to_free_21;
          if ( ptr_to_free_21 )
          {
            *ptr_to_free_21 = 0;
            ptr_to_free_22 = ptr_to_free_21;
            ptr_to_free_21[1] = 0;
            ptr_to_free_23 = (__int64)ptr_to_free_21;
            ptr_to_free_21[2] = 0;
          }
          else
          {
            ptr_to_free_15 = 0;
            ptr_to_free_14 = 0;
            ptr_to_free_22 = 0;
            ptr_to_free_23 = 0;
          }
          sub_140302260(ptr_to_free_23, a6);
          v61 = v141;
          do
          {
            v62 = (_BYTE *)ptr_to_free_22[1];
            if ( v62 == (_BYTE *)ptr_to_free_22[2] )
            {
              sub_1402A47D0(ptr_to_free_15, v62, v61);
            }
            else
            {
              *(_QWORD *)v62 = *v61;
              ptr_to_free_22[1] += 8;
            }
            ++n0x400_2;
            ++v61;
          }
          while ( n0x400_2 < 0x400 );
          ptr_to_free_20 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        v63 = (_BYTE *)ptr_to_free_15[1];
        if ( v63 == (_BYTE *)ptr_to_free_15[2] )
        {
          __asm { vzeroupper }
          sub_1402A47D0(ptr_to_free_15, v63, &ptr_to_free_19);
        }
        else
        {
          *(_QWORD *)v63 = ptr_to_free_20;
          ptr_to_free_15[1] += 8;
        }
      }
      else
      {
        v141[n0xF] = ptr_to_free_20;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      ptr_to_free_20 += 13;
      a13 = v30;
      *(_QWORD *)v116 = ptr_to_free_20;
    }
    while ( v30 < v124 );
    ptr_to_free_25 = ptr_to_free_27;
LABEL_94:
    v28 = v137;
    v13 = a6;
    if ( ptr_to_free_26 > 1 )
    {
      v28 = -1;
    }
    v64 = ptr_to_free_26 + v117;
    v117 += ptr_to_free_26;
LABEL_98:
    ptr_to_free_25 += 13;
    ptr_to_free_27 = ptr_to_free_25;
    ptr_to_free_24[10] = v28;
    if ( ++v132 < v13 )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  v117 = v64;
  if ( !ptr_to_free_15 )
  {
    goto LABEL_106;
  }
  if ( !((ptr_to_free_15[1] - *ptr_to_free_15) >> 3) )
  {
    __debugbreak();
  }
  i = (char *)*ptr_to_free_15;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 80LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 80LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 80) = -(__int64)(*(_QWORD *)(v71 + 80) != -1);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (v65 + 1) << 10;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    ptr_to_free_3 = 0;
  }
  else
  {
    ptr_to_free_11 = allocWithoutProfiling(Size);
    ptr_to_free_3 = (const void *)ptr_to_free_11;
    if ( ptr_to_free_11 )
    {
      Buffer_1 = (char *)ptr_to_free_11;
      goto LABEL_131;
    }
  }
  v79 = Size + 15;
  if ( Size + 15 < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && qword_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, ptr_to_free_28, a6, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            ptr_to_free_28,
            a6,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    sub_1402F5120(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    sub_1402F5120(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((n0xF + 2 * v117 + v117 + 32) << 7);
    }
    n0x8000_2 = v93 + 128;
    if ( *p_n0x8000_1 < v93 + 128 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      ptr_to_free_2 = 0;
    }
    else
    {
      ptr_to_free_12 = allocWithoutProfiling(n0x8000_2);
      ptr_to_free_2 = (const void *)ptr_to_free_12;
      if ( ptr_to_free_12 )
      {
        Buffer_2 = (double *)ptr_to_free_12;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 15;
    if ( n0x8000_2 + 15 < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      (__int64)ptr_to_free_28,
      a6,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 128,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(ptr_to_free_2);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  free_memory_wrapper(ptr_to_free_3);
  ptr_to_free_7 = ptr_to_free_13;
  if ( ptr_to_free_13 )
  {
    v104 = (_QWORD **)*ptr_to_free_13;
    **((_QWORD **)*ptr_to_free_13 + 1) = 0;
    ptr_to_free_5 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = ptr_to_free_5[5];
        ptr_to_free_6 = (_QWORD *)*ptr_to_free_5;
        if ( n0xF_2 > 0xF )
        {
          ptr_to_free_4 = (_QWORD *)ptr_to_free_5[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)ptr_to_free_4 - *(ptr_to_free_4 - 1) - 8 > 0x1F )
            {
              goto LABEL_191;
            }
            ptr_to_free_4 = (_QWORD *)*(ptr_to_free_4 - 1);
          }
          free_memory_wrapper(ptr_to_free_4);
        }
        ptr_to_free_5[4] = 0;
        ptr_to_free_5[5] = 15;
        *((_BYTE *)ptr_to_free_5 + 16) = 0;
        free_memory_wrapper(ptr_to_free_5);
        ptr_to_free_5 = ptr_to_free_6;
      }
      while ( ptr_to_free_6 );
    }
    free_memory_wrapper(*ptr_to_free_7);
    free_memory_wrapper(ptr_to_free_7);
  }
  ptr_to_free_9 = ptr_to_free_14;
  if ( ptr_to_free_14 )
  {
    ptr_to_free_8 = (_QWORD *)*ptr_to_free_14;
    if ( *ptr_to_free_14 )
    {
      if ( ((ptr_to_free_14[2] - (_QWORD)ptr_to_free_8) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)ptr_to_free_8 - *(ptr_to_free_8 - 1) - 8 > 0x1F )
        {
LABEL_191:
          invalid_parameter_noinfo_noreturn();
        }
        ptr_to_free_8 = (_QWORD *)*(ptr_to_free_8 - 1);
      }
      free_memory_wrapper(ptr_to_free_8);
      *ptr_to_free_9 = 0;
      ptr_to_free_9[1] = 0;
      ptr_to_free_9[2] = 0;
    }
    free_memory_wrapper(ptr_to_free_9);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: is_valid_handle_typeA (0x14030C820) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *packed_handle_ptr)
{
  __int64 packed_handle_value; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 metadata_type; // cx

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_metadata_ptr = get_handle_metadata_ptr(packed_handle_value & 0xFFFFFFFFFFFFLL);
  metadata_type = *(_WORD *)(handle_metadata_ptr + 4);
  if ( metadata_type == 4 || *(_WORD *)(handle_metadata_ptr + 2) != (HIWORD(packed_handle_value) & 0xFFF) )
  {
    return 0;
  }
  if ( metadata_type != 2 || *(_QWORD *)get_tls_data_offset_784() )
  {
    return check_handle_access_by_state(packed_handle_ptr) != 0;
  }
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030C820) ---

// --- Function: sub_14034F0C0 (0x14034F0C0) ---
char __fastcall sub_14034F0C0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        _QWORD *arg48)
{
  __int64 a8; // [rsp+18h] [rbp-E8h]
  __int64 a5[11]; // [rsp+30h] [rbp-D0h] BYREF
  __int16 n256; // [rsp+88h] [rbp-78h]
  __int64 n176; // [rsp+90h] [rbp-70h]
  _QWORD *v15; // [rsp+98h] [rbp-68h]
  uint64_t **p_EntityId; // [rsp+A0h] [rbp-60h]
  __int64 v17; // [rsp+A8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6A60)(__int64, __int64, __int64); // [rsp+B0h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E6420)(__int64, _BYTE *, unsigned __int64); // [rsp+B8h] [rbp-48h]
  __int64 v20; // [rsp+C0h] [rbp-40h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+C8h] [rbp-38h]
  __int64 v22; // [rsp+D0h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+D8h] [rbp-28h]
  __int64 (__fastcall *p_sub_1403E00D0)(__int64); // [rsp+E0h] [rbp-20h]
  __int64 v25; // [rsp+E8h] [rbp-18h]
  char v26; // [rsp+F0h] [rbp-10h]
  char v27; // [rsp+F1h] [rbp-Fh]
  __int64 n24; // [rsp+F8h] [rbp-8h]

  a5[0] = arg40;
  n256 = 256;
  a5[1] = (__int64)"TraceContext";
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)sub_1403E02C0;
  a5[9] = (__int64)sub_1403DFFB0;
  v15 = arg48;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  a5[10] = -1;
  n176 = 176;
  p_EntityId = "EntityId";
  v27 = 1;
  v17 = *arg48;
  p_sub_1403E6A60 = sub_1403E6A60;
  p_sub_1403E6420 = sub_1403E6420;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w;
  p_sub_1403E00D0 = sub_1403E00D0;
  LODWORD(a8) = a6;
  v20 = 0;
  v22 = 0;
  v25 = -1;
  v26 = 0;
  n24 = 24;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 2, a7, a8, a9, a10);
}

// --- End Function: sub_14034F0C0 (0x14034F0C0) ---

// --- Function: sub_140366CD0 (0x140366CD0) ---
_QWORD *__fastcall sub_140366CD0(_QWORD *a1, __int64 a2)
{
  *a1 = off_147F3F7D8;
  a1[1] = off_147F3F7A8;
  a1[2] = 0;
  a1[2] = *(_QWORD *)(a2 + 8);
  return a1;
}

// --- End Function: sub_140366CD0 (0x140366CD0) ---

// --- Function: sub_140366D50 (0x140366D50) ---
_QWORD *__fastcall sub_140366D50(_QWORD *a1)
{
  *a1 = off_147F3F7D8;
  a1[1] = off_147F3F7A8;
  a1[2] = 0;
  return a1;
}

// --- End Function: sub_140366D50 (0x140366D50) ---

// --- Function: sub_140369E00 (0x140369E00) ---
_QWORD *__fastcall sub_140369E00(_QWORD *a1, __int64 a2)
{
  a1[1] = a2;
  *a1 = off_147F3F7A8;
  return a1;
}

// --- End Function: sub_140369E00 (0x140369E00) ---

// --- Function: sub_14038E0B0 (0x14038E0B0) ---
__int64 __fastcall sub_14038E0B0(__int64 a1, unsigned __int64 n0x6400000)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403AF4C0();
  n0x40 = (n0x6400000 >> 8) + ((_BYTE)n0x6400000 != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
    {
      goto LABEL_7;
    }
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 64LL;
      if ( n0x4000 >= 0x4000 )
      {
        goto LABEL_2;
      }
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
      {
        n0x40_1 = -1;
      }
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
        {
          goto LABEL_2;
        }
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; n0x4000_2 + 64 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL); v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = -1 )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 64LL;
    }
    if ( n0x4000_2 < n0x4000 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 64)) - 1;
    }
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056A090((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056A0D0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_140569F50((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(n0x6400000, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_14038E0B0 (0x14038E0B0) ---

// --- Function: sub_14039EFB0 (0x14039EFB0) ---
void __fastcall sub_14039EFB0(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403AF4C0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 32) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; v7 + 64 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 40) = 0 )
    {
      v11 = v7;
      v7 += 64LL;
    }
    if ( v7 < v8 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~((1LL << ((__int64)v8 % 64)) - 1);
    }
  }
  else
  {
    sub_14739AF10(a2);
  }
}

// --- End Function: sub_14039EFB0 (0x14039EFB0) ---

// --- Function: sub_1403A8520 (0x1403A8520) ---
unsigned __int64 *__fastcall sub_1403A8520(__int64 a1, unsigned __int64 *a2)
{
  __int64 v4; // rax
  unsigned __int64 v5; // r9
  unsigned __int64 *result; // rax
  char v7; // [rsp+30h] [rbp+8h] BYREF

  v7 = 0;
  v4 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)global_validator_object + 296LL))(
         global_validator_object,
         a1,
         &v7);
  v5 = *(unsigned __int16 *)(v4 + 2) | (unsigned __int64)(v7 != 0 ? 0x2000 : 0);
  result = a2;
  *a2 = a1 | (v5 << 48);
  return result;
}

// --- End Function: sub_1403A8520 (0x1403A8520) ---

// --- Function: sub_1403AF4C0 (0x1403AF4C0) ---
__int64 sub_1403AF4C0()
{
  __int64 v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  result = *(_QWORD *)v0;
  if ( !*(_QWORD *)v0 )
  {
    v2 = (_QWORD *)allocWithoutProfiling(0x828u);
    if ( v2 )
    {
      v2[3] = &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)v0 = v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 192);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 192) = v6 | 1;
      _tlregdtor((__int64)sub_147E51590);
    }
    return *(_QWORD *)v0;
  }
  return result;
}

// --- End Function: sub_1403AF4C0 (0x1403AF4C0) ---

// --- Function: sub_1403BF290 (0x1403BF290) ---
__int64 __fastcall sub_1403BF290(volatile signed __int32 *a1, unsigned __int32 a2, __int64 a3, char a4)
{
  __int64 result; // rax
  char v7; // r14
  signed __int32 v8; // ecx
  bool v9; // zf
  unsigned __int32 v10; // esi
  signed __int32 v11; // eax
  unsigned __int32 v12; // [rsp+30h] [rbp-69h] BYREF
  unsigned __int32 v13[3]; // [rsp+34h] [rbp-65h] BYREF
  int n5632; // [rsp+40h] [rbp-59h] BYREF
  __int64 v15; // [rsp+44h] [rbp-55h]
  int v16; // [rsp+4Ch] [rbp-4Dh]
  __int64 v17; // [rsp+50h] [rbp-49h]
  unsigned __int64 v18; // [rsp+58h] [rbp-41h]
  __int64 v19; // [rsp+60h] [rbp-39h]
  __int64 v20; // [rsp+68h] [rbp-31h]
  int n5632_1; // [rsp+90h] [rbp-9h] BYREF
  __int64 v22; // [rsp+94h] [rbp-5h]
  int v23; // [rsp+9Ch] [rbp+3h]
  __int64 v24; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v25; // [rsp+A8h] [rbp+Fh]
  __int64 v26; // [rsp+B0h] [rbp+17h]
  __int64 v27; // [rsp+B8h] [rbp+1Fh]

  if ( a4 && *(_BYTE *)(get_tls_data_offset_784() + 28) && qword_14981D3D8 )
  {
    return sub_1403BF450(a1, a2);
  }
  v7 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v7 )
      {
        n5632 = 5632;
        v15 = 0;
        v16 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v17 = 1;
        qword_149818EA0(
          &n5632,
          0,
          &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          0);
        v12 = a2;
        qword_149808B88(a1, &v12, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        v18 = __rdtsc();
        qword_149818EA8(&n5632);
      }
      else
      {
        v10 = a2 + 2;
        v11 = _InterlockedCompareExchange(a1, a2 + 2, a2);
        v9 = a2 == v11;
        a2 = v11;
        if ( v9 )
        {
          n5632_1 = 5632;
          v22 = 0;
          v23 = 0;
          v25 = 0;
          v7 = 1;
          v26 = 0;
          v27 = 0;
          v24 = 1;
          qword_149818EA0(
            &n5632_1,
            0,
            &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          v13[0] = v10;
          qword_149808B88(a1, v13, 4, 0xFFFFFFFFLL);
          a2 = *a1;
          v25 = __rdtsc();
          qword_149818EA8(&n5632_1);
        }
      }
    }
    v8 = (a2 | 1) - 2;
    if ( !v7 )
    {
      v8 = a2 | 1;
    }
    result = (unsigned int)_InterlockedCompareExchange(a1, v8, a2);
    v9 = a2 == (_DWORD)result;
    a2 = result;
  }
  while ( !v9 );
  return result;
}

// --- End Function: sub_1403BF290 (0x1403BF290) ---

// --- Function: sub_1403D6A80 (0x1403D6A80) ---
__int64 __fastcall sub_1403D6A80(volatile signed __int32 *a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  __int64 result; // rax
  int v7; // [rsp+50h] [rbp+8h] BYREF
  int v8; // [rsp+58h] [rbp+10h] BYREF
  __int64 v9; // [rsp+60h] [rbp+18h] BYREF
  __int64 v10; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 248LL))(
        qword_14981D318,
        &v9,
        &v8);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(192 * (((unsigned __int64)a2 >> 16) & (unsigned int)(v8 - 1)) + v9 + 36);
      if ( v5 != -1 )
      {
        v4 = (v5 << 16) | (unsigned __int16)v4;
      }
    }
    result = (unsigned int)_InterlockedCompareExchange(a1, v4, a2);
    if ( a2 == (_DWORD)result )
    {
      break;
    }
    a2 = result;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    return qword_149808B90(a1);
  }
  if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 248LL))(qword_14981D318, &v10, &v7);
    *(_DWORD *)(192 * (HIWORD(a2) & (unsigned __int64)(unsigned int)(v7 - 1)) + v10 + 28) = (unsigned __int16)(HIWORD(a2) + v7);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D318 + 216LL))(qword_14981D318);
  }
  return result;
}

// --- End Function: sub_1403D6A80 (0x1403D6A80) ---

// --- Function: allocWithoutProfiling_w (0x1403DFFB0) ---
__int64 sub_1403DFFB0()
{
  return allocWithoutProfiling(1u);
}

// --- End Function: allocWithoutProfiling_w (0x1403DFFB0) ---

// --- Function: sub_1403DFFC0 (0x1403DFFC0) ---
_OWORD *__fastcall sub_1403DFFC0(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)allocWithoutProfiling(0x10u);
  if ( result )
  {
    *result = *a1;
  }
  return result;
}

// --- End Function: sub_1403DFFC0 (0x1403DFFC0) ---

// --- Function: sub_1403E00D0 (0x1403E00D0) ---
__int64 __fastcall sub_1403E00D0(__int64 a1)
{
  __int64 result; // rax

  result = allocWithoutProfiling(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 16) = *(double *)(a1 + 16);
  }
  return result;
}

// --- End Function: sub_1403E00D0 (0x1403E00D0) ---

// --- Function: free_memory_wrapper_w_1 (0x1403E02C0) ---
void __fastcall sub_1403E02C0(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w_1 (0x1403E02C0) ---

// --- Function: free_memory_wrapper_w_2 (0x1403E02D0) ---
void __fastcall sub_1403E02D0(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w_2 (0x1403E02D0) ---

// --- Function: free_memory_wrapper_w (0x1403E0310) ---
void __fastcall free_memory_wrapper_w(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w (0x1403E0310) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---

// --- Function: sub_1403E2C50 (0x1403E2C50) ---
char __fastcall sub_1403E2C50(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1403E2C50 (0x1403E2C50) ---

// --- Function: sub_1403E6420 (0x1403E6420) ---
__int64 __fastcall sub_1403E6420(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 16) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 34;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      v6 = sub_1403570D0((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FC400((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
  {
    return 0xFFFFFFFFLL;
  }
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
  {
    return 0xFFFFFFFFLL;
  }
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 34;
    }
    else
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403E6420 (0x1403E6420) ---

// --- Function: sub_1403E65D0 (0x1403E65D0) ---
__int64 __fastcall sub_1403E65D0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1403570D0(a2, a3, 0, *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1403E65D0 (0x1403E65D0) ---

// --- Function: sub_1403E6700 (0x1403E6700) ---
__int64 __fastcall sub_1403E6700(__int64 a1, __int64 a2, unsigned __int64 n12)
{
  int v3; // edi
  int n12_1; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12_1 = 0;
  if ( (int)n12 > 0 )
  {
    if ( n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 = 12;
      if ( (int)n12 <= 12 )
      {
        goto LABEL_52;
      }
    }
    v8 = sub_1404EEAB0((unsigned __int8 *)a1, (_BYTE *)((unsigned int)n12_1 + a2), n12 - (unsigned int)n12_1);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v8;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12_1);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 19;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v10 = sub_1404EE450((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v10;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12_1;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v12 = sub_1404EE6A0((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12_1);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 18;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v14 = sub_1404EE300((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12_1 += v14;
    if ( n12_1 < (int)n12 )
    {
LABEL_46:
      if ( n12 - n12_1 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12_1);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12_1 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
  {
    return (unsigned int)-1;
  }
  return (unsigned int)n12_1;
}

// --- End Function: sub_1403E6700 (0x1403E6700) ---

// --- Function: sub_1403E6A60 (0x1403E6A60) ---
__int64 __fastcall sub_1403E6A60(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 16) )
  {
    return sub_1403570D0(a2, a3, 0, v3);
  }
  else
  {
    return sub_1402FC400(a2, a3, 0, v3);
  }
}

// --- End Function: sub_1403E6A60 (0x1403E6A60) ---

// --- Function: sub_1403E6C00 (0x1403E6C00) ---
// attributes: thunk
__int64 __fastcall sub_1403E6C00(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404EEAB0(a1, a2, n0x21);
}

// --- End Function: sub_1403E6C00 (0x1403E6C00) ---

// --- Function: sub_14043AD00 (0x14043AD00) ---
char __fastcall sub_14043AD00(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        __int64 arg48)
{
  __int64 a8; // [rsp+18h] [rbp-E8h]
  __int64 a5[11]; // [rsp+30h] [rbp-D0h] BYREF
  __int16 n256; // [rsp+88h] [rbp-78h]
  __int64 n176; // [rsp+90h] [rbp-70h]
  __int64 v15; // [rsp+98h] [rbp-68h]
  const char *p_Unnamed_Text; // [rsp+A0h] [rbp-60h]
  __int64 v17; // [rsp+A8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6970)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+B0h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E6380)(__int64, double *, unsigned __int64); // [rsp+B8h] [rbp-48h]
  __int64 v20; // [rsp+C0h] [rbp-40h]
  bool (__fastcall *p_sub_1403E2A50)(unsigned __int8 *, unsigned __int8 *); // [rsp+C8h] [rbp-38h]
  __int64 v22; // [rsp+D0h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+D8h] [rbp-28h]
  __int64 (*p_allocWithoutProfiling_w)(); // [rsp+E0h] [rbp-20h]
  __int64 v25; // [rsp+E8h] [rbp-18h]
  __int16 v26; // [rsp+F0h] [rbp-10h]
  __int64 n21; // [rsp+F8h] [rbp-8h]

  a5[0] = arg40;
  a5[1] = (__int64)"TraceContext";
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v15 = arg48;
  p_Unnamed_Text = "Unnamed_Text";
  p_sub_1403E6970 = sub_1403E6970;
  p_sub_1403E6380 = sub_1403E6380;
  p_sub_1403E2A50 = sub_1403E2A50;
  p_free_memory_wrapper_w = free_memory_wrapper_w_1;
  p_allocWithoutProfiling_w = allocWithoutProfiling_w;
  LODWORD(a8) = a6;
  n256 = 256;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  a5[10] = -1;
  n176 = 176;
  v26 = 0;
  v17 = 0;
  v20 = 0;
  v22 = 0;
  v25 = -1;
  n21 = 21;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 2, a7, a8, a9, a10);
}

// --- End Function: sub_14043AD00 (0x14043AD00) ---

// --- Function: sub_14048CA30 (0x14048CA30) ---
__int64 __fastcall sub_14048CA30(int a1, __int64 a2)
{
  int v3; // ebx
  int v4; // r9d
  int v5; // ebx
  unsigned __int64 *v6; // rax
  unsigned __int64 *v7; // rcx
  __int64 *p_arg40; // rcx
  unsigned __int64 n15; // rax
  __int64 v11; // rbx
  __int64 v12; // [rsp+28h] [rbp-58h]
  int *p_n209; // [rsp+50h] [rbp-30h] BYREF
  __int64 *v14; // [rsp+58h] [rbp-28h]
  __int128 v15; // [rsp+60h] [rbp-20h] BYREF
  __int64 v16; // [rsp+70h] [rbp-10h]
  __int64 v17; // [rsp+98h] [rbp+18h] BYREF
  int n209; // [rsp+A0h] [rbp+20h] BYREF
  int n138; // [rsp+A4h] [rbp+24h]
  __int64 v20; // [rsp+A8h] [rbp+28h] BYREF

  v17 = a2;
  v3 = a2;
  if ( is_valid_handle_typeA(&v17) )
  {
    v15 = 0u;
    v16 = 0;
    v11 = sub_14048CBB0(a1, v3, (unsigned int)&v15, v4);
    if ( *((_QWORD *)&v15 + 1) >= 2u )
    {
      (*((void (__fastcall **)(__int64, __int128 *))&v15 + 1))(2, &v15);
    }
    return v11;
  }
  else
  {
    if ( dword_1495F84E8 >= 1 )
    {
      n209 = 209;
      p_n209 = &n209;
      n138 = 138;
      v14 = &v20;
      v5 = invokeGlobalCallbackAndMaskStatusBits(
             3,
             (__int64)&p_n209,
             (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps",
             "$$ null");
      if ( (v5 & 0xFFFFF) != 0 )
      {
        v6 = sub_1404AE300();
        v7 = v6;
        if ( v6 )
        {
          n15 = *v6;
          if ( n15 > 0xF )
          {
            n15 = 15;
          }
          p_arg40 = (__int64 *)&v7[22 * n15 + 1];
        }
        else
        {
          p_arg40 = &arg40;
        }
        n209 = 209;
        p_n209 = &n209;
        n138 = 138;
        v14 = &v20;
        LODWORD(v12) = v5;
        v15 = 0;
        sub_14043AD00(
          3,
          (__int64)&p_n209,
          "IEntityComponentResourceContainer::AsyncGetResourceValueMaps",
          (__int64)"$$ null",
          1,
          v12,
          &v15,
          0,
          (__int64)p_arg40,
          (__int64)"Requesting Component");
      }
    }
    return 0;
  }
}

// --- End Function: sub_14048CA30 (0x14048CA30) ---

// --- Function: sub_14048CBB0 (0x14048CBB0) ---
__int64 __fastcall sub_14048CBB0(__int64 ***rcx0, __int64 a2, _QWORD *a3, __int64 a4, char a5)
{
  __int128 v5; // xmm6
  __int64 ***v6; // rdi
  _QWORD *v7; // r12
  __int64 ptr_to_free_15; // rax
  __int64 p_sub_14041A020_4; // rdx
  __int64 **v11; // rbx
  __int64 *j; // rbx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r13
  unsigned __int8 (__fastcall *v16)(__int64); // rdi
  __int16 v17; // di
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rdx
  int v21; // ebx
  unsigned __int64 *v22; // rax
  unsigned __int64 *v23; // rdx
  __int64 *p_arg40_2; // rcx
  __int64 v25; // r12
  int *v26; // rdi
  int *v27; // rax
  int v28; // edi
  int v29; // r15d
  __int64 v30; // r15
  unsigned __int8 (__fastcall *v31)(__int64, __int64, const char *); // rdi
  __int64 v32; // rax
  __int64 *v33; // rdi
  __int64 *v34; // r15
  __int128 *v35; // r10
  int v36; // edi
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 **v38; // rax
  __int64 *i; // rax
  __int64 *v40; // rcx
  signed __int64 v41; // r14
  __int64 v42; // r14
  _QWORD *ptr_to_free_6; // rbx
  _QWORD *ptr_to_free_7; // rcx
  __int64 global_validator_object; // rdi
  bool valid; // al
  __int64 v47; // rbx
  bool v48; // zf
  int event_key_from_source_location; // eax
  int v50; // ebx
  __int64 *ThreadLogContextSlot; // rax
  unsigned __int64 n15_2; // rax
  int v53; // ebx
  unsigned __int64 *v54; // rax
  unsigned __int64 *v55; // rdx
  __int64 *p_arg40_1; // rcx
  unsigned __int64 n15_1; // rax
  int v58; // ebx
  unsigned __int64 *v59; // rax
  unsigned __int64 *v60; // rdx
  __int64 *p_arg40; // rcx
  unsigned __int64 n15; // rax
  signed __int64 v63; // r14
  _QWORD *ptr_to_free_4; // rax
  _QWORD *v65; // rbx
  __int64 v66; // rdi
  __int64 v67; // rax
  void (__fastcall *v68)(__int64, __int128 *, __int64); // r15
  _QWORD *ptr_to_free_5; // rax
  __int64 (__fastcall *p_sub_14041A020_2)(); // rax
  __int64 v71; // rax
  __int64 v72; // rbx
  __int64 v73; // rax
  __int64 v74; // rbx
  __int64 v75; // rax
  unsigned __int64 v76; // rdx
  __int64 *n; // rbx
  _QWORD *ptr_to_free_9; // r8
  _BYTE *v79; // rdi
  __int64 *v80; // r12
  __int64 *k; // r13
  unsigned __int64 v82; // rax
  _QWORD *ptr_to_free_10; // rdx
  __int64 *ptr_to_free_11; // rcx
  __int64 v85; // r15
  __int128 v86; // xmm6
  __int64 v87; // rdx
  __int64 v88; // rcx
  __int64 v89; // rax
  __int128 ptr_to_free_17; // xmm0
  __int64 **v91; // rax
  __int64 *m; // rax
  __int64 *v93; // rcx
  __int64 ptr_to_free_12; // rax
  _QWORD *v95; // rdx
  __int64 (__fastcall *p_sub_14041A020_5)(); // rax
  __int64 v97; // rbx
  __int64 v98; // rax
  const void *ptr_to_free_1; // rcx
  const void *v100; // rdx
  _QWORD *v101; // rbx
  const void *v102; // rdx
  const void *ptr_to_free_3; // rcx
  const void **ptr_to_free_14; // rdi
  const void **ptr_to_free_2; // rbx
  __int64 v107; // [rsp+30h] [rbp-D8h]
  __int64 p_sub_14041A020_7; // [rsp+68h] [rbp-A0h] BYREF
  _QWORD *ptr_to_free_8; // [rsp+70h] [rbp-98h] BYREF
  __int64 (__fastcall *p_sub_14041A020_3)(); // [rsp+78h] [rbp-90h]
  __int128 ptr_to_free_13; // [rsp+80h] [rbp-88h] BYREF
  _BYTE *v112; // [rsp+90h] [rbp-78h]
  __int128 ptr_to_free_16; // [rsp+98h] [rbp-70h] BYREF
  __int64 v114; // [rsp+A8h] [rbp-60h]
  __int64 a1; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v116; // [rsp+C0h] [rbp-48h]
  __int64 *p_p_sub_14041A020_1; // [rsp+C8h] [rbp-40h] BYREF
  char *p_ptr_to_free; // [rsp+D0h] [rbp-38h]
  __int64 *p_p_sub_14041A020; // [rsp+D8h] [rbp-30h] BYREF
  char *p_ptr_to_free_1; // [rsp+E0h] [rbp-28h]
  _QWORD *v121; // [rsp+E8h] [rbp-20h] BYREF
  const void *v122; // [rsp+F0h] [rbp-18h]
  _QWORD *ptr_to_free; // [rsp+F8h] [rbp-10h] BYREF
  __int64 (__fastcall *p_sub_14041A020_1)(); // [rsp+100h] [rbp-8h]
  _QWORD *v125; // [rsp+118h] [rbp+10h] BYREF
  const void *v126; // [rsp+120h] [rbp+18h]
  __int64 n32; // [rsp+128h] [rbp+20h]
  __int64 (__fastcall *p_sub_14041A020)(); // [rsp+130h] [rbp+28h]
  _QWORD v129[3]; // [rsp+138h] [rbp+30h] BYREF
  char v130[2]; // [rsp+150h] [rbp+48h] BYREF
  char v131[6]; // [rsp+152h] [rbp+4Ah] BYREF
  _DWORD v132[2]; // [rsp+158h] [rbp+50h] BYREF
  _DWORD v133[2]; // [rsp+160h] [rbp+58h] BYREF
  __int64 v134; // [rsp+168h] [rbp+60h] BYREF
  __int128 v135; // [rsp+170h] [rbp+68h] BYREF
  __int64 v136; // [rsp+180h] [rbp+78h]
  __int64 v137; // [rsp+188h] [rbp+80h] BYREF
  _QWORD v138[2]; // [rsp+190h] [rbp+88h] BYREF
  _QWORD p_p_sub_14041A020_2[2]; // [rsp+1A0h] [rbp+98h] BYREF
  _BYTE v140[32]; // [rsp+1B0h] [rbp+A8h] BYREF
  _BYTE v141[24]; // [rsp+1D0h] [rbp+C8h] BYREF
  _QWORD v142[2]; // [rsp+1E8h] [rbp+E0h] BYREF
  __int64 (__fastcall *p_sub_14041A020_6)(); // [rsp+1F8h] [rbp+F0h]
  char v144[24]; // [rsp+200h] [rbp+F8h] BYREF
  _OWORD v145[6]; // [rsp+218h] [rbp+110h] BYREF
  __int64 v147; // [rsp+290h] [rbp+188h] BYREF
  _QWORD *v148; // [rsp+298h] [rbp+190h]
  __int64 v149; // [rsp+2A0h] [rbp+198h] BYREF

  v148 = a3;
  v147 = a2;
  v145[1] = v5;
  v6 = rcx0;
  p_sub_14041A020_3 = 0;
  v7 = a3;
  LOBYTE(v149) = 0;
  ptr_to_free_15 = allocWithoutProfiling(0x40u);
  p_sub_14041A020_4 = 0;
  p_sub_14041A020_7 = 0;
  *(_QWORD *)ptr_to_free_15 = ptr_to_free_15;
  *(_QWORD *)(ptr_to_free_15 + 8) = ptr_to_free_15;
  *(_QWORD *)(ptr_to_free_15 + 16) = ptr_to_free_15;
  *(_WORD *)(ptr_to_free_15 + 24) = 257;
  v11 = *v6;
  ptr_to_free_8 = (_QWORD *)ptr_to_free_15;
  j = *v11;
  if ( !*((_BYTE *)j + 25) )
  {
    do
    {
      v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)::global_validator_object + 192LL))(::global_validator_object);
      v145[0] = *((_OWORD *)j + 2);
      v14 = (*(__int64 (__fastcall **)(__int64, _OWORD *))(*(_QWORD *)v13 + 24LL))(v13, v145);
      v15 = v14;
      if ( !v14 )
      {
        if ( dword_1495F84E8 >= 1 )
        {
          v149 = 0x8A000000D1LL;
          p_p_sub_14041A020 = &v149;
          p_ptr_to_free_1 = &a5;
          v58 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)&p_p_sub_14041A020,
                  (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                  "[$$] Invalid entity class in resourceContainerEntries!");
          if ( (v58 & 0xFFFFF) != 0 )
          {
            v59 = sub_1404AE300();
            v60 = v59;
            if ( v59 )
            {
              n15 = *v59;
              if ( n15 > 0xF )
              {
                n15 = 15;
              }
              p_arg40 = (__int64 *)&v60[22 * n15 + 1];
            }
            else
            {
              p_arg40 = &arg40;
            }
            p_p_sub_14041A020_1 = &p_sub_14041A020_7;
            p_ptr_to_free = (char *)&ptr_to_free_8;
            p_sub_14041A020_7 = 0x8A000000D1LL;
            LODWORD(v107) = v58;
            ptr_to_free_16 = 0;
            sub_14043B360(
              3,
              (unsigned int)&p_p_sub_14041A020_1,
              (unsigned int)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
              (unsigned int)"[$$] Invalid entity class in resourceContainerEntries!",
              1,
              v107,
              &ptr_to_free_16,
              0,
              (__int64)p_arg40,
              (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl");
          }
        }
        goto LABEL_78;
      }
      v16 = *(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v14 + 88LL);
      if ( word_1495F9534 == -1 )
      {
        word_1495F9534 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                            + 16LL))(
                                     global_dispatcher_ptr,
                                     v130,
                                     "EntityComponentResourceContainer");
      }
      if ( !v16(v15) )
      {
        if ( dword_1495F84E8 >= 1 )
        {
          v149 = 0x8A000000D1LL;
          p_p_sub_14041A020 = &v149;
          p_ptr_to_free_1 = &a5;
          v53 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)&p_p_sub_14041A020,
                  (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                  "[$$] Entity class [$$] in resourceContainerEntries does not have the Resource Container Component!");
          if ( (v53 & 0xFFFFF) != 0 )
          {
            v54 = sub_1404AE300();
            v55 = v54;
            if ( v54 )
            {
              n15_1 = *v54;
              if ( n15_1 > 0xF )
              {
                n15_1 = 15;
              }
              p_arg40_1 = (__int64 *)&v55[22 * n15_1 + 1];
            }
            else
            {
              p_arg40_1 = &arg40;
            }
            p_p_sub_14041A020_1 = &p_sub_14041A020_7;
            p_ptr_to_free = (char *)&ptr_to_free_8;
            p_sub_14041A020_7 = 0x8A000000D1LL;
            LODWORD(v107) = v53;
            ptr_to_free_16 = 0;
            sub_14043B360(
              3,
              (unsigned int)&p_p_sub_14041A020_1,
              (unsigned int)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
              (unsigned int)"[$$] Entity class [$$] in resourceContainerEntries does not have the Resource Container Component!",
              1,
              v107,
              &ptr_to_free_16,
              0,
              (__int64)p_arg40_1,
              (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl");
          }
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 24LL))(v15);
        goto LABEL_78;
      }
      v17 = word_1495F9534;
      if ( word_1495F9534 == -1 )
      {
        v17 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                 + 16LL))(
                          global_dispatcher_ptr,
                          v131,
                          "EntityComponentResourceContainer");
        word_1495F9534 = v17;
      }
      v18 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 96LL))(v15);
      v19 = *v18;
      v20 = v18[1];
      if ( *v18 == v20 )
      {
        goto LABEL_11;
      }
      while ( *(_WORD *)v19 != v17 )
      {
        v19 += 32;
        if ( v19 == v20 )
        {
          goto LABEL_11;
        }
      }
      v25 = *(_QWORD *)(v19 + 8);
      if ( !v25 )
      {
        goto LABEL_11;
      }
      v26 = (int *)sub_1404F16E0(&v121);
      v27 = (int *)(*(__int64 (__fastcall **)(__int64, _QWORD **))(*(_QWORD *)v25 + 24LL))(v25, &v125);
      v28 = *v26;
      v29 = *v27;
      if ( v126 )
      {
        sub_14739AF10(v126);
      }
      if ( v122 )
      {
        sub_14739AF10(v122);
      }
      if ( v28 != v29 )
      {
        if ( !Parameter_3
          || !(*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3)
          || (v30 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
              v31 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v30 + 256LL),
              v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 8LL))(v25),
              !v31(v30, v32, "ResourceContainer")) )
        {
LABEL_11:
          if ( dword_1495F84E8 >= 1 )
          {
            v149 = 0x8A000000D1LL;
            p_p_sub_14041A020 = &v149;
            p_ptr_to_free_1 = &a5;
            v21 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)&p_p_sub_14041A020,
                    (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                    "[$$] Entity class [$$] in resourceContainerEntries does not have the Resource Container Params?!");
            if ( (v21 & 0xFFFFF) != 0 )
            {
              v134 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 24LL))(v15);
              v22 = sub_1404AE300();
              v23 = v22;
              if ( v22 )
              {
                n15_2 = *v22;
                if ( n15_2 > 0xF )
                {
                  n15_2 = 15;
                }
                p_arg40_2 = (__int64 *)&v23[22 * n15_2 + 1];
              }
              else
              {
                p_arg40_2 = &arg40;
              }
              p_sub_14041A020_7 = 0x8A000000D1LL;
              p_p_sub_14041A020_1 = &p_sub_14041A020_7;
              p_ptr_to_free = (char *)&ptr_to_free_8;
              LODWORD(v107) = v21;
              ptr_to_free_16 = 0;
              sub_14043B4D0(
                3,
                1,
                v107,
                &ptr_to_free_16,
                0,
                (__int64)p_arg40_2,
                (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                (__int64)&v134);
            }
          }
          goto LABEL_78;
        }
      }
      p_sub_14041A020_4 = ((j[7] - j[6]) >> 3) + p_sub_14041A020_7;
      p_sub_14041A020_7 = p_sub_14041A020_4;
      if ( *(_BYTE *)(v25 + 44) )
      {
        if ( !*(_QWORD *)(v25 + 264) )
        {
          if ( dword_1495F84E8 >= 1 )
          {
            v149 = 0x8A000000D1LL;
            p_p_sub_14041A020_1 = &v149;
            p_ptr_to_free = &a5;
            v50 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)&p_p_sub_14041A020_1,
                    (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                    "[$$] Resource Container component for entity class [$$] in resourceContainerEntries is marked immuta"
                    "ble but has no default composition!");
            if ( (v50 & 0xFFFFF) != 0 )
            {
              v134 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 24LL))(v15);
              ThreadLogContextSlot = getThreadLogContextSlot();
              p_sub_14041A020_7 = 0x8A000000D1LL;
              p_p_sub_14041A020 = &p_sub_14041A020_7;
              p_ptr_to_free_1 = (char *)&ptr_to_free_8;
              LODWORD(v107) = v50;
              ptr_to_free_16 = 0;
              sub_14043B4D0(
                3,
                1,
                v107,
                &ptr_to_free_16,
                0,
                (__int64)ThreadLogContextSlot,
                (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                (__int64)&v134);
            }
          }
          goto LABEL_78;
        }
        v136 = 0;
        v135 = 0;
        sub_1404FC9D0(&v135);
        sub_1404A9B80(v25, &v135);
        v33 = (__int64 *)j[6];
        v34 = (__int64 *)j[7];
        if ( v33 != v34 )
        {
          while ( 1 )
          {
            v137 = *v33;
            if ( !v137 )
            {
              break;
            }
            v35 = (__int128 *)sub_1402B2F30(&ptr_to_free_8, &v137);
            if ( v35 != &v135 )
            {
              sub_140429530(v35, v135, (*((_QWORD *)&v135 + 1) - (_QWORD)v135) / 24LL);
            }
            if ( ++v33 == v34 )
            {
              goto LABEL_36;
            }
          }
          if ( dword_1495F84E8 >= 1 )
          {
            v132[0] = 209;
            v138[0] = v132;
            v132[1] = 138;
            v138[1] = v133;
            v36 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)v138,
                    (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                    "[$$] Invalid entity id in resourceContainerEntries!");
            if ( (v36 & 0xFFFFF) != 0 )
            {
              ThreadLogContextSlot_1 = getThreadLogContextSlot();
              p_p_sub_14041A020_2[0] = v133;
              p_p_sub_14041A020_2[1] = &v134;
              LODWORD(v107) = v36;
              ptr_to_free_13 = 0;
              v133[0] = 209;
              v133[1] = 138;
              sub_14043B360(
                3,
                (unsigned int)p_p_sub_14041A020_2,
                (unsigned int)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl",
                (unsigned int)"[$$] Invalid entity id in resourceContainerEntries!",
                1,
                v107,
                &ptr_to_free_13,
                0,
                (__int64)ThreadLogContextSlot_1,
                (__int64)"IEntityComponentResourceContainer::AsyncGetResourceValueMaps_Impl");
            }
          }
          LOBYTE(v149) = 1;
        }
LABEL_36:
        sub_1402B0320((const void **)&v135);
        p_sub_14041A020_4 = p_sub_14041A020_7;
      }
      v38 = (__int64 **)j[2];
      if ( *((_BYTE *)v38 + 25) )
      {
        for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( j != (__int64 *)i[2] )
          {
            break;
          }
          j = i;
        }
        j = i;
      }
      else
      {
        v40 = *v38;
        for ( j = (__int64 *)j[2]; !*((_BYTE *)v40 + 25); v40 = (__int64 *)*v40 )
        {
          j = v40;
        }
      }
    }
    while ( !*((_BYTE *)j + 25) );
    if ( !(_BYTE)v149 )
    {
      v6 = rcx0;
      v7 = v148;
      goto LABEL_47;
    }
LABEL_78:
    v63 = _InterlockedExchangeAdd64(
            (volatile signed __int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D3E0 + 224LL))(qword_14981D3E0),
            1u);
    p_sub_14041A020_1 = 0;
    v42 = v63 + 1;
    ptr_to_free_4 = (_QWORD *)allocWithoutProfiling(0x40u);
    *ptr_to_free_4 = ptr_to_free_4;
    ptr_to_free_4[1] = ptr_to_free_4;
    ptr_to_free_4[2] = ptr_to_free_4;
    *((_WORD *)ptr_to_free_4 + 12) = 257;
    ptr_to_free = ptr_to_free_4;
    v121 = (_QWORD *)v42;
    LODWORD(v122) = 8;
    if ( !is_valid_handle_typeA(&v147) )
    {
      v65 = v148;
      if ( *v148 )
      {
        v66 = qword_14981D3E0;
        v67 = *(_QWORD *)qword_14981D3E0;
        p_sub_14041A020 = 0;
        v68 = *(void (__fastcall **)(__int64, __int128 *, __int64))(v67 + 232);
        v125 = v121;
        LODWORD(v126) = (_DWORD)v122;
        ptr_to_free_5 = (_QWORD *)allocWithoutProfiling(0x40u);
        *ptr_to_free_5 = ptr_to_free_5;
        ptr_to_free_5[1] = ptr_to_free_5;
        ptr_to_free_5[2] = ptr_to_free_5;
        *((_WORD *)ptr_to_free_5 + 12) = 257;
        n32 = (__int64)ptr_to_free;
        ptr_to_free = ptr_to_free_5;
        p_sub_14041A020_2 = p_sub_14041A020_1;
        p_sub_14041A020_1 = p_sub_14041A020;
        p_sub_14041A020 = p_sub_14041A020_2;
        sub_140357470(v129, v65);
        sub_14044FCA0(v140, &v125);
        sub_140357470(v141, v129);
        v71 = allocWithoutProfiling(0x38u);
        v72 = v71;
        if ( v71 )
        {
          sub_14044FCA0(v71, v140);
          sub_140357470(v72 + 32, v141);
          v112 = (_BYTE *)v72;
        }
        else
        {
          v112 = 0;
        }
        *(_QWORD *)&ptr_to_free_13 = sub_140492CF0;
        *((_QWORD *)&ptr_to_free_13 + 1) = sub_140494870;
        sub_14045B470(v140);
        sub_14045B470(&v125);
        goto LABEL_89;
      }
      goto LABEL_91;
    }
    goto LABEL_49;
  }
LABEL_47:
  if ( p_sub_14041A020_3 == (__int64 (__fastcall *)())p_sub_14041A020_4 )
  {
    v41 = _InterlockedExchangeAdd64(
            (volatile signed __int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D3E0 + 224LL))(qword_14981D3E0),
            1u);
    p_sub_14041A020_1 = 0;
    v42 = v41 + 1;
    ptr_to_free_6 = (_QWORD *)allocWithoutProfiling(0x40u);
    *ptr_to_free_6 = ptr_to_free_6;
    ptr_to_free_6[1] = ptr_to_free_6;
    ptr_to_free_6[2] = ptr_to_free_6;
    *((_WORD *)ptr_to_free_6 + 12) = 257;
    ptr_to_free = ptr_to_free_6;
    v121 = (_QWORD *)v42;
    LODWORD(v122) = 0;
    sub_1402A6040(&ptr_to_free, &ptr_to_free, ptr_to_free_6);
    ptr_to_free_6[1] = ptr_to_free_6;
    *ptr_to_free_6 = ptr_to_free_6;
    ptr_to_free_6[2] = ptr_to_free_6;
    ptr_to_free_7 = ptr_to_free;
    ptr_to_free = ptr_to_free_8;
    ptr_to_free_8 = ptr_to_free_7;
    p_sub_14041A020_1 = p_sub_14041A020_3;
    p_sub_14041A020_3 = 0;
    if ( !is_valid_handle_typeA(&v147) )
    {
      if ( *v7 )
      {
        v66 = qword_14981D3E0;
        v68 = *(void (__fastcall **)(__int64, __int128 *, __int64))(*(_QWORD *)qword_14981D3E0 + 232LL);
        sub_14044FCA0(&v125, &v121);
        sub_140357470(v129, v7);
        sub_14044FCA0(v140, &v125);
        sub_140357470(v141, v129);
        v73 = allocWithoutProfiling(0x38u);
        v74 = v73;
        if ( v73 )
        {
          sub_14044FCA0(v73, v140);
          sub_140357470(v74 + 32, v141);
          v112 = (_BYTE *)v74;
        }
        else
        {
          v112 = 0;
        }
        *(_QWORD *)&ptr_to_free_13 = sub_140492CF0;
        *((_QWORD *)&ptr_to_free_13 + 1) = sub_140494870;
        sub_14045B470(v140);
        sub_14045B470(&v125);
LABEL_89:
        v68(v66, &ptr_to_free_13, 1);
        if ( *((_QWORD *)&ptr_to_free_13 + 1) >= 2u )
        {
          (*((void (__fastcall **)(__int64, __int128 *))&ptr_to_free_13 + 1))(2, &ptr_to_free_13);
        }
      }
LABEL_91:
      sub_1402A6040(&ptr_to_free, &ptr_to_free, ptr_to_free[1]);
      free_memory_wrapper(ptr_to_free);
      goto LABEL_140;
    }
LABEL_49:
    global_validator_object = ::global_validator_object;
    valid = is_valid_handle_typeA(&v147);
    v47 = v147 & 0xFFFFFFFFFFFFLL;
    v48 = !valid;
    v125 = &v121;
    event_key_from_source_location = event_key_from_source_location_29;
    if ( v48 )
    {
      v47 = 0;
    }
    if ( !event_key_from_source_location_29 )
    {
      event_key_from_source_location = get_event_key_from_source_location(
                                         &event_key_from_source_location_29,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\ICIGCargoSystem/IEn"
                                                  "tityComponentResourceContainer.h",
                                         38);
    }
    LODWORD(v126) = event_key_from_source_location;
    n32 = 32;
    p_sub_14041A020 = sub_14041A020;
    v129[0] = sub_14041A080;
    (*(void (__fastcall **)(__int64, __int64, _QWORD **))(*(_QWORD *)global_validator_object + 856LL))(
      global_validator_object,
      v47,
      &v125);
    goto LABEL_91;
  }
  a1 = 0;
  v116 = 0;
  v75 = sub_14038E0B0((__int64)&a1, 0x38u);
  v112 = 0;
  ptr_to_free_13 = 0;
  *(_QWORD *)v75 = v75;
  *(_QWORD *)(v75 + 8) = v75;
  *(_QWORD *)(v75 + 16) = v75;
  *(_WORD *)(v75 + 24) = 257;
  v76 = (unsigned __int64)v6[1];
  a1 = v75;
  sub_1403E4B00((__int64)&ptr_to_free_13, v76);
  n = **v6;
  if ( !*((_BYTE *)n + 25) )
  {
    ptr_to_free_9 = ptr_to_free_8;
    v79 = (_BYTE *)*((_QWORD *)&ptr_to_free_13 + 1);
    do
    {
      v80 = (__int64 *)n[6];
      for ( k = (__int64 *)n[7]; v80 != k; ++v80 )
      {
        v82 = *v80;
        ptr_to_free_10 = ptr_to_free_9;
        v149 = *v80;
        ptr_to_free_11 = (__int64 *)ptr_to_free_9[1];
        while ( !*((_BYTE *)ptr_to_free_11 + 25) )
        {
          if ( ptr_to_free_11[4] >= v82 )
          {
            ptr_to_free_10 = ptr_to_free_11;
            ptr_to_free_11 = (__int64 *)*ptr_to_free_11;
          }
          else
          {
            ptr_to_free_11 = (__int64 *)ptr_to_free_11[2];
          }
        }
        if ( *((_BYTE *)ptr_to_free_10 + 25) || v82 < ptr_to_free_10[4] )
        {
          ptr_to_free_10 = ptr_to_free_9;
        }
        if ( ptr_to_free_10 == ptr_to_free_9 )
        {
          v85 = a1;
          v86 = *((_OWORD *)n + 2);
          DWORD2(ptr_to_free_16) = 0;
          v87 = a1;
          v88 = *(_QWORD *)(a1 + 8);
          *(_QWORD *)&ptr_to_free_16 = v88;
          while ( !*(_BYTE *)(v88 + 25) )
          {
            *(_QWORD *)&ptr_to_free_16 = v88;
            if ( *(_QWORD *)(v88 + 32) >= v82 )
            {
              v87 = v88;
              DWORD2(ptr_to_free_16) = 1;
              v88 = *(_QWORD *)v88;
            }
            else
            {
              v88 = *(_QWORD *)(v88 + 16);
              DWORD2(ptr_to_free_16) = 0;
            }
          }
          if ( *(_BYTE *)(v87 + 25) || v82 < *(_QWORD *)(v87 + 32) )
          {
            if ( v116 == 0x492492492492492LL )
            {
              unknown_libname_7();
            }
            v89 = sub_14038E0B0((__int64)&a1, 0x38u);
            *(_QWORD *)(v89 + 32) = v149;
            *(_OWORD *)(v89 + 40) = 0;
            ptr_to_free_17 = ptr_to_free_16;
            *(_QWORD *)v89 = v85;
            *(_QWORD *)(v89 + 8) = v85;
            *(_QWORD *)(v89 + 16) = v85;
            *(_WORD *)(v89 + 24) = 0;
            ptr_to_free_16 = ptr_to_free_17;
            v87 = sub_1402DE890((__int64 **)&a1, (__int64)&ptr_to_free_16, v89);
          }
          *(_OWORD *)(v87 + 40) = v86;
          if ( v79 == v112 )
          {
            sub_1402A4BA0((__int64 *)&ptr_to_free_13, v79, &v149);
            v79 = (_BYTE *)*((_QWORD *)&ptr_to_free_13 + 1);
          }
          else
          {
            *(_QWORD *)v79 = v149;
            v79 += 8;
            *((_QWORD *)&ptr_to_free_13 + 1) = v79;
          }
          ptr_to_free_9 = ptr_to_free_8;
        }
      }
      v91 = (__int64 **)n[2];
      if ( *((_BYTE *)v91 + 25) )
      {
        for ( m = (__int64 *)n[1]; !*((_BYTE *)m + 25); m = (__int64 *)m[1] )
        {
          if ( n != (__int64 *)m[2] )
          {
            break;
          }
          n = m;
        }
        n = m;
      }
      else
      {
        v93 = *v91;
        for ( n = (__int64 *)n[2]; !*((_BYTE *)v93 + 25); v93 = (__int64 *)*v93 )
        {
          n = v93;
        }
      }
    }
    while ( !*((_BYTE *)n + 25) );
  }
  v142[0] = a2;
  p_sub_14041A020_6 = 0;
  ptr_to_free_12 = allocWithoutProfiling(0x40u);
  v95 = v148;
  *(_QWORD *)ptr_to_free_12 = ptr_to_free_12;
  *(_QWORD *)(ptr_to_free_12 + 8) = ptr_to_free_12;
  *(_QWORD *)(ptr_to_free_12 + 16) = ptr_to_free_12;
  *(_WORD *)(ptr_to_free_12 + 24) = 257;
  v142[1] = ptr_to_free_8;
  ptr_to_free_8 = (_QWORD *)ptr_to_free_12;
  p_sub_14041A020_5 = p_sub_14041A020_3;
  p_sub_14041A020_3 = p_sub_14041A020_6;
  p_sub_14041A020_6 = p_sub_14041A020_5;
  sub_140357470(v144, v95);
  v97 = sub_14044A500(&v121, v142);
  v98 = allocWithoutProfiling(0x30u);
  if ( v98 )
  {
    v114 = sub_14044A500(v98, v97);
  }
  else
  {
    v114 = 0;
  }
  *(_QWORD *)&ptr_to_free_16 = sub_140492DA0;
  *((_QWORD *)&ptr_to_free_16 + 1) = sub_140494B30;
  sub_14045B4E0(v97);
  sub_14045B4E0(v142);
  v42 = sub_14048C2E0(&ptr_to_free_13, &a1, 0, &ptr_to_free_16);
  if ( *((_QWORD *)&ptr_to_free_16 + 1) >= 2u )
  {
    (*((void (__fastcall **)(__int64, __int128 *))&ptr_to_free_16 + 1))(2, &ptr_to_free_16);
    *((_QWORD *)&ptr_to_free_16 + 1) = 0;
  }
  ptr_to_free_1 = (const void *)ptr_to_free_13;
  *(_QWORD *)&ptr_to_free_16 = 0;
  if ( (_QWORD)ptr_to_free_13 )
  {
    if ( ((unsigned __int64)&v112[-ptr_to_free_13] & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      ptr_to_free_1 = *(const void **)(ptr_to_free_13 - 8);
      if ( (unsigned __int64)(ptr_to_free_13 - (_QWORD)ptr_to_free_1 - 8) > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
    }
    free_memory_wrapper(ptr_to_free_1);
  }
  v100 = (const void *)a1;
  v101 = *(_QWORD **)(a1 + 8);
  if ( !*((_BYTE *)v101 + 25) )
  {
    do
    {
      sub_1404313A0(&a1, &a1, v101[2]);
      v102 = v101;
      v101 = (_QWORD *)*v101;
      sub_14039EFB0((__int64)&a1, v102, 0x38u);
    }
    while ( !*((_BYTE *)v101 + 25) );
    v100 = (const void *)a1;
  }
  sub_14039EFB0((__int64)&a1, v100, 0x38u);
LABEL_140:
  ptr_to_free_3 = ptr_to_free_8;
  ptr_to_free_14 = (const void **)ptr_to_free_8[1];
  if ( !*((_BYTE *)ptr_to_free_14 + 25) )
  {
    do
    {
      sub_1402A6040(&ptr_to_free_8, &ptr_to_free_8, ptr_to_free_14[2]);
      ptr_to_free_2 = ptr_to_free_14;
      ptr_to_free_14 = (const void **)*ptr_to_free_14;
      sub_1402B0320(ptr_to_free_2 + 5);
      free_memory_wrapper(ptr_to_free_2);
    }
    while ( !*((_BYTE *)ptr_to_free_14 + 25) );
    ptr_to_free_3 = ptr_to_free_8;
  }
  free_memory_wrapper(ptr_to_free_3);
  return v42;
}

// --- End Function: sub_14048CBB0 (0x14048CBB0) ---

// --- Function: sub_1404AE300 (0x1404AE300) ---
_QWORD *sub_1404AE300()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  if ( !v0 )
  {
    sub_140535CF0((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithoutProfiling(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_147E52AF0);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404AE300 (0x1404AE300) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 15;
  }
  return (__int64 *)&tls_log_structure_1[22 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: sub_140569F50 (0x140569F50) ---
char __fastcall sub_140569F50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149818690;
  if ( !qword_149818690 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403DE270(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149818690 = (__int64)v3;
  }
  if ( v3(a2, a3, 4096, 4) )
  {
    return 1;
  }
  if ( GetLastError() == 1455 )
  {
    sub_14056A220();
  }
  return 0;
}

// --- End Function: sub_140569F50 (0x140569F50) ---

// --- Function: sub_14056A090 (0x14056A090) ---
__int64 __fastcall sub_14056A090(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 4096 )
      {
        return 4096;
      }
      if ( ++v1 == v2 )
      {
        return 4096;
      }
    }
  }
  return 4096;
}

// --- End Function: sub_14056A090 (0x14056A090) ---

// --- Function: sub_14056A0D0 (0x14056A0D0) ---
__int64 __fastcall sub_14056A0D0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149818690;
  if ( !qword_149818690 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403DE270(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149818690 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 16) = a6;
  *(_QWORD *)(a1 + 24) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 20) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056A0D0 (0x14056A0D0) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !Parameter_3 )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = -1;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[4095] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)Parameter_3 + 280LL))(
                      Parameter_3,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: sub_140B869A0 (0x140B869A0) ---
__int64 __fastcall sub_140B869A0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 n2; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "EntityId";
  *(_BYTE *)(a1 + 89) = 1;
  *(_QWORD *)(a1 + 16) = *a2;
  *(_QWORD *)(a1 + 24) = sub_1403E6A60;
  *(_QWORD *)(a1 + 32) = sub_1403E6420;
  *(_QWORD *)(a1 + 48) = std::error_category::operator==;
  *(_QWORD *)(a1 + 64) = free_memory_wrapper_w;
  *(_QWORD *)(a1 + 72) = sub_1403E00D0;
  *(_QWORD *)(a1 + 112) = "UInt";
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 80) = -1;
  *(_BYTE *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 24;
  *(_QWORD *)(a1 + 104) = a3;
  *(_BYTE *)(a1 + 193) = 0;
  *(_QWORD *)(a1 + 120) = *a3;
  *(_QWORD *)(a1 + 128) = sub_1403E65D0;
  *(_QWORD *)(a1 + 136) = sub_1403E65D0;
  *(_QWORD *)(a1 + 152) = std::error_category::operator==;
  *(_QWORD *)(a1 + 168) = free_memory_wrapper_w_2;
  *(_QWORD *)(a1 + 176) = sub_1403DFFC0;
  n2 = 2;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 184) = -1;
  *(_BYTE *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 16;
  return n2;
}

// --- End Function: sub_140B869A0 (0x140B869A0) ---

// --- Function: sub_140C45220 (0x140C45220) ---
char __fastcall sub_140C45220(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        _QWORD *arg48)
{
  __int64 a8; // [rsp+18h] [rbp-E8h]
  __int64 a5[11]; // [rsp+30h] [rbp-D0h] BYREF
  __int16 n256; // [rsp+88h] [rbp-78h]
  __int64 n176; // [rsp+90h] [rbp-70h]
  _QWORD *v15; // [rsp+98h] [rbp-68h]
  const char *p_UInt; // [rsp+A0h] [rbp-60h]
  __int64 v17; // [rsp+A8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E65D0)(__int64, __int64, __int64); // [rsp+B0h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E65D0_1)(__int64, __int64, __int64); // [rsp+B8h] [rbp-48h]
  __int64 v20; // [rsp+C0h] [rbp-40h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+C8h] [rbp-38h]
  __int64 v22; // [rsp+D0h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+D8h] [rbp-28h]
  _OWORD *(__fastcall *p_sub_1403DFFC0)(_OWORD *); // [rsp+E0h] [rbp-20h]
  __int64 v25; // [rsp+E8h] [rbp-18h]
  char v26; // [rsp+F0h] [rbp-10h]
  char v27; // [rsp+F1h] [rbp-Fh]
  __int64 n16; // [rsp+F8h] [rbp-8h]

  a5[0] = arg40;
  n256 = 256;
  a5[1] = (__int64)"TraceContext";
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v15 = arg48;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  a5[10] = -1;
  n176 = 176;
  p_UInt = "UInt";
  v27 = 0;
  v17 = *arg48;
  p_sub_1403E65D0 = sub_1403E65D0;
  p_sub_1403E65D0_1 = sub_1403E65D0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w_2;
  p_sub_1403DFFC0 = sub_1403DFFC0;
  LODWORD(a8) = a6;
  v20 = 0;
  v22 = 0;
  v25 = -1;
  v26 = 0;
  n16 = 16;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 2, a7, a8, a9, a10);
}

// --- End Function: sub_140C45220 (0x140C45220) ---

// --- Function: sub_1411CEB20 (0x1411CEB20) ---
void __fastcall sub_1411CEB20(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rdi
  _QWORD *v6; // rbx
  _QWORD *ptr_to_free; // rcx

  v3 = a3;
  while ( !*((_BYTE *)v3 + 25) )
  {
    sub_1411CEB20(a1, a2, v3[2]);
    v6 = v3;
    v3 = (__int64 *)*v3;
    ptr_to_free = (_QWORD *)v6[6];
    if ( ptr_to_free )
    {
      if ( ((v6[8] - (_QWORD)ptr_to_free) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)ptr_to_free - *(ptr_to_free - 1) - 8 > 0x1F )
        {
          invalid_parameter_noinfo_noreturn();
        }
        ptr_to_free = (_QWORD *)*(ptr_to_free - 1);
      }
      free_memory_wrapper(ptr_to_free);
      v6[6] = 0;
      v6[7] = 0;
      v6[8] = 0;
    }
    sub_14039EFB0(a2, v6, 0x48u);
  }
}

// --- End Function: sub_1411CEB20 (0x1411CEB20) ---

// --- Function: sub_1414F7CD0 (0x1414F7CD0) ---
__int64 __fastcall sub_1414F7CD0(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a1)(
           a2,
           *(_QWORD *)(a1 + 48),
           *(_QWORD *)(a1 + 40),
           *(_QWORD *)(a1 + 32),
           *(_QWORD *)(a1 + 24),
           *(_QWORD *)(a1 + 16),
           *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1414F7CD0 (0x1414F7CD0) ---

// --- Function: sub_1415CC1C0 (0x1415CC1C0) ---
char __fastcall sub_1415CC1C0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        __int64 arg48,
        __int64 a11)
{
  void *v15; // rsp
  __int64 a8; // [rsp+18h] [rbp-158h]
  __int64 a5[11]; // [rsp+30h] [rbp-140h] BYREF
  __int16 n256; // [rsp+88h] [rbp-E8h]
  __int64 n176; // [rsp+90h] [rbp-E0h]
  __int64 v21; // [rsp+98h] [rbp-D8h] BYREF

  v15 = alloca(320);
  a5[0] = arg40;
  a5[1] = (__int64)"TraceContext";
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  a5[9] = (__int64)allocWithoutProfiling_w;
  n256 = 256;
  a5[10] = -1;
  n176 = 176;
  sub_140352B40(&v21, arg48, a11);
  LODWORD(a8) = a6;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 3, a7, a8, a9, a10);
}

// --- End Function: sub_1415CC1C0 (0x1415CC1C0) ---

// --- Function: sub_141600300 (0x141600300) ---
__int64 __fastcall sub_141600300(__int64 a1, unsigned __int64 *a2)
{
  __int64 *v2; // rbx
  __int64 v5; // r8
  __int64 v6; // rax
  unsigned __int64 v7; // r9
  __int64 v8; // rax
  __int64 v10; // [rsp+20h] [rbp-28h] BYREF
  int v11; // [rsp+28h] [rbp-20h]

  v2 = *(__int64 **)a1;
  v11 = 0;
  v5 = (__int64)v2;
  v6 = v2[1];
  v10 = v6;
  if ( !*(_BYTE *)(v6 + 25) )
  {
    v7 = *a2;
    do
    {
      v10 = v6;
      if ( *(_QWORD *)(v6 + 32) >= v7 )
      {
        v5 = v6;
        v11 = 1;
        v6 = *(_QWORD *)v6;
      }
      else
      {
        v6 = *(_QWORD *)(v6 + 16);
        v11 = 0;
      }
    }
    while ( !*(_BYTE *)(v6 + 25) );
  }
  if ( *(_BYTE *)(v5 + 25) || *a2 < *(_QWORD *)(v5 + 32) )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x555555555555555LL )
    {
      unknown_libname_7();
    }
    v8 = allocWithoutProfiling(0x30u);
    *(_QWORD *)(v8 + 32) = *a2;
    *(_QWORD *)(v8 + 40) = 0;
    *(_QWORD *)v8 = v2;
    *(_QWORD *)(v8 + 8) = v2;
    *(_QWORD *)(v8 + 16) = v2;
    *(_WORD *)(v8 + 24) = 0;
    v5 = sub_1402DE890((__int64 **)a1, (__int64)&v10, v8);
  }
  return v5 + 40;
}

// --- End Function: sub_141600300 (0x141600300) ---

// --- Function: sub_142D7D670 (0x142D7D670) ---
__int64 __fastcall sub_142D7D670(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  __int64 v6; // rcx

  v1 = dword_149AD7014;
  if ( !dword_149AD7014 )
  {
    v3 = sub_1402D09F0(0x46u, 8, 0, 2);
    v4 = sub_1402C7FC0(79764919, 1, (v3 << 25) ^ (unsigned int)((unsigned __int64)(v3 << 24) >> 31) & 0x4C11DB7);
    v5 = sub_1402D09F0(v4 >> 1, 32, v4 << 31, 2);
    v1 = sub_1402DFCB0((unsigned __int8 *)"AmmoContainerComponentParams", v5 ^ 0xFFFFFFu);
    v6 = allocWithProfilerInfo(0x1Eu, 0);
    *(_OWORD *)v6 = *(_OWORD *)"SAmmoContainerComponentParams";
    *(double *)(v6 + 16) = *(double *)"mponentParams";
    strcpy((char *)(v6 + 24), "arams");
    dword_149AD7014 = v1;
    if ( v6 )
    {
      sub_14739AF10((const void *)v6);
      v1 = dword_149AD7014;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return a1;
}

// --- End Function: sub_142D7D670 (0x142D7D670) ---

// --- Function: sub_1449CF740 (0x1449CF740) ---
_BOOL8 __fastcall sub_1449CF740(__int64 a1, int *a2, int *a3, int *a4, int *a5, int *a6)
{
  int v6; // r10d
  unsigned __int64 v9; // r9
  bool v10; // cl
  char v11; // al
  bool v12; // dl
  bool v13; // al
  bool v14; // al
  int v15; // r8d
  unsigned __int64 v16; // r9
  bool v17; // cl
  char v18; // al
  bool v19; // dl
  bool v20; // al
  bool v21; // al
  int v22; // r8d
  unsigned __int64 v23; // r9
  bool v24; // cl
  char v25; // al
  bool v26; // dl
  bool v27; // al
  bool v28; // al
  unsigned __int64 v29; // r9
  int v30; // r8d
  bool v31; // cl
  char v32; // al
  bool v33; // dl
  bool v34; // al
  bool v35; // al
  unsigned __int64 v36; // r9
  int v37; // r8d
  bool v38; // cl
  char v39; // al
  BOOL v40; // edx
  bool v41; // al
  _BOOL8 result; // rax

  v6 = *a2;
  v9 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v10 = 0;
    v9 += 8LL;
    v11 = v6;
    v6 >>= 7;
    v12 = (v11 & 0x40) != 0;
    v13 = (v11 & 0x40) == 0;
    if ( v6 )
    {
      v10 = v13;
    }
    v14 = 0;
    if ( v6 != -1 )
    {
      v14 = v12;
    }
  }
  while ( v14 || v10 );
  *(_QWORD *)(a1 + 8) = v9;
  v15 = *a3;
  v16 = (v9 + 7) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v17 = 0;
    v16 += 8LL;
    v18 = v15;
    v15 >>= 7;
    v19 = (v18 & 0x40) != 0;
    v20 = (v18 & 0x40) == 0;
    if ( v15 )
    {
      v17 = v20;
    }
    v21 = 0;
    if ( v15 != -1 )
    {
      v21 = v19;
    }
  }
  while ( v21 || v17 );
  *(_QWORD *)(a1 + 8) = v16;
  v22 = *a4;
  v23 = (v16 + 7) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v24 = 0;
    v23 += 8LL;
    v25 = v22;
    v22 >>= 7;
    v26 = (v25 & 0x40) != 0;
    v27 = (v25 & 0x40) == 0;
    if ( v22 )
    {
      v24 = v27;
    }
    v28 = 0;
    if ( v22 != -1 )
    {
      v28 = v26;
    }
  }
  while ( v28 || v24 );
  *(_QWORD *)(a1 + 8) = v23;
  v29 = (v23 + 7) & 0xFFFFFFFFFFFFFFF8uLL;
  v30 = *a5;
  do
  {
    v31 = 0;
    v29 += 8LL;
    v32 = v30;
    v30 >>= 7;
    v33 = (v32 & 0x40) != 0;
    v34 = (v32 & 0x40) == 0;
    if ( v30 )
    {
      v31 = v34;
    }
    v35 = 0;
    if ( v30 != -1 )
    {
      v35 = v33;
    }
  }
  while ( v35 || v31 );
  *(_QWORD *)(a1 + 8) = v29;
  v36 = (v29 + 7) & 0xFFFFFFFFFFFFFFF8uLL;
  v37 = *a6;
  do
  {
    v38 = 0;
    v36 += 8LL;
    v39 = v37;
    v37 >>= 7;
    v40 = (v39 & 0x40) != 0;
    v41 = (v39 & 0x40) == 0;
    if ( v37 )
    {
      v38 = v41;
    }
    result = 0;
    if ( v37 != -1 )
    {
      result = v40;
    }
  }
  while ( result || v38 );
  *(_QWORD *)(a1 + 8) = v36;
  return result;
}

// --- End Function: sub_1449CF740 (0x1449CF740) ---

// --- Function: sub_1449E7D50 (0x1449E7D50) ---
unsigned __int64 __fastcall sub_1449E7D50(__int64 a1, _QWORD *a2)
{
  __int64 v4; // rdi
  __int64 v5; // rbx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rcx
  _QWORD *v10; // rdi
  _QWORD *j; // rbx
  __int64 **v12; // rax
  __int64 i; // rax
  __int64 *v14; // rcx
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rax
  _QWORD *v17; // rdi
  _QWORD *m; // rbx
  __int64 **v19; // rax
  __int64 k; // rax
  __int64 *v21; // rcx
  __int64 v22; // rdi
  __int64 v23; // rbx
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rax
  __int64 v26; // rdi
  __int64 v27; // rbx
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rcx
  unsigned __int64 result; // rax
  _QWORD *v32; // rdi
  _QWORD *v33; // rbx
  unsigned __int64 *v34; // rcx

  align_serializer_offset_add71(a1);
  align_serializer_offset_add71(a1);
  align_serializer_offset_add71(a1);
  align_serializer_offset_add71(a1);
  v4 = a2[11];
  v5 = a2[10];
  v6 = (v4 - v5) / 144;
  v7 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v6 >>= 7;
    v7 += 8LL;
  }
  while ( v6 );
  for ( *(_QWORD *)(a1 + 8) = v7; v5 != v4; v5 += 144 )
  {
    sub_1449E6510(a1, v5);
  }
  sub_140521190(a1);
  align_serializer_offset_add71(a1);
  align_serializer_offset_add71(a1);
  v8 = a2[23];
  v9 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v8 >>= 7;
    v9 += 8LL;
  }
  while ( v8 );
  *(_QWORD *)(a1 + 8) = v9;
  v10 = (_QWORD *)a2[22];
  j = (_QWORD *)*v10;
  while ( j != v10 )
  {
    align_serializer_offset_add71(a1);
    sub_1449E70A0(a1, j + 5);
    v12 = (__int64 **)j[2];
    if ( *((_BYTE *)v12 + 25) )
    {
      for ( i = j[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( j != *(_QWORD **)(i + 16) )
        {
          break;
        }
        j = (_QWORD *)i;
      }
      j = (_QWORD *)i;
    }
    else
    {
      v14 = *v12;
      for ( j = (_QWORD *)j[2]; !*((_BYTE *)v14 + 25); v14 = (__int64 *)*v14 )
      {
        j = v14;
      }
    }
  }
  v15 = a2[15];
  v16 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v15 >>= 7;
    v16 += 8LL;
  }
  while ( v15 );
  *(_QWORD *)(a1 + 8) = v16;
  v17 = (_QWORD *)a2[14];
  m = (_QWORD *)*v17;
  while ( m != v17 )
  {
    sub_1411C3550(a1, m + 4);
    v19 = (__int64 **)m[2];
    if ( *((_BYTE *)v19 + 25) )
    {
      for ( k = m[1]; !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 8) )
      {
        if ( m != *(_QWORD **)(k + 16) )
        {
          break;
        }
        m = (_QWORD *)k;
      }
      m = (_QWORD *)k;
    }
    else
    {
      v21 = *v19;
      for ( m = (_QWORD *)m[2]; !*((_BYTE *)v21 + 25); v21 = (__int64 *)*v21 )
      {
        m = v21;
      }
    }
  }
  v22 = a2[27];
  v23 = a2[26];
  v24 = (v22 - v23) / 136;
  v25 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v24 >>= 7;
    v25 += 8LL;
  }
  while ( v24 );
  for ( *(_QWORD *)(a1 + 8) = v25; v23 != v22; v23 += 136 )
  {
    sub_1449E5D30(a1, v23);
  }
  v26 = a2[30];
  v27 = a2[29];
  v28 = (v26 - v27) / 136;
  v29 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v28 >>= 7;
    v29 += 8LL;
  }
  while ( v28 );
  for ( *(_QWORD *)(a1 + 8) = v29; v27 != v26; v27 += 136 )
  {
    sub_1449E5D30(a1, v27);
  }
  v30 = a2[25];
  result = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v30 >>= 7;
    result += 8LL;
  }
  while ( v30 );
  *(_QWORD *)(a1 + 8) = result;
  v32 = (_QWORD *)a2[24];
  v33 = (_QWORD *)*v32;
  while ( v33 != v32 )
  {
    sub_1411C3550(a1, v33 + 4);
    result = v33[2];
    if ( *(_BYTE *)(result + 25) )
    {
      for ( result = v33[1]; !*(_BYTE *)(result + 25); result = *(_QWORD *)(result + 8) )
      {
        if ( v33 != *(_QWORD **)(result + 16) )
        {
          break;
        }
        v33 = (_QWORD *)result;
      }
      v33 = (_QWORD *)result;
    }
    else
    {
      v34 = *(unsigned __int64 **)result;
      v33 = (_QWORD *)v33[2];
      if ( !*(_BYTE *)(*(_QWORD *)result + 25LL) )
      {
        do
        {
          result = *v34;
          v33 = v34;
          v34 = (unsigned __int64 *)result;
        }
        while ( !*(_BYTE *)(result + 25) );
      }
    }
  }
  return result;
}

// --- End Function: sub_1449E7D50 (0x1449E7D50) ---

// --- Function: sub_144A16590 (0x144A16590) ---
char __fastcall sub_144A16590(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        _QWORD *arg48,
        _QWORD *a11,
        _QWORD *a12)
{
  void *v16; // rsp
  __int64 a8; // [rsp+18h] [rbp-1B8h]
  __int64 a5[11]; // [rsp+30h] [rbp-1A0h] BYREF
  __int16 n256; // [rsp+88h] [rbp-148h]
  __int64 n176; // [rsp+90h] [rbp-140h]
  _QWORD *v22; // [rsp+98h] [rbp-138h]
  uint64_t **p_EntityId; // [rsp+A0h] [rbp-130h]
  __int64 v24; // [rsp+A8h] [rbp-128h]
  __int64 (__fastcall *p_sub_1403E6A60)(__int64, __int64, __int64); // [rsp+B0h] [rbp-120h]
  __int64 (__fastcall *p_sub_1403E6420)(__int64, _BYTE *, unsigned __int64); // [rsp+B8h] [rbp-118h]
  __int64 v27; // [rsp+C0h] [rbp-110h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+C8h] [rbp-108h]
  __int64 v29; // [rsp+D0h] [rbp-100h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+D8h] [rbp-F8h]
  __int64 (__fastcall *p_sub_1403E00D0)(__int64); // [rsp+E0h] [rbp-F0h]
  __int64 v32; // [rsp+E8h] [rbp-E8h]
  char v33; // [rsp+F0h] [rbp-E0h]
  char v34; // [rsp+F1h] [rbp-DFh]
  __int64 n24; // [rsp+F8h] [rbp-D8h]
  __int64 v36; // [rsp+100h] [rbp-D0h] BYREF

  v16 = alloca(416);
  a5[0] = arg40;
  a5[1] = (__int64)"TraceContext";
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v22 = arg48;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  p_EntityId = "EntityId";
  n256 = 256;
  a5[10] = -1;
  n176 = 176;
  v34 = 1;
  v24 = *arg48;
  p_sub_1403E6A60 = sub_1403E6A60;
  p_sub_1403E6420 = sub_1403E6420;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w;
  v27 = 0;
  v29 = 0;
  v33 = 0;
  p_sub_1403E00D0 = sub_1403E00D0;
  v32 = -1;
  n24 = 24;
  sub_140B869A0((__int64)&v36, a11, a12);
  LODWORD(a8) = a6;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 4, a7, a8, a9, a10);
}

// --- End Function: sub_144A16590 (0x144A16590) ---

// --- Function: sub_144A46C90 (0x144A46C90) ---
__int64 __fastcall sub_144A46C90(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4)
{
  __int64 *v4; // rsi
  __int64 v9; // r10
  __int64 v10; // rax
  unsigned __int64 v11; // r11
  char v12; // al
  __int64 v13; // r8
  int v14; // eax
  __int64 v15; // rax
  __int128 v16; // xmm0
  __int64 result; // rax
  __int128 v18; // [rsp+20h] [rbp-28h] BYREF

  v4 = *(__int64 **)a1;
  DWORD2(v18) = 0;
  v9 = (__int64)v4;
  v10 = v4[1];
  *(_QWORD *)&v18 = v10;
  if ( !*(_BYTE *)(v10 + 25) )
  {
    v11 = *a3;
    do
    {
      *(_QWORD *)&v18 = v10;
      if ( *(_QWORD *)(v10 + 32) >= v11 )
      {
        v9 = v10;
        DWORD2(v18) = 1;
        v10 = *(_QWORD *)v10;
      }
      else
      {
        v10 = *(_QWORD *)(v10 + 16);
        DWORD2(v18) = 0;
      }
    }
    while ( !*(_BYTE *)(v10 + 25) );
  }
  if ( *(_BYTE *)(v9 + 25) || *a3 < *(_QWORD *)(v9 + 32) )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x1AF286BCA1AF286LL )
    {
      unknown_libname_7();
    }
    v13 = allocWithoutProfiling(0x98u);
    *(_QWORD *)(v13 + 32) = *a3;
    *(_QWORD *)(v13 + 40) = *(_QWORD *)a4;
    *(_DWORD *)(v13 + 48) = *(_DWORD *)(a4 + 8);
    *(_OWORD *)(v13 + 56) = *(_OWORD *)(a4 + 16);
    v14 = *(_DWORD *)(a4 + 32);
    *(_QWORD *)(v13 + 80) = off_147F3F7D8;
    *(_QWORD *)(v13 + 88) = off_147F3F7A8;
    *(_DWORD *)(v13 + 72) = v14;
    v15 = *(_QWORD *)(a4 + 56);
    *(_QWORD *)(v13 + 104) = off_147F3F7D8;
    *(_QWORD *)(v13 + 112) = off_147F3F7A8;
    *(_QWORD *)(v13 + 96) = v15;
    *(_QWORD *)(v13 + 120) = *(_QWORD *)(a4 + 80);
    *(_OWORD *)(v13 + 128) = *(_OWORD *)(a4 + 88);
    v16 = v18;
    *(double *)(v13 + 144) = *(double *)(a4 + 104);
    *(_QWORD *)v13 = v4;
    *(_QWORD *)(v13 + 8) = v4;
    *(_QWORD *)(v13 + 16) = v4;
    *(_WORD *)(v13 + 24) = 0;
    v18 = v16;
    v9 = sub_1402DE890((__int64 **)a1, (__int64)&v18, v13);
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  *(_BYTE *)(a2 + 8) = v12;
  result = a2;
  *(_QWORD *)a2 = v9;
  return result;
}

// --- End Function: sub_144A46C90 (0x144A46C90) ---

// --- Function: sub_144BDC230 (0x144BDC230) ---
void __fastcall sub_144BDC230(__int64 rcx0, __int64 *a2)
{
  _BYTE *v4; // rdx
  __int64 v5; // rbx
  __int64 v6; // r8
  __int64 *v7; // r14
  __int64 *v8; // r12
  __int64 v9; // rax
  __int64 v10; // rdi
  int v11; // ebx
  __int64 *ThreadLogContextSlot; // rax
  __int16 v13; // bx
  _QWORD *v14; // rax
  _BYTE *v15; // rcx
  unsigned int *v16; // rsi
  int *v17; // rbx
  int *v18; // rax
  int v19; // ebx
  int v20; // edi
  __int64 v21; // rdi
  unsigned __int8 (__fastcall *v22)(__int64, __int64, const char *); // rbx
  __int64 v23; // rax
  __int64 v24; // rcx
  __int128 v25; // xmm0
  double v26; // xmm1_8
  bool v27; // zf
  __int64 v28; // rax
  unsigned __int64 v29; // r9
  bool v30; // cf
  unsigned __int64 v31; // rax
  bool v32; // cf
  __int64 v33; // rax
  __int128 v34; // xmm0
  _QWORD *v35; // rax
  int v36; // ebx
  __int64 *ThreadLogContextSlot_2; // rax
  int v38; // ebx
  __int64 v39; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v41; // rbx
  __int64 v42; // [rsp+28h] [rbp-D8h]
  __int64 a1; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v44; // [rsp+68h] [rbp-98h]
  int *p_n209; // [rsp+70h] [rbp-90h] BYREF
  int *p_n177; // [rsp+78h] [rbp-88h]
  _OWORD v47[2]; // [rsp+80h] [rbp-80h] BYREF
  _BYTE v48[8]; // [rsp+A0h] [rbp-60h] BYREF
  _DWORD v49[2]; // [rsp+A8h] [rbp-58h] BYREF
  __int64 p_n177_1; // [rsp+B0h] [rbp-50h] BYREF
  int *p_n209_1; // [rsp+B8h] [rbp-48h] BYREF
  _BYTE *v52; // [rsp+C0h] [rbp-40h]
  __int64 v53; // [rsp+C8h] [rbp-38h] BYREF
  __int64 v54; // [rsp+D0h] [rbp-30h]
  char v55; // [rsp+D8h] [rbp-28h]
  __int128 v56; // [rsp+E0h] [rbp-20h] BYREF
  char v57; // [rsp+F0h] [rbp-10h]
  _QWORD v58[2]; // [rsp+F8h] [rbp-8h] BYREF
  _BYTE v59[8]; // [rsp+108h] [rbp+8h] BYREF
  const void *v60; // [rsp+110h] [rbp+10h]
  _BYTE v61[16]; // [rsp+120h] [rbp+20h] BYREF
  __int64 v62; // [rsp+130h] [rbp+30h]
  int n209; // [rsp+138h] [rbp+38h] BYREF
  int n150; // [rsp+13Ch] [rbp+3Ch]
  int n177; // [rsp+140h] [rbp+40h] BYREF
  _BYTE v66[12]; // [rsp+144h] [rbp+44h] BYREF
  __int64 v67; // [rsp+150h] [rbp+50h] BYREF
  int v68; // [rsp+158h] [rbp+58h]
  __int128 v69; // [rsp+160h] [rbp+60h]
  int v70; // [rsp+170h] [rbp+70h]
  __int64 (__fastcall **v71)(); // [rsp+178h] [rbp+78h]
  __int64 (__fastcall **v72)(); // [rsp+180h] [rbp+80h]
  __int64 v73; // [rsp+188h] [rbp+88h]
  _BYTE v74[24]; // [rsp+190h] [rbp+90h] BYREF
  __int128 v75; // [rsp+1A8h] [rbp+A8h]
  double v76; // [rsp+1B8h] [rbp+B8h]

  a1 = 0;
  v44 = 0;
  v5 = sub_14038E0B0((__int64)&a1, 0x48u);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 16) = v5;
  *(_WORD *)(v5 + 24) = 257;
  v7 = (__int64 *)a2[29];
  v8 = (__int64 *)a2[30];
  for ( a1 = v5; v7 != v8; v7 += 17 )
  {
    if ( *((_DWORD *)v7 + 9) == 176 )
    {
      v9 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64, __int64))(*(_QWORD *)global_validator_object + 192LL))(
             global_validator_object,
             v4,
             v6,
             0x38E38E38E38E38ELL);
      v10 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + 16LL))(v9, *((unsigned int *)v7 + 8));
      if ( v10 )
      {
        v13 = word_1496AA290;
        if ( word_1496AA290 == -1 )
        {
          v13 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                    + 16LL))(
                            global_dispatcher_ptr,
                            v48,
                            "AmmoContainerComponent");
          word_1496AA290 = v13;
        }
        v14 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 96LL))(v10);
        v15 = (_BYTE *)*v14;
        v4 = (_BYTE *)v14[1];
        if ( (_BYTE *)*v14 != v4 )
        {
          while ( *(_WORD *)v15 != v13 )
          {
            v15 += 32;
            if ( v15 == v4 )
            {
              goto LABEL_23;
            }
          }
          v16 = (unsigned int *)*((_QWORD *)v15 + 1);
          if ( v16 )
          {
            v17 = (int *)sub_142D7D670((__int64)v59);
            v18 = (int *)(*(__int64 (__fastcall **)(unsigned int *, _OWORD *))(*(_QWORD *)v16 + 24LL))(v16, v47);
            v19 = *v17;
            v20 = *v18;
            if ( *((_QWORD *)&v47[0] + 1) )
            {
              sub_14739AF10(*((const void **)&v47[0] + 1));
            }
            if ( v60 )
            {
              sub_14739AF10(v60);
            }
            if ( v19 == v20
              || Parameter_3
              && (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3)
              && (v21 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
                  v22 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v21 + 256LL),
                  v23 = (*(__int64 (__fastcall **)(unsigned int *))(*(_QWORD *)v16 + 8LL))(v16),
                  v22(v21, v23, "SAmmoContainerComponentParams")) )
            {
              if ( v16[22] == 2 )
              {
                sub_145B7ECE0(v61, v16[7], 0);
                v24 = v62;
                a2[18] += v62;
                v25 = *((_OWORD *)v7 + 1);
                v67 = *v7;
                v70 = *((_DWORD *)v7 + 9);
                v71 = off_147F3F7D8;
                v73 = v24;
                v72 = off_147F3F7A8;
                v68 = 0;
                v69 = v25;
                sub_140366D50(v74);
                v26 = *((double *)v7 + 9);
                v75 = *(_OWORD *)(v7 + 7);
                v76 = v26;
                sub_144A46C90(a2 + 22, &v53, v7, &v67);
              }
            }
          }
        }
      }
      else
      {
        v49[0] = 209;
        v58[0] = v49;
        v49[1] = 150;
        v58[1] = &p_n177_1;
        v11 = invokeGlobalCallbackAndMaskStatusBits(
                2,
                (__int64)v58,
                (__int64)"CEntityComponentCommodityUIProvider::RequestVehicleLooseItemResourceData",
                "CEntityComponentCommodityUIProvider class CRC [$$] not found!");
        if ( (v11 & 0xFFFFF) != 0 )
        {
          v52 = (_BYTE *)*((unsigned int *)v7 + 8);
          p_n209_1 = 0;
          ThreadLogContextSlot = getThreadLogContextSlot();
          n209 = 209;
          p_n209 = &n209;
          n150 = 150;
          p_n177 = &n177;
          LODWORD(v42) = v11;
          v56 = 0;
          sub_140C45220(
            2,
            (unsigned int)&p_n209,
            (unsigned int)"CEntityComponentCommodityUIProvider::RequestVehicleLooseItemResourceData",
            (unsigned int)"CEntityComponentCommodityUIProvider class CRC [$$] not found!",
            1,
            v42,
            &v56,
            0,
            (__int64)ThreadLogContextSlot,
            (__int64)&p_n209_1);
        }
      }
    }
    else
    {
      v28 = *(_QWORD *)(v5 + 8);
      v6 = v5;
      *(_QWORD *)&v47[0] = v28;
      DWORD2(v47[0]) = 0;
      if ( !*(_BYTE *)(v28 + 25) )
      {
        v29 = v7[2];
        do
        {
          *(_QWORD *)&v47[0] = v28;
          v30 = *(_QWORD *)(v28 + 32) < v29;
          if ( *(_QWORD *)(v28 + 32) == v29 )
          {
            v30 = *(_QWORD *)(v28 + 40) < (unsigned __int64)v7[3];
          }
          if ( v30 )
          {
            v28 = *(_QWORD *)(v28 + 16);
            DWORD2(v47[0]) = 0;
          }
          else
          {
            v6 = v28;
            DWORD2(v47[0]) = 1;
            v28 = *(_QWORD *)v28;
          }
        }
        while ( !*(_BYTE *)(v28 + 25) );
      }
      if ( *(_BYTE *)(v6 + 25) )
      {
        goto LABEL_39;
      }
      v31 = v7[2];
      v32 = v31 < *(_QWORD *)(v6 + 32);
      if ( v31 == *(_QWORD *)(v6 + 32) )
      {
        v32 = (unsigned __int64)v7[3] < *(_QWORD *)(v6 + 40);
      }
      if ( v32 )
      {
LABEL_39:
        if ( v44 == 0x38E38E38E38E38ELL )
        {
          unknown_libname_7();
        }
        v33 = sub_14038E0B0((__int64)&a1, 0x48u);
        *(_OWORD *)(v33 + 32) = *((_OWORD *)v7 + 1);
        v34 = v47[0];
        *(_QWORD *)(v33 + 48) = 0;
        *(_QWORD *)(v33 + 56) = 0;
        *(_QWORD *)(v33 + 64) = 0;
        *(_QWORD *)v33 = v5;
        *(_QWORD *)(v33 + 8) = v5;
        *(_QWORD *)(v33 + 16) = v5;
        *(_WORD *)(v33 + 24) = 0;
        v47[0] = v34;
        v6 = sub_1402DE890((__int64 **)&a1, (__int64)v47, v33);
      }
      v4 = *(_BYTE **)(v6 + 56);
      if ( v4 == *(_BYTE **)(v6 + 64) )
      {
        sub_1402A4BA0((__int64 *)(v6 + 48), v4, v7);
      }
      else
      {
        *(_QWORD *)v4 = *v7;
        *(_QWORD *)(v6 + 56) += 8LL;
      }
    }
LABEL_23:
    v5 = a1;
  }
  if ( v44 )
  {
    v35 = (_QWORD *)sub_1403A8520(rcx0, &n209);
    p_n177_1 = sub_14048CA30(&a1, *v35);
    n209 = 209;
    n150 = 150;
    if ( p_n177_1 )
    {
      n177 = 177;
      p_n209 = &n209;
      p_n177 = (int *)v66;
      v38 = invokeGlobalCallbackAndMaskStatusBits(
              5,
              (__int64)&p_n209,
              (__int64)"CEntityComponentCommodityUIProvider::RequestVehicleLooseItemResourceData",
              "Loose Item AsyncGetResourceValueMaps request sent - playerId[$$] vehicleEntityId[$$] requestId[$$]");
      if ( (v38 & 0xFFFFF) != 0 )
      {
        v39 = *(_QWORD *)(rcx0 + 10376);
        p_n177 = (int *)p_n177_1;
        v54 = *a2;
        p_n209 = 0;
        v53 = 0;
        v55 = 0;
        *(_QWORD *)&v56 = 0;
        *((_QWORD *)&v56 + 1) = v39;
        v57 = 0;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        n209 = 209;
        p_n209_1 = &n209;
        v52 = v66;
        LODWORD(v42) = v38;
        v47[0] = 0;
        n150 = 150;
        n177 = 177;
        sub_144A16590(
          5,
          (__int64)&p_n209_1,
          "CEntityComponentCommodityUIProvider::RequestVehicleLooseItemResourceData",
          (__int64)"Loose Item AsyncGetResourceValueMaps request sent - playerId[$$] vehicleEntityId[$$] requestId[$$]",
          1,
          v42,
          v47,
          0,
          (__int64)ThreadLogContextSlot_1,
          (__int64)&v56,
          (__int64)&v53,
          (__int64)&p_n209);
      }
      v41 = *a2;
      *(_QWORD *)sub_141600300(rcx0 + 9648, &p_n177_1) = v41;
      goto LABEL_52;
    }
    p_n209 = &n209;
    p_n177 = &n177;
    v36 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)&p_n209,
            (__int64)"CEntityComponentCommodityUIProvider::RequestVehicleLooseItemResourceData",
            "AsyncGetResourceValueMaps Request Failed for vehicleEntityId[$$]");
    if ( (v36 & 0xFFFFF) != 0 )
    {
      v54 = *a2;
      v53 = 0;
      v55 = 0;
      ThreadLogContextSlot_2 = getThreadLogContextSlot();
      n209 = 209;
      p_n209 = &n209;
      n150 = 150;
      p_n177 = &n177;
      LODWORD(v42) = v36;
      v47[0] = 0;
      sub_14034F0C0(
        3,
        (unsigned int)&p_n209,
        (unsigned int)"CEntityComponentCommodityUIProvider::RequestVehicleLooseItemResourceData",
        (unsigned int)"AsyncGetResourceValueMaps Request Failed for vehicleEntityId[$$]",
        1,
        v42,
        v47,
        0,
        (__int64)ThreadLogContextSlot_2,
        (__int64)&v53);
    }
    v27 = (*((_BYTE *)a2 + 276) & 0xFB) == 0;
    *((_BYTE *)a2 + 276) &= ~4u;
    *((_DWORD *)a2 + 65) = 4;
    if ( !v27 )
    {
LABEL_52:
      v5 = a1;
      goto LABEL_53;
    }
LABEL_26:
    sub_144BF8000(rcx0, *a2);
    goto LABEL_52;
  }
  v27 = (*((_BYTE *)a2 + 276) & 0xFB) == 0;
  *((_BYTE *)a2 + 276) &= ~4u;
  *((_DWORD *)a2 + 65) = 0;
  if ( v27 )
  {
    goto LABEL_26;
  }
LABEL_53:
  sub_1411CEB20(&a1, &a1, *(_QWORD *)(v5 + 8));
  sub_14039EFB0((__int64)&a1, (const void *)a1, 0x48u);
}

// --- End Function: sub_144BDC230 (0x144BDC230) ---

// --- Function: sub_144BF8000 (0x144BF8000) ---
__int64 __fastcall sub_144BF8000(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r14
  __int64 v4; // rdi
  int v5; // ebx
  unsigned __int32 v6; // eax
  __int64 *v7; // rcx
  __int64 *v8; // r13
  __int64 *v9; // rax
  int v10; // ebx
  __int64 *ThreadLogContextSlot_3; // rax
  int v12; // ebx
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 *k; // rbx
  __int64 *v15; // rax
  __int64 *v16; // rdx
  __int64 *v17; // r12
  __int64 *v18; // rax
  __int64 v19; // rsi
  __int64 i; // rdi
  _QWORD *v21; // rax
  __int64 v22; // rax
  __int64 **v23; // rax
  __int64 *j; // rax
  int v25; // edi
  __int64 *ThreadLogContextSlot_2; // rax
  __int64 *v27; // rcx
  __int64 v28; // rbx
  unsigned int v29; // eax
  _QWORD *v30; // r13
  __int64 v31; // rbx
  __int16 v32; // dx
  void (__fastcall *v33)(int *, _QWORD *, _QWORD, _QWORD, int, int, int); // r10
  int v34; // ebx
  __int64 *ThreadLogContextSlot; // rax
  int v36; // eax
  __int64 result; // rax
  __int64 v38; // [rsp+28h] [rbp-D8h]
  _BYTE v39[8]; // [rsp+60h] [rbp-A0h] BYREF
  int v40; // [rsp+68h] [rbp-98h] BYREF
  int v41; // [rsp+70h] [rbp-90h] BYREF
  int v42; // [rsp+78h] [rbp-88h] BYREF
  __int64 *v43; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v44; // [rsp+88h] [rbp-78h] BYREF
  __int64 v45; // [rsp+90h] [rbp-70h] BYREF
  __int64 v46; // [rsp+98h] [rbp-68h] BYREF
  _DWORD v47[2]; // [rsp+A0h] [rbp-60h] BYREF
  _DWORD v48[2]; // [rsp+A8h] [rbp-58h] BYREF
  void *(__fastcall **v49)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+B0h] [rbp-50h] BYREF
  __int64 v50; // [rsp+B8h] [rbp-48h]
  _QWORD v51[2]; // [rsp+C0h] [rbp-40h] BYREF
  _QWORD v52[2]; // [rsp+D0h] [rbp-30h] BYREF
  _QWORD v53[2]; // [rsp+E0h] [rbp-20h] BYREF
  _QWORD v54[2]; // [rsp+F0h] [rbp-10h] BYREF
  _QWORD v55[2]; // [rsp+100h] [rbp+0h] BYREF
  _QWORD v56[2]; // [rsp+110h] [rbp+10h] BYREF
  _QWORD v57[2]; // [rsp+120h] [rbp+20h] BYREF
  _QWORD v58[2]; // [rsp+130h] [rbp+30h] BYREF
  _QWORD v59[2]; // [rsp+140h] [rbp+40h] BYREF
  _QWORD v60[2]; // [rsp+150h] [rbp+50h] BYREF
  char v61; // [rsp+160h] [rbp+60h]
  _QWORD v62[2]; // [rsp+168h] [rbp+68h] BYREF
  char v63; // [rsp+178h] [rbp+78h]
  _QWORD v64[2]; // [rsp+180h] [rbp+80h] BYREF
  char v65; // [rsp+190h] [rbp+90h]
  _QWORD v66[2]; // [rsp+198h] [rbp+98h] BYREF
  char v67; // [rsp+1A8h] [rbp+A8h]
  _QWORD v68[2]; // [rsp+1B0h] [rbp+B0h] BYREF
  char v69; // [rsp+1C0h] [rbp+C0h]
  __int128 v70; // [rsp+1C8h] [rbp+C8h] BYREF
  __int128 v71; // [rsp+1D8h] [rbp+D8h] BYREF
  __int128 v72; // [rsp+1E8h] [rbp+E8h] BYREF
  __int128 v73; // [rsp+1F8h] [rbp+F8h] BYREF
  _QWORD v74[8]; // [rsp+208h] [rbp+108h] BYREF
  __int64 v75; // [rsp+248h] [rbp+148h] BYREF
  __int64 v76; // [rsp+258h] [rbp+158h]
  __int64 v77; // [rsp+260h] [rbp+160h] BYREF
  _DWORD v78[3]; // [rsp+270h] [rbp+170h] BYREF
  char v79; // [rsp+27Ch] [rbp+17Ch] BYREF
  _DWORD v80[3]; // [rsp+280h] [rbp+180h] BYREF
  char v81; // [rsp+28Ch] [rbp+18Ch] BYREF
  _DWORD v82[3]; // [rsp+290h] [rbp+190h] BYREF
  char v83; // [rsp+29Ch] [rbp+19Ch] BYREF
  _DWORD v84[3]; // [rsp+2A0h] [rbp+1A0h] BYREF
  char v85; // [rsp+2ACh] [rbp+1ACh] BYREF
  int v86; // [rsp+2B0h] [rbp+1B0h] BYREF
  __int128 v87; // [rsp+2B8h] [rbp+1B8h]

  v2 = a1 + 10432;
  v45 = a1;
  v46 = a1 + 10432;
  v4 = a1;
  v5 = *(_DWORD *)(get_tls_data_offset_784() + 24);
  if ( *(_DWORD *)(v2 + 4) == v5 )
  {
    ++*(_DWORD *)(v2 + 8);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 1, 0);
    if ( v6 )
    {
      sub_1403BF290(
        (volatile signed __int32 *)v2,
        v6,
        (__int64)"CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
        1);
    }
    *(_DWORD *)(v2 + 4) = v5;
  }
  v7 = *(__int64 **)(v4 + 10416);
  v8 = v7;
  v9 = (__int64 *)v7[1];
  while ( !*((_BYTE *)v9 + 25) )
  {
    if ( v9[4] >= a2 )
    {
      v8 = v9;
      v9 = (__int64 *)*v9;
    }
    else
    {
      v9 = (__int64 *)v9[2];
    }
  }
  if ( *((_BYTE *)v8 + 25) || a2 < v8[4] || v8 == v7 )
  {
    v45 = 0x96000000D1LL;
    v53[0] = &v45;
    v53[1] = &v46;
    v34 = invokeGlobalCallbackAndMaskStatusBits(
            4,
            (__int64)v53,
            (__int64)"CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
            "Vehicle Data Map missing vehicleId! playerId[$$] vehicleEntityId[$$]");
    if ( (v34 & 0xFFFFF) != 0 )
    {
      v68[1] = *(_QWORD *)(v4 + 10376);
      v66[0] = 0;
      v66[1] = a2;
      v67 = 0;
      v68[0] = 0;
      v69 = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v46 = 0x96000000D1LL;
      v54[0] = &v46;
      v54[1] = v47;
      LODWORD(v38) = v34;
      v73 = 0;
      sub_1415CC1C0(
        4,
        (__int64)v54,
        "CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
        (__int64)"Vehicle Data Map missing vehicleId! playerId[$$] vehicleEntityId[$$]",
        1,
        v38,
        &v73,
        0,
        (__int64)ThreadLogContextSlot,
        (__int64)v68,
        (__int64)v66);
    }
  }
  else if ( *(_DWORD *)(v4 + 10368) )
  {
    v82[0] = 209;
    v57[0] = v82;
    v82[1] = 150;
    v57[1] = &v83;
    v82[2] = 177;
    v12 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)v57,
            (__int64)"CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
            "Sending Vehicle Data Response - vehicleId[$$]");
    if ( (v12 & 0xFFFFF) != 0 )
    {
      v62[0] = 0;
      v62[1] = a2;
      v63 = 0;
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      v84[0] = 209;
      v58[0] = v84;
      v84[1] = 150;
      v58[1] = &v85;
      v84[2] = 177;
      LODWORD(v38) = v12;
      v71 = 0;
      sub_14034F0C0(
        5,
        (__int64)v58,
        "CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
        (__int64)"Sending Vehicle Data Response - vehicleId[$$]",
        1,
        v38,
        &v71,
        0,
        (__int64)ThreadLogContextSlot_1,
        v62);
    }
    k = *(__int64 **)v8[29];
    if ( !*((_BYTE *)k + 25) )
    {
      v15 = v8 + 27;
      v43 = v8 + 27;
      do
      {
        v16 = (__int64 *)*v15;
        v17 = (__int64 *)*v15;
        v18 = *(__int64 **)(*v15 + 8);
        while ( !*((_BYTE *)v18 + 25) )
        {
          if ( v18[4] >= (unsigned __int64)k[4] )
          {
            v17 = v18;
            v18 = (__int64 *)*v18;
          }
          else
          {
            v18 = (__int64 *)v18[2];
          }
        }
        if ( *((_BYTE *)v17 + 25) || k[4] < (unsigned __int64)v17[4] || v17 == v16 )
        {
          v47[0] = 209;
          v59[0] = v47;
          v47[1] = 150;
          v59[1] = v48;
          v25 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)v59,
                  (__int64)"CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
                  "ResourceMap entity Missing in RCInfo Map - SelectedVehicle[$$]");
          if ( (v25 & 0xFFFFF) != 0 )
          {
            v64[0] = 0;
            v64[1] = a2;
            v65 = 0;
            ThreadLogContextSlot_2 = getThreadLogContextSlot();
            v48[0] = 209;
            v51[0] = v48;
            v48[1] = 150;
            v51[1] = &v49;
            LODWORD(v38) = v25;
            v72 = 0;
            sub_14034F0C0(
              3,
              (__int64)v51,
              "CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
              (__int64)"ResourceMap entity Missing in RCInfo Map - SelectedVehicle[$$]",
              1,
              v38,
              &v72,
              0,
              (__int64)ThreadLogContextSlot_2,
              v64);
          }
        }
        else
        {
          v19 = k[6];
          for ( i = k[5]; i != v19; v17[15] += v22 )
          {
            v21 = sub_140369E00(&v77, *(_QWORD *)(i + 16));
            sub_140366CD0(&v75, (__int64)v21);
            v22 = v76;
            i += 24;
            v8[26] += v76;
          }
        }
        v23 = (__int64 **)k[2];
        if ( *((_BYTE *)v23 + 25) )
        {
          for ( j = (__int64 *)k[1]; !*((_BYTE *)j + 25); j = (__int64 *)j[1] )
          {
            if ( k != (__int64 *)j[2] )
            {
              break;
            }
            k = j;
          }
          k = j;
        }
        else
        {
          v27 = *v23;
          for ( k = (__int64 *)k[2]; !*((_BYTE *)v27 + 25); v27 = (__int64 *)*v27 )
          {
            k = v27;
          }
        }
        v15 = v43;
      }
      while ( !*((_BYTE *)k + 25) );
      v2 = v46;
      v4 = v45;
    }
    v28 = *(_QWORD *)(v4 + 10048);
    v40 = *((_DWORD *)v8 + 78);
    v41 = *((_DWORD *)v8 + 77);
    v42 = *((_DWORD *)v8 + 76);
    LODWORD(v43) = *((_DWORD *)v8 + 75);
    v29 = *((_DWORD *)v8 + 74);
    v30 = v8 + 5;
    v44 = v29;
    v86 = 0;
    v39[0] = 0;
    v87 = xmmword_1486DE0B8;
    v31 = v28 & 0xFFFFFFFFFFFFLL;
    if ( v31 )
    {
      v50 = 0;
      v49 = &off_147F42890;
      sub_1449E7D50((__int64)&v49, v30);
      sub_1449CF740((__int64)&v49, (int *)&v44, (int *)&v43, &v42, &v41, &v40);
      v32 = *(_WORD *)(v4 + 10056);
      v74[0] = sub_144C2A810;
      v74[6] = v30;
      v74[1] = &v40;
      v74[2] = &v41;
      v74[3] = &v42;
      v74[4] = &v43;
      v74[5] = &v44;
      v52[0] = v74;
      v52[1] = sub_1414F7CD0;
      (*(void (__fastcall **)(__int64, _QWORD, int *, __int64, _QWORD *, _BYTE *))(*(_QWORD *)v31 + 8LL))(
        v31,
        v32 & 0x3FFF,
        &v86,
        v50,
        v52,
        v39);
      if ( v39[0] )
      {
        v33 = *(void (__fastcall **)(int *, _QWORD *, _QWORD, _QWORD, int, int, int))(v4 + 10024);
        if ( *(_QWORD *)(v4 + 10032) == 1 )
        {
          v33(&v86, v30, v44, (unsigned int)v43, v42, v41, v40);
          *(_DWORD *)(v4 + 10368) = 2;
          goto LABEL_50;
        }
        ((void (__fastcall *)(__int64, int *, _QWORD *, _QWORD, _DWORD, int, int, int))v33)(
          v4 + 10024,
          &v86,
          v30,
          v44,
          (_DWORD)v43,
          v42,
          v41,
          v40);
      }
    }
    *(_DWORD *)(v4 + 10368) = 2;
  }
  else
  {
    v78[0] = 209;
    v55[0] = v78;
    v78[1] = 150;
    v55[1] = &v79;
    v78[2] = 177;
    v10 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)v55,
            (__int64)"CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
            "Kiosk was Closed - Not Sending Vehicle Data Response - vehicleId[$$]");
    if ( (v10 & 0xFFFFF) != 0 )
    {
      v60[0] = 0;
      v60[1] = a2;
      v61 = 0;
      ThreadLogContextSlot_3 = getThreadLogContextSlot();
      v80[0] = 209;
      v56[0] = v80;
      v80[1] = 150;
      v56[1] = &v81;
      v80[2] = 177;
      LODWORD(v38) = v10;
      v70 = 0;
      sub_14034F0C0(
        5,
        (__int64)v56,
        "CEntityComponentCommodityUIProvider::SendVehicleCargoDataResponse",
        (__int64)"Kiosk was Closed - Not Sending Vehicle Data Response - vehicleId[$$]",
        1,
        v38,
        &v70,
        0,
        (__int64)ThreadLogContextSlot_3,
        v60);
    }
  }
LABEL_50:
  v36 = *(_DWORD *)(v2 + 8);
  if ( v36 )
  {
    result = (unsigned int)(v36 - 1);
    *(_DWORD *)(v2 + 8) = result;
  }
  else
  {
    *(_DWORD *)(v2 + 4) = -1;
    result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v2, 0, 1);
    if ( (_DWORD)result != 1 )
    {
      return sub_1403D6A80((volatile signed __int32 *)v2, result);
    }
  }
  return result;
}

// --- End Function: sub_144BF8000 (0x144BF8000) ---

// --- Function: sub_144C2A810 (0x144C2A810) ---
__int64 __fastcall sub_144C2A810(__int64 a1, __int64 a2, int *a3, int a4, __int64 a5, __int64 a6, __int64 a7)
{
  _QWORD *v9; // r11
  __int64 v10; // r9
  int v11; // r10d
  unsigned int v12; // eax
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r9
  char v16; // bl
  bool v17; // al
  bool v18; // dl
  bool v19; // al
  bool v20; // cl
  char v21; // al
  void *(__fastcall **v23)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+30h] [rbp-18h] BYREF
  __int64 v24; // [rsp+38h] [rbp-10h]

  v24 = a1;
  v23 = &off_147F42890;
  sub_1449F1010(&v23);
  v9 = (_QWORD *)v24;
  v10 = 0;
  v11 = *a3;
  v12 = *(unsigned __int8 *)(v24 + 24);
  v13 = *(_QWORD *)(v24 + 8);
  v14 = (unsigned __int64)(*(_QWORD *)(v24 + 16) + 7LL) >> 3;
  *(_QWORD *)(v24 + 16) = 8 * v14;
  if ( 8 * v14 <= v13 )
  {
    v10 = v12;
  }
  v15 = (v14 + *v9) * v10;
  if ( v15 )
  {
    do
    {
      v16 = v11 & 0x7F;
      v17 = (v11 & 0x40) != 0;
      v11 >>= 7;
      v18 = v17;
      v19 = 0;
      if ( v11 )
      {
        v19 = !v18;
      }
      v20 = 0;
      if ( v11 != -1 )
      {
        v20 = v18;
      }
      v9[2] += 8LL;
      v21 = v20 || v19;
      if ( v9[2] <= v13 )
      {
        *(_BYTE *)v15++ = v16 | (v21 << 7);
        v13 = v9[1];
      }
    }
    while ( v21 );
  }
  return sub_1449F1AF0((unsigned int)&v23, a4, a5, a6, a7);
}

// --- End Function: sub_144C2A810 (0x144C2A810) ---

// --- Function: sub_145B7ECE0 (0x145B7ECE0) ---
_QWORD *__fastcall sub_145B7ECE0(_QWORD *a1, int a2, __int64 a3)
{
  _QWORD *v3; // rax
  _QWORD *v5; // rax
  __int64 v6; // [rsp+30h] [rbp-28h] BYREF
  _QWORD v7[3]; // [rsp+40h] [rbp-18h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h]

  v10 = a3;
  if ( !a3 )
  {
    v10 = sub_145BB3830();
  }
  if ( v10 )
  {
    v3 = sub_140369E00(&v6, (unsigned int)(int)(float)((float)a2 * *(float *)(v10 + 340)));
    sub_140366CD0(a1, (__int64)v3);
  }
  else
  {
    v5 = sub_140369E00(v7, 0);
    sub_140366CD0(a1, (__int64)v5);
  }
  return a1;
}

// --- End Function: sub_145B7ECE0 (0x145B7ECE0) ---

// --- Function: sub_145BB3830 (0x145BB3830) ---
__int64 sub_145BB3830()
{
  Parameter *v0; // rax
  __int64 v2; // [rsp+30h] [rbp-48h]
  _BYTE v3[24]; // [rsp+50h] [rbp-28h] BYREF

  v0 = sub_1402C4DA0();
  v2 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)v0 + 576LL))(v0);
  return *(_QWORD *)(sub_140420C70(
                       v2,
                       (__int64)v3,
                       (__int64)"SGlobalSalvageRepairBeamParams.SGlobalSalvageRepairBeamParams")
                   + 16);
}

// --- End Function: sub_145BB3830 (0x145BB3830) ---

// --- Function: sub_147397F30 (0x147397F30) ---
void __fastcall sub_147397F30(__int64 pCZoneSystem)
{
  sub_147397F40(pCZoneSystem);
}

// --- End Function: sub_147397F30 (0x147397F30) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(const void *pCZoneSystem)
{
  if ( pCZoneSystem )
  {
    if ( qword_14981D3D8 && ::pCZoneSystem && pCZoneSystem == (const void *)::pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)pCZoneSystem < pCZoneSystem_1
      || (unsigned __int64)pCZoneSystem >= pCZoneSystem_1 + 0x8000000000LL )
    {
      if ( (unsigned __int64)pCZoneSystem >= pCZoneSystem_0
        && (unsigned __int64)pCZoneSystem < pCZoneSystem_0 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", pCZoneSystem);
      }
      sub_147397F30((__int64)pCZoneSystem);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: allocWithProfilerInfo (0x14739AFC0) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char tls_byte_at_offset_3401; // al
  __int64 profileSize; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    tls_byte_at_offset_3401 = get_tls_byte_at_offset_3401();
    sub_140566BA0(tls_byte_at_offset_3401);
    profileSize = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1473986B0(profileSize + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x14739AFC0) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memmove (0x147E162C1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x147E162C1) ---

