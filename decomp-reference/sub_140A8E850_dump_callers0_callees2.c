// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x140A8E850 (sub_140A8E850)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 96
// ------------------------------------------------------------

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: sub_1402A6C80 (0x1402A6C80) ---
double *__fastcall sub_1402A6C80(__int64 a1, _BYTE *a2, __int64 a3)
{
  __int64 v6; // rsi
  __int64 v7; // rdx
  unsigned __int64 _Newsize; // r15
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 _Newcapacity; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v13; // rax
  _QWORD *_Newvec; // rbx
  void *_Newvec_1; // rcx
  double *v16; // rsi
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8

  v6 = (__int64)&a2[-*(_QWORD *)a1] / 24;
  v7 = (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) / 24LL;
  if ( v7 == 0xAAAAAAAAAAAAAAALL )
    unknown_libname_10();
  _Newsize = v7 + 1;
  v9 = (*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) / 24LL;
  v10 = v9 >> 1;
  if ( v9 > 0xAAAAAAAAAAAAAAALL - (v9 >> 1) )
    goto LABEL_19;
  _Newcapacity = _Newsize;
  if ( v10 + v9 >= _Newsize )
    _Newcapacity = v10 + v9;
  if ( _Newcapacity > 0xAAAAAAAAAAAAAAALL )
    goto LABEL_19;
  allocSize = 24 * _Newcapacity;
  if ( 24 * _Newcapacity < 0x1000 )
  {
    if ( allocSize )
      _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      _Newvec = 0;
    goto LABEL_14;
  }
  if ( allocSize + 39 < allocSize )
LABEL_19:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 39);
  if ( !v13 )
    invalid_parameter_noinfo_noreturn();
  _Newvec = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(_Newvec - 1) = v13;
LABEL_14:
  _Newvec_1 = _Newvec;
  *(_OWORD *)&_Newvec[3 * v6] = *(_OWORD *)a3;
  v16 = (double *)&_Newvec[3 * v6];
  v16[2] = *(double *)(a3 + 16);
  v17 = *(_BYTE **)(a1 + 8);
  v18 = *(_BYTE **)a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(_Newvec, v18, a2 - v18);
    _Newvec_1 = v16 + 3;
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v18 = a2;
  }
  memmove(_Newvec_1, v18, Size);
  std::vector<vraudio::ChannelView>::_Change_array(
    (std::vector<vraudio::ChannelView> *)a1,
    (vraudio::ChannelView *const)_Newvec,
    _Newsize,
    _Newcapacity);
  return v16;
}

// --- End Function: sub_1402A6C80 (0x1402A6C80) ---

// --- Function: ?_Tidy@?$vector@V?$Vector@$02N@gte@@V?$allocator@V?$Vector@$02N@gte@@@std@@@std@@AEAAXXZ (0x1402B2380) ---
void __fastcall std::vector<gte::Vector<3,double>>::_Tidy(std::vector<gte::Vector<3,double>> *this)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)this;
  if ( v2 )
  {
    if ( (unsigned __int64)(24 * ((*((_QWORD *)this + 2) - (_QWORD)v2) / 24LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)*(v2 - 1);
    }
    sub_1402A3D30(v2);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
  }
}

// --- End Function: ?_Tidy@?$vector@V?$Vector@$02N@gte@@V?$allocator@V?$Vector@$02N@gte@@@std@@@std@@AEAAXXZ (0x1402B2380) ---

// --- Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B4910) ---
std::shared_ptr<vraudio::MixerNode> *__fastcall std::shared_ptr<vraudio::MixerNode>::operator=(
        std::shared_ptr<vraudio::MixerNode> *this,
        std::shared_ptr<vraudio::MixerNode> *_Right)
{
  __int64 v2; // rax
  __int64 v4; // r8
  volatile signed __int32 *v5; // rbx

  v2 = *(_QWORD *)_Right;
  v4 = *((_QWORD *)_Right + 1);
  *(_QWORD *)_Right = 0;
  *((_QWORD *)_Right + 1) = 0;
  v5 = (volatile signed __int32 *)*((_QWORD *)this + 1);
  *(_QWORD *)this = v2;
  *((_QWORD *)this + 1) = v4;
  if ( !v5 )
    return this;
  if ( _InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
    if ( _InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
  }
  return this;
}

// --- End Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B4910) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_9 (0x1402E1F70) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E1F70) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n22 = 22;
  if ( n22 + 1 >= 0x1000 )
  {
    allocSize = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n22 == -1 )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FBA60 (0x1402FBA60) ---
__int64 __fastcall sub_1402FBA60(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  _OWORD *v3; // r14
  unsigned __int64 n0xF; // rsi
  __int64 n22; // rdi
  unsigned __int64 allocSize; // rax
  __int64 v8; // rax
  __int64 v9; // rcx

  v2 = 0;
  v3 = (_OWORD *)a2;
  *(_OWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  n0xF = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)(a2 + 24) > 0xFu )
    v3 = *(_OWORD **)a2;
  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( n0xF > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  *(_QWORD *)(a1 + 24) = 15;
  if ( n0xF > 0xF )
  {
    if ( (n0xF | 0xF) <= 0x7FFFFFFFFFFFFFFFLL )
    {
      n22 = n0xF | 0xF;
      if ( (n0xF | 0xF) < 0x16 )
        n22 = 22;
      if ( (unsigned __int64)(n22 + 1) < 0x1000 )
      {
        if ( n22 != -1 )
          v2 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
        goto LABEL_18;
      }
      allocSize = n22 + 40;
      if ( n22 + 40 < (unsigned __int64)(n22 + 1) )
        sub_1402E1170();
    }
    else
    {
      allocSize = 0x8000000000000027uLL;
    }
    v8 = allocWithProfilerInfo_w(allocSize);
    v9 = v8;
    if ( !v8 )
      invalid_parameter_noinfo_noreturn();
    v2 = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v2 - 1) = v9;
LABEL_18:
    *(_QWORD *)a1 = v2;
    *(_QWORD *)(a1 + 16) = n0xF;
    *(_QWORD *)(a1 + 24) = n22;
    memcpy(v2, v3, n0xF + 1);
    return a1;
  }
  *(_QWORD *)(a1 + 16) = n0xF;
  *(_OWORD *)a1 = *v3;
  return a1;
}

// --- End Function: sub_1402FBA60 (0x1402FBA60) ---

// --- Function: sub_1402FDB90 (0x1402FDB90) ---
unsigned __int64 __fastcall sub_1402FDB90(__int64 *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  _QWORD *v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v7 = ((__int64)v2 - *a1) / 112;
  if ( a2 < v7 )
  {
    v8 = v4 + 112 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 112 )
    {
      if ( *(_BYTE *)(i + 88) )
      {
        if ( *(_QWORD *)i )
          result = (*(__int64 (**)(void))(i + 64))();
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
    return result;
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v11 = v10 / 112;
  if ( a2 > v10 / 112 )
  {
    if ( a2 > 0x249249249249249LL )
      unknown_libname_10();
    v12 = v11 >> 1;
    if ( v11 <= 0x249249249249249LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x249249249249249LL )
          goto LABEL_29;
      }
      else
      {
        v13 = a2;
      }
      allocSize = 112 * v13;
      if ( 112 * v13 < 0x1000 )
      {
        if ( allocSize )
          v16 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
        else
          v16 = 0;
LABEL_23:
        v17 = &v16[14 * v7];
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 14;
            --v18;
          }
          while ( v18 );
        }
        sub_1402FE290(*a1, a1[1], v16);
        return sub_1402FFAF0(a1, (__int64)v16, a2, v13);
      }
      if ( allocSize + 39 >= allocSize )
      {
        v15 = allocWithProfilerInfo_w(allocSize + 39);
        if ( !v15 )
          invalid_parameter_noinfo_noreturn();
        v16 = (_QWORD *)((v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v16 - 1) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402E1170();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 14;
  }
  a1[1] = (__int64)v2;
  return result;
}

// --- End Function: sub_1402FDB90 (0x1402FDB90) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149B3B1F0 )
    result = qword_149B3B1F0(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149B3B208 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
char __fastcall sub_1403045C0(
        unsigned int n4_1,
        __int64 *a2,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  char result; // al
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned __int64 n0x10; // rax
  __int64 *v17; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v19; // r13
  char *v20; // r15
  __int64 v21; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v23; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  __int64 *v25; // rax
  __int64 *v26; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v28; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  __int64 v32; // r13
  __int64 (__fastcall *v33)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v34; // rax
  unsigned __int64 v35; // rcx
  __int64 *v36; // rdi
  _QWORD *v37; // r13
  bool v38; // zf
  _QWORD *v39; // rbx
  _QWORD *v40; // rax
  _BYTE *v41; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v44; // r9
  __int64 v45; // rcx
  __m256 *p_Src; // r14
  char *v47; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __int64 p_Src_2; // r15
  _QWORD *v51; // r14
  _QWORD *v52; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v57; // rax
  __int64 *v58; // rcx
  __int64 v59; // rcx
  _QWORD *v60; // rbx
  __int64 v61; // rcx
  __int64 *v62; // r14
  __int64 p_Src_3; // rax
  __int64 *v64; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v66; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v70; // rax
  char *v71; // r11
  unsigned __int64 _Newcapacity_1; // r10
  char *v73; // rdi
  int v74; // r13d
  __int64 v75; // rcx
  __int64 v76; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v78; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v83; // rax
  __int64 v84; // r15
  char *v85; // r14
  __int64 v86; // rax
  void *v87; // rsp
  __int64 (__fastcall *v88)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v89; // edx
  int v90; // r12d
  char v91; // cl
  int v92; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v96; // al
  bool v97; // dl
  bool v98; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v100; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v105; // rax
  void *v106; // rsp
  char v107; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v110; // rsi
  _QWORD **v111; // rcx
  _QWORD *v112; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v114; // rdi
  __int64 v115; // rcx
  __int64 *v116; // rbx
  __int64 v117; // rcx
  int v118; // [rsp+90h] [rbp-10h]
  unsigned __int8 v119; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  __int64 *v121; // [rsp+B0h] [rbp+10h]
  __int64 v122; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v124; // [rsp+C8h] [rbp+28h] BYREF
  int v125[2]; // [rsp+D0h] [rbp+30h]
  char *v126; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v130; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v132; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v134; // [rsp+118h] [rbp+78h]
  char *v135; // [rsp+120h] [rbp+80h]
  __int64 *v136; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v138; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v143; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v144; // [rsp+168h] [rbp+C8h] BYREF
  __int64 v145; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v148[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v149[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v134 = a4;
  v135 = a3;
  v136 = a2;
  n4 = n4_1;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v130 = v12;
  if ( v11 )
  {
    result = sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v144 = (__int64 *)&v143;
  n0x10 = 0;
  v143 = 0;
  v17 = 0;
  v121 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v19 = 0;
  v122 = 0;
  v20 = 0;
  n0x10_1 = 0;
  v21 = 0;
  v126 = 0;
  v124 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v73 = (char *)v149;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v23 = v119;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 89) && n0x10 < 0x10 )
    {
      v148[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v149[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v17 )
      {
        __asm { vzeroupper }
        v25 = (__int64 *)allocWithProfilerInfo_w(0x18u);
        v17 = v25;
        v121 = v25;
        if ( v25 )
        {
          v26 = v25;
          *v25 = 0;
          n0x400_1 = 0;
          v25[1] = 0;
          v28 = (__int64)v25;
          v25[2] = 0;
        }
        else
        {
          v17 = 0;
          v26 = 0;
          n0x400_1 = 0;
          v121 = 0;
          v28 = 0;
        }
        sub_1403044D0(v28, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v149;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v26[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v26[2] )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              (std::vector<vraudio::AudioBuffer const *> *)v17,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v26[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v21 = v124;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v17[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v17[2] )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          (std::vector<vraudio::AudioBuffer const *> *)v17,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        v17[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v122 = *((_QWORD *)__Val_0___1 + 13) + v19;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v144, __Val_0___1, v14, v15);
    v32 = v21;
    v33 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v145 = v21++;
    v124 = v21;
    if ( !v33 )
    {
      v71 = v126;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v132 = 0;
    v34 = v33(*(_QWORD *)__Val_0___1, &v132, &__Val_0___4);
    v35 = 0;
    *(_QWORD *)v125 = 0;
    if ( !v132 )
      goto LABEL_94;
    v36 = v144;
    v37 = (_QWORD *)(v34 + 16);
    v138 = (_QWORD *)(v34 + 16);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v37 - 2);
      __Val_0___5 = (vraudio::AudioBuffer *)(v37 - 2);
      v38 = *v37 == 0;
      v124 = v21 + 1;
      v37[8] = v21;
      if ( v38 )
      {
        v60 = (_QWORD *)*(v37 - 1);
        v62 = 0;
      }
      else
      {
        if ( !*v36 )
        {
          __asm { vzeroupper }
          v39 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v39 )
          {
            *v39 = 0;
            v39[1] = 0;
            v40 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v40 = v40;
            v40[1] = v40;
            *v39 = v40;
          }
          else
          {
            v39 = 0;
          }
          *v36 = (__int64)v39;
        }
        v41 = (_BYTE *)*(v37 - 1);
        Size = -1;
        memset(&Src, 0, sizeof(Src));
        Size_1 = -1;
        do
          ++Size_1;
        while ( v41[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v41, Size_1, v15);
        v44 = (_BYTE *)*v37;
        do
          ++Size;
        while ( v44[Size] );
        v45 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v23, v44, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v47 = (char *)p_Src + v45;
          memmove(v47, v44, Size);
          v47[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v36;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(_QWORD *)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v51 = *(_QWORD **)__Val_0___7;
        v52 = **(_QWORD ***)__Val_0___7;
        if ( v52 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v52[4];
          Buf1 = v52 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = (__m256 *)p_Src_2;
          if ( v52[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v52 = (_QWORD *)*v52;
        }
        while ( v52 != v51 );
        __Val_0___7 = __Val_0___6;
        if ( v52 == v51 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v57 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v57 + 32) = 0;
          *(_QWORD *)(v57 + 40) = 0;
          *(__m256 *)(v57 + 16) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v58 = (__int64 *)v51[1];
          *(_QWORD *)v57 = v51;
          *(_QWORD *)(v57 + 8) = v58;
          v51[1] = v57;
          *v58 = v57;
          v59 = *(_QWORD *)*v36;
          v60 = (_QWORD *)(*(_QWORD *)(v59 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v59 + 8) + 40LL) > 0xFu )
            v60 = (_QWORD *)*v60;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v61 = *(_QWORD *)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v61 = *(_QWORD *)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - v61 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v61);
          }
LABEL_66:
          v17 = v121;
          v62 = 0;
          v37 = v138;
          __Val_0___3 = __Val_0___5;
          v35 = *(_QWORD *)v125;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          goto LABEL_74;
        }
        v60 = v52 + 2;
        if ( v60[3] > 0xFu )
          v60 = (_QWORD *)*v60;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
          if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v17 = v121;
        v62 = 0;
        v37 = v138;
        __Val_0___3 = __Val_0___5;
        v35 = *(_QWORD *)v125;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 15;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v60;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v17 )
        {
          __asm { vzeroupper }
          v64 = (__int64 *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v121 = v64;
          v17 = v64;
          if ( v64 )
          {
            *v64 = 0;
            v66 = (__int64)v64;
            v64[1] = 0;
            v64[2] = 0;
            v62 = v64;
          }
          else
          {
            v17 = 0;
            v121 = 0;
            v66 = 0;
          }
          sub_1403044D0(v66, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v149;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v62[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v62[2] )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                (std::vector<vraudio::AudioBuffer const *> *)v17,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v62[1] += 8;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v17[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v17[2] )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            (std::vector<vraudio::AudioBuffer const *> *)v17,
            _Whereptr_3,
            &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          v17[1] += 8;
        }
        v35 = *(_QWORD *)v125;
      }
      else
      {
        v149[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v35;
      v70 = v37[11] + v122;
      v37 += 14;
      v21 = v124;
      v122 = v70;
      *(_QWORD *)v125 = v35;
      v138 = v37;
    }
    while ( v35 < v132 );
    __Val_0___1 = __Val_0___2;
    v32 = v145;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v32 = -1;
    v71 = &v126[__Val_0___4];
    v126 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 112);
    v14 = v122;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 10) = v32;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v19 = v14;
      continue;
    }
    break;
  }
  v20 = v71;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  v126 = v71;
  if ( !v17 )
    goto LABEL_105;
  if ( !((v17[1] - *v17) >> 3) )
    __debugbreak();
  v73 = (char *)*v17;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v126 = v71;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v73, (unsigned __int64)&v73[8 * n0x400], (__int64)(8 * n0x400) >> 3, v119);
  v74 = 0;
  v75 = 0;
  v76 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v78 = *(_QWORD *)&v73[8 * n0x400_3];
    if ( v76 == *(_QWORD *)(v78 + 8) )
    {
      if ( ++v75 == 1 )
        *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3 - 8] + 80LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 80LL) = v75;
    }
    else
    {
      v75 = 0;
      *(_QWORD *)(v78 + 80) = -(__int64)(*(_QWORD *)(v78 + 80) != -1);
      v76 = *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v20 + 1) << 10;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v84 = 0;
  }
  else
  {
    v83 = allocWithProfilerInfo_w(n0x8000_2);
    v84 = v83;
    if ( v83 )
    {
      v85 = (char *)v83;
      goto LABEL_130;
    }
  }
  v86 = n0x8000_2 + 15;
  if ( n0x8000_2 + 15 < n0x8000_2 )
    v86 = 0xFFFFFFFFFFFFFF0LL;
  v87 = alloca(v86 & 0xFFFFFFFFFFFFFFF0uLL);
  v85 = (char *)&v119;
LABEL_130:
  v88 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v89 = 1;
  *v85 = 0;
  v90 = 0;
  LODWORD(v124) = 0;
  v125[0] = 1;
  if ( v88 && qword_149B3B200 && byte_149924748 )
  {
    v89 = v88(v130, n4, v135, v136, v134, __Val_0__, _Newcapacity, v148, n0x10_1, &a8);
    v125[0] = v89;
  }
  v91 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v92 = sub_140302340(
            *(_QWORD *)&FileTime,
            v130,
            (__int64)String,
            n4,
            v136,
            v135,
            v134,
            __Val_0__,
            _Newcapacity,
            a7,
            v85,
            n0x8000_2,
            (int *)&v124,
            v89,
            &a8);
    v91 = a8;
    v90 = v92;
    v74 = v124;
  }
  if ( n2_125 == 1 && (v91 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v85);
    v91 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v91 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v85);
    n2_126 = ::n2_126;
  }
  v85[v90] = 0;
  v96 = a8;
  v97 = (a8 & 1) != 0 && n2_125 == 2;
  v98 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v97 || v98 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v100 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v100 = v122 + v90 + ((_QWORD)(v126 + 4) << 9);
    n0x8000_3 = v100 + 128;
    if ( *p_n0x8000_1 < v100 + 128 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v105 = n0x8000_3 + 15;
    if ( n0x8000_3 + 15 < n0x8000_3 )
      v105 = 0xFFFFFFFFFFFFFF0LL;
    v106 = alloca(v105 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v119;
LABEL_166:
    v118 = v125[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v130,
      Buffer,
      String,
      n4,
      v136,
      v135,
      v134,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v73,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 128,
      (__int64)&v85[v74],
      v90 - v74,
      a8,
      v118);
    sub_1402A3D30(Buffer_3);
    v96 = a8;
  }
  v107 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v96 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v96 = a8;
      v107 = byte_149B3AEA8;
    }
    if ( v107 )
    {
      if ( (v96 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A3D30(v84);
  v110 = v143;
  if ( v143 )
  {
    v111 = (_QWORD **)*v143;
    **(_QWORD **)(*v143 + 8) = 0;
    v112 = *v111;
    if ( *v111 )
    {
      do
      {
        n0xF_1 = v112[5];
        v114 = (_QWORD *)*v112;
        if ( n0xF_1 > 0xF )
        {
          v115 = v112[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v115 - *(_QWORD *)(v115 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v115 = *(_QWORD *)(v115 - 8);
          }
          sub_1402A3D30(v115);
        }
        v112[4] = 0;
        v112[5] = 15;
        *((_BYTE *)v112 + 16) = 0;
        sub_1402A3D30((__int64)v112);
        v112 = v114;
      }
      while ( v114 );
    }
    sub_1402A3D30(*v110);
    result = sub_1402A3D30((__int64)v110);
  }
  v116 = v121;
  if ( v121 )
  {
    v117 = *v121;
    if ( *v121 )
    {
      if ( ((v121[2] - v117) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v117 - *(_QWORD *)(v117 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v117 = *(_QWORD *)(v117 - 8);
      }
      sub_1402A3D30(v117);
      *v116 = 0;
      v116[1] = 0;
      v116[2] = 0;
    }
    return sub_1402A3D30((__int64)v116);
  }
  return result;
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: sub_1403515F0 (0x1403515F0) ---
char __fastcall sub_1403515F0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v10; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n256; // [rsp+88h] [rbp-18h]
  __int64 n176; // [rsp+90h] [rbp-10h]
  __int64 n168; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = sub_1403E4B50;
  LODWORD(v10) = a6;
  n256 = 256;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[10] = -1;
  n176 = 176;
  n168 = 168;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 1u, a5, v10, a7, a8);
}

// --- End Function: sub_1403515F0 (0x1403515F0) ---

// --- Function: sub_14035AE20 (0x14035AE20) ---
_QWORD *__fastcall sub_14035AE20(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  void (__fastcall *v4)(__int64, _QWORD *, _QWORD *); // rax
  void (__fastcall *n2)(__int64, _QWORD *); // rax

  v2 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = (void (__fastcall *)(__int64, _QWORD *, _QWORD *))a2[1];
  if ( v4 == (void (__fastcall *)(__int64, _QWORD *, _QWORD *))1 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
    n2 = (void (__fastcall *)(__int64, _QWORD *))a2[1];
    if ( (unsigned __int64)n2 >= 2 )
      goto LABEL_7;
    goto LABEL_8;
  }
  if ( v4 )
  {
    v4(1, a1, a2);
    n2 = (void (__fastcall *)(__int64, _QWORD *))v2[1];
    if ( (unsigned __int64)n2 >= 2 )
    {
      a2 = v2;
LABEL_7:
      n2(2, a2);
      v2[1] = 0;
    }
LABEL_8:
    *v2 = 0;
  }
  return a1;
}

// --- End Function: sub_14035AE20 (0x14035AE20) ---

// --- Function: sub_14035B140 (0x14035B140) ---
_QWORD *__fastcall sub_14035B140(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149B3B33C + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035B140 (0x14035B140) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_140370B50 (0x140370B50) ---
__int64 __fastcall sub_140370B50(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx

  v1 = *(volatile signed __int32 **)(a1 + 24);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v4 = *(volatile signed __int32 **)(a1 + 8);
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
  }
  return result;
}

// --- End Function: sub_140370B50 (0x140370B50) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_1403778D0 (0x1403778D0) ---
__int64 __fastcall sub_1403778D0(_QWORD *a1)
{
  unsigned __int64 n0xF; // rdx
  _QWORD *v3; // rcx
  __int64 result; // rax
  unsigned __int64 n0xF_1; // rdx
  const void *v6; // rcx

  n0xF = a1[8];
  if ( n0xF > 0xF )
  {
    v3 = (_QWORD *)a1[5];
    if ( n0xF + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - *(v3 - 1) - 8 > 0x1F )
        goto LABEL_12;
      v3 = (_QWORD *)*(v3 - 1);
    }
    result = sub_1402A3D30(v3);
  }
  a1[7] = 0;
  a1[8] = 15;
  *((_BYTE *)a1 + 40) = 0;
  n0xF_1 = a1[4];
  if ( n0xF_1 > 0xF )
  {
    v6 = (const void *)a1[1];
    if ( n0xF_1 + 1 < 0x1000 )
    {
LABEL_10:
      result = sub_1402A3D30(v6);
      goto LABEL_11;
    }
    if ( (unsigned __int64)v6 - *((_QWORD *)v6 - 1) - 8 <= 0x1F )
    {
      v6 = (const void *)*((_QWORD *)v6 - 1);
      goto LABEL_10;
    }
LABEL_12:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  a1[3] = 0;
  a1[4] = 15;
  *((_BYTE *)a1 + 8) = 0;
  return result;
}

// --- End Function: sub_1403778D0 (0x1403778D0) ---

// --- Function: sub_140377C70 (0x140377C70) ---
_QWORD *__fastcall sub_140377C70(_QWORD *a1, _QWORD *a2)
{
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  void (__fastcall *v5)(__int64, _QWORD *, _QWORD *); // rax
  void (__fastcall *n2_1)(__int64, _QWORD *); // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a1[1];
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1, 0);
    a1[1] = 0;
  }
  *a1 = 0;
  v5 = (void (__fastcall *)(__int64, _QWORD *, _QWORD *))a2[1];
  if ( v5 == (void (__fastcall *)(__int64, _QWORD *, _QWORD *))1 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
  }
  else
  {
    if ( !v5 )
      return a1;
    v5(1, a1, a2);
  }
  n2_1 = (void (__fastcall *)(__int64, _QWORD *))a2[1];
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, a2);
    a2[1] = 0;
  }
  *a2 = 0;
  return a1;
}

// --- End Function: sub_140377C70 (0x140377C70) ---

// --- Function: sub_140398C70 (0x140398C70) ---
void __fastcall sub_140398C70(int a1, _QWORD *a2, _QWORD *a3)
{
  int v5; // ecx
  _QWORD *v6; // rbp
  volatile signed __int32 *v7; // rbx
  __int64 v8; // rax

  if ( a1 )
  {
    v5 = a1 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v6 = (_QWORD *)a2[2];
        if ( v6 )
        {
          v7 = (volatile signed __int32 *)v6[1];
          if ( v7 && _InterlockedExchangeAdd(v7 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
            if ( _InterlockedExchangeAdd(v7 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8LL))(v7);
          }
          sub_1402A3D30(v6);
        }
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
      return;
    }
  }
  else
  {
    LogFatalError("Can not request a copy for a CigMoveOnlyFunction, something's broken in the implementation");
  }
  if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      v8 = 1;
    }
    else
    {
      a2[2] = a3[2];
      *a2 = *a3;
      v8 = a3[1];
    }
    a2[1] = v8;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
  }
}

// --- End Function: sub_140398C70 (0x140398C70) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 16) & (unsigned int)(v9 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 = (v5 << 16) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 284) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 216LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 sub_1403E4B50()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4C70 (0x1403E4C70) ---
__int64 __fastcall sub_1403E4C70(__int64 a1)
{
  __int64 result; // rax

  result = allocWithProfilerInfo_w(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 16) = *(double *)(a1 + 16);
  }
  return result;
}

// --- End Function: sub_1403E4C70 (0x1403E4C70) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
__int64 __fastcall sub_1403E4E60(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4EB0 (0x1403E4EB0) ---
__int64 __fastcall sub_1403E4EB0(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4EB0 (0x1403E4EB0) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403EAFB0 (0x1403EAFB0) ---
__int64 __fastcall sub_1403EAFB0(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 16) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 34;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      v6 = sub_14035AA80((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    *a2 = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FE6B0((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
    return 0xFFFFFFFFLL;
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
    return 0xFFFFFFFFLL;
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 34;
    }
    else
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403EAFB0 (0x1403EAFB0) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n12; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12 = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 = 12;
      if ( (int)n12_1 <= 12 )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n12 + a2), n12_1 - (unsigned int)n12);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v8;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 19;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v10;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 18;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12 += v14;
    if ( n12 < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n12 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return (unsigned int)-1;
  return (unsigned int)n12;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB550 (0x1403EB550) ---
__int64 __fastcall sub_1403EB550(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 16) )
    return sub_14035AA80(a2, a3, 0, v3);
  else
    return sub_1402FE6B0(a2, a3, 0, v3);
}

// --- End Function: sub_1403EB550 (0x1403EB550) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: sub_1403FD8C0 (0x1403FD8C0) ---
_BYTE *__fastcall sub_1403FD8C0(__int64 a1, _QWORD *a2, unsigned __int8 *a3)
{
  __int64 v4; // rax
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  const char *p_integer; // r8
  size_t *v10; // rax
  _BYTE *v11; // rcx
  size_t n511_2; // rbx
  const void *v13; // rsi
  _BYTE *v14; // rax
  const char *p_UNDEFINED_1; // rbx
  int v16; // eax
  const char *p_UNDEFINED; // r8
  size_t *v18; // rax
  _BYTE *v19; // rcx
  size_t n511_6; // rsi
  const void *v21; // r15
  _BYTE *v22; // rax
  const char *v23; // r13
  int v24; // eax
  size_t *v25; // rax
  _BYTE *v26; // rcx
  size_t n511_10; // rbx
  const void *v28; // r14
  _BYTE *v29; // rax
  const char *v30; // r15
  const char *_:__3; // r12
  size_t *v32; // rax
  char *v33; // rcx
  size_t n511_14; // rbx
  const void *v35; // r14
  const char *v36; // rax
  _BYTE *result; // rax
  const char *v38; // [rsp+70h] [rbp-90h]
  const char *_:_; // [rsp+78h] [rbp-88h]
  const char *v40; // [rsp+80h] [rbp-80h]
  const char *_:__1; // [rsp+88h] [rbp-78h]
  const char *_:__2; // [rsp+90h] [rbp-70h]
  __int64 n511_13; // [rsp+A8h] [rbp-58h]
  const char *v45; // [rsp+B0h] [rbp-50h]
  _BYTE v46[520]; // [rsp+B8h] [rbp-48h] BYREF
  size_t n511_11; // [rsp+2C0h] [rbp+1C0h]
  __int64 n511_9; // [rsp+2C8h] [rbp+1C8h]
  void *v49; // [rsp+2D0h] [rbp+1D0h]
  _BYTE v50[520]; // [rsp+2D8h] [rbp+1D8h] BYREF
  size_t n511_7; // [rsp+4E0h] [rbp+3E0h]
  __int64 n511_5; // [rsp+4E8h] [rbp+3E8h]
  void *v53; // [rsp+4F0h] [rbp+3F0h]
  _BYTE v54[520]; // [rsp+4F8h] [rbp+3F8h] BYREF
  size_t n511_3; // [rsp+700h] [rbp+600h]
  __int64 n511_1; // [rsp+708h] [rbp+608h]
  void *v57; // [rsp+710h] [rbp+610h]
  _BYTE v58[520]; // [rsp+718h] [rbp+618h] BYREF
  __int64 v59; // [rsp+920h] [rbp+820h] BYREF
  __int64 n511; // [rsp+928h] [rbp+828h]
  _BYTE *v61; // [rsp+930h] [rbp+830h]
  _BYTE v62[520]; // [rsp+938h] [rbp+838h] BYREF
  __int64 v63; // [rsp+B40h] [rbp+A40h] BYREF
  __int64 n511_4; // [rsp+B48h] [rbp+A48h]
  _BYTE *v65; // [rsp+B50h] [rbp+A50h]
  _BYTE v66[520]; // [rsp+B58h] [rbp+A58h] BYREF
  __int64 v67; // [rsp+D60h] [rbp+C60h] BYREF
  __int64 n511_8; // [rsp+D68h] [rbp+C68h]
  _BYTE *v69; // [rsp+D70h] [rbp+C70h]
  _BYTE v70[520]; // [rsp+D78h] [rbp+C78h] BYREF
  __int64 v71; // [rsp+F80h] [rbp+E80h] BYREF
  __int64 n511_12; // [rsp+F88h] [rbp+E88h]
  _BYTE *v73; // [rsp+F90h] [rbp+E90h]
  _BYTE v74[520]; // [rsp+F98h] [rbp+E98h] BYREF
  char v75[8]; // [rsp+11A0h] [rbp+10A0h] BYREF
  __int64 v76; // [rsp+11A8h] [rbp+10A8h]
  _BYTE *v77; // [rsp+11B0h] [rbp+10B0h]
  _BYTE v78[520]; // [rsp+11B8h] [rbp+10B8h] BYREF

  if ( *a2 )
    sub_1402A3C90(a2);
  v4 = sub_140407C50((__int64)a3, (__int64)v75);
  v5 = a3[8];
  v62[0] = 0;
  v59 = 0;
  v38 = *(const char **)(v4 + 16);
  _:_ = __;                                     // ":"
  v61 = v62;
  n511 = 511;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          if ( v8 == 1 )
            p_integer = "string";
          else
            p_integer = "UNDEFINED";
        }
        else
        {
          p_integer = "uuid";
        }
      }
      else
      {
        p_integer = "geid";
      }
    }
    else
    {
      p_integer = "numeric";
    }
  }
  else
  {
    p_integer = "integer";
  }
  v10 = (size_t *)sub_1402A3190((__int64)&v59, (const char *)&Format_, p_integer);
  v58[0] = 0;
  v11 = v58;
  v57 = v58;
  n511_3 = 0;
  n511_1 = 511;
  n511_2 = *v10;
  v13 = (const void *)v10[2];
  if ( *v10 > 0x1FF )
  {
    v14 = v58;
    if ( n511_2 + 1 > 0x200 )
    {
      v14 = (_BYTE *)allocWithProfilerInfo(n511_2 + 1, 0);
      qword_149B3AB68 += n511_2 + 1;
      n511_1 = n511_2;
    }
    v57 = v14;
    n511_3 = n511_2;
    v14[n511_2] = 0;
    v11 = v57;
  }
  memmove(v11, v13, n511_2);
  n511_3 = n511_2;
  *((_BYTE *)v57 + n511_2) = 0;
  if ( v61 != v62 )
  {
    qword_149B3AB68 += -1 - n511;
    sub_147605980(v61);
  }
  p_UNDEFINED_1 = "mission";
  v40 = (const char *)v57;
  _:__1 = __;                                   // ":"
  v65 = v66;
  v16 = a3[1];
  v66[0] = 0;
  v63 = 0;
  n511_4 = 511;
  switch ( v16 )
  {
    case 0:
      p_UNDEFINED = "group";
      break;
    case 1:
      p_UNDEFINED = "squad";
      break;
    case 2:
      p_UNDEFINED = "invite";
      break;
    case 3:
      p_UNDEFINED = "lobby";
      break;
    case 4:
      p_UNDEFINED = "message";
      break;
    case 5:
      p_UNDEFINED = "channel";
      break;
    case 6:
      p_UNDEFINED = "call";
      break;
    case 7:
      p_UNDEFINED = "team";
      break;
    case 8:
      p_UNDEFINED = "org";
      break;
    case 9:
      p_UNDEFINED = "member";
      break;
    case 10:
      p_UNDEFINED = "rank";
      break;
    case 11:
      p_UNDEFINED = "account";
      break;
    case 12:
      p_UNDEFINED = "reputation";
      break;
    case 13:
      p_UNDEFINED = "reputationContext";
      break;
    case 14:
      p_UNDEFINED = "item";
      break;
    case 15:
      p_UNDEFINED = "player";
      break;
    case 16:
      p_UNDEFINED = "npc";
      break;
    case 17:
      p_UNDEFINED = "match";
      break;
    case 18:
      p_UNDEFINED = "root";
      break;
    case 19:
      p_UNDEFINED = "entityclass";
      break;
    case 20:
      p_UNDEFINED = "entitlement";
      break;
    case 21:
      p_UNDEFINED = "ltp";
      break;
    case 22:
      p_UNDEFINED = "customLobby";
      break;
    case 23:
      p_UNDEFINED = "location";
      break;
    case 24:
      p_UNDEFINED = "shard";
      break;
    case 25:
      p_UNDEFINED = "vehicle";
      break;
    case 26:
      p_UNDEFINED = "mission";
      break;
    default:
      p_UNDEFINED = "UNDEFINED";
      break;
  }
  v18 = (size_t *)sub_1402A3190((__int64)&v63, (const char *)&Format_, p_UNDEFINED);
  v54[0] = 0;
  v19 = v54;
  v53 = v54;
  n511_7 = 0;
  n511_5 = 511;
  n511_6 = *v18;
  v21 = (const void *)v18[2];
  if ( *v18 > 0x1FF )
  {
    v22 = v54;
    if ( n511_6 + 1 > 0x200 )
    {
      v22 = (_BYTE *)allocWithProfilerInfo(n511_6 + 1, 0);
      qword_149B3AB68 += n511_6 + 1;
      n511_5 = n511_6;
    }
    v53 = v22;
    n511_7 = n511_6;
    v22[n511_6] = 0;
    v19 = v53;
  }
  memmove(v19, v21, n511_6);
  n511_7 = n511_6;
  *((_BYTE *)v53 + n511_6) = 0;
  if ( v65 != v66 )
  {
    qword_149B3AB68 += -1 - n511_4;
    sub_147605980(v65);
  }
  v23 = (const char *)v53;
  _:__2 = __;                                   // ":"
  v69 = v70;
  v24 = *a3;
  v70[0] = 0;
  v67 = 0;
  n511_8 = 511;
  switch ( v24 )
  {
    case 0:
      p_UNDEFINED_1 = "global";
      break;
    case 1:
      p_UNDEFINED_1 = "groups";
      break;
    case 2:
      p_UNDEFINED_1 = "lobbies";
      break;
    case 3:
      p_UNDEFINED_1 = "voice";
      break;
    case 4:
      p_UNDEFINED_1 = "teams";
      break;
    case 5:
      p_UNDEFINED_1 = "orgs";
      break;
    case 6:
      p_UNDEFINED_1 = "platform";
      break;
    case 7:
      p_UNDEFINED_1 = "reputations";
      break;
    case 8:
      p_UNDEFINED_1 = "persistence";
      break;
    case 9:
      p_UNDEFINED_1 = "entitygraph";
      break;
    case 10:
      p_UNDEFINED_1 = "social";
      break;
    case 11:
      p_UNDEFINED_1 = "unattendedVehicle";
      break;
    case 12:
      p_UNDEFINED_1 = "corpse";
      break;
    case 13:
      break;
    case 14:
      p_UNDEFINED_1 = "quantumtracepoint";
      break;
    default:
      p_UNDEFINED_1 = "UNDEFINED";
      break;
  }
  v25 = (size_t *)sub_1402A3190((__int64)&v67, (const char *)&Format_, p_UNDEFINED_1);
  v50[0] = 0;
  v26 = v50;
  v49 = v50;
  n511_11 = 0;
  n511_9 = 511;
  n511_10 = *v25;
  v28 = (const void *)v25[2];
  if ( *v25 > 0x1FF )
  {
    v29 = v50;
    if ( n511_10 + 1 > 0x200 )
    {
      v29 = (_BYTE *)allocWithProfilerInfo(n511_10 + 1, 0);
      qword_149B3AB68 += n511_10 + 1;
      n511_9 = n511_10;
    }
    v49 = v29;
    n511_11 = n511_10;
    v29[n511_10] = 0;
    v26 = v49;
  }
  memmove(v26, v28, n511_10);
  n511_11 = n511_10;
  *((_BYTE *)v49 + n511_10) = 0;
  if ( v69 != v70 )
  {
    qword_149B3AB68 += -1 - n511_8;
    sub_147605980(v69);
  }
  v30 = (const char *)v49;
  _:__3 = __;                                   // ":"
  v73 = v74;
  v74[0] = 0;
  v71 = 0;
  n511_12 = 511;
  v32 = (size_t *)sub_1402A3190((__int64)&v71, (const char *)&Format_, "sc");
  v46[0] = 0;
  v33 = v46;
  v45 = v46;
  n511_13 = 511;
  n511_14 = *v32;
  v35 = (const void *)v32[2];
  if ( *v32 > 0x1FF )
  {
    v36 = v46;
    if ( n511_14 + 1 > 0x200 )
    {
      v36 = (const char *)allocWithProfilerInfo(n511_14 + 1, 0);
      qword_149B3AB68 += n511_14 + 1;
      n511_13 = n511_14;
    }
    v45 = v36;
    v36[n511_14] = 0;
    v33 = (char *)v36;
  }
  memmove(v33, v35, n511_14);
  v45[n511_14] = 0;
  if ( v73 != v74 )
  {
    qword_149B3AB68 += -1 - n511_12;
    sub_147605980(v73);
  }
  sub_1402A3190(
    (__int64)a2,
    "%s%s%s%s%s%s%s%s%s%s%s",
    (const char *)off_149926260,
    __,                                         // ":"
    v45,
    _:__3,
    v30,
    _:__2,
    v23,
    _:__1,
    v40,
    _:_,
    v38);
  if ( v45 != v46 )
  {
    qword_149B3AB68 += -1 - n511_13;
    sub_147605980(v45);
  }
  if ( v49 != v50 )
  {
    qword_149B3AB68 += -1 - n511_9;
    sub_147605980(v49);
  }
  if ( v53 != v54 )
  {
    qword_149B3AB68 += -1 - n511_5;
    sub_147605980(v53);
  }
  if ( v57 != v58 )
  {
    qword_149B3AB68 += -1 - n511_1;
    sub_147605980(v57);
  }
  result = v78;
  if ( v77 != v78 )
  {
    qword_149B3AB68 += -1 - v76;
    return (_BYTE *)sub_147605980(v77);
  }
  return result;
}

// --- End Function: sub_1403FD8C0 (0x1403FD8C0) ---

// --- Function: sub_140400EF0 (0x140400EF0) ---
__int64 __fastcall sub_140400EF0(unsigned __int8 *a1, __int64 a2)
{
  *(_BYTE *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 16) = a2 + 24;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 511;
  sub_1403FD8C0((__int64)a1, (_QWORD *)a2, a1);
  return a2;
}

// --- End Function: sub_140400EF0 (0x140400EF0) ---

// --- Function: sub_14040A6B0 (0x14040A6B0) ---
__int64 __fastcall sub_14040A6B0(__int64 a1, __int64 a2)
{
  char n3; // al
  char v5; // al
  __int64 result; // rax

  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_WORD *)a1 = 3840;
  *(_BYTE *)(a1 + 8) = 2;
  n3 = *(_BYTE *)(a1 + 32);
  if ( n3 == 3 )
  {
    *(_QWORD *)(a1 + 16) = a2;
    return a1;
  }
  else
  {
    if ( n3 )
    {
      v5 = n3 - 1;
      if ( v5 )
      {
        if ( (unsigned __int8)(v5 - 1) >= 2u )
          sub_140370D10((_QWORD *)(a1 + 16));
      }
    }
    *(_BYTE *)(a1 + 32) = 3;
    result = a1;
    *(_QWORD *)(a1 + 16) = a2;
  }
  return result;
}

// --- End Function: sub_14040A6B0 (0x14040A6B0) ---

// --- Function: sub_140454430 (0x140454430) ---
__int64 __fastcall sub_140454430(__int64 a1, int a2)
{
  unsigned __int64 n0x1000; // rsi
  __int64 v5; // rax
  _QWORD *v6; // rbx
  _QWORD *v7; // r8
  __int64 v8; // r9
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r14
  __int64 v11; // r15
  __int64 v12; // rax
  unsigned __int64 v13; // rsi
  __int64 v14; // r8
  __int64 v15; // rcx
  unsigned __int64 v16; // rdx
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 i; // rbp
  const void *v21; // r8

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  if ( a2 )
  {
    if ( (unsigned __int64)a2 > 0xAAAAAAAAAAAAAAALL )
      unknown_libname_10();
    n0x1000 = 24LL * a2;
    if ( n0x1000 < 0x1000 )
    {
      if ( n0x1000 )
        v6 = (_QWORD *)allocWithProfilerInfo_w(24LL * a2);
      else
        v6 = 0;
    }
    else
    {
      if ( n0x1000 + 39 < n0x1000 )
        goto LABEL_41;
      v5 = allocWithProfilerInfo_w(n0x1000 + 39);
      if ( !v5 )
        goto LABEL_40;
      v6 = (_QWORD *)((v5 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v6 - 1) = v5;
    }
    memmove(v6, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    v7 = *(_QWORD **)a1;
    if ( *(_QWORD *)a1 )
    {
      if ( (unsigned __int64)(24 * ((*(_QWORD *)(a1 + 16) - (_QWORD)v7) / 24LL)) >= 0x1000 )
      {
        if ( (unsigned __int64)v7 - *(v7 - 1) - 8 > 0x1F )
          goto LABEL_40;
        v7 = (_QWORD *)*(v7 - 1);
      }
      sub_1402A3D30(v7);
    }
    *(_QWORD *)a1 = v6;
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = &v6[n0x1000 / 8];
  }
  v8 = *(_QWORD *)(a1 + 24);
  v9 = 3 * a2;
  if ( v9 > (*(_QWORD *)(a1 + 40) - v8) / 112 )
  {
    if ( v9 > 0x249249249249249LL )
      unknown_libname_10();
    v10 = 112 * v9;
    v11 = (*(_QWORD *)(a1 + 32) - v8) / 112;
    if ( 112 * v9 < 0x1000 )
    {
      if ( v10 )
        v13 = allocWithProfilerInfo_w(112 * v9);
      else
        v13 = 0;
      goto LABEL_25;
    }
    if ( v10 + 39 >= v10 )
    {
      v12 = allocWithProfilerInfo_w(v10 + 39);
      if ( !v12 )
        goto LABEL_40;
      v13 = (v12 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v13 - 8) = v12;
LABEL_25:
      v14 = *(_QWORD *)(a1 + 32);
      v15 = *(_QWORD *)(a1 + 24);
      if ( v15 != v14 )
      {
        v16 = v13 + 16;
        do
        {
          *(_QWORD *)(v16 - 16) = 0;
          v16 += 112LL;
          *(_QWORD *)(v16 - 128) = *(_QWORD *)v15;
          v17 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)v15 = 0;
          *(_QWORD *)(v16 - 120) = v17;
          *(_QWORD *)(v16 - 112) = *(_QWORD *)(v15 + 16);
          *(_QWORD *)(v16 - 104) = *(_QWORD *)(v15 + 24);
          *(_QWORD *)(v16 - 96) = *(_QWORD *)(v15 + 32);
          *(_QWORD *)(v16 - 80) = *(_QWORD *)(v15 + 48);
          *(_QWORD *)(v16 - 88) = *(_QWORD *)(v15 + 40);
          *(_QWORD *)(v16 - 72) = *(_QWORD *)(v15 + 56);
          *(_QWORD *)(v16 - 64) = *(_QWORD *)(v15 + 64);
          *(_QWORD *)(v16 - 56) = *(_QWORD *)(v15 + 72);
          *(_QWORD *)(v16 - 48) = *(_QWORD *)(v15 + 80);
          *(_BYTE *)(v16 - 40) = *(_BYTE *)(v15 + 88);
          *(_BYTE *)(v16 - 39) = *(_BYTE *)(v15 + 89);
          *(_QWORD *)(v16 - 32) = *(_QWORD *)(v15 + 96);
          v18 = *(_QWORD *)(v15 + 104);
          v15 += 112;
          *(_QWORD *)(v16 - 24) = v18;
        }
        while ( v15 != v14 );
      }
      v19 = *(_QWORD *)(a1 + 24);
      if ( !v19 )
        goto LABEL_38;
      for ( i = *(_QWORD *)(a1 + 32); v19 != i; v19 += 112 )
      {
        if ( *(_BYTE *)(v19 + 88) && *(_QWORD *)v19 )
          (*(void (**)(void))(v19 + 64))();
      }
      v21 = *(const void **)(a1 + 24);
      if ( (unsigned __int64)(112 * ((*(_QWORD *)(a1 + 40) - (_QWORD)v21) / 112LL)) < 0x1000 )
      {
LABEL_37:
        sub_1402A3D30(v21);
LABEL_38:
        *(_QWORD *)(a1 + 24) = v13;
        *(_QWORD *)(a1 + 32) = v13 + 112 * v11;
        *(_QWORD *)(a1 + 40) = v13 + v10;
        return a1;
      }
      if ( (unsigned __int64)v21 - *((_QWORD *)v21 - 1) - 8 <= 0x1F )
      {
        v21 = (const void *)*((_QWORD *)v21 - 1);
        goto LABEL_37;
      }
LABEL_40:
      invalid_parameter_noinfo_noreturn();
    }
LABEL_41:
    sub_1402E1170();
  }
  return a1;
}

// --- End Function: sub_140454430 (0x140454430) ---

// --- Function: sub_140462B30 (0x140462B30) ---
__int64 __fastcall sub_140462B30(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rdi
  _QWORD *v4; // r8
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; v1 += 14 )
    {
      if ( *((_BYTE *)v1 + 88) && *v1 )
        ((void (*)(void))v1[8])();
    }
    v4 = (_QWORD *)*a1;
    if ( (unsigned __int64)(112 * ((a1[2] - *a1) / 112)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)*(v4 - 1);
    }
    sub_1402A3D30(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140462B30 (0x140462B30) ---

// --- Function: sub_1404AEB30 (0x1404AEB30) ---
unsigned __int8 *__fastcall sub_1404AEB30(GUID *a1)
{
  unsigned __int8 *result; // rax
  GUID v3; // [rsp+20h] [rbp-28h] BYREF

  sub_140402BA0(&v3);
  result = &a1->Data4[7];
  if ( a1 > (GUID *)&v3.Data4[7] || result < (unsigned __int8 *)&v3 )
    *a1 = v3;
  else
    *a1 = v3;
  return result;
}

// --- End Function: sub_1404AEB30 (0x1404AEB30) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1480BE950, v3);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n15; // rax

  v0 = sub_1404B3EA0();
  v1 = v0;
  if ( !v0 )
    return &dword_149B45F40;
  n15 = *v0;
  if ( n15 > 0xF )
    n15 = 15;
  return (__int64 *)&v1[22 * n15 + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_1404D06B0 (0x1404D06B0) ---
unsigned __int64 *sub_1404D06B0()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 n15; // rcx

  v0 = sub_1404B3EA0();
  n15 = *v0;
  if ( *v0 )
    *v0 = --n15;
  if ( n15 > 0xF )
    n15 = 15;
  return &v0[22 * n15 + 1];
}

// --- End Function: sub_1404D06B0 (0x1404D06B0) ---

// --- Function: sub_1404D4480 (0x1404D4480) ---
unsigned __int64 *__fastcall sub_1404D4480(_OWORD *a1)
{
  unsigned __int64 *v2; // rax
  unsigned __int64 *v3; // r9
  unsigned __int64 n0x10; // rdx
  unsigned __int64 *v5; // r8
  unsigned __int64 n15; // rax

  v2 = sub_1404B3EA0();
  v3 = v2;
  n0x10 = *v2 + 1;
  *v2 = n0x10;
  if ( n0x10 < 0x10 )
  {
    v5 = &v2[22 * n0x10];
    *(_OWORD *)(v5 + 1) = *a1;
    *(_OWORD *)(v5 + 3) = a1[1];
    *(_OWORD *)(v5 + 5) = a1[2];
    *(_OWORD *)(v5 + 7) = a1[3];
    *(_OWORD *)(v5 + 9) = a1[4];
    *(_OWORD *)(v5 + 11) = a1[5];
    *(_OWORD *)(v5 + 13) = a1[6];
    *(_OWORD *)(v5 + 15) = a1[7];
    *(_OWORD *)(v5 + 17) = a1[8];
    *(_OWORD *)(v5 + 19) = a1[9];
    *(_OWORD *)(v5 + 21) = a1[10];
  }
  n15 = *v2;
  if ( n15 > 0xF )
    n15 = 15;
  return &v3[22 * n15 + 1];
}

// --- End Function: sub_1404D4480 (0x1404D4480) ---

// --- Function: sub_1404D4560 (0x1404D4560) ---
__int64 sub_1404D4560()
{
  __int64 *v0; // rax
  __int64 *v1; // rbx
  unsigned __int64 n0x10; // rcx
  __int64 v3; // rax
  __int64 *v4; // rdx
  __int64 *v5; // rax
  char v6; // cl
  __int64 n15; // rax

  v0 = sub_1404B3EA0();
  v1 = v0;
  n0x10 = *v0 + 1;
  *v0 = n0x10;
  if ( n0x10 < 0x10 )
  {
    sub_1404AEB30((GUID *)&v0[22 * n0x10 + 1]);
    LOBYTE(v1[22 * *v1 + 3]) = v1[22 * *v1 - 21];
    BYTE1(v1[22 * *v1 + 3]) = *((_BYTE *)&v1[22 * *v1 - 20] - 7);
    BYTE2(v1[22 * *v1 + 3]) = *((_BYTE *)&v1[22 * *v1 - 20] - 6);
    BYTE3(v1[22 * *v1 + 3]) = *((_BYTE *)&v1[22 * *v1 - 20] - 5);
    BYTE4(v1[22 * *v1 + 3]) = *((_BYTE *)&v1[22 * *v1 - 20] - 4);
    BYTE5(v1[22 * *v1 + 3]) = *((_BYTE *)&v1[22 * *v1 - 20] - 3);
    BYTE6(v1[22 * *v1 + 3]) = *((_BYTE *)&v1[22 * *v1 - 20] - 2);
    HIBYTE(v1[22 * *v1 + 3]) = *((_BYTE *)&v1[22 * *v1 - 20] - 1);
    LOBYTE(v1[22 * *v1 + 4]) = v1[22 * *v1 - 20];
    BYTE1(v1[22 * *v1 + 4]) = *((_BYTE *)&v1[22 * *v1 - 19] - 7);
    BYTE2(v1[22 * *v1 + 4]) = *((_BYTE *)&v1[22 * *v1 - 19] - 6);
    BYTE3(v1[22 * *v1 + 4]) = *((_BYTE *)&v1[22 * *v1 - 19] - 5);
    BYTE4(v1[22 * *v1 + 4]) = *((_BYTE *)&v1[22 * *v1 - 19] - 4);
    BYTE5(v1[22 * *v1 + 4]) = *((_BYTE *)&v1[22 * *v1 - 19] - 3);
    BYTE6(v1[22 * *v1 + 4]) = *((_BYTE *)&v1[22 * *v1 - 19] - 2);
    HIBYTE(v1[22 * *v1 + 4]) = *((_BYTE *)&v1[22 * *v1 - 19] - 1);
    v3 = 22 * *v1;
    v4 = &v1[v3 - 15];
    v5 = &v1[v3 + 7];
    do
    {
      v6 = *(_BYTE *)v4;
      v4 = (__int64 *)((char *)v4 + 1);
      *(_BYTE *)v5 = v6;
      v5 = (__int64 *)((char *)v5 + 1);
    }
    while ( v6 );
  }
  n15 = *v1;
  if ( (unsigned __int64)*v1 > 0xF )
    n15 = 15;
  return (__int64)&v1[22 * n15 + 1];
}

// --- End Function: sub_1404D4560 (0x1404D4560) ---

// --- Function: sub_14059AF30 (0x14059AF30) ---
void __fastcall sub_14059AF30(_QWORD *a1)
{
  const void *v2; // rcx

  if ( *((_BYTE *)a1 + 136) != 1 )
    sub_140370D10(a1 + 19);
  v2 = (const void *)a1[13];
  if ( v2 )
    sub_1402A3D30(v2);
  sub_140370D10(a1 + 8);
  sub_140370D10(a1 + 7);
  sub_140370D10(a1 + 6);
  sub_140370D10(a1 + 5);
  sub_140370D10(a1);
}

// --- End Function: sub_14059AF30 (0x14059AF30) ---

// --- Function: sub_1405BD480 (0x1405BD480) ---
__int64 __fastcall sub_1405BD480(__int64 a1, int a2, _BYTE *a3)
{
  size_t Size; // r8
  unsigned __int64 n0xF; // rdx
  const void *v8; // rcx
  __int128 v10; // [rsp+20h] [rbp-38h] BYREF
  __int128 v11; // [rsp+30h] [rbp-28h]

  v10 = 0;
  v11 = 0;
  Size = -1;
  do
    ++Size;
  while ( a3[Size] );
  sub_1402FB100(&v10, a3, Size);
  *(_DWORD *)a1 = a2;
  sub_1402FBA60(a1 + 8, (__int64)&v10);
  n0xF = *((_QWORD *)&v11 + 1);
  *(_OWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 15;
  *(_BYTE *)(a1 + 40) = 0;
  if ( n0xF > 0xF )
  {
    v8 = (const void *)v10;
    if ( n0xF + 1 >= 0x1000 )
    {
      v8 = *(const void **)(v10 - 8);
      if ( (unsigned __int64)(v10 - (_QWORD)v8 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A3D30(v8);
  }
  return a1;
}

// --- End Function: sub_1405BD480 (0x1405BD480) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_140A335B0 (0x140A335B0) ---
_QWORD *__fastcall sub_140A335B0(_QWORD *a1, _QWORD *a2)
{
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  volatile signed __int32 *v7; // rbx
  volatile signed __int32 *v8; // rbx
  void (__fastcall *n2_1)(__int64, _QWORD *); // rax
  _QWORD *result; // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a1[1];
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1, 0);
    a1[1] = 0;
  }
  *a1 = 0;
  v5 = (_QWORD *)allocWithProfilerInfo_w(0x38u);
  v6 = v5;
  if ( v5 )
  {
    sub_14035AE20(v5, a2);
    v6[3] = 0;
    v6[4] = 0;
    v6[3] = a2[3];
    v6[4] = a2[4];
    a2[3] = 0;
    a2[4] = 0;
    v6[5] = 0;
    v6[6] = 0;
    v6[5] = a2[5];
    v6[6] = a2[6];
    a2[5] = 0;
    a2[6] = 0;
  }
  else
  {
    v6 = 0;
  }
  a1[2] = v6;
  *a1 = sub_140A81FA0;
  a1[1] = sub_140A83E60;
  v7 = (volatile signed __int32 *)a2[6];
  if ( v7 )
  {
    if ( _InterlockedExchangeAdd(v7 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
      if ( _InterlockedExchangeAdd(v7 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8LL))(v7);
    }
  }
  v8 = (volatile signed __int32 *)a2[4];
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd(v8 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v8)(v8);
      if ( _InterlockedExchangeAdd(v8 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 8LL))(v8);
    }
  }
  n2_1 = (void (__fastcall *)(__int64, _QWORD *))a2[1];
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, a2);
    a2[1] = 0;
  }
  result = a1;
  *a2 = 0;
  return result;
}

// --- End Function: sub_140A335B0 (0x140A335B0) ---

// --- Function: sub_140A34BE0 (0x140A34BE0) ---
__int64 __fastcall sub_140A34BE0(__int64 a1, __int64 a2)
{
  const void **v4; // rdi
  __int64 v5; // rsi
  const void *v6; // rdx
  __int64 v7; // rax
  const void *v8; // rcx
  const void *v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 80) )
  {
    if ( a2 == a1 )
      return a1;
    v4 = (const void **)(a1 + 8);
    if ( *(_BYTE *)a1 == *(_BYTE *)a2 )
    {
      v5 = a2 + 8;
      if ( *(_BYTE *)a2 == 1 )
      {
        if ( v4 != (const void **)v5 )
        {
          v6 = *v4;
          *v4 = 0;
          v7 = *(_QWORD *)(a1 + 24);
          *(_QWORD *)(a1 + 24) = 0;
          v8 = *v4;
          *v4 = v6;
          *(_QWORD *)(a1 + 16) = v6;
          *(_QWORD *)(a1 + 24) = v7;
          if ( v8 )
            sub_1402A3D30(v8);
          v9 = *v4;
          *v4 = *(const void **)v5;
          *(_QWORD *)v5 = v9;
          v10 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(v5 + 8);
          v11 = *(_QWORD *)(v5 + 16);
          *(_QWORD *)(v5 + 8) = v10;
          v12 = *(_QWORD *)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v11;
          *(_QWORD *)(v5 + 16) = v12;
        }
        return a1;
      }
      *(_DWORD *)v4 = *(_DWORD *)v5;
      sub_1402FB060((__int64 *)(a1 + 16), (#635 *)(a2 + 16));
      sub_1402FB060((__int64 *)(a1 + 48), (#635 *)(v5 + 40));
      return a1;
    }
    else
    {
      if ( *(_BYTE *)a1 == 1 )
      {
        if ( *v4 )
        {
          sub_1402A3D30(*v4);
          sub_140A8D080(a1, a2);
          return a1;
        }
      }
      else
      {
        sub_1403778D0((_QWORD *)(a1 + 8));
      }
      sub_140A8D080(a1, a2);
      return a1;
    }
  }
  else
  {
    sub_140A8D080(a1, a2);
    result = a1;
    *(_BYTE *)(a1 + 80) = 1;
  }
  return result;
}

// --- End Function: sub_140A34BE0 (0x140A34BE0) ---

// --- Function: sub_140A34F10 (0x140A34F10) ---
__int64 (__fastcall *__fastcall sub_140A34F10(
        _QWORD *a1,
        const char *p_$$,
        char **p_QueryActiveMissions:_playerId_should_be_same_as_the_local_playe))(__int64 a1)
{
  __int64 *v3; // rbx
  __int64 v4; // r9
  __int64 v7; // rdx
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 (__fastcall *p_sub_1403E4C70)(__int64); // rax
  _QWORD v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v3 = a1 + 3;
  v4 = a1[4] - a1[3];
  v11[0] = p_$$;
  v11[2] = 1;
  v7 = a1[1];
  v11[1] = v4 / 112;
  if ( v7 == a1[2] )
  {
    sub_1402A6C80((__int64)a1, (_BYTE *)v7, (__int64)v11);
  }
  else
  {
    *(_QWORD *)v7 = p_$$;
    *(_QWORD *)(v7 + 8) = v4 / 112;
    *(_QWORD *)(v7 + 16) = 1;
    a1[1] += 24LL;
  }
  sub_1402FDB90(
    v3,
    ((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (__int128)0x4924924924924925LL) >> 64) >> 63)
  + ((__int64)((unsigned __int128)((v3[1] - *v3) * (__int128)0x4924924924924925LL) >> 64) >> 5)
  + 1);
  v8 = *v3 + 112 * ((v3[1] - *v3) / 112);
  v9 = allocWithProfilerInfo_w(0x18u);
  if ( v9 )
  {
    *(_OWORD *)v9 = *(_OWORD *)p_QueryActiveMissions:_playerId_should_be_same_as_the_local_playe;
    *(double *)(v9 + 16) = *((double *)p_QueryActiveMissions:_playerId_should_be_same_as_the_local_playe + 2);
  }
  else
  {
    v9 = 0;
  }
  *(_QWORD *)(v8 - 112) = v9;
  *(_QWORD *)(v8 - 104) = "PlayerId";
  *(_BYTE *)(v8 - 23) = 1;
  *(_QWORD *)(v8 - 96) = *p_QueryActiveMissions:_playerId_should_be_same_as_the_local_playe;
  *(_QWORD *)(v8 - 88) = sub_1403EB550;
  *(_QWORD *)(v8 - 80) = sub_1403EAFB0;
  *(_QWORD *)(v8 - 64) = std::error_category::operator==;
  *(_QWORD *)(v8 - 48) = sub_1403E4EB0;
  p_sub_1403E4C70 = sub_1403E4C70;
  *(_QWORD *)(v8 - 40) = sub_1403E4C70;
  *(_QWORD *)(v8 - 72) = 0;
  *(_QWORD *)(v8 - 56) = 0;
  *(_QWORD *)(v8 - 32) = -1;
  *(_BYTE *)(v8 - 24) = 1;
  *(_QWORD *)(v8 - 16) = 24;
  *(_QWORD *)(v8 - 8) = 23;
  return p_sub_1403E4C70;
}

// --- End Function: sub_140A34F10 (0x140A34F10) ---

// --- Function: sub_140A35C50 (0x140A35C50) ---
__int64 *__fastcall sub_140A35C50(__int64 a1, __int64 *a2, __int64 p_sub_140A8E400, int a4, __int64 a5)
{
  __int64 v9; // r15
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // rdi
  _QWORD *v15; // rbx
  void (__fastcall *n2)(__int64, __int64); // rax
  _QWORD *v17; // rax
  _QWORD *v18; // rbx
  void (__fastcall *n2_1)(__int64, __int64); // rax
  _QWORD *v20; // rax
  _QWORD *v21; // rdi
  void (__fastcall *n2_2)(__int64, _QWORD *); // rax
  __int64 v23; // rax
  __int64 v24; // rbx
  _QWORD v26[2]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v27; // [rsp+40h] [rbp-58h]
  __int64 v28; // [rsp+48h] [rbp-50h]
  __int64 p_sub_140A8E400_1; // [rsp+50h] [rbp-48h]
  int v30; // [rsp+58h] [rbp-40h]
  char v31; // [rsp+5Ch] [rbp-3Ch]
  __int64 v32[2]; // [rsp+60h] [rbp-38h] BYREF

  v9 = sub_140A3D920();
  v10 = allocWithProfilerInfo_w(0x2B8u);
  if ( v10 )
  {
    v11 = *(_QWORD *)(a1 + 88);
    if ( v11 )
      _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
    v12 = *(_QWORD *)(a5 + 96);
    v26[0] = *(_QWORD *)(a1 + 80);
    v26[1] = *(_QWORD *)(a1 + 88);
    v13 = sub_140A64C30(v10, v12, (unsigned int)v26, a4, v9, 1);
    *a2 = v13;
    if ( v13 )
      _InterlockedIncrement((volatile signed __int32 *)(*(int *)(*(_QWORD *)(v13 + 8) + 4LL) + v13 + 16));
  }
  else
  {
    *a2 = 0;
  }
  v14 = *a2;
  _InterlockedIncrement((volatile signed __int32 *)(*(int *)(*(_QWORD *)(*a2 + 8) + 4LL) + *a2 + 16));
  sub_140377C70((_QWORD *)(v14 + 584), (_QWORD *)a5);
  sub_140377C70((_QWORD *)(v14 + 608), (_QWORD *)(a5 + 48));
  sub_140377C70((_QWORD *)(v14 + 632), (_QWORD *)(a5 + 72));
  sub_140377C70((_QWORD *)(v14 + 656), (_QWORD *)(a5 + 24));
  *(_BYTE *)(v14 + 128) = *(_QWORD *)(v14 + 584) != 0;
  *(_DWORD *)(v14 + 108) = *(_DWORD *)(a5 + 108);
  *(_BYTE *)(v14 + 112) = *(_BYTE *)(a5 + 112);
  *(_BYTE *)(v14 + 113) = *(_BYTE *)(a5 + 113);
  std::shared_ptr<vraudio::MixerNode>::operator=(
    (std::shared_ptr<vraudio::MixerNode> *)(v14 + 504),
    (std::shared_ptr<vraudio::MixerNode> *)(a5 + 120));
  v15 = (_QWORD *)(v14 + 432);
  n2 = *(void (__fastcall **)(__int64, __int64))(v14 + 440);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, v14 + 432);
    *(_QWORD *)(v14 + 440) = 0;
  }
  *v15 = 0;
  v17 = (_QWORD *)allocWithProfilerInfo_w(8u);
  if ( v17 )
    *v17 = v14;
  else
    v17 = 0;
  *(_QWORD *)(v14 + 448) = v17;
  *v15 = sub_140A81700;
  *(_QWORD *)(v14 + 440) = sub_140A83340;
  v18 = (_QWORD *)(v14 + 456);
  n2_1 = *(void (__fastcall **)(__int64, __int64))(v14 + 464);
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, v14 + 456);
    *(_QWORD *)(v14 + 464) = 0;
  }
  *v18 = 0;
  v20 = (_QWORD *)allocWithProfilerInfo_w(8u);
  if ( v20 )
    *v20 = v14;
  else
    v20 = 0;
  *(_QWORD *)(v14 + 472) = v20;
  v27 = a1;
  *v18 = sub_140A81EC0;
  v28 = v14;
  *(_QWORD *)(v14 + 464) = sub_140A83340;
  v30 = *(_DWORD *)(a5 + 104);
  v31 = *(_BYTE *)(a5 + 136);
  p_sub_140A8E400_1 = p_sub_140A8E400;
  sub_14035B140(v32, (__int64 *)(a5 + 144));
  v21 = (_QWORD *)(v14 + 480);
  n2_2 = (void (__fastcall *)(__int64, _QWORD *))v21[1];
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, v21);
    v21[1] = 0;
  }
  *v21 = 0;
  v23 = allocWithProfilerInfo_w(0x28u);
  v24 = v23;
  if ( v23 )
  {
    *(_QWORD *)v23 = v27;
    *(_QWORD *)(v23 + 8) = v28;
    *(_QWORD *)(v23 + 16) = p_sub_140A8E400_1;
    *(_DWORD *)(v23 + 24) = v30;
    *(_BYTE *)(v23 + 28) = v31;
    sub_14035B140((_QWORD *)(v23 + 32), v32);
  }
  else
  {
    v24 = 0;
  }
  v21[2] = v24;
  *v21 = sub_140A82880;
  v21[1] = sub_140A83F40;
  sub_140370D10(v32);
  return a2;
}

// --- End Function: sub_140A35C50 (0x140A35C50) ---

// --- Function: sub_140A3D920 (0x140A3D920) ---
__int64 sub_140A3D920()
{
  __int64 result; // rax
  __int64 v1; // rsi
  __int64 v2; // rbx
  int v3; // edi
  unsigned __int32 v4; // eax
  __int64 v5; // rdi
  __int64 v6; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rax
  char **v9; // rax
  char **v10; // rax
  int v11; // edx
  __int64 v12; // rax
  __int64 v13; // rax
  std::shared_ptr<vraudio::MixerNode> *_Right; // rax
  volatile signed __int32 *v15; // rsi
  int v16; // eax
  unsigned __int32 v17; // eax
  _QWORD v18[2]; // [rsp+30h] [rbp-78h] BYREF
  char v19; // [rsp+40h] [rbp-68h] BYREF
  volatile signed __int32 *v20; // [rsp+48h] [rbp-60h]
  _BYTE v21[16]; // [rsp+50h] [rbp-58h] BYREF
  _BYTE v22[16]; // [rsp+60h] [rbp-48h] BYREF
  _BYTE v23[16]; // [rsp+70h] [rbp-38h] BYREF
  char v24; // [rsp+B0h] [rbp+8h] BYREF
  char v25; // [rsp+B8h] [rbp+10h] BYREF
  __int64 v26; // [rsp+C0h] [rbp+18h] BYREF

  result = qword_149C88C90;
  if ( !qword_149C88C90 )
  {
    v1 = sub_140A8A0D0();
    v2 = v1 + 136;
    v3 = *(_DWORD *)(NtCurrentTeb_w() + 24);
    if ( *(_DWORD *)(v1 + 152) == v3 )
    {
      ++*(_DWORD *)(v1 + 156);
    }
    else
    {
      v4 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 1, 0);
      if ( v4 )
        sub_1403C33A0(v2, v4, "SClientCallDebug::GetCallDescription", 1);
      else
        *(_QWORD *)(v1 + 144) = *(_QWORD *)(NtCurrentTeb_w() + 32);
      *(_DWORD *)(v1 + 152) = v3;
    }
    v5 = qword_149C88C90;
    if ( !qword_149C88C90 )
    {
      v6 = allocWithProfilerInfo_w(0x40u);
      v5 = v6;
      if ( v6 )
      {
        *(_QWORD *)v6 = 0;
        *(_QWORD *)(v6 + 16) = 0;
        *(_QWORD *)(v6 + 24) = 0;
        *(_QWORD *)(v6 + 32) = 0;
        *(_DWORD *)(v6 + 42) = 0;
        *(_WORD *)(v6 + 46) = 0;
        *(_WORD *)(v6 + 40) = 0;
        *(_QWORD *)(v6 + 48) = 0;
        *(_QWORD *)(v6 + 56) = 0;
      }
      else
      {
        v5 = 0;
      }
      *(_QWORD *)(v5 + 8) = "sc.external.services.mission_service.v1.MissionService";
      v7 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)sub_14104FBA0(&off_149953698, v21) + 8LL) + 32LL);
      if ( v7[3] > 0xFu )
        v7 = (_QWORD *)*v7;
      *(_QWORD *)(v5 + 16) = v7;
      v8 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)sub_14104FBE0(&off_1499536E8, v22) + 8LL) + 32LL);
      if ( v8[3] > 0xFu )
        v8 = (_QWORD *)*v8;
      *(_QWORD *)(v5 + 24) = v8;
      *(_QWORD *)v5 = "Unary";
      sub_14035B3E0(&v26);
      v10 = sub_1403A9130(v9, "%s:%s:%s", *(const char **)v5, *(const char **)(v5 + 8), *(const char **)(v5 + 16));
      *(_QWORD *)(v5 + 32) = *(_QWORD *)(*(_QWORD *)sub_1405FD8C0(v1 + 160, v23, v10) + 32LL);
      sub_140370D10(&v26);
      *(_WORD *)(v5 + 40) = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const wchar_t *, _QWORD))(*(_QWORD *)qword_149B4FD40 + 312LL))(
                                        qword_149B4FD40,
                                        &v25,
                                        &Format_,
                                        *(_QWORD *)(v5 + 32));
      v12 = qword_149C889A8;
      if ( !qword_149C889A8 )
      {
        v13 = *(_QWORD *)qword_149B4FDB8;
        v18[0] = &v24;
        v18[1] = sub_140A32750;
        v12 = (*(__int64 (__fastcall **)(__int64, __int64 *, const char *, _QWORD *))(v13 + 72))(
                qword_149B4FDB8,
                &qword_149C889A8,
                "SServiceConfigMetrics",
                v18);
        v18[0] = -1;
      }
      if ( *(_DWORD *)(v12 + 312) )
      {
        LOBYTE(v11) = 102;
        _Right = (std::shared_ptr<vraudio::MixerNode> *)sub_1404A2AE0(
                                                          (unsigned int)&v19,
                                                          v11,
                                                          *(_QWORD *)(v5 + 8),
                                                          *(_QWORD *)(v5 + 16),
                                                          *(_QWORD *)v5);
        std::shared_ptr<vraudio::MixerNode>::operator=((std::shared_ptr<vraudio::MixerNode> *)(v5 + 48), _Right);
        v15 = v20;
        if ( v20 )
        {
          if ( _InterlockedExchangeAdd(v20 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
            if ( _InterlockedExchangeAdd(v15 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8LL))(v15);
          }
        }
      }
      qword_149C88C90 = v5;
    }
    v16 = *(_DWORD *)(v2 + 20);
    if ( v16 )
    {
      *(_DWORD *)(v2 + 20) = v16 - 1;
    }
    else
    {
      *(_DWORD *)(v2 + 16) = -1;
      v17 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 0, 1);
      if ( v17 == 1 )
        *(_QWORD *)(v2 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DB1F0(v2, v17);
    }
    return v5;
  }
  return result;
}

// --- End Function: sub_140A3D920 (0x140A3D920) ---

// --- Function: sub_140A3F350 (0x140A3F350) ---
volatile signed __int32 **__fastcall sub_140A3F350(volatile signed __int32 **a1)
{
  __int64 v2; // rax
  volatile signed __int32 *v3; // rbx
  volatile signed __int32 *v4; // r14
  __int64 v5; // rax
  __int64 v6; // rdi
  __int64 n16; // rcx
  __int64 n8; // rax
  volatile signed __int32 **result; // rax

  v2 = allocWithProfilerInfo_w(0x50u);
  v3 = (volatile signed __int32 *)v2;
  if ( v2 )
  {
    *(_DWORD *)(v2 + 8) = 1;
    *(_DWORD *)(v2 + 12) = 1;
    *(_QWORD *)v2 = off_1481B59E0;
    *(__m256i *)(v2 + 16) = (__m256i)0LL;
    *(__m256i *)(v2 + 48) = (__m256i)0LL;
    *(_QWORD *)(v2 + 24) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    *(_DWORD *)(v2 + 32) = -1;
    *(_QWORD *)(v2 + 36) = 0;
    *(_QWORD *)(v2 + 48) = 0;
    *(_QWORD *)(v2 + 56) = 0;
    *(_QWORD *)(v2 + 64) = 0;
    *(_WORD *)(v2 + 72) = 0;
  }
  else
  {
    v3 = 0;
  }
  v4 = v3 + 4;
  __asm { vzeroupper }
  v5 = allocWithProfilerInfo_w(0x130u);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 8) = 1;
    *(_DWORD *)(v5 + 12) = 1;
    *(_QWORD *)v5 = off_14827C460;
    memset((void *)(v5 + 32), 0, 0x110u);
    *(__m256i *)(v6 + 16) = (__m256i)0LL;
    n16 = v6 + 16;
    *(_QWORD *)(v6 + 48) = 0;
    *(_QWORD *)(v6 + 56) = 0;
    *(__m256i *)(v6 + 64) = (__m256i)0LL;
    *(__m256i *)(v6 + 96) = (__m256i)0LL;
    *(__m256i *)(v6 + 128) = (__m256i)0LL;
    *(__m256i *)(v6 + 160) = (__m256i)0LL;
    *(_QWORD *)(v6 + 192) = 0;
    *(_QWORD *)(v6 + 200) = 0;
    *(_QWORD *)(v6 + 208) = 0;
    *(_BYTE *)(v6 + 296) = 0;
    n8 = v6 + 8;
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 8));
  }
  else
  {
    n16 = 16;
    v6 = 0;
    n8 = 8;
  }
  if ( v3 )
    _InterlockedIncrement(v3 + 2);
  if ( v6 )
    _InterlockedIncrement((volatile signed __int32 *)n8);
  if ( v3 )
    _InterlockedIncrement(v3 + 2);
  *a1 = v4;
  a1[1] = v3;
  a1[2] = (volatile signed __int32 *)n16;
  a1[3] = (volatile signed __int32 *)v6;
  a1[4] = v4;
  a1[5] = v3;
  a1[6] = (volatile signed __int32 *)n16;
  a1[7] = (volatile signed __int32 *)v6;
  if ( v6 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 8), 0xFFFFFFFF) == 1 )
    {
      __asm { vzeroupper }
      (**(void (__fastcall ***)(__int64))v6)(v6);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
    }
  }
  if ( v3 )
  {
    if ( _InterlockedExchangeAdd(v3 + 2, 0xFFFFFFFF) == 1 )
    {
      __asm { vzeroupper }
      (**(void (__fastcall ***)(volatile signed __int32 *))v3)(v3);
      if ( _InterlockedExchangeAdd(v3 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8LL))(v3);
    }
  }
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140A3F350 (0x140A3F350) ---

// --- Function: sub_140A40330 (0x140A40330) ---
_QWORD *__fastcall sub_140A40330(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rsi
  __int64 v6; // rbx
  __int64 v7; // rax
  _QWORD *result; // rax
  _QWORD v9[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = allocWithProfilerInfo_w(0x50u);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)(v4 + 12) = 1;
    *(_QWORD *)v4 = off_1481B59E0;
    *(__m256i *)(v4 + 16) = (__m256i)0LL;
    *(__m256i *)(v4 + 48) = (__m256i)0LL;
    *(_QWORD *)(v4 + 24) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    *(_DWORD *)(v4 + 32) = -1;
    *(_QWORD *)(v4 + 36) = 0;
    *(_QWORD *)(v4 + 48) = 0;
    *(_QWORD *)(v4 + 56) = 0;
    *(_QWORD *)(v4 + 64) = 0;
    *(_WORD *)(v4 + 72) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)(v5 + 72) = 1;
  __asm { vzeroupper }
  sub_140A62D90(v9);
  v6 = v9[0];
  sub_140A34BE0(v9[0] + 200LL, a2);
  v7 = v9[1];
  *a1 = v5 + 16;
  a1[1] = v5;
  a1[3] = v7;
  result = a1;
  a1[2] = v6;
  return result;
}

// --- End Function: sub_140A40330 (0x140A40330) ---

// --- Function: sub_140A449C0 (0x140A449C0) ---
__int64 *__fastcall sub_140A449C0(__int64 *a1, __int64 *a2, char *a3)
{
  __int64 v6; // rbx
  int v7; // edi
  unsigned __int32 v8; // eax
  volatile signed __int32 *v9; // rdi
  __int64 *v10; // rdi
  _BYTE *v11; // rsi
  _QWORD *v12; // rcx
  __int64 v13; // rax
  __int64 v14; // r12
  _OWORD *v15; // rdi
  void (__fastcall *v16)(__int64); // rax
  void (__fastcall *n2)(__int64, _OWORD *); // rax
  __int64 v18; // r12
  __int64 v19; // rax
  volatile signed __int32 *v20; // rdi
  __int64 *ThreadLogContextSlot; // rax
  __int64 (__fastcall **v22)(); // rdi
  void (__fastcall *n2_1)(__int64, __int64); // rax
  void (__fastcall *p_sub_140398C70_1)(__int64, __int64 (__fastcall **)()); // rax
  volatile signed __int32 *v25; // rdi
  int v26; // eax
  unsigned __int32 v27; // eax
  volatile signed __int32 *v28; // rbx
  __int64 v29; // rax
  __int64 v30; // rcx
  _OWORD *v31; // rax
  _OWORD *v33; // [rsp+20h] [rbp-E0h] BYREF
  volatile signed __int32 *v34; // [rsp+28h] [rbp-D8h]
  __int64 (__fastcall *p_sub_140A81A00)(); // [rsp+30h] [rbp-D0h] BYREF
  void (__fastcall *p_sub_140398C70)(__int64, __int64 (__fastcall **)()); // [rsp+38h] [rbp-C8h]
  __int64 v37; // [rsp+40h] [rbp-C0h]
  _OWORD *v38; // [rsp+48h] [rbp-B8h]
  volatile signed __int32 *v39; // [rsp+50h] [rbp-B0h]
  char v40[8]; // [rsp+58h] [rbp-A8h] BYREF
  char v41[8]; // [rsp+60h] [rbp-A0h] BYREF
  _QWORD v42[9]; // [rsp+68h] [rbp-98h] BYREF
  char v43; // [rsp+B0h] [rbp-50h]
  char v44[8]; // [rsp+C0h] [rbp-40h] BYREF
  _QWORD v45[9]; // [rsp+C8h] [rbp-38h] BYREF
  char v46; // [rsp+110h] [rbp+10h]
  char v47[8]; // [rsp+118h] [rbp+18h] BYREF
  const void *v48; // [rsp+120h] [rbp+20h] BYREF

  sub_140A62D90(&v33);
  v6 = *a1;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 24);
  if ( *(_DWORD *)(v6 + 16) == v7 )
  {
    ++*(_DWORD *)(v6 + 20);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 1, 0);
    if ( v8 )
      sub_1403C33A0(
        v6,
        v8,
        "CFuture<class CigResult<struct SProtobufArenaMessage<class sc::external::services::mission_service::v1::QueryAct"
        "iveMissionsResponse>,struct CigError> >::Map",
        1);
    else
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 32);
    *(_DWORD *)(v6 + 16) = v7;
  }
  if ( v34 )
    _InterlockedIncrement(v34 + 2);
  if ( v34 )
    _InterlockedIncrement(v34 + 2);
  v38 = v33;
  v40[0] = *a3;
  v39 = v34;
  if ( v34 )
  {
    if ( _InterlockedExchangeAdd(v34 + 2, 0xFFFFFFFF) == 1 )
    {
      v9 = v34;
      (**(void (__fastcall ***)(volatile signed __int32 *))v34)(v34);
      if ( _InterlockedExchangeAdd(v9 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v34 + 8LL))(v34);
    }
  }
  v10 = a1 + 2;
  v11 = (_BYTE *)(a1[2] + 200);
  v46 = 0;
  v43 = 0;
  if ( v11[80] )
  {
    sub_140A8CBF0((__int64)v41, (__int64)v11);
    v43 = 1;
    if ( v46 )
    {
      sub_140A4EB10(v11, v44);
    }
    else
    {
      if ( !v11[80] )
        goto LABEL_27;
      v12 = v11 + 8;
      if ( *v11 == 1 )
        sub_140A69BE0(v12);
      else
        sub_1403778D0(v12);
      v11[80] = 0;
      v10 = a1 + 2;
    }
    if ( v46 )
    {
      if ( v44[0] == 1 )
        sub_140A69BE0(v45);
      else
        sub_1403778D0(v45);
    }
  }
LABEL_27:
  if ( v43 )
  {
    v13 = sub_140A724D0(v40, v47, v41);
    v14 = v13;
    v15 = v33 + 11;
    if ( *((_QWORD *)v33 + 22) )
    {
      sub_1404D4480(v33);
      v16 = *(void (__fastcall **)(__int64))v15;
      if ( *((_QWORD *)v15 + 1) == 1 )
        v16(v14);
      else
        ((void (__fastcall *)(_OWORD *, __int64))v16)(v15, v14);
      n2 = (void (__fastcall *)(__int64, _OWORD *))*((_QWORD *)v15 + 1);
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v15);
        *((_QWORD *)v15 + 1) = 0;
      }
      *(_QWORD *)v15 = 0;
      sub_1404D06B0();
    }
    else
    {
      sub_140A34BE0((__int64)v33 + 200, v13);
    }
    if ( v47[0] == 1 )
    {
      if ( v48 )
        sub_1402A3D30(v48);
    }
    else
    {
      sub_1403778D0(&v48);
    }
    goto LABEL_57;
  }
  v18 = *v10;
  v39 = 0;
  v19 = allocWithProfilerInfo_w(0x18u);
  if ( v19 )
  {
    *(_QWORD *)v19 = v33;
    *(_QWORD *)(v19 + 8) = v34;
    *(_BYTE *)(v19 + 16) = v40[0];
    v37 = v19;
    p_sub_140A81A00 = sub_140A81A00;
    p_sub_140398C70 = (void (__fastcall *)(__int64, __int64 (__fastcall **)()))sub_140398C70;
  }
  else
  {
    v20 = v34;
    p_sub_140A81A00 = sub_140A81A00;
    p_sub_140398C70 = (void (__fastcall *)(__int64, __int64 (__fastcall **)()))sub_140398C70;
    v37 = 0;
    if ( v34 )
    {
      if ( _InterlockedExchangeAdd(v34 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v20)(v20);
        if ( _InterlockedExchangeAdd(v20 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v20 + 8LL))(v20);
      }
    }
  }
  ThreadLogContextSlot = getThreadLogContextSlot();
  v22 = (__int64 (__fastcall **)())(v18 + 176);
  *(_OWORD *)v18 = *(_OWORD *)ThreadLogContextSlot;
  *(_OWORD *)(v18 + 16) = *((_OWORD *)ThreadLogContextSlot + 1);
  *(_OWORD *)(v18 + 32) = *((_OWORD *)ThreadLogContextSlot + 2);
  *(_OWORD *)(v18 + 48) = *((_OWORD *)ThreadLogContextSlot + 3);
  *(_OWORD *)(v18 + 64) = *((_OWORD *)ThreadLogContextSlot + 4);
  *(_OWORD *)(v18 + 80) = *((_OWORD *)ThreadLogContextSlot + 5);
  *(_OWORD *)(v18 + 96) = *((_OWORD *)ThreadLogContextSlot + 6);
  *(_OWORD *)(v18 + 112) = *((_OWORD *)ThreadLogContextSlot + 7);
  *(_OWORD *)(v18 + 128) = *((_OWORD *)ThreadLogContextSlot + 8);
  *(_OWORD *)(v18 + 144) = *((_OWORD *)ThreadLogContextSlot + 9);
  *(_OWORD *)(v18 + 160) = *((_OWORD *)ThreadLogContextSlot + 10);
  n2_1 = *(void (__fastcall **)(__int64, __int64))(v18 + 184);
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, v18 + 176);
    *(_QWORD *)(v18 + 184) = 0;
  }
  *v22 = 0;
  p_sub_140398C70_1 = p_sub_140398C70;
  if ( p_sub_140398C70 == (void (__fastcall *)(__int64, __int64 (__fastcall **)()))1 )
  {
    *v22 = p_sub_140A81A00;
    *(_QWORD *)(v18 + 184) = p_sub_140398C70;
LABEL_52:
    p_sub_140398C70_1 = p_sub_140398C70;
    if ( (unsigned __int64)p_sub_140398C70 >= 2 )
    {
      p_sub_140398C70(2, &p_sub_140A81A00);
      p_sub_140398C70_1 = 0;
      p_sub_140398C70 = 0;
    }
    p_sub_140A81A00 = 0;
    goto LABEL_55;
  }
  if ( p_sub_140398C70 )
  {
    ((void (__fastcall *)(__int64, __int64, __int64 (__fastcall **)()))p_sub_140398C70)(1, v18 + 176, &p_sub_140A81A00);
    goto LABEL_52;
  }
LABEL_55:
  if ( (unsigned __int64)p_sub_140398C70_1 >= 2 )
    p_sub_140398C70_1(2, &p_sub_140A81A00);
LABEL_57:
  if ( v43 )
  {
    if ( v41[0] == 1 )
      sub_140A69BE0(v42);
    else
      sub_1403778D0(v42);
  }
  if ( v39 )
  {
    if ( _InterlockedExchangeAdd(v39 + 2, 0xFFFFFFFF) == 1 )
    {
      v25 = v39;
      (**(void (__fastcall ***)(volatile signed __int32 *))v39)(v39);
      if ( _InterlockedExchangeAdd(v25 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v39 + 8LL))(v39);
    }
  }
  v26 = *(_DWORD *)(v6 + 20);
  if ( v26 )
  {
    *(_DWORD *)(v6 + 20) = v26 - 1;
  }
  else
  {
    *(_DWORD *)(v6 + 16) = -1;
    v27 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 0, 1);
    if ( v27 == 1 )
      *(_QWORD *)(v6 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(v6, v27);
  }
  v28 = (volatile signed __int32 *)a1[3];
  a1[2] = 0;
  a1[3] = 0;
  if ( v28 )
  {
    if ( _InterlockedExchangeAdd(v28 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v28)(v28);
      if ( _InterlockedExchangeAdd(v28 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v28 + 8LL))(v28);
    }
  }
  v29 = a1[1];
  v30 = *a1;
  *a1 = 0;
  a1[1] = 0;
  a2[1] = v29;
  v31 = v33;
  *a2 = v30;
  a2[2] = (__int64)v31;
  a2[3] = (__int64)v34;
  return a2;
}

// --- End Function: sub_140A449C0 (0x140A449C0) ---

// --- Function: sub_140A4EB10 (0x140A4EB10) ---
void __fastcall sub_140A4EB10(__int64 a1, __int64 a2)
{
  char v4; // cl
  bool v5; // zf
  _QWORD *v6; // rcx

  if ( *(_BYTE *)(a1 + 80) )
  {
    if ( a2 != a1 )
    {
      v4 = *(_BYTE *)a1;
      if ( v4 == *(_BYTE *)a2 )
      {
        if ( *(_BYTE *)a2 == 1 )
        {
          sub_140A6BE70(a1 + 8, a2 + 8);
        }
        else
        {
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
          sub_1402FB060((__int64 *)(a1 + 16), (#635 *)(a2 + 16));
          sub_1402FB060((__int64 *)(a1 + 48), (#635 *)(a2 + 48));
        }
      }
      else
      {
        v5 = v4 == 1;
        v6 = (_QWORD *)(a1 + 8);
        if ( v5 )
          sub_140A69BE0(v6);
        else
          sub_1403778D0(v6);
        sub_140A8CBF0(a1, a2);
      }
    }
  }
  else
  {
    sub_140A8CBF0(a1, a2);
    *(_BYTE *)(a1 + 80) = 1;
  }
}

// --- End Function: sub_140A4EB10 (0x140A4EB10) ---

// --- Function: sub_140A5AD40 (0x140A5AD40) ---
char __fastcall sub_140A5AD40(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11)
{
  void *v15; // rsp
  __int64 v17; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n256; // [rsp+88h] [rbp-F8h]
  __int64 n176; // [rsp+90h] [rbp-F0h]
  __int64 n168; // [rsp+98h] [rbp-E8h]
  __int64 v22; // [rsp+A0h] [rbp-E0h] BYREF

  v15 = alloca(336);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  n256 = 256;
  __Val_0___[10] = -1;
  n176 = 176;
  n168 = 168;
  sub_140A607C0(&v22, a10, a11);
  LODWORD(v17) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 3u, a5, v17, a7, a8);
}

// --- End Function: sub_140A5AD40 (0x140A5AD40) ---

// --- Function: __crtLCMapStringA_6 (0x140A5B250) ---
char __fastcall _crtLCMapStringA_6(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v11; // rsp
  __int64 v13; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n256; // [rsp+88h] [rbp-F8h]
  __int64 n176; // [rsp+90h] [rbp-F0h]
  __int64 n168; // [rsp+98h] [rbp-E8h]
  _QWORD *v18; // [rsp+A0h] [rbp-E0h]
  const char *p_PlayerId; // [rsp+A8h] [rbp-D8h]
  __int64 v20; // [rsp+B0h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1403EB550)(__int64, __int64, __int64); // [rsp+B8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403EAFB0)(__int64, _BYTE *, unsigned __int64); // [rsp+C0h] [rbp-C0h]
  __int64 v23; // [rsp+C8h] [rbp-B8h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+D0h] [rbp-B0h]
  __int64 v25; // [rsp+D8h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E4EB0)(const void *); // [rsp+E0h] [rbp-A0h]
  __int64 (__fastcall *p_sub_1403E4C70)(__int64); // [rsp+E8h] [rbp-98h]
  __int64 v28; // [rsp+F0h] [rbp-90h]
  char v29; // [rsp+F8h] [rbp-88h]
  char v30; // [rsp+F9h] [rbp-87h]
  __int64 n24; // [rsp+100h] [rbp-80h]
  __int64 n23; // [rsp+108h] [rbp-78h]
  _QWORD *v33; // [rsp+110h] [rbp-70h]
  const char *p_PlayerId_1; // [rsp+118h] [rbp-68h]
  __int64 v35; // [rsp+120h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB550_1)(__int64, __int64, __int64); // [rsp+128h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EAFB0_1)(__int64, _BYTE *, unsigned __int64); // [rsp+130h] [rbp-50h]
  __int64 v38; // [rsp+138h] [rbp-48h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z_1)(__int64, __int64); // [rsp+140h] [rbp-40h]
  __int64 v40; // [rsp+148h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4EB0_1)(const void *); // [rsp+150h] [rbp-30h]
  __int64 (__fastcall *p_sub_1403E4C70_1)(__int64); // [rsp+158h] [rbp-28h]
  __int64 v43; // [rsp+160h] [rbp-20h]
  char v44; // [rsp+168h] [rbp-18h]
  char v45; // [rsp+169h] [rbp-17h]
  __int64 n24_1; // [rsp+170h] [rbp-10h]
  __int64 n23_1; // [rsp+178h] [rbp-8h]

  v11 = alloca(336);
  __Val_0___[0] = a9;
  n256 = 256;
  __Val_0___[2] = 0;
  __Val_0___[1] = "TraceContext";
  __Val_0___[5] = 0;
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[7] = 0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[10] = -1;
  __Val_0___[6] = sub_1403E77F0;
  n176 = 176;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v18 = a10;
  n168 = 168;
  p_PlayerId = "PlayerId";
  v30 = 1;
  v20 = *a10;
  v33 = a11;
  p_sub_1403EB550 = sub_1403EB550;
  p_sub_1403EAFB0 = sub_1403EAFB0;
  v23 = 0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  v25 = 0;
  p_sub_1403E4EB0 = sub_1403E4EB0;
  p_sub_1403E4C70 = sub_1403E4C70;
  v28 = -1;
  v29 = 0;
  n24 = 24;
  n23 = 23;
  p_PlayerId_1 = "PlayerId";
  v45 = 1;
  v35 = *a11;
  LODWORD(v13) = a6;
  p_sub_1403EB550_1 = sub_1403EB550;
  p_sub_1403EAFB0_1 = sub_1403EAFB0;
  v38 = 0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z_1 = std::error_category::operator==;
  v40 = 0;
  p_sub_1403E4EB0_1 = sub_1403E4EB0;
  p_sub_1403E4C70_1 = sub_1403E4C70;
  v43 = -1;
  v44 = 0;
  n24_1 = 24;
  n23_1 = 23;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 3u, a5, v13, a7, a8);
}

// --- End Function: __crtLCMapStringA_6 (0x140A5B250) ---

// --- Function: sub_140A607C0 (0x140A607C0) ---
__int64 __fastcall sub_140A607C0(__int64 a1, _QWORD *a2, struct _exception *a3)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Count";
  *(_BYTE *)(a1 + 89) = 0;
  *(_QWORD *)(a1 + 16) = *a2;
  *(_QWORD *)(a1 + 24) = sub_1403EB110;
  *(_QWORD *)(a1 + 32) = sub_1403EB110;
  *(_QWORD *)(a1 + 48) = std::error_category::operator==;
  *(_QWORD *)(a1 + 64) = sub_1403E4E70;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = sub_1403E4B60;
  *(_QWORD *)(a1 + 80) = -1;
  *(_QWORD *)(a1 + 96) = 16;
  *(_QWORD *)(a1 + 104) = 21;
  return sub_140445490(a1 + 112, a3) + 1;
}

// --- End Function: sub_140A607C0 (0x140A607C0) ---

// --- Function: sub_140A62D90 (0x140A62D90) ---
_QWORD *__fastcall sub_140A62D90(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  _QWORD *result; // rax

  v2 = allocWithProfilerInfo_w(0x130u);
  v3 = v2;
  if ( v2 )
  {
    *(_DWORD *)(v2 + 8) = 1;
    *(_DWORD *)(v2 + 12) = 1;
    *(_QWORD *)v2 = off_14827ADA8;
    memset((void *)(v2 + 32), 0, 0x110u);
    *(__m256i *)(v3 + 16) = (__m256i)0LL;
    *(_QWORD *)(v3 + 48) = 0;
    *(_QWORD *)(v3 + 56) = 0;
    *(__m256i *)(v3 + 64) = (__m256i)0LL;
    *(__m256i *)(v3 + 96) = (__m256i)0LL;
    *(__m256i *)(v3 + 128) = (__m256i)0LL;
    *(__m256i *)(v3 + 160) = (__m256i)0LL;
    *(_QWORD *)(v3 + 192) = 0;
    *(_QWORD *)(v3 + 200) = 0;
    *(_QWORD *)(v3 + 208) = 0;
    *(_BYTE *)(v3 + 296) = 0;
  }
  else
  {
    v3 = 0;
  }
  a1[1] = v3;
  *a1 = v3 + 16;
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140A62D90 (0x140A62D90) ---

// --- Function: sub_140A64C30 (0x140A64C30) ---
__int64 __fastcall sub_140A64C30(__int64 a1, int a2, _QWORD *a3, __int64 *a4, __int64 a5, int a6)
{
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rcx
  volatile signed __int32 *v15; // rdi
  _QWORD v17[5]; // [rsp+30h] [rbp-28h] BYREF

  if ( a6 )
  {
    *(_QWORD *)(a1 + 8) = &unk_148279E70;
    *(_QWORD *)(a1 + 24) = &unk_148279E78;
    *(_QWORD *)(a1 + 680) = off_1481A0E28;
    *(_DWORD *)(a1 + 688) = 0;
  }
  v9 = a3[1];
  if ( v9 )
    _InterlockedIncrement((volatile signed __int32 *)(v9 + 8));
  v17[0] = *a3;
  v17[1] = a3[1];
  sub_140A67AD0(a1, a2, (unsigned int)v17, a5, 0);
  *(_QWORD *)a1 = off_148275510;
  *(_QWORD *)(a1 + 16) = off_148275518;
  *(_QWORD *)(*(int *)(*(_QWORD *)(a1 + 8) + 4LL) + a1 + 8) = off_148279C20;
  *(_QWORD *)(a1 + 528) = 0;
  *(_QWORD *)(a1 + 536) = 0;
  *(_QWORD *)(a1 + 544) = 0;
  v10 = a4[1];
  if ( v10 )
  {
    *(_QWORD *)(a1 + 536) = v10;
    v11 = a4[2];
    a4[1] = 0;
    v12 = *(_QWORD *)(a1 + 544);
    *(_QWORD *)(a1 + 544) = v11;
    v13 = *a4;
    a4[2] = v12;
    v14 = *(_QWORD *)(a1 + 528);
    *(_QWORD *)(a1 + 528) = v13;
    *a4 = v14;
  }
  *(_QWORD *)(a1 + 552) = 0;
  *(_QWORD *)(a1 + 560) = 0;
  *(_QWORD *)(a1 + 568) = 0;
  *(_QWORD *)(a1 + 576) = 0;
  *(_QWORD *)(a1 + 584) = 0;
  *(_QWORD *)(a1 + 592) = 0;
  *(_QWORD *)(a1 + 600) = 0;
  *(_QWORD *)(a1 + 608) = 0;
  *(_QWORD *)(a1 + 616) = 0;
  *(_QWORD *)(a1 + 624) = 0;
  *(_QWORD *)(a1 + 632) = 0;
  *(_QWORD *)(a1 + 640) = 0;
  *(_QWORD *)(a1 + 648) = 0;
  *(_QWORD *)(a1 + 656) = 0;
  *(_QWORD *)(a1 + 664) = 0;
  *(_QWORD *)(a1 + 672) = 0;
  v15 = (volatile signed __int32 *)a3[1];
  if ( v15 )
  {
    if ( _InterlockedExchangeAdd(v15 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
      if ( _InterlockedExchangeAdd(v15 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8LL))(v15);
    }
  }
  return a1;
}

// --- End Function: sub_140A64C30 (0x140A64C30) ---

// --- Function: sub_140A69BE0 (0x140A69BE0) ---
__int64 __fastcall sub_140A69BE0(_QWORD *a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx

  v1 = (volatile signed __int32 *)a1[2];
  a1[1] = 0;
  a1[2] = 0;
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  *a1 = 0;
  v4 = (volatile signed __int32 *)a1[2];
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
  }
  return result;
}

// --- End Function: sub_140A69BE0 (0x140A69BE0) ---

// --- Function: sub_140A724D0 (0x140A724D0) ---
__int64 __fastcall sub_140A724D0(char *a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm6
  bool v4; // zf
  __int64 v6; // r12
  char *v7; // r13
  char *v8; // rbx
  char *v9; // rsi
  __int64 *v10; // rax
  __int64 v11; // r15
  char *v12; // r14
  __int64 v13; // r13
  unsigned __int64 v14; // rdx
  __int128 v15; // xmm6
  __int64 v16; // rsi
  unsigned __int64 allocSize; // rdi
  char *v18; // r15
  int v19; // edi
  __int64 *ThreadLogContextSlot; // rax
  __int16 v21; // cx
  int v22; // esi
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v24; // rbx
  __int64 v26; // [rsp+20h] [rbp-E0h]
  int v27; // [rsp+28h] [rbp-D8h]
  __int64 *v28; // [rsp+50h] [rbp-B0h]
  __int128 v29; // [rsp+58h] [rbp-A8h] BYREF
  char v30; // [rsp+70h] [rbp-90h] BYREF
  char v31; // [rsp+71h] [rbp-8Fh]
  __int16 v32; // [rsp+72h] [rbp-8Eh]
  __int64 v33; // [rsp+74h] [rbp-8Ch]
  int v34; // [rsp+7Ch] [rbp-84h]
  unsigned __int64 v35; // [rsp+80h] [rbp-80h]
  unsigned __int64 v36; // [rsp+88h] [rbp-78h]
  __int64 v37; // [rsp+90h] [rbp-70h]
  __int64 v38; // [rsp+98h] [rbp-68h]
  __int128 v39; // [rsp+C0h] [rbp-40h] BYREF
  _QWORD v40[2]; // [rsp+D0h] [rbp-30h] BYREF
  _QWORD v41[2]; // [rsp+E0h] [rbp-20h] BYREF
  _QWORD v42[2]; // [rsp+F0h] [rbp-10h] BYREF
  _QWORD v43[2]; // [rsp+100h] [rbp+0h] BYREF
  __int64 v44; // [rsp+110h] [rbp+10h] BYREF
  __int64 v45; // [rsp+120h] [rbp+20h] BYREF
  int n147; // [rsp+128h] [rbp+28h]
  _BYTE v47[4]; // [rsp+12Ch] [rbp+2Ch] BYREF
  __int128 v48; // [rsp+140h] [rbp+40h]

  *(_QWORD *)&v29 = a2;
  v4 = *(_BYTE *)a3 == 1;
  v6 = a2;
  v45 = (__int64)a1;
  v7 = a1;
  if ( v4 )
  {
    v8 = 0;
    v9 = 0;
    if ( *(_QWORD *)(a3 + 16) )
      v10 = *(__int64 **)(a3 + 8);
    else
      v10 = &qword_149C87F50;
    v11 = *((int *)v10 + 6);
    v28 = v10;
    *(_QWORD *)&v39 = v11;
    if ( v11 )
    {
      v27 = 0;
      v26 = 0;
      v8 = (char *)allocWithProfilerInfo_w(16 * v11);
      v9 = &v8[16 * v11];
      v10 = v28;
    }
    v12 = v8;
    if ( v11 > 0 )
    {
      v48 = v3;
      v13 = 0;
      while ( 1 )
      {
        v14 = *(_QWORD *)(*(_QWORD *)(v10[4] + 8 * v13 + 8) + 16LL) & 0xFFFFFFFFFFFFFFFCuLL;
        if ( *(_QWORD *)(v14 + 24) > 0xFu )
          v14 = *(_QWORD *)v14;
        v15 = *(_OWORD *)sub_1402BC380(&v44, (char *)v14);
        if ( v8 >= v9 )
          break;
        *(_OWORD *)v8 = v15;
LABEL_24:
        v10 = v28;
        v8 += 16;
        if ( ++v13 >= v11 )
        {
          v6 = v29;
          v7 = (char *)v45;
          goto LABEL_26;
        }
      }
      v16 = (v8 - v12) >> 4;
      if ( v16 )
      {
        allocSize = 2 * v16;
        if ( !(2 * v16) )
        {
          v18 = 0;
LABEL_18:
          if ( v12 == v8 )
            v8 = v18;
          else
            v8 = (char *)memmove(v18, v12, v8 - v12) + 16 * v16;
          *(_OWORD *)v8 = v15;
          if ( v12 )
            sub_1402A3D30(v12);
          v12 = v18;
          v9 = &v18[allocSize];
          v11 = v39;
          goto LABEL_24;
        }
      }
      else
      {
        allocSize = 1;
      }
      allocSize *= 16LL;
      v27 = 0;
      v26 = 0;
      v18 = (char *)allocWithProfilerInfo_w(allocSize);
      goto LABEL_18;
    }
LABEL_26:
    v45 = 0x64000000DDLL;
    v40[0] = &v45;
    v40[1] = v47;
    n147 = 147;
    v19 = invokeGlobalCallbackAndMaskStatusBits(
            6,
            (__int64)v40,
            (__int64)"QueryActiveMissions Success",
            "Success. $$ ActiveMissions",
            v26,
            v27);
    if ( (v19 & 0xFFFFF) != 0 )
    {
      *(_QWORD *)&v29 = 0;
      *((_QWORD *)&v29 + 1) = (v8 - v12) >> 4;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v45 = 0x64000000DDLL;
      v41[0] = &v45;
      v41[1] = v47;
      n147 = 147;
      v39 = 0;
      sub_140351A20(
        6,
        (__int64)v41,
        "QueryActiveMissions Success",
        (__int64)"Success. $$ ActiveMissions",
        1,
        v19,
        &v39,
        0,
        (__int64)ThreadLogContextSlot,
        &v29);
    }
    v32 = 0;
    v33 = 1;
    v34 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v30 = 0;
    v35 = __rdtsc();
    v31 = *v7;
    qword_149B4B870(
      &v30,
      &word_149C87F80,
      "CMissionServiceExternal::QueryActiveMissions::<lambda_1>::operator ()",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CIGServices\\External\\Mission/MissionServiceExternal.cpp",
      120);
    v21 = word_149C87F80;
    *(_BYTE *)v6 = 1;
    v32 = v21;
    *(_QWORD *)(v6 + 8) = v12;
    *(_QWORD *)(v6 + 16) = v8;
    *(_QWORD *)(v6 + 24) = v9;
    v36 = __rdtsc();
    qword_149B4B878(&v30);
  }
  else
  {
    v45 = 0x64000000DDLL;
    v42[0] = &v45;
    v42[1] = v47;
    n147 = 147;
    v22 = invokeGlobalCallbackAndMaskStatusBits(
            4,
            (__int64)v42,
            (__int64)"QueryActiveMissions Fail",
            "Failed with Error: $$");
    if ( (v22 & 0xFFFFF) != 0 )
    {
      if ( *(_BYTE *)a3 )
        LogFatalError(
          "GetError should only be called on a result holding a T_Error object. Did you forget to do a cast-to-bool check first?");
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      v45 = 0x64000000DDLL;
      v43[0] = &v45;
      v24 = a3 + 8;
      v43[1] = v47;
      v29 = 0;
      n147 = 147;
      sub_1403518A0(
        4,
        (__int64)v43,
        "QueryActiveMissions Fail",
        (__int64)"Failed with Error: $$",
        1,
        v22,
        &v29,
        0,
        (__int64)ThreadLogContextSlot_1,
        a3 + 8);
    }
    else
    {
      v24 = a3 + 8;
    }
    v32 = 0;
    v33 = 1;
    v34 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v30 = 0;
    v35 = __rdtsc();
    v31 = *v7;
    qword_149B4B870(
      &v30,
      &word_149C87F84,
      "CMissionServiceExternal::QueryActiveMissions::<lambda_1>::operator ()",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CIGServices\\External\\Mission/MissionServiceExternal.cpp",
      126);
    v32 = word_149C87F84;
    if ( *(_BYTE *)a3 )
      LogFatalError(
        "GetError should only be called on a result holding a T_Error object. Did you forget to do a cast-to-bool check first?");
    *(_BYTE *)v6 = 0;
    *(_DWORD *)(v6 + 8) = *(_DWORD *)v24;
    *(_OWORD *)(v6 + 16) = 0;
    *(_QWORD *)(v6 + 32) = 0;
    *(_QWORD *)(v6 + 40) = 0;
    *(__m256i *)(v6 + 16) = *(__m256i *)(v24 + 8);
    *(_QWORD *)(v24 + 24) = 0;
    *(_QWORD *)(v24 + 32) = 15;
    *(_BYTE *)(v24 + 8) = 0;
    *(_OWORD *)(v6 + 48) = 0;
    *(_QWORD *)(v6 + 64) = 0;
    *(_QWORD *)(v6 + 72) = 0;
    *(__m256i *)(v6 + 48) = *(__m256i *)(v24 + 40);
    *(_QWORD *)(v24 + 56) = 0;
    *(_QWORD *)(v24 + 64) = 15;
    *(_BYTE *)(v24 + 40) = 0;
    v36 = __rdtsc();
    __asm { vzeroupper }
    qword_149B4B878(&v30);
  }
  return v6;
}

// --- End Function: sub_140A724D0 (0x140A724D0) ---

// --- Function: sub_140A81700 (0x140A81700) ---
__int64 __fastcall sub_140A81700(__int64 a1)
{
  return sub_140AA7E70(**(_QWORD **)(a1 + 16));
}

// --- End Function: sub_140A81700 (0x140A81700) ---

// --- Function: sub_140A81920 (0x140A81920) ---
__int64 *__fastcall sub_140A81920(__int64 a1)
{
  __int64 *result; // rax
  __int64 v2; // rcx

  result = *(__int64 **)(a1 + 16);
  v2 = *result;
  *(_DWORD *)(v2 + 108) = 0;
  *(_BYTE *)(v2 + 127) = 1;
  if ( *(_QWORD *)(v2 + 400) )
    return (__int64 *)sub_1478AE2B0();
  return result;
}

// --- End Function: sub_140A81920 (0x140A81920) ---

// --- Function: sub_140A81A00 (0x140A81A00) ---
__int64 __fastcall sub_140A81A00(__int64 a1)
{
  return sub_140A77A80(*(_QWORD *)(a1 + 16));
}

// --- End Function: sub_140A81A00 (0x140A81A00) ---

// --- Function: sub_140A81EC0 (0x140A81EC0) ---
__int64 __fastcall sub_140A81EC0(__int64 a1)
{
  return sub_140AB6280(**(_QWORD **)(a1 + 16));
}

// --- End Function: sub_140A81EC0 (0x140A81EC0) ---

// --- Function: sub_140A82880 (0x140A82880) ---
__int64 __fastcall sub_140A82880(__int64 a1)
{
  __int64 v1; // rdi
  bool v2; // al
  const char *p_sc.external.services.mission_service.v1.MissionService; // r8
  __int64 v4; // rbx

  v1 = *(_QWORD *)(a1 + 16);
  v2 = sub_1403BFA30((_QWORD *)(v1 + 32));
  p_sc.external.services.mission_service.v1.MissionService = "sc.external.services.mission_service.v1.MissionService";
  if ( !v2 )
    p_sc.external.services.mission_service.v1.MissionService = *(const char **)(v1 + 32);
  v4 = sub_140AB4180(*(_QWORD *)v1, *(_QWORD *)(v1 + 8), p_sc.external.services.mission_service.v1.MissionService);
  sub_140AB5890(*(_QWORD *)(v1 + 8), *(unsigned int *)(v1 + 24), *(unsigned __int8 *)(v1 + 28));
  return sub_140A56B40(*(_QWORD *)(v1 + 8), v4, *(_QWORD *)(v1 + 16));
}

// --- End Function: sub_140A82880 (0x140A82880) ---

// --- Function: sub_140A83340 (0x140A83340) ---
void __fastcall sub_140A83340(int a1, __int64 a2, _QWORD *a3)
{
  int v5; // ecx
  __int64 v6; // rax

  if ( a1 )
  {
    v5 = a1 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1402A3D30(*(const void **)(a2 + 16));
        *(_QWORD *)(a2 + 16) = 0;
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
      }
      return;
    }
  }
  else
  {
    LogFatalError("Can not request a copy for a CigMoveOnlyFunction, something's broken in the implementation");
  }
  if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)a2 = *a3;
      v6 = 1;
    }
    else
    {
      *(_QWORD *)(a2 + 16) = a3[2];
      *(_QWORD *)a2 = *a3;
      v6 = a3[1];
    }
    *(_QWORD *)(a2 + 8) = v6;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
  }
}

// --- End Function: sub_140A83340 (0x140A83340) ---

// --- Function: sub_140A837E0 (0x140A837E0) ---
void __fastcall sub_140A837E0(int a1, __int64 a2, _QWORD *a3)
{
  int v5; // ecx
  const void *v6; // rdi
  __int64 v7; // rax

  if ( a1 )
  {
    v5 = a1 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v6 = *(const void **)(a2 + 16);
        if ( v6 )
        {
          sub_140A69E00(*(__int64 **)(a2 + 16));
          sub_1402A3D30(v6);
        }
        *(_QWORD *)(a2 + 16) = 0;
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
      }
      return;
    }
  }
  else
  {
    LogFatalError("Can not request a copy for a CigMoveOnlyFunction, something's broken in the implementation");
  }
  if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)a2 = *a3;
      v7 = 1;
    }
    else
    {
      *(_QWORD *)(a2 + 16) = a3[2];
      *(_QWORD *)a2 = *a3;
      v7 = a3[1];
    }
    *(_QWORD *)(a2 + 8) = v7;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
  }
}

// --- End Function: sub_140A837E0 (0x140A837E0) ---

// --- Function: sub_140A83F40 (0x140A83F40) ---
void __fastcall sub_140A83F40(int a1, _QWORD *a2, _QWORD *a3)
{
  int v5; // ecx
  _QWORD *v6; // rdi
  __int64 v7; // rax

  if ( a1 )
  {
    v5 = a1 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v6 = (_QWORD *)a2[2];
        if ( v6 )
        {
          sub_140370D10(v6 + 4);
          sub_1402A3D30(v6);
        }
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
      return;
    }
  }
  else
  {
    LogFatalError("Can not request a copy for a CigMoveOnlyFunction, something's broken in the implementation");
  }
  if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      v7 = 1;
    }
    else
    {
      a2[2] = a3[2];
      *a2 = *a3;
      v7 = a3[1];
    }
    a2[1] = v7;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
  }
}

// --- End Function: sub_140A83F40 (0x140A83F40) ---

// --- Function: sub_140A8CBF0 (0x140A8CBF0) ---
__int64 __fastcall sub_140A8CBF0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx

  *(_BYTE *)a1 = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 == 1 )
  {
    result = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    v4 = *(_QWORD *)(a2 + 16);
    if ( v4 )
    {
      *(_QWORD *)(a1 + 16) = v4;
      *(_QWORD *)(a2 + 16) = 0;
      v5 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
      result = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 24) = v5;
      v6 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 8) = result;
      *(_QWORD *)(a2 + 8) = v6;
      __asm { vzeroupper }
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    result = 0;
    *(_OWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(__m256i *)(a1 + 16) = *(__m256i *)(a2 + 16);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 15;
    *(_BYTE *)(a2 + 16) = 0;
    *(_OWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
    *(__m256i *)(a1 + 48) = *(__m256i *)(a2 + 48);
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 72) = 15;
    *(_BYTE *)(a2 + 48) = 0;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140A8CBF0 (0x140A8CBF0) ---

// --- Function: sub_140A8E400 (0x140A8E400) ---
_QWORD *__fastcall sub_140A8E400(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5)
{
  *a2 = sub_140E49B60(a1, a3, a4, a5);
  return a2;
}

// --- End Function: sub_140A8E400 (0x140A8E400) ---

// --- Function: sub_140A8E850 (0x140A8E850) ---
__int64 __fastcall sub_140A8E850(_QWORD *a1, __int64 a2, __int64 **a3, char a4)
{
  __int64 *ThreadLogContextSlot; // rdx
  __int64 v7; // rax
  char v8; // r14
  int v9; // ebx
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v11; // rdi
  bool v12; // zf
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // r13
  __int64 v17; // rdi
  __int64 *v18; // r12
  __int64 v19; // rbx
  _DWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // r14
  __int64 v23; // rax
  unsigned __int8 *v24; // rax
  __int64 v25; // rax
  _QWORD *v26; // r8
  int v27; // edi
  __int64 v28; // rcx
  int v29; // ebx
  __int64 *ThreadLogContextSlot_2; // rax
  _QWORD *v31; // rax
  __int64 v32; // r8
  volatile signed __int32 *v33; // rcx
  int v34; // esi
  __int64 *ThreadLogContextSlot_3; // rax
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_1; // rcx
  __int64 v39; // rcx
  int v40; // ebx
  __int64 *ThreadLogContextSlot_4; // rax
  __int64 QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_2; // rax
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_3; // rcx
  volatile signed __int32 *v46; // rbx
  volatile signed __int32 *v47; // rbx
  volatile signed __int32 *v48; // rbx
  char v50; // [rsp+60h] [rbp-A0h] BYREF
  char v51; // [rsp+61h] [rbp-9Fh]
  char v52; // [rsp+70h] [rbp-90h] BYREF
  char v53; // [rsp+71h] [rbp-8Fh]
  __int16 v54; // [rsp+72h] [rbp-8Eh]
  __int64 v55; // [rsp+74h] [rbp-8Ch]
  int v56; // [rsp+7Ch] [rbp-84h]
  unsigned __int64 v57; // [rsp+80h] [rbp-80h]
  unsigned __int64 v58; // [rsp+88h] [rbp-78h]
  __int64 v59; // [rsp+90h] [rbp-70h]
  __int64 v60; // [rsp+98h] [rbp-68h]
  __int64 v61; // [rsp+C0h] [rbp-40h]
  __int128 v62; // [rsp+C8h] [rbp-38h] BYREF
  __int64 *v63; // [rsp+D8h] [rbp-28h]
  _QWORD *v64; // [rsp+E0h] [rbp-20h] BYREF
  _QWORD v65[3]; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v66; // [rsp+100h] [rbp+0h] BYREF
  void (__fastcall *n2_3)(__int64, __int64 *); // [rsp+108h] [rbp+8h]
  __int64 v68; // [rsp+110h] [rbp+10h]
  __int64 v69; // [rsp+118h] [rbp+18h] BYREF
  __int128 n2_2; // [rsp+120h] [rbp+20h]
  __int64 v71; // [rsp+130h] [rbp+30h] BYREF
  void (__fastcall *n2_1)(__int64, __int64 *); // [rsp+138h] [rbp+38h]
  __int64 v73; // [rsp+140h] [rbp+40h]
  __int64 v74; // [rsp+148h] [rbp+48h] BYREF
  __int128 n2; // [rsp+150h] [rbp+50h]
  __int64 v76; // [rsp+160h] [rbp+60h]
  __int64 v77; // [rsp+168h] [rbp+68h]
  __int16 v78; // [rsp+170h] [rbp+70h]
  __int64 v79; // [rsp+178h] [rbp+78h]
  volatile signed __int32 *v80; // [rsp+180h] [rbp+80h]
  char v81; // [rsp+188h] [rbp+88h]
  _QWORD v82[2]; // [rsp+190h] [rbp+90h] BYREF
  __int128 v83; // [rsp+1A0h] [rbp+A0h] BYREF
  char v84; // [rsp+1B0h] [rbp+B0h]
  char v85[8]; // [rsp+1B8h] [rbp+B8h] BYREF
  volatile signed __int32 *v86; // [rsp+1C0h] [rbp+C0h]
  volatile signed __int32 *v87; // [rsp+1D0h] [rbp+D0h]
  _QWORD v88[2]; // [rsp+1D8h] [rbp+D8h] BYREF
  _QWORD v89[2]; // [rsp+1E8h] [rbp+E8h] BYREF
  _QWORD v90[2]; // [rsp+1F8h] [rbp+F8h] BYREF
  _QWORD v91[2]; // [rsp+208h] [rbp+108h] BYREF
  _QWORD v92[2]; // [rsp+218h] [rbp+118h] BYREF
  _QWORD v93[2]; // [rsp+228h] [rbp+128h] BYREF
  _QWORD v94[2]; // [rsp+238h] [rbp+138h] BYREF
  _QWORD v95[2]; // [rsp+248h] [rbp+148h] BYREF
  _BYTE v96[24]; // [rsp+258h] [rbp+158h] BYREF
  __int64 v97[3]; // [rsp+270h] [rbp+170h] BYREF
  char v98[8]; // [rsp+288h] [rbp+188h] BYREF
  __int64 v99; // [rsp+290h] [rbp+190h] BYREF
  __m256 v100; // [rsp+298h] [rbp+198h]
  __m256 v101; // [rsp+2B8h] [rbp+1B8h]
  char v102[8]; // [rsp+2D8h] [rbp+1D8h] BYREF
  __int64 v103; // [rsp+2E0h] [rbp+1E0h] BYREF
  __m256 v104; // [rsp+2E8h] [rbp+1E8h]
  __m256 v105; // [rsp+308h] [rbp+208h]
  char v106[8]; // [rsp+328h] [rbp+228h] BYREF
  __int64 v107; // [rsp+330h] [rbp+230h] BYREF
  __m256 v108; // [rsp+338h] [rbp+238h]
  __m256 v109; // [rsp+358h] [rbp+258h]
  int n221; // [rsp+378h] [rbp+278h] BYREF
  int n100; // [rsp+37Ch] [rbp+27Ch]
  int n147; // [rsp+380h] [rbp+280h]
  _BYTE v113[4]; // [rsp+384h] [rbp+284h] BYREF
  char *QueryActiveMissions:_playerId_should_be_same_as_the_local_playe; // [rsp+388h] [rbp+288h] BYREF
  __int64 v115; // [rsp+390h] [rbp+290h]
  __int64 n66; // [rsp+398h] [rbp+298h]
  unsigned __int64 n79; // [rsp+3A0h] [rbp+2A0h]
  __int64 v118; // [rsp+3B0h] [rbp+2B0h] BYREF
  __m256 v119; // [rsp+3B8h] [rbp+2B8h] BYREF
  __m256 v120; // [rsp+3D8h] [rbp+2D8h] BYREF
  _DWORD v121[3]; // [rsp+400h] [rbp+300h] BYREF
  char v122; // [rsp+40Ch] [rbp+30Ch] BYREF
  char v123[8]; // [rsp+410h] [rbp+310h] BYREF
  __int64 v124; // [rsp+418h] [rbp+318h]
  char *v125; // [rsp+420h] [rbp+320h]
  char v126; // [rsp+428h] [rbp+328h] BYREF
  _BYTE v127[336]; // [rsp+630h] [rbp+530h] BYREF

  v50 = a4;
  v61 = a2;
  v64 = a1;
  ThreadLogContextSlot = getThreadLogContextSlot();
  v7 = 0;
  while ( !*((_BYTE *)ThreadLogContextSlot + v7) )
  {
    if ( (unsigned __int64)++v7 >= 0x10 )
    {
      v8 = 1;
      v51 = 1;
      sub_1404D4560();
      goto LABEL_6;
    }
  }
  v8 = 0;
  v51 = 0;
LABEL_6:
  if ( *a3 == a3[1] )
  {
    n221 = 221;
    v88[0] = &n221;
    n100 = 100;
    v88[1] = v113;
    n147 = 147;
    v9 = invokeGlobalCallbackAndMaskStatusBits(
           3,
           (__int64)v88,
           (__int64)"QueryActiveMissions Empty Request",
           "playerIds should never be empty");
    if ( (v9 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      v89[0] = &n221;
      v89[1] = v113;
      n221 = 221;
      v62 = 0;
      n100 = 100;
      n147 = 147;
      sub_1403515F0(
        3,
        (__int64)v89,
        "QueryActiveMissions Empty Request",
        (__int64)"playerIds should never be empty",
        1,
        v9,
        &v62,
        0,
        (__int64)ThreadLogContextSlot_1);
    }
    v54 = 0;
    v55 = 1;
    v56 = 0;
    v58 = 0;
    v59 = 0;
    v60 = 0;
    v53 = a4;
    v57 = __rdtsc();
    v52 = 0;
    qword_149B4B870(
      &v52,
      &word_149C87F10,
      "CMissionServiceExternal::QueryActiveMissions",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CIGServices\\External\\Mission/MissionServiceExternal.cpp",
      58);
    v54 = word_149C87F10;
    sub_1405BD480(&v118, 3, "QueryAvailableContracts: playerIds should never be empty");
    v11 = v61;
    v100 = v119;
    v101 = v120;
    v98[0] = 0;
    LODWORD(v99) = v118;
    *(_QWORD *)&v119.m256_f32[4] = 0;
    *(_QWORD *)&v119.m256_f32[6] = 15;
    LOBYTE(v119.m256_f32[0]) = 0;
    *(_QWORD *)&v120.m256_f32[4] = 0;
    *(_QWORD *)&v120.m256_f32[6] = 15;
    LOBYTE(v120.m256_f32[0]) = 0;
    __asm { vzeroupper }
    sub_140A40330(v61, v98);
    if ( v98[0] == 1 )
    {
      if ( v99 )
        sub_1402A3D30(v99);
    }
    else
    {
      sub_1403778D0(&v99);
    }
    sub_1403778D0(&v118);
    v58 = __rdtsc();
    qword_149B4B878(&v52);
    v12 = v8 == 0;
  }
  else
  {
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FD68 + 200LL))(qword_149B4FD68);
    v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 8LL))(v13);
    v15 = allocWithProfilerInfo_w(0x18u);
    if ( v15 )
    {
      *(_DWORD *)(v15 + 8) = 1;
      *(_QWORD *)v15 = off_14827B0A8;
      *(_DWORD *)(v15 + 12) = 1;
      *(_QWORD *)(v15 + 16) = v14;
    }
    else
    {
      v15 = 0;
    }
    v65[1] = v14;
    v65[2] = v15;
    v16 = sub_14104CE50(v14);
    v65[0] = v16;
    v17 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149B4FD30 + 40LL))(
                        qword_149B4FD30,
                        v127)
                    + 80);
    sub_14059AF30(v127);
    sub_140454430((__int64)v96, 10);
    v18 = *a3;
    v63 = a3[1];
    if ( v18 == v63 )
    {
LABEL_32:
      v66 = 0;
      n2_2 = 0;
      n2 = 0;
      n2_3 = 0;
      v68 = 0;
      v69 = 0;
      v71 = 0;
      n2_1 = 0;
      v73 = 0;
      v74 = 0;
      v76 = 0;
      v77 = 0;
      v78 = 0;
      v79 = 0;
      v80 = 0;
      v81 = 0;
      sub_14035B3E0(v82);
      v27 = (int)v64;
      n221 = 221;
      n100 = 100;
      n147 = 147;
      v28 = v64[244];
      v76 = v64[231];
      HIDWORD(v77) = *(_DWORD *)(v28 + 72);
      LODWORD(v77) = *(_DWORD *)(v28 + 112);
      v94[0] = &n221;
      v94[1] = v113;
      v29 = invokeGlobalCallbackAndMaskStatusBits(
              6,
              (__int64)v94,
              (__int64)"QueryActiveMissions Sent",
              "Sent. $$ players:");
      if ( (v29 & 0xFFFFF) != 0 )
      {
        v95[1] = a3[1] - *a3;
        v95[0] = 0;
        ThreadLogContextSlot_2 = getThreadLogContextSlot();
        v121[0] = 221;
        *(_QWORD *)&v62 = v121;
        *((_QWORD *)&v62 + 1) = &v122;
        v121[1] = 100;
        v121[2] = 147;
        v83 = 0;
        sub_140A5AD40(
          6,
          (unsigned int)&v62,
          (unsigned int)"QueryActiveMissions Sent",
          (unsigned int)"Sent. $$ players:",
          1,
          v29,
          (__int64)&v83,
          0,
          (__int64)ThreadLogContextSlot_2,
          (__int64)v95,
          (__int64)v96);
      }
      v31 = (_QWORD *)sub_140A35C50(
                        v27 + 1856,
                        (unsigned int)&v64,
                        (unsigned int)sub_140A8E400,
                        (unsigned int)v65,
                        (__int64)&v66);
      LOBYTE(v32) = 1;
      sub_140A9C280(*v31, v85, v32);
      if ( v64 )
      {
        v33 = (volatile signed __int32 *)((char *)v64 + *(int *)(v64[1] + 4LL) + 8);
        LODWORD(v63) = _InterlockedDecrement(v33 + 2);
        if ( (_DWORD)v63 )
        {
          if ( (int)v63 < 0 )
            LogFatalError("Deleting Reference Counted Object Twice");
        }
        else if ( v33 )
        {
          (**(void (__fastcall ***)(char *, __int64))v33)((char *)v33, 1);
        }
      }
      v11 = v61;
      sub_140A449C0(v85, v61, &v50);
      if ( v87 )
      {
        if ( _InterlockedExchangeAdd(v87 + 2, 0xFFFFFFFF) == 1 )
        {
          v46 = v87;
          (**(void (__fastcall ***)(volatile signed __int32 *))v87)(v87);
          if ( _InterlockedExchangeAdd(v46 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v87 + 8LL))(v87);
        }
      }
      if ( v86 )
      {
        if ( _InterlockedExchangeAdd(v86 + 2, 0xFFFFFFFF) == 1 )
        {
          v47 = v86;
          (**(void (__fastcall ***)(volatile signed __int32 *))v86)(v86);
          if ( _InterlockedExchangeAdd(v47 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v86 + 8LL))(v86);
        }
      }
      sub_140370D10(v82);
      v48 = v80;
      if ( v80 )
      {
        if ( _InterlockedExchangeAdd(v80 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v48)(v48);
          if ( _InterlockedExchangeAdd(v48 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v48 + 8LL))(v48);
        }
      }
      if ( (unsigned __int64)n2 >= 2 )
      {
        ((void (__fastcall *)(__int64, __int64 *))n2)(2, &v74);
        *(_QWORD *)&n2 = 0;
      }
      v74 = 0;
      if ( (unsigned __int64)n2_1 >= 2 )
      {
        n2_1(2, &v71);
        n2_1 = 0;
      }
      v71 = 0;
      if ( (unsigned __int64)n2_2 >= 2 )
      {
        ((void (__fastcall *)(__int64, __int64 *))n2_2)(2, &v69);
        *(_QWORD *)&n2_2 = 0;
      }
      v69 = 0;
      if ( (unsigned __int64)n2_3 >= 2 )
      {
        n2_3(2, &v66);
        n2_3 = 0;
      }
      v66 = 0;
    }
    else
    {
      while ( 1 )
      {
        v19 = *v18;
        if ( !*v18 )
          break;
        if ( v19 != v17 )
        {
          n221 = 221;
          v90[0] = &n221;
          n100 = 100;
          v90[1] = v113;
          n147 = 147;
          v34 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)v90,
                  (__int64)"QueryActiveMissions PlayerId Mismatch",
                  "playerId[$$] is different the local playerId[$$]");
          if ( (v34 & 0xFFFFF) != 0 )
          {
            QueryActiveMissions:_playerId_should_be_same_as_the_local_playe = 0;
            v115 = v17;
            LOBYTE(n66) = 0;
            *(_QWORD *)&v83 = 0;
            *((_QWORD *)&v83 + 1) = v19;
            v84 = 0;
            ThreadLogContextSlot_3 = getThreadLogContextSlot();
            n221 = 221;
            v91[0] = &n221;
            n100 = 100;
            v91[1] = v113;
            n147 = 147;
            v62 = 0;
            _crtLCMapStringA_6(
              3,
              (unsigned int)v91,
              (unsigned int)"QueryActiveMissions PlayerId Mismatch",
              (unsigned int)"playerId[$$] is different the local playerId[$$]",
              1,
              v34,
              (__int64)&v62,
              0,
              (__int64)ThreadLogContextSlot_3,
              (__int64)&v83,
              (__int64)&QueryActiveMissions:_playerId_should_be_same_as_the_local_playe);
          }
          v54 = 0;
          v55 = 1;
          v56 = 0;
          v58 = 0;
          v59 = 0;
          v60 = 0;
          v52 = 0;
          v57 = __rdtsc();
          v53 = v50;
          qword_149B4B870(
            &v52,
            &word_149C87F4C,
            "CMissionServiceExternal::QueryActiveMissions",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CIGServices\\External\\Mission/MissionServiceExternal.cpp",
            86);
          v54 = word_149C87F4C;
          v115 = 0;
          QueryActiveMissions:_playerId_should_be_same_as_the_local_playe = (char *)allocWithProfilerInfo_w(0x50u);
          n66 = 66;
          strcpy(
            QueryActiveMissions:_playerId_should_be_same_as_the_local_playe,
            "QueryActiveMissions: playerId should be same as the local playerId");
          n79 = 79;
          LODWORD(v118) = 3;
          __asm { vzeroupper }
          sub_1402FBA60(
            (__int64)&v119,
            (__int64)&QueryActiveMissions:_playerId_should_be_same_as_the_local_playe,
            v36,
            v37);
          *(_QWORD *)&v120.m256_f32[6] = 15;
          memset(&v120, 0, 24);
          LOBYTE(v120.m256_f32[0]) = 0;
          if ( n79 > 0xF )
          {
            QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_1 = (__int64)QueryActiveMissions:_playerId_should_be_same_as_the_local_playe;
            if ( n79 + 1 >= 0x1000 )
            {
              QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_1 = *((_QWORD *)QueryActiveMissions:_playerId_should_be_same_as_the_local_playe
                                                                                  - 1);
              if ( (unsigned __int64)&QueryActiveMissions:_playerId_should_be_same_as_the_local_playe[-QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_1 - 8] > 0x1F )
                invalid_parameter_noinfo_noreturn();
            }
            sub_1402A3D30(QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_1);
          }
          v11 = v61;
          v104 = v119;
          v105 = v120;
          v102[0] = 0;
          LODWORD(v103) = v118;
          *(_QWORD *)&v119.m256_f32[4] = 0;
          *(_QWORD *)&v119.m256_f32[6] = 15;
          LOBYTE(v119.m256_f32[0]) = 0;
          __asm { vzeroupper }
          sub_140A40330(v61, v102);
          if ( v102[0] == 1 )
          {
            v39 = v103;
            if ( !v103 )
              goto LABEL_49;
            goto LABEL_47;
          }
          sub_1403778D0(&v103);
          goto LABEL_49;
        }
        v20 = *(_DWORD **)(v16 + 32);
        if ( v20 && (v21 = *(int *)(v16 + 24), (int)v21 < *v20) )
        {
          v22 = *(_QWORD *)&v20[2 * v21 + 2];
          *(_DWORD *)(v16 + 24) = v21 + 1;
        }
        else
        {
          v23 = sub_14104CED0(*(_QWORD *)(v16 + 16));
          v22 = sub_147BCBA90(v16 + 16, v23);
        }
        v24 = (unsigned __int8 *)sub_14040A6B0((__int64)&v118, v19);
        v25 = sub_140400EF0(v24, (__int64)v123);
        v26 = (_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        if ( (*(_BYTE *)(v22 + 8) & 1) != 0 )
          v26 = (_QWORD *)*v26;
        sub_140A9A290(v22 + 16, *(_QWORD *)(v25 + 16), v26);
        if ( v125 != &v126 )
        {
          qword_149B3AB68 += -1 - v124;
          sub_147605980(v125);
        }
        if ( LOBYTE(v119.m256_f32[6]) >= 2u && (unsigned __int8)(LOBYTE(v119.m256_f32[6]) - 2) >= 2u )
          sub_140370D10(&v119.m256_f32[2]);
        v115 = v19;
        QueryActiveMissions:_playerId_should_be_same_as_the_local_playe = 0;
        LOBYTE(n66) = 0;
        sub_140A34F10(v96, "$$", &QueryActiveMissions:_playerId_should_be_same_as_the_local_playe);
        if ( ++v18 == v63 )
          goto LABEL_32;
      }
      n221 = 221;
      v92[0] = &n221;
      n100 = 100;
      v92[1] = v113;
      n147 = 147;
      v40 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)v92,
              (__int64)"QueryActiveMissions Invalid PlayerId",
              "playerId should never be INVALID_ENTITYID");
      if ( (v40 & 0xFFFFF) != 0 )
      {
        ThreadLogContextSlot_4 = getThreadLogContextSlot();
        v93[0] = &n221;
        v93[1] = v113;
        n221 = 221;
        v62 = 0;
        n100 = 100;
        n147 = 147;
        sub_1403515F0(
          3,
          (__int64)v93,
          "QueryActiveMissions Invalid PlayerId",
          (__int64)"playerId should never be INVALID_ENTITYID",
          1,
          v40,
          &v62,
          0,
          (__int64)ThreadLogContextSlot_4);
      }
      v54 = 0;
      v55 = 1;
      v56 = 0;
      v58 = 0;
      v59 = 0;
      v60 = 0;
      v52 = 0;
      v57 = __rdtsc();
      v53 = v50;
      qword_149B4B870(
        &v52,
        &word_149C87F48,
        "CMissionServiceExternal::QueryActiveMissions",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CIGServices\\External\\Mission/MissionServiceExternal.cpp",
        78);
      v54 = word_149C87F48;
      v115 = 0;
      QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_2 = allocWithProfilerInfo_w(0x40u);
      QueryActiveMissions:_playerId_should_be_same_as_the_local_playe = (char *)QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_2;
      n66 = 62;
      qmemcpy(
        (void *)QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_2,
        "QueryActiveMissions: playerId should never be IN",
        48);
      *(double *)(QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_2 + 48) = 0x4E455F44494C4156LL;
      strcpy((char *)(QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_2 + 56), "TITYID");
      n79 = 63;
      LODWORD(v118) = 3;
      __asm { vzeroupper }
      sub_1402FBA60((__int64)&v119, (__int64)&QueryActiveMissions:_playerId_should_be_same_as_the_local_playe, v43, v44);
      *(_QWORD *)&v120.m256_f32[6] = 15;
      memset(&v120, 0, 24);
      LOBYTE(v120.m256_f32[0]) = 0;
      if ( n79 > 0xF )
      {
        QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_3 = (__int64)QueryActiveMissions:_playerId_should_be_same_as_the_local_playe;
        if ( n79 + 1 >= 0x1000 )
        {
          QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_3 = *((_QWORD *)QueryActiveMissions:_playerId_should_be_same_as_the_local_playe
                                                                              - 1);
          if ( (unsigned __int64)&QueryActiveMissions:_playerId_should_be_same_as_the_local_playe[-QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_3
                                                                                                - 8] > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_1402A3D30(QueryActiveMissions:_playerId_should_be_same_as_the_local_playe_3);
      }
      v11 = v61;
      v108 = v119;
      v109 = v120;
      v106[0] = 0;
      LODWORD(v107) = v118;
      *(_QWORD *)&v119.m256_f32[4] = 0;
      *(_QWORD *)&v119.m256_f32[6] = 15;
      LOBYTE(v119.m256_f32[0]) = 0;
      __asm { vzeroupper }
      sub_140A40330(v61, v106);
      if ( v106[0] == 1 )
      {
        v39 = v107;
        if ( v107 )
LABEL_47:
          sub_1402A3D30(v39);
      }
      else
      {
        sub_1403778D0(&v107);
      }
LABEL_49:
      sub_1403778D0(&v118);
      v58 = __rdtsc();
      qword_149B4B878(&v52);
    }
    sub_140462B30(v97);
    std::vector<gte::Vector<3,double>>::_Tidy((std::vector<gte::Vector<3,double>> *)v96);
    sub_140A69BE0(v65);
    v12 = v51 == 0;
  }
  if ( !v12 )
    sub_1404D06B0();
  return v11;
}

// --- End Function: sub_140A8E850 (0x140A8E850) ---

// --- Function: sub_140A9A290 (0x140A9A290) ---
__int64 __fastcall sub_140A9A290(__int64 a1, _BYTE *a2, __int64 a3)
{
  size_t Size; // r8
  __int64 result; // rax
  const void *v7; // rcx
  __int128 v8; // [rsp+20h] [rbp-38h] BYREF
  __int128 v9; // [rsp+30h] [rbp-28h]

  v8 = 0;
  v9 = 0;
  Size = -1;
  do
    ++Size;
  while ( a2[Size] );
  sub_1402FB100(&v8, a2, Size);
  result = sub_147BCA300(a1, &v8, a3);
  if ( *((_QWORD *)&v9 + 1) > 0xFu )
  {
    v7 = (const void *)v8;
    if ( (unsigned __int64)(*((_QWORD *)&v9 + 1) + 1LL) >= 0x1000 )
    {
      v7 = *(const void **)(v8 - 8);
      if ( (unsigned __int64)(v8 - (_QWORD)v7 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    return sub_1402A3D30(v7);
  }
  return result;
}

// --- End Function: sub_140A9A290 (0x140A9A290) ---

// --- Function: sub_140A9B8C0 (0x140A9B8C0) ---
_QWORD *__fastcall sub_140A9B8C0(__int64 a1, _QWORD *a2, char a3, char a4)
{
  _QWORD *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // r8
  std::shared_ptr<vraudio::MixerNode> *_Right; // rax
  volatile signed __int32 *v11; // rbx
  __int64 v12; // rsi
  __int64 v13; // rdi
  char v14; // bl
  __int64 v15; // rdx
  const char *p_star_engine; // r14
  __int64 v17; // r8
  __int64 v18; // rdx
  unsigned int v19; // ebx
  __int64 v20; // rdx
  int v21; // eax
  __int64 v22; // rbx
  __int64 v23; // rbx
  __int64 v24; // rax
  __int64 v25; // rcx
  int v27; // [rsp+50h] [rbp-38h] BYREF
  volatile signed __int32 *v28; // [rsp+58h] [rbp-30h]
  char v29; // [rsp+90h] [rbp+8h] BYREF

  *(_BYTE *)(a1 + 384) = a3;
  *(_BYTE *)(a1 + 385) = a4;
  v6 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)qword_149B4FC40 + 72LL))(qword_149B4FC40, &v29);
  v7 = *(_QWORD *)(a1 + 520);
  *(_QWORD *)(a1 + 192) = *v6;
  v8 = *(_QWORD *)(v7 + 56);
  v9 = *(_QWORD *)(v7 + 8);
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)(v8 + 8));
  _Right = (std::shared_ptr<vraudio::MixerNode> *)sub_140A85550((int)&v27, "grpc: %s - %s", v9);
  std::shared_ptr<vraudio::MixerNode>::operator=((std::shared_ptr<vraudio::MixerNode> *)(a1 + 368), _Right);
  v11 = v28;
  v12 = -1;
  if ( v28 )
  {
    if ( _InterlockedExchangeAdd(v28 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
    }
  }
  v13 = *(_QWORD *)(a1 + 368);
  v14 = *(_BYTE *)(a1 + 384);
  sub_1404D4480((_OWORD *)(v13 + 8));
  LOBYTE(v15) = v14 != 0;
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 16LL))(v13, v15);
  p_star_engine = &byte_149B4FFC0;
  v17 = -1;
  if ( !qword_149B4FDB8 )
    p_star_engine = "star-engine";
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8LL);
  do
    ++v17;
  while ( *(_BYTE *)(v18 + v17) );
  v19 = ~(unsigned int)psub_1403360E0(0xFFFFFFFF, v18, v17);
  v20 = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 16LL);
  do
    ++v12;
  while ( *(_BYTE *)(v20 + v12) );
  v21 = psub_1403360E0(0xFFFFFFFF, v20, v12);
  sub_1403A9130((char **)(a1 + 392), "%s=%u", p_star_engine, v19 + ~v21);
  v22 = *(_QWORD *)(a1 + 368);
  if ( *(_BYTE *)(v22 + 56) )
  {
    sub_140384840((void **)(a1 + 392), ", ");
    sub_140384840((void **)(a1 + 392), (char *)(v22 + 56));
  }
  v23 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 152) + 8LL))(*(_QWORD *)(a1 + 152));
  *(_QWORD *)(a1 + 144) = (**(__int64 (__fastcall ***)(__int64))v23)(v23);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v23 + 8LL))(v23, a1 + 480);
  v24 = *(_QWORD *)(a1 + 8);
  *a2 = a1;
  v25 = a1 + 8 + *(int *)(v24 + 4);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v25 + 8LL))(v25);
  sub_1404D06B0();
  return a2;
}

// --- End Function: sub_140A9B8C0 (0x140A9B8C0) ---

// --- Function: sub_140A9C280 (0x140A9C280) ---
_OWORD *__fastcall sub_140A9C280(__int64 a1, _OWORD *a2, char a3)
{
  _QWORD *v6; // rax
  __int64 v7; // rcx
  int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rsi
  _DWORD *v11; // r12
  int v12; // edi
  unsigned __int32 v13; // eax
  __int64 v14; // rax
  void (__fastcall *n2)(__int64, __int64); // rax
  int v16; // eax
  unsigned __int32 v17; // eax
  __int64 v18; // rcx
  __int64 v19; // rbx
  __int64 v20; // rbx
  __int64 *(__fastcall *p_sub_140A81920)(__int64); // [rsp+20h] [rbp-79h] BYREF
  void (__fastcall *p_sub_140A837E0)(int, __int64, __int64 *(__fastcall **)(__int64)); // [rsp+28h] [rbp-71h]
  _QWORD *v24; // [rsp+30h] [rbp-69h]
  __int128 v25; // [rsp+40h] [rbp-59h] BYREF
  __int128 v26; // [rsp+50h] [rbp-49h]
  __int128 v27; // [rsp+60h] [rbp-39h] BYREF
  __int128 v28; // [rsp+70h] [rbp-29h]
  _QWORD v29[5]; // [rsp+80h] [rbp-19h] BYREF
  __int128 v30; // [rsp+A8h] [rbp+Fh]
  __int64 v31; // [rsp+108h] [rbp+6Fh] BYREF

  sub_140A3F350((volatile signed __int32 **)&v25);
  if ( a1 )
    _InterlockedIncrement((volatile signed __int32 *)(*(int *)(*(_QWORD *)(a1 + 8) + 4LL) + a1 + 16));
  v6 = (_QWORD *)allocWithProfilerInfo_w(8u);
  if ( v6 )
  {
    *v6 = a1;
    v24 = v6;
    p_sub_140A81920 = sub_140A81920;
    p_sub_140A837E0 = (void (__fastcall *)(int, __int64, __int64 *(__fastcall **)(__int64)))sub_140A837E0;
  }
  else
  {
    v24 = 0;
    p_sub_140A81920 = sub_140A81920;
    p_sub_140A837E0 = (void (__fastcall *)(int, __int64, __int64 *(__fastcall **)(__int64)))sub_140A837E0;
    if ( a1 )
    {
      v7 = a1 + *(int *)(*(_QWORD *)(a1 + 8) + 4LL) + 8LL;
      v8 = _InterlockedDecrement((volatile signed __int32 *)(v7 + 8));
      if ( v8 )
      {
        if ( v8 < 0 )
          LogFatalError("Deleting Reference Counted Object Twice");
      }
      else if ( v7 )
      {
        (**(void (__fastcall ***)(__int64, __int64))v7)(v7, 1);
      }
    }
  }
  v9 = NtCurrentTeb_w();
  v10 = v25;
  v11 = (_DWORD *)(v25 + 16);
  v12 = *(_DWORD *)(v9 + 24);
  if ( *(_DWORD *)(v25 + 16) == v12 )
  {
    ++*(_DWORD *)(v25 + 20);
  }
  else
  {
    v13 = _InterlockedCompareExchange((volatile signed __int32 *)v25, 1, 0);
    if ( v13 )
    {
      v10 = v25;
      sub_1403C33A0(
        v25,
        v13,
        "CPromiseBase<class CigResult<struct SProtobufArenaMessage<class sc::external::services::mission_service::v1::Que"
        "ryActiveMissionsResponse>,struct CigError> >::SetCancelCallback",
        1);
    }
    else
    {
      v14 = NtCurrentTeb_w();
      v10 = v25;
      *(_QWORD *)(v25 + 8) = *(_QWORD *)(v14 + 32);
    }
    *v11 = v12;
  }
  n2 = *(void (__fastcall **)(__int64, __int64))(v10 + 40);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, v10 + 32);
    *(_QWORD *)(v10 + 40) = 0;
  }
  *(_QWORD *)(v10 + 32) = 0;
  if ( p_sub_140A837E0 == (void (__fastcall *)(int, __int64, __int64 *(__fastcall **)(__int64)))1 )
  {
    *(_QWORD *)(v10 + 32) = p_sub_140A81920;
    *(_QWORD *)(v10 + 40) = p_sub_140A837E0;
  }
  else
  {
    if ( !p_sub_140A837E0 )
      goto LABEL_26;
    p_sub_140A837E0(1, v10 + 32, &p_sub_140A81920);
  }
  if ( (unsigned __int64)p_sub_140A837E0 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 *(__fastcall **)(__int64)))p_sub_140A837E0)(2, &p_sub_140A81920);
    p_sub_140A837E0 = 0;
  }
  p_sub_140A81920 = 0;
LABEL_26:
  v16 = *(_DWORD *)(v10 + 20);
  if ( v16 )
  {
    *(_DWORD *)(v10 + 20) = v16 - 1;
  }
  else
  {
    *v11 = -1;
    v17 = _InterlockedCompareExchange((volatile signed __int32 *)v10, 0, 1);
    v10 = v25;
    if ( v17 == 1 )
      *(_QWORD *)(v25 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(v25, v17);
  }
  if ( (unsigned __int64)p_sub_140A837E0 >= 2 )
    ((void (__fastcall *)(__int64, __int64 *(__fastcall **)(__int64)))p_sub_140A837E0)(2, &p_sub_140A81920);
  sub_14035AE20(v29, (_QWORD *)(a1 + 608));
  v29[4] = *((_QWORD *)&v25 + 1);
  v30 = v26;
  v29[3] = v10;
  v25 = 0;
  v26 = 0;
  sub_140A335B0((_QWORD *)(a1 + 608), v29);
  sub_140A9B8C0(a1, &v31, a3, 1);
  if ( v31 )
  {
    v18 = v31 + 8 + *(int *)(*(_QWORD *)(v31 + 8) + 4LL);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 16LL))(v18);
  }
  *a2 = v27;
  a2[1] = v28;
  v27 = 0;
  v28 = 0;
  sub_140370B50((__int64)&v27);
  if ( *((_QWORD *)&v26 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v26 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      v19 = *((_QWORD *)&v26 + 1);
      (***((void (__fastcall ****)(_QWORD))&v26 + 1))(*((_QWORD *)&v26 + 1));
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v19 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v26 + 1) + 8LL))(*((_QWORD *)&v26 + 1));
    }
  }
  if ( *((_QWORD *)&v25 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v25 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      v20 = *((_QWORD *)&v25 + 1);
      (***((void (__fastcall ****)(_QWORD))&v25 + 1))(*((_QWORD *)&v25 + 1));
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v20 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v25 + 1) + 8LL))(*((_QWORD *)&v25 + 1));
    }
  }
  return a2;
}

// --- End Function: sub_140A9C280 (0x140A9C280) ---

// --- Function: sub_140E49B60 (0x140E49B60) ---
__int64 __fastcall sub_140E49B60(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int128 v8; // xmm1
  __m256 v10; // [rsp+30h] [rbp-38h] BYREF
  __int128 v11; // [rsp+50h] [rbp-18h]

  (*(void (__fastcall **)(_QWORD, __m256 *, __int64, __int64, __int64))(**(_QWORD **)(a1 + 8) + 16LL))(
    *(_QWORD *)(a1 + 8),
    &v10,
    a1 + 40,
    a2,
    a4);
  v6 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)qword_151709B08 + 296LL))(
         qword_151709B08,
         *(_QWORD *)&v10.m256_f32[4],
         216);
  v7 = v6;
  if ( v6 )
  {
    v8 = v11;
    *(__m256 *)(v6 + 16) = v10;
    *(_QWORD *)(v6 + 8) = a2;
    *(_QWORD *)v6 = off_1482C2658;
    *(_OWORD *)(v6 + 48) = v8;
    *(_QWORD *)(v6 + 80) = 0;
    *(_QWORD *)(v6 + 144) = 0;
    *(_QWORD *)(v6 + 208) = 0;
    *(_WORD *)(v6 + 64) = 0;
  }
  else
  {
    v7 = 0;
  }
  __asm { vzeroupper }
  sub_140E44F30(LODWORD(v10.m256_f32[4]), v7 + 72, v7 + 88, v7 + 152, a3);
  return v7;
}

// --- End Function: sub_140E49B60 (0x140E49B60) ---

// --- Function: sub_14104CE50 (0x14104CE50) ---
__int64 __fastcall sub_14104CE50(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = sub_147BE1260(a1, 48);
    *(_QWORD *)(result + 8) = a1;
    *(_QWORD *)result = off_148362B28;
    *(_QWORD *)(result + 16) = a1;
  }
  else
  {
    result = allocWithProfilerInfo_w(0x30u);
    if ( !result )
      return 0;
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)result = off_148362B28;
    *(_QWORD *)(result + 16) = 0;
  }
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

// --- End Function: sub_14104CE50 (0x14104CE50) ---

// --- Function: sub_14104CED0 (0x14104CED0) ---
__int64 __fastcall sub_14104CED0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = sub_147BE1260(a1, 32);
    *(_QWORD *)(result + 8) = a1;
  }
  else
  {
    result = allocWithProfilerInfo_w(0x20u);
    if ( !result )
      return 0;
    *(_QWORD *)(result + 8) = 0;
  }
  *(_QWORD *)result = off_1483629E0;
  *(_DWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 16) = &qword_15170F800;
  return result;
}

// --- End Function: sub_14104CED0 (0x14104CED0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: sub_147BCA300 (0x147BCA300) ---
// Hidden C++ exception states: #wind=5
__int64 *__fastcall sub_147BCA300(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  __int64 v6; // rcx
  __int64 *result; // rax
  __int64 v8; // r9
  __int64 *v9; // rdi
  size_t Size; // r8
  char v11[8]; // [rsp+28h] [rbp-30h] BYREF
  __int64 *v12; // [rsp+30h] [rbp-28h]

  v4 = a2;
  v6 = *a1;
  if ( (v6 & 3) != 0 )
  {
    if ( a2[3] >= 0x10u )
      v4 = (_QWORD *)*a2;
    return sub_1402FAE70((__int64 *)(v6 & 0xFFFFFFFFFFFFFFFCuLL), v4, a2[2], a4);
  }
  else if ( a3 )
  {
    result = (__int64 *)sub_147BCA030(v11, a3, a2);
    *a1 = *result;
  }
  else
  {
    result = (__int64 *)allocWithProfilerInfo_w(0x20u);
    v9 = result;
    v12 = result;
    if ( result )
    {
      Size = v4[2];
      if ( v4[3] >= 0x10u )
        v4 = (_QWORD *)*v4;
      result[2] = 0;
      result[3] = 15;
      *(_BYTE *)result = 0;
      result = sub_1402FAE70(result, v4, Size, v8);
    }
    else
    {
      v9 = 0;
    }
    *a1 = (unsigned __int64)v9 | 2;
  }
  return result;
}

// --- End Function: sub_147BCA300 (0x147BCA300) ---

// --- Function: sub_147BCBA90 (0x147BCBA90) ---
__int64 __fastcall sub_147BCBA90(__int64 a1, __int64 a2)
{
  int *v4; // rcx
  int v5; // eax
  __int64 result; // rax

  v4 = *(int **)(a1 + 16);
  if ( !v4 || (v5 = *v4, *v4 == *(_DWORD *)(a1 + 12)) )
  {
    sub_147BCBCA0(a1, 1);
    v4 = *(int **)(a1 + 16);
    v5 = *v4;
  }
  *v4 = v5 + 1;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8LL * *(int *)(a1 + 8) + 8) = a2;
  result = a2;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

// --- End Function: sub_147BCBA90 (0x147BCBA90) ---

// --- Function: sub_147BCBCA0 (0x147BCBCA0) ---
__int64 __fastcall sub_147BCBCA0(__int64 *a1, int a2)
{
  __int64 v3; // rcx
  int n1073741819; // eax
  int n0x7FFFFFFF; // edi
  int *v6; // rsi
  __int64 v8; // rbp
  int n0x7FFFFFFF_1; // eax
  _DWORD *v10; // rax
  __int64 v11; // r14
  __int64 v12; // rcx
  unsigned __int64 v13; // r14
  __int64 v14; // rcx
  __int64 v15; // rbp
  unsigned __int64 v16; // r8
  _QWORD *v17; // rdx
  unsigned __int64 v18; // rax
  __int64 v19; // rax
  unsigned __int64 n64_1; // r14
  __int64 v21; // rax
  int *buf; // rdi
  unsigned __int64 v23; // rcx
  char n64; // cl

  v3 = *((int *)a1 + 2);
  n1073741819 = *((_DWORD *)a1 + 3);
  n0x7FFFFFFF = v3 + a2;
  v6 = (int *)a1[2];
  if ( n1073741819 >= (int)v3 + a2 )
    return (__int64)&v6[2 * v3 + 2];
  v8 = *a1;
  if ( n0x7FFFFFFF >= 1 )
  {
    if ( n1073741819 <= 1073741819 )
    {
      n0x7FFFFFFF_1 = 2 * n1073741819 + 1;
      if ( n0x7FFFFFFF_1 >= n0x7FFFFFFF )
        n0x7FFFFFFF = n0x7FFFFFFF_1;
    }
    else
    {
      n0x7FFFFFFF = 0x7FFFFFFF;
    }
  }
  else
  {
    n0x7FFFFFFF = 1;
  }
  if ( v8 )
    v10 = (_DWORD *)sub_147BE1270(*a1, 8LL * n0x7FFFFFFF + 8, &char `RTTI Type Descriptor');
  else
    v10 = (_DWORD *)allocWithProfilerInfo_w(8LL * n0x7FFFFFFF + 8);
  a1[2] = (__int64)v10;
  v11 = *((int *)a1 + 3);
  *((_DWORD *)a1 + 3) = n0x7FFFFFFF;
  if ( v6 )
  {
    v12 = *v6;
    if ( (int)v12 > 0 )
    {
      memcpy(v10 + 2, v6 + 2, 8 * v12);
      LODWORD(v12) = *v6;
    }
    v13 = 8 * v11 + 8;
    *(_DWORD *)a1[2] = v12;
    if ( v8 )
    {
      v14 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 6280LL;
      if ( *(_QWORD *)(v14 + 8) == *(_QWORD *)*a1 )
      {
        v15 = *(_QWORD *)(v14 + 16);
      }
      else
      {
        v15 = *(_QWORD *)(*a1 + 24);
        if ( !v15 || *(_QWORD *)v15 != v14 )
          return a1[2] + 8LL * *((int *)a1 + 2) + 8;
      }
      v16 = *(unsigned __int8 *)(v15 + 64);
      v17 = *(_QWORD **)(v15 + 72);
      _BitScanReverse64(&v18, v13);
      v19 = (unsigned int)(v18 - 4);
      if ( (unsigned int)v19 < v16 )
      {
        *(_QWORD *)v6 = v17[v19];
        v17[(unsigned int)v19] = v6;
      }
      else
      {
        n64_1 = v13 >> 3;
        memmove(v6, v17, 8 * v16);
        v21 = *(unsigned __int8 *)(v15 + 64);
        buf = &v6[2 * v21];
        v23 = (8 * n64_1 - 8 * v21 + 7) >> 3;
        if ( buf > &v6[2 * n64_1] )
          v23 = 0;
        if ( v23 )
          memset(buf, 0, 8 * v23);
        n64 = 64;
        *(_QWORD *)(v15 + 72) = v6;
        if ( n64_1 < 0x40 )
          n64 = n64_1;
        *(_BYTE *)(v15 + 64) = n64;
      }
      return a1[2] + 8LL * *((int *)a1 + 2) + 8;
    }
    sub_1402A3D30(v6);
  }
  else
  {
    *v10 = 0;
  }
  return a1[2] + 8LL * *((int *)a1 + 2) + 8;
}

// --- End Function: sub_147BCBCA0 (0x147BCBCA0) ---

// --- Function: sub_147BE1260 (0x147BE1260) ---
// attributes: thunk
__int64 __fastcall sub_147BE1260(__int64 a1, __int64 a2)
{
  return sub_147BE0BC0(a1, a2);
}

// --- End Function: sub_147BE1260 (0x147BE1260) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

