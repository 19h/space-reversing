// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1468C1420 (CEntity::ChangeOwnerEntity)
// Caller Depth: 0
// Callee/Ref Depth: 1
// Total Functions Found: 29
// ------------------------------------------------------------

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: LogTraceConditional (0x1402BED30) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list varargs; // [rsp+38h] [rbp+10h] BYREF

  va_start(varargs, format_string);
  if ( qword_14981D3D8 && CSystem )
  {
    if ( qword_14981D2D0 )
    {
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_14981D2D0 + 8LL))(
        qword_14981D2D0,
        3,
        format_string,
        (__int64 *)varargs);
    }
  }
}

// --- End Function: LogTraceConditional (0x1402BED30) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1402D0950 (0x1402D0950) ---
unsigned __int64 __fastcall sub_1402D0950(__int64 a1)
{
  unsigned __int64 tls_data_offset_784; // rax
  unsigned __int64 v3; // rdx

  tls_data_offset_784 = get_tls_data_offset_784();
  if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(tls_data_offset_784 + 0x18)
    && (tls_data_offset_784 = *(unsigned int *)(a1 + 0xC), (_DWORD)tls_data_offset_784) )
  {
    tls_data_offset_784 = (unsigned int)(tls_data_offset_784 - 1);
    *(_DWORD *)(a1 + 0xC) = tls_data_offset_784;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      tls_data_offset_784 = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
      {
        return sub_1403C6F70((volatile signed __int64 *)a1, v3);
      }
    }
  }
  return tls_data_offset_784;
}

// --- End Function: sub_1402D0950 (0x1402D0950) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !off_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !off_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: is_valid_handle_typeB (0x14030C8B0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *packed_handle_ptr)
{
  unsigned __int64 packed_handle_value; // r9
  __int64 handle_ptr; // r10
  unsigned __int64 handle_flags; // r9
  __int64 mask_from_flag; // rax
  __int64 handle_ptr_copy; // r10
  __int64 metadata_ptr; // rbx
  bool is_thread_state_ok; // al

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_ptr = packed_handle_value & 0xFFFFFFFFFFFFLL;
  handle_flags = HIWORD(packed_handle_value);
  if ( (handle_flags & 0xF000) != 0 )
  {
    mask_from_flag = map_flag_to_mask(0x2000u);
    metadata_ptr = handle_ptr_copy & ~(mask_from_flag - 1);
  }
  else
  {
    metadata_ptr = handle_ptr - 6;
  }
  if ( *(_WORD *)(metadata_ptr + 2) != (handle_flags & 0xFFF) )
  {
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (is_thread_state_ok = is_thread_flag_57_or_38_set()) )
  {
    is_thread_state_ok = 1;
  }
  return *(_WORD *)(metadata_ptr + 4) == 2 && is_thread_state_ok
      || check_handle_access_by_state_extended(packed_handle_ptr) != 0;
}

// --- End Function: is_valid_handle_typeB (0x14030C8B0) ---

// --- Function: sub_14033D280 (0x14033D280) ---
_QWORD *__fastcall sub_14033D280(unsigned __int64 tls_data_offset_784, _QWORD *a2)
{
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)tls_data_offset_784 + 0x338LL);
  n0xFFFF = n0xFFFF_86;
  if ( n0xFFFF_86 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                 + 0x10LL))(
                          global_dispatcher_ptr,
                          &v9,
                          "IEntityComponentNetwork");
    n0xFFFF_86 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(tls_data_offset_784, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033D280 (0x14033D280) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037C210) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
  {
    return 0;
  }
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
         global_validator_object,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
  {
    return 0;
  }
  if ( n4 != 2 || *(_QWORD *)get_tls_data_offset_784() )
  {
    return check_indirect_handle_access_by_state(a1) != 0;
  }
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037C210) ---

// --- Function: check_handle_access_by_state_extended (0x14038E620) ---
// Checks access permissions for the provided packed handle using extended logic.
// Calculates the metadata pointer based on high bits in the packed handle.
// Validates access based on the state field (metadata + 4): - State 0: Returns
// false (invalid). - State 1: Checks if the handle's payload exists in a thread-
// local list using `check_thread_list_contains_value`. - State 2: Returns true if
// specific thread flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3 or 4: Returns
// true if thread data exists, its status field at +8 is 1, and the payload value
// is not equal to the constant 0x13374770CLL. - Other states: Return false.
char __fastcall check_handle_access_by_state_extended(_QWORD *packed_handle_ptr)
{
  _QWORD *handle_payload_ptr; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  handle_payload_ptr = (_QWORD *)(*packed_handle_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*packed_handle_ptr & 0xF000000000000000uLL) != 0 )
  {
    metadata_ptr = *packed_handle_ptr & 0xFFFFFF000000LL;
  }
  else
  {
    metadata_ptr = (__int64)handle_payload_ptr + 0xFFFFFFFA;
  }
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value((__int64)handle_payload_ptr);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(metadata_ptr + 4) - 3 <= 1 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *handle_payload_ptr != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls((__int64)handle_payload_ptr);
  }
}

// --- End Function: check_handle_access_by_state_extended (0x14038E620) ---

// --- Function: sub_1403C6C70 (0x1403C6C70) ---
void __fastcall sub_1403C6C70(volatile signed __int64 *a1, signed __int64 a2, __int64 a3, __int64 a4, char a5)
{
  int *p_n0x1600; // rcx
  int v8; // esi
  bool v9; // zf
  signed __int64 v10; // rax
  int v11; // [rsp+30h] [rbp-61h] BYREF
  _DWORD v12[3]; // [rsp+34h] [rbp-5Dh] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-51h] BYREF
  __int64 v14; // [rsp+44h] [rbp-4Dh]
  int v15; // [rsp+4Ch] [rbp-45h]
  __int64 v16; // [rsp+50h] [rbp-41h]
  unsigned __int64 v17; // [rsp+58h] [rbp-39h]
  __int64 v18; // [rsp+60h] [rbp-31h]
  __int64 v19; // [rsp+68h] [rbp-29h]
  int n0x1600; // [rsp+90h] [rbp-1h] BYREF
  __int64 v21; // [rsp+94h] [rbp+3h]
  int v22; // [rsp+9Ch] [rbp+Bh]
  __int64 v23; // [rsp+A0h] [rbp+Fh]
  unsigned __int64 v24; // [rsp+A8h] [rbp+17h]
  __int64 v25; // [rsp+B0h] [rbp+1Fh]
  __int64 v26; // [rsp+B8h] [rbp+27h]

  if ( a5 && *(_BYTE *)(get_tls_data_offset_784() + 0x1C) && qword_14981D3D8 )
  {
    sub_1403C6E30(a1, a2);
    return;
  }
  if ( (a2 & 0x200000) != 0 )
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
      {
        (*(void (__fastcall **)(__int64, volatile signed __int64 *))(*(_QWORD *)qword_14981D318 + 0x128LL))(
          qword_14981D318,
          a1);
      }
      if ( (a2 & 0x100000) != 0 )
      {
        break;
      }
      v8 = a2 | 0x100000;
      v10 = _InterlockedCompareExchange64(a1, a2 | 0x100000, a2);
      v9 = a2 == v10;
      a2 = v10;
      if ( v9 )
      {
        n0x1600 = 0x1600;
        v21 = 0;
        v22 = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v23 = 1;
        psub_7FF6AAB938D0(
          &n0x1600,
          0,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          0);
        v12[0] = v8;
        off_149808B88(a1, v12, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        p_n0x1600 = &n0x1600;
        v24 = __rdtsc();
        goto LABEL_12;
      }
LABEL_13:
      if ( (a2 & 0x200000) == 0 )
      {
        return;
      }
    }
    n0x1600_1 = 0x1600;
    v14 = 0;
    v15 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v16 = 1;
    psub_7FF6AAB938D0(
      &n0x1600_1,
      0,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      0);
    v11 = a2;
    off_149808B88(a1, &v11, 4, 0xFFFFFFFFLL);
    a2 = *a1;
    p_n0x1600 = &n0x1600_1;
    v17 = __rdtsc();
LABEL_12:
    psub_7FF6AAB93930(p_n0x1600);
    goto LABEL_13;
  }
}

// --- End Function: sub_1403C6C70 (0x1403C6C70) ---

// --- Function: sub_1403D85B0 (0x1403D85B0) ---
unsigned __int64 __fastcall sub_1403D85B0(
        volatile signed __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_tls_data_offset_784() + 0x1C) && qword_14981D3D8 )
  {
    return sub_1403D8640(a1, a2);
  }
  else
  {
    return sub_1403D8810(a1, a2);
  }
}

// --- End Function: sub_1403D85B0 (0x1403D85B0) ---

// --- Function: sub_1403D8A00 (0x1403D8A00) ---
__int64 __fastcall sub_1403D8A00(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rdi
  __int64 v9; // r8
  int v10; // ecx
  __int64 v11; // r8
  unsigned __int64 v12; // rbx
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned int)(v14 - 1)) + v16 + 0x24);
      if ( v5 != 0xFFFFFFFF )
      {
        v4 |= (unsigned __int64)v5 << 0x30;
      }
    }
    v6 = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == v6 )
    {
      break;
    }
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
    {
      off_149808B98(a1);
    }
    result = 0xFFFF00000000LL;
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v8 = qword_14981D318;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v15,
        &v13);
      v9 = v15 + 0xC0 * (WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1));
      LODWORD(a2) = *(_DWORD *)(v9 + 0x24);
      *(_DWORD *)(v9 + 0x1C) = (unsigned __int16)(WORD2(a2) + v13);
      for ( result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8);
            (_DWORD)a2 != 0xFFFFFFFF;
            result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8) )
      {
        v10 = (unsigned __int16)(a2 + v13);
        v11 = v15 + 0xC0LL * ((unsigned int)a2 & (v13 - 1));
        LODWORD(a2) = *(_DWORD *)(v11 + 0x24);
        *(_DWORD *)(v11 + 0x1C) = v10;
      }
    }
  }
  else
  {
    result = 0xFFC00000LL;
    if ( (a2 & 0xFFC00000) != 0 )
    {
      return off_149808B90(a1);
    }
    else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v15,
        &v13);
      v12 = HIWORD(a2);
      *(_DWORD *)(0xC0LL * ((unsigned int)v12 & (v13 - 1)) + v15 + 0x1C) = (unsigned __int16)(v12 + v13);
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D318 + 0xD8LL))(
               qword_14981D318,
               (unsigned int)v12);
    }
  }
  return result;
}

// --- End Function: sub_1403D8A00 (0x1403D8A00) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 0xF;
  }
  return (__int64 *)&tls_log_structure_1[0x16 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: is_thread_flag_57_or_38_set (0x140535D40) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 thread_data_ptr_offset_16; // rcx

  thread_data_ptr_offset_16 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  if ( thread_data_ptr_offset_16 )
  {
    return *(_BYTE *)(thread_data_ptr_offset_16 + 0x39) != 0;
  }
  else
  {
    return *(_BYTE *)(get_tls_data_offset_784() + 0x26) != 0;
  }
}

// --- End Function: is_thread_flag_57_or_38_set (0x140535D40) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !CSystem )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = 0xFFFFFFFF;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[0xFFF] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)CSystem + 0x118LL))(
                      CSystem,
                      &fmt,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: sub_1467C3410 (0x1467C3410) ---
unsigned __int64 *__fastcall sub_1467C3410(unsigned __int64 tls_data_offset_784, unsigned __int64 *a2)
{
  char v4; // r8
  unsigned __int64 v5; // rcx
  unsigned __int16 v6; // ax

  v4 = sub_1468E7840(tls_data_offset_784);
  if ( v4 )
  {
    v5 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
  }
  else
  {
    v5 = tls_data_offset_784 - 6;
  }
  v6 = *(_WORD *)(v5 + 2) | 0x2000;
  if ( !v4 )
  {
    v6 = *(_WORD *)(v5 + 2);
  }
  *a2 = tls_data_offset_784 | ((unsigned __int64)v6 << 0x30);
  return a2;
}

// --- End Function: sub_1467C3410 (0x1467C3410) ---

// --- Function: sub_14683B580 (0x14683B580) ---
__int64 sub_14683B580(const char *a1, ...)
{
  __int64 result; // rax

  if ( a1 )
  {
    return (*(__int64 (__fastcall **)(Parameter *, __int64, __int64))(*(_QWORD *)CSystem + 0x158LL))(CSystem, 6, 2);
  }
  return result;
}

// --- End Function: sub_14683B580 (0x14683B580) ---

// --- Function: sub_1468AB010 (0x1468AB010) ---
char __fastcall sub_1468AB010(
        int n3,
        __int64 a2,
        void *p_Entities_that_cannot_be_replicated_must_not_change_parent_(exce, __int64 a4, __int64 a7, __int64 a6, __int128 *a9, __int64 *a10, __int64 *ThreadLogContextSlot, _QWORD *arg48, _QWORD *a11, _QWORD *a12, _QWORD *a13, _QWORD *a14)
{
  void *v14; // rsp
  __int64 v15; // rax
  __int64 a8; // [rsp+18h] [rbp-288h]
  __int64 a5[11]; // [rsp+30h] [rbp-270h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-218h]
  __int64 n0xB0; // [rsp+90h] [rbp-210h]
  _QWORD *v21; // [rsp+98h] [rbp-208h]
  const char *p_UInt; // [rsp+A0h] [rbp-200h]
  __int64 v23; // [rsp+A8h] [rbp-1F8h]
  __int64 (__fastcall *p_sub_1403E65D0)(__int64, __int64, __int64); // [rsp+B0h] [rbp-1F0h]
  __int64 (__fastcall *p_sub_1403E65D0_1)(__int64, __int64, __int64); // [rsp+B8h] [rbp-1E8h]
  __int64 v26; // [rsp+C0h] [rbp-1E0h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+C8h] [rbp-1D8h]
  __int64 v28; // [rsp+D0h] [rbp-1D0h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+D8h] [rbp-1C8h]
  _OWORD *(__fastcall *p_sub_1403DFFC0)(_OWORD *); // [rsp+E0h] [rbp-1C0h]
  unsigned __int64 v31; // [rsp+E8h] [rbp-1B8h]
  char v32; // [rsp+F0h] [rbp-1B0h]
  char v33; // [rsp+F1h] [rbp-1AFh]
  __int64 n0x10; // [rsp+F8h] [rbp-1A8h]
  _QWORD *v35; // [rsp+100h] [rbp-1A0h]
  const char *p_Name; // [rsp+108h] [rbp-198h]
  __int64 v37; // [rsp+110h] [rbp-190h]
  __int64 (__fastcall *p_sub_1403E6A90)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+118h] [rbp-188h]
  __int64 (__fastcall *p_sub_1403E6550)(__int64, double *, unsigned __int64); // [rsp+120h] [rbp-180h]
  __int64 v40; // [rsp+128h] [rbp-178h]
  bool (__fastcall *p_sub_1403E2AB0)(__int64, __int64); // [rsp+130h] [rbp-170h]
  __int64 v42; // [rsp+138h] [rbp-168h]
  void (__fastcall *p_sub_1403E02E0)(const void **); // [rsp+140h] [rbp-160h]
  _QWORD *(__fastcall *p_sub_1403DFFF0)(_QWORD *); // [rsp+148h] [rbp-158h]
  unsigned __int64 v45; // [rsp+150h] [rbp-150h]
  char v46; // [rsp+158h] [rbp-148h]
  char v47; // [rsp+159h] [rbp-147h]
  __int64 n0x18; // [rsp+160h] [rbp-140h]
  _QWORD *v49; // [rsp+168h] [rbp-138h]
  uint64_t **p_EntityId; // [rsp+170h] [rbp-130h]
  __int64 v51; // [rsp+178h] [rbp-128h]
  __int64 (__fastcall *p_sub_1403E6A60)(__int64, __int64, __int64); // [rsp+180h] [rbp-120h]
  __int64 (__fastcall *p_sub_1403E6420)(__int64, _BYTE *, unsigned __int64); // [rsp+188h] [rbp-118h]
  __int64 v54; // [rsp+190h] [rbp-110h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z_1)(__int64, __int64); // [rsp+198h] [rbp-108h]
  __int64 v56; // [rsp+1A0h] [rbp-100h]
  void (__fastcall *p_free_memory_wrapper_w_1)(const void *); // [rsp+1A8h] [rbp-F8h]
  __int64 (__fastcall *p_sub_1403E00D0)(__int64); // [rsp+1B0h] [rbp-F0h]
  unsigned __int64 v59; // [rsp+1B8h] [rbp-E8h]
  char v60; // [rsp+1C0h] [rbp-E0h]
  char v61; // [rsp+1C1h] [rbp-DFh]
  __int64 n0x18_1; // [rsp+1C8h] [rbp-D8h]
  _QWORD *v63; // [rsp+1D0h] [rbp-D0h]
  const char *p_Name_1; // [rsp+1D8h] [rbp-C8h]
  __int64 v65; // [rsp+1E0h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1403E6A90_1)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+1E8h] [rbp-B8h]
  __int64 (__fastcall *p_sub_1403E6550_1)(__int64, double *, unsigned __int64); // [rsp+1F0h] [rbp-B0h]
  __int64 v68; // [rsp+1F8h] [rbp-A8h]
  bool (__fastcall *p_sub_1403E2AB0_1)(__int64, __int64); // [rsp+200h] [rbp-A0h]
  __int64 v70; // [rsp+208h] [rbp-98h]
  void (__fastcall *p_sub_1403E02E0_1)(const void **); // [rsp+210h] [rbp-90h]
  _QWORD *(__fastcall *p_sub_1403DFFF0_1)(_QWORD *); // [rsp+218h] [rbp-88h]
  unsigned __int64 v73; // [rsp+220h] [rbp-80h]
  char v74; // [rsp+228h] [rbp-78h]
  char v75; // [rsp+229h] [rbp-77h]
  __int64 n0x18_2; // [rsp+230h] [rbp-70h]
  _QWORD *v77; // [rsp+238h] [rbp-68h]
  uint64_t **p_EntityId_1; // [rsp+240h] [rbp-60h]
  __int64 v79; // [rsp+248h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6A60_1)(__int64, __int64, __int64); // [rsp+250h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E6420_1)(__int64, _BYTE *, unsigned __int64); // [rsp+258h] [rbp-48h]
  __int64 v82; // [rsp+260h] [rbp-40h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z_2)(__int64, __int64); // [rsp+268h] [rbp-38h]
  __int64 v84; // [rsp+270h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w_2)(const void *); // [rsp+278h] [rbp-28h]
  __int64 (__fastcall *p_sub_1403E00D0_1)(__int64); // [rsp+280h] [rbp-20h]
  unsigned __int64 v87; // [rsp+288h] [rbp-18h]
  char v88; // [rsp+290h] [rbp-10h]
  char v89; // [rsp+291h] [rbp-Fh]
  __int64 n0x18_3; // [rsp+298h] [rbp-8h]

  v14 = alloca(0x270);
  a5[0] = (__int64)ThreadLogContextSlot;
  p_UInt = "UInt";
  a5[2] = 0;
  a5[1] = (__int64)"TraceContext";
  a5[5] = 0;
  a5[3] = (__int64)sub_1403E6C00;
  a5[7] = 0;
  a5[4] = (__int64)sub_1403E6700;
  v33 = 0;
  a5[6] = (__int64)sub_1403E2C50;
  n0x100 = 0x100;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v21 = arg48;
  n0xB0 = 0xB0;
  v23 = *arg48;
  p_sub_1403E65D0 = sub_1403E65D0;
  p_sub_1403E65D0_1 = sub_1403E65D0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w_2;
  p_sub_1403DFFC0 = sub_1403DFFC0;
  v35 = a11;
  v26 = 0;
  v28 = 0;
  v32 = 0;
  v47 = 0;
  v31 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x10 = 0x10;
  p_Name = "Name";
  v37 = *a11;
  p_sub_1403E6A90 = sub_1403E6A90;
  p_sub_1403E6550 = sub_1403E6550;
  p_sub_1403E2AB0 = sub_1403E2AB0;
  v40 = 0;
  v42 = 0;
  v46 = 0;
  p_sub_1403E02E0 = sub_1403E02E0;
  p_sub_1403DFFF0 = sub_1403DFFF0;
  v45 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x18 = 0x18;
  v49 = a12;
  p_EntityId = "EntityId";
  v61 = 1;
  v15 = *a12;
  v54 = 0;
  v56 = 0;
  v51 = v15;
  p_sub_1403E6A60 = sub_1403E6A60;
  p_sub_1403E6420 = sub_1403E6420;
  p_??8error_category@std@@QEBA_NAEBV01@@Z_1 = std::error_category::operator==;
  v63 = a13;
  p_Name_1 = "Name";
  p_free_memory_wrapper_w_1 = free_memory_wrapper_w;
  p_sub_1403E00D0 = sub_1403E00D0;
  v59 = 0xFFFFFFFFFFFFFFFFuLL;
  v60 = 0;
  n0x18_1 = 0x18;
  v75 = 0;
  v65 = *a13;
  p_sub_1403E6A90_1 = sub_1403E6A90;
  p_sub_1403E6550_1 = sub_1403E6550;
  p_sub_1403E2AB0_1 = sub_1403E2AB0;
  v77 = a14;
  v68 = 0;
  v70 = 0;
  p_sub_1403E02E0_1 = sub_1403E02E0;
  p_sub_1403DFFF0_1 = sub_1403DFFF0;
  v73 = 0xFFFFFFFFFFFFFFFFuLL;
  v74 = 0;
  n0x18_2 = 0x18;
  p_EntityId_1 = "EntityId";
  v89 = 1;
  v79 = *a14;
  v82 = 0;
  v84 = 0;
  v88 = 0;
  LODWORD(a8) = a6;
  p_sub_1403E6A60_1 = sub_1403E6A60;
  p_sub_1403E6420_1 = sub_1403E6420;
  p_??8error_category@std@@QEBA_NAEBV01@@Z_2 = std::error_category::operator==;
  p_free_memory_wrapper_w_2 = free_memory_wrapper_w;
  p_sub_1403E00D0_1 = sub_1403E00D0;
  v87 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x18_3 = 0x18;
  return sub_140302350(
           n3,
           a2,
           p_Entities_that_cannot_be_replicated_must_not_change_parent_(exce,
           a4,
           (__int64)a5,
           6,
           a7,
           a8,
           a9,
           a10);
}

// --- End Function: sub_1468AB010 (0x1468AB010) ---

// --- Function: __crtLCMapStringA_169 (0x1468AB410) ---
char __fastcall _crtLCMapStringA_169(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        _QWORD *arg48,
        _QWORD *a11,
        _QWORD *a12)
{
  void *v12; // rsp
  __int64 a8; // [rsp+18h] [rbp-1B8h]
  __int64 a5[11]; // [rsp+30h] [rbp-1A0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-148h]
  __int64 n0xB0; // [rsp+90h] [rbp-140h]
  _QWORD *v18; // [rsp+98h] [rbp-138h]
  const char *p_Name; // [rsp+A0h] [rbp-130h]
  __int64 v20; // [rsp+A8h] [rbp-128h]
  __int64 (__fastcall *p_sub_1403E6A90)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+B0h] [rbp-120h]
  __int64 (__fastcall *p_sub_1403E6550)(__int64, double *, unsigned __int64); // [rsp+B8h] [rbp-118h]
  __int64 v23; // [rsp+C0h] [rbp-110h]
  bool (__fastcall *p_sub_1403E2AB0)(__int64, __int64); // [rsp+C8h] [rbp-108h]
  __int64 v25; // [rsp+D0h] [rbp-100h]
  void (__fastcall *p_sub_1403E02E0)(const void **); // [rsp+D8h] [rbp-F8h]
  _QWORD *(__fastcall *p_sub_1403DFFF0)(_QWORD *); // [rsp+E0h] [rbp-F0h]
  unsigned __int64 v28; // [rsp+E8h] [rbp-E8h]
  char v29; // [rsp+F0h] [rbp-E0h]
  char v30; // [rsp+F1h] [rbp-DFh]
  __int64 n0x18; // [rsp+F8h] [rbp-D8h]
  _QWORD *v32; // [rsp+100h] [rbp-D0h]
  const char *p_Name_1; // [rsp+108h] [rbp-C8h]
  __int64 v34; // [rsp+110h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1403E6A90_1)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+118h] [rbp-B8h]
  __int64 (__fastcall *p_sub_1403E6550_1)(__int64, double *, unsigned __int64); // [rsp+120h] [rbp-B0h]
  __int64 v37; // [rsp+128h] [rbp-A8h]
  bool (__fastcall *p_sub_1403E2AB0_1)(__int64, __int64); // [rsp+130h] [rbp-A0h]
  __int64 v39; // [rsp+138h] [rbp-98h]
  void (__fastcall *p_sub_1403E02E0_1)(const void **); // [rsp+140h] [rbp-90h]
  _QWORD *(__fastcall *p_sub_1403DFFF0_1)(_QWORD *); // [rsp+148h] [rbp-88h]
  unsigned __int64 v42; // [rsp+150h] [rbp-80h]
  char v43; // [rsp+158h] [rbp-78h]
  char v44; // [rsp+159h] [rbp-77h]
  __int64 n0x18_1; // [rsp+160h] [rbp-70h]
  _QWORD *v46; // [rsp+168h] [rbp-68h]
  const char *p_Number; // [rsp+170h] [rbp-60h]
  __int64 v48; // [rsp+178h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E65D0)(__int64, __int64, __int64); // [rsp+180h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E65D0_1)(__int64, __int64, __int64); // [rsp+188h] [rbp-48h]
  __int64 v51; // [rsp+190h] [rbp-40h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+198h] [rbp-38h]
  __int64 v53; // [rsp+1A0h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+1A8h] [rbp-28h]
  _OWORD *(__fastcall *p_sub_1403DFFC0)(_OWORD *); // [rsp+1B0h] [rbp-20h]
  unsigned __int64 v56; // [rsp+1B8h] [rbp-18h]
  char v57; // [rsp+1C0h] [rbp-10h]
  char v58; // [rsp+1C1h] [rbp-Fh]
  __int64 n0x10; // [rsp+1C8h] [rbp-8h]

  v12 = alloca(0x1A0);
  a5[0] = arg40;
  n0x100 = 0x100;
  a5[2] = 0;
  a5[1] = (__int64)"TraceContext";
  a5[5] = 0;
  a5[3] = (__int64)sub_1403E6C00;
  a5[7] = 0;
  a5[4] = (__int64)sub_1403E6700;
  a5[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  a5[6] = (__int64)sub_1403E2C50;
  n0xB0 = 0xB0;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v18 = arg48;
  p_Name = "Name";
  v30 = 0;
  v20 = *arg48;
  v32 = a11;
  p_sub_1403DFFF0 = sub_1403DFFF0;
  p_sub_1403E6A90 = sub_1403E6A90;
  p_sub_1403E6550 = sub_1403E6550;
  v23 = 0;
  p_sub_1403E2AB0 = sub_1403E2AB0;
  v25 = 0;
  p_sub_1403E02E0 = sub_1403E02E0;
  v28 = 0xFFFFFFFFFFFFFFFFuLL;
  v29 = 0;
  n0x18 = 0x18;
  p_Name_1 = "Name";
  v44 = 0;
  v34 = *a11;
  v46 = a12;
  p_sub_1403DFFF0_1 = sub_1403DFFF0;
  p_sub_1403E6A90_1 = sub_1403E6A90;
  p_sub_1403E6550_1 = sub_1403E6550;
  v37 = 0;
  p_sub_1403E2AB0_1 = sub_1403E2AB0;
  v39 = 0;
  p_sub_1403E02E0_1 = sub_1403E02E0;
  v42 = 0xFFFFFFFFFFFFFFFFuLL;
  v43 = 0;
  n0x18_1 = 0x18;
  p_Number = "Number";
  v58 = 0;
  v48 = *a12;
  p_sub_1403E65D0 = sub_1403E65D0;
  p_sub_1403E65D0_1 = sub_1403E65D0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w_2;
  p_sub_1403DFFC0 = sub_1403DFFC0;
  v51 = 0;
  v53 = 0;
  v56 = 0xFFFFFFFFFFFFFFFFuLL;
  v57 = 0;
  n0x10 = 0x10;
  LODWORD(a8) = a6;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 4, a7, a8, a9, a10);
}

// --- End Function: __crtLCMapStringA_169 (0x1468AB410) ---

// --- Function: CEntity::ChangeOwnerEntity (0x1468C1420) ---
double __fastcall CEntity::ChangeOwnerEntity(
        unsigned __int64 tls_data_offset_784_12,
        unsigned __int64 tls_data_offset_784_11,
        signed int n4_1)
{
  __int64 n4_2; // r13
  unsigned __int64 tls_data_offset_784; // rdi
  unsigned __int64 entity; // rbx
  int v6; // esi
  __int64 v7; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  _QWORD *v9; // rax
  volatile signed __int32 *v10; // rsi
  volatile signed __int32 *v11; // r14
  signed __int64 v12; // rdx
  char v13; // cl
  unsigned __int64 v14; // rdx
  unsigned __int16 v15; // ax
  int v16; // esi
  unsigned __int64 v17; // rax
  __int64 tls_data_offset_784_4; // r8
  char v19; // dl
  unsigned __int64 v20; // rcx
  unsigned __int16 v21; // ax
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  unsigned __int16 v24; // ax
  __int64 p_tls_data_offset_784_1; // rsi
  __int64 tls_data_offset_784_10; // r15
  __int64 tls_data_offset_784_8; // r14
  int v28; // eax
  unsigned __int64 *v29; // r12
  unsigned __int64 v30; // rax
  __int64 v31; // r13
  unsigned __int64 v32; // rax
  __int64 v33; // r13
  __int64 v34; // rax
  char v35; // dl
  unsigned __int64 v36; // rcx
  unsigned __int16 v37; // ax
  bool v38; // al
  unsigned __int64 v39; // rdi
  unsigned __int64 tls_data_offset_784_6; // r13
  __int64 v41; // rcx
  unsigned __int64 p_tls_data_offset_784_2; // r12
  char v43; // dl
  unsigned __int64 v44; // rcx
  unsigned __int16 v45; // ax
  unsigned __int64 tls_data_offset_784_7; // rdi
  char v47; // dl
  unsigned __int64 v48; // rcx
  unsigned __int16 v49; // ax
  __int64 v50; // rbx
  int v51; // eax
  int v52; // ecx
  const char *p_No_Owner; // rax
  __int64 *ThreadLogContextSlot; // rax
  unsigned __int64 n0x200000; // rax
  __int64 *v57; // [rsp+28h] [rbp-D8h]
  unsigned __int64 tls_data_offset_784_1; // [rsp+78h] [rbp-88h]
  __int64 v59; // [rsp+80h] [rbp-80h]
  int v60; // [rsp+80h] [rbp-80h]
  unsigned __int64 tls_data_offset_784_5; // [rsp+88h] [rbp-78h] BYREF
  unsigned int n4; // [rsp+90h] [rbp-70h]
  __int64 tls_data_offset_784_3; // [rsp+98h] [rbp-68h] BYREF
  __int64 v64[3]; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int64 v65; // [rsp+B8h] [rbp-48h] BYREF
  __int64 tls_data_offset_784_9; // [rsp+C8h] [rbp-38h] BYREF
  __int64 p_tls_data_offset_784; // [rsp+D0h] [rbp-30h] BYREF
  unsigned int v68[2]; // [rsp+D8h] [rbp-28h] BYREF
  unsigned int v69[2]; // [rsp+E0h] [rbp-20h] BYREF
  unsigned int v70[2]; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v71[2]; // [rsp+F0h] [rbp-10h] BYREF
  char v72; // [rsp+100h] [rbp+0h]
  int n0xF00; // [rsp+110h] [rbp+10h] BYREF
  __int64 v74; // [rsp+114h] [rbp+14h]
  int v75; // [rsp+11Ch] [rbp+1Ch]
  __int64 v76; // [rsp+120h] [rbp+20h]
  unsigned __int64 v77; // [rsp+128h] [rbp+28h]
  __int64 v78; // [rsp+130h] [rbp+30h]
  __int64 v79; // [rsp+138h] [rbp+38h]
  _QWORD v80[2]; // [rsp+160h] [rbp+60h] BYREF
  const void *ptr_to_free; // [rsp+170h] [rbp+70h]
  _QWORD v82[2]; // [rsp+178h] [rbp+78h] BYREF
  const void *ptr_to_free_1; // [rsp+188h] [rbp+88h]
  __int64 v84[2]; // [rsp+190h] [rbp+90h] BYREF
  const void *ptr_to_free_2; // [rsp+1A0h] [rbp+A0h]
  __int64 v86[2]; // [rsp+1A8h] [rbp+A8h] BYREF
  const void *ptr_to_free_3; // [rsp+1B8h] [rbp+B8h]
  _QWORD v88[2]; // [rsp+1C0h] [rbp+C0h] BYREF
  _QWORD v89[2]; // [rsp+1D0h] [rbp+D0h] BYREF
  _QWORD v90[2]; // [rsp+1E0h] [rbp+E0h] BYREF
  _QWORD v91[2]; // [rsp+1F0h] [rbp+F0h] BYREF
  __int64 v92[2]; // [rsp+200h] [rbp+100h] BYREF
  unsigned int v93[2]; // [rsp+210h] [rbp+110h] BYREF
  char *v94; // [rsp+218h] [rbp+118h]
  __int64 v95[2]; // [rsp+220h] [rbp+120h] BYREF
  char v96; // [rsp+230h] [rbp+130h]
  char v97[8]; // [rsp+238h] [rbp+138h] BYREF
  __int128 v98; // [rsp+240h] [rbp+140h] BYREF
  char v99[8]; // [rsp+250h] [rbp+150h] BYREF
  volatile signed __int32 *v100; // [rsp+258h] [rbp+158h]
  __int128 v101; // [rsp+260h] [rbp+160h] BYREF
  _DWORD v102[3]; // [rsp+270h] [rbp+170h] BYREF
  char v103; // [rsp+27Ch] [rbp+17Ch] BYREF
  _DWORD v104[3]; // [rsp+280h] [rbp+180h] BYREF
  char v105; // [rsp+28Ch] [rbp+18Ch] BYREF
  _DWORD v106[3]; // [rsp+290h] [rbp+190h] BYREF
  char v107; // [rsp+29Ch] [rbp+19Ch] BYREF
  _DWORD v108[3]; // [rsp+2A0h] [rbp+1A0h] BYREF
  char v109; // [rsp+2ACh] [rbp+1ACh] BYREF

  n4_2 = n4_1;
  tls_data_offset_784 = tls_data_offset_784_11;
  tls_data_offset_784_1 = tls_data_offset_784_11;
  entity = tls_data_offset_784_12;
  tls_data_offset_784_3 = tls_data_offset_784_12;
  n4 = n4_1;
  v74 = 0;
  v75 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  n0xF00 = 0xF00;
  v76 = 1;
  psub_7FF6AAB938D0(
    &n0xF00,
    0,
    &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  if ( (_DWORD)n4_2 == 4 )
  {
    CEntity::ClearAllOwners(entity);
    goto LABEL_141;
  }
  if ( (int)n4_2 >= 3 )
  {
    LogFatalError("Invalid entity ownership reason");
  }
  if ( *(_BYTE *)(entity + 0xD) < 5u )
  {
    if ( tls_data_offset_784 )
    {
      if ( !(_BYTE)isEditor
        && (*(_BYTE *)(tls_data_offset_784 + 0xD) >= 5u
         || (*(_BYTE *)(tls_data_offset_784 + 8) & 8) != 0 && (*(_BYTE *)(entity + 8) & 8) == 0) )
      {
        v106[0] = 0xD2;
        v88[0] = v106;
        v106[1] = 0x2C;
        v88[1] = &v107;
        v106[2] = 0x31;
        v6 = invokeGlobalCallbackAndMaskStatusBits(
               2,
               (__int64)v88,
               (__int64)"Attaching to an already removing owner - will crash later",
               "Attaching $$ to an already removing owner ($$). reason ($$)");
        if ( (v6 & 0xFFFFF) != 0 )
        {
          v7 = *(_QWORD *)(entity + 0x290);
          v89[1] = (unsigned int)n4_2;
          v82[1] = *(_QWORD *)(tls_data_offset_784 + 0x290);
          v89[0] = 0;
          v82[0] = 0;
          ptr_to_free_1 = 0;
          v80[0] = 0;
          v80[1] = v7;
          ptr_to_free = 0;
          ThreadLogContextSlot_1 = getThreadLogContextSlot();
          v108[0] = 0xD2;
          v90[0] = v108;
          v90[1] = &v109;
          v98 = 0;
          v108[1] = 0x2C;
          v108[2] = 0x31;
          _crtLCMapStringA_169(
            2,
            (unsigned int)v90,
            (unsigned int)"Attaching to an already removing owner - will crash later",
            (unsigned int)"Attaching $$ to an already removing owner ($$). reason ($$)",
            1,
            v6,
            &v98,
            0,
            (__int64)ThreadLogContextSlot_1,
            (__int64)v80,
            (__int64)v82,
            (__int64)v89);
          free_memory_wrapper(ptr_to_free);
          free_memory_wrapper(ptr_to_free_1);
        }
      }
      if ( *(_BYTE *)(entity + 0xD) < 4u )
      {
        v9 = (_QWORD *)sub_1468DEFD0(entity, v99);
        v10 = (volatile signed __int32 *)v9[1];
        v9[1] = 0;
        *v9 = 0;
        v11 = v100;
        if ( v100 )
        {
          if ( _InterlockedExchangeAdd(v100 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
            if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
            {
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
            }
          }
        }
        if ( v10 )
        {
          if ( _InterlockedExchangeAdd(v10 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
            if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
            {
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
            }
          }
        }
      }
    }
    if ( dword_1497929D8 == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
    {
      ++dword_1497929DC;
    }
    else
    {
      v12 = _InterlockedIncrement64(&qword_1497929D0);
      if ( (v12 & 0x200000) != 0 )
      {
        sub_1403C6C70(
          &qword_1497929D0,
          v12,
          (__int64)"CEntity::ChangeOwnerEntity",
          (__int64)"s_aggregateHierarchyLock",
          1);
      }
    }
    if ( !is_valid_handle_typeB((unsigned __int64 *)(entity + 0x4D8 + 8 * n4_2)) && !tls_data_offset_784 )
    {
      goto LABEL_36;
    }
    sub_146900A50(entity, 0x16);
    if ( tls_data_offset_784 )
    {
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v13 = 0;
        v14 = tls_data_offset_784 - 6;
      }
      else
      {
        v13 = 1;
        v14 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v15 = *(_WORD *)(v14 + 2) | 0x2000;
      if ( !v13 )
      {
        v15 = *(_WORD *)(v14 + 2);
      }
      if ( *(_QWORD *)(entity + 8 * n4_2 + 0x4D8) == (tls_data_offset_784 | ((unsigned __int64)v15 << 0x30)) )
      {
LABEL_36:
        sub_1402D0950((__int64)&qword_1497929D0);
        goto LABEL_141;
      }
    }
    sub_1402D0950((__int64)&qword_1497929D0);
    v16 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
    if ( dword_1497929D8 == v16 )
    {
      ++dword_1497929DC;
    }
    else
    {
      v17 = _InterlockedCompareExchange64(&qword_1497929D0, 0x200000, 0);
      if ( v17 )
      {
        sub_1403D85B0(
          &qword_1497929D0,
          v17,
          0,
          (__int64)"CEntity::ChangeOwnerEntity",
          (__int64)"s_aggregateHierarchyLock",
          1);
      }
      dword_1497929D8 = v16;
    }
    if ( tls_data_offset_784 )
    {
      tls_data_offset_784_4 = ::tls_data_offset_784_1;
      if ( ::tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v19 = 0;
        v20 = entity - 6;
      }
      else
      {
        v19 = 1;
        v20 = entity & 0xFFFFFFFFFF000000uLL;
      }
      v21 = *(_WORD *)(v20 + 2) | 0x2000;
      if ( !v19 )
      {
        v21 = *(_WORD *)(v20 + 2);
      }
      v22 = entity | ((unsigned __int64)v21 << 0x30);
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        tls_data_offset_784_4 = 0;
        v23 = tls_data_offset_784 - 6;
      }
      else
      {
        LOBYTE(tls_data_offset_784_4) = 1;
        v23 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v24 = *(_WORD *)(v23 + 2) | 0x2000;
      if ( !(_BYTE)tls_data_offset_784_4 )
      {
        v24 = *(_WORD *)(v23 + 2);
      }
      if ( !(unsigned __int8)sub_1468C20C0(
                               tls_data_offset_784 | ((unsigned __int64)v24 << 0x30),
                               v22,
                               tls_data_offset_784_4,
                               qword_15126E3D8) )
      {
        if ( byte_14981D4A0 )
        {
          goto LABEL_128;
        }
        sub_14033D280(entity, v64);
        if ( !AssetMeta::HasActorSubresource(v64)
          || !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v64[0] & 0xFFFFFFFFFFFFLL) + 0x578LL))(v64[0] & 0xFFFFFFFFFFFFLL) )
        {
          goto LABEL_128;
        }
        sub_14683B580(
          "%s setting reason=%u owner to nullptr due to non-authoritative client ownership change on entityId=%llu entity"
          "Name=\"%s\" entityState=%u",
          "CEntity::ChangeOwnerEntity",
          n4_2,
          *(_QWORD *)(entity + 0x10),
          *(const char **)(entity + 0x290),
          *(unsigned __int8 *)(entity + 0xD));
        goto LABEL_60;
      }
      if ( dword_15126E238 == 1 )
      {
        v34 = sub_1467C3410(tls_data_offset_784, v97);
        if ( (unsigned __int8)sub_1468C2120(entity, v34) )
        {
          LogTraceConditional(
            "%s: Trying to set cyclic entity ownership - eReason=%d entity {name =\"%s\" id=%llu} newOwner {name=\"%s\" id=%llu}",
            "CEntity::ChangeOwnerEntity",
            n4_2,
            *(const char **)(entity + 0x290),
            *(_QWORD *)(entity + 0x10),
            *(const char **)(tls_data_offset_784 + 0x290),
            *(_QWORD *)(tls_data_offset_784 + 0x10));
          CEntity::DumpOwnerInfo(entity);
          if ( (_BYTE)isEditor )
          {
            sub_14683B580(
              "Cyclic Entity ownership - attempting to set entity as being owned by itself or one of the entities owned by it!!!");
          }
          else
          {
            LogFatalError(
              "Cyclic Entity ownership - attempting to set entity as being owned by itself or one of the entities owned by it!!!");
          }
LABEL_60:
          p_tls_data_offset_784_1 = *(_QWORD *)(entity + 0x318);
          tls_data_offset_784 = 0;
          tls_data_offset_784_10 = *(_QWORD *)(entity + 0x310);
          tls_data_offset_784_1 = 0;
          tls_data_offset_784_8 = *(_QWORD *)(entity + 0x320);
          goto LABEL_61;
        }
      }
    }
    p_tls_data_offset_784_1 = *(_QWORD *)(entity + 0x318);
    tls_data_offset_784_8 = *(_QWORD *)(entity + 0x320);
    tls_data_offset_784_10 = *(_QWORD *)(entity + 0x310);
    if ( tls_data_offset_784 )
    {
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v35 = 0;
        v36 = tls_data_offset_784 - 6;
      }
      else
      {
        v35 = 1;
        v36 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v37 = *(_WORD *)(v36 + 2) | 0x2000;
      tls_data_offset_784_1 = tls_data_offset_784;
      if ( !v35 )
      {
        v37 = *(_WORD *)(v36 + 2);
      }
      *(_QWORD *)(entity + 8 * n4_2 + 0x4D8) = tls_data_offset_784 | ((unsigned __int64)v37 << 0x30);
      v28 = *(_DWORD *)(entity + 0x4F0) | (1 << n4_2);
      goto LABEL_62;
    }
LABEL_61:
    *(_QWORD *)(entity + 8 * n4_2 + 0x4D8) = 0;
    v28 = *(_DWORD *)(entity + 0x4F0) & ~(1 << n4_2);
LABEL_62:
    *(_DWORD *)(entity + 0x4F0) = v28;
    v59 = 0;
    v29 = (unsigned __int64 *)(entity + 0x4D8);
    do
    {
      v30 = *v29;
      if ( *v29 )
      {
        v31 = v30 & 0xFFFFFFFFFFFFLL;
        v32 = HIWORD(v30);
        v33 = (v32 & 0xF000) != 0 ? v31 & 0xFFFFFF000000LL : v31 - 6;
        tls_data_offset_784_1 = tls_data_offset_784;
        if ( *(_WORD *)(v33 + 2) == (v32 & 0xFFF) )
        {
          if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v38 = is_thread_flag_57_or_38_set()) )
          {
            v38 = 1;
          }
          if ( (tls_data_offset_784_1 = tls_data_offset_784, *(_WORD *)(v33 + 4) == 2) && v38
            || check_handle_access_by_state_extended(v29) )
          {
            tls_data_offset_784_5 = tls_data_offset_784;
            v39 = *v29;
            if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(entity & 0xFFFFFFFFFFFFLL) + 0x58LL))(entity & 0xFFFFFFFFFFFFLL)
              || (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v39 & 0xFFFFFFFFFFFFLL) + 0x58LL))(v39 & 0xFFFFFFFFFFFFLL) )
            {
              tls_data_offset_784 = tls_data_offset_784_1;
            }
            else
            {
              tls_data_offset_784 = tls_data_offset_784_5;
              v65 = *v29;
              tls_data_offset_784_1 = tls_data_offset_784_5;
              if ( !(unsigned __int8)sub_1468C2120(entity, &v65) )
              {
                tls_data_offset_784_6 = *v29;
                tls_data_offset_784_1 = tls_data_offset_784_5;
                goto LABEL_94;
              }
            }
          }
        }
      }
      v41 = v59;
      *v29++ = 0;
      *(_DWORD *)(entity + 0x4F0) &= ~(1 << v59++);
    }
    while ( (unsigned __int64)(v41 + 1) < 3 );
    tls_data_offset_784_6 = 0;
LABEL_94:
    if ( (*(_BYTE *)(entity + 0x4F0) & 3) != 0
      && (is_valid_handle_typeB((unsigned __int64 *)(entity + 0x4D8))
       || *(_QWORD *)(entity + 0x4E0) != *(_QWORD *)(entity + 0x18)) )
    {
      for ( p_tls_data_offset_784_2 = tls_data_offset_784_6;
            (*(_BYTE *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x4F0) & 3) != 0
         && (is_valid_handle_typeB((unsigned __int64 *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x4D8))
          || *(_QWORD *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x4E0) != *(_QWORD *)((p_tls_data_offset_784_2
                                                                                             & 0xFFFFFFFFFFFFLL)
                                                                                            + 0x18));
            p_tls_data_offset_784_2 = *(_QWORD *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x310) )
      {
        ;
      }
    }
    else
    {
      if ( ::tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v43 = 0;
        v44 = entity - 6;
      }
      else
      {
        v43 = 1;
        v44 = entity & 0xFFFFFFFFFF000000uLL;
      }
      v45 = *(_WORD *)(v44 + 2) | 0x2000;
      if ( !v43 )
      {
        v45 = *(_WORD *)(v44 + 2);
      }
      p_tls_data_offset_784_2 = entity | ((unsigned __int64)v45 << 0x30);
    }
    tls_data_offset_784_5 = tls_data_offset_784_6;
    if ( sub_1468E7C70(entity) )
    {
      if ( !is_valid_handle_typeB(&tls_data_offset_784_5)
        || (tls_data_offset_784_7 = tls_data_offset_784_5,
            (*(_DWORD *)((tls_data_offset_784_5 & 0xFFFFFFFFFFFFLL) + 0x110) & 0x2000) != 0) )
      {
        if ( ::tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + ::tls_data_offset_784_1 )
        {
          v47 = 0;
          v48 = entity - 6;
        }
        else
        {
          v47 = 1;
          v48 = entity & 0xFFFFFFFFFF000000uLL;
        }
        v49 = *(_WORD *)(v48 + 2) | 0x2000;
        if ( !v47 )
        {
          v49 = *(_WORD *)(v48 + 2);
        }
        tls_data_offset_784_7 = entity | ((unsigned __int64)v49 << 0x30);
        goto LABEL_125;
      }
    }
    else
    {
      tls_data_offset_784_7 = tls_data_offset_784_5;
    }
    if ( !sub_1468E7C70(tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL) )
    {
      v50 = tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL;
      do
      {
        tls_data_offset_784_7 = *(_QWORD *)(v50 + 0x310);
        v50 = tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL;
      }
      while ( !sub_1468E7C70(tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL) );
      entity = tls_data_offset_784_3;
    }
LABEL_125:
    if ( tls_data_offset_784_10 != tls_data_offset_784_6
      || p_tls_data_offset_784_2 != p_tls_data_offset_784_1
      || tls_data_offset_784_8 != tls_data_offset_784_7 )
    {
      if ( *(_BYTE *)(entity + 0xD) >= 4u )
      {
        v52 = *(_DWORD *)(entity + 0x110);
        if ( (v52 & 0x10) == 0 && (v52 & 0x1800) != 0x1000 )
        {
          v102[0] = 0xD2;
          v91[0] = v102;
          v102[1] = 0x2C;
          v91[1] = &v103;
          v102[2] = 0x31;
          v60 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)v91,
                  (__int64)"Entities that cannot be replicated must not change parent (except during spawn or removal)",
                  "Entities that cannot be replicated must not change parent (except during spawn or removal) - reason=$$"
                  ", parent {name =\"$$\" id=$$}, child {name =\"$$\" id=$$}");
          if ( (v60 & 0xFFFFF) != 0 )
          {
            v95[1] = *(_QWORD *)(entity + 0x10);
            v86[1] = *(_QWORD *)(entity + 0x290);
            v95[0] = 0;
            v96 = 0;
            v86[0] = 0;
            ptr_to_free_3 = 0;
            v72 = 0;
            if ( tls_data_offset_784_1 )
            {
              v71[1] = *(_QWORD *)(tls_data_offset_784_1 + 0x10);
              p_No_Owner = *(const char **)(tls_data_offset_784_1 + 0x290);
              v71[0] = 0;
            }
            else
            {
              *(_OWORD *)v71 = 0;
              p_No_Owner = "No Owner";
            }
            v84[1] = (__int64)p_No_Owner;
            v92[1] = n4;
            v84[0] = 0;
            ptr_to_free_2 = 0;
            v92[0] = 0;
            ThreadLogContextSlot = getThreadLogContextSlot();
            v104[0] = 0xD2;
            *(_QWORD *)v93 = v104;
            v104[1] = 0x2C;
            v94 = &v105;
            v104[2] = 0x31;
            LODWORD(v57) = v60;
            v101 = 0;
            sub_1468AB010(
              3,
              (unsigned int)v93,
              (unsigned int)"Entities that cannot be replicated must not change parent (except during spawn or removal)",
              (unsigned int)"Entities that cannot be replicated must not change parent (except during spawn or removal) -"
                            " reason=$$, parent {name =\"$$\" id=$$}, child {name =\"$$\" id=$$}",
              1,
              (__int64)v57,
              &v101,
              0,
              ThreadLogContextSlot,
              (__int64)v92,
              (__int64)v84,
              (__int64)v71,
              (__int64)v86,
              (__int64)v95);
            free_memory_wrapper(ptr_to_free_2);
            free_memory_wrapper(ptr_to_free_3);
          }
        }
      }
      tls_data_offset_784_3 = tls_data_offset_784_8;
      tls_data_offset_784_9 = tls_data_offset_784_7;
      p_tls_data_offset_784 = p_tls_data_offset_784_1;
      *(_QWORD *)v68 = p_tls_data_offset_784_2;
      *(_QWORD *)v69 = tls_data_offset_784_10;
      *(_QWORD *)v70 = tls_data_offset_784_6;
      CEntity::OnAggregateHierarchyChanged(
        entity,
        (unsigned int)v70,
        (unsigned int)v69,
        (unsigned int)v68,
        &p_tls_data_offset_784,
        &tls_data_offset_784_9,
        &tls_data_offset_784_3,
        n4);
      v51 = dword_1497929DC;
      if ( dword_1497929DC )
      {
        goto LABEL_129;
      }
LABEL_139:
      dword_1497929D8 = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(&qword_1497929D0, 0, 0x200000);
      if ( n0x200000 != 0x200000 )
      {
        sub_1403D8A00(&qword_1497929D0, n0x200000);
      }
      goto LABEL_141;
    }
LABEL_128:
    v51 = dword_1497929DC;
    if ( dword_1497929DC )
    {
LABEL_129:
      dword_1497929DC = v51 - 1;
      goto LABEL_141;
    }
    goto LABEL_139;
  }
LABEL_141:
  v77 = __rdtsc();
  return psub_7FF6AAB93930(&n0xF00);
}

// --- End Function: CEntity::ChangeOwnerEntity (0x1468C1420) ---

// --- Function: sub_1468C20C0 (0x1468C20C0) ---
bool __fastcall sub_1468C20C0(__int64 a1, __int64 a2, __int64 tls_data_offset_784)
{
  return !(*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL) + 0x58LL))(
            a2 & 0xFFFFFFFFFFFFLL,
            a2 & 0xFFFFFFFFFFFFLL,
            tls_data_offset_784)
      && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x58LL))(a1 & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_1468C20C0 (0x1468C20C0) ---

// --- Function: sub_1468C2120 (0x1468C2120) ---
char __fastcall sub_1468C2120(unsigned __int64 tls_data_offset_784, __int64 *a2)
{
  __int64 i; // r8
  __int64 v4; // rbx
  bool v5; // al
  char v6; // dl
  unsigned __int64 v7; // rcx
  unsigned __int16 v8; // ax
  __int64 v10; // [rsp+48h] [rbp+10h] BYREF

  for ( i = *a2; ; i = *(_QWORD *)((v10 & 0xFFFFFFFFFFFFLL) + 0x310) )
  {
    v10 = i;
    if ( !i )
    {
      break;
    }
    v4 = (i & 0xF000000000000000uLL) != 0 ? i & 0xFFFFFF000000LL : (i & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v4 + 2) != (HIWORD(i) & 0xFFF) )
    {
      break;
    }
    if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v5 = is_thread_flag_57_or_38_set()) )
    {
      v5 = 1;
    }
    if ( (*(_WORD *)(v4 + 4) != 2 || !v5) && !check_handle_access_by_state_extended(&v10) )
    {
      break;
    }
    if ( tls_data_offset_784_1 > tls_data_offset_784 || tls_data_offset_784 >= qword_15126E3D8 + tls_data_offset_784_1 )
    {
      v6 = 0;
      v7 = tls_data_offset_784 - 6;
    }
    else
    {
      v6 = 1;
      v7 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
    }
    v8 = *(_WORD *)(v7 + 2) | 0x2000;
    if ( !v6 )
    {
      v8 = *(_WORD *)(v7 + 2);
    }
    if ( v10 == (tls_data_offset_784 | ((unsigned __int64)v8 << 0x30)) )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1468C2120 (0x1468C2120) ---

// --- Function: CEntity::ClearAllOwners (0x1468C23F0) ---
unsigned __int64 __fastcall CEntity::ClearAllOwners(unsigned __int64 tls_data_offset_784)
{
  int v2; // edi
  unsigned __int64 v3; // rax
  __int64 p_tls_data_offset_784_1; // rcx
  __int64 tls_data_offset_784_3; // rdx
  __int64 v6; // r8
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r9
  char v9; // bp
  unsigned __int64 v10; // r11
  unsigned __int16 v11; // ax
  unsigned __int64 v12; // rax
  char v13; // r10
  unsigned __int16 v14; // dx
  unsigned __int64 n0x200000; // rax
  unsigned int v16[2]; // [rsp+50h] [rbp-58h] BYREF
  unsigned int v17[2]; // [rsp+58h] [rbp-50h] BYREF
  __int64 v18; // [rsp+60h] [rbp-48h] BYREF
  __int64 tls_data_offset_784_2; // [rsp+B0h] [rbp+8h] BYREF
  __int64 tls_data_offset_784_1; // [rsp+B8h] [rbp+10h] BYREF
  __int64 p_tls_data_offset_784; // [rsp+C0h] [rbp+18h] BYREF
  unsigned __int64 v22; // [rsp+C8h] [rbp+20h] BYREF

  v2 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( dword_1497929D8 == v2 )
  {
    ++dword_1497929DC;
  }
  else
  {
    v3 = _InterlockedCompareExchange64(&qword_1497929D0, 0x200000, 0);
    if ( v3 )
    {
      sub_1403D85B0(&qword_1497929D0, v3, 0, (__int64)"CEntity::ClearAllOwners", (__int64)"s_aggregateHierarchyLock", 1);
    }
    dword_1497929D8 = v2;
  }
  p_tls_data_offset_784_1 = *(_QWORD *)(tls_data_offset_784 + 0x318);
  tls_data_offset_784_3 = *(_QWORD *)(tls_data_offset_784 + 0x320);
  v6 = *(_QWORD *)(tls_data_offset_784 + 0x310);
  *(_DWORD *)(tls_data_offset_784 + 0x4F0) = 0;
  *(_QWORD *)(tls_data_offset_784 + 0x4D8) = 0;
  *(_QWORD *)(tls_data_offset_784 + 0x4E0) = 0;
  *(_QWORD *)(tls_data_offset_784 + 0x4E8) = 0;
  if ( ::tls_data_offset_784_1 > tls_data_offset_784 || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
  {
    v9 = 0;
    v8 = tls_data_offset_784 - 6;
    v7 = tls_data_offset_784 - 6;
    v10 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
  }
  else
  {
    v7 = tls_data_offset_784 - 6;
    v8 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
    v9 = 1;
    v10 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
  }
  v11 = *(_WORD *)(v8 + 2) | 0x2000;
  if ( !v9 )
  {
    v11 = *(_WORD *)(v8 + 2);
  }
  v12 = tls_data_offset_784 | ((unsigned __int64)v11 << 0x30);
  if ( ::tls_data_offset_784_1 > tls_data_offset_784 || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
  {
    v13 = 0;
    v10 = v7;
  }
  else
  {
    v13 = 1;
  }
  tls_data_offset_784_2 = tls_data_offset_784_3;
  v14 = *(_WORD *)(v10 + 2) | 0x2000;
  v22 = v12;
  if ( !v13 )
  {
    v14 = *(_WORD *)(v10 + 2);
  }
  tls_data_offset_784_1 = tls_data_offset_784 | ((unsigned __int64)v14 << 0x30);
  p_tls_data_offset_784 = p_tls_data_offset_784_1;
  *(_QWORD *)v16 = v6;
  *(_QWORD *)v17 = 0;
  CEntity::OnAggregateHierarchyChanged(
    tls_data_offset_784,
    (unsigned int)v17,
    (unsigned int)v16,
    (unsigned int)&v22,
    &p_tls_data_offset_784,
    &tls_data_offset_784_1,
    &tls_data_offset_784_2,
    4u);
  v18 = 0;
  sub_1468E9770(tls_data_offset_784, &v18, 4);
  if ( dword_1497929DC )
  {
    return (unsigned int)--dword_1497929DC;
  }
  else
  {
    dword_1497929D8 = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64(&qword_1497929D0, 0, 0x200000);
    if ( n0x200000 != 0x200000 )
    {
      return sub_1403D8A00(&qword_1497929D0, n0x200000);
    }
  }
  return n0x200000;
}

// --- End Function: CEntity::ClearAllOwners (0x1468C23F0) ---

// --- Function: CEntity::DumpOwnerInfo (0x1468D1660) ---
unsigned __int64 __fastcall CEntity::DumpOwnerInfo(unsigned __int64 entity)
{
  signed __int64 v2; // rdx
  char v3; // dl
  unsigned __int64 v4; // rcx
  unsigned __int16 v5; // ax
  unsigned __int64 i; // rcx
  __int64 v7; // rbx
  bool v8; // al
  unsigned __int64 v10; // [rsp+40h] [rbp+8h] BYREF

  if ( dword_1497929D8 == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
  {
    ++dword_1497929DC;
  }
  else
  {
    v2 = _InterlockedIncrement64(&qword_1497929D0);
    if ( (v2 & 0x200000) != 0 )
    {
      sub_1403C6C70(&qword_1497929D0, v2, (__int64)"CEntity::DumpOwnerInfo", (__int64)"s_aggregateHierarchyLock", 1);
    }
  }
  if ( tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + tls_data_offset_784_1 )
  {
    v3 = 0;
    v4 = entity - 6;
  }
  else
  {
    v3 = 1;
    v4 = entity & 0xFFFFFFFFFF000000uLL;
  }
  v5 = *(_WORD *)(v4 + 2) | 0x2000;
  if ( !v3 )
  {
    v5 = *(_WORD *)(v4 + 2);
  }
  for ( i = entity | ((unsigned __int64)v5 << 0x30); ; i = *(_QWORD *)((v10 & 0xFFFFFFFFFFFFLL) + 0x310) )
  {
    v10 = i;
    if ( !i )
    {
      break;
    }
    v7 = (i & 0xF000000000000000uLL) != 0 ? i & 0xFFFFFF000000LL : (i & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v7 + 2) != (HIWORD(i) & 0xFFF) )
    {
      break;
    }
    if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v8 = is_thread_flag_57_or_38_set()) )
    {
      v8 = 1;
    }
    if ( (*(_WORD *)(v7 + 4) != 2 || !v8) && !check_handle_access_by_state_extended(&v10) )
    {
      break;
    }
    sub_1468F26E0(v10 & 0xFFFFFFFFFFFFLL);
  }
  return sub_1402D0950((__int64)&qword_1497929D0);
}

// --- End Function: CEntity::DumpOwnerInfo (0x1468D1660) ---

// --- Function: sub_1468DEFD0 (0x1468DEFD0) ---
_QWORD *__fastcall sub_1468DEFD0(unsigned __int64 tls_data_offset_784, _QWORD *a2)
{
  __int64 v2; // rax
  volatile signed __int32 *v4; // r8
  __int64 v5; // r9
  signed __int32 v6; // eax
  signed __int32 v7; // ett

  v2 = *(_QWORD *)(tls_data_offset_784 + 0x2C8);
  if ( v2 && (v4 = *(volatile signed __int32 **)(v2 + 0x28)) != 0 )
  {
    v5 = *(_QWORD *)(v2 + 0x20);
    _InterlockedIncrement(v4 + 3);
    *a2 = 0;
    a2[1] = 0;
    v6 = *((_DWORD *)v4 + 2);
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = v6;
        v6 = _InterlockedCompareExchange(v4 + 2, v6 + 1, v6);
        if ( v7 == v6 )
        {
          break;
        }
        if ( !v6 )
        {
          goto LABEL_8;
        }
      }
      *a2 = v5;
      a2[1] = v4;
    }
LABEL_8:
    if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
      return a2;
    }
  }
  else
  {
    a2[1] = 0;
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1468DEFD0 (0x1468DEFD0) ---

// --- Function: sub_1468E7C70 (0x1468E7C70) ---
bool __fastcall sub_1468E7C70(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  if ( (*(_DWORD *)(a1 + 0x110) & 0x1800) == 0x1000
    && is_valid_handle_typeB((unsigned __int64 *)(a1 + 0x310))
    && (((unsigned __int8)(*(_DWORD *)(a1 + 0x110) >> 0xD)
       ^ (unsigned __int8)(*(_DWORD *)((*(_QWORD *)(a1 + 0x310) & 0xFFFFFFFFFFFFLL) + 0x110) >> 0xD))
      & 1) != 0 )
  {
    return 1;
  }
  if ( (*(_BYTE *)(a1 + 0x4F0) & 3) == 0 )
  {
    v4 = *(_QWORD *)(a1 + 0x4E8);
    if ( is_valid_handle_typeB(&v4) )
    {
      v2 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 0x658LL))(v4 & 0xFFFFFFFFFFFFLL);
      if ( v2 )
      {
        return (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x48LL))(v2) != 2;
      }
    }
    return 1;
  }
  return 0;
}

// --- End Function: sub_1468E7C70 (0x1468E7C70) ---

// --- Function: CEntity::OnAggregateHierarchyChanged (0x1468ED340) ---
double __fastcall CEntity::OnAggregateHierarchyChanged(
        unsigned __int64 tls_data_offset_784,
        unsigned __int64 *a2,
        __int64 *a3,
        __int64 *a4,
        __int64 *p_tls_data_offset_784,
        __int64 *p_tls_data_offset_784a,
        __int64 *tls_data_offset_784a_2,
        unsigned int n4)
{
  __int64 v9; // rcx
  unsigned __int64 *p_tls_data_offset_784a_1; // rdi
  unsigned __int64 *tls_data_offset_784a; // r15
  unsigned __int64 v15; // r12
  unsigned __int64 v16; // r13
  __int64 *tls_data_offset_784a_3; // rcx
  __int64 *tls_data_offset_784a_1; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // rdx
  __int64 v22; // rax
  unsigned __int64 v23; // r9
  char v24; // dl
  unsigned __int64 v25; // rcx
  unsigned __int16 v26; // ax
  bool v27; // zf
  unsigned __int64 *v28; // rdx
  __int64 tls_data_offset_784_3; // rax
  __int64 tls_data_offset_784_4; // rax
  __int64 *tls_data_offset_784a_5; // rax
  __int64 *v32; // rdi
  __int64 tls_data_offset_784_5; // r15
  char v34; // dl
  unsigned __int64 v35; // rcx
  unsigned __int16 v36; // ax
  int v37; // ebx
  unsigned __int64 v38; // rax
  unsigned __int64 n0x200000; // rax
  __int64 v40; // rdi
  __int64 tls_data_offset_784_6; // rbx
  __int64 v42; // rsi
  _QWORD *v43; // r14
  _QWORD *i; // rsi
  double result; // xmm0_8
  __int64 tls_data_offset_784_1; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v47; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v48; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v49; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v50; // [rsp+50h] [rbp-B0h] BYREF
  _QWORD v51[2]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 tls_data_offset_784a_4; // [rsp+68h] [rbp-98h] BYREF
  unsigned int v53[2]; // [rsp+70h] [rbp-90h] BYREF
  unsigned int v54[2]; // [rsp+78h] [rbp-88h] BYREF
  unsigned int v55[2]; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v56[2]; // [rsp+88h] [rbp-78h] BYREF
  unsigned __int64 v57; // [rsp+90h] [rbp-70h] BYREF
  __int64 p_p_sub_1467B7D90; // [rsp+98h] [rbp-68h] BYREF
  __int64 v59; // [rsp+A0h] [rbp-60h]
  _QWORD v60[3]; // [rsp+A8h] [rbp-58h] BYREF
  int n0xF00; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v62; // [rsp+C4h] [rbp-3Ch]
  int v63; // [rsp+CCh] [rbp-34h]
  __int64 v64; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v65; // [rsp+D8h] [rbp-28h]
  __int64 v66; // [rsp+E0h] [rbp-20h]
  __int64 v67; // [rsp+E8h] [rbp-18h]
  unsigned __int64 v68; // [rsp+160h] [rbp+60h] BYREF
  unsigned __int64 v69; // [rsp+168h] [rbp+68h] BYREF
  __int64 *v70; // [rsp+170h] [rbp+70h] BYREF
  __int64 tls_data_offset_784_2; // [rsp+178h] [rbp+78h] BYREF

  v70 = a3;
  v9 = *(_QWORD *)(tls_data_offset_784 + 0x2A8);
  v59 = v9;
  if ( n4 == 4 )
  {
    v48 = 0;
  }
  else
  {
    v49 = *a2;
    v48 = sub_1468D8EC0(&v49, v9);
  }
  p_tls_data_offset_784a_1 = (unsigned __int64 *)p_tls_data_offset_784a;
  tls_data_offset_784a = (unsigned __int64 *)tls_data_offset_784a_2;
  v15 = *a2;
  v16 = *a3;
  tls_data_offset_784_2 = *a4;
  tls_data_offset_784a_3 = (__int64 *)*tls_data_offset_784a_2;
  tls_data_offset_784a_2 = (__int64 *)*tls_data_offset_784a_2;
  tls_data_offset_784_1 = *p_tls_data_offset_784;
  tls_data_offset_784a_1 = (__int64 *)*p_tls_data_offset_784a;
  p_tls_data_offset_784a = (__int64 *)*p_tls_data_offset_784a;
  if ( v15 != v16 )
  {
    v68 = v16;
    v69 = v15;
    if ( is_valid_handle_typeB(&v68) )
    {
      v19 = v68;
      v20 = *(unsigned int *)(tls_data_offset_784 + 0x2EC);
      v21 = (__int64)(*(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x300) - *(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x2F8)) >> 3;
      if ( v20 != v21 - 1 )
      {
        v22 = *(_QWORD *)(*(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x300) - 8LL);
        if ( v21 <= v20 )
        {
          __debugbreak();
        }
        *(_QWORD *)(*(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x2F8) + 8 * v20) = v22;
        *(_DWORD *)((v22 & 0xFFFFFFFFFFFFLL) + 0x2EC) = *(_DWORD *)(tls_data_offset_784 + 0x2EC);
        v19 = v68;
      }
      *(_QWORD *)((v19 & 0xFFFFFFFFFFFFLL) + 0x300) -= 8LL;
      *(_DWORD *)(tls_data_offset_784 + 0x2EC) = 0xFFFFFFFF;
      *(_QWORD *)(tls_data_offset_784 + 0x310) = 0;
    }
    if ( is_valid_handle_typeB(&v69) )
    {
      v23 = (v69 & 0xFFFFFFFFFFFFLL) + 0x2F8;
      *(_DWORD *)(tls_data_offset_784 + 0x2EC) = (__int64)(*(_QWORD *)((v69 & 0xFFFFFFFFFFFFLL) + 0x300)
                                                         - *(_QWORD *)((v69 & 0xFFFFFFFFFFFFLL) + 0x2F8)) >> 3;
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v24 = 0;
        v25 = tls_data_offset_784 - 6;
      }
      else
      {
        v24 = 1;
        v25 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v26 = *(_WORD *)(v25 + 2) | 0x2000;
      v27 = v24 == 0;
      v28 = *(unsigned __int64 **)(v23 + 8);
      if ( v27 )
      {
        v26 = *(_WORD *)(v25 + 2);
      }
      v47 = tls_data_offset_784 | ((unsigned __int64)v26 << 0x30);
      if ( v28 == *(unsigned __int64 **)(v23 + 0x10) )
      {
        sub_1468A5EB0(v23, v28, &v47);
      }
      else
      {
        *v28 = tls_data_offset_784 | ((unsigned __int64)v26 << 0x30);
        *(_QWORD *)(v23 + 8) += 8LL;
        v47 = 0;
      }
      *(_QWORD *)(tls_data_offset_784 + 0x310) = v69;
    }
    tls_data_offset_784a_3 = tls_data_offset_784a_2;
    tls_data_offset_784a_1 = p_tls_data_offset_784a;
  }
  if ( tls_data_offset_784_2 == tls_data_offset_784_1 )
  {
    if ( tls_data_offset_784a_1 == tls_data_offset_784a_3 )
    {
      goto LABEL_37;
    }
  }
  else
  {
    v50 = *a4;
    v60[0] = &v50;
    v60[1] = sub_14689FFD0;
    sub_1468D5530(tls_data_offset_784, (__int64)v60);
    v60[0] = 0xFFFFFFFFFFFFFFFFuLL;
  }
  v51[0] = *p_tls_data_offset_784;
  sub_1468EDEA0(qword_15126E2D8, tls_data_offset_784, a4, v51, p_tls_data_offset_784a_1);
  tls_data_offset_784a_1 = p_tls_data_offset_784a;
  tls_data_offset_784a_3 = tls_data_offset_784a_2;
  if ( p_tls_data_offset_784a != tls_data_offset_784a_2 )
  {
    v51[1] = *tls_data_offset_784a;
    tls_data_offset_784a_4 = *p_tls_data_offset_784a_1;
    sub_1468F0740(tls_data_offset_784, &tls_data_offset_784a_4);
    if ( is_valid_handle_typeB(p_tls_data_offset_784a_1) )
    {
      tls_data_offset_784_3 = *p_tls_data_offset_784a_1 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      tls_data_offset_784_3 = 0;
    }
    if ( tls_data_offset_784_3 == tls_data_offset_784
      || (is_valid_handle_typeB(tls_data_offset_784a)
        ? (tls_data_offset_784_4 = *tls_data_offset_784a & 0xFFFFFFFFFFFFLL)
        : (tls_data_offset_784_4 = 0),
          tls_data_offset_784_4 == tls_data_offset_784) )
    {
      sub_146900A50(tls_data_offset_784, 0xC0);
    }
    tls_data_offset_784a_3 = tls_data_offset_784a_2;
    tls_data_offset_784a_1 = p_tls_data_offset_784a;
  }
LABEL_37:
  if ( v15 == v16 && tls_data_offset_784a_1 == tls_data_offset_784a_3 )
  {
    v32 = v70;
LABEL_46:
    tls_data_offset_784_5 = tls_data_offset_784_2;
    if ( tls_data_offset_784_2 == tls_data_offset_784_1 )
    {
      goto LABEL_52;
    }
    goto LABEL_41;
  }
  p_tls_data_offset_784a = (__int64 *)*tls_data_offset_784a;
  tls_data_offset_784a_5 = (__int64 *)*p_tls_data_offset_784a_1;
  v32 = v70;
  tls_data_offset_784a_2 = tls_data_offset_784a_5;
  v70 = (__int64 *)*v70;
  *(_QWORD *)v53 = *a2;
  sub_1468ED950(
    tls_data_offset_784,
    (unsigned int)v53,
    (unsigned int)&v70,
    (unsigned int)&tls_data_offset_784a_2,
    &p_tls_data_offset_784a);
  if ( v15 == v16 )
  {
    goto LABEL_46;
  }
  tls_data_offset_784_5 = tls_data_offset_784_2;
LABEL_41:
  tls_data_offset_784_2 = *p_tls_data_offset_784;
  *(_QWORD *)v54 = *a4;
  *(_QWORD *)v55 = *v32;
  *(_QWORD *)v56 = *a2;
  sub_1468EDCA0(tls_data_offset_784, (unsigned int)v56, (unsigned int)v55, (unsigned int)v54, &tls_data_offset_784_2);
  if ( v15 != v16 )
  {
    v57 = *a2;
    sub_1468E9770(tls_data_offset_784, &v57, n4);
    if ( ::tls_data_offset_784_1 > tls_data_offset_784
      || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
    {
      v34 = 0;
      v35 = tls_data_offset_784 - 6;
    }
    else
    {
      v34 = 1;
      v35 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
    }
    v36 = *(_WORD *)(v35 + 2) | 0x2000;
    if ( !v34 )
    {
      v36 = *(_WORD *)(v35 + 2);
    }
    p_p_sub_1467B7D90 = tls_data_offset_784 | ((unsigned __int64)v36 << 0x30);
    sub_1467CDA70(::tls_data_offset_784, (__int64)&p_p_sub_1467B7D90, a2, v32, a4);
  }
LABEL_52:
  v37 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( dword_1497929C8 == v37 )
  {
    ++dword_1497929CC;
  }
  else
  {
    v38 = _InterlockedCompareExchange64(&qword_1497929C0, 0x200000, 0);
    if ( v38 )
    {
      sub_1403D85B0(
        &qword_1497929C0,
        v38,
        0,
        (__int64)"CEntity::OnAggregateHierarchyChanged",
        (__int64)"CEntityAggregateRadius::s_aggregateRadiusHierarchyLock",
        1);
    }
    dword_1497929C8 = v37;
  }
  sub_1469080C0(tls_data_offset_784, v48, v59);
  if ( *(_BYTE *)(tls_data_offset_784 + 0xD) >= 5u
    && *(_DWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x40LL) != 0xFFFFFFFF )
  {
    __debugbreak();
  }
  if ( dword_1497929CC )
  {
    --dword_1497929CC;
  }
  else
  {
    dword_1497929C8 = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64(&qword_1497929C0, 0, 0x200000);
    if ( n0x200000 != 0x200000 )
    {
      sub_1403D8A00(&qword_1497929C0, n0x200000);
    }
  }
  if ( *(_BYTE *)(tls_data_offset_784 + 0xD) >= 5u
    && *(_DWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x40LL) != 0xFFFFFFFF )
  {
    __debugbreak();
  }
  if ( tls_data_offset_784_5 != tls_data_offset_784_1 )
  {
    v40 = *a4;
    v65 = 0;
    v66 = 0;
    tls_data_offset_784_6 = *p_tls_data_offset_784;
    n0xF00 = 0xF00;
    v62 = 0;
    v63 = 0;
    v67 = 0;
    v64 = 1;
    psub_7FF6AAB938D0(
      &n0xF00,
      0,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      0);
    v42 = *(_QWORD *)(tls_data_offset_784 + 0x330);
    if ( v42 )
    {
      v43 = *(_QWORD **)(v42 + 8);
      for ( i = *(_QWORD **)v42; i != v43; ++i )
      {
        (*(void (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*i + 0x508LL))(*i, v40, tls_data_offset_784_6);
      }
    }
    v65 = __rdtsc();
    return psub_7FF6AAB93930(&n0xF00);
  }
  return result;
}

// --- End Function: CEntity::OnAggregateHierarchyChanged (0x1468ED340) ---

// --- Function: sub_146900A50 (0x146900A50) ---
char __fastcall sub_146900A50(unsigned __int64 tls_data_offset_784, __int16 a2)
{
  unsigned int v2; // eax
  unsigned __int16 v3; // r9
  bool v4; // r10
  __int16 v5; // tt
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_DWORD *)(tls_data_offset_784 + 8);
  if ( (v2 & 8) == 0 )
  {
    v3 = a2 & 0x7FFF;
    if ( (a2 & 0x7FFF) != 0 )
    {
      v4 = (v2 & 0x400) != 0 && (((unsigned __int16)(0xFEFF * ((v2 >> 4) & 1)) | 0x100) & v3) != 0;
      _m_prefetchw((const void *)(tls_data_offset_784 + 0x120));
      LOWORD(v2) = *(_WORD *)(tls_data_offset_784 + 0x120);
      do
      {
        v5 = v2;
        LOWORD(v2) = _InterlockedCompareExchange16(
                       (volatile signed __int16 *)(tls_data_offset_784 + 0x120),
                       v3 | (v4 << 0xF) | v2,
                       v2);
      }
      while ( v5 != (_WORD)v2 );
      if ( (v2 & 0x8000u) == 0 && v4 )
      {
        sub_14033D280(tls_data_offset_784, &v7);
        LOBYTE(v2) = AssetMeta::HasActorSubresource(&v7);
        if ( (_BYTE)v2 )
        {
          LOBYTE(v2) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v7 & 0xFFFFFFFFFFFFLL) + 0x590LL))(v7 & 0xFFFFFFFFFFFFLL);
        }
      }
    }
  }
  return v2;
}

// --- End Function: sub_146900A50 (0x146900A50) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 0x10);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

