// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x1403AAE7F (sub_1403AAD20)
//   - 0x1405729FF (sub_140572750)
//   - 0x140850F90 (sub_140850F90)
//   - 0x140851367 (sub_140850F90)
//   - 0x140854340 (sub_140854340)
//   - 0x1422BC915 (sub_1422BC170)
//   - 0x142432BA3 (sub_142432A30)
//   - 0x14261D176 (sub_14261CF60)
//   - 0x142F778AE (sub_142F77640)
//   - 0x143B49822 (sub_143B497B0)
//   - 0x14408717E (sub_1440870C0)
//   - 0x14409842D (sub_1440980A0)
//   - 0x1440A39AE (sub_1440A3890)
//   - 0x1440ABB9F (sub_1440ABB50)
//   - 0x1440ABE2D (sub_1440ABE10)
//   - 0x1440BA857 (sub_1440BA790)
//   - 0x1465F09C7 (sub_1465F0750)
//   - 0x146B2DCC0 (sub_146B2DA00)
//   - 0x146B31C46 (sub_146B317A0)
//   - 0x146B52900 (sub_146B52350)
//   - 0x146C4B767 (sub_146C4B3F0)
//   - 0x146C84D9E (sub_146C84D10)
//   - 0x146D132BB (sub_146D131F0)
//   - 0x146D9913C (sub_146D98FD0)
//   - 0x146E64E60 (sub_146E64E50)
//   - 0x146E6699A (sub_146E66810)
//   - 0x1475F37E3 (sub_1475F3500)
//   - 0x14760166C (sub_147601360)
//   - 0x14760461B (sub_1476044B0)
//   - 0x14760494F (sub_1476044B0)
//   - 0x1477045F0 (sub_147703E00)
//   - 0x147704F5A (sub_147703E00)
// Caller Depth: 0
// Callee/Ref Depth: 4
// Total Functions Found: 1490
// ------------------------------------------------------------

// --- Function: sub_1402A4D50 (0x1402A4D50) ---
__int64 __fastcall sub_1402A4D50(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1402A4D50 (0x1402A4D50) ---

// --- Function: sub_1402A4EC0 (0x1402A4EC0) ---
__int64 __fastcall sub_1402A4EC0(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A4EC0 (0x1402A4EC0) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A50D0) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A50D0) ---

// --- Function: sub_1402A5330 (0x1402A5330) ---
__int64 __fastcall sub_1402A5330(_QWORD *a1)
{
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 result; // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *))a1[1];
  if ( (unsigned __int64)n2 < 2 )
  {
    result = 0;
    *a1 = 0;
  }
  else
  {
    n2(2, a1);
    result = 0;
    a1[1] = 0;
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_1402A5330 (0x1402A5330) ---

// --- Function: sub_1402A53A0 (0x1402A53A0) ---
__int64 __fastcall sub_1402A53A0(__int64 a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // rax
  __int64 v3; // rcx

  result = a1 + 0x18;
  if ( *(_QWORD *)(a1 + 0x10) != a1 + 0x18 )
  {
    v2 = 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
    v3 = *(_QWORD *)(a1 + 0x10);
    qword_149C78668 += v2;
    return sub_147715880(v3, (unsigned int)dword_149A5EC00);
  }
  return result;
}

// --- End Function: sub_1402A53A0 (0x1402A53A0) ---

// --- Function: sub_1402A53E0 (0x1402A53E0) ---
__int64 __fastcall sub_1402A53E0(__int64 a1, __int64 a2)
{
  return a2;
}

// --- End Function: sub_1402A53E0 (0x1402A53E0) ---

// --- Function: sub_1402A5430 (0x1402A5430) ---
bool __fastcall sub_1402A5430(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2;
}

// --- End Function: sub_1402A5430 (0x1402A5430) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A59E0) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A59E0) ---

// --- Function: sub_1402A59F0 (0x1402A59F0) ---
__int64 sub_1402A59F0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  unsigned __int64 v5; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1402A6440(a1, Buffer, v5);
  return a1;
}

// --- End Function: sub_1402A59F0 (0x1402A59F0) ---

// --- Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A5AB0) ---
bool __fastcall AK::WriteBytesCount::Reserve(AK::WriteBytesCount *this)
{
  return 0;
}

// --- End Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A5AB0) ---

// --- Function: __StarEngineModule__ (0x1402A5D20) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A5D20) ---

// --- Function: sub_1402A63B0 (0x1402A63B0) ---
_BYTE *__fastcall sub_1402A63B0(__int64 *a1, __int64 n0x1FF_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0x1FF; // rcx

  result = a1 + 3;
  if ( n0x1FF_1 )
  {
    allocSize = n0x1FF_1 + 1;
    if ( (unsigned __int64)(n0x1FF_1 + 1) <= 0x200 )
    {
      n0x1FF = 0x1FF;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149C78668 += allocSize;
      n0x1FF = n0x1FF_1;
    }
    a1[1] = n0x1FF;
    *a1 = n0x1FF_1;
    a1[2] = (__int64)result;
    result[n0x1FF_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0x1FF;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A63B0 (0x1402A63B0) ---

// --- Function: sub_1402A6440 (0x1402A6440) ---
__int64 __fastcall sub_1402A6440(__int64 a1, const void *a2, size_t Size)
{
  size_t Size_1; // r8
  __int64 v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  Size_1 = *(_QWORD *)(a1 + 8);
  if ( Size > Size_1 )
  {
    v7 = *(_QWORD *)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != a1 + 0x18 )
    {
      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - Size_1;
      sub_147715880(v7, (unsigned int)dword_149A5EC00);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x1FF;
    sub_1402A63B0(a1, Size);
  }
  memmove(*(void **)(a1 + 0x10), a2, Size);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = Size;
  *(_BYTE *)(Size + result) = 0;
  return result;
}

// --- End Function: sub_1402A6440 (0x1402A6440) ---

// --- Function: sub_1402A6590 (0x1402A6590) ---
__int64 __fastcall sub_1402A6590(__int64 a1)
{
  return sub_147715880(a1, (unsigned int)dword_149A5EC00);
}

// --- End Function: sub_1402A6590 (0x1402A6590) ---

// --- Function: sub_1402A65A0 (0x1402A65A0) ---
__int64 __fastcall sub_1402A65A0(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: sub_1402A65A0 (0x1402A65A0) ---

// --- Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A65F0) ---
unsigned __int8 *__fastcall AK::WriteBytesMem::Bytes(AK::WriteBytesMem *this)
{
  return (unsigned __int8 *)*((_QWORD *)this + 2);
}

// --- End Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A65F0) ---

// --- Function: sub_1402A6600 (0x1402A6600) ---
__int64 __fastcall sub_1402A6600(__int64 a1, __int64 a2)
{
  return sub_1402A6590(a2);
}

// --- End Function: sub_1402A6600 (0x1402A6600) ---

// --- Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_0 (0x1402A68B0) ---
__int64 __fastcall __crt_win32_buffer_debug_info::file_name(__crt_win32_buffer_debug_info *this)
{
  return *((_QWORD *)this + 1);
}

// --- End Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_0 (0x1402A68B0) ---

// --- Function: sub_1402A6BE0 (0x1402A6BE0) ---
void *sub_1402A6BE0()
{
  return &unk_149C78580;
}

// --- End Function: sub_1402A6BE0 (0x1402A6BE0) ---

// --- Function: sub_1402A6C80 (0x1402A6C80) ---
__int64 __fastcall sub_1402A6C80(unsigned int *a1)
{
  return *a1;
}

// --- End Function: sub_1402A6C80 (0x1402A6C80) ---

// --- Function: ??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z (0x1402A87C0) ---
int *__fastcall std::_Copy_memmove<int *,int *>(char *_First, char *_Last, int *_Dest)
{
  signed __int64 v4; // rbx

  v4 = _Last - _First;
  memmove(_Dest, _First, _Last - _First);
  return (int *)((char *)_Dest + v4);
}

// --- End Function: ??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z (0x1402A87C0) ---

// --- Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A8950) ---
__int64 __fastcall std::_Deallocate<16,0>(__int64 a1, unsigned __int64 n0x1000)
{
  if ( n0x1000 >= 0x1000 )
  {
    if ( (unsigned __int64)(a1 - *(_QWORD *)(a1 - 8) - 8) > 0x1F )
      invalid_parameter_noinfo_noreturn();
    a1 = *(_QWORD *)(a1 - 8);
  }
  return sub_1402A6590(a1);
}

// --- End Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A8950) ---

// --- Function: ??$_Destroy_range@V?$allocator@V?$shared_ptr@VTriangle@ETManifoldMesh@gte@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VTriangle@ETManifoldMesh@gte@@@0@QEAV10@AEAV?$allocator@V?$shared_ptr@VTriangle@ETManifoldMesh@gte@@@std@@@0@@Z (0x1402A89A0) ---
void __fastcall std::_Destroy_range<std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle>>>(
        std::shared_ptr<gte::ETManifoldMesh::Triangle> *_First,
        std::shared_ptr<gte::ETManifoldMesh::Triangle> *const _Last,
        std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle> > *_Al)
{
  std::shared_ptr<gte::ETManifoldMesh::Triangle> *_First_1; // rdi
  volatile signed __int32 *v5; // rbx

  if ( _First != _Last )
  {
    _First_1 = _First;
    do
    {
      v5 = (volatile signed __int32 *)*((_QWORD *)_First_1 + 1);
      if ( v5 && _InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *, std::shared_ptr<gte::ETManifoldMesh::Triangle> *const, std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle> > *))v5)(
          v5,
          _Last,
          _Al);
        if ( _InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
      }
      _First_1 = (std::shared_ptr<gte::ETManifoldMesh::Triangle> *)((char *)_First_1 + 0x10);
    }
    while ( _First_1 != _Last );
  }
}

// --- End Function: ??$_Destroy_range@V?$allocator@V?$shared_ptr@VTriangle@ETManifoldMesh@gte@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VTriangle@ETManifoldMesh@gte@@@0@QEAV10@AEAV?$allocator@V?$shared_ptr@VTriangle@ETManifoldMesh@gte@@@std@@@0@@Z (0x1402A89A0) ---

// --- Function: sub_1402A8EB0 (0x1402A8EB0) ---
char *__fastcall sub_1402A8EB0(_QWORD *a1, _QWORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _QWORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  char *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = (char *)a1[1];
  v4 = (char *)a1[2];
  if ( v2 == v4 )
  {
    v7 = 0x1FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*a1] >> 3;
    if ( v8 == 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10(v4);
    v9 = (__int64)&v4[-*a1] >> 3;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_QWORD *)sub_140394E70(a1, 8 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = (char *)a1[1];
    v16 = (char *)*a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 8;
      Size = a1[1] - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *a1 )
      sub_1403A6820(a1, *a1, (a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL);
    *a1 = v13;
    result = v17;
    a1[1] = &v13[v11];
    a1[2] = &v13[v12];
  }
  else
  {
    *(_QWORD *)v2 = *a2;
    result = (char *)a1[1];
    a1[1] = result + 8;
  }
  return result;
}

// --- End Function: sub_1402A8EB0 (0x1402A8EB0) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8FF0) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  __int64 v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10(this);
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(_QWORD *)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8FF0) ---

// --- Function: sub_1402A93C0 (0x1402A93C0) ---
char *__fastcall sub_1402A93C0(__int64 a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  std::array<int,2> *v12; // rsi
  std::array<int,2> *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  char *v16; // rbp
  size_t Size; // r8
  __int64 v18; // rcx
  char *result; // rax

  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 3;
  _Count = 0x1FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10(a1);
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<std::array<int,2>>::allocate((std::allocator<std::array<int,2> > *)a1, _Count);
  *((_QWORD *)v12 + v4) = *a3;
  v13 = v12;
  v14 = *(_BYTE **)(a1 + 8);
  v15 = *(_BYTE **)a1;
  v16 = (char *)v12 + 8 * v4;
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = (std::array<int,2> *)(v16 + 8);
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  v18 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - v18) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v18 = *(_QWORD *)(v18 - 8);
    }
    sub_1402A6590(v18);
  }
  *(_QWORD *)a1 = v12;
  result = v16;
  *(_QWORD *)(a1 + 8) = (char *)v12 + 8 * v10;
  *(_QWORD *)(a1 + 0x10) = (char *)v12 + 8 * _Count;
  return result;
}

// --- End Function: sub_1402A93C0 (0x1402A93C0) ---

// --- Function: sub_1402A96C0 (0x1402A96C0) ---
char *__fastcall sub_1402A96C0(__int64 *a1, _BYTE *a2, __int64 a3)
{
  __int64 v6; // r12
  __int64 v7; // rdx
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  _QWORD *v13; // rbx
  void *v14; // rcx
  double *v15; // rbp
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  size_t Size; // r8
  __int64 v19; // r8
  char *result; // rax

  v6 = (__int64)&a2[-*a1] / 0x28;
  v7 = (a1[1] - *a1) / 0x28;
  if ( v7 == 0x666666666666666LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x28;
  if ( v9 > 0x666666666666666LL - (v9 >> 1) )
    goto LABEL_24;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x666666666666666LL )
    goto LABEL_24;
  v11 = 0x28 * v10;
  if ( 0x28 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = (_QWORD *)sub_1402A65A0(0x28 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_24:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_22;
  v13 = (_QWORD *)((v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v13[0xFFFFFFFF] = v12;
LABEL_13:
  v14 = v13;
  *(__m256i *)&v13[5 * v6] = *(__m256i *)a3;
  v15 = (double *)&v13[5 * v6];
  v15[4] = *(double *)(a3 + 0x20);
  v16 = (_BYTE *)a1[1];
  v17 = (_BYTE *)*a1;
  if ( a2 == v16 )
  {
    Size = v16 - v17;
    __asm { vzeroupper }
  }
  else
  {
    __asm { vzeroupper }
    memmove(v13, v17, a2 - v17);
    v14 = v15 + 5;
    Size = a1[1] - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v14, v17, Size);
  v19 = *a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(0x28 * ((a1[2] - v19) / 0x28)) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v19);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v19 - *(_QWORD *)(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(_QWORD *)(v19 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v13;
  a1[1] = (__int64)&v13[5 * v8];
  result = (char *)&v13[5 * v6];
  a1[2] = (__int64)&v13[v11 / 8];
  return result;
}

// --- End Function: sub_1402A96C0 (0x1402A96C0) ---

// --- Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z (0x1402AA7A0) ---
void __fastcall std::_Tree_val<std::_Tree_simple_types<int>>::_Erase_tree<std::allocator<std::_Tree_node<int,void *>>>(
        std::_Tree_val<std::_Tree_simple_types<int> > *this,
        std::allocator<std::_Tree_node<int,void *> > *_Al,
        std::_Tree_node<int,void *> *_Rootnode)
{
  std::_Tree_node<int,void *> *_Rootnode_1; // rbx
  __int64 _Rootnode_2; // rcx

  _Rootnode_1 = _Rootnode;
  while ( !*((_BYTE *)_Rootnode_1 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<int>>::_Erase_tree<std::allocator<std::_Tree_node<int,void *>>>(
      this,
      _Al,
      *((std::_Tree_node<int,void *> **)_Rootnode_1 + 2));
    _Rootnode_2 = (__int64)_Rootnode_1;
    _Rootnode_1 = *(std::_Tree_node<int,void *> **)_Rootnode_1;
    sub_1402A6590(_Rootnode_2);
  }
}

// --- End Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z (0x1402AA7A0) ---

// --- Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBNH@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@1@@Z (0x1402AAA20) ---
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
        std::_Tree_val<std::_Tree_simple_types<std::pair<double const ,int> > > *a1,
        std::allocator<std::_Tree_node<std::pair<double const ,int>,void *> > *_Al,
        __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rcx
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 0x19); result = sub_1402A6590(v6) )
  {
    std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
      a1,
      _Al,
      *(std::_Tree_node<std::pair<double const ,int>,void *> **)(i + 0x10));
    v6 = i;
    i = *(_QWORD *)i;
  }
  return result;
}

// --- End Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBNH@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@1@@Z (0x1402AAA20) ---

// --- Function: sub_1402ABF30 (0x1402ABF30) ---
const void **__fastcall sub_1402ABF30(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  size_t Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  size_t v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  __int64 v17; // rbx

  Size_1 = (size_t)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = Size_1 + a2;
  v11 = (Size_1 + a2) | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
        v15 = 0;
      else
        v15 = (_QWORD *)sub_1402A65A0(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 0x28;
    if ( v6 + 0x28 < (unsigned __int64)(v6 + 1) )
      sub_1402E3880();
  }
  v14 = sub_1402A65A0(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v15[0xFFFFFFFF] = v14;
LABEL_15:
  Src[2] = (const void *)v10;
  v16 = (char *)v15 + Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, Size_1);
    memcpy((char *)v15 + Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = (__int64)*Src;
  memcpy(v15, *Src, Size_1);
  memcpy((char *)v15 + Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v17 - *(_QWORD *)(v17 - 8) - 8) <= 0x1F )
    {
      v17 = *(_QWORD *)(v17 - 8);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A6590(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402ABF30 (0x1402ABF30) ---

// --- Function: sub_1402AC770 (0x1402AC770) ---
char *__fastcall sub_1402AC770(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // r14
  unsigned __int64 v5; // rcx
  __int64 v6; // r14
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v10; // rax
  _QWORD *v11; // rbx
  _QWORD *v12; // rcx
  char *result; // rax

  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v4 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v5 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 3;
  v6 = v4 >> 3;
  v7 = v5 >> 1;
  if ( v5 > 0x1FFFFFFFFFFFFFFFLL - (v5 >> 1) )
    goto LABEL_21;
  v8 = v7 + v5;
  if ( v7 + v5 >= a2 )
  {
    if ( v8 > 0x1FFFFFFFFFFFFFFFLL )
      goto LABEL_21;
  }
  else
  {
    v8 = a2;
  }
  allocSize = 8 * v8;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v11 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v11 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_21:
    sub_1402E3880();
  v10 = sub_1402A65A0(allocSize + 0x27);
  if ( !v10 )
    goto LABEL_19;
  v11 = (_QWORD *)((v10 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v11[0xFFFFFFFF] = v10;
LABEL_13:
  memset(&v11[v6], 0, 8 * (a2 - v6));
  memmove(v11, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v12 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v12) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_17:
      sub_1402A6590((__int64)v12);
      goto LABEL_18;
    }
    if ( (unsigned __int64)v12 - v12[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v12 = (_QWORD *)v12[0xFFFFFFFF];
      goto LABEL_17;
    }
LABEL_19:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_18:
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 8) = &v11[a2];
  result = (char *)&v11[allocSize / 8];
  *(_QWORD *)(a1 + 0x10) = &v11[allocSize / 8];
  return result;
}

// --- End Function: sub_1402AC770 (0x1402AC770) ---

// --- Function: unknown_libname_2 (0x1402B0240) ---
// Microsoft VisualC v14 64bit runtime
_QWORD *__fastcall unknown_libname_2(_QWORD *a1, _QWORD *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

// --- End Function: unknown_libname_2 (0x1402B0240) ---

// --- Function: unknown_libname_474 (0x1402B0940) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_474(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_474 (0x1402B0940) ---

// --- Function: sub_1402B0A70 (0x1402B0A70) ---
_QWORD *__fastcall sub_1402B0A70(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  *a1 = a3;
  sub_1402CF910(a3, a2, a4);
  return a1;
}

// --- End Function: sub_1402B0A70 (0x1402B0A70) ---

// --- Function: sub_1402B0AA0 (0x1402B0AA0) ---
__int64 __fastcall sub_1402B0AA0(__int64 a1, __int64 a2, __int64 a3, char a4, unsigned __int8 a5, __int64 a6)
{
  *(_BYTE *)(a1 + 8) = a4;
  *(_QWORD *)a1 = a3;
  if ( a4 )
    sub_1402D4DE0(a3, a2, a6, a5);
  return a1;
}

// --- End Function: sub_1402B0AA0 (0x1402B0AA0) ---

// --- Function: sub_1402B0B20 (0x1402B0B20) ---
__int64 __fastcall sub_1402B0B20(__int64 a1, __int64 a2, __int64 a3, char a4, unsigned __int8 a5, __int64 a6)
{
  *(_BYTE *)(a1 + 8) = a4;
  *(_QWORD *)a1 = a3;
  if ( a4 )
    sub_1402E0A70(a3, a2, a6, a5);
  return a1;
}

// --- End Function: sub_1402B0B20 (0x1402B0B20) ---

// --- Function: sub_1402B0F80 (0x1402B0F80) ---
__int64 *__fastcall sub_1402B0F80(__int64 *a1)
{
  __int64 v2; // rax

  *a1 = 0;
  a1[1] = 0;
  v2 = sub_1402A65A0(0x30u);
  *(_QWORD *)v2 = v2;
  *(_QWORD *)(v2 + 8) = v2;
  *(_QWORD *)(v2 + 0x10) = v2;
  *(_WORD *)(v2 + 0x18) = 0x101;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_1402B0F80 (0x1402B0F80) ---

// --- Function: sub_1402B3B40 (0x1402B3B40) ---
// local variable allocation has failed, the output may be wrong!
_QWORD *__fastcall sub_1402B3B40(_QWORD *a1, double a2)
{
  __int128 v3; // kr00_16

  *((double *)&v3 + 1) = *(&a2 + 1);
  *(double *)&v3 = a2 * 10000000.0;
  _XMM0 = v3;
  __asm { vcvttsd2si rax, xmm0 }
  *a1 = _RAX;
  return a1;
}

// --- End Function: sub_1402B3B40 (0x1402B3B40) ---

// --- Function: sub_1402B3B60 (0x1402B3B60) ---
__int64 sub_1402B3B60(__int64 a1, char a2, __int64 a3, const char *Format, ...)
{
  _QWORD *v6; // rax
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, Format);
  *(_DWORD *)(a1 + 0x4C) = 0xFF0001;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_DWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x68) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x70) = 4;
  *(__m256i *)(a1 + 0x71) = (__m256i)0LL;
  *(__m256i *)(a1 + 0x91) = (__m256i)0LL;
  *(_BYTE *)(a1 + 0xB1) = a2;
  *(_QWORD *)(a1 + 0xB8) = a3;
  __asm { vzeroupper }
  v6 = sub_1402A6BE0();
  _stdio_common_vsprintf(*v6 | 2LL, (char *)(a1 + 0x71), 0x40u, Format, 0, va);
  return a1;
}

// --- End Function: sub_1402B3B60 (0x1402B3B60) ---

// --- Function: sub_1402B3C60 (0x1402B3C60) ---
_QWORD *__fastcall sub_1402B3C60(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return a1;
}

// --- End Function: sub_1402B3C60 (0x1402B3C60) ---

// --- Function: sub_1402B3CF0 (0x1402B3CF0) ---
void __fastcall sub_1402B3CF0(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: sub_1402B3CF0 (0x1402B3CF0) ---

// --- Function: sub_1402B3D20 (0x1402B3D20) ---
_QWORD *__fastcall sub_1402B3D20(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

// --- End Function: sub_1402B3D20 (0x1402B3D20) ---

// --- Function: sub_1402B3D30 (0x1402B3D30) ---
_QWORD *__fastcall sub_1402B3D30(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1482B6D28;
  return a1;
}

// --- End Function: sub_1402B3D30 (0x1402B3D30) ---

// --- Function: sub_1402B3ED0 (0x1402B3ED0) ---
const ULONG_PTR *__fastcall sub_1402B3ED0(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int32 v4; // eax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 0x14);
  if ( v2 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v4 == 1 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(v1 + 8) = &p_Src;
    }
    else
    {
      return sub_1403DF590(v1, v4);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_1402B3ED0 (0x1402B3ED0) ---

// --- Function: sub_1402B3F10 (0x1402B3F10) ---
__int64 __fastcall sub_1402B3F10(__int64 a1)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) )
    return rw_lock_release_read_lock(*(_QWORD *)a1);
  return result;
}

// --- End Function: sub_1402B3F10 (0x1402B3F10) ---

// --- Function: sub_1402B3F20 (0x1402B3F20) ---
const ULONG_PTR *__fastcall sub_1402B3F20(__int64 *p_p_Src_1)
{
  const ULONG_PTR *p_p_Src; // rax
  __int64 p_Src; // rcx
  int v3; // eax
  unsigned __int64 n0x200000; // rax

  p_p_Src = (const ULONG_PTR *)p_p_Src_1;
  p_Src = *p_p_Src_1;
  if ( p_Src && *((_BYTE *)p_p_Src + 8) )
  {
    v3 = *(_DWORD *)(p_Src + 0x14);
    if ( v3 )
    {
      p_p_Src = (const ULONG_PTR *)(unsigned int)(v3 - 1);
      *(_DWORD *)(p_Src + 0x14) = (_DWORD)p_p_Src;
    }
    else
    {
      *(_DWORD *)(p_Src + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)p_Src, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_Src = &::p_Src;
        *(_QWORD *)(p_Src + 8) = &::p_Src;
      }
      else
      {
        return rw_lock_handle_write_release_contention(p_Src, n0x200000);
      }
    }
  }
  return p_p_Src;
}

// --- End Function: sub_1402B3F20 (0x1402B3F20) ---

// --- Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B48C0) ---
void __fastcall std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>(
        std::shared_ptr<std::vector<char> > *this)
{
  volatile signed __int32 *v1; // rbx

  v1 = (volatile signed __int32 *)*((_QWORD *)this + 1);
  if ( v1 && _InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
    if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
  }
}

// --- End Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B48C0) ---

// --- Function: std::vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___ (0x1402B4C40) ---
__int64 __fastcall std::vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___(
        __int64 *a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    if ( (unsigned __int64)(0x28 * ((a1[2] - v2) / 0x28)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = *(_QWORD *)(v2 - 8);
    }
    sub_1402A6590(v2);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: std::vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___ (0x1402B4C40) ---

// --- Function: sub_1402B4EC0 (0x1402B4EC0) ---
__int64 __fastcall sub_1402B4EC0(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
  {
    sub_1403A6820(a1, *a1, (a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1402B4EC0 (0x1402B4EC0) ---

// --- Function: sub_1402B6C70 (0x1402B6C70) ---
__int64 (__fastcall *__fastcall sub_1402B6C70(_QWORD *a1))(__int64, _QWORD *)
{
  unsigned __int64 v1; // rdx
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  void (__fastcall *n2_1)(__int64, _QWORD *); // rax
  __int64 (__fastcall *n2_2)(__int64, _QWORD *); // rax

  v1 = a1[0xA];
  if ( v1 )
  {
    sub_1403A6820((__int64)(a1 + 0xA), v1, (a1[0xC] - v1) & 0xFFFFFFFFFFFFFFF8uLL);
    a1[0xA] = 0;
    a1[0xB] = 0;
    a1[0xC] = 0;
  }
  n2 = (void (__fastcall *)(__int64, _QWORD *))a1[7];
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1 + 6);
    a1[7] = 0;
  }
  a1[6] = 0;
  n2_1 = (void (__fastcall *)(__int64, _QWORD *))a1[4];
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, a1 + 3);
    a1[4] = 0;
  }
  a1[3] = 0;
  n2_2 = (__int64 (__fastcall *)(__int64, _QWORD *))a1[1];
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2 = (__int64 (__fastcall *)(__int64, _QWORD *))n2_2(2, a1);
    a1[1] = 0;
  }
  *a1 = 0;
  return n2_2;
}

// --- End Function: sub_1402B6C70 (0x1402B6C70) ---

// --- Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B6FE0) ---
_QWORD *__fastcall std::shared_ptr<vraudio::MixerNode>::operator=(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v4; // r8
  volatile signed __int32 *v5; // rbx

  v2 = *a2;
  v4 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  v5 = (volatile signed __int32 *)a1[1];
  *a1 = v2;
  a1[1] = v4;
  if ( !v5 )
    return a1;
  if ( _InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
    if ( _InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
  }
  return a1;
}

// --- End Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B6FE0) ---

// --- Function: ??0_lambda_17b8e77e04f0039ff1429d79b8271fa1_@@QEAA@AEBQEB_W@Z (0x1402B7240) ---
// Microsoft VisualC v14 64bit runtime
_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *__fastcall _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
        _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *this,
        const wchar_t **a2)
{
  *(_QWORD *)this = *a2;
  return this;
}

// --- End Function: ??0_lambda_17b8e77e04f0039ff1429d79b8271fa1_@@QEAA@AEBQEB_W@Z (0x1402B7240) ---

// --- Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B7250) ---
bool __fastcall std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B7250) ---

// --- Function: ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$AkJsonBase@VAkVariant@WwiseAuthoringAPI@AK@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@5@@WwiseAuthoringAPI@AK@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ (0x1402B77D0) ---
std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *__fastcall std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string>>>>>,std::_Iterator_base0>::operator++(
        std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *this)
{
  __int64 v1; // rdx
  __int64 **v3; // r9
  __int64 i; // rax
  __int64 *j; // rcx

  v1 = *(_QWORD *)this;
  v3 = *(__int64 ***)(*(_QWORD *)this + 0x10LL);
  if ( *((_BYTE *)v3 + 0x19) )
  {
    for ( i = *(_QWORD *)(v1 + 8); !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
    {
      if ( v1 != *(_QWORD *)(i + 0x10) )
        break;
      *(_QWORD *)this = i;
      v1 = i;
    }
    *(_QWORD *)this = i;
    return this;
  }
  else
  {
    for ( j = *v3; !*((_BYTE *)j + 0x19); j = (__int64 *)*j )
      v3 = (__int64 **)j;
    *(_QWORD *)this = v3;
    return this;
  }
}

// --- End Function: ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$AkJsonBase@VAkVariant@WwiseAuthoringAPI@AK@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@5@@WwiseAuthoringAPI@AK@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ (0x1402B77D0) ---

// --- Function: LogTraceConditional (0x1402C36D0) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( qword_149C8E0F8 && qword_149C8DFE0 )
  {
    if ( qword_149C8DFF0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149C8DFF0 + 8LL))(
        qword_149C8DFF0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C36D0) ---

// --- Function: sub_1402C6D50 (0x1402C6D50) ---
__int64 __fastcall sub_1402C6D50(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0x24;
  sub_1402C88C0(
    a1,
    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    *(unsigned __int8 *)(a2 + 7),
    *(unsigned __int8 *)(a2 + 6),
    *(unsigned __int8 *)(a2 + 5),
    *(unsigned __int8 *)(a2 + 4),
    HIBYTE(*(_DWORD *)a2),
    (unsigned __int8)BYTE2(*(_DWORD *)a2),
    BYTE1(*(_DWORD *)a2),
    (unsigned __int8)*(_DWORD *)a2,
    *(unsigned __int8 *)(a2 + 0xF),
    *(unsigned __int8 *)(a2 + 0xE),
    *(unsigned __int8 *)(a2 + 0xD),
    *(unsigned __int8 *)(a2 + 0xC),
    HIBYTE(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)BYTE2(*(_DWORD *)(a2 + 8)),
    BYTE1(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)*(_DWORD *)(a2 + 8));
  return a1;
}

// --- End Function: sub_1402C6D50 (0x1402C6D50) ---

// --- Function: sub_1402C7510 (0x1402C7510) ---
__int64 sub_1402C7510(__int64 *a1, float a2, float a3, float a4, __int128 *a5, unsigned __int8 a6, __int64 a7, ...)
{
  __int64 v7; // rax
  double v9[3]; // [rsp+30h] [rbp-48h] BYREF
  int v10; // [rsp+48h] [rbp-30h] BYREF
  __int128 v11; // [rsp+4Ch] [rbp-2Ch]
  float v12; // [rsp+5Ch] [rbp-1Ch]
  float v13; // [rsp+60h] [rbp-18h]
  va_list va; // [rsp+B8h] [rbp+40h] BYREF

  va_start(va, a7);
  v10 = a6 | 0x70;
  v9[0] = a2;
  v7 = *a1;
  v11 = *a5;
  v9[1] = a3;
  v13 = a4;
  v12 = a4;
  v9[2] = 0.5;
  return (*(__int64 (__fastcall **)(__int64 *, double *, int *, __int64, __int64 *))(v7 + 0x560))(
           a1,
           v9,
           &v10,
           a7,
           (__int64 *)va);
}

// --- End Function: sub_1402C7510 (0x1402C7510) ---

// --- Function: sub_1402C88C0 (0x1402C88C0) ---
__int64 sub_1402C88C0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  unsigned __int64 v5; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1402E0CC0(a1, Buffer);
  return a1;
}

// --- End Function: sub_1402C88C0 (0x1402C88C0) ---

// --- Function: NtCurrentTeb_w (0x1402C8AD0) ---
__int64 sub_1402C8AD0()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C8AD0) ---

// --- Function: sub_1402C9900 (0x1402C9900) ---
__int64 sub_1402C9900()
{
  return qword_149C8DFE0;
}

// --- End Function: sub_1402C9900 (0x1402C9900) ---

// --- Function: sub_1402CF910 (0x1402CF910) ---
__int64 __fastcall sub_1402CF910(__int64 a1, __int64 a2, char a3)
{
  __int64 result; // rax
  int v7; // edi
  unsigned int v8; // eax

  result = NtCurrentTeb_w();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v8 )
    {
      result = sub_1403C6E80(a1, v8, a2, a3);
    }
    else
    {
      result = NtCurrentTeb_w();
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v7;
  }
  return result;
}

// --- End Function: sub_1402CF910 (0x1402CF910) ---

// --- Function: sub_1402CF990 (0x1402CF990) ---
__int64 __fastcall sub_1402CF990(__int64 a1, __int64 a2, char a3)
{
  unsigned int v4; // eax
  __int64 result; // rax

  v4 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
  if ( v4 )
    return sub_1403C6E80(a1, v4, a2, a3);
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1402CF990 (0x1402CF990) ---

// --- Function: sub_1402D4DE0 (0x1402D4DE0) ---
double __fastcall sub_1402D4DE0(__int64 a1, const char *a2, const char *a3, char a4)
{
  signed __int64 v8; // rdx
  double result; // xmm0_8

  if ( *(_DWORD *)(a1 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)a1);
    if ( (v8 & 0x200000) != 0 )
      return rw_lock_acquire_read_lock_dispatch(a1, v8, a2, a3, a4);
  }
  return result;
}

// --- End Function: sub_1402D4DE0 (0x1402D4DE0) ---

// --- Function: rw_lock_release_read_lock (0x1402D4E60) ---
// Releases a read lock on a read-write lock. If the current thread is the
// recursive owner, it decrements the recursive count. Otherwise, it atomically
// decrements the main lock state. If the lock state transitions to indicate no
// more readers and pending write locks, it dispatches to a contention handler.
__int64 __fastcall rw_lock_release_read_lock(__int64 p_rw_lock_state)
{
  __int64 result; // rax
  unsigned __int64 current_lock_value; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(result + 0x18)
    && (result = *(unsigned int *)(p_rw_lock_state + 0x14), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(p_rw_lock_state + 0x14) = result;
  }
  else
  {
    current_lock_value = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (current_lock_value & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
        return rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, current_lock_value);
    }
  }
  return result;
}

// --- End Function: rw_lock_release_read_lock (0x1402D4E60) ---

// --- Function: sub_1402DD7D0 (0x1402DD7D0) ---
const ULONG_PTR *__fastcall sub_1402DD7D0(__int64 a1)
{
  unsigned __int32 v1; // eax
  const ULONG_PTR *p_p_Src; // rax

  v1 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
  if ( v1 != 1 )
    return sub_1403DF590(a1, v1);
  p_p_Src = &p_Src;
  *(_QWORD *)(a1 + 8) = &p_Src;
  return p_p_Src;
}

// --- End Function: sub_1402DD7D0 (0x1402DD7D0) ---

// --- Function: sub_1402E0A70 (0x1402E0A70) ---
unsigned __int64 __fastcall sub_1402E0A70(__int64 a1, const char *a2, const char *a3, char a4)
{
  unsigned __int64 result; // rax
  int v9; // edi
  __int64 v10; // r8

  result = NtCurrentTeb_w();
  v9 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v9 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v10 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0x200000, 0);
    if ( result )
      result = sub_1403E1120(a1, result, v10, a2, a3, a4);
    else
      *(_QWORD *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 0x10) = v9;
  }
  return result;
}

// --- End Function: sub_1402E0A70 (0x1402E0A70) ---

// --- Function: sub_1402E0B70 (0x1402E0B70) ---
const ULONG_PTR *__fastcall sub_1402E0B70(__int64 a1)
{
  int v1; // eax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int64 n0x200000; // rax

  v1 = *(_DWORD *)(a1 + 0x14);
  if ( v1 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v1 - 1);
    *(_DWORD *)(a1 + 0x14) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(a1 + 8) = &p_Src;
    }
    else
    {
      return rw_lock_handle_write_release_contention(a1, n0x200000);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_1402E0B70 (0x1402E0B70) ---

// --- Function: sub_1402E0C10 (0x1402E0C10) ---
__int64 __fastcall sub_1402E0C10(__int64 *a1, __int64 *a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = *a2;
    *a1 = *a2;
  }
  else
  {
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_1402E0C10 (0x1402E0C10) ---

// --- Function: sub_1402E0CC0 (0x1402E0CC0) ---
__int64 __fastcall sub_1402E0CC0(__int64 a1, const void *a2, size_t n0x24_1)
{
  size_t n0x24_2; // r8
  const void *v7; // rcx
  _BYTE *v8; // rsi
  __int64 n0x24; // rax
  __int64 v10; // rax
  __int64 result; // rax

  n0x24_2 = *(_QWORD *)(a1 + 8);
  if ( n0x24_1 > n0x24_2 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - n0x24_2;
      sub_147715880(v7);
    }
    *v8 = 0;
    n0x24 = 0x24;
    *(_QWORD *)(a1 + 8) = 0x24;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    if ( n0x24_1 )
    {
      if ( n0x24_1 + 1 > 0x25 )
      {
        v10 = allocWithProfilerInfo(n0x24_1 + 1, 0);
        qword_149C78848 += n0x24_1 + 1;
        v8 = (_BYTE *)v10;
        n0x24 = n0x24_1;
      }
      *(_QWORD *)(a1 + 8) = n0x24;
      *(_QWORD *)a1 = n0x24_1;
      *(_QWORD *)(a1 + 0x10) = v8;
      v8[n0x24_1] = 0;
    }
  }
  memmove(*(void **)(a1 + 0x10), a2, n0x24_1);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n0x24_1;
  *(_BYTE *)(n0x24_1 + result) = 0;
  return result;
}

// --- End Function: sub_1402E0CC0 (0x1402E0CC0) ---

// --- Function: sub_1402E1280 (0x1402E1280) ---
__int64 __fastcall sub_1402E1280(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 i; // rdi
  volatile signed __int32 *v10; // rcx
  __int64 v11; // rcx
  __int64 result; // rax

  v4 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v4 != i; v4 += 0x10 )
    {
      v10 = *(volatile signed __int32 **)(v4 + 8);
      if ( v10 && _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
    }
    v11 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v11 - *(_QWORD *)(v11 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v11 = *(_QWORD *)(v11 - 8);
    }
    result = sub_1402A6590(v11);
  }
  *a1 = a2;
  a1[1] = a2 + 0x10 * a3;
  a1[2] = a2 + 0x10 * a4;
  return result;
}

// --- End Function: sub_1402E1280 (0x1402E1280) ---

// --- Function: sub_1402E13B0 (0x1402E13B0) ---
__int64 __fastcall sub_1402E13B0(unsigned __int64 *a1, const void *a2, size_t Size)
{
  char *v5; // rsi
  size_t Size_1; // r14
  unsigned __int64 v8; // rbp
  unsigned __int64 n8; // rdx
  unsigned __int64 v10; // rax
  __int64 result; // rax

  if ( Size )
  {
    v5 = (char *)a1[2];
    Size_1 = *a1;
    v8 = *a1 + Size;
    if ( v8 <= a1[1] )
    {
      memcpy(&v5[Size_1], a2, Size);
      *a1 += Size;
      result = a1[2];
      *(_BYTE *)(*a1 + result) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= v8 )
        n8 = *a1 + Size;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        sub_1402A63B0((__int64 *)a1, n8);
        memcpy((void *)a1[2], v5, Size_1);
        memcpy((void *)(Size_1 + a1[2]), a2, Size);
        v10 = a1[2];
        *a1 = v8;
        *(_BYTE *)(Size_1 + Size + v10) = 0;
      }
      result = (__int64)(a1 + 3);
      if ( v5 != (char *)(a1 + 3) )
      {
        qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
        return sub_147715880(v5);
      }
    }
  }
  return result;
}

// --- End Function: sub_1402E13B0 (0x1402E13B0) ---

// --- Function: ?_Decref@_Ref_count_base@std@@QEAAXXZ (0x1402E16D0) ---
__int64 __fastcall std::_Ref_count_base::_Decref(std::_Ref_count_base *this)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)this + 2, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    result = (**(__int64 (__fastcall ***)(std::_Ref_count_base *))this)(this);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 3, 0xFFFFFFFF) == 1 )
      return (*(__int64 (__fastcall **)(std::_Ref_count_base *))(*(_QWORD *)this + 8LL))(this);
  }
  return result;
}

// --- End Function: ?_Decref@_Ref_count_base@std@@QEAAXXZ (0x1402E16D0) ---

// --- Function: sub_1402E2560 (0x1402E2560) ---
__int64 *__fastcall sub_1402E2560(std::_Tree_val<std::_Tree_simple_types<int> > *a1, __int64 *_Wherenode_9)
{
  __int64 *_Wherenode_7; // rax
  __int64 *v3; // r9
  __int64 *_Wherenode_11; // r14
  __int64 ***i; // r8
  __int64 *_Wherenode_10; // rdx
  __int64 *_Wherenode_2; // rdi
  __int64 **_Wherenode_1; // rbx
  __int64 **_Wherenode_3; // rdx
  __int64 *_Wherenode_4; // rcx
  __int64 v12; // rdx
  __int64 _Wherenode_6; // rax
  __int64 *_Wherenode_5; // rcx
  __int64 **v15; // rcx
  char v16; // dl
  __int64 **_Wherenode_8; // r9
  std::_Tree_node<int,void *> *_Wherenode; // rcx
  __int64 *v19; // rcx
  __int64 ***v20; // rax
  __int64 *v21; // rcx
  __int64 v22; // rax
  __int64 *v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 *_Wherenode_12; // rax

  _Wherenode_7 = (__int64 *)_Wherenode_9[2];
  v3 = _Wherenode_9 + 2;
  _Wherenode_11 = _Wherenode_9;
  if ( *((_BYTE *)_Wherenode_7 + 0x19) )
  {
    _Wherenode_7 = (__int64 *)_Wherenode_9[1];
    for ( i = (__int64 ***)(_Wherenode_9 + 1); !*((_BYTE *)_Wherenode_7 + 0x19); _Wherenode_7 = (__int64 *)_Wherenode_7[1] )
    {
      if ( _Wherenode_9 != (__int64 *)_Wherenode_7[2] )
        break;
      _Wherenode_9 = _Wherenode_7;
    }
  }
  else
  {
    _Wherenode_10 = (__int64 *)*_Wherenode_7;
    if ( !*(_BYTE *)(*_Wherenode_7 + 0x19) )
    {
      do
      {
        _Wherenode_7 = _Wherenode_10;
        _Wherenode_10 = (__int64 *)*_Wherenode_10;
      }
      while ( !*((_BYTE *)_Wherenode_10 + 0x19) );
    }
    i = (__int64 ***)(_Wherenode_11 + 1);
  }
  _Wherenode_2 = (__int64 *)*v3;
  if ( *(_BYTE *)(*_Wherenode_11 + 0x19) )
    goto LABEL_13;
  if ( *((_BYTE *)_Wherenode_2 + 0x19) )
  {
    _Wherenode_2 = (__int64 *)*_Wherenode_11;
LABEL_13:
    _Wherenode_1 = *i;
    if ( !*((_BYTE *)_Wherenode_2 + 0x19) )
      _Wherenode_2[1] = (__int64)_Wherenode_1;
    if ( *(__int64 **)(*(_QWORD *)a1 + 8LL) == _Wherenode_11 )
    {
      *(_QWORD *)(*(_QWORD *)a1 + 8LL) = _Wherenode_2;
    }
    else if ( *_Wherenode_1 == _Wherenode_11 )
    {
      *_Wherenode_1 = _Wherenode_2;
    }
    else
    {
      _Wherenode_1[2] = _Wherenode_2;
    }
    if ( **(__int64 ***)a1 == _Wherenode_11 )
    {
      if ( *((_BYTE *)_Wherenode_2 + 0x19) )
      {
        _Wherenode_3 = _Wherenode_1;
      }
      else
      {
        _Wherenode_4 = (__int64 *)*_Wherenode_2;
        _Wherenode_3 = (__int64 **)_Wherenode_2;
        if ( !*(_BYTE *)(*_Wherenode_2 + 0x19) )
        {
          do
          {
            _Wherenode_3 = (__int64 **)_Wherenode_4;
            _Wherenode_4 = (__int64 *)*_Wherenode_4;
          }
          while ( !*((_BYTE *)_Wherenode_4 + 0x19) );
        }
      }
      **(_QWORD **)a1 = _Wherenode_3;
    }
    v12 = *(_QWORD *)a1;
    if ( *(__int64 **)(*(_QWORD *)a1 + 0x10LL) == _Wherenode_11 )
    {
      if ( *((_BYTE *)_Wherenode_2 + 0x19) )
      {
        *(_QWORD *)(v12 + 0x10) = _Wherenode_1;
      }
      else
      {
        _Wherenode_6 = _Wherenode_2[2];
        for ( _Wherenode_5 = _Wherenode_2; !*(_BYTE *)(_Wherenode_6 + 0x19); _Wherenode_6 = *(_QWORD *)(_Wherenode_6 + 0x10) )
          _Wherenode_5 = (__int64 *)_Wherenode_6;
        *(_QWORD *)(v12 + 0x10) = _Wherenode_5;
      }
    }
    goto LABEL_43;
  }
  _Wherenode_2 = (__int64 *)_Wherenode_7[2];
  if ( _Wherenode_7 == _Wherenode_11 )
    goto LABEL_13;
  *(_QWORD *)(*_Wherenode_11 + 8) = _Wherenode_7;
  *_Wherenode_7 = *_Wherenode_11;
  if ( _Wherenode_7 == (__int64 *)*v3 )
  {
    _Wherenode_1 = (__int64 **)_Wherenode_7;
  }
  else
  {
    _Wherenode_1 = (__int64 **)_Wherenode_7[1];
    if ( !*((_BYTE *)_Wherenode_2 + 0x19) )
      _Wherenode_2[1] = (__int64)_Wherenode_1;
    *_Wherenode_1 = _Wherenode_2;
    _Wherenode_7[2] = *v3;
    *(_QWORD *)(*v3 + 8) = _Wherenode_7;
  }
  if ( *(__int64 **)(*(_QWORD *)a1 + 8LL) == _Wherenode_11 )
  {
    *(_QWORD *)(*(_QWORD *)a1 + 8LL) = _Wherenode_7;
  }
  else
  {
    v15 = *i;
    if ( **i == _Wherenode_11 )
      *v15 = _Wherenode_7;
    else
      v15[2] = _Wherenode_7;
  }
  v16 = *((_BYTE *)_Wherenode_7 + 0x18);
  _Wherenode_7[1] = (__int64)*i;
  *((_BYTE *)_Wherenode_7 + 0x18) = *((_BYTE *)_Wherenode_11 + 0x18);
  *((_BYTE *)_Wherenode_11 + 0x18) = v16;
LABEL_43:
  if ( *((_BYTE *)_Wherenode_11 + 0x18) == 1 )
  {
    if ( _Wherenode_2 != *(__int64 **)(*(_QWORD *)a1 + 8LL) )
    {
      do
      {
        _Wherenode_8 = _Wherenode_1;
        if ( *((_BYTE *)_Wherenode_2 + 0x18) != 1 )
          break;
        _Wherenode = (std::_Tree_node<int,void *> *)*_Wherenode_1;
        if ( _Wherenode_2 == *_Wherenode_1 )
        {
          _Wherenode = (std::_Tree_node<int,void *> *)_Wherenode_1[2];
          if ( !*((_BYTE *)_Wherenode + 0x18) )
          {
            *((_BYTE *)_Wherenode + 0x18) = 1;
            v19 = _Wherenode_1[2];
            *((_BYTE *)_Wherenode_1 + 0x18) = 0;
            _Wherenode_1[2] = (__int64 *)*v19;
            if ( !*(_BYTE *)(*v19 + 0x19) )
              *(_QWORD *)(*v19 + 8) = _Wherenode_1;
            v19[1] = (__int64)_Wherenode_1[1];
            if ( _Wherenode_1 == *(__int64 ***)(*(_QWORD *)a1 + 8LL) )
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8LL) = v19;
            }
            else
            {
              v20 = (__int64 ***)_Wherenode_1[1];
              if ( _Wherenode_1 == *v20 )
                *v20 = (__int64 **)v19;
              else
                v20[2] = (__int64 **)v19;
            }
            *v19 = (__int64)_Wherenode_1;
            _Wherenode_1[1] = v19;
            _Wherenode = (std::_Tree_node<int,void *> *)_Wherenode_1[2];
          }
          if ( *((_BYTE *)_Wherenode + 0x19) )
            goto LABEL_75;
          if ( *(_BYTE *)(*(_QWORD *)_Wherenode + 0x18LL) != 1 || *(_BYTE *)(*((_QWORD *)_Wherenode + 2) + 0x18LL) != 1 )
          {
            if ( *(_BYTE *)(*((_QWORD *)_Wherenode + 2) + 0x18LL) == 1 )
            {
              *(_BYTE *)(*(_QWORD *)_Wherenode + 0x18LL) = 1;
              *((_BYTE *)_Wherenode + 0x18) = 0;
              std::_Tree_val<std::_Tree_simple_types<int>>::_Rrotate(a1, _Wherenode);
              _Wherenode = (std::_Tree_node<int,void *> *)_Wherenode_1[2];
            }
            *((_BYTE *)_Wherenode + 0x18) = *((_BYTE *)_Wherenode_1 + 0x18);
            *((_BYTE *)_Wherenode_1 + 0x18) = 1;
            *(_BYTE *)(*((_QWORD *)_Wherenode + 2) + 0x18LL) = 1;
            std::_Tree_val<std::_Tree_simple_types<int>>::_Lrotate(a1, (std::_Tree_node<int,void *> *)_Wherenode_1);
            break;
          }
        }
        else
        {
          if ( !*((_BYTE *)_Wherenode + 0x18) )
          {
            *((_BYTE *)_Wherenode + 0x18) = 1;
            v21 = *_Wherenode_1;
            *((_BYTE *)_Wherenode_1 + 0x18) = 0;
            *_Wherenode_1 = (__int64 *)v21[2];
            v22 = v21[2];
            if ( !*(_BYTE *)(v22 + 0x19) )
              *(_QWORD *)(v22 + 8) = _Wherenode_1;
            v21[1] = (__int64)_Wherenode_1[1];
            if ( _Wherenode_1 == *(__int64 ***)(*(_QWORD *)a1 + 8LL) )
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8LL) = v21;
            }
            else
            {
              v23 = _Wherenode_1[1];
              if ( _Wherenode_1 == (__int64 **)v23[2] )
                v23[2] = (__int64)v21;
              else
                *v23 = (__int64)v21;
            }
            v21[2] = (__int64)_Wherenode_1;
            _Wherenode_1[1] = v21;
            _Wherenode = (std::_Tree_node<int,void *> *)*_Wherenode_1;
          }
          if ( *((_BYTE *)_Wherenode + 0x19) )
            goto LABEL_75;
          v24 = *((_QWORD *)_Wherenode + 2);
          if ( *(_BYTE *)(v24 + 0x18) != 1 || *(_BYTE *)(*(_QWORD *)_Wherenode + 0x18LL) != 1 )
          {
            if ( *(_BYTE *)(*(_QWORD *)_Wherenode + 0x18LL) == 1 )
            {
              *(_BYTE *)(v24 + 0x18) = 1;
              *((_BYTE *)_Wherenode + 0x18) = 0;
              std::_Tree_val<std::_Tree_simple_types<int>>::_Lrotate(a1, _Wherenode);
              _Wherenode = (std::_Tree_node<int,void *> *)*_Wherenode_1;
            }
            *((_BYTE *)_Wherenode + 0x18) = *((_BYTE *)_Wherenode_1 + 0x18);
            *((_BYTE *)_Wherenode_1 + 0x18) = 1;
            *(_BYTE *)(*(_QWORD *)_Wherenode + 0x18LL) = 1;
            std::_Tree_val<std::_Tree_simple_types<int>>::_Rrotate(a1, (std::_Tree_node<int,void *> *)_Wherenode_1);
            break;
          }
        }
        *((_BYTE *)_Wherenode + 0x18) = 0;
LABEL_75:
        _Wherenode_2 = (__int64 *)_Wherenode_1;
        _Wherenode_1 = (__int64 **)_Wherenode_1[1];
      }
      while ( _Wherenode_8 != *(__int64 ***)(*(_QWORD *)a1 + 8LL) );
    }
    *((_BYTE *)_Wherenode_2 + 0x18) = 1;
  }
  v25 = *((_QWORD *)a1 + 1);
  _Wherenode_12 = _Wherenode_11;
  if ( v25 )
    *((_QWORD *)a1 + 1) = v25 - 1;
  return _Wherenode_12;
}

// --- End Function: sub_1402E2560 (0x1402E2560) ---

// --- Function: ?GetLocaleT@_LocaleUpdate@@QEAAPEAU__crt_locale_pointers@@XZ (0x1402E2EC0) ---
struct __crt_locale_pointers *__fastcall _LocaleUpdate::GetLocaleT(_LocaleUpdate *this)
{
  return (struct __crt_locale_pointers *)((char *)this + 8);
}

// --- End Function: ?GetLocaleT@_LocaleUpdate@@QEAAPEAU__crt_locale_pointers@@XZ (0x1402E2EC0) ---

// --- Function: sub_1402E2EE0 (0x1402E2EE0) ---
__int64 __fastcall sub_1402E2EE0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 n8; // rbx
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v5; // r15
  unsigned __int64 allocSize; // rcx
  __int64 v7; // rax
  _QWORD *v8; // r14
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx
  __int64 v11; // r12
  size_t Size; // rdi
  const void *v13; // rdx
  char *v14; // rdi
  size_t Size_1; // r8
  char *v16; // rcx
  __int64 result; // rax
  __int64 v18; // rcx

  n8 = 1;
  n8_1 = a1[2];
  if ( n8_1 )
    n8 = n8_1;
  while ( n8 - n8_1 < a2 || n8 < 8 )
  {
    if ( 0xFFFFFFFFFFFFFFFLL - n8 < n8 )
      unknown_libname_8(n8_1, a2, 0xFFFFFFFFFFFFFFFLL);
    n8 *= 2LL;
  }
  v5 = a1[3] >> 1;
  if ( n8 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  allocSize = 8 * n8;
  if ( 8 * n8 < 0x1000 )
  {
    if ( allocSize )
      v8 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v8 = 0;
    goto LABEL_15;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_25:
    sub_1402E3880();
  v7 = sub_1402A65A0(allocSize + 0x27);
  if ( !v7 )
    goto LABEL_24;
  v8 = (_QWORD *)((v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v8[0xFFFFFFFF] = v7;
LABEL_15:
  v9 = a1[2];
  v10 = n8 - v9;
  v11 = 8 * v5;
  Size = 8 * v9 - 8 * v5;
  memmove(&v8[v5], (const void *)(a1[1] + 8 * v5), Size);
  v13 = (const void *)a1[1];
  v14 = (char *)&v8[v5] + Size;
  if ( v5 > v10 )
  {
    memmove(v14, v13, 8 * v10);
    memmove(v8, (const void *)(8 * v10 + a1[1]), v11 - 8 * v10);
    v16 = (char *)v8 + v11 - 8 * v10;
    Size_1 = 8 * v10;
  }
  else
  {
    memmove(v14, v13, 8 * v5);
    memset(&v14[v11], 0, 8 * (v10 - v5));
    Size_1 = 8 * v5;
    v16 = (char *)v8;
  }
  result = (__int64)memset(v16, 0, Size_1);
  v18 = a1[1];
  if ( v18 )
  {
    if ( (unsigned __int64)(8LL * a1[2]) < 0x1000 )
    {
LABEL_22:
      result = sub_1402A6590(v18);
      goto LABEL_23;
    }
    if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) <= 0x1F )
    {
      v18 = *(_QWORD *)(v18 - 8);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  a1[2] += v10;
  a1[1] = v8;
  return result;
}

// --- End Function: sub_1402E2EE0 (0x1402E2EE0) ---

// --- Function: _InterlockedIncrement_w_1 (0x1402E32A0) ---
void __fastcall sub_1402E32A0(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 8));
}

// --- End Function: _InterlockedIncrement_w_1 (0x1402E32A0) ---

// --- Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E3310) ---
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
        __int64 **a1,
        __int64 a2,
        __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 0x18) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 0x18LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 0x18) )
      {
        v13 = *(_QWORD **)(v9 + 0x10);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 0x10) = *v13;
          if ( !*(_BYTE *)(*v13 + 0x19LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 0x10LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 0x19) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v12 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 0x18) )
      {
        v19 = *(_QWORD *)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = *(_QWORD *)(v19 + 0x10);
          v20 = *(_QWORD *)(v19 + 0x10);
          if ( !*(_BYTE *)(v20 + 0x19) )
            *(_QWORD *)(v20 + 8) = v9;
          *(_QWORD *)(v19 + 8) = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(__int64 **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          *(_QWORD *)(v19 + 0x10) = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 0x19LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v11 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 0x18) = 1;
  return a3;
}

// --- End Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E3310) ---

// --- Function: ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z (0x1402E3570) ---
void __fastcall std::_Tree_val<std::_Tree_simple_types<int>>::_Lrotate(
        std::_Tree_val<std::_Tree_simple_types<int> > *this,
        std::_Tree_node<int,void *> *_Wherenode)
{
  std::_Tree_node<int,void *> *v2; // r8
  std::_Tree_node<int,void *> **v3; // rax

  v2 = (std::_Tree_node<int,void *> *)*((_QWORD *)_Wherenode + 2);
  *((_QWORD *)_Wherenode + 2) = *(_QWORD *)v2;
  if ( !*(_BYTE *)(*(_QWORD *)v2 + 0x19LL) )
    *(_QWORD *)(*(_QWORD *)v2 + 8LL) = _Wherenode;
  *((_QWORD *)v2 + 1) = *((_QWORD *)_Wherenode + 1);
  if ( _Wherenode == *(std::_Tree_node<int,void *> **)(*(_QWORD *)this + 8LL) )
  {
    *(_QWORD *)(*(_QWORD *)this + 8LL) = v2;
    *(_QWORD *)v2 = _Wherenode;
    *((_QWORD *)_Wherenode + 1) = v2;
  }
  else
  {
    v3 = (std::_Tree_node<int,void *> **)*((_QWORD *)_Wherenode + 1);
    if ( _Wherenode == *v3 )
      *v3 = v2;
    else
      v3[2] = v2;
    *(_QWORD *)v2 = _Wherenode;
    *((_QWORD *)_Wherenode + 1) = v2;
  }
}

// --- End Function: ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z (0x1402E3570) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E3660) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E3660) ---

// --- Function: ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z (0x1402E3800) ---
void __fastcall std::_Tree_val<std::_Tree_simple_types<int>>::_Rrotate(
        std::_Tree_val<std::_Tree_simple_types<int> > *this,
        std::_Tree_node<int,void *> *_Wherenode)
{
  __int64 v2; // r8
  __int64 v3; // rax
  _QWORD *v4; // rax

  v2 = *(_QWORD *)_Wherenode;
  *(_QWORD *)_Wherenode = *(_QWORD *)(*(_QWORD *)_Wherenode + 0x10LL);
  v3 = *(_QWORD *)(v2 + 0x10);
  if ( !*(_BYTE *)(v3 + 0x19) )
    *(_QWORD *)(v3 + 8) = _Wherenode;
  *(_QWORD *)(v2 + 8) = *((_QWORD *)_Wherenode + 1);
  if ( _Wherenode == *(std::_Tree_node<int,void *> **)(*(_QWORD *)this + 8LL) )
  {
    *(_QWORD *)(*(_QWORD *)this + 8LL) = v2;
    *(_QWORD *)(v2 + 0x10) = _Wherenode;
    *((_QWORD *)_Wherenode + 1) = v2;
  }
  else
  {
    v4 = (_QWORD *)*((_QWORD *)_Wherenode + 1);
    if ( _Wherenode == (std::_Tree_node<int,void *> *)v4[2] )
      v4[2] = v2;
    else
      *v4 = v2;
    *(_QWORD *)(v2 + 0x10) = _Wherenode;
    *((_QWORD *)_Wherenode + 1) = v2;
  }
}

// --- End Function: ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z (0x1402E3800) ---

// --- Function: sub_1402E3880 (0x1402E3880) ---
void __noreturn sub_1402E3880()
{
  stdext::exception *v0; // rax
  _BYTE v1[24]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B3D30(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E3880 (0x1402E3880) ---

// --- Function: unknown_libname_7 (0x1402E38C0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402E38C0) ---

// --- Function: ?Size@WriteBytesMem@AK@@QEBAHXZ (0x1402E4650) ---
__int64 __fastcall AK::WriteBytesMem::Size(AK::WriteBytesMem *this)
{
  return *((unsigned int *)this + 2);
}

// --- End Function: ?Size@WriteBytesMem@AK@@QEBAHXZ (0x1402E4650) ---

// --- Function: unknown_libname_8 (0x1402E4660) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_8()
{
  std::_Xlength_error("deque<T> too long");
}

// --- End Function: unknown_libname_8 (0x1402E4660) ---

// --- Function: unknown_libname_9 (0x1402E4680) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E4680) ---

// --- Function: unknown_libname_10 (0x1402E46A0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E46A0) ---

// --- Function: ?allocate@?$allocator@H@std@@QEAAPEAH_K@Z (0x1402E4820) ---
int *__fastcall std::allocator<int>::allocate(std::allocator<int> *this, unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  int *result; // rax

  if ( _Count > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  allocSize = 4 * _Count;
  if ( 4 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (int *)sub_1402A65A0(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E3880();
  v3 = sub_1402A65A0(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (int *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@H@std@@QEAAPEAH_K@Z (0x1402E4820) ---

// --- Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E4890) ---
std::array<int,2> *__fastcall std::allocator<std::array<int,2>>::allocate(
        std::allocator<std::array<int,2> > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  std::array<int,2> *result; // rax

  if ( _Count > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  allocSize = 8 * _Count;
  if ( 8 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (std::array<int,2> *)sub_1402A65A0(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E3880();
  v3 = sub_1402A65A0(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (std::array<int,2> *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E4890) ---

// --- Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E4AE0) ---
_QWORD *__fastcall std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
        _QWORD *a1,
        _QWORD *a2)
{
  *a2 = *a1;
  return a2;
}

// --- End Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E4AE0) ---

// --- Function: NtCurrentTeb_ww (0x1402E4B80) ---
bool sub_1402E4B80()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E4B80) ---

// --- Function: ?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXXZ (0x1402E50F0) ---
void __fastcall std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>>::clear(
        std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> > *this)
{
  _QWORD *v1; // rdi
  __int64 v3; // rbx
  __int64 v4; // rcx

  v1 = *(_QWORD **)this;
  v3 = *(_QWORD *)(*(_QWORD *)this + 8LL);
  while ( !*(_BYTE *)(v3 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<int>>::_Erase_tree<std::allocator<std::_Tree_node<int,void *>>>(
      this,
      this,
      *(std::_Tree_node<int,void *> **)(v3 + 0x10));
    v4 = v3;
    v3 = *(_QWORD *)v3;
    sub_1402A6590(v4);
  }
  v1[1] = v1;
  *v1 = v1;
  v1[2] = v1;
  *((_QWORD *)this + 1) = 0;
}

// --- End Function: ?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXXZ (0x1402E50F0) ---

// --- Function: sub_1402E55F0 (0x1402E55F0) ---
_QWORD *__fastcall sub_1402E55F0(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 8);
  return a2;
}

// --- End Function: sub_1402E55F0 (0x1402E55F0) ---

// --- Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E5F10) ---
// Microsoft VisualC v14 64bit runtime
__int64 __fastcall __crt_strtox::maximum_signed_value(__crt_strtox *this)
{
  return 0x7FFFFFFFFFFFFFFFLL;
}

// --- End Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E5F10) ---

// --- Function: ?resize@?$vector@PEAMV?$allocator@PEAM@std@@@std@@QEAAX_K@Z (0x1402E65A0) ---
char *__fastcall std::vector<float *>::resize(__int64 *a1, unsigned __int64 a2)
{
  char *v2; // rsi
  __int64 v4; // r8
  unsigned __int64 v5; // rcx
  char *result; // rax
  size_t Size; // rbx

  v2 = (char *)a1[1];
  v4 = *a1;
  v5 = (__int64)&v2[-*a1] >> 3;
  if ( a2 >= v5 )
  {
    if ( a2 > v5 )
    {
      if ( a2 <= (a1[2] - v4) >> 3 )
      {
        Size = 8 * (a2 - v5);
        memset(v2, 0, Size);
        result = &v2[Size];
        a1[1] = (__int64)&v2[Size];
      }
      else
      {
        return sub_1402AC770((__int64)a1, a2);
      }
    }
  }
  else
  {
    result = (char *)(v4 + 8 * a2);
    a1[1] = (__int64)result;
  }
  return result;
}

// --- End Function: ?resize@?$vector@PEAMV?$allocator@PEAM@std@@@std@@QEAAX_K@Z (0x1402E65A0) ---

// --- Function: sub_1402E6690 (0x1402E6690) ---
__int64 __fastcall sub_1402E6690(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  int v4; // esi
  __int64 v6; // r8
  unsigned __int64 v7; // rax

  *(_QWORD *)a2 = a1;
  v2 = a1 + 0x10;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_QWORD *)(a2 + 8) = a1 + 0x10;
  *(_DWORD *)(a2 + 0x18) = 1;
  v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v4 )
  {
    ++*(_DWORD *)(v2 + 0x14);
    return a2;
  }
  else
  {
    v6 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v7 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( v7 )
      sub_1403E1120(v2, v7, v6, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v2 + 8) = v6;
    *(_DWORD *)(v2 + 0x10) = v4;
    return a2;
  }
}

// --- End Function: sub_1402E6690 (0x1402E6690) ---

// --- Function: fprintf (0x1402F9B00) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F9B00) ---

// --- Function: sub_1402FD1B0 (0x1402FD1B0) ---
_QWORD *__fastcall sub_1402FD1B0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v3; // r9
  __int64 v4; // r8
  _QWORD *result; // rax

  v2 = *a2;
  v3 = a2[2];
  v4 = a2[1];
  a2[2] = 0;
  a2[1] = 0;
  *a2 = 0;
  *a1 = v2;
  result = a1;
  a1[1] = v4;
  a1[2] = v3;
  return result;
}

// --- End Function: sub_1402FD1B0 (0x1402FD1B0) ---

// --- Function: sub_1402FD790 (0x1402FD790) ---
__int64 *__fastcall sub_1402FD790(__int64 *a1, __m256i *a2)
{
  unsigned __int64 n0xF; // rdx
  __int64 v5; // rcx
  __int64 *result; // rax

  if ( a1 != (__int64 *)a2 )
  {
    n0xF = a1[3];
    if ( n0xF > 0xF )
    {
      v5 = *a1;
      if ( n0xF + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)(v5 - *(_QWORD *)(v5 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v5 = *(_QWORD *)(v5 - 8);
      }
      sub_1402A6590(v5);
    }
    a1[3] = 0xF;
    a1[2] = 0;
    *(_BYTE *)a1 = 0;
    *(__m256i *)a1 = *a2;
    a2->m256i_i64[2] = 0;
    a2->m256i_i64[3] = 0xF;
    a2->m256i_i8[0] = 0;
  }
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FD790 (0x1402FD790) ---

// --- Function: sub_1402FD820 (0x1402FD820) ---
_QWORD *__fastcall sub_1402FD820(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a1 = *a2 - *a3;
  return a1;
}

// --- End Function: sub_1402FD820 (0x1402FD820) ---

// --- Function: sub_1402FD830 (0x1402FD830) ---
void *__fastcall sub_1402FD830(_QWORD *a1, const void *a2, size_t Size)
{
  __int64 n0x16; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n0x16 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 0xF;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_1402A65A0(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    v10[0xFFFFFFFF] = v9;
    goto LABEL_17;
  }
  n0x16 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n0x16 = 0x16;
  if ( (unsigned __int64)(n0x16 + 1) >= 0x1000 )
  {
    allocSize = n0x16 + 0x28;
    if ( n0x16 + 0x28 < (unsigned __int64)(n0x16 + 1) )
      sub_1402E3880();
    goto LABEL_6;
  }
  if ( n0x16 == 0xFFFFFFFFFFFFFFFFuLL )
    v10 = 0;
  else
    v10 = (_QWORD *)sub_1402A65A0(n0x16 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n0x16;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FD830 (0x1402FD830) ---

// --- Function: sub_1402FE5E0 (0x1402FE5E0) ---
_QWORD *__fastcall sub_1402FE5E0(_QWORD *a1, _QWORD *a2)
{
  *a1 += *a2;
  return a1;
}

// --- End Function: sub_1402FE5E0 (0x1402FE5E0) ---

// --- Function: sub_1402FE5F0 (0x1402FE5F0) ---
__int64 __fastcall sub_1402FE5F0(unsigned __int8 *a1)
{
  return *a1;
}

// --- End Function: sub_1402FE5F0 (0x1402FE5F0) ---

// --- Function: sub_1402FFA40 (0x1402FFA40) ---
__int64 __fastcall sub_1402FFA40(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  if ( a4 < a5 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(a3 + 0x70 * a4 + 0x18))(
             *(_QWORD *)(a3 + 0x70 * a4),
             a1,
             a2,
             a4 - a5 + 1);
  else
    return 0;
}

// --- End Function: sub_1402FFA40 (0x1402FFA40) ---

// --- Function: sub_1402FFA80 (0x1402FFA80) ---
__int64 __fastcall sub_1402FFA80(int a1, int a2, int a3, __int64 a4, __int64 a5)
{
  char v6; // [rsp+40h] [rbp-18h] BYREF

  return sub_140301DB0((unsigned int)&v6, a1, a2, a3, a4, a5);
}

// --- End Function: sub_1402FFA80 (0x1402FFA80) ---

// --- Function: sub_1402FFF10 (0x1402FFF10) ---
__int64 **__fastcall sub_1402FFF10(__int64 **a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v6; // rcx
  __int64 *v7; // rbx
  __int64 n0x28; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 *v12; // rbp
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r8
  __int64 *v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // r9
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  __int64 *v24; // rdx
  __int64 *v25; // r9
  __int64 v26; // rsi
  __int64 v27; // rdi
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r10
  __int64 v30; // rax
  bool v31; // zf
  __int64 *v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rsi
  unsigned __int64 v35; // rdi
  unsigned __int64 v36; // r11
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 **result; // rax

  v6 = a2;
  v7 = &a2[(__int64)(a3 - (_QWORD)a2) >> 4];
  n0x28 = (__int64)(a3 - 8 - (_QWORD)a2) >> 3;
  if ( n0x28 <= 0x28 )
  {
    v14 = a3 - 8;
  }
  else
  {
    v9 = (n0x28 + 1) >> 3;
    v10 = 0x10 * v9;
    v11 = 8 * v9;
    v12 = &a2[v9];
    sub_1402FFE90(a2, v12, &a2[2 * v9]);
    sub_1402FFE90(&v7[v11 / 0xFFFFFFFFFFFFFFF8uLL], v7, &v7[(unsigned __int64)v11 / 8]);
    sub_1402FFE90(a3 - 8 - v10, a3 - 8 - v11, a3 - 8);
    v14 = v13;
    v6 = v12;
  }
  sub_1402FFE90(v6, v7, v14);
  v15 = v7 + 1;
  if ( a2 < v7 )
  {
    v16 = *v7;
    do
    {
      v17 = v7[0xFFFFFFFF];
      v18 = *(_QWORD *)(v16 + 8);
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 < v18 || v19 == v18 && *(_QWORD *)(v17 + 0x50) < *(_QWORD *)(v16 + 0x50) )
        break;
      if ( v18 < v19 || v18 == v19 && *(_QWORD *)(v16 + 0x50) < *(_QWORD *)(v17 + 0x50) )
        break;
      v7 += 0xFFFFFFFF;
      v16 = v17;
    }
    while ( a2 < v7 );
  }
  if ( (unsigned __int64)v15 < a3 )
  {
    v20 = *v7;
    v21 = *(_QWORD *)(*v7 + 8);
    do
    {
      v22 = *v15;
      v23 = *(_QWORD *)(*v15 + 8);
      if ( v23 < v21 || v23 == v21 && *(_QWORD *)(v22 + 0x50) < *(_QWORD *)(v20 + 0x50) )
        break;
      if ( v21 < v23 || v21 == v23 && *(_QWORD *)(v20 + 0x50) < *(_QWORD *)(v22 + 0x50) )
        break;
      ++v15;
    }
    while ( (unsigned __int64)v15 < a3 );
  }
  v24 = v15;
  v25 = v7;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( (unsigned __int64)v24 < a3 )
      {
        v26 = *v24;
        v27 = *v7;
        v28 = *(_QWORD *)(*v24 + 8);
        v29 = *(_QWORD *)(*v7 + 8);
        if ( v29 >= v28 && (v29 != v28 || *(_QWORD *)(v27 + 0x50) >= *(_QWORD *)(v26 + 0x50)) )
        {
          if ( v28 < v29 || v28 == v29 && *(_QWORD *)(v26 + 0x50) < *(_QWORD *)(v27 + 0x50) )
            break;
          if ( v15 != v24 )
          {
            v30 = *v15;
            *v15 = v26;
            *v24 = v30;
          }
          ++v15;
        }
        ++v24;
      }
      v31 = v25 == a2;
      if ( v25 <= a2 )
        goto LABEL_46;
      v32 = v25 + 0xFFFFFFFF;
      while ( 1 )
      {
        v33 = *v7;
        v34 = *v32;
        v35 = *(_QWORD *)(*v7 + 8);
        v36 = *(_QWORD *)(*v32 + 8);
        if ( v36 >= v35 && (v36 != v35 || *(_QWORD *)(v34 + 0x50) >= *(_QWORD *)(v33 + 0x50)) )
          break;
LABEL_44:
        v25 += 0xFFFFFFFF;
        v32 += 0xFFFFFFFF;
        if ( a2 >= v25 )
          goto LABEL_45;
      }
      if ( v35 >= v36 && (v35 != v36 || *(_QWORD *)(v33 + 0x50) >= *(_QWORD *)(v34 + 0x50)) )
      {
        v7 += 0xFFFFFFFF;
        if ( v7 != v32 )
        {
          v37 = *v7;
          *v7 = v34;
          *v32 = v37;
        }
        goto LABEL_44;
      }
LABEL_45:
      v31 = v25 == a2;
LABEL_46:
      if ( !v31 )
      {
        v25 += 0xFFFFFFFF;
        if ( v24 == (__int64 *)a3 )
        {
          v7 += 0xFFFFFFFF;
          if ( v25 != v7 )
          {
            v40 = *v25;
            *v25 = *v7;
            *v7 = v40;
          }
          v41 = v15[0xFFFFFFFF];
          v15 += 0xFFFFFFFF;
          v42 = *v7;
          *v7 = v41;
          *v15 = v42;
        }
        else
        {
          v43 = *v24;
          *v24++ = *v25;
          *v25 = v43;
        }
        continue;
      }
      break;
    }
    if ( v24 != (__int64 *)a3 )
    {
      if ( v15 != v24 )
      {
        v38 = *v7;
        *v7 = *v15;
        *v15 = v38;
      }
      ++v15;
      v39 = *v7;
      *v7++ = *v24;
      *v24++ = v39;
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v7;
  a1[1] = v15;
  return result;
}

// --- End Function: sub_1402FFF10 (0x1402FFF10) ---

// --- Function: sub_1403001D0 (0x1403001D0) ---
unsigned __int64 __fastcall sub_1403001D0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rdi
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r11
  __int64 v11; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 n2; // rax
  unsigned __int64 v15; // r11
  __int64 v16; // rcx
  __int64 v17; // r8
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v10 = 2 * v9;
      v11 = *(_QWORD *)(a1 + 0x10 * v9 + 0x10);
      v12 = *(_QWORD *)(a1 + 0x10 * v9 + 8);
      v13 = *(_QWORD *)(v11 + 8);
      if ( v13 < *(_QWORD *)(v12 + 8)
        || v13 == *(_QWORD *)(v12 + 8) && *(_QWORD *)(v11 + 0x50) < *(_QWORD *)(v12 + 0x50) )
      {
        n2 = 1;
      }
      else
      {
        n2 = 2;
      }
      v9 = v10 + n2;
      *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * (v10 + n2));
      a2 = v10 + n2;
    }
    while ( v10 + n2 < v5 );
  }
  if ( v9 == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v8 >= a2 )
  {
    result = *a4;
    *(_QWORD *)(a1 + 8 * a2) = *a4;
  }
  else
  {
    while ( 1 )
    {
      v15 = *a4;
      v16 = (a2 - 1) >> 1;
      v17 = *(_QWORD *)(a1 + 8 * v16);
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(*a4 + 8) )
      {
        if ( result != *(_QWORD *)(*a4 + 8) )
          break;
        result = *(_QWORD *)(v15 + 0x50);
        if ( *(_QWORD *)(v17 + 0x50) >= result )
          break;
      }
      *(_QWORD *)(a1 + 8 * a2) = v17;
      a2 = (a2 - 1) >> 1;
      if ( v8 >= v16 )
      {
        result = *a4;
        *(_QWORD *)(a1 + 8 * v16) = *a4;
        return result;
      }
    }
    *(_QWORD *)(a1 + 8 * a2) = v15;
  }
  return result;
}

// --- End Function: sub_1403001D0 (0x1403001D0) ---

// --- Function: sub_1403002C0 (0x1403002C0) ---
unsigned __int64 __fastcall sub_1403002C0(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4924924924924925LL) >> 0x40) >> 0x3F;
  v7 = ((__int64)v2 - *a1) / 0x70;
  if ( a2 < v7 )
  {
    v8 = v4 + 0x70 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 0x70 )
    {
      if ( *(_BYTE *)(i + 0x58) )
      {
        if ( *(_QWORD *)i )
          result = (*(__int64 (**)(void))(i + 0x40))();
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
    return result;
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4924924924924925LL) >> 0x40) >> 0x3F;
  v11 = v10 / 0x70;
  if ( a2 > v10 / 0x70 )
  {
    if ( a2 > 0x249249249249249LL )
      unknown_libname_10();
    v12 = v11 >> 1;
    if ( v11 <= 0x249249249249249LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x249249249249249LL )
          goto LABEL_29;
      }
      else
      {
        v13 = a2;
      }
      allocSize = 0x70 * v13;
      if ( 0x70 * v13 < 0x1000 )
      {
        if ( allocSize )
          v16 = sub_1402A65A0(allocSize);
        else
          v16 = 0;
LABEL_23:
        v17 = (_QWORD *)(v16 + 0x70 * v7);
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 0xE;
            --v18;
          }
          while ( v18 );
        }
        sub_1403009C0(*a1, a1[1], v16, a1);
        return sub_140302220(a1, v16, a2, v13);
      }
      if ( allocSize + 0x27 >= allocSize )
      {
        v15 = sub_1402A65A0(allocSize + 0x27);
        if ( !v15 )
          invalid_parameter_noinfo_noreturn();
        v16 = (v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
        *(_QWORD *)(v16 - 8) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402E3880();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 0xE;
  }
  a1[1] = v2;
  return result;
}

// --- End Function: sub_1403002C0 (0x1403002C0) ---

// --- Function: sub_1403005F0 (0x1403005F0) ---
__int64 __fastcall sub_1403005F0(char *a1, char *a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n0x100; // rax
  char *v7; // r15
  char *v8; // rdi
  char *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  char *v30; // rsi
  int v31; // [rsp+20h] [rbp-48h]
  char *v32; // [rsp+30h] [rbp-38h] BYREF
  char *v33; // [rsp+38h] [rbp-30h]
  __int64 v34; // [rsp+70h] [rbp+8h] BYREF

  n0x100 = (a2 - a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( v8 != v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 0x50) < *(_QWORD *)(*(_QWORD *)v8 + 0x50LL) )
          {
            n0x100 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i + 0xFFFFFFFF);
              i += 0xFFFFFFF8;
              n0x100 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n0x100 )
              {
                if ( *(_QWORD *)(v14 + 8) != n0x100 )
                  break;
                n0x100 = *(_QWORD *)(v17 + 0x50);
                if ( *(_QWORD *)(v14 + 0x50) >= (unsigned __int64)n0x100 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FFF10(&v32, v8, v7, a4);
      v9 = v32;
      v10 = v33;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((v32 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - v33) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1403005F0(v33, v7, a3, a4);
        v7 = v9;
      }
      else
      {
        sub_1403005F0(v8, v32, a3, a4);
        v8 = v10;
      }
      n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    v18 = (v7 - v8) >> 3;
    v19 = (v7 - v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 0x50) < *(_QWORD *)(v25 + 0x50) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 0x50) >= *(_QWORD *)(v21 + 0x50)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v30 = v7 + 0xFFFFFFF8;
      do
      {
        v34 = *(_QWORD *)v30;
        *(_QWORD *)v30 = *(_QWORD *)v8;
        LOBYTE(v31) = a4;
        sub_1403001D0(v8, 0, (v30 - v8) >> 3, &v34, v31);
        v30 += 0xFFFFFFF8;
        n0x100 = (unsigned __int64)&v30[8LL - (_QWORD)v8] & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n0x100 >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_1403005F0 (0x1403005F0) ---

// --- Function: sub_140300DE0 (0x140300DE0) ---
__int64 __fastcall sub_140300DE0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
      return 0xFFFFFFFFLL;
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAu;
    *(_BYTE *)(v6 + v5) = v9 + 0x30;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_140300DE0 (0x140300DE0) ---

// --- Function: sub_140300EA0 (0x140300EA0) ---
__int64 __fastcall sub_140300EA0(
        double *Buffer,
        size_t Size,
        __int64 a3,
        const void **a4,
        const void **a5,
        __int64 a6,
        char *p_])
{
  _BYTE *v7; // rdi
  size_t Size_1; // rbx
  char *v12; // rcx
  size_t Size_2; // rsi
  size_t Size_3; // rdi
  __int64 v15; // r14
  _BYTE *v16; // rsi
  char *v17; // rcx
  size_t Size_4; // rbp
  int v19; // eax
  int v20; // ecx
  __int64 result; // rax

  v7 = *a4;
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_1;
  while ( v7[Size_1] );
  if ( Size_1 + a3 >= Size )
    return 0xFFFFFFFFLL;
  v12 = (char *)Buffer + a3;
  Size_2 = Size - a3;
  if ( Size_1 )
  {
    if ( !v12 )
    {
LABEL_6:
      *errno() = 0x16;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v7 && Size_2 >= Size_1 )
    {
      memcpy(v12, *a4, Size_1);
    }
    else
    {
      memset(v12, 0, Size - a3);
      if ( !v7 )
        goto LABEL_6;
      if ( Size_2 < Size_1 )
      {
        *errno() = 0x22;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size_1 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  v15 = a3 + (int)Size_1;
  v16 = *a5;
  do
    ++Size_3;
  while ( v16[Size_3] );
  if ( Size_3 + v15 >= Size )
    return 0xFFFFFFFFLL;
  v17 = (char *)Buffer + v15;
  Size_4 = Size - v15;
  if ( !Size_3 )
    goto LABEL_28;
  if ( !v17 )
    goto LABEL_20;
  if ( v16 && Size_4 >= Size_3 )
  {
    memcpy(v17, *a5, Size_3);
  }
  else
  {
    memset(v17, 0, Size - v15);
    if ( !v16 )
    {
LABEL_20:
      *errno() = 0x16;
LABEL_27:
      invalid_parameter_noinfo();
      goto LABEL_28;
    }
    if ( Size_4 < Size_3 )
    {
      *errno() = 0x22;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( (Size_3 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v19 = sub_140301050(Buffer, Size, (int)v15 + (int)Size_3, a6, p_]);
  if ( v19 < 0 )
    return 0xFFFFFFFFLL;
  v20 = Size_3 + v19;
  result = (unsigned int)(Size_1 + Size_3 + v19);
  if ( v20 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_140300EA0 (0x140300EA0) ---

// --- Function: sub_140301050 (0x140301050) ---
__int64 __fastcall sub_140301050(double *Buffer, unsigned __int64 n0xF, __int64 a3, const void **a4, char *_)
{
  _BYTE *v5; // rsi
  size_t Size; // rbx
  char *v10; // rcx
  size_t Size_1; // rbp
  __int64 v12; // rcx
  size_t Size_2; // rdi
  _BYTE *v14; // rcx

  v5 = *a4;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( v5[Size] );
  if ( Size + a3 >= n0xF )
    return 0xFFFFFFFFLL;
  v10 = (char *)Buffer + a3;
  Size_1 = n0xF - a3;
  if ( !Size )
    goto LABEL_14;
  if ( !v10 )
    goto LABEL_6;
  if ( v5 && Size_1 >= Size )
  {
    memcpy(v10, v5, Size);
  }
  else
  {
    memset(v10, 0, n0xF - a3);
    if ( !v5 )
    {
LABEL_6:
      *errno() = 0x16;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( Size_1 < Size )
    {
      *errno() = 0x22;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v12 = a3 + (int)Size;
  if ( v12 + 1 >= n0xF )
    return 0xFFFFFFFFLL;
  Size_2 = n0xF - v12;
  v14 = (char *)Buffer + v12;
  if ( !v14 )
  {
LABEL_17:
    *errno() = 0x16;
    invalid_parameter_noinfo();
    return (unsigned int)(Size + 1);
  }
  if ( _ && Size_2 )
  {
    *v14 = *_;
    return (unsigned int)(Size + 1);
  }
  else
  {
    memset(v14, 0, Size_2);
    if ( !_ )
      goto LABEL_17;
    if ( !Size_2 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(Size + 1);
  }
}

// --- End Function: sub_140301050 (0x140301050) ---

// --- Function: sub_1403011A0 (0x1403011A0) ---
__int64 __fastcall sub_1403011A0(double *Buffer, unsigned __int64 n0xF, __int64 a3, __int64 p____EVT_COUNT__:, int *a5)
{
  unsigned __int64 n0xD; // rdi
  char *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r10
  int v13; // ecx
  int v14; // r9d
  __int64 v15; // rdi
  __int64 i; // r8
  __int64 v17; // r11
  int v18; // eax
  char *v19; // r8
  char *v20; // rax
  __int64 v21; // r10
  char v22; // cl
  char v23; // dl
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v10 = (char *)Buffer + a3;
  if ( !v10 )
    goto LABEL_3;
  if ( p____EVT_COUNT__: && n0xD >= 0xD )
  {
    *(double *)v10 = *(double *)p____EVT_COUNT__:;
    *((_DWORD *)v10 + 2) = *(_DWORD *)(p____EVT_COUNT__: + 8);
    v10[0xC] = *(_BYTE *)(p____EVT_COUNT__: + 0xC);
    goto LABEL_11;
  }
  memset(v10, 0, n0xF - a3);
  if ( p____EVT_COUNT__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v11 = n0xF - (a3 + 0xD);
  v12 = (__int64)Buffer + a3 + 0xD;
  v13 = *a5;
  if ( *a5 >= 0 )
  {
    v14 = 0;
  }
  else if ( v11 )
  {
    *(_BYTE *)v12 = 0x2D;
    v13 = -v13 & 0x7FFFFFFF;
    v14 = 1;
  }
  else
  {
    v14 = 0xFFFFFFFF;
  }
  v15 = v14;
  for ( i = v14; ; ++i )
  {
    v17 = v14;
    if ( v14 >= (int)v11 || i < 0 )
      break;
    ++v14;
    v18 = v13 % 0xA;
    v13 /= 0xA;
    *(_BYTE *)(i + v12) = v18 + 0x30;
    if ( !v13 )
    {
      if ( v15 < v17 )
      {
        v19 = (char *)(v17 + v12);
        v20 = (char *)(v15 + v12);
        v21 = -v12;
        do
        {
          v22 = *v19--;
          v23 = *v20;
          *v20++ = v22;
          v19[1] = v23;
        }
        while ( (__int64)&v20[v21] < (__int64)&v19[v21] );
      }
      result = (unsigned int)(v14 + 0xD);
      if ( v14 >= 0 )
        return result;
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1403011A0 (0x1403011A0) ---

// --- Function: sub_140301320 (0x140301320) ---
__int64 __fastcall sub_140301320(
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a3,
        __int64 p____@severity__:,
        __int64 *p_n0xF,
        char *___severity__:_,
        __int64 a7,
        char *p______tags__:[)
{
  int n0xF_1; // ebp
  unsigned __int64 n0xD; // rbx
  char *v13; // rcx
  int v14; // ebx
  __int64 v15; // rsi
  __int64 v16; // rcx
  unsigned int n0xF_2; // r9d
  __int64 v18; // r8
  __int64 v19; // r11
  unsigned int v20; // eax
  char *v21; // rdx
  __int64 v22; // r9
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  __int64 result; // rax

  n0xF_1 = n0xF;
  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v13 = (char *)Buffer + a3;
  if ( !v13 )
    goto LABEL_3;
  if ( p____@severity__: && n0xD >= 0xD )
  {
    *(double *)v13 = *(double *)p____@severity__:;
    *((_DWORD *)v13 + 2) = *(_DWORD *)(p____@severity__: + 8);
    v13[0xC] = *(_BYTE *)(p____@severity__: + 0xC);
    goto LABEL_11;
  }
  memset(v13, 0, n0xF - a3);
  if ( p____@severity__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v14 = 0;
  v15 = a3 + 0xD;
  v16 = 0;
  n0xF_2 = *(_DWORD *)p_n0xF;
  v18 = (__int64)Buffer + v15;
  while ( 1 )
  {
    v19 = v14;
    if ( v14 >= n0xF_1 - (int)v15 || v16 < 0 )
      break;
    ++v14;
    v20 = n0xF_2 % 0xA;
    n0xF_2 /= 0xAu;
    *(_BYTE *)(v16 + v18) = v20 + 0x30;
    ++v16;
    if ( !n0xF_2 )
    {
      if ( (int)v19 > 0 )
      {
        v21 = (char *)(v19 + v18);
        v22 = -v18;
        do
        {
          v23 = *v21--;
          v24 = *(_BYTE *)v18;
          *(_BYTE *)v18++ = v23;
          v21[1] = v24;
        }
        while ( v22 + v18 < (__int64)&v21[v22] );
      }
      if ( v14 >= 0 )
      {
        v25 = sub_1403014C0(Buffer, n0xF_1, (int)v15 + v14, ___severity__:_, a7, p______tags__:[);
        if ( v25 >= 0 )
        {
          v26 = v14 + v25;
          result = (unsigned int)(v14 + v25 + 0xD);
          if ( v26 < 0 )
            return 0xFFFFFFFFLL;
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_140301320 (0x140301320) ---

// --- Function: unknown_libname_477 (0x1403016C0) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
_QWORD *__fastcall unknown_libname_477(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  *a1 = a2;
  result = a1;
  a1[1] = a3;
  return result;
}

// --- End Function: unknown_libname_477 (0x1403016C0) ---

// --- Function: sub_140301AF0 (0x140301AF0) ---
_QWORD *__fastcall sub_140301AF0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __int64 p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __int64 p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)sub_1402A65A0(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)sub_1402A65A0(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    memset(&Src, 0, sizeof(Src));
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FD830(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402ABF30((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(_QWORD *)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = (__m256 *)p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = sub_1402A65A0(0x30u);
      *(_QWORD *)(v23 + 0x20) = 0;
      *(_QWORD *)(v23 + 0x28) = 0;
      *(__m256 *)(v23 + 0x10) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 0xF;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x10LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x28LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(_QWORD *)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
        if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A6590(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140301AF0 (0x140301AF0) ---

// --- Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x140302090) ---
void __fastcall std::vector<vraudio::AudioBuffer const *>::_Change_array(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  __int64 v6; // rcx

  v6 = *(_QWORD *)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_1402A6590(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x140302090) ---

// --- Function: sub_1403023E0 (0x1403023E0) ---
bool __fastcall sub_1403023E0(__int64 a1, _QWORD *a2, __int64 *a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  __int64 __Val_0___1; // r10
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // bp
  __int64 v18; // rdi
  __int64 v19; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v21; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v23; // rdi
  unsigned __int64 v24; // r9
  char v25; // al
  __int64 v26; // r8
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rax
  unsigned __int64 v30; // [rsp+20h] [rbp-48h]
  bool v32; // [rsp+80h] [rbp+18h]

  v7 = sub_1403031E0(*((unsigned int *)a3 + 9), a2, a3[3], a1);
  if ( v9 + v7 > v10 )
    return 0;
  v13 = *((unsigned int *)a3 + 8);
  v17 = 0;
  if ( (_DWORD)v13 != 1 )
  {
    v14 = sub_1403031E0(v13, v8, v9, v10);
    if ( v15 + v14 < v16 )
      v17 = 1;
  }
  v18 = a3[1];
  v19 = *a3;
  v32 = v17;
  if ( (v18 - *a3) / 0x70 != _Newcapacity )
  {
    if ( v19 != v18 )
    {
      do
      {
        if ( *(_BYTE *)(v19 + 0x58) && *(_QWORD *)v19 )
          (*(void (**)(void))(v19 + 0x40))();
        v19 += 0x70;
      }
      while ( v19 != v18 );
      a3[1] = *a3;
    }
    sub_1403002C0(a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v17 = 1;
    v32 = 1;
  }
  _Newcapacity_2 = 0;
  v21 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v23 = __Val_0___1 + 0x30;
    v24 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v30 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v17 )
    {
      v21 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v23 + 0x18)
        && *(_QWORD *)v23 )
      {
        if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_1 )
          __debugbreak();
        v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v23)(*(_QWORD *)(v23 - 0x30), *(_QWORD *)(v24 + v23 + *a3));
        v24 = v30;
        v17 = v25 == 0;
        v32 = v25 == 0;
      }
      ++_Newcapacity_1;
      v23 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v17 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v27 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v21 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v27 + 0x38)
          && *(_QWORD *)(v27 + 0x20) )
        {
          if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_2 )
            __debugbreak();
          v28 = v27 + v26 + *a3;
          if ( *(_BYTE *)(v28 + 0x58) )
          {
            if ( *(_QWORD *)v28 )
              (*(void (**)(void))(v28 + 0x40))();
          }
          v29 = (*(__int64 (__fastcall **)(_QWORD))(v27 + 0x38))(*(_QWORD *)(v27 - 0x10));
          v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v28 = v29;
          *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 - 8);
          *(_QWORD *)(v28 + 0x10) = *(_QWORD *)v27;
          *(_QWORD *)(v28 + 0x18) = *(_QWORD *)(v27 + 8);
          *(_QWORD *)(v28 + 0x20) = *(_QWORD *)(v27 + 0x10);
          *(_QWORD *)(v28 + 0x30) = *(_QWORD *)(v27 + 0x20);
          *(_QWORD *)(v28 + 0x28) = *(_QWORD *)(v27 + 0x18);
          *(_QWORD *)(v28 + 0x38) = *(_QWORD *)(v27 + 0x28);
          *(_QWORD *)(v28 + 0x40) = *(_QWORD *)(v27 + 0x30);
          *(_QWORD *)(v28 + 0x48) = *(_QWORD *)(v27 + 0x38);
          *(_QWORD *)(v28 + 0x50) = *(_QWORD *)(v27 + 0x40);
          *(_QWORD *)(v28 + 0x60) = *(_QWORD *)(v27 + 0x50);
          *(_QWORD *)(v28 + 0x68) = *(_QWORD *)(v27 + 0x58);
          *(_BYTE *)(v28 + 0x58) = 1;
          *(_BYTE *)(v28 + 0x59) = *(_BYTE *)(v27 + 0x49);
        }
        ++_Newcapacity_2;
        v27 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v17 = v32;
    }
    a3[3] = a1;
  }
  return v17;
}

// --- End Function: sub_1403023E0 (0x1403023E0) ---

// --- Function: sub_140302770 (0x140302770) ---
__int64 __fastcall sub_140302770(__int64 a1, __int64 a2)
{
  float v2; // xmm0_4
  __int64 result; // rax

  v2 = *(float *)(a2 + 0x34);
  qword_149C78C98 = *(__int64 (**)(void))a1;
  qword_149C78CF0 = *(_QWORD *)(a1 + 8);
  qword_149C78CF8 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 0x10);
  qword_149C78D00 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 0x18);
  qword_149C78D08 = *(_QWORD *)(a1 + 0x20);
  qword_149C78D10 = *(_QWORD *)(a1 + 0x28);
  qword_149C78D18 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD))(a1 + 0x30);
  qword_149C78D20 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD))(a1 + 0x38);
  qword_149C78D28 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 0x40);
  qword_149C78D30 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 0x48);
  qword_149C78D38 = *(_QWORD *)(a1 + 0x50);
  byte_149A5E748 = *(_BYTE *)a2;
  n0x8000_0 = *(_QWORD *)(a2 + 8);
  qword_149C78D48 = *(_QWORD *)(a2 + 0x10);
  n0x8000 = *(_QWORD *)(a2 + 0x18);
  n0x100000 = *(_QWORD *)(a2 + 0x20);
  n2 = *(_DWORD *)(a2 + 0x28);
  n2_0 = *(_DWORD *)(a2 + 0x2C);
  byte_149C789B8 = *(_BYTE *)(a2 + 0x30);
  qword_149A5E758 = *(_QWORD *)(a2 + 0x38);
  result = *(_QWORD *)(a2 + 0x40);
  qword_149A5E760 = result;
  *(float *)&dword_149A5E754 = v2;
  return result;
}

// --- End Function: sub_140302770 (0x140302770) ---

// --- Function: sub_1403030E0 (0x1403030E0) ---
__int64 __fastcall sub_1403030E0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", v3 - 0x3E8 * v7) + 0x13);
}

// --- End Function: sub_1403030E0 (0x1403030E0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1403031A0) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149C78D00 )
    result = qword_149C78D00(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149C78D18 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149C78D20 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1403031A0) ---

// --- Function: sub_1403031E0 (0x1403031E0) ---
__int64 __fastcall sub_1403031E0(int a1)
{
  __int64 n0x3E8; // rax

  switch ( a1 )
  {
    case 2:
      n0x3E8 = 0x3E8;
      break;
    case 3:
      n0x3E8 = 0x1388;
      break;
    case 4:
      n0x3E8 = 0x3A98;
      break;
    case 5:
      n0x3E8 = 0x7530;
      break;
    case 6:
      n0x3E8 = 0xEA60;
      break;
    case 7:
      n0x3E8 = 0x493E0;
      break;
    case 8:
      n0x3E8 = 0xDBBA0;
      break;
    case 9:
      n0x3E8 = 0x1B7740;
      break;
    default:
      n0x3E8 = 0;
      break;
  }
  return n0x3E8;
}

// --- End Function: sub_1403031E0 (0x1403031E0) ---

// --- Function: sub_1403032F0 (0x1403032F0) ---
__int64 __fastcall sub_1403032F0(_WORD *a1, int a2, char n0x25)
{
  unsigned int n2_1; // r10d
  __int64 n2; // rax

  n2_1 = 0;
  switch ( n0x25 )
  {
    case 8:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x625C;
      n2 = 2;
      break;
    case 9:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x745C;
      n2 = 2;
      break;
    case 0xA:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x6E5C;
      n2 = 2;
      break;
    case 0xC:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x665C;
      n2 = 2;
      break;
    case 0xD:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x725C;
      n2 = 2;
      break;
    case 0x22:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x225C;
      n2 = 2;
      break;
    case 0x5C:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 0x5C5C;
      n2 = 2;
      break;
    default:
      if ( a2 > 0 )
      {
        *(_BYTE *)a1 = n0x25;
        n2_1 = 1;
      }
LABEL_18:
      n2 = n2_1;
      break;
  }
  return n2;
}

// --- End Function: sub_1403032F0 (0x1403032F0) ---

// --- Function: sub_140303440 (0x140303440) ---
__int64 __fastcall sub_140303440(_BYTE *a1, int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // r10
  int v8; // edx
  int v9; // ebp
  unsigned __int64 i; // rbx
  int v11; // r11d
  int v12; // r9d
  _WORD *v13; // r8
  __int64 v14; // rax
  unsigned int v15; // edx

  v4 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v4;
  while ( *(_BYTE *)(a3 + v4) );
  v8 = 0;
  v9 = 0;
  if ( a4 )
  {
    if ( a2 <= 0 )
    {
      v9 = 1;
    }
    else
    {
      *a1 = 0x22;
      v8 = 1;
    }
  }
  for ( i = 0; i < v4; ++i )
  {
    if ( v8 >= a2 )
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = a2 - v8;
      v13 = &a1[v8];
      switch ( *(_BYTE *)(i + a3) )
      {
        case 8:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x625C;
          v8 += 2;
          break;
        case 9:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x745C;
          v8 += 2;
          break;
        case 0xA:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x6E5C;
          v8 += 2;
          break;
        case 0xC:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x665C;
          v8 += 2;
          break;
        case 0xD:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x725C;
          v8 += 2;
          break;
        case 0x22:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x225C;
          v8 += 2;
          break;
        case 0x5C:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x5C5C;
          v8 += 2;
          break;
        default:
          if ( v12 > 0 )
          {
            *(_BYTE *)v13 = *(_BYTE *)(i + a3);
            v11 = 1;
          }
LABEL_26:
          v8 += v11;
          break;
      }
    }
  }
  if ( a4 )
  {
    if ( v8 < a2 )
    {
      v14 = v8;
      v15 = v8 + 1;
      if ( v9 )
        v15 = 0xFFFFFFFF;
      a1[v14] = 0x22;
      return v15;
    }
    v9 = 1;
  }
  if ( v9 )
    return 0xFFFFFFFF;
  return (unsigned int)v8;
}

// --- End Function: sub_140303440 (0x140303440) ---

// --- Function: sub_140304A70 (0x140304A70) ---
__int64 __fastcall sub_140304A70(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        __int64 a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  __int64 v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  unsigned int v87[2]; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149A5E708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149A5E720[0];
  }
  else
  {
    v17 = off_149A5E728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149A5E738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149A5E710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149A5E710 )
      {
        memcpy(Buffer, off_149A5E710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_140300EA0((double *)Buffer, Size, (int)Size_1 + 1LL, (const void **)v87, v21, (__int64)&off_149A5E710, "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149A5E710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149A5E710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149A5E710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149A5E710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149A5E730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149A5E730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149A5E730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149A5E730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149A5E710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  *(_QWORD *)v87 = v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149A5E710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149A5E710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149A5E710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = *(_QWORD *)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = v45 + 2;
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( Size_11 + v48 >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[v48];
  Size_12 = Size - v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140307B30(
          (_DWORD)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64)sub_1402FFA40);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149A5E710;
      *(_QWORD *)v87 = qword_149C789B0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149A5E710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_140300EA0(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149A5E718,
                        (const void **)(*(_QWORD *)v87 + Sizec),
                        (__int64)&off_149A5E710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149A5E710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149A5E710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149C78D18(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140304A70 (0x140304A70) ---

// --- Function: sub_140305570 (0x140305570) ---
__int64 __fastcall sub_140305570(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        char *a7,
        __int64 a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        __int64 a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_27; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  int n0xF_8; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  int n0xF_10; // ebp
  int n0xF_11; // r14d
  int n0xF_12; // r15d
  int n0xF_13; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_14; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_15; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_16; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_17; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_23; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_19; // edx
  int n0xF_20; // ecx
  bool v109; // r15
  int n0xF_21; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_24; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_25; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_26; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  __int64 *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  int n0xF_9; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  int n0xF_18; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_22; // [rsp+98h] [rbp-D0h]
  __int64 n0xF_5; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  __int64 v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, __int64, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 0x80;
  LODWORD(n0xF_5) = n4;
  v159 = a6;
  n0xF_22 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_27 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_140300DE0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_27 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_27;
  if ( n0xF_27 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_27 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149C78D28 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149C78D28(
              v162,
              v161,
              n4_1,
              v166,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149C78D20;
  v156 = v50;
  v51 = (a18 & 1) != 0 && ::n2 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_0 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149C78CF8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_9 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_95;
    }
    v53 = qword_149C78CF8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149C78CF8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_9 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_9 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_8 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_140301320(
            Buffer,
            n0xF_3,
            n0xF_2,
            (__int64)",\"@severity\":",
            &n0xF_5,
            ",\"severity\":\"",
            (__int64)&off_149A5E738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    LODWORD(n0xF_5) = n0xF_8;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149C789B0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_22 )
    {
LABEL_129:
      n0xF_3 = n0xF + 0x80;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_8 = n0xF_5;
      v62 = v160;
      v58 = v159;
      goto LABEL_131;
    }
    Size_7 = n0xF_22 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_22 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 0x22;
      }
      else
      {
LABEL_111:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_22 )
      goto LABEL_130;
    n2 = n0xF_22 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_8 = n0xF_5;
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_9 = n0xF_8;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149C789B0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_140301050(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_10 = n0xF_8;
    n0xF_11 = n0xF_6;
    v47 = 1;
    n0xF_12 = n0xF_2;
    n0xF_13 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_9 = n0xF_8;
LABEL_145:
  n0xF_10 = n0xF_8;
  n0xF_11 = n0xF_6;
  n0xF_12 = n0xF_2;
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_13;
      n0xF_9 = n0xF_8;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_9 = n0xF_10;
    n0xF_2 = n0xF_12 + 0xB;
    n0xF_6 = n0xF_11;
    n0xF_8 = n0xF_10;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_1403032F0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_14 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_14 = n0xF_2;
        n0xF_2 = n0xF_14;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_9 = n0xF_8;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_9 = n0xF_8;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_1403032F0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_15 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_15 = n0xF_2;
        n0xF_2 = n0xF_15;
      }
    }
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_209:
  n0xF_16 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140307B30((_DWORD)Buffer, n0xF, n0xF_2, v164, __Val_0___1, _Newcapacity, a11, 1, (__int64)sub_1402FFA80);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_16;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_17 = n0xF_29;
  v102 = 0;
  n0xF_5 = 0;
  v103 = 0;
  n0xF_23 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_23);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_8 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_18 = n0xF_8;
              n0xF_19 = n0xF_2;
              n0xF_20 = n0xF_8;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_21 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_19 = n0xF_2;
            n0xF_18 = n0xF_8;
            n0xF_20 = n0xF_8;
            n0xF_21 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_8 )
            {
LABEL_248:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_22 )
              {
                v105 = v160;
                n0xF_8 = n0xF_20;
                n0xF_2 = n0xF_19;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_255;
              }
              if ( n0xF_22 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 0x16;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_8 = n0xF_18;
                n0xF_2 = n0xF_21;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_8 = n0xF_18;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_21;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_21;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_8 && n0xF_2 + 1LL < n0xF_22 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_292;
                }
                if ( n0xF_22 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_23 = n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_8 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_20 = n0xF_8;
          n0xF_18 = n0xF_8;
          v47 = 1;
          n0xF_19 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_21 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_23 >= n0xF_17 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_24 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_24 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_25 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_25;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_8 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_22 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_22 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_315:
      n0xF_17 = n0xF_29;
      if ( (n0xF_23 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_17 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      n0xF_5 = ++n0xF_23;
      if ( n0xF_23 >= n0xF_17 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( (int)a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_8 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_8 )
  {
    v137 = sub_1403011A0(Buffer, n0xF_3, n0xF_2, (__int64)",\"EVT_COUNT\":", (int *)&a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149C78D30 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149C78D30(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_26 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_26 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (__int64 *)n0xF_26;
    v147 = v161;
    qword_149C78D20(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140305570 (0x140305570) ---

// --- Function: sub_140306C00 (0x140306C00) ---
void __fastcall sub_140306C00(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)sub_1402A65A0(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E3880();
      v8 = sub_1402A65A0(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_140306C00 (0x140306C00) ---

// --- Function: sub_140306CF0 (0x140306CF0) ---
char __fastcall sub_140306CF0(
        int n4_1,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 __Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // r14
  char result; // al
  unsigned __int64 n0x10; // rax
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v17; // r13
  char *v18; // r15
  __int64 v19; // r14
  const vraudio::AudioBuffer *__Val_0___2; // rdi
  unsigned __int8 v21; // si
  const vraudio::AudioBuffer *__Val_0___5; // r15
  __int64 *v23; // rax
  __int64 *v24; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v26; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v30; // r13
  __int64 (__fastcall *v31)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v32; // rax
  unsigned __int64 v33; // rcx
  __int64 *v34; // rdi
  _QWORD *v35; // r13
  bool v36; // zf
  _QWORD *v37; // rbx
  _QWORD *v38; // rax
  _BYTE *v39; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v42; // r9
  __int64 v43; // rcx
  __m256 *p_Src; // r14
  char *v45; // r14
  const vraudio::AudioBuffer *__Val_0___4; // r12
  unsigned __int64 n0xF; // r13
  __int64 p_Src_2; // r15
  _QWORD *v49; // r14
  _QWORD *v50; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v55; // rax
  __int64 *v56; // rcx
  __int64 v57; // rcx
  _QWORD *v58; // rbx
  __int64 v59; // rcx
  __int64 *v60; // r14
  __int64 p_Src_3; // rax
  __int64 *v62; // rax
  unsigned __int64 n0x400_3; // r15
  __int64 v64; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v68; // rax
  char *v69; // r11
  __int64 v70; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v72; // rdi
  int v73; // r13d
  __int64 v74; // rcx
  __int64 v75; // r9
  unsigned __int64 n0x400_4; // r8
  __int64 v77; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v82; // rax
  __int64 v83; // r15
  char *v84; // r14
  __int64 v85; // rax
  void *v86; // rsp
  __int64 (__fastcall *v87)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v88; // edx
  int v89; // r12d
  char v90; // cl
  int v91; // eax
  FILE *File; // rax
  int n2; // r8d
  FILE *File_1; // rax
  char v95; // al
  bool v96; // dl
  bool v97; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v99; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v104; // rax
  void *v105; // rsp
  char v106; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v109; // rsi
  _QWORD **v110; // rcx
  _QWORD *v111; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v113; // rdi
  __int64 v114; // rcx
  __int64 *v115; // rbx
  __int64 v116; // rcx
  int v117; // [rsp+90h] [rbp-10h]
  unsigned __int8 v118; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0x400_2; // [rsp+A8h] [rbp+8h]
  __int64 *v120; // [rsp+B0h] [rbp+10h]
  __int64 v121; // [rsp+B8h] [rbp+18h]
  int n4; // [rsp+C0h] [rbp+20h]
  __int64 v123; // [rsp+C8h] [rbp+28h] BYREF
  unsigned __int64 v124; // [rsp+D0h] [rbp+30h]
  char *v125; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  __int64 __Val_0___7; // [rsp+F0h] [rbp+50h]
  int v129[2]; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0__; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v131; // [rsp+108h] [rbp+68h] BYREF
  __int64 __Val_0___3; // [rsp+110h] [rbp+70h]
  __int64 v133; // [rsp+118h] [rbp+78h]
  void *v134; // [rsp+120h] [rbp+80h]
  __int64 v135; // [rsp+128h] [rbp+88h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+130h] [rbp+90h]
  _QWORD *v137; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___1; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v142; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v143; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v144; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v147[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v148[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v133 = a4;
  v134 = a3;
  v135 = a2;
  n4 = n4_1;
  __Val_0___7 = __Val_0___8;
  if ( qword_149C78C98 )
  {
    v12 = qword_149C78C98();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  *(_QWORD *)v129 = v12;
  if ( v11 )
  {
    result = sub_1403023E0(v12, v10, v11, __Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_149C78CF0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149C78CF0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149C78D60++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403030E0(Buffer, 0x20u, v12);
  v143 = (__int64 *)&v142;
  n0x10 = 0;
  v142 = 0;
  v15 = 0;
  v120 = 0;
  n0x400 = 0;
  n0x400_2 = 0;
  v17 = 0;
  v121 = 0;
  v18 = 0;
  n0x10_1 = 0;
  v19 = 0;
  v125 = 0;
  v123 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v72 = (char *)v148;
    goto LABEL_106;
  }
  __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___7;
  v21 = v118;
  __Val_0___3 = __Val_0___7;
  while ( 2 )
  {
    __Val_0___5 = __Val_0___2;
    if ( *((_BYTE *)__Val_0___2 + 0x59) && n0x10 < 0x10 )
    {
      v147[n0x10++] = __Val_0___2;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0__ = (unsigned __int64)__Val_0___2;
    if ( n0x400 < 0x400 )
    {
      v148[n0x400] = __Val_0___2;
LABEL_30:
      n0x400_2 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149A5E748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v23 = (__int64 *)sub_1402A65A0(0x18u);
        v15 = v23;
        v120 = v23;
        if ( v23 )
        {
          v24 = v23;
          *v23 = 0;
          n0x400_1 = 0;
          v23[1] = 0;
          v26 = (__int64)v23;
          v23[2] = 0;
        }
        else
        {
          v15 = 0;
          v24 = 0;
          n0x400_1 = 0;
          v120 = 0;
          v26 = 0;
        }
        sub_140306C00(v26, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v148;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v24[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v24[2] )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              (std::vector<vraudio::AudioBuffer const *> *)v15,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v24[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0x400_2;
        __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
        v19 = v123;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v15[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v15[2] )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          (std::vector<vraudio::AudioBuffer const *> *)v15,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0__);
      }
      else
      {
        *_Whereptr_1 = __Val_0___2;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v121 = *((_QWORD *)__Val_0___2 + 0xD) + v17;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___2 + 1) = sub_140301AF0(&v143, (__int64)__Val_0___2);
    v30 = v19;
    v31 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___2 + 7);
    v144 = v19++;
    v123 = v19;
    if ( !v31 )
    {
      v69 = v125;
      goto LABEL_98;
    }
    __Val_0__ = 0;
    v131 = 0;
    v32 = v31(*(_QWORD *)__Val_0___2, &v131, &__Val_0__);
    v33 = 0;
    v124 = 0;
    if ( !v131 )
      goto LABEL_94;
    v34 = v143;
    v35 = (_QWORD *)(v32 + 0x10);
    v137 = (_QWORD *)(v32 + 0x10);
    do
    {
      __Val_0___5 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      __Val_0___6 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      v36 = *v35 == 0;
      v123 = v19 + 1;
      v35[8] = v19;
      if ( v36 )
      {
        v58 = (_QWORD *)v35[0xFFFFFFFF];
        v60 = 0;
      }
      else
      {
        if ( !*v34 )
        {
          __asm { vzeroupper }
          v37 = (_QWORD *)sub_1402A65A0(0x10u);
          if ( v37 )
          {
            *v37 = 0;
            v37[1] = 0;
            v38 = (_QWORD *)sub_1402A65A0(0x30u);
            *v38 = v38;
            v38[1] = v38;
            *v37 = v38;
          }
          else
          {
            v37 = 0;
          }
          *v34 = (__int64)v37;
        }
        v39 = (_BYTE *)v35[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v39[Size_1] );
        __asm { vzeroupper }
        sub_1402FD830(&Src, v39, Size_1);
        v42 = (_BYTE *)*v35;
        do
          ++Size;
        while ( v42[Size] );
        v43 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402ABF30((const void **)&Src, Size, v21, v42, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v45 = (char *)p_Src + v43;
          memmove(v45, v42, Size);
          v45[Size] = 0;
        }
        __Val_0___4 = (const vraudio::AudioBuffer *)*v34;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(_QWORD *)Src.m256_f32;
        __Val_0___1 = __Val_0___4;
        v49 = *(_QWORD **)__Val_0___4;
        v50 = **(_QWORD ***)__Val_0___4;
        if ( v50 == *(_QWORD **)__Val_0___4 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v50[4];
          Buf1 = v50 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = (__m256 *)p_Src_2;
          if ( v50[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v50 = (_QWORD *)*v50;
        }
        while ( v50 != v49 );
        __Val_0___4 = __Val_0___1;
        if ( v50 == v49 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___4 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v55 = sub_1402A65A0(0x30u);
          *(_QWORD *)(v55 + 0x20) = 0;
          *(_QWORD *)(v55 + 0x28) = 0;
          *(__m256 *)(v55 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___4 + 1);
          v56 = (__int64 *)v49[1];
          *(_QWORD *)v55 = v49;
          *(_QWORD *)(v55 + 8) = v56;
          v49[1] = v55;
          *v56 = v55;
          v57 = *(_QWORD *)*v34;
          v58 = (_QWORD *)(*(_QWORD *)(v57 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v57 + 8) + 0x28LL) > 0xFu )
            v58 = (_QWORD *)*v58;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v59 = *(_QWORD *)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v59 = *(_QWORD *)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - v59 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A6590(v59);
          }
LABEL_66:
          v15 = v120;
          v60 = 0;
          v35 = v137;
          __Val_0___5 = __Val_0___6;
          v33 = v124;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v58 = v50 + 2;
        if ( v58[3] > 0xFu )
          v58 = (_QWORD *)*v58;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
          if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A6590(p_Src_2);
        v15 = v120;
        v60 = 0;
        v35 = v137;
        __Val_0___5 = __Val_0___6;
        v33 = v124;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___5 + 1) = v58;
      n0x400 = n0x400_2;
      __Val_0___1 = __Val_0___5;
      if ( n0x400_2 >= 0x400 )
      {
        if ( !byte_149A5E748 )
          goto LABEL_92;
        if ( !v15 )
        {
          __asm { vzeroupper }
          v62 = (__int64 *)sub_1402A65A0(0x18u);
          n0x400_3 = 0;
          v120 = v62;
          v15 = v62;
          if ( v62 )
          {
            *v62 = 0;
            v64 = (__int64)v62;
            v62[1] = 0;
            v62[2] = 0;
            v60 = v62;
          }
          else
          {
            v15 = 0;
            v120 = 0;
            v64 = 0;
          }
          sub_140306C00(v64, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v148;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v60[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v60[2] )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                (std::vector<vraudio::AudioBuffer const *> *)v15,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v60[1] += 8;
            }
            ++n0x400_3;
            ++__Val_0__1;
          }
          while ( n0x400_3 < 0x400 );
          n0x400 = n0x400_2;
          __Val_0___5 = __Val_0___6;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v15[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v15[2] )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            (std::vector<vraudio::AudioBuffer const *> *)v15,
            _Whereptr_3,
            &__Val_0___1);
        }
        else
        {
          *_Whereptr_3 = __Val_0___5;
          v15[1] += 8;
        }
        v33 = v124;
      }
      else
      {
        v148[n0x400_2] = __Val_0___5;
      }
      n0x400_2 = ++n0x400;
LABEL_92:
      ++v33;
      v68 = v35[0xB] + v121;
      v35 += 0xE;
      v19 = v123;
      v121 = v68;
      v124 = v33;
      v137 = v35;
    }
    while ( v33 < v131 );
    __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
    v30 = v144;
LABEL_94:
    if ( __Val_0__ > 1 )
      v30 = 0xFFFFFFFFFFFFFFFFuLL;
    v69 = &v125[__Val_0__];
    v125 += __Val_0__;
LABEL_98:
    __Val_0___2 = (const vraudio::AudioBuffer *)((char *)__Val_0___2 + 0x70);
    v70 = v121;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___5 + 0xA) = v30;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___3 = (__int64)__Val_0___2;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v17 = v70;
      continue;
    }
    break;
  }
  v18 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  v125 = v69;
  if ( !v15 )
    goto LABEL_105;
  if ( !((v15[1] - *v15) >> 3) )
    __debugbreak();
  v72 = (char *)*v15;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v125 = v69;
LABEL_106:
  __asm { vzeroupper }
  sub_1403005F0(v72, &v72[8 * n0x400], (__int64)(8 * n0x400) >> 3, v118);
  v73 = 0;
  v74 = 0;
  v75 = 0;
  for ( n0x400_4 = 0; n0x400_4 < n0x400; ++n0x400_4 )
  {
    v77 = *(_QWORD *)&v72[8 * n0x400_4];
    if ( v75 == *(_QWORD *)(v77 + 8) )
    {
      if ( ++v74 == 1 )
        *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 0x50LL) = v74;
    }
    else
    {
      v74 = 0;
      *(_QWORD *)(v77 + 0x50) = -(__int64)(*(_QWORD *)(v77 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v75 = *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = n0x8000_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
    n0x8000 = ::n0x8000;
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
    n0x100000 = ::n0x100000;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149A5E748 )
    p_n0x8000 = &n0x8000_1;
  if ( !n0x8000_0 )
    n0x8000_2 = (_QWORD)(v18 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v83 = 0;
  }
  else
  {
    v82 = sub_1402A65A0(n0x8000_2);
    v83 = v82;
    if ( v82 )
    {
      v84 = (char *)v82;
      goto LABEL_130;
    }
  }
  v85 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v85 = 0xFFFFFFFFFFFFFF0LL;
  v86 = alloca(v85 & 0xFFFFFFFFFFFFFFF0uLL);
  v84 = (char *)&v118;
LABEL_130:
  v87 = (__int64 (__fastcall *)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149C78D08;
  v88 = 1;
  *v84 = 0;
  v89 = 0;
  LODWORD(v123) = 0;
  LODWORD(v124) = 1;
  if ( v87 && qword_149C78D10 && byte_149A5E748 )
  {
    v88 = v87(*(_QWORD *)v129, (unsigned int)n4, v134, v135, v133, __Val_0___7, _Newcapacity, v147, n0x10_1, &a8);
    LODWORD(v124) = v88;
  }
  v90 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v91 = sub_140304A70(
            *(_QWORD *)&FileTime,
            *(__int64 *)v129,
            (__int64)String,
            n4,
            (__int64 *)v135,
            v134,
            v133,
            (_QWORD *)__Val_0___7,
            _Newcapacity,
            a7,
            v84,
            n0x8000_2,
            (int *)&v123,
            v88,
            &a8);
    v90 = a8;
    v89 = v91;
    v73 = v123;
  }
  if ( ::n2 == 1 && (v90 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v84);
    v90 = a8;
  }
  n2 = n2_0;
  if ( n2_0 == 1 && (v90 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(n2_0 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v84);
    n2 = n2_0;
  }
  v84[v89] = 0;
  v95 = a8;
  v96 = (a8 & 1) != 0 && ::n2 == 2;
  v97 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v96 || v97 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149A5E748 )
      p_n0x8000_1 = &n0x8000_1;
    v99 = qword_149C78D48;
    if ( !qword_149C78D48 )
      v99 = v121 + v89 + ((_QWORD)(v125 + 4) << 9);
    n0x8000_3 = v99 + 0x80;
    if ( *p_n0x8000_1 < v99 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = sub_1402A65A0(n0x8000_3);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v104 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v104 = 0xFFFFFFFFFFFFFF0LL;
    v105 = alloca(v104 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v118;
LABEL_166:
    v117 = v124;
    *(_BYTE *)Buffer_1 = 0;
    sub_140305570(
      *(_QWORD *)&FileTime,
      *(__int64 *)v129,
      Buffer,
      String,
      n4,
      (_QWORD *)v135,
      v134,
      v133,
      __Val_0___7,
      _Newcapacity,
      a7,
      (__int64)v72,
      n0x400_2,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v84[v73],
      v89 - v73,
      a8,
      v117);
    sub_1402A6590(Buffer_3);
    v95 = a8;
  }
  v106 = byte_149C789B8;
  if ( byte_149C789B8 )
  {
    if ( (v95 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v95 = a8;
      v106 = byte_149C789B8;
    }
    if ( v106 )
    {
      if ( (v95 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A6590(v83);
  v109 = v142;
  if ( v142 )
  {
    v110 = (_QWORD **)*v142;
    **(_QWORD **)(*v142 + 8) = 0;
    v111 = *v110;
    if ( *v110 )
    {
      do
      {
        n0xF_1 = v111[5];
        v113 = (_QWORD *)*v111;
        if ( n0xF_1 > 0xF )
        {
          v114 = v111[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v114 - *(_QWORD *)(v114 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v114 = *(_QWORD *)(v114 - 8);
          }
          sub_1402A6590(v114);
        }
        v111[4] = 0;
        v111[5] = 0xF;
        *((_BYTE *)v111 + 0x10) = 0;
        sub_1402A6590((__int64)v111);
        v111 = v113;
      }
      while ( v113 );
    }
    sub_1402A6590(*v109);
    result = sub_1402A6590((__int64)v109);
  }
  v115 = v120;
  if ( v120 )
  {
    v116 = *v120;
    if ( *v120 )
    {
      if ( ((v120[2] - v116) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v116 - *(_QWORD *)(v116 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v116 = *(_QWORD *)(v116 - 8);
      }
      sub_1402A6590(v116);
      *v115 = 0;
      v115[1] = 0;
      v115[2] = 0;
    }
    return sub_1402A6590((__int64)v115);
  }
  return result;
}

// --- End Function: sub_140306CF0 (0x140306CF0) ---

// --- Function: sub_140307B30 (0x140307B30) ---
__int64 __fastcall sub_140307B30(
        __int64 a1,
        __int64 a2,
        int a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        __int64 (__fastcall *a9)(__int64, __int64, __int64, __int64, __int64, _BYTE *))
{
  __int64 v9; // rbp
  int v11; // ecx
  int v12; // esi
  char n0x25; // r8
  __int64 v14; // r15
  char *v15; // rbx
  __int64 v17; // rcx
  char n0x24; // cl
  __int64 v19; // rdi
  _BYTE *v20; // r11
  unsigned __int64 n0x39; // rcx
  char *v22; // r10
  int n0x1F_2; // r8d
  signed __int64 n0x1F; // rdx
  __int64 v25; // r9
  int n0x1F_1; // eax
  __int64 n0x1F_3; // rcx
  int v28; // eax
  int v29; // edi
  _BYTE *v30; // rbp
  int n0x1F_5; // r9d
  __int64 n0x1F_6; // r8
  char *v33; // r11
  __int64 v34; // r10
  int n0x1F_4; // eax
  int v36; // eax
  int v37; // eax
  __int64 v38; // rax
  _BYTE *v40; // [rsp+28h] [rbp-90h]
  char String[4]; // [rsp+30h] [rbp-88h] BYREF
  int v42; // [rsp+34h] [rbp-84h]
  __int64 (__fastcall *v43)(__int64, __int64, __int64, __int64, __int64, _BYTE *); // [rsp+38h] [rbp-80h]
  __int64 v44; // [rsp+40h] [rbp-78h]
  _BYTE v45[32]; // [rsp+48h] [rbp-70h] BYREF

  v9 = a5;
  v11 = a3;
  v12 = a3;
  v44 = a5;
  n0x25 = *a4;
  v14 = 0;
  v43 = a9;
  v15 = a4;
  v42 = v11;
  if ( n0x25 )
  {
    do
    {
      v17 = 0x3FF6C0900000000LL;
      if ( n0x25 == 0x24 )
      {
        n0x24 = *++v15;
        v19 = 0;
        if ( n0x24 == 0x24 )
        {
LABEL_6:
          v19 = v14++;
        }
        else
        {
          while ( (unsigned __int8)(n0x24 - 0x30) <= 9u )
          {
            String[0] = n0x24;
            ++v15;
            v19 = atoi(String) + 0xA * v19;
            n0x24 = *v15;
            if ( *v15 == 0x24 )
              goto LABEL_6;
          }
          --v15;
        }
        v20 = 0;
        if ( v15[1] == 0x7B )
        {
          n0x39 = (unsigned __int8)v15[2];
          v22 = v15;
          v15 += 2;
          n0x1F_2 = 0;
          n0x1F = 0;
          if ( (_BYTE)n0x39 != 0x7D )
          {
            do
            {
              if ( n0x1F >= 0x1F
                || (unsigned __int8)n0x39 > 0x39u
                || (v25 = 0x3FF6C0900000000LL, !_bittest64(&v25, n0x39)) )
              {
                v15 = v22;
                goto LABEL_20;
              }
              ++v15;
              v45[n0x1F] = n0x39;
              ++n0x1F_2;
              ++n0x1F;
              n0x39 = (unsigned __int8)*v15;
            }
            while ( (_BYTE)n0x39 != 0x7D );
            if ( n0x1F_2 > 0 )
            {
              n0x1F_1 = 0x1F;
              if ( n0x1F_2 < 0x1F )
                n0x1F_1 = n0x1F_2;
              n0x1F_3 = n0x1F_1;
              if ( (unsigned __int64)n0x1F_1 >= 0x20 )
LABEL_55:
                _report_rangecheckfailure(n0x1F_3, n0x1F);
              v45[n0x1F_1] = 0;
              v20 = v45;
            }
          }
        }
LABEL_20:
        if ( v12 < (int)a2 )
        {
          v28 = v43(v12 + a1, a2 - v12, v9, v19 + a7, a6, v20);
          if ( v28 >= 0 )
            v12 += v28;
        }
        v29 = a2;
      }
      else if ( n0x25 == 0x25 )
      {
        v30 = 0;
        n0x1F_5 = 0;
        n0x1F_6 = 0;
        v33 = v15;
        v34 = 0;
        while ( 2 )
        {
          n0x1F = *++v15;
          switch ( (int)n0x1F )
          {
            case 0:
              v15 = v33 + 1;
              goto LABEL_39;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x42:
            case 0x44:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x59:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x62:
            case 0x68:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x71:
            case 0x72:
            case 0x74:
            case 0x76:
            case 0x77:
              v17 = 0x3FF6C0900000000LL;
              goto LABEL_28;
            case 0x25:
            case 0x41:
            case 0x43:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x53:
            case 0x58:
            case 0x5A:
            case 0x61:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x69:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x73:
            case 0x75:
            case 0x78:
              if ( n0x1F_5 <= 0 )
                goto LABEL_37;
              n0x1F_4 = 0x1F;
              if ( n0x1F_5 < 0x1F )
                n0x1F_4 = n0x1F_5;
              n0x1F_3 = n0x1F_4;
              if ( (unsigned __int64)n0x1F_4 >= 0x20 )
                goto LABEL_55;
              v45[n0x1F_4] = 0;
              v30 = v45;
LABEL_37:
              v34 = v14++;
LABEL_39:
              v29 = a2;
              if ( v12 >= (int)a2 )
              {
                v9 = v44;
              }
              else
              {
                v40 = v30;
                v9 = v44;
                v36 = v43(v12 + a1, a2 - v12, v44, v34 + a7, a6, v40);
                if ( v36 >= 0 )
                  v12 += v36;
              }
              break;
            default:
LABEL_28:
              if ( n0x1F_6 < 0x1F && (unsigned __int8)n0x1F <= 0x39u && _bittest64(&v17, n0x1F) )
              {
                ++n0x1F_5;
                v45[n0x1F_6++] = n0x1F;
              }
              continue;
          }
          break;
        }
      }
      else
      {
        v29 = a2;
        if ( a8 )
        {
          if ( v12 < (int)a2 )
          {
            v37 = sub_1403032F0((_WORD *)(v12 + a1), (int)a2 - v12, n0x25);
            if ( v37 >= 0 )
              v12 += v37;
          }
        }
        else if ( v12 < (int)a2 )
        {
          v38 = v12++;
          *(_BYTE *)(v38 + a1) = n0x25;
        }
      }
      n0x25 = *++v15;
    }
    while ( n0x25 );
    v11 = v42;
  }
  else
  {
    v29 = a2;
  }
  if ( v12 < v29 )
    *(_BYTE *)(v12 + a1) = 0;
  return (unsigned int)(v12 - v11);
}

// --- End Function: sub_140307B30 (0x140307B30) ---

// --- Function: swprintf (0x140308540) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A6BE0();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: swprintf (0x140308540) ---

// --- Function: unknown_libname_18 (0x140308760) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_18(_QWORD *a1)
{
  return *a1 == 0;
}

// --- End Function: unknown_libname_18 (0x140308760) ---

// --- Function: sub_140309F90 (0x140309F90) ---
unsigned __int64 __fastcall sub_140309F90(unsigned __int64 *a1, _WORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  unsigned __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _WORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  _BYTE *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = (char *)a1[1];
  v4 = (char *)a1[2];
  if ( v2 == v4 )
  {
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*a1] >> 1;
    if ( v8 == 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = (__int64)&v4[-*a1] >> 1;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x7FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_WORD *)sub_140394E70((__int64)a1, 2 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = (char *)a1[1];
    v16 = (_BYTE *)*a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 2;
      Size = a1[1] - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *a1 )
      sub_1403A6820((__int64)a1, *a1, 2 * ((__int64)(a1[2] - *a1) >> 1));
    *a1 = (unsigned __int64)v13;
    result = (unsigned __int64)v17;
    a1[1] = (unsigned __int64)&v13[v11];
    a1[2] = (unsigned __int64)&v13[v12];
  }
  else
  {
    *(_WORD *)v2 = *a2;
    result = a1[1];
    a1[1] = result + 2;
  }
  return result;
}

// --- End Function: sub_140309F90 (0x140309F90) ---

// --- Function: sub_14030A110 (0x14030A110) ---
char *__fastcall sub_14030A110(unsigned __int64 *a1, _BYTE *a2, __int64 a3)
{
  __int64 v6; // r8
  __int64 v7; // r15
  __int64 v8; // rdx
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  __int64 v12; // r12
  char *v13; // rax
  char *v14; // rdi
  double *v15; // rbp
  void *v16; // rcx
  unsigned __int64 v17; // r8
  const void *v18; // rdx
  size_t Size; // r8
  char *result; // rax

  v6 = 0xAAAAAAAAAAAAAAALL;
  v7 = (__int64)&a2[-*a1] / 0x18;
  v8 = (__int64)(a1[1] - *a1) / 0x18;
  if ( v8 == 0xAAAAAAAAAAAAAAALL )
    unknown_libname_10();
  v9 = v8 + 1;
  v10 = (__int64)(a1[2] - *a1) / 0x18;
  v11 = v10 >> 1;
  if ( v10 <= 0xAAAAAAAAAAAAAAALL - (v10 >> 1) )
  {
    v6 = v11 + v10;
    if ( v11 + v10 < v9 )
      v6 = v9;
  }
  v12 = 0x18 * v6;
  v13 = (char *)sub_140394E70((__int64)a1, 0x18 * v6);
  v14 = v13;
  *(_OWORD *)&v13[0x18 * v7] = *(_OWORD *)a3;
  v15 = (double *)&v13[0x18 * v7];
  v16 = v13;
  v15[2] = *(double *)(a3 + 0x10);
  v17 = a1[1];
  v18 = (const void *)*a1;
  if ( a2 == (_BYTE *)v17 )
  {
    Size = v17 - (_QWORD)v18;
  }
  else
  {
    memmove(v13, v18, a2 - (_BYTE *)v18);
    v16 = v15 + 3;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v16, v18, Size);
  if ( *a1 )
    sub_1403A6820((__int64)a1, *a1, 0x18 * ((__int64)(a1[2] - *a1) / 0x18));
  *a1 = (unsigned __int64)v14;
  a1[1] = (unsigned __int64)&v14[0x18 * v9];
  result = &v14[0x18 * v7];
  a1[2] = (unsigned __int64)&v14[v12];
  return result;
}

// --- End Function: sub_14030A110 (0x14030A110) ---

// --- Function: sub_14030A470 (0x14030A470) ---
_OWORD *__fastcall sub_14030A470(__int64 *a1, _BYTE *a2, _OWORD *a3)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rdi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  void *v15; // rcx
  _OWORD *v16; // r14
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  __int64 v20; // rcx
  _OWORD *result; // rax

  v4 = (unsigned __int64)&a2[-*a1];
  v5 = (a1[1] - *a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_24;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 0x10 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = v14;
  v16 = (_OWORD *)((char *)v14 + (v4 & 0xFFFFFFFFFFFFFFF0uLL));
  *v16 = *a3;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v15 = v16 + 1;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v15, v18, Size);
  v20 = *a1;
  if ( *a1 )
  {
    if ( ((a1[2] - v20) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v14;
  result = v16;
  a1[1] = (__int64)&v14[2 * v8];
  a1[2] = (__int64)&v14[allocSize / 8];
  return result;
}

// --- End Function: sub_14030A470 (0x14030A470) ---

// --- Function: ??$_Emplace_reallocate@W4Api@RtAudio@@@?$vector@W4Api@RtAudio@@V?$allocator@W4Api@RtAudio@@@std@@@std@@QEAAPEAW4Api@RtAudio@@QEAW423@$$QEAW423@@Z (0x14030A8E0) ---
RtAudio::Api *__fastcall std::vector<enum RtAudio::Api>::_Emplace_reallocate<enum RtAudio::Api>(
        std::vector<enum RtAudio::Api> *this,
        RtAudio::Api *const _Whereptr,
        RtAudio::Api *<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _DWORD *v15; // r14
  void *v16; // rcx
  RtAudio::Api *_Whereptr_2; // r8
  RtAudio::Api *_Whereptr_1; // rdx
  size_t Size; // r8
  __int64 v20; // rcx
  RtAudio::Api *result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 2;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 2;
  if ( v5 == 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 2;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x3FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 4 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = (_DWORD *)v14 + v3;
  *v15 = *(_DWORD *)<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (RtAudio::Api *)*((_QWORD *)this + 1);
  _Whereptr_1 = *(RtAudio::Api **)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = _Whereptr_2 - _Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, _Whereptr - _Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(_QWORD *)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - v20) & 0xFFFFFFFFFFFFFFFCuLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (RtAudio::Api *)((char *)v14 + 4 * v3);
  *((_QWORD *)this + 1) = (char *)v14 + 4 * v9;
  *((_QWORD *)this + 2) = (char *)v14 + allocSize;
  return result;
}

// --- End Function: ??$_Emplace_reallocate@W4Api@RtAudio@@@?$vector@W4Api@RtAudio@@V?$allocator@W4Api@RtAudio@@@std@@@std@@QEAAPEAW4Api@RtAudio@@QEAW423@$$QEAW423@@Z (0x14030A8E0) ---

// --- Function: sub_14030B7B0 (0x14030B7B0) ---
__int64 __fastcall sub_14030B7B0(unsigned int *a1)
{
  return *a1;
}

// --- End Function: sub_14030B7B0 (0x14030B7B0) ---

// --- Function: lookup_entry_in_hashtable (0x14030B8E0) ---
// Looks up an entry in a hash table based on a case-insensitive string key.
// Calculates a hash of the input string, uses SIMD instructions to efficiently
// search the corresponding bucket, and verifies the match using `_stricmp`. The
// hash table structure is described by `hash_table_ctx`, the key is `key_ptr`, and
// the result (pointers to the entry and key) is stored in `result_out`.
_OWORD *__fastcall lookup_entry_in_hashtable(_QWORD *a1, _OWORD *a2, const char **a3)
{
  const char *v3; // r11
  unsigned int n0x9E37; // r10d
  char i; // r9
  int v8; // eax
  bool v9; // cc
  int v10; // ecx
  __int64 v11; // rbp
  unsigned __int64 v12; // r12
  unsigned __int128 v13; // rax
  __int64 v14; // rsi
  __int64 v20; // rdi
  __int64 v21; // rdi
  _OWORD *result; // rax
  __int128 v25; // [rsp+20h] [rbp-68h]

  v3 = *a3;
  n0x9E37 = 0x9E37;
  for ( i = **a3; i; n0x9E37 = ((0x401 * (n0x9E37 + v10)) >> 6) ^ (0x401 * (n0x9E37 + v10)) )
  {
    v8 = i;
    ++v3;
    v9 = (unsigned __int8)(i - 0x41) <= 0x19u;
    i = *v3;
    v10 = v8 + 0x20;
    if ( !v9 )
      v10 = v8;
  }
  v11 = a1[3];
  v12 = 0;
  v13 = 0x8001 * ((9 * n0x9E37) ^ ((9 * n0x9E37) >> 0xB)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v14 = v11 & ((*((_QWORD *)&v13 + 1) + (_QWORD)v13) >> 7);
  _XMM7 = (BYTE8(v13) + (_BYTE)v13) & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v14 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
      break;
LABEL_9:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_1482B5BB0
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *(_QWORD *)&v25 = *a1 + a1[3];
      goto LABEL_14;
    }
    v12 += 0x10LL;
    v14 = v11 & (v12 + v14);
    if ( v12 > a1[3] )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v20, _EBX);
    v21 = v11 & (v14 + v20);
    if ( !_stricmp(*(const char **)(0x20 * v21 + a1[1]), *a3) )
      break;
    _EBX &= _EBX - 1;
    if ( !_EBX )
      goto LABEL_9;
  }
  *(_QWORD *)&v25 = v21 + *a1;
  *((_QWORD *)&v25 + 1) = 0x20 * v21 + a1[1];
LABEL_14:
  result = a2;
  *a2 = v25;
  return result;
}

// --- End Function: lookup_entry_in_hashtable (0x14030B8E0) ---

// --- Function: sub_14030BA70 (0x14030BA70) ---
float *__fastcall sub_14030BA70(float *a1, float *a2)
{
  if ( *a1 < *a2 )
    return a2;
  return a1;
}

// --- End Function: sub_14030BA70 (0x14030BA70) ---

// --- Function: sub_14030CB30 (0x14030CB30) ---
_DWORD *__fastcall sub_14030CB30(_DWORD *a1)
{
  *a1 = 0xFFFFFFFF;
  return a1;
}

// --- End Function: sub_14030CB30 (0x14030CB30) ---

// --- Function: unknown_libname_19 (0x140311130) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_19(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: unknown_libname_19 (0x140311130) ---

// --- Function: unknown_libname_20 (0x140311140) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_20(_WORD *a1, _WORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: unknown_libname_20 (0x140311140) ---

// --- Function: is_valid_handle_typeA (0x140311420) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B84E0(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_140322850(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x140311420) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x1403114B0) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  char v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = is_thread_privileged_or_bypass_mode()) != 0 )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || (unsigned __int8)sub_140395410(a1) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x1403114B0) ---

// --- Function: sub_140311590 (0x140311590) ---
__int64 __fastcall sub_140311590(unsigned __int16 *a1)
{
  return *a1;
}

// --- End Function: sub_140311590 (0x140311590) ---

// --- Function: sub_1403115A0 (0x1403115A0) ---
__int64 __fastcall sub_1403115A0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403115A0 (0x1403115A0) ---

// --- Function: sub_140322850 (0x140322850) ---
char __fastcall sub_140322850(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B84E0(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B43C0(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = sub_1403B43C0(v1);
      return sub_140395230(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (unsigned __int8)is_thread_privileged_or_bypass_mode() )
    return 1;
  payload_ptr_state2 = sub_1403B43C0(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_140322850 (0x140322850) ---

// --- Function: sub_140325FD0 (0x140325FD0) ---
__int64 __fastcall sub_140325FD0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 0x29);
}

// --- End Function: sub_140325FD0 (0x140325FD0) ---

// --- Function: map_flag_to_mask (0x140327450) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140327450) ---

// --- Function: sub_14032BBD0 (0x14032BBD0) ---
_QWORD *__fastcall sub_14032BBD0(_QWORD *a1, _QWORD *a2)
{
  *a2 = a1[3];
  a2[1] = a1[7];
  a2[2] = a1[0xB];
  return a2;
}

// --- End Function: sub_14032BBD0 (0x14032BBD0) ---

// --- Function: sub_14032CE50 (0x14032CE50) ---
float *__fastcall sub_14032CE50(unsigned __int64 *a1, float *a2)
{
  _XMM0 = a1[1];
  _XMM1 = a1[5];
  __asm { vcvtpd2ps xmm0, xmm0 }
  *a2 = *(float *)&_XMM0;
  _XMM0 = a1[9];
  __asm
  {
    vcvtpd2ps xmm0, xmm0
    vcvtpd2ps xmm1, xmm1
  }
  a2[2] = *(float *)&_XMM0;
  a2[1] = *(float *)&_XMM1;
  return a2;
}

// --- End Function: sub_14032CE50 (0x14032CE50) ---

// --- Function: sub_1403351C0 (0x1403351C0) ---
__int64 __fastcall sub_1403351C0(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v6; // rcx
  __int64 result; // rax

  v6 = *a1;
  if ( v6 )
    sub_1403A6820((__int64)a1, v6, 0x18 * ((__int64)(a1[2] - v6) / 0x18));
  *a1 = a2;
  a1[1] = a2 + 0x18 * a3;
  result = 3 * a4;
  a1[2] = a2 + 0x18 * a4;
  return result;
}

// --- End Function: sub_1403351C0 (0x1403351C0) ---

// --- Function: sub_1403355F0 (0x1403355F0) ---
__int64 __fastcall sub_1403355F0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 n4_1,
        unsigned __int8 a5)
{
  unsigned __int64 n4; // r8
  __int64 v7; // rsi
  __int64 v8; // r10
  unsigned __int64 v9; // rdx
  __int64 n8; // r11
  unsigned __int64 n8_1; // rcx
  __int64 (__fastcall *v12)(__int64, unsigned __int64 *, __int64, _QWORD); // rax
  __int64 v13; // rdi
  __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 n0x20_1; // rax
  unsigned __int64 n0x20; // rcx
  __int64 n0x10000; // rdx
  unsigned __int64 n0x10000_1; // rcx
  __int64 v22; // rax
  __int64 result; // rax

  n4 = 4;
  if ( n4_1 > 4 )
    n4 = n4_1;
  v7 = (n4 + 3) & ~(n4 - 1);
  v8 = a2 - v7;
  if ( !a2 )
    v8 = 0;
  v9 = *a3;
  if ( *a3 )
  {
    v9 = v7 + ((v9 + 3) & 0xFFFFFFFFFFFFFFFCuLL);
    *a3 = v9;
  }
  n8 = 8;
  n8_1 = 8;
  if ( n4 > 8 )
    n8_1 = n4;
  if ( v8 )
  {
    v12 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *, __int64, _QWORD))(v8 - 8);
    if ( n8_1 > 8 )
      n8 = n8_1;
    v13 = (n8 + 7) & ~(n8 - 1);
    v14 = v8 - v13;
    if ( v9 )
      *a3 = v9 + v13;
    v15 = v12(v14, a3, n8, a5);
    v9 = *a3;
    if ( *a3 )
    {
      v9 -= v13;
      *a3 = v9;
    }
    v8 = v15 + v13;
    if ( !v15 )
      v8 = 0;
  }
  else if ( v9 )
  {
    if ( n8_1 > 8 )
      n8 = n8_1;
    v16 = (n8 + 7) & ~(n8 - 1);
    allocSize = v9 + v16;
    *a3 = v9 + v16;
    if ( v9 + v16 )
    {
      if ( a5 )
      {
        n0x20_1 = allocSize + 0x10;
        n0x20 = 0x20;
        if ( n0x20_1 > 0x20 )
        {
          do
            n0x20 *= 2LL;
          while ( n0x20 < n0x20_1 );
          n0x10000 = 0x10000;
          if ( n0x20 > 0x10000 )
          {
            n0x10000_1 = n0x20 >> 3;
            if ( n0x10000_1 > 0x10000 )
              n0x10000 = n0x10000_1;
            n0x20 = ~(n0x10000 - 1) & (n0x10000 + n0x20_1 - 1);
          }
        }
        allocSize = n0x20 - 0x10;
        *a3 = allocSize;
      }
      v22 = allocWithProfilerInfo(allocSize, (struct _exception *)n8);
    }
    else
    {
      v22 = 0;
    }
    v9 = *a3;
    if ( *a3 )
    {
      v9 -= v16;
      *a3 = v9;
    }
    v8 = v16 + v22;
    if ( !v22 )
      v8 = 0;
    if ( v8 )
    {
      *(_QWORD *)(v8 - 8) = sub_140335790;
      v9 = *a3;
    }
  }
  if ( v9 )
    *a3 = v9 - v7;
  result = v7 + v8;
  if ( !v8 )
    return 0;
  return result;
}

// --- End Function: sub_1403355F0 (0x1403355F0) ---

// --- Function: j_cosf (0x140335840) ---
// attributes: thunk
float __cdecl j_cosf(float X)
{
  return cosf(X);
}

// --- End Function: j_cosf (0x140335840) ---

// --- Function: sub_140335A10 (0x140335A10) ---
__int64 __fastcall sub_140335A10(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( *a1
    && (v3 = sub_1403B84E0(v1 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v3 + 4), n4 != 4)
    && *(_WORD *)(v3 + 2) == (HIWORD(v1) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(a1)) )
  {
    return *a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_140335A10 (0x140335A10) ---

// --- Function: j_sinf (0x140335F90) ---
// attributes: thunk
float __cdecl j_sinf(float X)
{
  return sinf(X);
}

// --- End Function: j_sinf (0x140335F90) ---

// --- Function: sub_140335FE0 (0x140335FE0) ---
__int64 __fastcall sub_140335FE0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_140335FE0 (0x140335FE0) ---

// --- Function: sub_140338B20 (0x140338B20) ---
__int64 __fastcall sub_140338B20(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  int C; // ecx

  sub_1403E5F00();
  for ( psub_140338B20 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_1403E5BF0; a3; --a3 )
  {
    C = *a2++;
    a1 = dword_149C7B660[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_140338B20 (0x140338B20) ---

// --- Function: sub_140338BA0 (0x140338BA0) ---
__int64 sub_140338BA0()
{
  sub_1403E5CF0();
  return psub_140338BA0();
}

// --- End Function: sub_140338BA0 (0x140338BA0) ---

// --- Function: sub_140338BC0 (0x140338BC0) ---
__int64 sub_140338BC0()
{
  sub_1403E5CF0();
  return psub_140338BC0();
}

// --- End Function: sub_140338BC0 (0x140338BC0) ---

// --- Function: unknown_libname_23 (0x140339F20) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_23(_QWORD *a1, _QWORD *a2)
{
  return *a1 != *a2;
}

// --- End Function: unknown_libname_23 (0x140339F20) ---

// --- Function: sub_14033A390 (0x14033A390) ---
double *__fastcall sub_14033A390(double *a1, double *a2, double *a3)
{
  double v3; // xmm4_8
  double *result; // rax
  double v5; // xmm9_8
  double v6; // xmm11_8
  double v7; // xmm12_8
  double v8; // xmm13_8
  double v9; // xmm8_8
  double v10; // xmm6_8
  double v11; // xmm4_8
  double v12; // xmm3_8
  double v13; // kr00_8
  double v14; // xmm2_8
  double v15; // xmm1_8
  double v16; // xmm2_8

  v3 = a2[3];
  result = a1;
  v5 = a2[2];
  v6 = a2[1];
  v7 = a3[1];
  v8 = a3[2];
  v9 = v8 * v6 - v7 * v5 + *a3 * v3;
  v10 = *a3 * v5 - *a2 * v8 + v3 * v7;
  v11 = *a2 * v7 - *a3 * v6 + v3 * v8;
  v12 = *a2 * v10 - v6 * v9;
  v13 = v5 * v9 - *a2 * v11;
  v14 = v13 + a2[5];
  *a1 = v6 * v11 - v5 * v10 + a2[4] + *a3 + v6 * v11 - v5 * v10;
  v15 = v14 + v7 + v13;
  v16 = v12 + a2[6];
  a1[1] = v15;
  a1[2] = v16 + v8 + v12;
  return result;
}

// --- End Function: sub_14033A390 (0x14033A390) ---

// --- Function: sub_14033D3F0 (0x14033D3F0) ---
_QWORD *__fastcall sub_14033D3F0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_14;
  if ( n0xFFFF_14 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                          qword_149C8DFC8,
                          &v9,
                          "IItemPortContainer");
    n0xFFFF_14 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033D3F0 (0x14033D3F0) ---

// --- Function: sub_140347770 (0x140347770) ---
char *__fastcall sub_140347770(const void **a1, _BYTE *a2, _WORD *a3)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  char *v12; // rsi
  char *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  size_t Size; // r8

  v4 = (a2 - (_BYTE *)*a1) >> 1;
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  v6 = ((_BYTE *)a1[1] - (_BYTE *)*a1) >> 1;
  if ( v6 == 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 1;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x7FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    v5 = v11 + v9;
    if ( v11 + v9 < v10 )
      v5 = v6 + 1;
  }
  v12 = (char *)std::allocator<wchar_t>::allocate((__int64)a1, v5);
  *(_WORD *)&v12[2 * v4] = *a3;
  v13 = v12;
  v14 = a1[1];
  v15 = *a1;
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = &v12[2 * v4 + 2];
    Size = (_BYTE *)a1[1] - a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  sub_1403E2D40(a1, v12, v10, v5);
  return &v12[2 * v4];
}

// --- End Function: sub_140347770 (0x140347770) ---

// --- Function: sub_1403484B0 (0x1403484B0) ---
unsigned __int64 __fastcall sub_1403484B0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbx
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r15
  __int64 v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // r13
  __int64 v15; // rbp
  __int64 v16; // rbx
  unsigned __int64 i; // rdi
  __int64 v18; // rbx
  __int64 j; // rdi
  __int64 v20; // r8
  unsigned __int64 result; // rax

  v6 = (a2 - *a1) / 0x90;
  v7 = (a1[1] - *a1) / 0x90;
  if ( v7 == 0x1C71C71C71C71C7LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x90;
  if ( v9 > 0x1C71C71C71C71C7LL - (v9 >> 1) )
    goto LABEL_28;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x1C71C71C71C71C7LL )
    goto LABEL_28;
  v11 = 0x90 * v10;
  if ( 0x90 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = sub_1402A65A0(0x90 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_28:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_26;
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_13:
  v14 = v13 + 0x90 * v6;
  sub_14036F3C0(v14, a3);
  v15 = a1[1];
  v16 = *a1;
  if ( a2 == v15 )
  {
    for ( i = v13; v16 != v15; v16 += 0x90 )
    {
      sub_14036F3C0(i, v16);
      i += 0x90LL;
    }
  }
  else
  {
    sub_1403529F0(*a1, a2, v13, a1);
    sub_1403529F0(a2, a1[1], v14 + 0x90, a1);
  }
  v18 = *a1;
  if ( *a1 )
  {
    for ( j = a1[1]; v18 != j; v18 += 0x90 )
      sub_140378880(v18);
    v20 = *a1;
    if ( (unsigned __int64)(0x90 * ((a1[2] - *a1) / 0x90)) < 0x1000 )
      goto LABEL_24;
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
LABEL_24:
      sub_1402A6590(v20);
      goto LABEL_25;
    }
LABEL_26:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  *a1 = v13;
  result = v14;
  a1[1] = v13 + 0x90 * v8;
  a1[2] = v11 + v13;
  return result;
}

// --- End Function: sub_1403484B0 (0x1403484B0) ---

// --- Function: sub_14034AD90 (0x14034AD90) ---
__int64 __fastcall sub_14034AD90(_QWORD *a1, const char **a2)
{
  const char *v2; // rdi
  _QWORD *v3; // rbx
  unsigned int v6; // esi
  unsigned __int8 C; // al
  __int64 v8; // rax
  __int64 v9; // r15
  __int64 v10; // rdi
  __int64 v11; // rsi
  _QWORD *v12; // rdx
  _QWORD *v13; // rax
  __int64 v14; // rax
  __int64 v15; // rdx

  v2 = *a2;
  v3 = 0;
  v6 = 0;
  C = **a2;
  if ( C )
  {
    do
    {
      v6 = tolower(C) + 5 * v6;
      C = *++v2;
    }
    while ( *v2 );
  }
  v8 = a1[3];
  v9 = v6;
  v10 = *(_QWORD *)(v8 + 0x10 * (v6 & a1[6]) + 8);
  if ( v10 != a1[1] )
  {
    v11 = *(_QWORD *)(v8 + 0x10 * (v6 & a1[6]));
    if ( !_stricmp(*a2, *(const char **)(v10 + 0x10)) )
    {
LABEL_7:
      v3 = (_QWORD *)v10;
    }
    else
    {
      while ( v10 != v11 )
      {
        v10 = *(_QWORD *)(v10 + 8);
        if ( !_stricmp(*a2, *(const char **)(v10 + 0x10)) )
          goto LABEL_7;
      }
    }
  }
  if ( !v3 )
    return 0;
  v12 = (_QWORD *)(a1[3] + 0x10 * (v9 & a1[6]));
  v13 = (_QWORD *)*v12;
  if ( (_QWORD *)v12[1] == v3 )
  {
    if ( v13 == v3 )
    {
      v14 = a1[1];
      *v12 = v14;
    }
    else
    {
      v14 = v3[1];
    }
    v12[1] = v14;
  }
  else if ( v13 == v3 )
  {
    *v12 = *v3;
  }
  v15 = *v3;
  --a1[2];
  *(_QWORD *)v3[1] = v15;
  *(_QWORD *)(v15 + 8) = v3[1];
  sub_1402A6590((__int64)v3);
  return 1;
}

// --- End Function: sub_14034AD90 (0x14034AD90) ---

// --- Function: sub_14034C540 (0x14034C540) ---
void __fastcall sub_14034C540(__int64 a1, _BYTE *a2, const void *a3, unsigned __int64 a4)
{
  _BYTE *v4; // rbp
  __int64 v6; // rdx
  _BYTE *v8; // r12
  __int64 v11; // rcx
  unsigned __int64 _Newcapacity_1; // r8
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  unsigned __int64 _Newcapacity; // r14
  unsigned __int64 allocSize; // rcx
  __int64 v17; // rax
  char *_Newvec; // rdi
  size_t Size_1; // r8
  const void *v20; // rdx
  char *_Newvec_1; // rcx
  size_t Size; // r12
  unsigned __int64 v23; // r14
  __int64 v24; // [rsp+78h] [rbp+10h]
  unsigned __int64 _Newsize; // [rsp+88h] [rbp+20h]

  if ( !a4 )
    return;
  v4 = *(_BYTE **)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 0x10);
  v8 = *(_BYTE **)a1;
  if ( a4 <= (v6 - (__int64)v4) >> 3 )
  {
    Size = 8 * a4;
    v23 = (v4 - a2) >> 3;
    if ( a4 >= v23 )
    {
      memmove(&a2[Size], a2, v4 - a2);
      *(_QWORD *)(a1 + 8) = &a2[8 * v23 + Size];
    }
    else
    {
      memmove(v4, &v4[-Size], 8 * a4);
      *(_QWORD *)(a1 + 8) = &v4[Size];
      memmove(&a2[Size], a2, &v4[-Size] - a2);
    }
    memmove(a2, a3, Size);
    return;
  }
  v11 = (v4 - v8) >> 3;
  if ( a4 > 0x1FFFFFFFFFFFFFFFLL - v11 )
    unknown_libname_10();
  _Newcapacity_1 = v11 + a4;
  v13 = (v6 - (__int64)v8) >> 3;
  _Newsize = v11 + a4;
  v14 = v13 >> 1;
  if ( v13 > 0x1FFFFFFFFFFFFFFFLL - (v13 >> 1) )
    goto LABEL_26;
  _Newcapacity = _Newcapacity_1;
  if ( v14 + v13 >= _Newcapacity_1 )
    _Newcapacity = v14 + v13;
  if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_26;
  allocSize = 8 * _Newcapacity;
  if ( 8 * _Newcapacity >= 0x1000 )
  {
    if ( allocSize + 0x27 >= allocSize )
    {
      v17 = sub_1402A65A0(allocSize + 0x27);
      if ( !v17 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (char *)((v17 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      *((_QWORD *)_Newvec + 0xFFFFFFFF) = v17;
      goto LABEL_16;
    }
LABEL_26:
    sub_1402E3880();
  }
  if ( allocSize )
    _Newvec = (char *)sub_1402A65A0(allocSize);
  else
    _Newvec = 0;
LABEL_16:
  v24 = (a2 - v8) >> 3;
  memmove(&_Newvec[8 * v24], a3, 8 * a4);
  if ( a4 == 1 && a2 == v4 )
  {
    Size_1 = v4 - v8;
    v20 = v8;
    _Newvec_1 = _Newvec;
  }
  else
  {
    memmove(_Newvec, v8, a2 - v8);
    v20 = a2;
    Size_1 = v4 - a2;
    _Newvec_1 = &_Newvec[8 * a4 + 8 * v24];
  }
  memmove(_Newvec_1, v20, Size_1);
  std::vector<vraudio::AudioBuffer const *>::_Change_array(
    (std::vector<vraudio::AudioBuffer const *> *)a1,
    (const vraudio::AudioBuffer **const)_Newvec,
    _Newsize,
    _Newcapacity);
}

// --- End Function: sub_14034C540 (0x14034C540) ---

// --- Function: sub_14034F590 (0x14034F590) ---
int *__fastcall sub_14034F590(__int64 a1, unsigned __int64 _Count_1)
{
  char *v2; // rsi
  int *result; // rax
  unsigned __int64 _Count_3; // rbp
  unsigned __int64 _Count_2; // rcx
  unsigned __int64 _Count; // rsi
  unsigned __int64 v9; // rdx
  int *v10; // r14
  __int64 v11; // rcx
  size_t Size; // rbx

  v2 = *(char **)(a1 + 8);
  result = *(int **)a1;
  _Count_3 = (__int64)&v2[-*(_QWORD *)a1] >> 2;
  if ( _Count_1 >= _Count_3 )
  {
    if ( _Count_1 > _Count_3 )
    {
      _Count_2 = (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)result) >> 2;
      if ( _Count_1 <= _Count_2 )
      {
        Size = 4 * (_Count_1 - _Count_3);
        memset(v2, 0, Size);
        result = (int *)&v2[Size];
        *(_QWORD *)(a1 + 8) = &v2[Size];
      }
      else
      {
        _Count = 0x3FFFFFFFFFFFFFFFLL;
        if ( _Count_1 > 0x3FFFFFFFFFFFFFFFLL )
          unknown_libname_10();
        v9 = _Count_2 >> 1;
        if ( _Count_2 <= 0x3FFFFFFFFFFFFFFFLL - (_Count_2 >> 1) )
        {
          _Count = v9 + _Count_2;
          if ( v9 + _Count_2 < _Count_1 )
            _Count = _Count_1;
        }
        v10 = std::allocator<int>::allocate((std::allocator<int> *)a1, _Count);
        memset(&v10[_Count_3], 0, 4 * (_Count_1 - _Count_3));
        memmove(v10, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
        v11 = *(_QWORD *)a1;
        if ( *(_QWORD *)a1 )
        {
          if ( ((*(_QWORD *)(a1 + 0x10) - v11) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
          {
            if ( (unsigned __int64)(v11 - *(_QWORD *)(v11 - 8) - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
            v11 = *(_QWORD *)(v11 - 8);
          }
          sub_1402A6590(v11);
        }
        *(_QWORD *)a1 = v10;
        *(_QWORD *)(a1 + 8) = &v10[_Count_1];
        result = &v10[_Count];
        *(_QWORD *)(a1 + 0x10) = result;
      }
    }
  }
  else
  {
    result += _Count_1;
    *(_QWORD *)(a1 + 8) = result;
  }
  return result;
}

// --- End Function: sub_14034F590 (0x14034F590) ---

// --- Function: sub_14034FA50 (0x14034FA50) ---
__int64 __fastcall sub_14034FA50(__int64 *a1, unsigned __int64 _Count_1)
{
  _QWORD *v2; // rsi
  __int64 result; // rax
  unsigned __int64 _Count_2; // rdi
  _QWORD *v7; // rbx
  _QWORD *j; // rdi
  unsigned __int64 _Count_3; // rcx
  unsigned __int64 _Count; // rsi
  unsigned __int64 v11; // rdx
  std::array<int,2> *v12; // r10
  __int64 *v13; // rdi
  std::array<int,2> *v14; // rdx
  __int64 *i; // rcx
  __int64 v16; // rax

  v2 = (_QWORD *)a1[1];
  result = *a1;
  _Count_2 = ((__int64)v2 - *a1) >> 3;
  if ( _Count_1 >= _Count_2 )
  {
    if ( _Count_1 > _Count_2 )
    {
      _Count_3 = (a1[2] - result) >> 3;
      if ( _Count_1 <= _Count_3 )
      {
        result = sub_1403532D0(v2, _Count_1 - _Count_2, a1);
        a1[1] = result;
      }
      else
      {
        _Count = 0x1FFFFFFFFFFFFFFFLL;
        if ( _Count_1 > 0x1FFFFFFFFFFFFFFFLL )
          unknown_libname_10();
        v11 = _Count_3 >> 1;
        if ( _Count_3 <= 0x1FFFFFFFFFFFFFFFLL - (_Count_3 >> 1) )
        {
          _Count = v11 + _Count_3;
          if ( v11 + _Count_3 < _Count_1 )
            _Count = _Count_1;
        }
        v12 = std::allocator<std::array<int,2>>::allocate((std::allocator<std::array<int,2> > *)a1, _Count);
        if ( _Count_1 != _Count_2 )
          memset64((char *)v12 + 8 * _Count_2, (unsigned __int64)&qword_149C78E84 + 4, _Count_1 - _Count_2);
        v13 = (__int64 *)a1[1];
        v14 = v12;
        for ( i = (__int64 *)*a1; i != v13; *((_QWORD *)v14 + 0xFFFFFFFF) = v16 )
        {
          *(_QWORD *)v14 = (char *)&qword_149C78E84 + 4;
          v14 = (std::array<int,2> *)((char *)v14 + 8);
          v16 = *i;
          *i++ = (__int64)&qword_149C78E84 + 4;
        }
        return sub_1403E3C00(a1, v12, _Count_1, _Count);
      }
    }
  }
  else
  {
    v7 = (_QWORD *)(result + 8 * _Count_1);
    for ( j = v7; j != v2; ++j )
    {
      if ( *(int *)(*j - 4LL) > 0 )
        result = sub_147715880((const void *)(*j - 8LL));
    }
    a1[1] = (__int64)v7;
  }
  return result;
}

// --- End Function: sub_14034FA50 (0x14034FA50) ---

// --- Function: sub_1403532D0 (0x1403532D0) ---
char *__fastcall sub_1403532D0(char *buf, __int64 a2)
{
  unsigned __int64 v2; // rdx

  if ( !a2 )
    return buf;
  v2 = 8 * a2;
  memset64(buf, (unsigned __int64)&qword_149C78E84 + 4, v2 >> 3);
  return &buf[v2];
}

// --- End Function: sub_1403532D0 (0x1403532D0) ---

// --- Function: sub_140353FA0 (0x140353FA0) ---
signed __int64 __fastcall sub_140353FA0(volatile signed __int64 *a1, __int64 *a2)
{
  _QWORD *v4; // rbx
  __int64 v5; // rdx
  unsigned __int64 v6; // rax
  signed __int64 v7; // rsi

  if ( *a1 )
    return *a1;
  v4 = (_QWORD *)sub_1402A65A0(8u);
  if ( v4 )
  {
    *v4 = (char *)&qword_149C78E84 + 4;
    v5 = *a2;
    if ( *a2 )
    {
      v6 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v6;
      while ( *(_BYTE *)(v5 + v6) );
      sub_1403E25F0(v4, v5, (int)v6);
    }
    else
    {
      sub_1403E25F0(v4, 0, 0);
    }
  }
  else
  {
    v4 = 0;
  }
  v7 = _InterlockedCompareExchange64(a1, (signed __int64)v4, 0);
  if ( !v7 )
    return *a1;
  if ( v4 )
  {
    if ( *(int *)(*v4 - 4LL) > 0 )
      sub_147715880(*v4 - 8LL, (unsigned int)dword_149A5EC00);
    sub_1402A6590((__int64)v4);
  }
  return v7;
}

// --- End Function: sub_140353FA0 (0x140353FA0) ---

// --- Function: sub_140354080 (0x140354080) ---
signed __int64 __fastcall sub_140354080(volatile signed __int64 *a1)
{
  __int64 v2; // rax
  signed __int64 v3; // rdi
  _QWORD *v4; // rax
  signed __int64 v5; // rbp
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx
  __int64 v8; // rcx
  _QWORD **v9; // rcx
  _QWORD *v10; // rcx
  _QWORD *v11; // rbx

  if ( *a1 )
    return *a1;
  v2 = sub_1402A65A0(0x60u);
  v3 = v2;
  if ( v2 )
  {
    *(_QWORD *)v2 = &off_1482C4EE0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_QWORD *)(v2 + 0x10) = &p_Src;
    *(_DWORD *)(v2 + 0x18) = 0xFFFFFFFF;
    *(_QWORD *)(v2 + 0x1C) = 0;
    *(_QWORD *)(v2 + 0x28) = 0;
    *(_QWORD *)(v2 + 0x30) = 0;
    v4 = (_QWORD *)sub_1402A65A0(0x20u);
    *v4 = v4;
    v4[1] = v4;
    *(_QWORD *)(v3 + 0x28) = v4;
    *(_QWORD *)(v3 + 0x38) = 0;
    *(_QWORD *)(v3 + 0x40) = 0;
    *(_QWORD *)(v3 + 0x48) = 0;
    *(_QWORD *)(v3 + 0x50) = 7;
    *(_QWORD *)(v3 + 0x58) = 8;
    *(_DWORD *)(v3 + 0x20) = 0x3F800000;
    std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
      (unsigned __int64 **)(v3 + 0x38),
      0x10u,
      *(_QWORD *)(v3 + 0x28));
  }
  else
  {
    v3 = 0;
  }
  v5 = _InterlockedCompareExchange64(a1, v3, 0);
  if ( !v5 )
    return *a1;
  if ( v3 )
  {
    *(_QWORD *)v3 = &off_1482C4EE0;
    v6 = *(_QWORD **)(v3 + 0x28);
    v7 = (_QWORD *)*v6;
    if ( (_QWORD *)*v6 != v6 )
    {
      do
      {
        sub_147715880((const void *)v7[3]);
        v7 = (_QWORD *)*v7;
      }
      while ( v7 != *(_QWORD **)(v3 + 0x28) );
    }
    v8 = *(_QWORD *)(v3 + 0x38);
    if ( v8 )
    {
      if ( ((*(_QWORD *)(v3 + 0x48) - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v8 - *(_QWORD *)(v8 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v8 = *(_QWORD *)(v8 - 8);
      }
      sub_1402A6590(v8);
      *(_QWORD *)(v3 + 0x38) = 0;
      *(_QWORD *)(v3 + 0x40) = 0;
      *(_QWORD *)(v3 + 0x48) = 0;
    }
    v9 = *(_QWORD ***)(v3 + 0x28);
    *v9[1] = 0;
    v10 = *v9;
    if ( v10 )
    {
      do
      {
        v11 = (_QWORD *)*v10;
        sub_1402A6590((__int64)v10);
        v10 = v11;
      }
      while ( v11 );
    }
    sub_1402A6590(*(_QWORD *)(v3 + 0x28));
    *(_QWORD *)v3 = &off_1482C4EA0;
    sub_1402A6590(v3);
  }
  return v5;
}

// --- End Function: sub_140354080 (0x140354080) ---

// --- Function: sub_140354250 (0x140354250) ---
char __fastcall sub_140354250(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9)
{
  __int64 v10; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-18h]
  __int64 n0xB0; // [rsp+90h] [rbp-10h]
  __int64 n0xA8; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  LODWORD(v10) = a6;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 1u, a5, v10, a7, a8);
}

// --- End Function: sub_140354250 (0x140354250) ---

// --- Function: sub_140357350 (0x140357350) ---
__int64 __fastcall sub_140357350(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 n2; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF930;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF4D0;
  *(_QWORD *)(a1 + 0x30) = sub_1403EBBC0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x78) = "Count";
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EF3A0;
  *(_QWORD *)(a1 + 0x90) = sub_1403EF3A0;
  *(_QWORD *)(a1 + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9240;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F40;
  n2 = 2;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x10;
  *(_QWORD *)(a1 + 0xD8) = 0x15;
  return n2;
}

// --- End Function: sub_140357350 (0x140357350) ---

// --- Function: sub_14035C9A0 (0x14035C9A0) ---
float *__fastcall sub_14035C9A0(float *a1, float *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

// --- End Function: sub_14035C9A0 (0x14035C9A0) ---

// --- Function: sub_14035CDA0 (0x14035CDA0) ---
unsigned __int64 __fastcall sub_14035CDA0(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        int *a4,
        unsigned __int64 n4,
        unsigned __int8 a6)
{
  __int64 v6; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rax
  _QWORD *v12; // rdx
  _QWORD *v13; // rdx
  unsigned __int64 n4_1; // rdx
  __int64 n8; // r8
  __int64 v16; // rdi
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v19; // [rsp+48h] [rbp+10h] BYREF

  v6 = *a4;
  if ( (_DWORD)v6 )
  {
    v19 = 8 * v6;
    v10 = sub_1403355F0(a1, 0, &v19, n4, a6);
    v11 = v19 >> 3;
    *a4 = v19 >> 3;
  }
  else
  {
    v10 = 0;
    LODWORD(v11) = 0;
  }
  if ( a2 )
  {
    if ( v10 )
    {
      if ( a3 < (int)v11 )
        LODWORD(v11) = a3;
      if ( a2 != v10 )
      {
        v11 = (int)v11;
        if ( a2 > v10 || a2 + 8LL * (int)v11 <= v10 )
        {
          if ( (_DWORD)v11 )
          {
            v13 = (_QWORD *)v10;
            do
            {
              *v13 = *(_QWORD *)((char *)v13 + a2 - v10);
              ++v13;
              --v11;
            }
            while ( v11 );
          }
        }
        else if ( (_DWORD)v11 )
        {
          v12 = (_QWORD *)(v10 + 8 * ((int)v11 - 1LL));
          do
          {
            *v12 = *(_QWORD *)((char *)v12 + a2 - v10);
            v12 += 0xFFFFFFFF;
            --v11;
          }
          while ( v11 );
        }
      }
    }
    n4_1 = 4;
    v19 = 0;
    n8 = 8;
    if ( n4 > 4 )
      n4_1 = n4;
    v16 = a2 - ((n4_1 + 3) & ~(n4_1 - 1));
    n8_1 = 8;
    if ( n4_1 > 8 )
      n8_1 = n4_1;
    if ( v16 )
    {
      if ( n8_1 > 8 )
        n8 = n8_1;
      (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64, _QWORD))(v16 - 8))(
        v16 - ((n8 + 7) & ~(n8 - 1)),
        &v19,
        n8,
        0);
    }
  }
  return v10;
}

// --- End Function: sub_14035CDA0 (0x14035CDA0) ---

// --- Function: sub_14035D730 (0x14035D730) ---
__int64 __fastcall sub_14035D730(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 0x2D;
    v6 = 1;
    a4 = -a4 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = 0xFFFFFFFF;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
      return 0xFFFFFFFFLL;
    ++v6;
    v10 = a4 % 0xA;
    a4 /= 0xA;
    *(_BYTE *)(v8 + v4) = v10 + 0x30;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_14035D730 (0x14035D730) ---

// --- Function: sub_14035DAD0 (0x14035DAD0) ---
_QWORD *__fastcall sub_14035DAD0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  void (__fastcall *v4)(__int64, _QWORD *, _QWORD *); // rax
  void (__fastcall *n2)(__int64, _QWORD *); // rax

  v2 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = (void (__fastcall *)(__int64, _QWORD *, _QWORD *))a2[1];
  if ( v4 == (void (__fastcall *)(__int64, _QWORD *, _QWORD *))1 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
    n2 = (void (__fastcall *)(__int64, _QWORD *))a2[1];
    if ( (unsigned __int64)n2 >= 2 )
      goto LABEL_7;
    goto LABEL_8;
  }
  if ( v4 )
  {
    v4(1, a1, a2);
    n2 = (void (__fastcall *)(__int64, _QWORD *))v2[1];
    if ( (unsigned __int64)n2 >= 2 )
    {
      a2 = v2;
LABEL_7:
      n2(2, a2);
      v2[1] = 0;
    }
LABEL_8:
    *v2 = 0;
  }
  return a1;
}

// --- End Function: sub_14035DAD0 (0x14035DAD0) ---

// --- Function: sub_14035DC00 (0x14035DC00) ---
__int64 *__fastcall sub_14035DC00(__int64 *a1, __int64 a2, char a3)
{
  int v6; // esi

  *a1 = a2;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a2 + 0x10) == v6 )
  {
    ++*(_DWORD *)(a2 + 0x14);
  }
  else
  {
    sub_1402CF990(a2, (__int64)&p_Src, a3);
    *(_DWORD *)(a2 + 0x10) = v6;
  }
  return a1;
}

// --- End Function: sub_14035DC00 (0x14035DC00) ---

// --- Function: sub_14035DCB0 (0x14035DCB0) ---
__int64 __fastcall sub_14035DCB0(__int64 a1, const void **a2)
{
  size_t Size; // rdi

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)(a1 + 8) = 0x1FF;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
  {
    sub_1402A63B0((__int64 *)a1, *((int *)*a2 + 0xFFFFFFFE));
    memcpy(*(void **)(a1 + 0x10), *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035DCB0 (0x14035DCB0) ---

// --- Function: sub_14035DDD0 (0x14035DDD0) ---
_QWORD *__fastcall sub_14035DDD0(_QWORD *a1, _QWORD *a2)
{
  *a1 = (char *)&qword_149C78E84 + 4;
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_14035DDD0 (0x14035DDD0) ---

// --- Function: sub_14035DDF0 (0x14035DDF0) ---
_QWORD *__fastcall sub_14035DDF0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149C78E84 + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149C78E84 + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035DDF0 (0x14035DDF0) ---

// --- Function: sub_14035DE10 (0x14035DE10) ---
void **__fastcall sub_14035DE10(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149C78E84 + 4;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035DE10 (0x14035DE10) ---

// --- Function: CreateStringObjectFromString (0x14035DF70) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149C78E84 + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035DF70) ---

// --- Function: sub_14035E010 (0x14035E010) ---
void **__fastcall sub_14035E010(void **a1, void *a2, size_t Size)
{
  _DWORD *v6; // rax

  *a1 = (char *)&qword_149C78E84 + 4;
  if ( Size )
  {
    v6 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v6 + 2;
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035E010 (0x14035E010) ---

// --- Function: sub_14035E090 (0x14035E090) ---
void __fastcall sub_14035E090(_QWORD *a1)
{
  *a1 = (char *)&qword_149C78E84 + 4;
}

// --- End Function: sub_14035E090 (0x14035E090) ---

// --- Function: sub_14035E0A0 (0x14035E0A0) ---
_QWORD *__fastcall sub_14035E0A0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = &unk_149C7C038;
  v2 = *a2;
  *a2 = (__int64)&unk_149C7C038;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035E0A0 (0x14035E0A0) ---

// --- Function: sub_14035E0C0 (0x14035E0C0) ---
void **__fastcall sub_14035E0C0(void **a1, const void **a2)
{
  __int64 v4; // rdi

  *a1 = &unk_149C7C038;
  v4 = *((int *)*a2 + 0xFFFFFFFE);
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
  {
    sub_1403E24E0(a1);
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, 2 * v4);
  }
  return a1;
}

// --- End Function: sub_14035E0C0 (0x14035E0C0) ---

// --- Function: sub_14035E2A0 (0x14035E2A0) ---
_QWORD *__fastcall sub_14035E2A0(_QWORD *a1)
{
  *a1 = &unk_149C7C038;
  return a1;
}

// --- End Function: sub_14035E2A0 (0x14035E2A0) ---

// --- Function: sub_14035E580 (0x14035E580) ---
_QWORD *__fastcall sub_14035E580(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  *a1 = a3;
  result = a1;
  a1[1] = a2;
  return result;
}

// --- End Function: sub_14035E580 (0x14035E580) ---

// --- Function: sub_14035EBC0 (0x14035EBC0) ---
__int64 __fastcall sub_14035EBC0(__int64 a1, __int64 a2, double a3)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(double *)(a1 + 0x10) = *(double *)(a2 + 0x10);
  *(double *)(a1 + 0x18) = a3;
  return a1;
}

// --- End Function: sub_14035EBC0 (0x14035EBC0) ---

// --- Function: sub_14035EC10 (0x14035EC10) ---
_OWORD *__fastcall sub_14035EC10(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_14035EC10 (0x14035EC10) ---

// --- Function: sub_14035F320 (0x14035F320) ---
_QWORD *__fastcall sub_14035F320(_QWORD *a1, __int64 a2, __int64 a3)
{
  _BYTE *v5; // rdi
  unsigned __int64 v6; // rax
  size_t Size; // rbx
  void *v9; // rax
  _BYTE v11[8]; // [rsp+20h] [rbp-248h] BYREF
  __int64 v12; // [rsp+28h] [rbp-240h]
  char *v13; // [rsp+30h] [rbp-238h]
  char v14; // [rsp+38h] [rbp-230h] BYREF

  v5 = *(_BYTE **)(sub_1405B5980(a2, v11) + 0x10);
  a1[1] = v5;
  *a1 = a3;
  a1[2] = 0;
  sub_1402A6590(0);
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  while ( v5[++v6] != 0 )
    ;
  Size = v6 + 1;
  v9 = (void *)sub_1402A65A0(v6 + 1);
  a1[2] = v9;
  a1[1] = v9;
  if ( Size )
  {
    if ( v9 )
    {
      if ( v5 )
      {
        memcpy(v9, v5, Size);
        goto LABEL_9;
      }
      memset(v9, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_9:
  if ( v13 != &v14 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - v12;
    sub_147715880(v13);
  }
  return a1;
}

// --- End Function: sub_14035F320 (0x14035F320) ---

// --- Function: sub_140361800 (0x140361800) ---
_QWORD *__fastcall sub_140361800(_QWORD *a1, _BYTE *a2)
{
  __int64 v4; // rbx
  int v5; // esi
  signed __int32 v6; // edi
  signed __int64 v7; // rax
  signed __int64 v8; // r12
  _DWORD *v9; // r15
  unsigned __int64 v10; // rsi
  int v11; // eax
  _BYTE v13[16]; // [rsp+20h] [rbp-38h] BYREF
  _DWORD *v14; // [rsp+60h] [rbp+8h] BYREF
  _BYTE *v15; // [rsp+68h] [rbp+10h] BYREF

  *a1 = 0;
  if ( a2 && *a2 )
  {
    v4 = sub_140354080(&qword_149C7BA98) + 8;
    v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v4 + 0x10) == v5 )
    {
      ++*(_DWORD *)(v4 + 0x14);
    }
    else
    {
      v6 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
      if ( v6 )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
          sub_1403C6EF0(v4, v6, "CCryName::CCryName");
        else
          sub_1403C7160(v4, v6, "CCryName::CCryName");
      }
      else
      {
        *(_QWORD *)(v4 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      }
      *(_DWORD *)(v4 + 0x10) = v5;
    }
    v7 = sub_140354080(&qword_149C7BA98);
    v15 = a2;
    v14 = 0;
    v8 = v7 + 0x20;
    v9 = (_DWORD *)sub_14035BF70(v7 + 0x20, &v15, &v14);
    if ( !v9 )
    {
      v10 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v10;
      while ( a2[v10] );
      v9 = (_DWORD *)allocWithProfilerInfo(v10 + 0xD, 0);
      v9[2] = v10 + 0xD;
      *v9 = 0;
      v9[1] = v10;
      memcpy(v9 + 3, a2, v10 + 1);
      v14 = v9 + 3;
      *(_QWORD *)(*(_QWORD *)sub_1403515A0(v8, v13, &v14) + 0x18LL) = v9;
    }
    *a1 = v9 + 3;
    v11 = *(_DWORD *)(v4 + 0x14);
    if ( v11 )
    {
      *(_DWORD *)(v4 + 0x14) = v11 - 1;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      sub_1402DD7D0(v4);
    }
  }
  if ( *a1 )
    sub_1403E62B0(a1);
  return a1;
}

// --- End Function: sub_140361800 (0x140361800) ---

// --- Function: sub_140361AC0 (0x140361AC0) ---
__int64 __fastcall sub_140361AC0(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 result; // rax
  _QWORD v11[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v12[4]; // [rsp+40h] [rbp-28h] BYREF

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = &p_Src;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_OWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  v12[0] = v11;
  *(_QWORD *)(a1 + 0x40) = &p_Src;
  v12[1] = v12;
  *(_DWORD *)(a1 + 0x48) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x4C) = 0;
  v11[0] = 0x200000;
  v11[1] = 0;
  v8 = sub_140572D10((__int64)v12);
  *(__m256i *)a1 = *(__m256i *)sub_140572D50((__int64)v12, ~(v8 - 1) & (v8 + a2 - 1), v8, a3, 0, 0);
  v9 = *(unsigned int *)(a1 + 0x14);
  if ( a4 == 0xFFFFFFFFFFFFFFFFuLL )
    *(_QWORD *)(a1 + 0x30) = v9;
  else
    *(_QWORD *)(a1 + 0x30) = ~(v9 - 1) & (v9 + a4 - 1);
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140361AC0 (0x140361AC0) ---

// --- Function: sub_140361C90 (0x140361C90) ---
_QWORD *__fastcall sub_140361C90(_QWORD *a1, unsigned __int8 **a2)
{
  __int64 *v4; // rax
  _QWORD *v5; // rax
  __int64 v6; // rdx
  unsigned __int8 *v7; // r8
  __int64 v8; // r9
  int v9; // eax
  int v10; // ecx
  __int64 v11; // rax

  *a1 = &unk_149C7C038;
  v4 = (__int64 *)sub_1403B2140();
  v5 = (_QWORD *)sub_140353FA0(&qword_149C7BDF0, v4);
  v7 = *a2;
  v8 = *v5 - (_QWORD)*a2;
  do
  {
    v9 = v7[v8];
    v10 = *v7 - v9;
    if ( v10 )
      break;
    ++v7;
  }
  while ( v9 );
  if ( v10 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)qword_149C8DFE0 + 0x4E0LL))(
            qword_149C8DFE0,
            v6,
            v7);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD *, _QWORD))(*(_QWORD *)v11 + 0xA8LL))(v11, *a2, a1, 0);
  }
  return a1;
}

// --- End Function: sub_140361C90 (0x140361C90) ---

// --- Function: sub_140361D70 (0x140361D70) ---
_QWORD *__fastcall sub_140361D70(_QWORD *a1, unsigned __int8 **a2)
{
  _QWORD *v4; // rax
  __int64 v5; // rdx
  unsigned __int8 *v6; // r8
  __int64 v7; // r10
  int v8; // eax
  int v9; // r9d
  __int64 v10; // rax

  *a1 = &unk_149C7C038;
  v4 = (_QWORD *)sub_1403B2140();
  v6 = *a2;
  v7 = *v4 - (_QWORD)*a2;
  do
  {
    v8 = v6[v7];
    v9 = *v6 - v8;
    if ( v9 )
      break;
    ++v6;
  }
  while ( v8 );
  if ( v9 )
  {
    v10 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)qword_149C8DFE0 + 0x4E0LL))(
            qword_149C8DFE0,
            v5,
            v6);
    (*(void (__fastcall **)(__int64, unsigned __int8 *, _QWORD *, _QWORD))(*(_QWORD *)v10 + 0xA8LL))(v10, *a2, a1, 0);
  }
  return a1;
}

// --- End Function: sub_140361D70 (0x140361D70) ---

// --- Function: sub_1403624C0 (0x1403624C0) ---
_QWORD *__fastcall sub_1403624C0(_QWORD *a1, __int64 a2)
{
  a1[1] = a2;
  *a1 = off_1482C5768;
  return a1;
}

// --- End Function: sub_1403624C0 (0x1403624C0) ---

// --- Function: sub_140363600 (0x140363600) ---
__int64 __fastcall sub_140363600(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int64 n4_1; // rdi
  unsigned __int16 n4; // ax
  __int64 v7; // r12
  __int64 v8; // r13
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 v11; // r14
  __int64 v12; // rbp
  __int64 v13; // r14
  __int64 v14; // rbp

  *(_DWORD *)(a1 + 4) = 0xF0000000;
  v2 = a1 + 4;
  *(_DWORD *)a1 = 0xF0000000;
  n4_1 = 0;
  *(_DWORD *)(a1 + 8) = 0xF0000000;
  *(_DWORD *)(a1 + 0xC) = 0xF0000000;
  *(_DWORD *)(a1 + 0x10) = 0xF0000000;
  *(_DWORD *)(a1 + 0x14) = 0xF0000000;
  *(_DWORD *)(a1 + 0x18) = 0xF0000000;
  *(_DWORD *)(a1 + 0x1C) = 0xF0000000;
  *(_QWORD *)(a1 + 0x20) = 0;
  n4 = *(_WORD *)(a2 + 0x28);
  *(_DWORD *)(a1 + 0x28) = n4;
  if ( n4 > 4u )
    sub_1403950C0();
  if ( *(_WORD *)(a2 + 0x28) )
  {
    v7 = a2 - a1;
    v8 = 0xFFFFFFFFFFFFFFFCuLL - a1;
    do
    {
      if ( n4_1 >= 4 )
      {
        v11 = v2 + v8 + *(_QWORD *)(a2 + 0x20) - 0x20LL;
        v12 = v2 + v8 + *(_QWORD *)(a1 + 0x20) - 0x20LL;
        if ( v12 != v11 )
        {
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
            qword_149C8DF38,
            v2 + v8 + *(_QWORD *)(a1 + 0x20) - 0x20LL);
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xE8LL))(
            qword_149C8DF38,
            v12,
            v11);
        }
        v13 = v11 + 4;
        v14 = v12 + 4;
        if ( v14 == v13 )
          goto LABEL_15;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v14);
        v9 = v13;
        v10 = v14;
      }
      else
      {
        if ( v2 - 4 != v2 + v7 - 4 )
        {
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v2 - 4);
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xE8LL))(
            qword_149C8DF38,
            v2 - 4,
            v2 + v7 - 4);
        }
        if ( v2 == v7 + v2 )
          goto LABEL_15;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v2);
        v9 = v7 + v2;
        v10 = v2;
      }
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xE8LL))(
        qword_149C8DF38,
        v10,
        v9);
LABEL_15:
      ++n4_1;
      v2 += 8;
    }
    while ( n4_1 < *(unsigned __int16 *)(a2 + 0x28) );
  }
  return a1;
}

// --- End Function: sub_140363600 (0x140363600) ---

// --- Function: sub_140363FD0 (0x140363FD0) ---
__int64 __fastcall sub_140363FD0(__int64 a1, __int64 **a2)
{
  __int64 *v3; // rsi
  __int64 *i; // rbx
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  *(_DWORD *)a1 = 0xF0000000;
  *(_DWORD *)(a1 + 4) = 0xF0000000;
  *(_DWORD *)(a1 + 8) = 0xF0000000;
  *(_DWORD *)(a1 + 0xC) = 0xF0000000;
  *(_DWORD *)(a1 + 0x10) = 0xF0000000;
  *(_DWORD *)(a1 + 0x14) = 0xF0000000;
  *(_DWORD *)(a1 + 0x18) = 0xF0000000;
  *(_DWORD *)(a1 + 0x1C) = 0xF0000000;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x28) = 1;
  v3 = a2[1];
  for ( i = *a2; i != v3; ++i )
  {
    v6 = *i;
    if ( (_WORD)v6 != 0xFFFF )
      (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)qword_149C8DF38 + 0x70LL))(
        qword_149C8DF38,
        a1,
        &v6);
  }
  return a1;
}

// --- End Function: sub_140363FD0 (0x140363FD0) ---

// --- Function: sub_140364420 (0x140364420) ---
__int64 __fastcall sub_140364420(__int64 a1)
{
  *(_DWORD *)a1 = 0xF0000000;
  *(_DWORD *)(a1 + 4) = 0xF0000000;
  *(_DWORD *)(a1 + 8) = 0xF0000000;
  *(_DWORD *)(a1 + 0xC) = 0xF0000000;
  *(_DWORD *)(a1 + 0x10) = 0xF0000000;
  *(_DWORD *)(a1 + 0x14) = 0xF0000000;
  *(_DWORD *)(a1 + 0x18) = 0xF0000000;
  *(_DWORD *)(a1 + 0x1C) = 0xF0000000;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x28) = 0;
  return a1;
}

// --- End Function: sub_140364420 (0x140364420) ---

// --- Function: sub_1403651D0 (0x1403651D0) ---
_QWORD *__fastcall sub_1403651D0(_QWORD *a1)
{
  *a1 = 0;
  a1[2] = 0;
  return a1;
}

// --- End Function: sub_1403651D0 (0x1403651D0) ---

// --- Function: sub_1403651E0 (0x1403651E0) ---
__int64 __fastcall sub_1403651E0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a2 + 0x20);
  *(_DWORD *)(a1 + 0x28) = *(_DWORD *)(a2 + 0x28);
  *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = &off_1482C6B58;
  *(_OWORD *)(a1 + 0x40) = *(_OWORD *)(a2 + 0x40);
  *(double *)(a1 + 0x50) = *(double *)(a2 + 0x50);
  *(_DWORD *)(a1 + 0x58) = *(_DWORD *)(a2 + 0x58);
  *(_DWORD *)(a1 + 0x5C) = *(_DWORD *)(a2 + 0x5C);
  *(_DWORD *)(a1 + 0x60) = *(_DWORD *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x64) = *(_DWORD *)(a2 + 0x64);
  *(_DWORD *)(a1 + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x6C) = *(_DWORD *)(a2 + 0x6C);
  *(_DWORD *)(a1 + 0x70) = *(_DWORD *)(a2 + 0x70);
  *(_DWORD *)(a1 + 0x74) = *(_DWORD *)(a2 + 0x74);
  *(_DWORD *)(a1 + 0x78) = *(_DWORD *)(a2 + 0x78);
  *(_DWORD *)(a1 + 0x7C) = *(_DWORD *)(a2 + 0x7C);
  *(_BYTE *)(a1 + 0x80) = *(_BYTE *)(a2 + 0x80);
  *(_QWORD *)(a1 + 0x88) = *(_QWORD *)(a2 + 0x88);
  *(_OWORD *)(a1 + 0x90) = *(_OWORD *)(a2 + 0x90);
  *(double *)(a1 + 0xA0) = *(double *)(a2 + 0xA0);
  *(double *)(a1 + 0xA8) = *(double *)(a2 + 0xA8);
  *(_DWORD *)(a1 + 0xB0) = *(_DWORD *)(a2 + 0xB0);
  *(double *)(a1 + 0xB4) = *(double *)(a2 + 0xB4);
  *(_DWORD *)(a1 + 0xBC) = *(_DWORD *)(a2 + 0xBC);
  *(double *)(a1 + 0xC0) = *(double *)(a2 + 0xC0);
  *(_DWORD *)(a1 + 0xC8) = *(_DWORD *)(a2 + 0xC8);
  *(_DWORD *)(a1 + 0xD8) = *(_DWORD *)(a2 + 0xD8);
  *(_DWORD *)(a1 + 0xCC) = *(_DWORD *)(a2 + 0xCC);
  *(_DWORD *)(a1 + 0xD0) = *(_DWORD *)(a2 + 0xD0);
  *(_DWORD *)(a1 + 0xD4) = *(_DWORD *)(a2 + 0xD4);
  *(_DWORD *)(a1 + 0xDC) = *(_DWORD *)(a2 + 0xDC);
  *(_DWORD *)(a1 + 0xE0) = *(_DWORD *)(a2 + 0xE0);
  *(_BYTE *)(a1 + 0xE4) = *(_BYTE *)(a2 + 0xE4);
  *(_BYTE *)(a1 + 0xE5) = *(_BYTE *)(a2 + 0xE5);
  *(_BYTE *)(a1 + 0xE6) = *(_BYTE *)(a2 + 0xE6);
  *(_BYTE *)(a1 + 0xE7) = *(_BYTE *)(a2 + 0xE7);
  *(_BYTE *)(a1 + 0xE8) = *(_BYTE *)(a2 + 0xE8);
  *(_BYTE *)(a1 + 0xE9) = *(_BYTE *)(a2 + 0xE9);
  *(_BYTE *)(a1 + 0xEA) = *(_BYTE *)(a2 + 0xEA);
  *(_BYTE *)(a1 + 0xEB) = *(_BYTE *)(a2 + 0xEB);
  *(_BYTE *)(a1 + 0xEC) = *(_BYTE *)(a2 + 0xEC);
  *(_BYTE *)(a1 + 0xED) = *(_BYTE *)(a2 + 0xED);
  *(_QWORD *)(a1 + 0xF0) = *(_QWORD *)(a2 + 0xF0);
  *(_DWORD *)(a1 + 0xF8) = *(_DWORD *)(a2 + 0xF8);
  *(_OWORD *)(a1 + 0xFC) = *(_OWORD *)(a2 + 0xFC);
  *(_QWORD *)(a1 + 0x110) = &off_1482C6B58;
  *(_OWORD *)(a1 + 0x118) = *(_OWORD *)(a2 + 0x118);
  *(double *)(a1 + 0x128) = *(double *)(a2 + 0x128);
  *(_DWORD *)(a1 + 0x130) = *(_DWORD *)(a2 + 0x130);
  *(_DWORD *)(a1 + 0x134) = *(_DWORD *)(a2 + 0x134);
  *(_DWORD *)(a1 + 0x138) = *(_DWORD *)(a2 + 0x138);
  *(_BYTE *)(a1 + 0x13C) = *(_BYTE *)(a2 + 0x13C);
  *(_BYTE *)(a1 + 0x13D) = *(_BYTE *)(a2 + 0x13D);
  *(_DWORD *)(a1 + 0x140) = *(_DWORD *)(a2 + 0x140);
  *(_OWORD *)(a1 + 0x144) = *(_OWORD *)(a2 + 0x144);
  *(_WORD *)(a1 + 0x154) = *(_WORD *)(a2 + 0x154);
  *(_QWORD *)(a1 + 0x158) = *(_QWORD *)(a2 + 0x158);
  return a1;
}

// --- End Function: sub_1403651E0 (0x1403651E0) ---

// --- Function: sub_140365980 (0x140365980) ---
__int64 __fastcall sub_140365980(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *a2;
  result = a1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

// --- End Function: sub_140365980 (0x140365980) ---

// --- Function: sub_14036CF10 (0x14036CF10) ---
_DWORD *__fastcall sub_14036CF10(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // rax

  *a1 = a2;
  result = a1;
  a1[1] = a3;
  return result;
}

// --- End Function: sub_14036CF10 (0x14036CF10) ---

// --- Function: sub_14036DFF0 (0x14036DFF0) ---
__int64 __fastcall sub_14036DFF0(__int64 a1, __int64 a2)
{
  void (__fastcall ***v4)(_QWORD); // rcx

  v4 = *(void (__fastcall ****)(_QWORD))a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  if ( v4 )
    (**v4)(v4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  return a1;
}

// --- End Function: sub_14036DFF0 (0x14036DFF0) ---

// --- Function: sub_14036E030 (0x14036E030) ---
__int64 __fastcall sub_14036E030(__int64 a1, void (__fastcall ***a2)(_QWORD), float a3)
{
  __int64 result; // rax

  *(_QWORD *)a1 = a2;
  if ( a2 )
  {
    (**a2)(a2);
    result = a1;
    *(float *)(a1 + 8) = a3;
  }
  else
  {
    *(float *)(a1 + 8) = a3;
    return a1;
  }
  return result;
}

// --- End Function: sub_14036E030 (0x14036E030) ---

// --- Function: sub_14036F220 (0x14036F220) ---
__int64 __fastcall sub_14036F220(__int64 a1)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_DWORD *)a1 = 0x2D;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  return a1;
}

// --- End Function: sub_14036F220 (0x14036F220) ---

// --- Function: sub_14036F3C0 (0x14036F3C0) ---
__int64 __fastcall sub_14036F3C0(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  char v5; // al

  sub_14035DE10((void **)a1, (const void **)a2);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 0x10) = *(_OWORD *)(a2 + 0x10);
  *(double *)(a1 + 0x20) = *(double *)(a2 + 0x20);
  *(_QWORD *)(a1 + 0x40) = *(_QWORD *)(a2 + 0x40);
  *(_QWORD *)(a1 + 0x28) = *(_QWORD *)(a2 + 0x28);
  *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = *(_QWORD *)(a2 + 0x38);
  *(_OWORD *)(a1 + 0x48) = *(_OWORD *)(a2 + 0x48);
  *(double *)(a1 + 0x58) = *(double *)(a2 + 0x58);
  *(_QWORD *)(a1 + 0x60) = *(_QWORD *)(a2 + 0x60);
  *(_QWORD *)(a1 + 0x68) = *(_QWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x70) = *(_DWORD *)(a2 + 0x70);
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  v4 = *(_QWORD *)(a2 + 0x80);
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 8));
  *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(a2 + 0x78);
  *(_QWORD *)(a1 + 0x80) = *(_QWORD *)(a2 + 0x80);
  *(_BYTE *)(a1 + 0x8C) = 0;
  v5 = *(_BYTE *)(a2 + 0x8C);
  *(_BYTE *)(a1 + 0x8C) = v5;
  if ( v5 )
    *(_DWORD *)(a1 + 0x88) = *(_DWORD *)(a2 + 0x88);
  return a1;
}

// --- End Function: sub_14036F3C0 (0x14036F3C0) ---

// --- Function: sub_14036F660 (0x14036F660) ---
__int64 __fastcall sub_14036F660(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 0x1C) = 0x40004;
  *(_DWORD *)(a1 + 0x18) = 0x3F800000;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = 0x3F800000;
  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)a1 = 0xFFFF;
  *(_DWORD *)(a1 + 8) = 0x3F800000;
  *(_DWORD *)(a1 + 0xC) = 0x3F800000;
  *(_DWORD *)(a1 + 0x10) = 0x3E99999A;
  return result;
}

// --- End Function: sub_14036F660 (0x14036F660) ---

// --- Function: sub_14036F6D0 (0x14036F6D0) ---
_QWORD *__fastcall sub_14036F6D0(_QWORD *a1)
{
  a1[1] = 0;
  *a1 = 0;
  return a1;
}

// --- End Function: sub_14036F6D0 (0x14036F6D0) ---

// --- Function: sub_14036FB80 (0x14036FB80) ---
__int64 __fastcall sub_14036FB80(__int64 a1, int a2, float a3, char a4, char a5)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 8) = a5;
  result = a1;
  *(float *)a1 = a3;
  *(_DWORD *)(a1 + 4) = a2;
  *(_BYTE *)(a1 + 9) = a4;
  return result;
}

// --- End Function: sub_14036FB80 (0x14036FB80) ---

// --- Function: sub_140371070 (0x140371070) ---
__int64 __fastcall sub_140371070(__int64 a1)
{
  *(_DWORD *)(a1 + 0x14) = 0x3F800000;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)a1 = &off_1482C68F0;
  return a1;
}

// --- End Function: sub_140371070 (0x140371070) ---

// --- Function: sub_1403719C0 (0x1403719C0) ---
_BYTE *__fastcall sub_1403719C0(_BYTE *a1, __int64 a2)
{
  *a1 = 1;
  sub_1404D8EF0(a2);
  return a1;
}

// --- End Function: sub_1403719C0 (0x1403719C0) ---

// --- Function: sub_1403724E0 (0x1403724E0) ---
__int64 __fastcall sub_1403724E0(__int64 a1, __int16 a2, __int64 a3, char a4)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 2) &= 0xF0u;
  *(_DWORD *)(a1 + 0xC) = 0;
  *(_BYTE *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x14) = 0;
  *(_WORD *)a1 = 0;
  *(_QWORD *)(a1 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x160) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x158) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x150) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x278) = 0x3FF0000000000000LL;
  result = a1;
  *(_QWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1A8) = 0;
  *(_DWORD *)(a1 + 0x1B0) = 0;
  *(_QWORD *)(a1 + 0x1B4) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1BC) = 0;
  *(_DWORD *)(a1 + 0x1C4) = 0;
  *(_QWORD *)(a1 + 0x1C8) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1D0) = 0;
  *(_DWORD *)(a1 + 0x1D8) = 0;
  *(_DWORD *)(a1 + 0x1DC) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1E0) = 0;
  *(_QWORD *)(a1 + 0x260) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = 0;
  *(_QWORD *)(a1 + 0x280) = 0;
  *(_QWORD *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x290) = 0;
  *(_QWORD *)(a1 + 0x298) = 0;
  *(_QWORD *)(a1 + 0x2A0) = 0;
  *(_QWORD *)(a1 + 0x2A8) = 0;
  *(_QWORD *)(a1 + 0x2B8) = 0;
  *(_QWORD *)(a1 + 0x2C0) = 0;
  *(_QWORD *)(a1 + 0x2C8) = 0;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_QWORD *)(a1 + 0x1F0) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x200) = 0;
  *(_QWORD *)(a1 + 0x208) = a3;
  *(_BYTE *)(a1 + 0x210) = 0;
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0;
  *(_QWORD *)(a1 + 0x228) = 0;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_DWORD *)(a1 + 0x234) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x250) = 0;
  *(_WORD *)(a1 + 0x258) = a2;
  *(_BYTE *)(a1 + 0x25A) = a4;
  *(_DWORD *)(a1 + 0x25C) = 0;
  *(_QWORD *)(a1 + 0x2B0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x2D0) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2D4) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2D8) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2DC) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2E0) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2E4) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2E8) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2EC) = 0xF0000000;
  *(_QWORD *)(a1 + 0x2F0) = 0;
  *(_DWORD *)(a1 + 0x2F8) = 0;
  *(_QWORD *)(a1 + 0x300) = 0;
  *(_BYTE *)(a1 + 0x308) = 0;
  *(_QWORD *)(a1 + 0x30C) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x318) = 0;
  return result;
}

// --- End Function: sub_1403724E0 (0x1403724E0) ---

// --- Function: sub_140372710 (0x140372710) ---
__int64 sub_140372710(__int64 a1, __int16 a2, __int64 a3, char a4, char *Format, ...)
{
  _QWORD *v6; // rax
  __int64 result; // rax
  va_list va; // [rsp+78h] [rbp+30h] BYREF

  va_start(va, Format);
  sub_1403724E0(a1, a2, a3, a4);
  v6 = sub_1402A6BE0();
  _stdio_common_vsprintf(*v6 | 2LL, (char *)(a1 + 0x320), 0x3Fu, Format, 0, va);
  result = a1;
  *(_BYTE *)(a1 + 0x35F) = 0;
  return result;
}

// --- End Function: sub_140372710 (0x140372710) ---

// --- Function: sub_140373AF0 (0x140373AF0) ---
__int64 __fastcall sub_140373AF0(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx

  v1 = *(volatile signed __int32 **)(a1 + 0x18);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v4 = *(volatile signed __int32 **)(a1 + 8);
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
  }
  return result;
}

// --- End Function: sub_140373AF0 (0x140373AF0) ---

// --- Function: sub_140373CC0 (0x140373CC0) ---
void __fastcall sub_140373CC0(_QWORD *a1)
{
  __int64 v1; // rcx

  v1 = *a1 - 8LL;
  if ( *(int *)(v1 + 4) > 0 )
    sub_147715880(v1, (unsigned int)dword_149A5EC00);
}

// --- End Function: sub_140373CC0 (0x140373CC0) ---

// --- Function: sub_140373E10 (0x140373E10) ---
__int64 __fastcall sub_140373E10(__int64 a1)
{
  __int64 (__fastcall ***v1)(_QWORD, __int64); // rcx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = *(__int64 (__fastcall ****)(_QWORD, __int64))a1;
    if ( v1 )
      return (**v1)(v1, 1);
  }
  return result;
}

// --- End Function: sub_140373E10 (0x140373E10) ---

// --- Function: sub_140373F20 (0x140373F20) ---
__int64 __fastcall sub_140373F20(__int64 a1)
{
  return sub_1402A6590(*(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_140373F20 (0x140373F20) ---

// --- Function: sub_140374740 (0x140374740) ---
__int64 __fastcall sub_140374740(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v2 = (_QWORD *)a1[0x45];
  if ( v2 != a1 + 0x46 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - a1[0x44];
    sub_147715880(v2);
  }
  v3 = (_QWORD *)a1[2];
  result = (__int64)(a1 + 3);
  if ( v3 != a1 + 3 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
    return sub_147715880(v3);
  }
  return result;
}

// --- End Function: sub_140374740 (0x140374740) ---

// --- Function: sub_1403749E0 (0x1403749E0) ---
__int64 __fastcall sub_1403749E0(__int64 *a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    return sub_1402A6590(v1);
  return result;
}

// --- End Function: sub_1403749E0 (0x1403749E0) ---

// --- Function: sub_140375170 (0x140375170) ---
__int64 __fastcall sub_140375170(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 i; // rsi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != i; v1 += 0x90 )
      sub_140378880(v1);
    v4 = *a1;
    if ( (unsigned __int64)(0x90 * ((a1[2] - *a1) / 0x90)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_1402A6590(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140375170 (0x140375170) ---

// --- Function: sub_140375620 (0x140375620) ---
__int64 __fastcall sub_140375620(__int64 *a1)
{
  __int64 v1; // rdi
  __int64 v3; // rbp
  _QWORD *v4; // rbx
  _QWORD *v5; // rcx
  __int64 v6; // r8
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 )
  {
    v3 = a1[1];
    if ( v1 != v3 )
    {
      v4 = (_QWORD *)(v1 + 0x18);
      do
      {
        v5 = (_QWORD *)v4[0xFFFFFFFF];
        if ( v5 != v4 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - v4[0xFFFFFFFE];
          sub_147715880(v5);
        }
        v1 += 0x218;
        v4 += 0x43;
      }
      while ( v1 != v3 );
    }
    v6 = *a1;
    if ( (unsigned __int64)(0x218 * ((a1[2] - *a1) / 0x218)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_1402A6590(v6);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140375620 (0x140375620) ---

// --- Function: sub_140375A30 (0x140375A30) ---
__int64 __fastcall sub_140375A30(_DWORD *a1)
{
  __int64 result; // rax

  if ( *a1 != 0xF0000000 )
    return (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, a1);
  return result;
}

// --- End Function: sub_140375A30 (0x140375A30) ---

// --- Function: sub_140375A50 (0x140375A50) ---
__int64 __fastcall sub_140375A50(_DWORD *a1)
{
  __int64 result; // rax

  result = sub_1403D3830();
  if ( a1[7] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 7);
  if ( a1[6] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 6);
  if ( a1[5] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 5);
  if ( a1[4] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 4);
  if ( a1[3] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 3);
  if ( a1[2] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 2);
  if ( a1[1] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 1);
  if ( *a1 != 0xF0000000 )
    return (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, a1);
  return result;
}

// --- End Function: sub_140375A50 (0x140375A50) ---

// --- Function: sub_140377960 (0x140377960) ---
__int64 __fastcall sub_140377960(__int64 a1)
{
  __int64 v2; // rdi
  int v3; // ebp
  __int64 v4; // rsi
  signed __int64 v5; // r14
  _QWORD *i; // rax
  _QWORD *j; // rax
  _QWORD *k; // rax
  int v9; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v11; // rdi
  __int64 v12; // rcx
  __int64 result; // rax
  __int64 v14; // rcx
  __int64 v15; // rcx

  v2 = psub_140338BA0();
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v3 )
  {
    ++*(_DWORD *)(v2 + 0x14);
  }
  else
  {
    v4 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( v5 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
        rw_lock_acquire_write_lock_profiled(
          v2,
          v5,
          v4,
          "SCigEventDispatcher::~SCigEventDispatcher",
          "*g_pGetLinkUnlinkLock()");
      else
        rw_lock_acquire_write_lock_unprofiled(
          v2,
          v5,
          v4,
          "SCigEventDispatcher::~SCigEventDispatcher",
          "*g_pGetLinkUnlinkLock()");
    }
    else
    {
      *(_QWORD *)(v2 + 8) = v4;
    }
    *(_DWORD *)(v2 + 0x10) = v3;
  }
  for ( i = *(_QWORD **)a1; *(_QWORD *)a1 != *(_QWORD *)(a1 + 8); i = *(_QWORD **)a1 )
    sub_1403DF130(a1, *i);
  for ( j = *(_QWORD **)(a1 + 0x20); j != *(_QWORD **)(a1 + 0x28); j = *(_QWORD **)(a1 + 0x20) )
    sub_1403DEFC0(a1, *j);
  for ( k = *(_QWORD **)(a1 + 0x40); k != *(_QWORD **)(a1 + 0x48); k = *(_QWORD **)(a1 + 0x40) )
    sub_1403DEFC0(*k, a1);
  if ( v2 )
  {
    v9 = *(_DWORD *)(v2 + 0x14);
    if ( v9 )
    {
      *(_DWORD *)(v2 + 0x14) = v9 - 1;
    }
    else
    {
      *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v2 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v2, n0x200000);
    }
  }
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 0x60) + 8LL);
  while ( !*(_BYTE *)(v11 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *)(a1 + 0x60),
      (std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *)(a1 + 0x60),
      *(std::_Tree_node<gte::Logger::Listener *,void *> **)(v11 + 0x10));
    v12 = v11;
    v11 = *(_QWORD *)v11;
    sub_1402A6590(v12);
  }
  result = sub_1402A6590(*(_QWORD *)(a1 + 0x60));
  v14 = *(_QWORD *)(a1 + 0x40);
  if ( v14 )
    result = sub_1402A6590(v14);
  v15 = *(_QWORD *)(a1 + 0x20);
  if ( v15 )
    result = sub_1402A6590(v15);
  if ( *(_QWORD *)a1 )
    return sub_1402A6590(*(_QWORD *)a1);
  return result;
}

// --- End Function: sub_140377960 (0x140377960) ---

// --- Function: sub_140378880 (0x140378880) ---
__int64 __fastcall sub_140378880(_QWORD *a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = (volatile signed __int32 *)a1[0x10];
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  if ( *(int *)(*a1 - 4LL) > 0 )
    return sub_147715880((const void *)(*a1 - 8LL));
  return result;
}

// --- End Function: sub_140378880 (0x140378880) ---

// --- Function: sub_140379B70 (0x140379B70) ---
__int64 __fastcall sub_140379B70(_BYTE *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return sub_1404D5120();
  return result;
}

// --- End Function: sub_140379B70 (0x140379B70) ---

// --- Function: sub_14037A590 (0x14037A590) ---
__int64 (__fastcall *__fastcall sub_14037A590(__int64 a1))(__int64, __int64, _QWORD)
{
  __int64 (__fastcall *n2)(__int64, __int64, _QWORD); // rax
  __int64 v3; // rcx

  sub_140375A50((_DWORD *)(a1 + 0x2D0));
  n2 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a1 + 0x2C0);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2 = (__int64 (__fastcall *)(__int64, __int64, _QWORD))n2(2, a1 + 0x2B8, 0);
    *(_QWORD *)(a1 + 0x2C0) = 0;
  }
  *(_QWORD *)(a1 + 0x2B8) = 0;
  v3 = *(_QWORD *)(a1 + 0x298);
  if ( v3 )
  {
    if ( ((*(_QWORD *)(a1 + 0x2A8) - v3) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = *(_QWORD *)(v3 - 8);
    }
    n2 = (__int64 (__fastcall *)(__int64, __int64, _QWORD))sub_1402A6590(v3);
    *(_QWORD *)(a1 + 0x298) = 0;
    *(_QWORD *)(a1 + 0x2A0) = 0;
    *(_QWORD *)(a1 + 0x2A8) = 0;
  }
  return n2;
}

// --- End Function: sub_14037A590 (0x14037A590) ---

// --- Function: sub_14037A850 (0x14037A850) ---
__int64 __fastcall sub_14037A850(_QWORD *a1)
{
  unsigned __int64 n0xF; // rdx
  __int64 v3; // rcx
  __int64 result; // rax
  unsigned __int64 n0xF_1; // rdx
  __int64 v6; // rcx

  n0xF = a1[8];
  if ( n0xF > 0xF )
  {
    v3 = a1[5];
    if ( n0xF + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        goto LABEL_12;
      v3 = *(_QWORD *)(v3 - 8);
    }
    result = sub_1402A6590(v3);
  }
  a1[7] = 0;
  a1[8] = 0xF;
  *((_BYTE *)a1 + 0x28) = 0;
  n0xF_1 = a1[4];
  if ( n0xF_1 > 0xF )
  {
    v6 = a1[1];
    if ( n0xF_1 + 1 < 0x1000 )
    {
LABEL_10:
      result = sub_1402A6590(v6);
      goto LABEL_11;
    }
    if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) <= 0x1F )
    {
      v6 = *(_QWORD *)(v6 - 8);
      goto LABEL_10;
    }
LABEL_12:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  a1[3] = 0;
  a1[4] = 0xF;
  *((_BYTE *)a1 + 8) = 0;
  return result;
}

// --- End Function: sub_14037A850 (0x14037A850) ---

// --- Function: sub_14037ABF0 (0x14037ABF0) ---
_QWORD *__fastcall sub_14037ABF0(_QWORD *a1, _QWORD *a2)
{
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  void (__fastcall *v5)(__int64, _QWORD *, _QWORD *); // rax
  void (__fastcall *n2_1)(__int64, _QWORD *); // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a1[1];
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1, 0);
    a1[1] = 0;
  }
  *a1 = 0;
  v5 = (void (__fastcall *)(__int64, _QWORD *, _QWORD *))a2[1];
  if ( v5 == (void (__fastcall *)(__int64, _QWORD *, _QWORD *))1 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
  }
  else
  {
    if ( !v5 )
      return a1;
    v5(1, a1, a2);
  }
  n2_1 = (void (__fastcall *)(__int64, _QWORD *))a2[1];
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, a2);
    a2[1] = 0;
  }
  *a2 = 0;
  return a1;
}

// --- End Function: sub_14037ABF0 (0x14037ABF0) ---

// --- Function: sub_14037AE80 (0x14037AE80) ---
void **__fastcall sub_14037AE80(void **a1, void **a2)
{
  void *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403EDAA0(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_14037AE80 (0x14037AE80) ---

// --- Function: copyStringStructure (0x14037AEC0) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
void **__fastcall copyStringStructure(void **a1, const void **a2, __int64 a3)
{
  size_t Size; // rdi

  LOBYTE(a3) = 0x20;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  sub_1403EDAA0(a1, Size, a3);
  if ( Size && *a1 != *a2 )
    memcpy(*a1, *a2, Size);
  return a1;
}

// --- End Function: copyStringStructure (0x14037AEC0) ---

// --- Function: assignCStringToStringStructure (0x14037AF20) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
__int64 __fastcall assignCStringToStringStructure(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rax

  if ( a2 )
  {
    v4 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v4;
    while ( *(_BYTE *)(a2 + v4) );
    sub_1403E25F0(a1, a2, (int)v4);
    return a1;
  }
  else
  {
    sub_1403E25F0(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x14037AF20) ---

// --- Function: sub_14037AF60 (0x14037AF60) ---
__int64 *__fastcall sub_14037AF60(__int64 *a1, __int64 *a2)
{
  __int64 v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *(_DWORD *)(*a2 - 8) )
    sub_1403EDB70(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_14037AF60 (0x14037AF60) ---

// --- Function: sub_14037BE50 (0x14037BE50) ---
__int64 *__fastcall sub_14037BE50(__int64 *a1, __int64 *a2)
{
  __int64 v4; // rcx

  if ( a1 != a2 )
  {
    v4 = *a1;
    if ( v4 )
    {
      if ( ((a1[2] - v4) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v4 = *(_QWORD *)(v4 - 8);
      }
      sub_1402A6590(v4);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = *a2;
    a1[1] = a2[1];
    a1[2] = a2[2];
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return a1;
}

// --- End Function: sub_14037BE50 (0x14037BE50) ---

// --- Function: sub_14037C160 (0x14037C160) ---
__int64 __fastcall sub_14037C160(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a2 + 0x20);
  *(_QWORD *)(a1 + 0x28) = *(_QWORD *)(a2 + 0x28);
  *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = *(_QWORD *)(a2 + 0x38);
  *(_QWORD *)(a1 + 0x40) = *(_QWORD *)(a2 + 0x40);
  *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(a2 + 0x48);
  *(_QWORD *)(a1 + 0x50) = *(_QWORD *)(a2 + 0x50);
  *(_QWORD *)(a1 + 0x58) = *(_QWORD *)(a2 + 0x58);
  *(double *)(a1 + 0x60) = *(double *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_QWORD *)(a1 + 0x70) = *(_QWORD *)(a2 + 0x70);
  *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(a2 + 0x78);
  *(_QWORD *)(a1 + 0x80) = *(_QWORD *)(a2 + 0x80);
  *(_QWORD *)(a1 + 0x88) = *(_QWORD *)(a2 + 0x88);
  *(_OWORD *)(a1 + 0x90) = *(_OWORD *)(a2 + 0x90);
  *(double *)(a1 + 0xA0) = *(double *)(a2 + 0xA0);
  *(_DWORD *)(a1 + 0xA8) = *(_DWORD *)(a2 + 0xA8);
  *(_QWORD *)(a1 + 0xB0) = *(_QWORD *)(a2 + 0xB0);
  *(_QWORD *)(a1 + 0xB8) = *(_QWORD *)(a2 + 0xB8);
  *(_QWORD *)(a1 + 0xC0) = *(_QWORD *)(a2 + 0xC0);
  *(_QWORD *)(a1 + 0xC8) = *(_QWORD *)(a2 + 0xC8);
  *(_OWORD *)(a1 + 0xD0) = *(_OWORD *)(a2 + 0xD0);
  *(double *)(a1 + 0xE0) = *(double *)(a2 + 0xE0);
  *(_QWORD *)(a1 + 0xE8) = *(_QWORD *)(a2 + 0xE8);
  *(_DWORD *)(a1 + 0xF0) = *(_DWORD *)(a2 + 0xF0);
  *(_DWORD *)(a1 + 0xF4) = *(_DWORD *)(a2 + 0xF4);
  *(_DWORD *)(a1 + 0xF8) = *(_DWORD *)(a2 + 0xF8);
  *(_DWORD *)(a1 + 0xFC) = *(_DWORD *)(a2 + 0xFC);
  *(_DWORD *)(a1 + 0x100) = *(_DWORD *)(a2 + 0x100);
  *(double *)(a1 + 0x104) = *(double *)(a2 + 0x104);
  *(_DWORD *)(a1 + 0x10C) = *(_DWORD *)(a2 + 0x10C);
  *(double *)(a1 + 0x110) = *(double *)(a2 + 0x110);
  *(_DWORD *)(a1 + 0x118) = *(_DWORD *)(a2 + 0x118);
  *(double *)(a1 + 0x11C) = *(double *)(a2 + 0x11C);
  *(_DWORD *)(a1 + 0x124) = *(_DWORD *)(a2 + 0x124);
  *(_DWORD *)(a1 + 0x128) = *(_DWORD *)(a2 + 0x128);
  *(_DWORD *)(a1 + 0x12C) = *(_DWORD *)(a2 + 0x12C);
  *(_DWORD *)(a1 + 0x130) = *(_DWORD *)(a2 + 0x130);
  *(_DWORD *)(a1 + 0x134) = *(_DWORD *)(a2 + 0x134);
  *(_DWORD *)(a1 + 0x138) = *(_DWORD *)(a2 + 0x138);
  *(double *)(a1 + 0x13C) = *(double *)(a2 + 0x13C);
  *(_DWORD *)(a1 + 0x144) = *(_DWORD *)(a2 + 0x144);
  *(double *)(a1 + 0x148) = *(double *)(a2 + 0x148);
  *(_DWORD *)(a1 + 0x150) = *(_DWORD *)(a2 + 0x150);
  *(double *)(a1 + 0x154) = *(double *)(a2 + 0x154);
  *(_DWORD *)(a1 + 0x15C) = *(_DWORD *)(a2 + 0x15C);
  *(double *)(a1 + 0x160) = *(double *)(a2 + 0x160);
  *(_DWORD *)(a1 + 0x168) = *(_DWORD *)(a2 + 0x168);
  *(double *)(a1 + 0x16C) = *(double *)(a2 + 0x16C);
  *(_DWORD *)(a1 + 0x174) = *(_DWORD *)(a2 + 0x174);
  *(double *)(a1 + 0x178) = *(double *)(a2 + 0x178);
  *(_DWORD *)(a1 + 0x180) = *(_DWORD *)(a2 + 0x180);
  *(double *)(a1 + 0x184) = *(double *)(a2 + 0x184);
  *(_DWORD *)(a1 + 0x18C) = *(_DWORD *)(a2 + 0x18C);
  *(double *)(a1 + 0x190) = *(double *)(a2 + 0x190);
  *(_DWORD *)(a1 + 0x198) = *(_DWORD *)(a2 + 0x198);
  *(double *)(a1 + 0x19C) = *(double *)(a2 + 0x19C);
  *(_DWORD *)(a1 + 0x1A4) = *(_DWORD *)(a2 + 0x1A4);
  *(double *)(a1 + 0x1A8) = *(double *)(a2 + 0x1A8);
  *(_DWORD *)(a1 + 0x1B0) = *(_DWORD *)(a2 + 0x1B0);
  *(double *)(a1 + 0x1B4) = *(double *)(a2 + 0x1B4);
  *(_DWORD *)(a1 + 0x1BC) = *(_DWORD *)(a2 + 0x1BC);
  *(double *)(a1 + 0x1C0) = *(double *)(a2 + 0x1C0);
  *(_DWORD *)(a1 + 0x1C8) = *(_DWORD *)(a2 + 0x1C8);
  *(__m256i *)(a1 + 0x1D0) = *(__m256i *)(a2 + 0x1D0);
  *(__m256i *)(a1 + 0x1F0) = *(__m256i *)(a2 + 0x1F0);
  *(__m256i *)(a1 + 0x210) = *(__m256i *)(a2 + 0x210);
  *(__m256i *)(a1 + 0x230) = *(__m256i *)(a2 + 0x230);
  *(__m256i *)(a1 + 0x250) = *(__m256i *)(a2 + 0x250);
  *(__m256i *)(a1 + 0x270) = *(__m256i *)(a2 + 0x270);
  *(_DWORD *)(a1 + 0x290) = *(_DWORD *)(a2 + 0x290);
  *(_DWORD *)(a1 + 0x294) = *(_DWORD *)(a2 + 0x294);
  *(_DWORD *)(a1 + 0x298) = *(_DWORD *)(a2 + 0x298);
  *(_DWORD *)(a1 + 0x29C) = *(_DWORD *)(a2 + 0x29C);
  *(_DWORD *)(a1 + 0x2A0) = *(_DWORD *)(a2 + 0x2A0);
  *(_DWORD *)(a1 + 0x2A4) = *(_DWORD *)(a2 + 0x2A4);
  *(_DWORD *)(a1 + 0x2A8) = *(_DWORD *)(a2 + 0x2A8);
  *(_DWORD *)(a1 + 0x2AC) = *(_DWORD *)(a2 + 0x2AC);
  *(_DWORD *)(a1 + 0x2B0) = *(_DWORD *)(a2 + 0x2B0);
  *(_DWORD *)(a1 + 0x2B4) = *(_DWORD *)(a2 + 0x2B4);
  *(_DWORD *)(a1 + 0x2B8) = *(_DWORD *)(a2 + 0x2B8);
  *(_DWORD *)(a1 + 0x2BC) = *(_DWORD *)(a2 + 0x2BC);
  *(_DWORD *)(a1 + 0x2C0) = *(_DWORD *)(a2 + 0x2C0);
  *(_DWORD *)(a1 + 0x2C4) = *(_DWORD *)(a2 + 0x2C4);
  *(_DWORD *)(a1 + 0x2C8) = *(_DWORD *)(a2 + 0x2C8);
  *(_DWORD *)(a1 + 0x2CC) = *(_DWORD *)(a2 + 0x2CC);
  *(_DWORD *)(a1 + 0x2D0) = *(_DWORD *)(a2 + 0x2D0);
  *(_DWORD *)(a1 + 0x2D4) = *(_DWORD *)(a2 + 0x2D4);
  *(_DWORD *)(a1 + 0x2D8) = *(_DWORD *)(a2 + 0x2D8);
  *(_DWORD *)(a1 + 0x2DC) = *(_DWORD *)(a2 + 0x2DC);
  *(_DWORD *)(a1 + 0x2E0) = *(_DWORD *)(a2 + 0x2E0);
  *(_DWORD *)(a1 + 0x2E4) = *(_DWORD *)(a2 + 0x2E4);
  *(_DWORD *)(a1 + 0x2E8) = *(_DWORD *)(a2 + 0x2E8);
  *(_DWORD *)(a1 + 0x2EC) = *(_DWORD *)(a2 + 0x2EC);
  *(_DWORD *)(a1 + 0x2F0) = *(_DWORD *)(a2 + 0x2F0);
  *(_DWORD *)(a1 + 0x2F4) = *(_DWORD *)(a2 + 0x2F4);
  *(_DWORD *)(a1 + 0x2F8) = *(_DWORD *)(a2 + 0x2F8);
  *(_DWORD *)(a1 + 0x2FC) = *(_DWORD *)(a2 + 0x2FC);
  *(_DWORD *)(a1 + 0x300) = *(_DWORD *)(a2 + 0x300);
  *(_DWORD *)(a1 + 0x304) = *(_DWORD *)(a2 + 0x304);
  *(_DWORD *)(a1 + 0x308) = *(_DWORD *)(a2 + 0x308);
  *(_DWORD *)(a1 + 0x30C) = *(_DWORD *)(a2 + 0x30C);
  *(_DWORD *)(a1 + 0x310) = *(_DWORD *)(a2 + 0x310);
  *(_DWORD *)(a1 + 0x314) = *(_DWORD *)(a2 + 0x314);
  *(_DWORD *)(a1 + 0x318) = *(_DWORD *)(a2 + 0x318);
  *(_DWORD *)(a1 + 0x31C) = *(_DWORD *)(a2 + 0x31C);
  *(_DWORD *)(a1 + 0x320) = *(_DWORD *)(a2 + 0x320);
  *(_DWORD *)(a1 + 0x324) = *(_DWORD *)(a2 + 0x324);
  *(double *)(a1 + 0x328) = *(double *)(a2 + 0x328);
  *(_DWORD *)(a1 + 0x330) = *(_DWORD *)(a2 + 0x330);
  *(_DWORD *)(a1 + 0x334) = *(_DWORD *)(a2 + 0x334);
  *(_DWORD *)(a1 + 0x338) = *(_DWORD *)(a2 + 0x338);
  *(_DWORD *)(a1 + 0x33C) = *(_DWORD *)(a2 + 0x33C);
  *(_DWORD *)(a1 + 0x340) = *(_DWORD *)(a2 + 0x340);
  *(_BYTE *)(a1 + 0x344) = *(_BYTE *)(a2 + 0x344);
  *(_DWORD *)(a1 + 0x348) = *(_DWORD *)(a2 + 0x348);
  *(_DWORD *)(a1 + 0x34C) = *(_DWORD *)(a2 + 0x34C);
  *(_DWORD *)(a1 + 0x350) = *(_DWORD *)(a2 + 0x350);
  *(_DWORD *)(a1 + 0x354) = *(_DWORD *)(a2 + 0x354);
  *(_DWORD *)(a1 + 0x358) = *(_DWORD *)(a2 + 0x358);
  *(_DWORD *)(a1 + 0x35C) = *(_DWORD *)(a2 + 0x35C);
  result = a1;
  *(_OWORD *)(a1 + 0x360) = *(_OWORD *)(a2 + 0x360);
  *(double *)(a1 + 0x370) = *(double *)(a2 + 0x370);
  *(_OWORD *)(a1 + 0x378) = *(_OWORD *)(a2 + 0x378);
  *(double *)(a1 + 0x388) = *(double *)(a2 + 0x388);
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_14037C160 (0x14037C160) ---

// --- Function: sub_14037CAC0 (0x14037CAC0) ---
_DWORD *__fastcall sub_14037CAC0(_DWORD *a1, _DWORD *a2)
{
  if ( a1 != a2 )
  {
    (*(void (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, a1);
    *a1 = *a2;
    *a2 = 0xF0000000;
  }
  return a1;
}

// --- End Function: sub_14037CAC0 (0x14037CAC0) ---

// --- Function: sub_14037CB50 (0x14037CB50) ---
__int64 __fastcall sub_14037CB50(__int64 a1, __int64 a2)
{
  unsigned __int16 n4; // ax
  unsigned __int64 n4_1; // rdi
  __int64 v6; // rbx
  __int64 v7; // r12
  __int64 v8; // r13
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 v11; // r14
  __int64 v12; // rbp
  __int64 v13; // r14
  __int64 v14; // rbp

  if ( a2 == a1 )
    return a1;
  sub_1403D3830();
  n4 = *(_WORD *)(a2 + 0x28);
  *(_WORD *)(a1 + 0x28) = n4;
  if ( n4 > 4u )
    sub_1403950C0(a1);
  n4_1 = 0;
  if ( *(_WORD *)(a2 + 0x28) )
  {
    v6 = a1 + 4;
    v7 = a2 - a1;
    v8 = 0xFFFFFFFFFFFFFFFCuLL - a1;
    do
    {
      if ( n4_1 >= 4 )
      {
        v11 = v6 + v8 + *(_QWORD *)(a2 + 0x20) - 0x20LL;
        v12 = v6 + v8 + *(_QWORD *)(a1 + 0x20) - 0x20LL;
        if ( v12 != v11 )
        {
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
            qword_149C8DF38,
            v6 + v8 + *(_QWORD *)(a1 + 0x20) - 0x20LL);
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xE8LL))(
            qword_149C8DF38,
            v12,
            v11);
        }
        v13 = v11 + 4;
        v14 = v12 + 4;
        if ( v14 == v13 )
          goto LABEL_16;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v14);
        v9 = v13;
        v10 = v14;
      }
      else
      {
        if ( v6 - 4 != v6 + v7 - 4 )
        {
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v6 - 4);
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xE8LL))(
            qword_149C8DF38,
            v6 - 4,
            v6 + v7 - 4);
        }
        if ( v6 == v7 + v6 )
          goto LABEL_16;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v6);
        v9 = v7 + v6;
        v10 = v6;
      }
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xE8LL))(
        qword_149C8DF38,
        v10,
        v9);
LABEL_16:
      ++n4_1;
      v6 += 8;
    }
    while ( n4_1 < *(unsigned __int16 *)(a2 + 0x28) );
  }
  return a1;
}

// --- End Function: sub_14037CB50 (0x14037CB50) ---

// --- Function: sub_1403826E0 (0x1403826E0) ---
bool __fastcall sub_1403826E0(_WORD *a1, unsigned __int16 a2)
{
  return *a1 == a2;
}

// --- End Function: sub_1403826E0 (0x1403826E0) ---

// --- Function: sub_140382780 (0x140382780) ---
bool __fastcall sub_140382780(__int64 a1, __int64 a2)
{
  return a1 != a2;
}

// --- End Function: sub_140382780 (0x140382780) ---

// --- Function: sub_1403828E0 (0x1403828E0) ---
bool __fastcall sub_1403828E0(_WORD *a1, unsigned __int16 a2)
{
  return *a1 != a2;
}

// --- End Function: sub_1403828E0 (0x1403828E0) ---

// --- Function: ??A?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAAEAD_K@Z (0x1403829B0) ---
__int64 __fastcall std::unique_ptr<char [0]>::operator[](_QWORD *a1, __int64 a2)
{
  return a2 + *a1;
}

// --- End Function: ??A?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAAEAD_K@Z (0x1403829B0) ---

// --- Function: AssetMeta::HasActorSubresource (0x140382D20) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x128LL))(
         qword_149C8DFC0,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return (unsigned __int8)sub_140395350(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x140382D20) ---

// --- Function: ?Count@WriteBytesMem@AK@@UEBAHXZ (0x140382DD0) ---
__int64 __fastcall AK::WriteBytesMem::Count(AK::WriteBytesMem *this)
{
  return *((unsigned int *)this + 6);
}

// --- End Function: ?Count@WriteBytesMem@AK@@UEBAHXZ (0x140382DD0) ---

// --- Function: HIWORD_w (0x140382E00) ---
bool __fastcall sub_140382E00(_QWORD *a1)
{
  return *a1 && *(_QWORD *)((*a1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*a1);
}

// --- End Function: HIWORD_w (0x140382E00) ---

// --- Function: sub_140387C60 (0x140387C60) ---
__int64 __fastcall sub_140387C60(__int64 a1, _QWORD *a2)
{
  sub_1403E4320(a1, *a2, *(int *)(*a2 - 8LL));
  return a1;
}

// --- End Function: sub_140387C60 (0x140387C60) ---

// --- Function: sub_140387C80 (0x140387C80) ---
__int64 __fastcall sub_140387C80(__int64 a1, char a2)
{
  char v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  sub_1403E4320(a1, &v4, 1);
  return a1;
}

// --- End Function: sub_140387C80 (0x140387C80) ---

// --- Function: sub_140387CB0 (0x140387CB0) ---
__int64 __fastcall sub_140387CB0(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rax

  if ( a2 )
  {
    v4 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v4;
    while ( *(_BYTE *)(a2 + v4) );
    sub_1403E4320(a1, a2, (int)v4);
    return a1;
  }
  else
  {
    sub_1403E4320(a1, 0, 0);
    return a1;
  }
}

// --- End Function: sub_140387CB0 (0x140387CB0) ---

// --- Function: sub_140387DF0 (0x140387DF0) ---
__int64 __fastcall sub_140387DF0(__int64 a1, __int64 a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v4; // ax
  unsigned int v5; // ecx
  __int64 result; // rax

  *(float *)a1 = *(float *)a2 + *(float *)a1;
  *(float *)(a1 + 4) = *(float *)(a2 + 4) + *(float *)(a1 + 4);
  v2 = *(_WORD *)(a2 + 8);
  if ( *(_WORD *)(a1 + 8) >= v2 )
    v2 = *(_WORD *)(a1 + 8);
  *(_WORD *)(a1 + 8) = v2;
  v4 = *(_WORD *)(a2 + 0xA);
  if ( *(_WORD *)(a1 + 0xA) >= v4 )
    v4 = *(_WORD *)(a1 + 0xA);
  *(_WORD *)(a1 + 0xA) = v4;
  if ( (*(_BYTE *)(a1 + 0xC) & 1) != 0 || (*(_BYTE *)(a2 + 0xC) & 1) != 0 )
    v5 = *(_DWORD *)(a1 + 0xC) | 1;
  else
    v5 = *(_DWORD *)(a1 + 0xC) & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 0xC) = v5;
  result = v5 >> 1;
  if ( (v5 & 2) != 0 || (result = *(_DWORD *)(a2 + 0xC) >> 1, (*(_DWORD *)(a2 + 0xC) & 2) != 0) )
    *(_DWORD *)(a1 + 0xC) = v5 | 2;
  else
    *(_DWORD *)(a1 + 0xC) = v5 & 0xFFFFFFFD;
  return result;
}

// --- End Function: sub_140387DF0 (0x140387DF0) ---

// --- Function: sub_140387F04 (0x140387F04) ---
__int64 __fastcall sub_140387F04(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
}

// --- End Function: sub_140387F04 (0x140387F04) ---

// --- Function: sub_140393240 (0x140393240) ---
__int64 __fastcall sub_140393240(__int64 a1, unsigned __int64 n4, __int64 *a3)
{
  __int16 v3; // r9
  __int64 result; // rax
  __int64 v8; // [rsp+30h] [rbp+8h] BYREF

  v3 = n4 + 1;
  if ( *(_WORD *)(a1 + 0x28) >= (unsigned __int16)(n4 + 1) )
    v3 = *(_WORD *)(a1 + 0x28);
  *(_WORD *)(a1 + 0x28) = v3;
  if ( n4 >= 4 )
  {
    sub_1403950C0(a1);
    result = *a3;
    v8 = result;
    if ( (_WORD)result != 0xFFFF )
      return (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64 *))(*(_QWORD *)qword_149C8DF38 + 0x70LL))(
               qword_149C8DF38,
               *(_QWORD *)(a1 + 0x20) + 8 * n4 - 0x1C,
               &v8);
  }
  else
  {
    result = *a3;
    v8 = result;
    if ( (_WORD)result != 0xFFFF )
      return (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64 *))(*(_QWORD *)qword_149C8DF38 + 0x70LL))(
               qword_149C8DF38,
               a1 + 8 * n4 + 4,
               &v8);
  }
  return result;
}

// --- End Function: sub_140393240 (0x140393240) ---

// --- Function: sub_140393EC0 (0x140393EC0) ---
__int64 __fastcall sub_140393EC0(__int64 a1, unsigned __int64 n4, __int64 *a3)
{
  __int16 v3; // r9
  __int64 result; // rax
  __int64 v8; // [rsp+30h] [rbp+8h] BYREF

  v3 = n4 + 1;
  if ( *(_WORD *)(a1 + 0x28) >= (unsigned __int16)(n4 + 1) )
    v3 = *(_WORD *)(a1 + 0x28);
  *(_WORD *)(a1 + 0x28) = v3;
  if ( n4 >= 4 )
  {
    sub_1403950C0(a1);
    result = *a3;
    v8 = result;
    if ( (_WORD)result != 0xFFFF )
      return (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64 *))(*(_QWORD *)qword_149C8DF38 + 0x70LL))(
               qword_149C8DF38,
               *(_QWORD *)(a1 + 0x20) + 8 * (n4 - 4),
               &v8);
  }
  else
  {
    result = *a3;
    v8 = result;
    if ( (_WORD)result != 0xFFFF )
      return (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64 *))(*(_QWORD *)qword_149C8DF38 + 0x70LL))(
               qword_149C8DF38,
               a1 + 8 * n4,
               &v8);
  }
  return result;
}

// --- End Function: sub_140393EC0 (0x140393EC0) ---

// --- Function: sub_140394E70 (0x140394E70) ---
__int64 __fastcall sub_140394E70(__int64 a1, unsigned __int64 allocSize)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  unsigned __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  __int64 v11; // r9
  __int64 v12; // rdx
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v15; // eax
  unsigned __int64 v16; // rdx
  unsigned int v17; // edi
  _QWORD v18[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v19[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403B7230();
  n0x40 = (allocSize >> 8) + ((_BYTE)allocSize != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
      goto LABEL_7;
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 0x40LL;
      if ( n0x4000 >= 0x4000 )
        goto LABEL_2;
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
        n0x40_1 = 0xFFFFFFFFFFFFFFFFuLL;
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
          goto LABEL_2;
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    v11 = 1;
    v12 = n0x4000_2 & 0x3F;
    if ( n0x4000 >= (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << v12;
      n0x4000_2 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ;
          n0x4000_2 + 0x40 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL);
          v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = 0xFFFFFFFFFFFFFFFFuLL )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 0x40LL;
    }
    if ( n0x4000_2 < n0x4000 )
    {
      n0x4000_2 >>= 6;
      v12 = ((__int64)n0x4000 >> 0x3F) & 0x3F;
      v11 = (1LL << ((__int64)n0x4000 % 0x40)) - 1;
      v3[1].m256i_i64[n0x4000_2 + 1] |= v11;
    }
    if ( !v3->m256i_i64[0] )
    {
      v18[0] = 0x200000;
      v19[0] = v18;
      v18[1] = 0;
      v19[1] = v19;
      v15 = sub_140572D10(v19, v12, n0x4000_2, v11);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_140572D50((unsigned int)v19, 0x400000, v15, (unsigned int)&p_CigTemporaryAllocator, 0, 0);
    }
    v16 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v16 )
    {
      v17 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v16 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_140572BD0(v3, v3->m256i_i64[0] + v16, v17, 0);
      v3[1].m256i_i32[0] += v17;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(allocSize, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140394E70 (0x140394E70) ---

// --- Function: sub_1403950C0 (0x1403950C0) ---
unsigned __int64 __fastcall sub_1403950C0(__int64 a1)
{
  unsigned __int64 n4; // rax
  unsigned __int64 n4_1; // rdi
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rcx

  n4 = *(unsigned __int16 *)(a1 + 0x28);
  if ( (unsigned int)n4 > 4 )
  {
    n4_1 = 8 * n4 - 0x20;
    n4 = *(unsigned __int16 *)(a1 + 0x2A);
    if ( n4 < n4_1 )
    {
      v4 = sub_1477159A0(*(_QWORD *)(a1 + 0x20), n4_1, 0, (unsigned int)dword_149A5EC00);
      v5 = *(unsigned __int16 *)(a1 + 0x28);
      *(_QWORD *)(a1 + 0x20) = v4;
      n4 = (unsigned __int64)*(unsigned __int16 *)(a1 + 0x2A) >> 3;
      if ( n4 < v5 - 4 )
      {
        do
        {
          v6 = *(_QWORD *)(a1 + 0x20);
          *(_DWORD *)(v6 + 8 * n4) = 0xF0000000;
          *(_DWORD *)(v6 + 8 * n4++ + 4) = 0xF0000000;
        }
        while ( n4 < (unsigned __int64)*(unsigned __int16 *)(a1 + 0x28) - 4 );
      }
      *(_WORD *)(a1 + 0x2A) = n4_1;
    }
  }
  return n4;
}

// --- End Function: sub_1403950C0 (0x1403950C0) ---

// --- Function: check_thread_list_contains_value (0x140395170) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 a1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8LL))(a1, &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140395170) ---

// --- Function: sub_140395230 (0x140395230) ---
bool __fastcall sub_140395230(unsigned __int64 a1)
{
  __int64 v2; // r9
  unsigned __int64 *v3; // r10
  unsigned __int64 *v4; // r8
  unsigned __int64 v5; // rcx
  unsigned __int64 *v6; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) != 1 )
    return 0;
  v3 = *(unsigned __int64 **)(v2 + 0x30);
  v4 = *(unsigned __int64 **)(v2 + 0x28);
  v5 = v3 - v4;
  while ( (__int64)v5 > 0 )
  {
    if ( v4[v5 >> 1] >= a1 )
    {
      v5 >>= 1;
    }
    else
    {
      v4 += (v5 >> 1) + 1;
      v5 += 0xFFFFFFFFFFFFFFFFuLL - (v5 >> 1);
    }
  }
  if ( v4 == v3 || (v6 = v4 + 1, a1 < *v4) )
    v6 = v4;
  if ( v4 == v6 )
    v4 = *(unsigned __int64 **)(v2 + 0x30);
  return v4 != v3;
}

// --- End Function: sub_140395230 (0x140395230) ---

// --- Function: validate_access_with_virtual_calls (0x1403952D0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  v3 = qword_149C8DFC0;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8LL))(a1, &v7);
  return v4(v3, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x1403952D0) ---

// --- Function: sub_140395350 (0x140395350) ---
char __fastcall sub_140395350(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x128LL))(
         qword_149C8DFC0,
         v1,
         0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
      return sub_140395230(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (unsigned __int8)is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140395350 (0x140395350) ---

// --- Function: sub_140395410 (0x140395410) ---
char __fastcall sub_140395410(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rbx
  __int64 v2; // rax

  payload_ptr_state1 = *a1 & 0xFFFFFFFFFFFFLL;
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
      return sub_140395230(payload_ptr_state1);
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (unsigned __int8)is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls(payload_ptr_state1);
}

// --- End Function: sub_140395410 (0x140395410) ---

// --- Function: getModuleFunction (0x14039E810) ---
FARPROC __fastcall getModuleFunction(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: getModuleFunction (0x14039E810) ---

// --- Function: sub_1403A27F0 (0x1403A27F0) ---
_QWORD *sub_1403A27F0(_QWORD *a1, const wchar_t **a2, ...)
{
  _QWORD *v4; // rax
  unsigned __int64 v5; // rcx
  wchar_t Buffer[4096]; // [rsp+30h] [rbp-2028h] BYREF
  va_list va; // [rsp+2070h] [rbp+18h] BYREF

  va_start(va, a2);
  *a1 = &unk_149C7C038;
  v4 = sub_1402A6BE0();
  _stdio_common_vswprintf(*v4 | 1LL, Buffer, 0x1000u, *a2, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1403E2690(a1, Buffer, (int)v5);
  return a1;
}

// --- End Function: sub_1403A27F0 (0x1403A27F0) ---

// --- Function: sub_1403A6820 (0x1403A6820) ---
__int64 __fastcall sub_1403A6820(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  __int64 v6; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // rcx
  unsigned __int64 n0x40; // rcx
  __int64 result; // rax
  unsigned __int64 v13; // rcx

  v5 = sub_1403B7230();
  v6 = v5;
  v7 = *(_QWORD *)v5;
  if ( !*(_QWORD *)v5 || a2 < v7 || a2 >= v7 + *(unsigned int *)(v5 + 0x20) )
    return sub_147715880(a2, (unsigned int)dword_149A5EC00);
  v8 = (a2 - v7) >> 8;
  v9 = (a3 >> 8) + v8 + ((_BYTE)a3 != 0);
  v10 = v9;
  if ( v9 >= (v8 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
    v10 = (v8 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
  n0x40 = v10 - v8;
  if ( (v8 & 0x3F) != 0 || n0x40 < 0x40 )
  {
    *(_QWORD *)(v5 + 8 * (v8 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v8 & 0x3F));
    v8 = (v8 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
  }
  for ( result = v8 + 0x40; v8 + 0x40 <= (v9 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v6 + 8 * (v13 >> 6) + 0x28) = 0 )
  {
    v13 = v8;
    v8 += 0x40LL;
  }
  if ( v8 < v9 )
  {
    result = v9;
    *(_QWORD *)(v6 + 8 * (v8 >> 6) + 0x28) &= ~((1LL << ((__int64)v9 % 0x40)) - 1);
  }
  return result;
}

// --- End Function: sub_1403A6820 (0x1403A6820) ---

// --- Function: sub_1403A78C0 (0x1403A78C0) ---
__int64 sub_1403A78C0(__int64 *a1, float a2, float a3, float a4, __int128 *a5, unsigned __int8 a6, __int64 a7, ...)
{
  __int64 v7; // rax
  double v9[3]; // [rsp+30h] [rbp-48h] BYREF
  int v10; // [rsp+48h] [rbp-30h] BYREF
  __int128 v11; // [rsp+4Ch] [rbp-2Ch]
  float v12; // [rsp+5Ch] [rbp-1Ch]
  float v13; // [rsp+60h] [rbp-18h]
  va_list va; // [rsp+B8h] [rbp+40h] BYREF

  va_start(va, a7);
  v10 = a6 | 0x70;
  v13 = a4;
  v12 = a4;
  v11 = xmmword_1482BB410;
  if ( a5 )
    v11 = *a5;
  v7 = *a1;
  v9[0] = a2;
  v9[2] = 0.5;
  v9[1] = a3;
  return (*(__int64 (__fastcall **)(__int64 *, double *, int *, __int64, char *))(v7 + 0x560))(a1, v9, &v10, a7, va);
}

// --- End Function: sub_1403A78C0 (0x1403A78C0) ---

// --- Function: sub_1403A9330 (0x1403A9330) ---
__int64 __fastcall sub_1403A9330(__int64 a1, unsigned __int8 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0xA8LL))(
           qword_149C8DFC8,
           a1,
           a2);
}

// --- End Function: sub_1403A9330 (0x1403A9330) ---

// --- Function: sub_1403A9A30 (0x1403A9A30) ---
void __fastcall sub_1403A9A30(__int64 a1, __m256i *a2)
{
  *(_BYTE *)a1 |= 0x10u;
  *(__m256i *)(a1 + 0x70) = *a2;
  __asm { vzeroupper }
}

// --- End Function: sub_1403A9A30 (0x1403A9A30) ---

// --- Function: sub_1403A9A40 (0x1403A9A40) ---
__int64 __fastcall sub_1403A9A40(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 2) |= 1u;
  return sub_14037CB50(a1 + 0x2D0, a2);
}

// --- End Function: sub_1403A9A40 (0x1403A9A40) ---

// --- Function: sub_1403A9A50 (0x1403A9A50) ---
void __fastcall sub_1403A9A50(__int64 a1, __int64 a2, char a3)
{
  *(_BYTE *)(a1 + 1) |= 0x20u;
  *(_QWORD *)(a1 + 0x1F0) = a2;
  *(_BYTE *)(a1 + 0x210) = a3;
}

// --- End Function: sub_1403A9A50 (0x1403A9A50) ---

// --- Function: sub_1403AAD20 (0x1403AAE7F) ---
__int64 __fastcall sub_1403AAD20(_QWORD *lpThreadParameter)
{
  DWORD CurrentThreadId; // eax
  void (__fastcall *v3)(_QWORD); // rdi
  __int64 v4; // rsi
  HANDLE hThread; // rax
  HANDLE hThread_1; // rax
  int n2; // edx
  DWORD v8; // eax
  _QWORD v10[3]; // [rsp+20h] [rbp-58h] BYREF
  unsigned int v11; // [rsp+3Ch] [rbp-3Ch]
  unsigned int v12; // [rsp+40h] [rbp-38h]
  _QWORD v13[3]; // [rsp+48h] [rbp-30h] BYREF
  int n3; // [rsp+60h] [rbp-18h]

  sub_14053EF00(lpThreadParameter[2]);
  CurrentThreadId = GetCurrentThreadId();
  sub_1403E7290(v13, CurrentThreadId);
  sub_1403E7D90(v13[0]);
  v3 = (void (__fastcall *)(_QWORD))*lpThreadParameter;
  v4 = lpThreadParameter[1];
  if ( *(int *)(lpThreadParameter[2] - 4LL) > 0 )
    sub_147715880((const void *)(lpThreadParameter[2] - 8LL));
  sub_1402A6590((__int64)lpThreadParameter);
  hThread = GetCurrentThread();
  if ( !SetThreadPriorityBoost(hThread, 1) )
    __debugbreak();
  switch ( n3 )
  {
    case 0:
      hThread_1 = GetCurrentThread();
      n2 = 0xFFFFFFF1;
      goto LABEL_13;
    case 1:
      hThread_1 = GetCurrentThread();
      n2 = 0xFFFFFFFE;
      goto LABEL_13;
    case 2:
      hThread_1 = GetCurrentThread();
      n2 = 0xFFFFFFFF;
      goto LABEL_13;
    case 3:
      hThread_1 = GetCurrentThread();
      n2 = 0;
      goto LABEL_13;
    case 4:
      hThread_1 = GetCurrentThread();
      n2 = 1;
      goto LABEL_13;
    case 5:
      hThread_1 = GetCurrentThread();
      n2 = 2;
      goto LABEL_13;
    case 6:
      hThread_1 = GetCurrentThread();
      n2 = 0xF;
LABEL_13:
      if ( !SetThreadPriority(hThread_1, n2) )
        goto LABEL_14;
      goto LABEL_15;
    default:
LABEL_14:
      __debugbreak();
LABEL_15:
      if ( n3 >= 3 )
        sub_1403E70E0();
      v8 = GetCurrentThreadId();
      sub_1403E7290(v10, v8);
      sub_14056ECD0(v10[0]);
      if ( qword_149C8E0F8 && qword_149C8DFE0 )
      {
        (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFE0 + 0x598LL))(qword_149C8DFE0, v10[0]);
        sub_1403E7CC0();
      }
      sub_14053BDD0(v11, v12);
      v3(v4);
      if ( qword_149C8E0F8 && qword_149C8DFE0 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x5A0LL))(qword_149C8DFE0);
      if ( *(int *)(v10[0] - 4LL) > 0 )
        sub_147715880((const void *)(v10[0] - 8LL));
      if ( *(int *)(v13[0] - 4LL) > 0 )
        sub_147715880((const void *)(v13[0] - 8LL));
      return 0;
  }
}

// --- End Function: sub_1403AAD20 (0x1403AAE7F) ---

// --- Function: sub_1403ACC80 (0x1403ACC80) ---
void **sub_1403ACC80(void **a1, const char *Format_1, ...)
{
  _QWORD *v4; // rdi
  int BufferCount_2; // eax
  int BufferCount_1; // ecx
  size_t BufferCount; // rbx
  va_list va; // [rsp+70h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = sub_1402A6BE0();
  BufferCount_2 = _stdio_common_vsprintf(*v4 | 2LL, 0, 0, Format_1, 0, va);
  if ( BufferCount_2 < 0 )
    BufferCount_2 = 0xFFFFFFFF;
  BufferCount_1 = 0;
  if ( BufferCount_2 >= 0 )
    BufferCount_1 = BufferCount_2;
  BufferCount = BufferCount_1;
  sub_1403EDAA0(a1, BufferCount_1, 0x20);
  _stdio_common_vsprintf(*v4 | 1LL, (char *)*a1, BufferCount, Format_1, 0, va);
  return a1;
}

// --- End Function: sub_1403ACC80 (0x1403ACC80) ---

// --- Function: sub_1403AE750 (0x1403AE750) ---
float *__fastcall sub_1403AE750(float *a1, int a2)
{
  float v5; // xmm7_4
  __m128 n0x3F800000; // kr00_16
  __m128 v7; // xmm6
  __m128 v10; // xmm0
  float *result; // rax

  _XMM2 = 0;
  __asm { vroundss xmm2, xmm2, xmm3, 1 }
  v5 = (float)((float)((float)((float)((float)a2 * 0.75487763) + 0.5) - *(float *)&_XMM2)
             + (float)((float)((float)((float)a2 * 0.75487763) + 0.5) - *(float *)&_XMM2))
     - 1.0;
  n0x3F800000 = (__m128)0x3F800000u;
  n0x3F800000.m128_f32[0] = 1.0 - (float)(v5 * v5);
  v7 = _mm_sqrt_ps(_mm_shuffle_ps(n0x3F800000, n0x3F800000, 0));
  _XMM1 = 0;
  __asm { vroundss xmm1, xmm1, xmm4, 1 }
  v10.m128_u64[1] = 0;
  *(double *)v10.m128_u64 = _libm_sse2_sincosf_();
  v7.m128_f32[0] = _mm_shuffle_ps(v7, v7, 0xFF).m128_f32[0];
  result = a1;
  a1[2] = v5;
  *a1 = _mm_shuffle_ps(v10, v10, 1).m128_f32[0] * v7.m128_f32[0];
  a1[1] = v10.m128_f32[0] * v7.m128_f32[0];
  return result;
}

// --- End Function: sub_1403AE750 (0x1403AE750) ---

// --- Function: sub_1403B0260 (0x1403B0260) ---
const char *__fastcall sub_1403B0260(int a1)
{
  const char *p_Unknown_Pass; // rax

  switch ( a1 )
  {
    case 0:
      p_Unknown_Pass = "PostNetworkStartUpdate";
      break;
    case 1:
      p_Unknown_Pass = "PrePhysicsUpdate-UpdateZoneHost";
      break;
    case 2:
      p_Unknown_Pass = "PrePhysicsUpdate";
      break;
    case 3:
      p_Unknown_Pass = "PrePhysicsUpdate2";
      break;
    case 4:
      p_Unknown_Pass = "TrackviewInterruptUpdate";
      break;
    case 5:
      p_Unknown_Pass = "PreUpdate";
      break;
    case 6:
      p_Unknown_Pass = "Update-UpdateZoneHosts";
      break;
    case 7:
      p_Unknown_Pass = "Update";
      break;
    case 8:
      p_Unknown_Pass = "PostUpdate";
      break;
    case 9:
      p_Unknown_Pass = "PostAnimationUpdate";
      break;
    case 0xA:
      p_Unknown_Pass = "PreRenderUpdate_AimableController";
      break;
    case 0xB:
      p_Unknown_Pass = "PreRenderUpdate_LocalPlayerAimComponent";
      break;
    case 0xC:
      p_Unknown_Pass = "PreRenderUpdate";
      break;
    case 0xD:
      p_Unknown_Pass = "EndOfFrameUpdate";
      break;
    default:
      __debugbreak();
      p_Unknown_Pass = "Unknown Pass";
      break;
  }
  return p_Unknown_Pass;
}

// --- End Function: sub_1403B0260 (0x1403B0260) ---

// --- Function: sub_1403B0790 (0x1403B0790) ---
__int64 __fastcall sub_1403B0790(__int64 a1)
{
  return a1 + 0x18;
}

// --- End Function: sub_1403B0790 (0x1403B0790) ---

// --- Function: sub_1403B1500 (0x1403B1500) ---
float __fastcall sub_1403B1500(__int64 a1, int a2)
{
  return *(float *)(a1 + 4LL * a2 + 8);
}

// --- End Function: sub_1403B1500 (0x1403B1500) ---

// --- Function: sub_1403B1A80 (0x1403B1A80) ---
__int64 __fastcall sub_1403B1A80(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 2);
}

// --- End Function: sub_1403B1A80 (0x1403B1A80) ---

// --- Function: sub_1403B1A90 (0x1403B1A90) ---
const char *__fastcall sub_1403B1A90(__int16 a1)
{
  switch ( a1 )
  {
    case 0:
      return "keyboard";
    case 1:
      return "mouse";
    case 2:
      return "joystick";
    case 3:
      return "gamepad";
  }
  return "unknown";
}

// --- End Function: sub_1403B1A90 (0x1403B1A90) ---

// --- Function: sub_1403B2140 (0x1403B2140) ---
__int64 sub_1403B2140()
{
  __int64 result; // rax
  _QWORD *v1; // rcx
  signed __int64 v2; // rbx

  result = qword_149C7BE08;
  if ( !qword_149C7BE08 )
  {
    v1 = (_QWORD *)sub_1402A65A0(8u);
    if ( v1 )
      *v1 = "@LOC_EMPTY";
    else
      v1 = 0;
    v2 = _InterlockedCompareExchange64(&qword_149C7BE08, (signed __int64)v1, 0);
    if ( v2 )
    {
      sub_1402A6590((__int64)v1);
      return v2;
    }
    else
    {
      return qword_149C7BE08;
    }
  }
  return result;
}

// --- End Function: sub_1403B2140 (0x1403B2140) ---

// --- Function: sub_1403B27D0 (0x1403B27D0) ---
_QWORD *__fastcall sub_1403B27D0(_QWORD *a1, _QWORD *a2)
{
  _DWORD *v2; // rax
  size_t Size; // rdi
  _DWORD *v6; // rax
  _DWORD *v7; // rdx
  _BYTE *Src_1; // rbx
  size_t Size_2; // rbp
  int *v10; // r14
  size_t Size_1; // rdi
  unsigned __int8 *Src_2; // rcx
  __int64 v13; // rdx
  unsigned __int64 n0x2D; // rax
  _DWORD *v15; // rax
  _BYTE *Src_3; // rcx
  unsigned __int64 Size_3; // rcx
  _DWORD *v19; // rax
  void *Src; // [rsp+40h] [rbp+8h] BYREF

  v2 = (_DWORD *)*a2;
  Src = (char *)&qword_149C78E84 + 4;
  Size = (int)v2[0xFFFFFFFE];
  if ( (_DWORD)Size )
  {
    v6 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)v6 + Size + 8) = 0;
    v7 = (_DWORD *)*a2;
    Src = v6 + 2;
    if ( v6 + 2 != v7 )
      memcpy(v6 + 2, v7, Size);
  }
  sub_1403D2570(&Src);
  Src_1 = Src;
  Size_2 = *((int *)Src + 0xFFFFFFFE);
  v10 = (int *)((char *)Src + 0xFFFFFFF8);
  Size_1 = Size_2;
  Src_2 = (unsigned __int8 *)Src + Size_2 + 0xFFFFFFFF;
  if ( Src_2 < Src )
  {
LABEL_9:
    *a1 = (char *)&qword_149C78E84 + 4;
    if ( !(_DWORD)Size_2 )
      goto LABEL_13;
    v15 = (_DWORD *)allocWithProfilerInfo(Size_2 + 9, 0);
    Src_3 = v15 + 2;
    *v15 = Size_2;
    v15[1] = Size_2;
    *((_BYTE *)v15 + Size_2 + 8) = 0;
    goto LABEL_11;
  }
  v13 = 0x200000000801LL;
  while ( 1 )
  {
    n0x2D = *Src_2;
    LOBYTE(n0x2D) = n0x2D - 0x2F;
    if ( (unsigned __int8)n0x2D <= 0x2Du )
    {
      if ( _bittest64(&v13, n0x2D) )
        break;
    }
    if ( --Src_2 < Src )
      goto LABEL_9;
  }
  *a1 = (char *)&qword_149C78E84 + 4;
  Size_3 = Src_2 - Src_1 + 1;
  if ( Size_3 < Size_2 )
  {
    Src_1 += Size_3;
    Size_1 = Size_2 - Size_3;
    if ( Size_2 != Size_3 )
    {
      v19 = (_DWORD *)allocWithProfilerInfo(Size_1 + 9, 0);
      Src_3 = v19 + 2;
      *v19 = Size_1;
      v19[1] = Size_1;
      *((_BYTE *)v19 + Size_1 + 8) = 0;
LABEL_11:
      *a1 = Src_3;
      if ( Src_3 != Src_1 )
        memcpy(Src_3, Src_1, Size_1);
    }
  }
LABEL_13:
  if ( v10[1] > 0 )
    sub_147715880(v10);
  return a1;
}

// --- End Function: sub_1403B27D0 (0x1403B27D0) ---

// --- Function: sub_1403B2CC0 (0x1403B2CC0) ---
float __fastcall sub_1403B2CC0(__int64 a1)
{
  return *(float *)(a1 + 0xF0);
}

// --- End Function: sub_1403B2CC0 (0x1403B2CC0) ---

// --- Function: sub_1403B4280 (0x1403B4280) ---
__int64 __fastcall sub_1403B4280(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rdi
  bool v7; // al
  __int64 v8; // [rsp+30h] [rbp+8h] BYREF

  if ( !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x88))
    || (result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x88) & 0xFFFFFFFFFFFFLL) + 0x668LL))(*(_QWORD *)(a1 + 0x88) & 0xFFFFFFFFFFFFLL)) == 0 )
  {
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x1D0LL))(v3);
    (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v4 + 0x100LL))(v4, &v8, *(_QWORD *)(a1 + 8));
    v5 = v8;
    if ( v8 )
    {
      v6 = (v8 & 0xF000000000000000uLL) != 0 ? v8 & 0xFFFFFF000000LL : (v8 & 0xFFFFFFFFFFFFLL) - 6;
      if ( *(_WORD *)(v6 + 2) == (HIWORD(v8) & 0xFFF) )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v7 = is_thread_privileged_or_bypass_mode(), v5 = v8, v7) )
          v7 = 1;
        if ( *(_WORD *)(v6 + 4) == 2 && v7 )
          return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v5 & 0xFFFFFFFFFFFFLL);
        if ( sub_140395410(&v8) )
        {
          v5 = v8;
          return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v5 & 0xFFFFFFFFFFFFLL);
        }
      }
    }
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x10LL))(qword_149C8DF28);
  }
  return result;
}

// --- End Function: sub_1403B4280 (0x1403B4280) ---

// --- Function: sub_1403B43C0 (0x1403B43C0) ---
__int64 __fastcall sub_1403B43C0(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B43C0 (0x1403B43C0) ---

// --- Function: sub_1403B43E0 (0x1403B43E0) ---
__int64 __fastcall sub_1403B43E0(__int64 a1)
{
  return *(unsigned int *)(a1 + 0xA8);
}

// --- End Function: sub_1403B43E0 (0x1403B43E0) ---

// --- Function: sub_1403B43F0 (0x1403B43F0) ---
_QWORD *__fastcall sub_1403B43F0(unsigned __int64 *a1, _QWORD *a2)
{
  if ( is_entity_descriptor_valid_or_accessible(a1) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B43F0 (0x1403B43F0) ---

// --- Function: j_psub_140338BA0 (0x1403B65B0) ---
// attributes: thunk
__int64 __fastcall j_psub_140338BA0()
{
  return psub_140338BA0();
}

// --- End Function: j_psub_140338BA0 (0x1403B65B0) ---

// --- Function: sub_1403B7230 (0x1403B7230) ---
__int64 sub_1403B7230()
{
  __int64 *v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(__int64 **)(NtCurrentTeb_w() + 0x10);
  result = *v0;
  if ( !*v0 )
  {
    v2 = (_QWORD *)sub_1402A65A0(0x828u);
    if ( v2 )
    {
      v2[3] = &p_Src;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *v0 = (__int64)v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 0xC0);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 0xC0) = v6 | 1;
      _tlregdtor(sub_1481CE000);
    }
    return *v0;
  }
  return result;
}

// --- End Function: sub_1403B7230 (0x1403B7230) ---

// --- Function: sub_1403B84E0 (0x1403B84E0) ---
__int64 __fastcall sub_1403B84E0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x128LL))(
           qword_149C8DFC0,
           a1,
           0);
}

// --- End Function: sub_1403B84E0 (0x1403B84E0) ---

// --- Function: sub_1403B92F0 (0x1403B92F0) ---
__int64 __fastcall sub_1403B92F0(__int64 a1, unsigned __int64 n4)
{
  if ( n4 >= 4 )
    return *(_QWORD *)(a1 + 0x20) + 8 * n4 - 0x20;
  else
    return a1 + 8 * n4;
}

// --- End Function: sub_1403B92F0 (0x1403B92F0) ---

// --- Function: sub_1403B9CD0 (0x1403B9CD0) ---
__int64 __fastcall sub_1403B9CD0(__int64 a1)
{
  return *(unsigned int *)(a1 + 0xC0);
}

// --- End Function: sub_1403B9CD0 (0x1403B9CD0) ---

// --- Function: sub_1403BA040 (0x1403BA040) ---
__m128 *__fastcall sub_1403BA040(__int64 a1, __int64 a2)
{
  _RBX = (__m128 *)a2;
  sub_1403651E0(a2, a1);
  __asm { vbroadcastss xmm1, dword ptr [rbx+5Ch] }
  _RBX[4] = _mm_mul_ps(_XMM1, _RBX[4]);
  _RBX[5].m128_f32[0] = _XMM1.m128_f32[0] * _RBX[5].m128_f32[0];
  _RBX[5].m128_f32[1] = _XMM1.m128_f32[0] * _RBX[5].m128_f32[1];
  _RBX[5].m128_i32[3] = 0x3F800000;
  return _RBX;
}

// --- End Function: sub_1403BA040 (0x1403BA040) ---

// --- Function: sub_1403BABD0 (0x1403BABD0) ---
__int64 __fastcall sub_1403BABD0(__int64 a1, __int64 a2, unsigned int a3)
{
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DF38 + 0x128LL))(
    qword_149C8DF38,
    a2,
    a1,
    a3);
  return a2;
}

// --- End Function: sub_1403BABD0 (0x1403BABD0) ---

// --- Function: sub_1403BAC10 (0x1403BAC10) ---
__int64 __fastcall sub_1403BAC10(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0x100LL))(qword_149C8DF38, a1);
}

// --- End Function: sub_1403BAC10 (0x1403BAC10) ---

// --- Function: sub_1403BAC50 (0x1403BAC50) ---
_QWORD *__fastcall sub_1403BAC50(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r14
  unsigned __int64 i; // rsi
  __int64 (__fastcall *v6)(__int64, __int64 *, char *); // rdi
  _QWORD *v7; // rax
  char v9; // [rsp+40h] [rbp+8h] BYREF
  __int64 v10; // [rsp+48h] [rbp+10h] BYREF

  v2 = qword_149C8DF38;
  *a2 = (char *)&qword_149C78E84 + 4;
  for ( i = 0;
        i < (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0x100LL))(qword_149C8DF38, a1);
        ++i )
  {
    if ( *(_DWORD *)(*a2 - 8LL) )
      sub_1403E4320(a2, word_1482C0F50, 1);
    v6 = *(__int64 (__fastcall **)(__int64, __int64 *, char *))(*(_QWORD *)v2 + 0x48LL);
    (*(void (__fastcall **)(__int64, char *, __int64, _QWORD))(*(_QWORD *)qword_149C8DF38 + 0x128LL))(
      qword_149C8DF38,
      &v9,
      a1,
      (unsigned int)i);
    v7 = (_QWORD *)v6(v2, &v10, &v9);
    sub_1403E4320(a2, *v7, *(int *)(*v7 - 8LL));
    if ( *(int *)(v10 - 4) > 0 )
      sub_147715880((const void *)(v10 - 8));
  }
  return a2;
}

// --- End Function: sub_1403BAC50 (0x1403BAC50) ---

// --- Function: sub_1403BADE0 (0x1403BADE0) ---
_QWORD *__fastcall sub_1403BADE0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r14
  unsigned __int64 i; // rsi
  __int64 (__fastcall *v6)(__int64, char *); // rbx
  __int64 v7; // rdx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char v11; // [rsp+40h] [rbp+8h] BYREF

  v2 = qword_149C8DF38;
  *a2 = (char *)&qword_149C78E84 + 4;
  for ( i = 0;
        i < (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0x100LL))(qword_149C8DF38, a1);
        ++i )
  {
    if ( *(_DWORD *)(*a2 - 8LL) )
      sub_1403E4320(a2, word_1482C0F50, 1);
    v6 = *(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v2 + 0x40LL);
    (*(void (__fastcall **)(__int64, char *, __int64, _QWORD))(*(_QWORD *)qword_149C8DF38 + 0x128LL))(
      qword_149C8DF38,
      &v11,
      a1,
      (unsigned int)i);
    v7 = v6(v2, &v11);
    if ( v7 )
    {
      v9 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v9;
      while ( *(_BYTE *)(v7 + v9) );
      v8 = (int)v9;
    }
    else
    {
      v8 = 0;
    }
    sub_1403E4320(a2, v7, v8);
  }
  return a2;
}

// --- End Function: sub_1403BADE0 (0x1403BADE0) ---

// --- Function: sub_1403BB1A0 (0x1403BB1A0) ---
__int64 __fastcall sub_1403BB1A0(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 0x28);
}

// --- End Function: sub_1403BB1A0 (0x1403BB1A0) ---

// --- Function: sub_1403BDD40 (0x1403BDD40) ---
bool __fastcall sub_1403BDD40(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0x100LL))(qword_149C8DF38, a1) != 0;
}

// --- End Function: sub_1403BDD40 (0x1403BDD40) ---

// --- Function: sub_1403BDE70 (0x1403BDE70) ---
bool __fastcall sub_1403BDE70(__int64 a1)
{
  return *(float *)(a1 + 0x5C) < 0.00000011920929;
}

// --- End Function: sub_1403BDE70 (0x1403BDE70) ---

// --- Function: sub_1403BE260 (0x1403BE260) ---
__int64 __fastcall sub_1403BE260(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      *(_QWORD *)(a1 + 8) = 0x40004;
      *(_DWORD *)(a1 + 4) = 0x3F800000;
      *(_DWORD *)a1 = 0x3F800000;
    }
  }
  else
  {
    result = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0;
  }
  return result;
}

// --- End Function: sub_1403BE260 (0x1403BE260) ---

// --- Function: sub_1403BE550 (0x1403BE550) ---
void sub_1403BE550()
{
  int v0; // ebx
  signed __int32 v1; // edi
  HMODULE hModule; // rax
  HMODULE hModule_1; // rbx
  HMODULE hModule_2; // rax

  if ( !byte_149C79025 )
  {
    v0 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( dword_149A5FFD8 == v0 )
    {
      ++dword_149A5FFDC;
    }
    else
    {
      v1 = _InterlockedCompareExchange(&dword_149A5FFC8, 1, 0);
      if ( v1 )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
          sub_1403C6EF0((__int64)&dword_149A5FFC8, v1, "InitProcAddresses");
        else
          sub_1403C7160((__int64)&dword_149A5FFC8, v1, "InitProcAddresses");
      }
      else
      {
        off_149A5FFD0 = *(char **)(NtCurrentTeb_w() + 0x20);
      }
      dword_149A5FFD8 = v0;
      if ( byte_149C79025 == 1 )
      {
LABEL_16:
        if ( dword_149A5FFDC )
        {
          --dword_149A5FFDC;
        }
        else
        {
          dword_149A5FFD8 = 0xFFFFFFFF;
          sub_1402DD7D0((__int64)&dword_149A5FFC8);
        }
        return;
      }
    }
    hModule = LoadLibraryA("KernelBase.dll");
    hModule_1 = hModule;
    if ( hModule )
    {
      qword_149C7B108 = (__int64)GetProcAddress(hModule, "GetThreadDescription");
      qword_149C7B110 = (__int64)GetProcAddress(hModule_1, "SetThreadDescription");
    }
    hModule_2 = LoadLibraryA("ntdll.dll");
    if ( hModule_2 )
      qword_149C7B118 = (__int64)GetProcAddress(hModule_2, "NtQueryInformationThread");
    byte_149C79025 = 1;
    goto LABEL_16;
  }
}

// --- End Function: sub_1403BE550 (0x1403BE550) ---

// --- Function: get_event_key_from_source_location (0x1403BF3E0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149C7B100;
  if ( !qword_149C7B100 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149C7B100 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BF3E0) ---

// --- Function: sub_1403C21C0 (0x1403C21C0) ---
__int64 __fastcall sub_1403C21C0(__int64 a1, int a2, __int64 a3)
{
  __int64 p_rw_lock_state; // rbp
  _QWORD *v6; // rsi
  signed __int64 v7; // rdi
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // r8
  __int64 v13; // rdx
  __int64 v14; // rcx
  void (__fastcall *v15)(__int64); // rax
  __int64 *v16; // rax
  _QWORD *v17; // rcx
  __int64 v19; // [rsp+20h] [rbp-38h] BYREF
  __int64 v20; // [rsp+28h] [rbp-30h]
  __int64 v21; // [rsp+30h] [rbp-28h]
  __int64 v22; // [rsp+38h] [rbp-20h]
  int v23; // [rsp+40h] [rbp-18h]
  _QWORD *v24; // [rsp+48h] [rbp-10h]

  p_rw_lock_state = a1 + 8;
  v6 = (_QWORD *)a1;
  if ( *(_DWORD *)(a1 + 0x18) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state + 0x14);
  }
  else
  {
    v7 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (v7 & 0x200000) != 0 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
        rw_lock_acquire_read_lock_profiled(p_rw_lock_state, v7, "SCigEventSystem::InvokeCallbacks", "m_callbackLock");
      else
        rw_lock_acquire_read_lock_unprofiled(p_rw_lock_state, v7, "SCigEventSystem::InvokeCallbacks", "m_callbackLock");
    }
  }
  v8 = v6[4];
  v9 = v6[5];
  if ( v8 != v9 )
  {
    while ( *(_DWORD *)v8 != a2 )
    {
      v8 += 0x20;
      if ( v8 == v9 )
        return rw_lock_release_read_lock(p_rw_lock_state);
    }
    v10 = 0;
    v19 = 0;
    v20 = (__int64)(*(_QWORD *)(v8 + 0x10) - *(_QWORD *)(v8 + 8)) >> 5;
    v11 = v20;
    v12 = *(_QWORD *)(v8 + 8);
    v13 = v6[0xE];
    v22 = v13;
    v21 = v12;
    v23 = a2;
    v24 = v6;
    v6[0xE] = &v19;
    if ( v11 > 0 )
    {
      while ( 1 )
      {
        v14 = v12 + 0x20 * v10 + 8;
        v15 = *(void (__fastcall **)(__int64))v14;
        if ( *(_QWORD *)(v14 + 8) == 1 )
          v15(a3);
        else
          ((void (__fastcall *)(__int64, __int64))v15)(v14, a3);
        v10 = v19 + 1;
        v19 = v10;
        if ( v10 >= v20 )
          break;
        v12 = v21;
      }
      v6 = v24;
      v13 = v22;
    }
    v16 = (__int64 *)v6[0xE];
    v17 = v6 + 0xE;
    if ( v16 )
    {
      while ( v16 != &v19 )
      {
        v17 = v16 + 3;
        v16 = (__int64 *)v16[3];
        if ( !v16 )
          return rw_lock_release_read_lock(p_rw_lock_state);
      }
      *v17 = v13;
    }
  }
  return rw_lock_release_read_lock(p_rw_lock_state);
}

// --- End Function: sub_1403C21C0 (0x1403C21C0) ---

// --- Function: sub_1403C3450 (0x1403C3450) ---
bool __fastcall sub_1403C3450(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403C3450 (0x1403C3450) ---

// --- Function: sub_1403C4E50 (0x1403C4E50) ---
bool __fastcall sub_1403C4E50(__int64 a1)
{
  return *(_DWORD *)(a1 + 0x18) != 0;
}

// --- End Function: sub_1403C4E50 (0x1403C4E50) ---

// --- Function: sub_1403C6E80 (0x1403C6E80) ---
__int64 __fastcall sub_1403C6E80(__int64 a1, unsigned int a2, __int64 a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return sub_1403C6EF0(a1, a2, a3);
  else
    return sub_1403C7160(a1, a2, a3);
}

// --- End Function: sub_1403C6E80 (0x1403C6E80) ---

// --- Function: sub_1403C6EF0 (0x1403C6EF0) ---
__int64 __fastcall sub_1403C6EF0(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_Src; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_Src_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149C8E038;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149C89AA0(
            &n0x1600,
            &word_149C7BF34,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_Src = &p_Src;
          HIWORD(n0x1600) = word_149C7BF34;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src);
          qword_149C89AE0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149C89AA8(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF38,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_Src_1 = &p_Src;
          HIWORD(n0x1600_1) = word_149C7BF38;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C6EF0 (0x1403C6EF0) ---

// --- Function: sub_1403C7160 (0x1403C7160) ---
__int64 __fastcall sub_1403C7160(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_Src; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_Src_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF2C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_Src = &p_Src;
        HIWORD(n0x1600) = word_149C7BF2C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a3);
        v15 = a2;
        qword_149C78FC8(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149C89AA8(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF30,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_Src_1 = &p_Src;
          HIWORD(n0x1600_1) = word_149C7BF30;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a3);
          v16[0] = v12;
          qword_149C78FC8(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C7160 (0x1403C7160) ---

// --- Function: sub_1403C7440 (0x1403C7440) ---
char **__fastcall sub_1403C7440(char **a1)
{
  char *v1; // r9
  char v3; // al
  char v4; // cl

  v1 = *a1;
  v3 = **a1;
  if ( v3 )
  {
    do
    {
      ++v1;
      v4 = v3 + 0x20;
      if ( (unsigned __int8)(v3 - 0x41) > 0x19u )
        v4 = v3;
      v1[0xFFFFFFFF] = v4;
      v3 = *v1;
    }
    while ( *v1 );
  }
  return a1;
}

// --- End Function: sub_1403C7440 (0x1403C7440) ---

// --- Function: sub_1403C7C90 (0x1403C7C90) ---
__int64 __fastcall sub_1403C7C90(__int64 a1, unsigned __int8 *a2)
{
  __int64 result; // rax

  result = *a2;
  *(_BYTE *)a1 = result;
  if ( *a2 != 1 )
  {
    *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
    result = 0;
    *(_OWORD *)(a1 + 0x10) = 0;
    *(_QWORD *)(a1 + 0x20) = 0;
    *(_QWORD *)(a1 + 0x28) = 0;
    *(__m256i *)(a1 + 0x10) = *(__m256i *)(a2 + 0x10);
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0xF;
    a2[0x10] = 0;
    *(_OWORD *)(a1 + 0x30) = 0;
    *(_QWORD *)(a1 + 0x40) = 0;
    *(_QWORD *)(a1 + 0x48) = 0;
    *(__m256i *)(a1 + 0x30) = *(__m256i *)(a2 + 0x30);
    *((_QWORD *)a2 + 8) = 0;
    *((_QWORD *)a2 + 9) = 0xF;
    a2[0x30] = 0;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1403C7C90 (0x1403C7C90) ---

// --- Function: sub_1403C83B0 (0x1403C83B0) ---
void __fastcall sub_1403C83B0(volatile signed __int32 *a1)
{
  signed __int32 v2; // ecx
  signed __int32 v3; // eax
  signed __int32 v4; // [rsp+8h] [rbp+8h]

  v2 = *a1;
  HIWORD(v4) = HIWORD(v2);
  if ( (_WORD)v2 )
  {
    while ( 1 )
    {
      LOWORD(v4) = 0;
      v3 = _InterlockedCompareExchange(a1, v4, v2);
      if ( v3 == v2 )
        break;
      HIWORD(v4) = HIWORD(v3);
      v2 = v3;
      if ( !(_WORD)v3 )
        return;
    }
    qword_149C89B38();
  }
}

// --- End Function: sub_1403C83B0 (0x1403C83B0) ---

// --- Function: sub_1403C8EA0 (0x1403C8EA0) ---
__int64 *__fastcall sub_1403C8EA0(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // rbx
  int v7; // r15d
  signed __int32 v8; // edi
  __int64 v9; // rcx
  __int64 v10; // rdi
  char v11; // al
  int v12; // eax
  void (__fastcall *v13)(char *); // rax
  volatile signed __int32 *v14; // rbx
  volatile signed __int32 *v15; // rbx
  __int64 v16; // rcx
  __int64 v17; // rax
  char v19[8]; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v20; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v21[4]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v22[4]; // [rsp+50h] [rbp-B0h] BYREF
  char v23; // [rsp+70h] [rbp-90h]
  unsigned __int8 v24[8]; // [rsp+80h] [rbp-80h] BYREF
  __int64 v25; // [rsp+88h] [rbp-78h] BYREF
  __m256i v26; // [rsp+90h] [rbp-70h] BYREF
  __m256i v27; // [rsp+B0h] [rbp-50h] BYREF
  char v28; // [rsp+D0h] [rbp-30h]
  unsigned __int8 v29[8]; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v30; // [rsp+E0h] [rbp-20h] BYREF
  __m256i v31; // [rsp+E8h] [rbp-18h] BYREF
  __m256i v32; // [rsp+108h] [rbp+8h] BYREF
  char v33; // [rsp+128h] [rbp+28h]

  v3 = *a1;
  v23 = 0;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v8 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
        sub_1403C6EF0(v3, v8, "CFuture<class CigOptionalErrorResult<struct CigError> >::OnResolved");
      else
        sub_1403C7160(v3, v8, "CFuture<class CigOptionalErrorResult<struct CigError> >::OnResolved");
    }
    else
    {
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    }
    *(_DWORD *)(v3 + 0x10) = v7;
  }
  if ( *(_BYTE *)(*a1 + 0x39) )
    goto LABEL_48;
  v9 = a1[2];
  if ( !*(_BYTE *)(*a1 + 0x38) )
  {
    sub_1403DA270(v9, a3);
    goto LABEL_48;
  }
  v10 = v9 + 0xC8;
  v33 = 0;
  v28 = 0;
  if ( *(_BYTE *)(v9 + 0x118) )
  {
    sub_1403C7C90((__int64)v24, (unsigned __int8 *)(v9 + 0xC8));
    v28 = 1;
  }
  v11 = *(_BYTE *)(v10 + 0x50);
  if ( v33 )
  {
    if ( v11 )
    {
      if ( v29 != (unsigned __int8 *)v10 )
      {
        if ( *(_BYTE *)v10 == v29[0] )
        {
          if ( v29[0] != 1 )
          {
            *(_DWORD *)(v10 + 8) = v30;
            sub_1402FD790((__int64 *)(v10 + 0x10), &v31);
            sub_1402FD790((__int64 *)(v10 + 0x30), &v32);
          }
        }
        else
        {
          if ( *(_BYTE *)v10 != 1 )
            sub_14037A850((_QWORD *)(v10 + 8));
          sub_1403C7C90(v10, v29);
        }
      }
    }
    else
    {
      sub_1403C7C90(v10, v29);
      *(_BYTE *)(v10 + 0x50) = 1;
    }
  }
  else if ( v11 )
  {
    if ( *(_BYTE *)v10 != 1 )
      sub_14037A850((_QWORD *)(v10 + 8));
    *(_BYTE *)(v10 + 0x50) = 0;
  }
  if ( v28 )
  {
    if ( v23 )
    {
      if ( v19[0] == v24[0] )
      {
        if ( v24[0] != 1 )
        {
          LODWORD(v20) = v25;
          sub_1402FD790(v21, &v26);
          sub_1402FD790(v22, &v27);
        }
      }
      else
      {
        if ( v19[0] != 1 )
          sub_14037A850(&v20);
        sub_1403C7C90((__int64)v19, v24);
      }
    }
    else
    {
      sub_1403C7C90((__int64)v19, v24);
      v23 = 1;
    }
LABEL_41:
    if ( v28 && v24[0] != 1 )
      sub_14037A850(&v25);
    goto LABEL_44;
  }
  if ( v23 )
  {
    if ( v19[0] != 1 )
      sub_14037A850(&v20);
    v23 = 0;
    goto LABEL_41;
  }
LABEL_44:
  if ( v33 && v29[0] != 1 )
    sub_14037A850(&v30);
LABEL_48:
  v12 = *(_DWORD *)(v3 + 0x14);
  if ( v12 )
  {
    *(_DWORD *)(v3 + 0x14) = v12 - 1;
  }
  else
  {
    *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
    sub_1402DD7D0(v3);
  }
  if ( v23 )
  {
    v13 = *(void (__fastcall **)(char *))a3;
    if ( *(_QWORD *)(a3 + 8) == 1 )
      v13(v19);
    else
      ((void (__fastcall *)(__int64, char *))v13)(a3, v19);
    v14 = (volatile signed __int32 *)a1[1];
    *a1 = 0;
    a1[1] = 0;
    if ( v14 )
    {
      if ( _InterlockedExchangeAdd(v14 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v14)(v14);
        if ( _InterlockedExchangeAdd(v14 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v14 + 8LL))(v14);
      }
    }
  }
  v15 = (volatile signed __int32 *)a1[3];
  a1[2] = 0;
  a1[3] = 0;
  if ( v15 )
  {
    if ( _InterlockedExchangeAdd(v15 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
      if ( _InterlockedExchangeAdd(v15 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8LL))(v15);
    }
  }
  v16 = *a1;
  v17 = a1[1];
  *a1 = 0;
  a1[1] = 0;
  *a2 = v16;
  a2[1] = v17;
  if ( v23 && v19[0] != 1 )
    sub_14037A850(&v20);
  return a2;
}

// --- End Function: sub_1403C8EA0 (0x1403C8EA0) ---

// --- Function: sub_1403CE280 (0x1403CE280) ---
__int64 __fastcall sub_1403CE280(__int64 a1)
{
  __int128 v1; // xmm6
  __int64 v2; // r12
  __m128i v4; // xmm6
  int v5; // ebp
  signed __int32 v6; // esi
  __m128i *v7; // rax
  int v8; // eax
  __int64 v9; // rax
  signed __int64 epi64; // r14
  __int64 v11; // rbp
  __int64 v12; // r15
  __int64 v13; // rbx
  __int64 v14; // rsi
  void (__fastcall *v15)(__int64); // rax
  __int64 v16; // rax
  _QWORD *i; // rbx
  void (__fastcall *n2)(__int64, _QWORD *); // r9
  char v20; // [rsp+20h] [rbp-58h] BYREF
  __int128 v21; // [rsp+40h] [rbp-38h]

  v21 = v1;
  v2 = 0;
  v4 = 0;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x50) == v5 )
  {
    ++*(_DWORD *)(a1 + 0x54);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x40), 1, 0);
    if ( v6 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
        sub_1403C6EF0(a1 + 0x40, v6, "SCigEventSystem::PullEvents");
      else
        sub_1403C7160(a1 + 0x40, v6, "SCigEventSystem::PullEvents");
    }
    else
    {
      *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    }
    *(_DWORD *)(a1 + 0x50) = v5;
  }
  v7 = (__m128i *)(a1 + 0x58);
  if ( &v20 != (char *)(a1 + 0x58) )
  {
    v4 = *v7;
    v2 = *(_QWORD *)(a1 + 0x68);
    v7->m128i_i64[0] = 0;
    *(_QWORD *)(a1 + 0x60) = 0;
    *(_QWORD *)(a1 + 0x68) = 0;
  }
  v8 = *(_DWORD *)(a1 + 0x54);
  if ( v8 )
  {
    *(_DWORD *)(a1 + 0x54) = v8 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x50) = 0xFFFFFFFF;
    sub_1402DD7D0(a1 + 0x40);
  }
  v9 = psub_140338BC0();
  epi64 = _mm_extract_epi64(v4, 1);
  v11 = v4.m128i_i64[0];
  *(_QWORD *)(v9 + 8LL * (*(_QWORD *)(v9 + 0x20))++) = a1;
  v12 = (epi64 - v4.m128i_i64[0]) / 0x18;
  if ( v12 )
  {
    v13 = v4.m128i_i64[0];
    v14 = (epi64 - v4.m128i_i64[0]) / 0x18;
    do
    {
      v15 = *(void (__fastcall **)(__int64))v13;
      if ( *(_QWORD *)(v13 + 8) == 1 )
        v15(a1);
      else
        ((void (__fastcall *)(__int64, __int64))v15)(v13, a1);
      v13 += 0x18;
      --v14;
    }
    while ( v14 );
  }
  v16 = psub_140338BC0();
  *(_QWORD *)(v16 + 8LL * (*(_QWORD *)(v16 + 0x20))--) = 0;
  if ( v4.m128i_i64[0] )
  {
    for ( i = (_QWORD *)v4.m128i_i64[0]; i != (_QWORD *)epi64; i += 3 )
    {
      n2 = (void (__fastcall *)(__int64, _QWORD *))i[1];
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, i);
        i[1] = 0;
      }
      *i = 0;
    }
    if ( (unsigned __int64)(0x18 * ((v2 - v4.m128i_i64[0]) / 0x18)) >= 0x1000 )
    {
      v11 = *(_QWORD *)(v4.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v4.m128i_i64[0] - v11 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A6590(v11);
  }
  return (unsigned int)v12;
}

// --- End Function: sub_1403CE280 (0x1403CE280) ---

// --- Function: sub_1403CE4A0 (0x1403CE4A0) ---
unsigned __int64 __fastcall sub_1403CE4A0(__int64 a1, unsigned __int64 a2, signed __int64 *a3)
{
  signed __int64 v6; // rdi
  unsigned __int64 v7; // r15
  int v8; // ebp
  signed __int32 v9; // r12d
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  __int64 v12; // rbp
  unsigned __int64 v13; // r9
  int v14; // eax

  v6 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 0x20), a2);
  v7 = v6 + a2;
  if ( v6 + a2 > *(_QWORD *)(a1 + 0x28) )
  {
    v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x48) == v8 )
    {
      ++*(_DWORD *)(a1 + 0x4C);
    }
    else
    {
      v9 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x38), 1, 0);
      if ( v9 )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
          sub_1403C6EF0(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
        else
          sub_1403C7160(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
      }
      else
      {
        *(_QWORD *)(a1 + 0x40) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      }
      *(_DWORD *)(a1 + 0x48) = v8;
    }
    v10 = *(_QWORD *)(a1 + 0x28);
    if ( v7 > v10 )
    {
      v11 = (v7 - v10) % *(_QWORD *)(a1 + 0x30);
      v12 = *(_QWORD *)(a1 + 0x30) + v7 - v10 - v11;
      v13 = *(_QWORD *)(a1 + 0x30) + v7 - v11;
      if ( v13 > *(_QWORD *)(a1 + 8) )
        LogFatalError(
          "Not enough storage reserved for thread safe container. Allocating %zu, Page size %u, Required %zu, Reserved %zu",
          a2,
          *(_DWORD *)(a1 + 0x14),
          v13,
          *(_QWORD *)(a1 + 8));
      sub_140572BD0(a1, *(_QWORD *)a1 + *(_QWORD *)(a1 + 0x28), v12);
      *(_QWORD *)(a1 + 0x28) += v12;
    }
    v14 = *(_DWORD *)(a1 + 0x4C);
    if ( v14 )
    {
      *(_DWORD *)(a1 + 0x4C) = v14 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x48) = 0xFFFFFFFF;
      sub_1402DD7D0(a1 + 0x38);
    }
  }
  if ( a3 )
    *a3 = v6;
  return v7 + *(_QWORD *)a1 - a2;
}

// --- End Function: sub_1403CE4A0 (0x1403CE4A0) ---

// --- Function: rw_lock_acquire_read_lock_dispatch (0x1403CF2D0) ---
// Dispatches to either a profiled read lock acquisition function
// (`rw_lock_acquire_read_lock_profiled`) or a standard, unprofiled one
// (`rw_lock_acquire_read_lock_unprofiled`). The choice depends on a boolean flag
// (`is_profiled_mode`), a debug flag within the thread context (at offset `0x1C`),
// and the availability of the global environment (`gEnv`).
double __fastcall rw_lock_acquire_read_lock_dispatch(
        __int64 a1,
        signed __int64 a2,
        const char *a3,
        const char *a4,
        char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return rw_lock_acquire_read_lock_profiled(a1, a2, a3, a4);
  else
    return rw_lock_acquire_read_lock_unprofiled(a1, a2, a3, a4);
}

// --- End Function: rw_lock_acquire_read_lock_dispatch (0x1403CF2D0) ---

// --- Function: rw_lock_acquire_read_lock_profiled (0x1403CF350) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended, it retries. Upon successful acquisition,
// it logs detailed profiling information, including timestamps, lock name, lock
// owner, and caller, using a dedicated profiling system.
void __fastcall rw_lock_acquire_read_lock_profiled(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_Src; // rdx
  _BYTE v18[16]; // [rsp+30h] [rbp-29h] BYREF
  int n0x1600; // [rsp+40h] [rbp-19h] BYREF
  __int64 v20; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v22; // [rsp+50h] [rbp-9h]
  unsigned __int64 v23; // [rsp+58h] [rbp-1h]
  __int64 v24; // [rsp+60h] [rbp+7h]
  __int64 v25; // [rsp+68h] [rbp+Fh]
  char v26; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149C8E038;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 0xF8LL))(v4, v18, &v26);
  if ( (a2 & 0x200000) == 0 )
    return;
  v12 = (unsigned __int64)v11 << 0x20;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 0x124) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n0x1600 = 0x1600;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v20 = 1;
      n2 = 2;
      v22 = __rdtsc();
      qword_149C89AA0(
        &n0x1600,
        &word_149C7BF44,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      v15 = word_149C7BF44;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return;
  }
  *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n0x1600 = 0x1600;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v20 = 1;
  n2 = 2;
  v22 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_149C7BF48,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  v15 = word_149C7BF48;
LABEL_10:
  HIWORD(n0x1600) = v15;
  qword_149C89AE0("Lock: %s", a4);
  p_p_Src = &p_Src;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_Src = *(const ULONG_PTR **)(a1 + 8);
  qword_149C89AE0("LockOwner: %s", p_p_Src);
  qword_149C89AE0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 0xE8LL))(v4, v11);
  v23 = __rdtsc();
  qword_149C89AA8(&n0x1600);
}

// --- End Function: rw_lock_acquire_read_lock_profiled (0x1403CF350) ---

// --- Function: rw_lock_acquire_read_lock_unprofiled (0x1403CF580) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by a writer). It then attempts to atomically set the read lock flag using
// `_InterlockedCompareExchange64`. Upon successful acquisition, it logs basic
// information about the lock, its owner, and the caller. This version does not
// include detailed performance profiling.
void __fastcall rw_lock_acquire_read_lock_unprofiled(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_Src_1; // rdx
  int *p_n0x1600; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_Src; // rdx
  int v14; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v15[3]; // [rsp+34h] [rbp-65h] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v17; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v19; // [rsp+50h] [rbp-49h]
  unsigned __int64 v20; // [rsp+58h] [rbp-41h]
  __int64 v21; // [rsp+60h] [rbp-39h]
  __int64 v22; // [rsp+68h] [rbp-31h]
  int n0x1600; // [rsp+90h] [rbp-9h] BYREF
  __int64 v24; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v26; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+Fh]
  __int64 v28; // [rsp+B0h] [rbp+17h]
  __int64 v29; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x128LL))(qword_149C8E038, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n0x1600 = 0x1600;
        v24 = 1;
        n2 = 2;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v26 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF40,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(n0x1600) = word_149C7BF40;
        qword_149C89AE0("Lock: %s", a4);
        p_p_Src = &p_Src;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a3);
        v15[0] = v10;
        qword_149C78FC8(a1, v15, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n0x1600 = &n0x1600;
        v27 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return;
    }
    n0x1600_1 = 0x1600;
    v17 = 1;
    n2_1 = 2;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v19 = __rdtsc();
    qword_149C89AA0(
      &n0x1600_1,
      &word_149C7BF3C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(n0x1600_1) = word_149C7BF3C;
    qword_149C89AE0("Lock: %s", a4);
    p_p_Src_1 = &p_Src;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149C89AE0("LockOwner: %s", p_p_Src_1);
    qword_149C89AE0("Caller: %s", a3);
    v14 = v6;
    qword_149C78FC8(a1, &v14, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n0x1600 = &n0x1600_1;
    v20 = __rdtsc();
LABEL_13:
    qword_149C89AA8(p_n0x1600);
    goto LABEL_14;
  }
}

// --- End Function: rw_lock_acquire_read_lock_unprofiled (0x1403CF580) ---

// --- Function: rw_lock_handle_release_contention (0x1403CF7F0) ---
// Handles the release of a read-write lock when contention or specific lock flags
// are present. It continuously attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`. Depending on the resulting lock state, it may
// trigger further release operations (e.g., waking waiting threads via
// `qword_149B3B488`) or update thread context information related to lock
// ownership and counts.
__int64 __fastcall rw_lock_handle_release_contention(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v8 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
      break;
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
      return result;
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
    return qword_149C78FD0(a1, v4);
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v11,
      &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v7 & (v9 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(
             qword_149C8E038,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: rw_lock_handle_release_contention (0x1403CF7F0) ---

// --- Function: sub_1403D30D0 (0x1403D30D0) ---
__int64 __fastcall sub_1403D30D0(__int64 a1, unsigned __int8 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0xB8LL))(
           qword_149C8DFC8,
           a1,
           a2);
}

// --- End Function: sub_1403D30D0 (0x1403D30D0) ---

// --- Function: sub_1403D37D0 (0x1403D37D0) ---
void __fastcall sub_1403D37D0(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rdi

  *(_QWORD *)(a1 + 0x20) = 0;
  if ( a2 != 0xFFFFFFFFFFFFFFFFuLL )
  {
    v3 = *(_QWORD *)(a1 + 0x28);
    v4 = ~(*(unsigned int *)(a1 + 0x14) - 1LL) & (*(unsigned int *)(a1 + 0x14) + a2 - 1);
    if ( v4 < v3 )
    {
      sub_140572C50(a1, v4 + *(_QWORD *)a1, v3 - v4, 0);
      *(_QWORD *)(a1 + 0x28) = v4;
    }
  }
}

// --- End Function: sub_1403D37D0 (0x1403D37D0) ---

// --- Function: sub_1403D3830 (0x1403D3830) ---
__int64 __fastcall sub_1403D3830(__int64 a1)
{
  unsigned __int64 n4; // rdi
  __int64 v3; // rdx
  bool v4; // zf
  unsigned __int64 v5; // rdx
  __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  __int64 result; // rax

  n4 = 4;
  if ( *(_WORD *)(a1 + 0x28) > 4u )
  {
    do
    {
      v3 = *(_QWORD *)(a1 + 0x20) - 0x20LL;
      v4 = *(_DWORD *)(v3 + 8 * n4) == 0xF0000000;
      v5 = v3 + 8 * n4;
      if ( !v4 )
        (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v5);
      v6 = *(_QWORD *)(a1 + 0x20) - 0x1CLL;
      v4 = *(_DWORD *)(v6 + 8 * n4) == 0xF0000000;
      v7 = v6 + 8 * n4;
      if ( !v4 )
        (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, v7);
      ++n4;
    }
    while ( n4 < *(unsigned __int16 *)(a1 + 0x28) );
  }
  sub_147715880(*(const void **)(a1 + 0x20));
  result = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x28) = 0;
  if ( *(_DWORD *)a1 != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(qword_149C8DF38, a1);
  if ( *(_DWORD *)(a1 + 4) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 4);
  if ( *(_DWORD *)(a1 + 8) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 8);
  if ( *(_DWORD *)(a1 + 0xC) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 0xC);
  if ( *(_DWORD *)(a1 + 0x10) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 0x10);
  if ( *(_DWORD *)(a1 + 0x14) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 0x14);
  if ( *(_DWORD *)(a1 + 0x18) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
               qword_149C8DF38,
               a1 + 0x18);
  if ( *(_DWORD *)(a1 + 0x1C) != 0xF0000000 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF38 + 0xF8LL))(
             qword_149C8DF38,
             a1 + 0x1C);
  return result;
}

// --- End Function: sub_1403D3830 (0x1403D3830) ---

// --- Function: sub_1403DA270 (0x1403DA270) ---
__int64 (__fastcall *__fastcall sub_1403DA270(_OWORD *a1, _QWORD *a2))(_QWORD, _QWORD)
{
  int *ThreadLogContextSlot; // rax
  _QWORD *v5; // rbx
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  __int64 (__fastcall *n2_1)(_QWORD, _QWORD); // rax

  ThreadLogContextSlot = getThreadLogContextSlot();
  *a1 = *(_OWORD *)ThreadLogContextSlot;
  a1[1] = *((_OWORD *)ThreadLogContextSlot + 1);
  a1[2] = *((_OWORD *)ThreadLogContextSlot + 2);
  a1[3] = *((_OWORD *)ThreadLogContextSlot + 3);
  a1[4] = *((_OWORD *)ThreadLogContextSlot + 4);
  a1[5] = *((_OWORD *)ThreadLogContextSlot + 5);
  a1[6] = *((_OWORD *)ThreadLogContextSlot + 6);
  a1[7] = *((_OWORD *)ThreadLogContextSlot + 7);
  a1[8] = *((_OWORD *)ThreadLogContextSlot + 8);
  a1[9] = *((_OWORD *)ThreadLogContextSlot + 9);
  a1[0xA] = *((_OWORD *)ThreadLogContextSlot + 0xA);
  v5 = a1 + 0xB;
  n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))v5[1];
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, v5, 0);
    v5[1] = 0;
  }
  *v5 = 0;
  n2_1 = (__int64 (__fastcall *)(_QWORD, _QWORD))a2[1];
  if ( n2_1 == (__int64 (__fastcall *)(_QWORD, _QWORD))1 )
  {
    *v5 = *a2;
    v5[1] = a2[1];
  }
  else
  {
    if ( !n2_1 )
      return n2_1;
    ((void (__fastcall *)(__int64, _QWORD *, _QWORD *))n2_1)(1, v5, a2);
  }
  n2_1 = (__int64 (__fastcall *)(_QWORD, _QWORD))a2[1];
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1 = (__int64 (__fastcall *)(_QWORD, _QWORD))n2_1(2, a2);
    a2[1] = 0;
  }
  *a2 = 0;
  return n2_1;
}

// --- End Function: sub_1403DA270 (0x1403DA270) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403DAA60) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = n2_4;
  if ( !n2_4 )
  {
    v1 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
           qword_149C8DFD0,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    n2_4 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403DAA60) ---

// --- Function: sub_1403DAB30 (0x1403DAB30) ---
unsigned __int64 __fastcall sub_1403DAB30(__int64 a1)
{
  int v2; // esi
  signed __int32 v3; // ebp
  int v4; // eax
  unsigned __int64 result; // rax
  __int64 v6; // rcx
  signed __int32 v7; // [rsp+40h] [rbp+8h]

  v2 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x18) == v2 )
  {
    ++*(_DWORD *)(a1 + 0x1C);
  }
  else
  {
    v3 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 8), 1, 0);
    if ( v3 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
        sub_1403C6EF0(a1 + 8, v3, "CIGEvent::Signal");
      else
        sub_1403C7160(a1 + 8, v3, "CIGEvent::Signal");
    }
    else
    {
      *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    }
    *(_DWORD *)(a1 + 0x18) = v2;
  }
  *(_DWORD *)a1 = 1;
  v4 = *(_DWORD *)(a1 + 0x1C);
  if ( v4 )
  {
    result = (unsigned int)(v4 - 1);
    *(_DWORD *)(a1 + 0x1C) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFF;
    result = (unsigned __int64)sub_1402DD7D0(a1 + 8);
  }
  v6 = *(unsigned int *)(a1 + 0x20);
  HIWORD(v7) = HIWORD(*(_DWORD *)(a1 + 0x20));
  if ( (_WORD)v6 )
  {
    while ( 1 )
    {
      LOWORD(v7) = 0;
      result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x20), v7, v6);
      if ( (_DWORD)result == (_DWORD)v6 )
        break;
      HIWORD(v7) = WORD1(result);
      v6 = (unsigned int)result;
      if ( !(_WORD)result )
        return result;
    }
    return qword_149C89B38(v6, WORD1(v6), WORD1(result), 0);
  }
  return result;
}

// --- End Function: sub_1403DAB30 (0x1403DAB30) ---

// --- Function: sub_1403DAC90 (0x1403DAC90) ---
char __fastcall sub_1403DAC90(_DWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v6; // r8
  int v7; // r14d
  signed __int32 v8; // esi
  int v9; // eax

  v3 = (__int64)(a1 + 2);
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v8 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
        sub_1403C6EF0(v3, v8, (const char *)&p_Src);
      else
        sub_1403C7160(v3, v8, (const char *)&p_Src);
    }
    else
    {
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    }
    *(_DWORD *)(v3 + 0x10) = v7;
  }
  while ( !*a1 )
  {
    LOBYTE(v6) = 2;
    sub_1403E1B60(a1 + 8, v3, v6, a3);
  }
  *a1 = 0;
  v9 = *(_DWORD *)(v3 + 0x14);
  if ( v9 )
  {
    *(_DWORD *)(v3 + 0x14) = v9 - 1;
  }
  else
  {
    *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
    sub_1402DD7D0(v3);
  }
  return 1;
}

// --- End Function: sub_1403DAC90 (0x1403DAC90) ---

// --- Function: sub_1403DF590 (0x1403DF590) ---
const ULONG_PTR *__fastcall sub_1403DF590(__int64 a1, __int64 a2)
{
  unsigned __int32 i; // edi
  unsigned int v4; // ebx
  signed __int32 v5; // eax
  const ULONG_PTR *p_Src; // rax
  int v7; // [rsp+50h] [rbp+8h] BYREF
  int v8; // [rsp+58h] [rbp+10h] BYREF
  __int64 v9; // [rsp+60h] [rbp+18h] BYREF
  __int64 v10; // [rsp+68h] [rbp+20h] BYREF

  for ( i = a2; ; i = v5 )
  {
    v4 = i & 0xFFFFFFFE;
    if ( (i & 0xFFFE) == 0 && (i & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v9,
        &v8);
      v4 = (unsigned __int16)v4;
      a2 = *(unsigned int *)(((((unsigned __int64)i >> 0x10) & (unsigned int)(v8 - 1)) << 9) + v9 + 0x124);
      if ( (_DWORD)a2 != 0xFFFFFFFF )
      {
        a2 = (unsigned int)((_DWORD)a2 << 0x10);
        v4 = a2 | (unsigned __int16)v4;
      }
    }
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, i);
    if ( i == v5 )
      break;
  }
  if ( (i & 0xFFFE) != 0 )
  {
    qword_149C78FD0(a1, a2);
  }
  else if ( (i & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v10,
      &v7);
    *(_DWORD *)(((HIWORD(i) & (unsigned __int64)(unsigned int)(v7 - 1)) << 9) + v10 + 0x11C) = (unsigned __int16)(HIWORD(i) + v7);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(qword_149C8E038);
  }
  p_Src = &::p_Src;
  *(_QWORD *)(a1 + 8) = &::p_Src;
  return p_Src;
}

// --- End Function: sub_1403DF590 (0x1403DF590) ---

// --- Function: sub_1403DF920 (0x1403DF920) ---
__int64 __fastcall sub_1403DF920(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  double v7; // xmm3_8
  double v8; // xmm4_8
  __int64 result; // rax
  _QWORD *v12; // rbx
  _QWORD *v13; // rdi
  __int64 v14; // r14
  __int64 v15; // rdi
  __int64 v16; // rbp
  volatile signed __int32 *v17; // rbx
  __int64 v18; // rdi
  __int64 v19; // rax
  float v20; // [rsp+80h] [rbp+18h] BYREF
  __int64 v21; // [rsp+88h] [rbp+20h]

  v21 = a4;
  if ( a3 != *(_DWORD *)(a1 + 0x48) )
    goto LABEL_3;
  v7 = *(double *)(a2 + 8) - *(double *)(a1 + 0x38);
  v8 = *(double *)(a2 + 0x10) - *(double *)(a1 + 0x40);
  result = (unsigned int)(dword_149A5EC04 * dword_149A5EC04);
  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, eax }
  if ( (*(double *)a2 - *(double *)(a1 + 0x30)) * (*(double *)a2 - *(double *)(a1 + 0x30)) + v7 * v7 + v8 * v8 > *(double *)&_XMM0 )
  {
LABEL_3:
    v12 = *(_QWORD **)a1;
    v13 = *(_QWORD **)(a1 + 8);
    v14 = 0;
    if ( *(_QWORD **)a1 != v13 )
    {
      do
      {
        if ( *v12 )
          (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v12 + 0x10LL))(*v12);
        *v12++ = 0;
      }
      while ( v12 != v13 );
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
    }
    v15 = *(_QWORD *)(a1 + 0x18);
    v16 = *(_QWORD *)(a1 + 0x20);
    if ( v15 != v16 )
    {
      do
      {
        v17 = *(volatile signed __int32 **)(v15 + 8);
        if ( v17 )
        {
          if ( _InterlockedExchangeAdd(v17 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v17)(v17);
            if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v17 + 8LL))(v17);
          }
        }
        v15 += 0x10;
      }
      while ( v15 != v16 );
      *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a1 + 0x18);
    }
    v18 = v21;
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(v21 + 8)) )
      v14 = *(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFLL;
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x670LL))(v14);
    if ( a3 == (_DWORD)result )
    {
      v19 = *(_QWORD *)qword_149C8E0C8;
      v20 = (float)dword_149A5EC08;
      result = (*(__int64 (__fastcall **)(__int64, __int64, float *, __int64, __int64, __int64))(v19 + 0x5B0))(
                 qword_149C8E0C8,
                 a2,
                 &v20,
                 a1,
                 a1 + 0x18,
                 v18);
    }
    *(_DWORD *)(a1 + 0x48) = a3;
    *(_OWORD *)(a1 + 0x30) = *(_OWORD *)a2;
    *(double *)(a1 + 0x40) = *(double *)(a2 + 0x10);
  }
  return result;
}

// --- End Function: sub_1403DF920 (0x1403DF920) ---

// --- Function: sub_1403E1120 (0x1403E1120) ---
__int64 __fastcall sub_1403E1120(__int64 a1, unsigned __int64 a2, __int64 a3, const char *a4, const char *a5, char a6)
{
  if ( a6 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403E1120 (0x1403E1120) ---

// --- Function: rw_lock_acquire_write_lock_profiled (0x1403E11B0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended (e.g., by readers or another writer), it
// waits. Upon successful acquisition, it logs detailed profiling information,
// including timestamps, lock name, lock owner, and caller, using a dedicated
// profiling system. It also sets the lock owner pointer at `p_rw_lock_state + 8`.
__int64 __fastcall rw_lock_acquire_write_lock_profiled(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5)
{
  __int64 v5; // r15
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r14d
  const char *v12; // r13
  bool v13; // zf
  signed __int64 v14; // rax
  __int64 result; // rax
  unsigned __int64 v16; // rdx
  signed __int64 v17; // rax
  const ULONG_PTR *p_p_Src; // rdx
  signed __int64 v19; // rax
  const ULONG_PTR *p_p_Src_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-91h] BYREF
  __int64 v22; // [rsp+34h] [rbp-8Dh]
  int n2; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 v24; // [rsp+40h] [rbp-81h]
  unsigned __int64 v25; // [rsp+48h] [rbp-79h]
  __int64 v26; // [rsp+50h] [rbp-71h]
  __int64 v27; // [rsp+58h] [rbp-69h]
  int n0x1600_1; // [rsp+80h] [rbp-41h] BYREF
  __int64 v29; // [rsp+84h] [rbp-3Dh]
  int n2_1; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 v31; // [rsp+90h] [rbp-31h]
  unsigned __int64 v32; // [rsp+98h] [rbp-29h]
  __int64 v33; // [rsp+A0h] [rbp-21h]
  __int64 v34; // [rsp+A8h] [rbp-19h]
  _BYTE v35[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char v36; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 v37; // [rsp+130h] [rbp+6Fh]

  v37 = a3;
  v5 = qword_149C8E038;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v5 + 0xF8LL))(v5, v35, &v36);
  v12 = a5;
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v16 = (unsigned __int64)v11 << 0x30;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v10 + 0x124) = HIWORD(a2);
        v17 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v16 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v13 = a2 == v17;
        a2 = v17;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v22 = 1;
          n2 = 2;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v24 = __rdtsc();
          qword_149C89AA0(
            &n0x1600,
            &word_149C7BF54,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(n0x1600) = word_149C7BF54;
          qword_149C89AE0("Lock: %s", v12);
          p_p_Src = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src);
          qword_149C89AE0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v25 = __rdtsc();
          qword_149C89AA8(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
        v19 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v16, a2);
        v13 = a2 == v19;
        a2 = v19;
        if ( v13 )
        {
          n0x1600_1 = 0x1600;
          v29 = 1;
          n2_1 = 2;
          v32 = 0;
          v33 = 0;
          v34 = 0;
          v31 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF58,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600_1) = word_149C7BF58;
          qword_149C89AE0("Lock: %s", v12);
          p_p_Src_1 = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v32 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | 0x200000, a2);
    v13 = a2 == v14;
    a2 = v14;
  }
  while ( !v13 );
  result = v37;
  *(_QWORD *)(a1 + 8) = v37;
  return result;
}

// --- End Function: rw_lock_acquire_write_lock_profiled (0x1403E11B0) ---

// --- Function: rw_lock_acquire_write_lock_unprofiled (0x1403E1470) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by readers). It then attempts to atomically set the write lock flag or
// increment a write lock count using `_InterlockedCompareExchange64`. Upon
// successful acquisition, it logs basic information about the lock, its owner, and
// the caller. This version does not include detailed performance profiling. It
// also sets the lock owner pointer at `p_rw_lock_state + 8`.
signed __int64 __fastcall rw_lock_acquire_write_lock_unprofiled(
        __int64 a1,
        signed __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5)
{
  char v5; // r14
  signed __int64 v9; // rcx
  bool v10; // zf
  signed __int64 result; // rax
  const ULONG_PTR *p_p_Src; // rdx
  int v13; // esi
  signed __int64 v14; // rax
  const ULONG_PTR *p_p_Src_1; // rdx
  int v16; // [rsp+38h] [rbp-81h] BYREF
  _DWORD v17[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int n0x1600; // [rsp+48h] [rbp-71h] BYREF
  __int64 v19; // [rsp+4Ch] [rbp-6Dh]
  int n2; // [rsp+54h] [rbp-65h]
  unsigned __int64 v21; // [rsp+58h] [rbp-61h]
  unsigned __int64 v22; // [rsp+60h] [rbp-59h]
  __int64 v23; // [rsp+68h] [rbp-51h]
  __int64 v24; // [rsp+70h] [rbp-49h]
  int n0x1600_1; // [rsp+98h] [rbp-21h] BYREF
  __int64 v26; // [rsp+9Ch] [rbp-1Dh]
  int n2_1; // [rsp+A4h] [rbp-15h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-11h]
  unsigned __int64 v29; // [rsp+B0h] [rbp-9h]
  __int64 v30; // [rsp+B8h] [rbp-1h]
  __int64 v31; // [rsp+C0h] [rbp+7h]

  v5 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x128LL))(qword_149C8E038, a1);
      if ( (a2 & 0x2003FF) == 0 )
        break;
      if ( v5 )
      {
        n0x1600 = 0x1600;
        v19 = 1;
        n2 = 2;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v21 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF4C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(n0x1600) = word_149C7BF4C;
        qword_149C89AE0("Lock: %s", a5);
        p_p_Src = &p_Src;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a4);
        v16 = a2;
        qword_149C78FC8(a1, &v16, 4, 0xFFFFFFFFLL);
        a2 = *(_QWORD *)a1;
        v22 = __rdtsc();
        qword_149C89AA8(&n0x1600);
      }
      else
      {
        v13 = a2 + 0x400000;
        v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 + 0x400000, a2);
        v10 = a2 == v14;
        a2 = v14;
        if ( v10 )
        {
          v5 = 1;
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF50,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600_1) = word_149C7BF50;
          qword_149C89AE0("Lock: %s", a5);
          p_p_Src_1 = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a4);
          v17[0] = v13;
          qword_149C78FC8(a1, v17, 4, 0xFFFFFFFFLL);
          a2 = *(_QWORD *)a1;
          v29 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v9 = (a2 | 0x200000) - 0x400000;
    if ( !v5 )
      v9 = a2 | 0x200000;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v9, a2);
    v10 = a2 == result;
    a2 = result;
  }
  while ( !v10 );
  *(_QWORD *)(a1 + 8) = a3;
  return result;
}

// --- End Function: rw_lock_acquire_write_lock_unprofiled (0x1403E1470) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403E1740) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // rbx
  signed __int64 v4; // rdi
  signed __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v7; // r8
  int v8; // ecx
  __int64 v9; // r8
  unsigned __int64 v10; // rbx
  const ULONG_PTR *p_p_Src; // rax
  int v12; // [rsp+70h] [rbp+8h] BYREF
  int v13; // [rsp+78h] [rbp+10h] BYREF
  __int64 v14; // [rsp+80h] [rbp+18h] BYREF
  __int64 v15; // [rsp+88h] [rbp+20h] BYREF

  for ( i = a2; ; i = v5 )
  {
    v4 = i & 0xFFFFFFFFFFD003FFuLL;
    if ( (i & 0xFFFF00100000LL) != 0 )
    {
      v4 = i & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (i & 0xFFC003FF) == 0 && (i & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v15,
        &v13);
      v4 = i & 0xFFFFFFD003FFLL;
      a2 = *(unsigned int *)(((HIWORD(i) & (unsigned int)(v13 - 1)) << 9) + v15 + 0x124);
      if ( (_DWORD)a2 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)(unsigned int)a2 << 0x30;
    }
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v4, i);
    if ( i == v5 )
      break;
  }
  if ( (i & 0x3FF) != 0 )
  {
    if ( (i & 0x100000) != 0 )
      qword_149C78FD8(a1);
    if ( (i & 0xFFFF00000000LL) != 0 )
    {
      v6 = qword_149C8E038;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v14,
        &v12);
      v7 = v14 + ((WORD2(i) & (unsigned __int64)(unsigned int)(v12 - 1)) << 9);
      LODWORD(i) = *(_DWORD *)(v7 + 0x124);
      *(_DWORD *)(v7 + 0x11C) = (unsigned __int16)(WORD2(i) + v12);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xD8LL))(v6);
      while ( (_DWORD)i != 0xFFFFFFFF )
      {
        v8 = (unsigned __int16)(i + v12);
        v9 = v14 + ((unsigned __int64)((unsigned int)i & (v12 - 1)) << 9);
        LODWORD(i) = *(_DWORD *)(v9 + 0x124);
        *(_DWORD *)(v9 + 0x11C) = v8;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xD8LL))(v6);
      }
    }
  }
  else if ( (i & 0xFFC00000) != 0 )
  {
    qword_149C78FD0(a1, a2);
  }
  else if ( (i & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v14,
      &v12);
    v10 = HIWORD(i);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v10 & (v12 - 1)) << 9) + v14 + 0x11C) = (unsigned __int16)(v10 + v12);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(qword_149C8E038, (unsigned int)v10);
  }
  p_p_Src = &p_Src;
  *(_QWORD *)(a1 + 8) = &p_Src;
  return p_p_Src;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403E1740) ---

// --- Function: sub_1403E1B60 (0x1403E1B60) ---
__int64 __fastcall sub_1403E1B60(volatile signed __int32 *a1, __int64 a2, unsigned __int8 a3, __int64 a4)
{
  signed __int32 v4; // ebx
  __int64 v7; // rsi
  unsigned __int16 v9; // di
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned __int16 v12; // bp
  signed __int32 v13; // eax
  int v14; // eax
  __int64 result; // rax
  int v16; // edi
  signed __int32 v17; // ebx
  signed __int32 v18; // [rsp+50h] [rbp+8h]

  v4 = *a1;
  HIWORD(v18) = HIWORD(*a1);
  v7 = a2;
  v9 = *a1;
  if ( v9 )
  {
LABEL_4:
    v12 = v9;
  }
  else
  {
    while ( 1 )
    {
      LOWORD(v18) = qword_149C89B30();
      v12 = v18;
      v13 = _InterlockedCompareExchange(a1, v18, v4);
      v9 = v13;
      if ( v13 == v4 )
        break;
      HIWORD(v18) = HIWORD(v13);
      v4 = v13;
      qword_149C89B38((unsigned __int16)v18, a2, v10, v11);
      if ( v9 )
        goto LABEL_4;
    }
  }
  v14 = *(_DWORD *)(v7 + 0x14);
  if ( v14 )
  {
    *(_DWORD *)(v7 + 0x14) = v14 - 1;
  }
  else
  {
    *(_DWORD *)(v7 + 0x10) = 0xFFFFFFFF;
    sub_1402DD7D0(v7);
  }
  LOBYTE(a2) = 1;
  qword_149C89B40(v12, a2, a3, a4);
  result = NtCurrentTeb_w();
  v16 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(v7 + 0x10) == v16 )
  {
    ++*(_DWORD *)(v7 + 0x14);
  }
  else
  {
    v17 = _InterlockedCompareExchange((volatile signed __int32 *)v7, 1, 0);
    if ( v17 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
        result = sub_1403C6EF0(v7, v17, (const char *)&p_Src);
      else
        result = sub_1403C7160(v7, v17, (const char *)&p_Src);
    }
    else
    {
      result = NtCurrentTeb_w();
      *(_QWORD *)(v7 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(v7 + 0x10) = v16;
  }
  return result;
}

// --- End Function: sub_1403E1B60 (0x1403E1B60) ---

// --- Function: sub_1403E2480 (0x1403E2480) ---
char *__fastcall sub_1403E2480(char **a1, __int64 a2)
{
  char *result; // rax
  _DWORD *v5; // rax

  if ( a2 )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 2);
    *v5 = a2;
    v5[1] = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149C78E84 + 4;
    *a1 = (char *)&qword_149C78E84 + 4;
  }
  return result;
}

// --- End Function: sub_1403E2480 (0x1403E2480) ---

// --- Function: sub_1403E24E0 (0x1403E24E0) ---
void *__fastcall sub_1403E24E0(void **a1, __int64 a2)
{
  void *result; // rax
  _DWORD *v5; // rax

  if ( a2 )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(2 * a2 + 0xA, 0);
    *a1 = v5 + 2;
    *v5 = a2;
    v5[1] = a2;
    result = *a1;
    *((_WORD *)*a1 + a2) = 0;
  }
  else
  {
    result = &unk_149C7C038;
    *a1 = &unk_149C7C038;
  }
  return result;
}

// --- End Function: sub_1403E24E0 (0x1403E24E0) ---

// --- Function: sub_1403E25F0 (0x1403E25F0) ---
void *__fastcall sub_1403E25F0(void **a1, void *a2, size_t Size)
{
  char *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = (char *)*a1;
  if ( Size > *((int *)v5 + 0xFFFFFFFF) )
  {
    v7 = (int *)(v5 + 0xFFFFFFF8);
    if ( v7[1] > 0 )
      sub_147715880(v7);
    *a1 = (char *)&qword_149C78E84 + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, Size);
  *((_DWORD *)*a1 + 0xFFFFFFFE) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403E25F0 (0x1403E25F0) ---

// --- Function: sub_1403E2690 (0x1403E2690) ---
void *__fastcall sub_1403E2690(void **a1, void *a2, unsigned __int64 a3)
{
  char *v4; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v4 = (char *)*a1;
  if ( a3 > *((int *)v4 + 0xFFFFFFFF) )
  {
    v7 = (int *)(v4 + 0xFFFFFFF8);
    if ( v7[1] > 0 )
      sub_147715880(v7, (unsigned int)dword_149A5EC00);
    *a1 = &unk_149C7C038;
    if ( a3 )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(2 * a3 + 0xA, 0);
      *a1 = v8 + 2;
      *v8 = a3;
      v8[1] = a3;
      *((_WORD *)*a1 + a3) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, 2 * a3);
  *((_DWORD *)*a1 + 0xFFFFFFFE) = a3;
  result = *a1;
  *((_WORD *)*a1 + a3) = 0;
  return result;
}

// --- End Function: sub_1403E2690 (0x1403E2690) ---

// --- Function: ?_Change_array@?$vector@V?$Triplet@NH@Eigen@@V?$allocator@V?$Triplet@NH@Eigen@@@std@@@std@@AEAAXQEAV?$Triplet@NH@Eigen@@_K1@Z (0x1403E2EF0) ---
void __fastcall std::vector<Eigen::Triplet<double,int>>::_Change_array(
        std::vector<Eigen::Triplet<double,int>> *this,
        Eigen::Triplet<double,int> *const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  __int64 v6; // rcx

  v6 = *(_QWORD *)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - v6) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_1402A6590(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = (char *)_Newvec + 0x10 * _Newsize;
  *((_QWORD *)this + 2) = (char *)_Newvec + 0x10 * _Newcapacity;
}

// --- End Function: ?_Change_array@?$vector@V?$Triplet@NH@Eigen@@V?$allocator@V?$Triplet@NH@Eigen@@@std@@@std@@AEAAXQEAV?$Triplet@NH@Eigen@@_K1@Z (0x1403E2EF0) ---

// --- Function: sub_1403E3C00 (0x1403E3C00) ---
__int64 __fastcall sub_1403E3C00(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rdi
  __int64 v10; // rcx
  __int64 result; // rax

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v4 != i; ++v4 )
    {
      if ( *(int *)(*v4 - 4LL) > 0 )
        sub_147715880((const void *)(*v4 - 8LL));
    }
    v10 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v10 - *(_QWORD *)(v10 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = *(_QWORD *)(v10 - 8);
    }
    sub_1402A6590(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 8 * a3;
  result = a2 + 8 * a4;
  a1[2] = result;
  return result;
}

// --- End Function: sub_1403E3C00 (0x1403E3C00) ---

// --- Function: sub_1403E4320 (0x1403E4320) ---
void __fastcall sub_1403E4320(void **a1, char *a2, size_t Size)
{
  char *v4; // rbp
  size_t Size_1; // r13
  unsigned __int64 n8; // r15
  _DWORD *v9; // rax
  char *v10; // rcx

  if ( Size )
  {
    v4 = (char *)*a1;
    Size_1 = *((int *)*a1 + 0xFFFFFFFE);
    if ( Size + Size_1 <= *((int *)*a1 + 0xFFFFFFFF) )
    {
      if ( &v4[Size_1] != a2 )
        memcpy(&v4[Size_1], a2, Size);
      *((_DWORD *)*a1 + 0xFFFFFFFE) += Size;
      *((_BYTE *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= Size + Size_1 )
        n8 = Size + Size_1;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        v9 = (_DWORD *)allocWithProfilerInfo(n8 + 9, 0);
        *a1 = v9 + 2;
        *v9 = n8;
        v9[1] = n8;
        *((_BYTE *)*a1 + n8) = 0;
        if ( *a1 != v4 )
          memcpy(*a1, v4, Size_1);
        v10 = (char *)*a1 + Size_1;
        if ( v10 != a2 )
          memcpy(v10, a2, Size);
        *((_DWORD *)*a1 + 0xFFFFFFFE) = Size + Size_1;
        *((_BYTE *)*a1 + Size_1 + Size) = 0;
      }
      if ( *((int *)v4 + 0xFFFFFFFF) > 0 )
        sub_147715880(v4 + 0xFFFFFFF8);
    }
  }
}

// --- End Function: sub_1403E4320 (0x1403E4320) ---

// --- Function: sub_1403E4E90 (0x1403E4E90) ---
char *__fastcall sub_1403E4E90(_QWORD *a1)
{
  char *result; // rax

  result = (char *)&qword_149C78E84 + 4;
  *a1 = (char *)&qword_149C78E84 + 4;
  return result;
}

// --- End Function: sub_1403E4E90 (0x1403E4E90) ---

// --- Function: sub_1403E5CF0 (0x1403E5CF0) ---
HMODULE sub_1403E5CF0()
{
  HMODULE hModule; // rax
  __int64 (__fastcall *psub_140338BA0)(); // rbx
  HMODULE hModule_1; // rax
  HMODULE hModule_2; // rax
  HMODULE hModule_3; // rax
  __int64 (*psub_140338BC0)(); // rbx

  hModule = GetModuleHandleA(0);
  psub_140338BA0 = GetProcAddress(hModule, "__GetLinkUnlinkLock__");
  if ( !psub_140338BA0 )
  {
    hModule_1 = LoadLibraryA(0);
    if ( hModule_1 )
      psub_140338BA0 = GetProcAddress(hModule_1, "__GetLinkUnlinkLock__");
  }
  ::psub_140338BA0 = psub_140338BA0;
  hModule_2 = GetModuleHandleA(0);
  hModule_3 = (HMODULE)GetProcAddress(hModule_2, "__GetInsidePullEvents__");
  psub_140338BC0 = (__int64 (*)())hModule_3;
  if ( hModule_3 || (hModule_3 = LoadLibraryA(0)) == 0 )
  {
    ::psub_140338BC0 = psub_140338BC0;
  }
  else
  {
    hModule_3 = (HMODULE)GetProcAddress(hModule_3, "__GetInsidePullEvents__");
    ::psub_140338BC0 = (__int64 (*)())hModule_3;
  }
  return hModule_3;
}

// --- End Function: sub_1403E5CF0 (0x1403E5CF0) ---

// --- Function: sub_1403E6390 (0x1403E6390) ---
void *__fastcall sub_1403E6390(void *a1, const void *a2, size_t Size)
{
  void *result; // rax

  if ( a1 != a2 )
    return memcpy(a1, a2, Size);
  return result;
}

// --- End Function: sub_1403E6390 (0x1403E6390) ---

// --- Function: sub_1403E63B0 (0x1403E63B0) ---
void __fastcall sub_1403E63B0(__int64 a1, const char *a2)
{
  __int64 v3; // rbx
  int v4; // ebp
  signed __int32 v5; // edi
  signed __int64 v6; // rax
  int v7; // eax
  const char *v8; // [rsp+38h] [rbp+10h] BYREF

  if ( a2 )
  {
    v3 = sub_140354080(&qword_149C7BA98) + 8;
    v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v3 + 0x10) == v4 )
    {
      ++*(_DWORD *)(v3 + 0x14);
    }
    else
    {
      v5 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
      if ( v5 )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
          sub_1403C6EF0(v3, v5, "CCryName::_release");
        else
          sub_1403C7160(v3, v5, "CCryName::_release");
      }
      else
      {
        *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      }
      *(_DWORD *)(v3 + 0x10) = v4;
    }
    if ( (int)--*((_DWORD *)a2 + 0xFFFFFFFD) <= 0 )
    {
      v6 = sub_140354080(&qword_149C7BA98);
      v8 = a2;
      sub_14034AD90((_QWORD *)(v6 + 0x20), &v8);
      sub_147715880(a2 + 0xFFFFFFF4);
    }
    v7 = *(_DWORD *)(v3 + 0x14);
    if ( v7 )
    {
      *(_DWORD *)(v3 + 0x14) = v7 - 1;
    }
    else
    {
      *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
      sub_1402DD7D0(v3);
    }
  }
}

// --- End Function: sub_1403E63B0 (0x1403E63B0) ---

// --- Function: ?allocate@?$allocator@V?$Vector@$02N@gte@@@std@@QEAAPEAV?$Vector@$02N@gte@@_K@Z (0x1403E66E0) ---
gte::Vector<3,double> *__fastcall std::allocator<gte::Vector<3,double>>::allocate(
        std::allocator<gte::Vector<3,double> > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  gte::Vector<3,double> *result; // rax

  if ( _Count > 0xAAAAAAAAAAAAAAALL )
    goto LABEL_10;
  allocSize = 0x18 * _Count;
  if ( 0x18 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (gte::Vector<3,double> *)sub_1402A65A0(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E3880();
  v3 = sub_1402A65A0(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (gte::Vector<3,double> *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@V?$Vector@$02N@gte@@@std@@QEAAPEAV?$Vector@$02N@gte@@_K@Z (0x1403E66E0) ---

// --- Function: __safe_get_tls_index (0x1403E6FE0) ---
__int64 _safe_get_tls_index()
{
  sub_1403E74B0();
  return (unsigned int)dword_149C7B128;
}

// --- End Function: __safe_get_tls_index (0x1403E6FE0) ---

// --- Function: sub_1403E70E0 (0x1403E70E0) ---
__int64 sub_1403E70E0()
{
  HANDLE CurrentThread; // rax
  __int64 result; // rax
  int v2; // [rsp+20h] [rbp-28h] BYREF
  __int64 v3; // [rsp+24h] [rbp-24h]

  v2 = 1;
  v3 = 1;
  CurrentThread = GetCurrentThread();
  result = SetThreadInformation(CurrentThread, 3, &v2);
  if ( !(_DWORD)result )
    __debugbreak();
  return result;
}

// --- End Function: sub_1403E70E0 (0x1403E70E0) ---

// --- Function: sub_1403E7140 (0x1403E7140) ---
__int64 __fastcall sub_1403E7140(int n2)
{
  int n0x1F80; // edx
  __int64 result; // rax
  int v3; // [rsp+B0h] [rbp+8h]
  unsigned int v4; // [rsp+B0h] [rbp+8h]

  n0x1F80 = 0x1F80;
  if ( n2 == 1 || n2 == 2 && (!qword_149C8E0F8 || !(_BYTE)qword_149C8E516) )
    n0x1F80 = 0x1D00;
  __asm { vstmxcsr [rsp+0A8h+arg_0] }
  result = n0x1F80 | v3 & 0xFFFFE040;
  v4 = n0x1F80 | v3 & 0xFFFFE040;
  __asm { vldmxcsr [rsp+0A8h+arg_0] }
  return result;
}

// --- End Function: sub_1403E7140 (0x1403E7140) ---

// --- Function: sub_1403E7220 (0x1403E7220) ---
__int64 __fastcall sub_1403E7220(__int64 a1, __int64 a2)
{
  HMODULE hModule; // rax
  FARPROC ProcAddress; // rbx
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  ProcAddress = GetProcAddress(hModule, "___cigFetchNonWrapFunction___");
  if ( !ProcAddress )
  {
    hModule_1 = LoadLibraryA(0);
    if ( hModule_1 )
      ProcAddress = GetProcAddress(hModule_1, "___cigFetchNonWrapFunction___");
  }
  return ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a1, a2);
}

// --- End Function: sub_1403E7220 (0x1403E7220) ---

// --- Function: sub_1403E7290 (0x1403E7290) ---
__int64 __fastcall sub_1403E7290(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  unsigned __int64 Size_1; // rax
  size_t Size; // rdi
  _DWORD *v6; // rax

  if ( qword_149C8E0F8 && qword_149C8DFE0 )
  {
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DFE0 + 0x6A8LL))(qword_149C8DFE0, a1, a2);
    return a1;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
    *(_QWORD *)(a1 + 0x18) = 0;
    *(_QWORD *)(a1 + 0x20) = 0;
    *(_QWORD *)a1 = (char *)&qword_149C78E84 + 4;
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( *((_BYTE *)&p_Src + Size_1) );
    Size = (int)Size_1;
    if ( (_DWORD)Size_1 )
    {
      v6 = (_DWORD *)allocWithProfilerInfo((int)Size_1 + 9LL, 0);
      *(_QWORD *)a1 = v6 + 2;
      *v6 = Size;
      v6[1] = Size;
      *(_BYTE *)(Size + *(_QWORD *)a1) = 0;
      if ( *(const ULONG_PTR **)a1 != &p_Src )
        memcpy(*(void **)a1, &p_Src, Size);
    }
    result = a1;
    *(_DWORD *)(a1 + 8) = 0x2710;
    *(_QWORD *)(a1 + 0x10) = 0x1000;
    *(_DWORD *)(a1 + 0x18) = 3;
    *(_DWORD *)(a1 + 0x1C) = 2;
    *(_DWORD *)(a1 + 0x20) = 0xFFFFFFFF;
    *(_BYTE *)(a1 + 0x24) = 1;
  }
  return result;
}

// --- End Function: sub_1403E7290 (0x1403E7290) ---

// --- Function: sub_1403E74B0 (0x1403E74B0) ---
void sub_1403E74B0()
{
  __int64 n7; // rax
  __int64 Relationship; // rcx
  unsigned int v25; // r8d
  __int64 Relationship_1; // rcx
  __int64 Relationship_2; // rcx
  __int64 Relationship_3; // rcx
  __int64 v41; // rbx
  unsigned __int64 NodeNumber; // rcx
  unsigned __int64 size; // rcx
  void *v44; // rsp
  void *v45; // rsp
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *p_Buffer; // r15
  unsigned __int64 v47; // r12
  int v48; // r13d
  unsigned __int8 v49; // cl
  unsigned __int8 v50; // r14
  unsigned __int8 v51; // cl
  unsigned __int8 v52; // si
  unsigned __int8 v53; // cl
  unsigned __int8 v54; // di
  unsigned __int8 v55; // cl
  unsigned __int8 v56; // r10
  unsigned __int8 v57; // cl
  unsigned __int8 v58; // r9
  unsigned __int8 v59; // cl
  unsigned __int8 v60; // r8
  unsigned __int8 v61; // cl
  unsigned __int8 v62; // al
  __int64 v63; // rcx
  _BYTE *v64; // rax
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer; // [rsp+20h] [rbp+0h] BYREF

  if ( !byte_149C79026 )
  {
    _RAX = 1;
    __asm { cpuid }
    dword_149C79044 = _RAX;
    n7 = 7;
    dword_149C7904C = _RCX;
    dword_149C79048 = _RBX;
    dword_149C79118 = _RDX;
    __asm { cpuid }
    dword_149C7B12C = _RAX;
    _RAX = 0x80000007LL;
    dword_149C7B134 = _RCX;
    dword_149C7B130 = _RBX;
    dword_149C7B138 = _RDX;
    __asm { cpuid }
    dword_149C7B13C = _RAX;
    _RAX = 0x80000001LL;
    dword_149C7B144 = _RCX;
    dword_149C7B140 = _RBX;
    dword_149C7B148 = _RDX;
    __asm { cpuid }
    _RAX = 0x80000000LL;
    dword_149C7B14C = _RCX;
    dword_149C7B150 = _RDX;
    __asm { cpuid }
    LODWORD(Buffer.ProcessorMask) = 0xFFFFFFFF;
    v25 = _RAX;
    HIDWORD(Buffer.ProcessorMask) = _RBX;
    Buffer.Relationship = Relationship;
    *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
    if ( (unsigned int)_RAX > 0x80000002 )
    {
      _RAX = 0x80000002LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_1;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149C7B160 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000003 )
    {
      _RAX = 0x80000003LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_2;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149C7B170 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000004 )
    {
      _RAX = 0x80000004LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_3;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149C7B180 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    v41 = 0;
    Buffer.NumaNode.NodeNumber = 0;
    if ( GetLogicalProcessorInformation(0, &Buffer.NumaNode.NodeNumber) || GetLastError() != ERROR_INSUFFICIENT_BUFFER )
      __debugbreak();
    NodeNumber = Buffer.NumaNode.NodeNumber + 0xFLL;
    if ( NodeNumber <= Buffer.NumaNode.NodeNumber )
      NodeNumber = 0xFFFFFFFFFFFFFF0LL;
    size = NodeNumber & 0xFFFFFFFFFFFFFFF0uLL;
    v44 = alloca(size);
    v45 = alloca(size);
    p_Buffer = &Buffer;
    if ( !GetLogicalProcessorInformation(&Buffer, &Buffer.NumaNode.NodeNumber) )
      __debugbreak();
    v47 = (unsigned __int64)Buffer.NumaNode.NodeNumber >> 5;
    if ( v47 )
    {
      v48 = dword_149C7B128;
      do
      {
        if ( p_Buffer->Relationship == RelationProcessorCore )
        {
          v49 = (p_Buffer->ProcessorMask & 0x55) + (((unsigned __int8)p_Buffer->ProcessorMask >> 1) & 0x55);
          v50 = (v49 & 0x33) + ((v49 >> 2) & 0x33);
          v51 = (BYTE1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE1(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v52 = (v51 & 0x33) + ((v51 >> 2) & 0x33);
          v53 = (WORD1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE2(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v54 = (v53 & 0x33) + ((v53 >> 2) & 0x33);
          v55 = (BYTE3(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE3(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v56 = (v55 & 0x33) + ((v55 >> 2) & 0x33);
          v57 = (HIDWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE4(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v58 = (v57 & 0x33) + ((v57 >> 2) & 0x33);
          v59 = (((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) & 0x55)
              + (((unsigned __int8)((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) >> 1) & 0x55);
          v60 = (v59 & 0x33) + ((v59 >> 2) & 0x33);
          v61 = (HIWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE6(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v62 = (HIBYTE(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)HIBYTE(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v48 += (unsigned __int8)((v50 >> 4)
                                 + (v50 & 0xF)
                                 + (v52 >> 4)
                                 + (v52 & 0xF)
                                 + (v54 >> 4)
                                 + (v54 & 0xF)
                                 + (v56 >> 4)
                                 + (v56 & 0xF)
                                 + (v58 >> 4)
                                 + (v58 & 0xF)
                                 + (v60 >> 4)
                                 + (v60 & 0xF)
                                 + ((unsigned __int8)((v61 & 0x33) + ((v61 >> 2) & 0x33)) >> 4)
                                 + (((v61 & 0x33) + ((v61 >> 2) & 0x33)) & 0xF)
                                 + ((unsigned __int8)((v62 & 0x33) + ((v62 >> 2) & 0x33)) >> 4)
                                 + (((v62 & 0x33) + ((v62 >> 2) & 0x33)) & 0xF));
        }
        ++p_Buffer;
        --v47;
      }
      while ( v47 );
      dword_149C7B128 = v48;
    }
    v63 = 0;
    if ( (_BYTE)xmmword_149C7B160 )
    {
      do
      {
        for ( ; *((_BYTE *)&xmmword_149C7B160 + v41) == 0x20; ++v41 )
          ;
        *((_BYTE *)&xmmword_149C7B160 + v63) = *((_BYTE *)&xmmword_149C7B160 + v41);
        if ( *((_BYTE *)&xmmword_149C7B160 + v41) )
        {
          while ( 1 )
          {
            v64 = (char *)&xmmword_149C7B160 + v41;
            ++v63;
            ++v41;
            if ( *v64 == 0x20 )
              break;
            *((_BYTE *)&xmmword_149C7B160 + v63) = *((_BYTE *)&xmmword_149C7B160 + v41);
            if ( !*((_BYTE *)&xmmword_149C7B160 + v41) )
              goto LABEL_27;
          }
        }
        else
        {
LABEL_27:
          if ( v63 )
          {
            if ( *((_BYTE *)&xmmword_149C7B160 + v63 - 1) == 0x20 )
              *((_BYTE *)&xmmword_149C7B160 + v63 - 1) = 0;
          }
        }
      }
      while ( *((_BYTE *)&xmmword_149C7B160 + v41) );
    }
    byte_149C79026 = 1;
  }
}

// --- End Function: sub_1403E74B0 (0x1403E74B0) ---

// --- Function: sub_1403E78F0 (0x1403E78F0) ---
__int64 __fastcall sub_1403E78F0(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __m128i v4; // rax
  __m128i v5; // rt0
  __m128i v7; // [rsp+10h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    v5.m128i_i64[0] = v2.m128i_i64[0];
    v5.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, epi64 + 1, *(_QWORD *)v2.m128i_i64[0], v5.m128i_i64);
    v4 = v5;
    v7 = v5;
    if ( *(_OWORD *)&v5 == __PAIR128__(epi64, v2.m128i_u64[0]) )
      break;
    v2 = v7;
    if ( !v4.m128i_i64[0] )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_1403E78F0 (0x1403E78F0) ---

// --- Function: sub_1403E79B0 (0x1403E79B0) ---
__int64 __fastcall sub_1403E79B0(volatile signed __int64 *a1, _QWORD *a2)
{
  __m128i v3; // rt0
  __m128i i; // xmm0
  signed __int64 epi64; // r9
  __m128i v6; // rax
  __m128i v7; // rt0
  __m128i v9; // [rsp+10h] [rbp-28h]

  v3 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v3.m128i_i64);
  for ( i = v3; ; i = v9 )
  {
    if ( a2 == (_QWORD *)i.m128i_i64[0] )
      __debugbreak();
    epi64 = _mm_extract_epi64(i, 1);
    *a2 = i.m128i_i64[0];
    v7.m128i_i64[0] = i.m128i_i64[0];
    v7.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, epi64 + 1, (signed __int64)a2, v7.m128i_i64);
    v6 = v7;
    v9 = v7;
    if ( *(_OWORD *)&v7 == __PAIR128__(epi64, i.m128i_u64[0]) )
      break;
  }
  return v6.m128i_i64[0];
}

// --- End Function: sub_1403E79B0 (0x1403E79B0) ---

// --- Function: sub_1403E7A80 (0x1403E7A80) ---
__int64 __fastcall sub_1403E7A80(int a1)
{
  if ( !a1 )
    return 0;
  if ( a1 == 1 )
    return 1;
  return 2;
}

// --- End Function: sub_1403E7A80 (0x1403E7A80) ---

// --- Function: sub_1403E7AA0 (0x1403E7AA0) ---
__int64 __fastcall sub_1403E7AA0(int n2, int a2)
{
  int n0x1F80; // eax

  n0x1F80 = 0x1F80;
  if ( n2 == 1 || n2 == 2 && (!qword_149C8E0F8 || !(_BYTE)qword_149C8E516) )
    n0x1F80 = 0x1D00;
  return a2 & 0xFFFFE040 | n0x1F80;
}

// --- End Function: sub_1403E7AA0 (0x1403E7AA0) ---

// --- Function: sub_1403E7AE0 (0x1403E7AE0) ---
LARGE_INTEGER sub_1403E7AE0()
{
  LARGE_INTEGER PerformanceCount; // [rsp+30h] [rbp+8h] BYREF

  QueryPerformanceCounter(&PerformanceCount);
  return PerformanceCount;
}

// --- End Function: sub_1403E7AE0 (0x1403E7AE0) ---

// --- Function: AcquireSRWLockShared (0x1403E7B20) ---
// attributes: thunk
void __stdcall AcquireSRWLockShared(PSRWLOCK SRWLock)
{
  __imp_AcquireSRWLockShared(SRWLock);
}

// --- End Function: AcquireSRWLockShared (0x1403E7B20) ---

// --- Function: ReleaseSRWLockShared (0x1403E7B30) ---
// attributes: thunk
void __stdcall ReleaseSRWLockShared(PSRWLOCK SRWLock)
{
  __imp_ReleaseSRWLockShared(SRWLock);
}

// --- End Function: ReleaseSRWLockShared (0x1403E7B30) ---

// --- Function: sub_1403E7CC0 (0x1403E7CC0) ---
__int64 sub_1403E7CC0()
{
  __int64 result; // rax
  int v1; // [rsp+B0h] [rbp+8h]
  int v2; // [rsp+B0h] [rbp+8h]

  __asm { vstmxcsr [rsp+0A8h+arg_0] }
  v1 |= 0x8000u;
  __asm
  {
    vldmxcsr [rsp+0A8h+arg_0]
    vstmxcsr [rsp+0A8h+arg_0]
  }
  result = v2 | 0x40u;
  v2 |= 0x40u;
  __asm { vldmxcsr [rsp+0A8h+arg_0] }
  return result;
}

// --- End Function: sub_1403E7CC0 (0x1403E7CC0) ---

// --- Function: sub_1403E7D90 (0x1403E7D90) ---
void __fastcall sub_1403E7D90(char *PSrc_1)
{
  unsigned __int64 v2; // rax
  size_t Count; // rbx
  wchar_t *Dest; // rsi
  int (__fastcall *v5)(HANDLE, wchar_t *); // rbx
  HANDLE CurrentThread; // rax
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-28h] BYREF
  DWORD CurrentThreadId; // [rsp+30h] [rbp-18h]
  int v9; // [rsp+34h] [rbp-14h]
  mbstate_t State; // [rsp+50h] [rbp+8h] BYREF
  char *PSrc; // [rsp+58h] [rbp+10h] BYREF

  sub_1403BE550();
  if ( qword_149C7B110 )
  {
    PSrc = PSrc_1;
    v2 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v2;
    while ( PSrc_1[v2] );
    Count = v2 + 1;
    Dest = (wchar_t *)sub_1402A65A0(saturated_mul(v2 + 1, 2u));
    State = 0;
    mbsrtowcs(Dest, (const char **)&PSrc, Count, &State);
    v5 = (int (__fastcall *)(HANDLE, wchar_t *))qword_149C7B110;
    CurrentThread = GetCurrentThread();
    if ( v5(CurrentThread, Dest) < 0 )
      __debugbreak();
    sub_1402A6590((__int64)Dest);
  }
  LODWORD(Arguments[0]) = 0x1000;
  Arguments[1] = (ULONG_PTR)PSrc_1;
  CurrentThreadId = GetCurrentThreadId();
  v9 = 0;
  RaiseException(0x406D1388u, 0, 6u, Arguments);
}

// --- End Function: sub_1403E7D90 (0x1403E7D90) ---

// --- Function: sub_1403E8680 (0x1403E8680) ---
void *__fastcall sub_1403E8680(void **a1)
{
  void *result; // rax

  result = *a1;
  if ( *((_DWORD *)*a1 + 0xFFFFFFFE) )
    return (void *)sub_1403EDAA0(a1, 0, 0x20);
  return result;
}

// --- End Function: sub_1403E8680 (0x1403E8680) ---

// --- Function: sub_1403E8B60 (0x1403E8B60) ---
__int64 __fastcall sub_1403E8B60(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E8B60 (0x1403E8B60) ---

// --- Function: sub_1403E8B90 (0x1403E8B90) ---
__int64 __fastcall sub_1403E8B90(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // rdx
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E8B90 (0x1403E8B90) ---

// --- Function: sub_1403E8F30 (0x1403E8F30) ---
__int64 sub_1403E8F30()
{
  return sub_1402A65A0(1u);
}

// --- End Function: sub_1403E8F30 (0x1403E8F30) ---

// --- Function: sub_1403E8F40 (0x1403E8F40) ---
_OWORD *__fastcall sub_1403E8F40(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)sub_1402A65A0(0x10u);
  if ( result )
    *result = *a1;
  return result;
}

// --- End Function: sub_1403E8F40 (0x1403E8F40) ---

// --- Function: sub_1403E8F70 (0x1403E8F70) ---
_QWORD *__fastcall sub_1403E8F70(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)sub_1402A65A0(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A6590(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)sub_1402A65A0(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E8F70 (0x1403E8F70) ---

// --- Function: sub_1403E9050 (0x1403E9050) ---
__int64 __fastcall sub_1403E9050(__int64 a1)
{
  __int64 result; // rax

  result = sub_1402A65A0(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 0x10) = *(double *)(a1 + 0x10);
  }
  return result;
}

// --- End Function: sub_1403E9050 (0x1403E9050) ---

// --- Function: sub_1403E9230 (0x1403E9230) ---
__int64 __fastcall sub_1403E9230(__int64 a1)
{
  return sub_1402A6590(a1);
}

// --- End Function: sub_1403E9230 (0x1403E9230) ---

// --- Function: sub_1403E9240 (0x1403E9240) ---
__int64 __fastcall sub_1403E9240(__int64 a1)
{
  return sub_1402A6590(a1);
}

// --- End Function: sub_1403E9240 (0x1403E9240) ---

// --- Function: sub_1403E9250 (0x1403E9250) ---
__int64 __fastcall sub_1403E9250(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_1402A6590(*(_QWORD *)(a1 + 0x10));
    return sub_1402A6590(a1);
  }
  return result;
}

// --- End Function: sub_1403E9250 (0x1403E9250) ---

// --- Function: sub_1403E9280 (0x1403E9280) ---
__int64 __fastcall sub_1403E9280(__int64 a1)
{
  return sub_1402A6590(a1);
}

// --- End Function: sub_1403E9280 (0x1403E9280) ---

// --- Function: sub_1403EA1B0 (0x1403EA1B0) ---
unsigned __int64 __fastcall sub_1403EA1B0(__int64 *a1, const char *SubStr, unsigned __int64 a3)
{
  __int64 v3; // r9
  char *v5; // rax

  v3 = *a1;
  if ( a3 <= *(int *)(*a1 - 8) && v3 + a3 && (v5 = strstr((const char *)(v3 + a3), SubStr)) != 0 )
    return (unsigned __int64)&v5[-*a1];
  else
    return 0xFFFFFFFFFFFFFFFFuLL;
}

// --- End Function: sub_1403EA1B0 (0x1403EA1B0) ---

// --- Function: sub_1403EA670 (0x1403EA670) ---
unsigned __int64 __fastcall sub_1403EA670(__int64 *a1, char a2, unsigned __int64 a3)
{
  __int64 v3; // r9
  unsigned __int64 v4; // rax
  __int64 v5; // rax

  v3 = *a1;
  v4 = *(int *)(*a1 - 8);
  if ( *(_DWORD *)(*a1 - 8) )
  {
    if ( a3 >= v4 )
      a3 = v4 - 1;
    v5 = v3 + a3;
    if ( *(_BYTE *)(v3 + a3) == a2 )
      return v5 - v3;
    while ( v5 != v3 )
    {
      if ( *(_BYTE *)--v5 == a2 )
        return v5 - v3;
    }
  }
  return 0xFFFFFFFFFFFFFFFFuLL;
}

// --- End Function: sub_1403EA670 (0x1403EA670) ---

// --- Function: sub_1403EAAF0 (0x1403EAAF0) ---
__int64 __fastcall sub_1403EAAF0(__int64 *a1)
{
  if ( AssetMeta::HasActorSubresource(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403EAAF0 (0x1403EAAF0) ---

// --- Function: sub_1403EAB20 (0x1403EAB20) ---
__int64 __fastcall sub_1403EAB20(unsigned __int64 *a1)
{
  if ( is_entity_descriptor_valid_or_accessible(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403EAB20 (0x1403EAB20) ---

// --- Function: sub_1403EB9C0 (0x1403EB9C0) ---
bool __fastcall sub_1403EB9C0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  signed __int64 v2; // r8
  int v3; // eax
  int v4; // edx

  if ( a1 == a2 )
    return 1;
  if ( !a1 || !a2 )
    return 0;
  v2 = a2 - a1;
  do
  {
    v3 = a1[v2];
    v4 = *a1 - v3;
    if ( v4 )
      break;
    ++a1;
  }
  while ( v3 );
  return !v4;
}

// --- End Function: sub_1403EB9C0 (0x1403EB9C0) ---

// --- Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403EBA00) ---
bool __fastcall FH4::HandlerMap4::iterator::operator==(__int64 a1, __int64 a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

// --- End Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403EBA00) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403EBA10) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403EBA10) ---

// --- Function: sub_1403EBA20 (0x1403EBA20) ---
bool __fastcall sub_1403EBA20(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403EBA20 (0x1403EBA20) ---

// --- Function: sub_1403EBBC0 (0x1403EBBC0) ---
char __fastcall sub_1403EBBC0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403EBBC0 (0x1403EBBC0) ---

// --- Function: sub_1403EBE30 (0x1403EBE30) ---
__int64 __fastcall sub_1403EBE30(_QWORD *a1)
{
  return *(int *)(*a1 - 8LL);
}

// --- End Function: sub_1403EBE30 (0x1403EBE30) ---

// --- Function: sub_1403EC890 (0x1403EC890) ---
unsigned __int64 __fastcall sub_1403EC890(__int64 *a1, __int64 a2)
{
  unsigned __int64 result; // rax

  if ( a1[1] == a1[2] )
    return sub_1403484B0(a1, a1[1], a2);
  result = sub_14036F3C0(a1[1], a2);
  a1[1] += 0x90;
  return result;
}

// --- End Function: sub_1403EC890 (0x1403EC890) ---

// --- Function: sub_1403ED3F0 (0x1403ED3F0) ---
void __fastcall sub_1403ED3F0(void **a1, unsigned __int64 a2)
{
  int *v2; // rdi
  unsigned __int64 v5; // rcx
  _DWORD *v6; // rax

  v2 = (int *)*a1;
  v5 = *((int *)*a1 + 0xFFFFFFFF);
  if ( a2 > v5 )
  {
    if ( a2 )
    {
      v6 = (_DWORD *)allocWithProfilerInfo(a2 + 9, 0);
      *a1 = v6 + 2;
      *v6 = a2;
      v6[1] = a2;
      *((_BYTE *)*a1 + a2) = 0;
    }
    else
    {
      *a1 = (char *)&qword_149C78E84 + 4;
    }
    if ( *a1 != v2 )
      memcpy(*a1, v2, v2[0xFFFFFFFE]);
    *((_DWORD *)*a1 + 0xFFFFFFFE) = v2[0xFFFFFFFE];
    *((_BYTE *)*a1 + v2[0xFFFFFFFE]) = 0;
LABEL_12:
    if ( v2[0xFFFFFFFF] > 0 )
      sub_147715880(v2 + 0xFFFFFFFE);
    return;
  }
  if ( !a2 && v2[0xFFFFFFFE] != (_DWORD)v5 )
  {
    sub_1403E2480((char **)a1, v2[0xFFFFFFFE]);
    if ( *a1 != v2 )
      memcpy(*a1, v2, v2[0xFFFFFFFE]);
    goto LABEL_12;
  }
}

// --- End Function: sub_1403ED3F0 (0x1403ED3F0) ---

// --- Function: sub_1403EDAA0 (0x1403EDAA0) ---
__int64 __fastcall sub_1403EDAA0(void **a1, unsigned __int64 a2, char Val)
{
  _DWORD *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx
  __int64 result; // rax

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 + 0xFFFFFFFE);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return result;
    v3[0xFFFFFFFE] = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return result;
  if ( a2 <= (int)v3[0xFFFFFFFF] )
  {
    memset((char *)v3 + v6, Val, Size);
    *((_DWORD *)*a1 + 0xFFFFFFFE) = v6 + Size;
LABEL_11:
    result = *((int *)*a1 + 0xFFFFFFFE);
    *((_BYTE *)*a1 + result) = 0;
    return result;
  }
  sub_1403E2480(a1);
  if ( *a1 != v3 )
    memcpy(*a1, v3, (int)v3[0xFFFFFFFE]);
  result = (__int64)memset((char *)*a1 + (int)v3[0xFFFFFFFE], Val_1, Size);
  if ( (int)v3[0xFFFFFFFF] > 0 )
    return sub_147715880(v3 + 0xFFFFFFFE, (unsigned int)dword_149A5EC00);
  return result;
}

// --- End Function: sub_1403EDAA0 (0x1403EDAA0) ---

// --- Function: sub_1403EDB70 (0x1403EDB70) ---
__int64 __fastcall sub_1403EDB70(void **a1, unsigned __int64 a2, unsigned __int16 a3)
{
  char *v3; // rdi
  unsigned __int64 v5; // r9
  int *v6; // rsi
  __int64 v7; // rbp
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  _WORD *v10; // rdi
  __int64 result; // rax
  char *v12; // rdi
  unsigned __int64 i; // rcx

  v3 = (char *)*a1;
  v5 = *((int *)*a1 + 0xFFFFFFFE);
  v6 = (int *)((char *)*a1 + 0xFFFFFFF8);
  v7 = a3;
  if ( a2 <= v5 )
  {
    if ( a2 >= v5 )
      return result;
    *v6 = a2;
    goto LABEL_17;
  }
  v8 = a2 - v5;
  if ( a2 == v5 )
    return result;
  if ( a2 <= *((int *)v3 + 0xFFFFFFFF) )
  {
    v12 = &v3[2 * v5];
    for ( i = a2 - v5; i; --i )
    {
      *(_WORD *)v12 = a3;
      v12 += 2;
    }
    *((_DWORD *)*a1 + 0xFFFFFFFE) = a2;
LABEL_17:
    result = *((int *)*a1 + 0xFFFFFFFE);
    *((_WORD *)*a1 + result) = 0;
    return result;
  }
  sub_1403E24E0(a1);
  if ( *a1 != v3 )
    memcpy(*a1, v3, 2LL * *v6);
  v9 = v8;
  v10 = (char *)*a1 + 2 * *v6;
  result = v7;
  while ( v9 )
  {
    *v10++ = v7;
    --v9;
  }
  if ( v6[1] > 0 )
    return sub_147715880(v6, (unsigned int)dword_149A5EC00);
  return result;
}

// --- End Function: sub_1403EDB70 (0x1403EDB70) ---

// --- Function: ??$size@V?$vector@Uindexed_polygon@GameGraph@AI@GSC@@V?$allocator@Uindexed_polygon@GameGraph@AI@GSC@@@std@@@std@@@std@@YA_KAEBV?$vector@Uindexed_polygon@GameGraph@AI@GSC@@V?$allocator@Uindexed_polygon@GameGraph@AI@GSC@@@std@@@0@@Z (0x1403EEE80) ---
__int64 __fastcall std::size<std::vector<GSC::AI::GameGraph::indexed_polygon>>(
        const std::vector<GSC::AI::GameGraph::indexed_polygon> *_Cont)
{
  return (*((_QWORD *)_Cont + 1) - *(_QWORD *)_Cont) / 0x18LL;
}

// --- End Function: ??$size@V?$vector@Uindexed_polygon@GameGraph@AI@GSC@@V?$allocator@Uindexed_polygon@GameGraph@AI@GSC@@@std@@@std@@@std@@YA_KAEBV?$vector@Uindexed_polygon@GameGraph@AI@GSC@@V?$allocator@Uindexed_polygon@GameGraph@AI@GSC@@@std@@@0@@Z (0x1403EEE80) ---

// --- Function: sub_1403EEEB0 (0x1403EEEB0) ---
__int64 __fastcall sub_1403EEEB0(_QWORD *a1)
{
  return (a1[1] - *a1) / 0x90LL;
}

// --- End Function: sub_1403EEEB0 (0x1403EEEB0) ---

// --- Function: sub_1403EF0C0 (0x1403EF0C0) ---
void **__fastcall sub_1403EF0C0(__int64 *a1, void **a2, size_t a3, size_t Size_1)
{
  __int64 v6; // rdx
  size_t v7; // rcx
  size_t Size; // r8

  v6 = *a1;
  v7 = *(int *)(*a1 - 8);
  if ( a3 < v7 )
  {
    Size = v7 - a3;
    if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
      Size_1 = v7 - a3;
    if ( a3 + Size_1 <= v7 )
      Size = Size_1;
    sub_14035E010(a2, (void *)(a3 + v6), Size);
    return a2;
  }
  else
  {
    *a2 = (char *)&qword_149C78E84 + 4;
    return a2;
  }
}

// --- End Function: sub_1403EF0C0 (0x1403EF0C0) ---

// --- Function: sub_1403EF1F0 (0x1403EF1F0) ---
__int64 __fastcall sub_1403EF1F0(const char *p_null_1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  return sub_140303440(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EF1F0 (0x1403EF1F0) ---

// --- Function: sub_1403EF240 (0x1403EF240) ---
__int64 __fastcall sub_1403EF240(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 0x10) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 0x22;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      v6 = sub_14035D730((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    *a2 = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  v6 = sub_140300DE0((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
    return 0xFFFFFFFFLL;
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
    return 0xFFFFFFFFLL;
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 0x22;
    }
    else
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403EF240 (0x1403EF240) ---

// --- Function: sub_1403EF370 (0x1403EF370) ---
__int64 __fastcall sub_1403EF370(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  const char *p_null; // r8

  p_null = "null";
  LOBYTE(a4) = 1;
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140303440(a2, a3, p_null, a4);
}

// --- End Function: sub_1403EF370 (0x1403EF370) ---

// --- Function: sub_1403EF3A0 (0x1403EF3A0) ---
__int64 __fastcall sub_1403EF3A0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_14035D730(a2, a3, 0, *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1403EF3A0 (0x1403EF3A0) ---

// --- Function: sub_1403EF4D0 (0x1403EF4D0) ---
__int64 __fastcall sub_1403EF4D0(__int64 a1, __int64 a2, unsigned __int64 n0xC_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n0xC_1 > 0 )
  {
    if ( n0xC_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n0xC_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F91E0(a1, (unsigned int)n0xC + a2, n0xC_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F8B80(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F8DD0(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F8A30(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n0xC_1 )
    {
LABEL_46:
      if ( n0xC_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EF4D0 (0x1403EF4D0) ---

// --- Function: sub_1403EF740 (0x1403EF740) ---
__int64 __fastcall sub_1403EF740(const char *Val, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( Val )
    p_null = Val;
  if ( a5 )
    return sub_140303440(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EF740 (0x1403EF740) ---

// --- Function: sub_1403EF7E0 (0x1403EF7E0) ---
__int64 __fastcall sub_1403EF7E0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 0x10) )
    return sub_14035D730(a2, a3, 0, v3);
  else
    return sub_140300DE0(a2, a3, 0, v3);
}

// --- End Function: sub_1403EF7E0 (0x1403EF7E0) ---

// --- Function: sub_1403EF810 (0x1403EF810) ---
__int64 __fastcall sub_1403EF810(__int64 a1, void *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140303440(a2, Size_1, p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EF810 (0x1403EF810) ---

// --- Function: sub_1403EF930 (0x1403EF930) ---
// attributes: thunk
__int64 __fastcall sub_1403EF930(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1404F91E0(a1, a2, a3);
}

// --- End Function: sub_1403EF930 (0x1403EF930) ---

// --- Function: _snprintf_s (0x1403F11F0) ---
int snprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = (unsigned __int64 *)sub_1402A6BE0();
  result = _stdio_common_vsnprintf_s(*v8, DstBuf, SizeInBytes, MaxCount, Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: _snprintf_s (0x1403F11F0) ---

// --- Function: sub_1403FB1C0 (0x1403FB1C0) ---
__int64 __fastcall sub_1403FB1C0(__int64 *a1)
{
  _QWORD **v1; // rdx
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = (_QWORD **)*a1;
  **(_QWORD **)(*a1 + 8) = 0;
  v3 = *v1;
  if ( *v1 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      sub_1402A6590((__int64)v3);
      v3 = v4;
    }
    while ( v4 );
  }
  return sub_1402A6590(*a1);
}

// --- End Function: sub_1403FB1C0 (0x1403FB1C0) ---

// --- Function: sub_1403FC550 (0x1403FC550) ---
__int64 __fastcall sub_1403FC550(_QWORD *a1, __int64 a2)
{
  return *a1 + 0x18 * a2;
}

// --- End Function: sub_1403FC550 (0x1403FC550) ---

// --- Function: sub_14040AAF0 (0x14040AAF0) ---
__m128 __fastcall sub_14040AAF0(__int64 a1)
{
  __int128 v1; // xmm0
  __int128 v2; // kr00_16
  __int128 v4; // xmm0
  __int128 v5; // kr00_16
  __int128 v7; // kr00_16

  v2 = *(unsigned int *)(a1 + 0xF0);
  *(float *)&v2 = *(float *)(a1 + 0xF0) * 0.5;
  v1 = v2;
  *(float *)&v1 = tanf(*(float *)&v2);
  v5 = v1;
  *(float *)&v5 = *(float *)&v1 * *(float *)(a1 + 0xFC);
  v4 = v5;
  *(float *)&v4 = atanf(*(float *)&v5);
  v7 = v4;
  *(float *)&v7 = *(float *)&v4 + *(float *)&v4;
  return (__m128)v7;
}

// --- End Function: sub_14040AAF0 (0x14040AAF0) ---

// --- Function: sub_140414FE0 (0x140414FE0) ---
__int64 __fastcall sub_140414FE0(__int64 a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  float v10; // xmm0_4
  float v11; // xmm3_4
  float v12; // xmm5_4
  float v13; // kr00_4
  float v14; // xmm1_4
  float v15; // xmm3_4

  *(float *)(a1 + 0xF0) = a4;
  v10 = tanf(a4 * 0.5);
  *(float *)(a1 + 0x358) = v10 + v10;
  v11 = (float)a2 / a7;
  v12 = v11 * -0.5;
  v13 = (float)a3;
  *(float *)(a1 + 0xFC) = v11 / v13;
  v14 = (float)(v13 * 0.5) / v10;
  *(float *)(a1 + 0x114) = v14;
  *(float *)(a1 + 0x100) = a7;
  *(float *)(a1 + 0x104) = (float)((float)(v11 * -0.5) * a5) * (float)(1.0 / v14);
  *(float *)(a1 + 0x108) = a5;
  v15 = (float)(1.0 / v14) * a6;
  *(float *)(a1 + 0x10C) = (float)((float)(v13 * 0.5) * a5) * (float)(1.0 / v14);
  *(_DWORD *)(a1 + 0xF4) = a2;
  *(float *)(a1 + 0x11C) = v15 * v12;
  *(float *)(a1 + 0x124) = v15 * (float)(v13 * 0.5);
  *(float *)(a1 + 0x110) = v12;
  *(float *)(a1 + 0x118) = v13 * 0.5;
  *(float *)(a1 + 0x120) = a6;
  *(_DWORD *)(a1 + 0xF8) = a3;
  return sub_140417420(a1);
}

// --- End Function: sub_140414FE0 (0x140414FE0) ---

// --- Function: sub_140417420 (0x140417420) ---
__int64 __fastcall sub_140417420(unsigned __int64 *a1)
{
  float v9; // xmm12_4
  float v21; // xmm14_4
  float v22; // xmm13_4
  float v23; // xmm11_4
  float v24; // xmm6_4
  float v25; // xmm6_4
  float v26; // xmm12_4
  float v27; // xmm14_4
  float v28; // xmm13_4
  float v29; // xmm11_4
  float v30; // xmm6_4
  float v31; // xmm6_4
  float v32; // xmm11_4
  float v33; // xmm14_4
  float v34; // xmm13_4
  float v35; // xmm12_4
  float v36; // xmm6_4
  double v37; // xmm14_8
  double v38; // xmm13_8
  double v39; // xmm12_8
  double v40; // xmm11_8
  double v41; // xmm6_8
  double v42; // kr00_8
  double v47; // xmm12_8
  double v48; // xmm11_8
  double v49; // kr00_8
  double v50; // xmm6_8
  double v55; // xmm13_8
  double v56; // xmm11_8
  double v57; // xmm12_8
  double v58; // xmm14_8
  double v63; // xmm13_8
  double v64; // xmm11_8
  double v65; // kr00_8
  double v66; // xmm6_8
  double v71; // xmm11_8
  double v72; // xmm12_8
  double v73; // kr00_8
  double v78; // xmm11_8
  double v79; // xmm6_8
  double v80; // xmm6_8
  int v85; // eax
  double v86; // xmm6_8
  int v87; // edx
  BOOL v88; // ecx
  int v95; // ecx
  unsigned int v96; // ecx
  unsigned int v97; // ecx
  int v104; // ecx
  unsigned int v105; // ecx
  unsigned int v106; // ecx
  int v113; // ecx
  unsigned int v114; // ecx
  unsigned int v115; // ecx
  int v122; // ecx
  unsigned int v123; // ecx
  unsigned int v124; // ecx
  int v131; // ecx
  unsigned int v132; // ecx
  unsigned int v133; // ecx
  int v140; // ecx
  unsigned int v141; // ecx
  unsigned int v142; // ecx
  __int64 result; // rax
  float v144; // xmm5_4
  float v145; // xmm4_4
  float v146; // xmm3_4
  float v152; // xmm9_4
  float v154; // xmm5_4
  float v155; // xmm10_4
  __m128 v156; // kr00_16
  float v159; // xmm1_4
  float v166; // [rsp+0h] [rbp-108h]
  float v167; // [rsp+4h] [rbp-104h]
  float v168; // [rsp+Ch] [rbp-FCh]
  double v169; // [rsp+10h] [rbp-F8h]
  double v170; // [rsp+18h] [rbp-F0h]
  double v171; // [rsp+20h] [rbp-E8h]
  double v172; // [rsp+28h] [rbp-E0h]
  double v173; // [rsp+30h] [rbp-D8h]
  double v174; // [rsp+38h] [rbp-D0h]
  double v175; // [rsp+40h] [rbp-C8h]
  double v176; // [rsp+48h] [rbp-C0h]
  double v177; // [rsp+50h] [rbp-B8h]
  float v178; // [rsp+110h] [rbp+8h]
  double v179; // [rsp+110h] [rbp+8h]
  float v180; // [rsp+110h] [rbp+8h]
  float v181; // [rsp+110h] [rbp+8h]
  float v182; // [rsp+110h] [rbp+8h]
  float v183; // [rsp+110h] [rbp+8h]
  float v184; // [rsp+110h] [rbp+8h]
  float v185; // [rsp+110h] [rbp+8h]
  float v186; // [rsp+118h] [rbp+10h]
  double v187; // [rsp+118h] [rbp+10h]
  float v188; // [rsp+120h] [rbp+18h]
  double v189; // [rsp+120h] [rbp+18h]
  float v190; // [rsp+128h] [rbp+20h]
  double v191; // [rsp+128h] [rbp+20h]

  _XMM1 = a1[2];
  _XMM0 = *a1;
  _XMM2 = a1[0xA];
  __asm
  {
    vcvtsd2ss xmm10, xmm1, xmm1
    vcvtsd2ss xmm4, xmm0, xmm0
  }
  v172 = *((double *)a1 + 2);
  _XMM1 = a1[4];
  __asm { vcvtsd2ss xmm8, xmm1, xmm1 }
  v9 = *((float *)a1 + 0x46);
  v177 = *(double *)a1;
  _XMM0 = a1[1];
  v170 = *((double *)a1 + 4);
  _XMM1 = a1[5];
  __asm { vcvtsd2ss xmm3, xmm1, xmm1 }
  v174 = *((double *)a1 + 1);
  __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
  v176 = *((double *)a1 + 5);
  _XMM1 = a1[6];
  __asm { vcvtsd2ss xmm7, xmm1, xmm1 }
  v175 = *((double *)a1 + 6);
  _XMM1 = a1[8];
  __asm { vcvtsd2ss xmm9, xmm1, xmm1 }
  v169 = *((double *)a1 + 8);
  _XMM1 = a1[9];
  __asm { vcvtsd2ss xmm15, xmm1, xmm1 }
  v171 = *((double *)a1 + 9);
  LODWORD(_XMM1) = *((_DWORD *)a1 + 0x45);
  __asm { vcvtsd2ss xmm5, xmm2, xmm2 }
  v173 = *((double *)a1 + 0xA);
  LODWORD(_XMM2) = *((_DWORD *)a1 + 0x44);
  v21 = (float)(*(float *)&_XMM4 * *(float *)&_XMM2) + (float)(*(float *)&_XMM0 * *(float *)&_XMM1);
  v178 = *(float *)&_XMM4;
  v22 = (float)(*(float *)&_XMM8 * *(float *)&_XMM2) + (float)(*(float *)&_XMM3 * *(float *)&_XMM1);
  v188 = *(float *)&_XMM10;
  *(float *)&_XMM10 = *(float *)&_XMM10 * v9;
  v168 = *(float *)&_XMM3;
  v23 = (float)(*(float *)&_XMM9 * *(float *)&_XMM2) + (float)(*(float *)&_XMM15 * *(float *)&_XMM1);
  *((float *)a1 + 0x4F) = *(float *)&_XMM10 + v21;
  v190 = *(float *)&_XMM7;
  *(float *)&_XMM7 = *(float *)&_XMM7 * v9;
  *((float *)a1 + 0x50) = *(float *)&_XMM7 + v22;
  v167 = *(float *)&_XMM5;
  *(float *)&_XMM5 = *(float *)&_XMM5 * v9;
  *((float *)a1 + 0x51) = *(float *)&_XMM5 + v23;
  LODWORD(_XMM2) = _XMM2 ^ 0x80000000;
  v24 = (float)(*(float *)&_XMM2 * *(float *)&_XMM4) + (float)(*(float *)&_XMM0 * *(float *)&_XMM1);
  v186 = *(float *)&_XMM8;
  *(float *)&_XMM8 = (float)(*(float *)&_XMM8 * *(float *)&_XMM2) + (float)(*(float *)&_XMM3 * *(float *)&_XMM1);
  *((float *)a1 + 0x52) = v24 + *(float *)&_XMM10;
  v166 = *(float *)&_XMM9;
  *(float *)&_XMM9 = (float)(*(float *)&_XMM9 * *(float *)&_XMM2) + (float)(*(float *)&_XMM15 * *(float *)&_XMM1);
  *((float *)a1 + 0x53) = *(float *)&_XMM8 + *(float *)&_XMM7;
  *((float *)a1 + 0x54) = *(float *)&_XMM9 + *(float *)&_XMM5;
  *(float *)&_XMM2 = COERCE_FLOAT(LODWORD(v9) ^ 0x80000000) * v188;
  *(float *)&_XMM3 = COERCE_FLOAT(LODWORD(v9) ^ 0x80000000) * v190;
  *(float *)&_XMM4 = COERCE_FLOAT(LODWORD(v9) ^ 0x80000000) * v167;
  *((float *)a1 + 0x55) = v21 + *(float *)&_XMM2;
  *((float *)a1 + 0x56) = v22 + *(float *)&_XMM3;
  *((float *)a1 + 0x57) = v23 + *(float *)&_XMM4;
  *((float *)a1 + 0x58) = v24 + *(float *)&_XMM2;
  *((float *)a1 + 0x59) = *(float *)&_XMM8 + *(float *)&_XMM3;
  *((float *)a1 + 0x5A) = *(float *)&_XMM9 + *(float *)&_XMM4;
  v25 = *((float *)a1 + 0x41);
  LODWORD(_XMM2) = *((_DWORD *)a1 + 0x42);
  v26 = *((float *)a1 + 0x43);
  v27 = (float)(v25 * v178) + (float)(*(float *)&_XMM2 * *(float *)&_XMM0);
  v28 = (float)(v25 * v186) + (float)(*(float *)&_XMM2 * v168);
  v29 = (float)(v25 * v166) + (float)(*(float *)&_XMM15 * *(float *)&_XMM2);
  *((float *)a1 + 0x5B) = (float)(v26 * v188) + v27;
  *((float *)a1 + 0x5C) = (float)(v26 * v190) + v28;
  *(float *)&_XMM5 = (float)(COERCE_FLOAT(LODWORD(v25) ^ 0x80000000) * v178)
                   + (float)(*(float *)&_XMM2 * *(float *)&_XMM0);
  *(float *)&_XMM10 = (float)(COERCE_FLOAT(LODWORD(v25) ^ 0x80000000) * v166)
                    + (float)(*(float *)&_XMM15 * *(float *)&_XMM2);
  *((float *)a1 + 0x5D) = (float)(v26 * v167) + v29;
  v30 = (float)(COERCE_FLOAT(LODWORD(v25) ^ 0x80000000) * v186) + (float)(*(float *)&_XMM2 * v168);
  *((float *)a1 + 0x5E) = *(float *)&_XMM5 + (float)(v26 * v188);
  *((float *)a1 + 0x5F) = v30 + (float)(v26 * v190);
  *((float *)a1 + 0x60) = *(float *)&_XMM10 + (float)(v26 * v167);
  *(float *)&_XMM2 = COERCE_FLOAT(LODWORD(v26) ^ 0x80000000) * v188;
  *(float *)&_XMM3 = COERCE_FLOAT(LODWORD(v26) ^ 0x80000000) * v190;
  *(float *)&_XMM4 = COERCE_FLOAT(LODWORD(v26) ^ 0x80000000) * v167;
  *((float *)a1 + 0x61) = *(float *)&_XMM2 + v27;
  *((float *)a1 + 0x62) = *(float *)&_XMM3 + v28;
  *((float *)a1 + 0x63) = *(float *)&_XMM4 + v29;
  *((float *)a1 + 0x64) = *(float *)&_XMM2 + *(float *)&_XMM5;
  *((float *)a1 + 0x65) = *(float *)&_XMM3 + v30;
  *((float *)a1 + 0x66) = *(float *)&_XMM4 + *(float *)&_XMM10;
  v31 = *((float *)a1 + 0x47);
  LODWORD(_XMM2) = *((_DWORD *)a1 + 0x48);
  v32 = *((float *)a1 + 0x49);
  *(float *)&_XMM5 = *(float *)&_XMM2 * *(float *)&_XMM0;
  *(float *)&_XMM4 = *(float *)&_XMM2 * v168;
  v33 = (float)(v31 * v178) + (float)(*(float *)&_XMM2 * *(float *)&_XMM0);
  v34 = (float)(v31 * v186) + (float)(*(float *)&_XMM2 * v168);
  *(float *)&_XMM3 = *(float *)&_XMM2 * *(float *)&_XMM15;
  v35 = (float)(v31 * v166) + (float)(*(float *)&_XMM2 * *(float *)&_XMM15);
  *((float *)a1 + 0x67) = (float)(v32 * v188) + v33;
  *((float *)a1 + 0x68) = (float)(v32 * v190) + v34;
  *((float *)a1 + 0x69) = (float)(v32 * v167) + v35;
  LODWORD(_XMM2) = LODWORD(v31) ^ 0x80000000;
  *(float *)&_XMM1 = COERCE_FLOAT(LODWORD(v31) ^ 0x80000000) * v178;
  v36 = (float)(COERCE_FLOAT(LODWORD(v31) ^ 0x80000000) * v186) + *(float *)&_XMM4;
  *(float *)&_XMM5 = *(float *)&_XMM1 + *(float *)&_XMM5;
  *(float *)&_XMM10 = (float)(*(float *)&_XMM2 * v166) + *(float *)&_XMM3;
  *((float *)a1 + 0x6A) = *(float *)&_XMM5 + (float)(v32 * v188);
  *((float *)a1 + 0x6B) = v36 + (float)(v32 * v190);
  *(float *)&_XMM3 = COERCE_FLOAT(LODWORD(v32) ^ 0x80000000) * v190;
  *(float *)&_XMM2 = COERCE_FLOAT(LODWORD(v32) ^ 0x80000000) * v188;
  *(float *)&_XMM4 = COERCE_FLOAT(LODWORD(v32) ^ 0x80000000) * v167;
  *((float *)a1 + 0x6C) = *(float *)&_XMM10 + (float)(v32 * v167);
  *((float *)a1 + 0x6D) = *(float *)&_XMM2 + v33;
  *((float *)a1 + 0x6E) = *(float *)&_XMM3 + v34;
  *((float *)a1 + 0x6F) = *(float *)&_XMM4 + v35;
  *((float *)a1 + 0x70) = *(float *)&_XMM2 + *(float *)&_XMM5;
  *((float *)a1 + 0x71) = *(float *)&_XMM3 + v36;
  *((float *)a1 + 0x72) = *(float *)&_XMM4 + *(float *)&_XMM10;
  *(_QWORD *)&_XMM3 = a1[7];
  *(_QWORD *)&_XMM4 = a1[0xB];
  v37 = *((double *)a1 + 3);
  v38 = *((float *)a1 + 0x5E) + v37;
  v39 = *((float *)a1 + 0x5F) + *(double *)&_XMM3;
  *(double *)&_XMM10 = *((float *)a1 + 0x64) + v37 - v38;
  *(double *)&_XMM8 = *((float *)a1 + 0x65) + *(double *)&_XMM3 - v39;
  v40 = *((float *)a1 + 0x60) + *(double *)&_XMM4;
  *(double *)&_XMM7 = *((float *)a1 + 0x66) + *(double *)&_XMM4 - v40;
  v41 = *((float *)a1 + 0x5B) + v37 - v38;
  *(double *)&_XMM5 = *((float *)a1 + 0x5C) + *(double *)&_XMM3 - v39;
  v187 = *(double *)&_XMM4;
  v42 = *((float *)a1 + 0x5D) + *(double *)&_XMM4 - v40;
  v179 = *(double *)&_XMM3;
  *(double *)&_XMM9 = *(double *)&_XMM5 * *(double *)&_XMM7 - v42 * *(double *)&_XMM8;
  *(double *)&_XMM7 = v42 * *(double *)&_XMM10 - v41 * *(double *)&_XMM7;
  v191 = v37;
  *(double *)&_XMM5 = v41 * *(double *)&_XMM8 - *(double *)&_XMM5 * *(double *)&_XMM10;
  _XMM1 = COERCE_UNSIGNED_INT64(
            *(double *)&_XMM7 * *(double *)&_XMM7
          + *(double *)&_XMM9 * *(double *)&_XMM9
          + *(double *)&_XMM5 * *(double *)&_XMM5
          + 2.225073858507201e-308);
  __asm
  {
    vmovddup xmm2, xmm1
    vsqrtpd xmm4, xmm2
    vunpckhpd xmm4, xmm4, xmm4
  }
  *(double *)&_XMM0 = 1.0 / *(double *)&_XMM4;
  *(_QWORD *)&_XMM4 = a1[0xB];
  *((double *)a1 + 0x3A) = *(double *)&_XMM9 * *(double *)&_XMM0;
  *((double *)a1 + 0x3B) = *(double *)&_XMM7 * *(double *)&_XMM0;
  *((double *)a1 + 0x3C) = *(double *)&_XMM5 * *(double *)&_XMM0;
  *((double *)a1 + 0x3D) = -(*(double *)&_XMM7 * *(double *)&_XMM0 * v39
                           + v38 * (*(double *)&_XMM9 * *(double *)&_XMM0)
                           + v40 * (*(double *)&_XMM5 * *(double *)&_XMM0));
  *(double *)&_XMM15 = *((float *)a1 + 0x70) + v37;
  v47 = *((float *)a1 + 0x71) + *(double *)&_XMM3;
  v48 = *((float *)a1 + 0x72) + *(double *)&_XMM4;
  *(double *)&_XMM1 = *((float *)a1 + 0x6B) + *(double *)&_XMM3;
  v189 = *((float *)a1 + 0x6A) + v37;
  v49 = *((float *)a1 + 0x6C) + *(double *)&_XMM4 - v48;
  *(double *)&_XMM10 = (*(double *)&_XMM1 - v47) * (*(double *)&_XMM4 - v48) - v49 * (*(double *)&_XMM3 - v47);
  v50 = v49 * (v37 - *(double *)&_XMM15) - (v189 - *(double *)&_XMM15) * (*(double *)&_XMM4 - v48);
  *(double *)&_XMM4 = (v189 - *(double *)&_XMM15) * (*(double *)&_XMM3 - v47)
                    - (*(double *)&_XMM1 - v47) * (v37 - *(double *)&_XMM15);
  _XMM0 = COERCE_UNSIGNED_INT64(
            v50 * v50
          + *(double *)&_XMM10 * *(double *)&_XMM10
          + *(double *)&_XMM4 * *(double *)&_XMM4
          + 2.225073858507201e-308);
  __asm { vmovddup xmm3, xmm0 }
  __asm
  {
    vsqrtpd xmm1, xmm3
    vunpckhpd xmm1, xmm1, xmm1
  }
  *(double *)&_XMM2 = *(double *)&_XMM10 * (1.0 / *(double *)&_XMM1);
  a1[0x42] = *(unsigned __int64 *)&_XMM2;
  *(double *)&_XMM3 = v50 * (1.0 / *(double *)&_XMM1);
  *(double *)&_XMM4 = *(double *)&_XMM4 * (1.0 / *(double *)&_XMM1);
  a1[0x43] = *(unsigned __int64 *)&_XMM3;
  a1[0x44] = *(unsigned __int64 *)&_XMM4;
  *((double *)a1 + 0x45) = -(*(double *)&_XMM2 * *(double *)&_XMM15 + v47 * *(double *)&_XMM3 + v48 * *(double *)&_XMM4);
  v55 = *((float *)a1 + 0x67) + v37;
  v56 = *((float *)a1 + 0x68) + v179;
  v57 = *((float *)a1 + 0x69) + v187;
  *(double *)&_XMM10 = v37 - v55;
  v58 = *((float *)a1 + 0x6D) + v37;
  *(double *)&_XMM0 = *((float *)a1 + 0x6E) + v179;
  *(double *)&_XMM4 = *((float *)a1 + 0x6F) + v187 - v57;
  *(double *)&_XMM9 = (*(double *)&_XMM0 - v56) * (v187 - v57) - *(double *)&_XMM4 * (v179 - v56);
  *(double *)&_XMM7 = *(double *)&_XMM4 * *(double *)&_XMM10 - (v58 - v55) * (v187 - v57);
  *(double *)&_XMM4 = (v58 - v55) * (v179 - v56) - (*(double *)&_XMM0 - v56) * *(double *)&_XMM10;
  _XMM1 = COERCE_UNSIGNED_INT64(
            *(double *)&_XMM7 * *(double *)&_XMM7
          + *(double *)&_XMM9 * *(double *)&_XMM9
          + *(double *)&_XMM4 * *(double *)&_XMM4
          + 2.225073858507201e-308);
  __asm { vmovddup xmm3, xmm1 }
  __asm
  {
    vsqrtpd xmm0, xmm3
    vunpckhpd xmm0, xmm0, xmm0
  }
  *(double *)&_XMM0 = 1.0 / *(double *)&_XMM0;
  *(double *)&_XMM1 = *(double *)&_XMM7 * *(double *)&_XMM0;
  *(double *)&_XMM3 = *(double *)&_XMM4 * *(double *)&_XMM0;
  *((double *)a1 + 0x46) = *(double *)&_XMM9 * *(double *)&_XMM0;
  *((double *)a1 + 0x47) = *(double *)&_XMM7 * *(double *)&_XMM0;
  *(double *)&_XMM0 = v55 * (*(double *)&_XMM9 * *(double *)&_XMM0);
  v63 = v55 - v189;
  a1[0x48] = *(unsigned __int64 *)&_XMM3;
  *((double *)a1 + 0x49) = -(v56 * *(double *)&_XMM1 + *(double *)&_XMM0 + v57 * *(double *)&_XMM3);
  v64 = *((float *)a1 + 0x6B) + v179;
  *(double *)&_XMM10 = *((float *)a1 + 0x6C) + v187;
  *(double *)&_XMM4 = *((float *)a1 + 0x68) + v179 - v64;
  v65 = *((float *)a1 + 0x69) + v187 - *(double *)&_XMM10;
  *(double *)&_XMM8 = *(double *)&_XMM4 * (v187 - *(double *)&_XMM10) - v65 * (v179 - v64);
  v66 = v65 * (v191 - v189) - v63 * (v187 - *(double *)&_XMM10);
  *(double *)&_XMM5 = v63 * (v179 - v64) - *(double *)&_XMM4 * (v191 - v189);
  _XMM1 = COERCE_UNSIGNED_INT64(
            v66 * v66
          + *(double *)&_XMM8 * *(double *)&_XMM8
          + *(double *)&_XMM5 * *(double *)&_XMM5
          + 2.225073858507201e-308);
  __asm { vmovddup xmm3, xmm1 }
  __asm
  {
    vsqrtpd xmm0, xmm3
    vunpckhpd xmm0, xmm0, xmm0
  }
  *(double *)&_XMM0 = 1.0 / *(double *)&_XMM0;
  *((double *)a1 + 0x4A) = *(double *)&_XMM0 * *(double *)&_XMM8;
  *((double *)a1 + 0x4B) = *(double *)&_XMM0 * v66;
  *((double *)a1 + 0x4C) = *(double *)&_XMM0 * *(double *)&_XMM5;
  *((double *)a1 + 0x4D) = -(*(double *)&_XMM0 * *(double *)&_XMM8 * v189
                           + *(double *)&_XMM0 * v66 * v64
                           + *(double *)&_XMM0 * *(double *)&_XMM5 * *(double *)&_XMM10);
  v71 = *((float *)a1 + 0x6F) + v187;
  v72 = *((float *)a1 + 0x6E) + v179;
  *(double *)&_XMM4 = *((float *)a1 + 0x71) + v179 - v72;
  v73 = *((float *)a1 + 0x72) + v187 - v71;
  *(double *)&_XMM9 = *(double *)&_XMM4 * (v187 - v71) - v73 * (v179 - v72);
  *(double *)&_XMM8 = v73 * (v191 - v58) - (*(double *)&_XMM15 - v58) * (v187 - v71);
  *(double *)&_XMM5 = (*(double *)&_XMM15 - v58) * (v179 - v72) - *(double *)&_XMM4 * (v191 - v58);
  _XMM1 = COERCE_UNSIGNED_INT64(
            *(double *)&_XMM8 * *(double *)&_XMM8
          + *(double *)&_XMM9 * *(double *)&_XMM9
          + *(double *)&_XMM5 * *(double *)&_XMM5
          + 2.225073858507201e-308);
  __asm { vmovddup xmm3, xmm1 }
  __asm
  {
    vsqrtpd xmm0, xmm3
    vunpckhpd xmm0, xmm0, xmm0
  }
  *(double *)&_XMM0 = 1.0 / *(double *)&_XMM0;
  *((double *)a1 + 0x4E) = *(double *)&_XMM0 * *(double *)&_XMM9;
  *((double *)a1 + 0x4F) = *(double *)&_XMM0 * *(double *)&_XMM8;
  *((double *)a1 + 0x50) = *(double *)&_XMM0 * *(double *)&_XMM5;
  *((double *)a1 + 0x51) = -(v58 * (*(double *)&_XMM0 * *(double *)&_XMM9)
                           + *(double *)&_XMM0 * *(double *)&_XMM8 * v72
                           + *(double *)&_XMM0 * *(double *)&_XMM5 * v71);
  v78 = *((float *)a1 + 0x6B) + v179;
  *(double *)&_XMM8 = *((float *)a1 + 0x68) + v179 - v78;
  *(double *)&_XMM10 = *((float *)a1 + 0x6C) + v187;
  v79 = *((float *)a1 + 0x69) + v187 - *(double *)&_XMM10;
  *(double *)&_XMM5 = *((float *)a1 + 0x71) + v179 - v78;
  *(double *)&_XMM4 = *((float *)a1 + 0x72) + v187 - *(double *)&_XMM10;
  *(double *)&_XMM9 = *(double *)&_XMM5 * v79 - *(double *)&_XMM4 * *(double *)&_XMM8;
  v80 = *(double *)&_XMM4 * v63 - (*(double *)&_XMM15 - v189) * v79;
  *(double *)&_XMM4 = (*(double *)&_XMM15 - v189) * *(double *)&_XMM8 - *(double *)&_XMM5 * v63;
  _XMM0 = COERCE_UNSIGNED_INT64(
            v80 * v80
          + *(double *)&_XMM9 * *(double *)&_XMM9
          + *(double *)&_XMM4 * *(double *)&_XMM4
          + 2.225073858507201e-308);
  __asm { vmovddup xmm3, xmm0 }
  __asm
  {
    vsqrtpd xmm1, xmm3
    vunpckhpd xmm1, xmm1, xmm1
  }
  *(double *)&_XMM0 = 1.0 / *(double *)&_XMM1;
  *(double *)&_XMM1 = 1.0 / *(double *)&_XMM1 * v80;
  *((double *)a1 + 0x3E) = *(double *)&_XMM0 * *(double *)&_XMM9;
  a1[0x3F] = *(unsigned __int64 *)&_XMM1;
  *((double *)a1 + 0x40) = *(double *)&_XMM0 * *(double *)&_XMM4;
  *((double *)a1 + 0x41) = -(*(double *)&_XMM1 * v78
                           + *(double *)&_XMM0 * *(double *)&_XMM9 * v189
                           + *(double *)&_XMM0 * *(double *)&_XMM4 * *(double *)&_XMM10);
  v85 = 1;
  if ( fabs(v177 - (v176 * v173 - v171 * v175)) > 0.001 )
  {
    v86 = v169;
LABEL_6:
    v87 = 0;
    goto LABEL_7;
  }
  v86 = v169;
  if ( fabs(v170 - (v172 * v171 - v174 * v173)) > 0.001 || fabs(v169 - (v174 * v175 - v172 * v176)) > 0.001 )
    goto LABEL_6;
  v87 = 1;
LABEL_7:
  v88 = fabs(v174 - (v86 * v175 - v170 * v173)) <= 0.001
     && fabs(v176 - (v177 * v173 - v86 * v172)) <= 0.001
     && fabs(v171 - (v170 * v172 - v177 * v175)) <= 0.001;
  if ( fabs(v172 - (v170 * v171 - v86 * v176)) > 0.001
    || fabs(v175 - (v86 * v174 - v177 * v171)) > 0.001
    || fabs(v173 - (v177 * v176 - v170 * v174)) > 0.001 )
  {
    v85 = 0;
  }
  if ( (v88 & v85 & v87) == 0 )
  {
    *((_OWORD *)a1 + 0x1D) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x1E) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x21) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x22) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x23) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x24) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x25) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x26) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x27) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x28) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x1F) ^= xmmword_1482C3CD0;
    *((_OWORD *)a1 + 0x20) ^= xmmword_1482C3CD0;
  }
  _XMM0 = a1[0x3A];
  _XMM1 = a1[0x3B];
  __asm { vcvtpd2ps xmm0, xmm0 }
  v180 = *(float *)&_XMM0;
  _XMM0 = a1[0x3C];
  __asm { vcvtpd2ps xmm0, xmm0 }
  __asm { vcvtpd2ps xmm1, xmm1 }
  v95 = 3 * (LODWORD(v180) >> 0x1F);
  *((_DWORD *)a1 + 0xA4) = v95;
  *((_DWORD *)a1 + 0xB6) = 3 - v95;
  v96 = 3 * ((unsigned int)_XMM1 >> 0x1F);
  *((_DWORD *)a1 + 0xAA) = v96 + 1;
  *((_DWORD *)a1 + 0xBC) = 4 - v96;
  v97 = 3 * ((unsigned int)_XMM0 >> 0x1F);
  *((_DWORD *)a1 + 0xB0) = v97 + 2;
  *((_DWORD *)a1 + 0xC2) = 5 - v97;
  _XMM0 = a1[0x3E];
  _XMM1 = a1[0x3F];
  __asm { vcvtpd2ps xmm0, xmm0 }
  v181 = *(float *)&_XMM0;
  _XMM0 = a1[0x40];
  __asm { vcvtpd2ps xmm0, xmm0 }
  __asm { vcvtpd2ps xmm1, xmm1 }
  v104 = 3 * (LODWORD(v181) >> 0x1F);
  *((_DWORD *)a1 + 0xA5) = v104;
  *((_DWORD *)a1 + 0xB7) = 3 - v104;
  v105 = 3 * ((unsigned int)_XMM1 >> 0x1F);
  *((_DWORD *)a1 + 0xAB) = v105 + 1;
  *((_DWORD *)a1 + 0xBD) = 4 - v105;
  v106 = 3 * ((unsigned int)_XMM0 >> 0x1F);
  *((_DWORD *)a1 + 0xB1) = v106 + 2;
  *((_DWORD *)a1 + 0xC3) = 5 - v106;
  _XMM0 = a1[0x42];
  _XMM1 = a1[0x43];
  __asm { vcvtpd2ps xmm0, xmm0 }
  v182 = *(float *)&_XMM0;
  _XMM0 = a1[0x44];
  __asm
  {
    vcvtpd2ps xmm1, xmm1
    vcvtpd2ps xmm0, xmm0
  }
  v113 = 3 * (LODWORD(v182) >> 0x1F);
  *((_DWORD *)a1 + 0xA6) = v113;
  *((_DWORD *)a1 + 0xB8) = 3 - v113;
  v114 = 3 * ((unsigned int)_XMM1 >> 0x1F);
  *((_DWORD *)a1 + 0xAC) = v114 + 1;
  *((_DWORD *)a1 + 0xBE) = 4 - v114;
  v115 = 3 * ((unsigned int)_XMM0 >> 0x1F);
  *((_DWORD *)a1 + 0xB2) = v115 + 2;
  *((_DWORD *)a1 + 0xC4) = 5 - v115;
  _XMM0 = a1[0x46];
  _XMM1 = a1[0x47];
  __asm { vcvtpd2ps xmm0, xmm0 }
  v183 = *(float *)&_XMM0;
  _XMM0 = a1[0x48];
  __asm { vcvtpd2ps xmm0, xmm0 }
  __asm { vcvtpd2ps xmm1, xmm1 }
  v122 = 3 * (LODWORD(v183) >> 0x1F);
  *((_DWORD *)a1 + 0xA7) = v122;
  *((_DWORD *)a1 + 0xB9) = 3 - v122;
  v123 = 3 * ((unsigned int)_XMM1 >> 0x1F);
  *((_DWORD *)a1 + 0xAD) = v123 + 1;
  *((_DWORD *)a1 + 0xBF) = 4 - v123;
  v124 = 3 * ((unsigned int)_XMM0 >> 0x1F);
  *((_DWORD *)a1 + 0xB3) = v124 + 2;
  *((_DWORD *)a1 + 0xC5) = 5 - v124;
  _XMM0 = a1[0x4A];
  _XMM1 = a1[0x4B];
  __asm { vcvtpd2ps xmm0, xmm0 }
  v184 = *(float *)&_XMM0;
  _XMM0 = a1[0x4C];
  __asm { vcvtpd2ps xmm1, xmm1 }
  __asm { vcvtpd2ps xmm0, xmm0 }
  v131 = 3 * (LODWORD(v184) >> 0x1F);
  *((_DWORD *)a1 + 0xA8) = v131;
  *((_DWORD *)a1 + 0xBA) = 3 - v131;
  v132 = 3 * ((unsigned int)_XMM1 >> 0x1F);
  *((_DWORD *)a1 + 0xAE) = v132 + 1;
  *((_DWORD *)a1 + 0xC0) = 4 - v132;
  v133 = 3 * ((unsigned int)_XMM0 >> 0x1F);
  *((_DWORD *)a1 + 0xB4) = v133 + 2;
  *((_DWORD *)a1 + 0xC6) = 5 - v133;
  _XMM0 = a1[0x4E];
  _XMM1 = a1[0x4F];
  __asm { vcvtpd2ps xmm0, xmm0 }
  v185 = *(float *)&_XMM0;
  _XMM0 = a1[0x50];
  __asm { vcvtpd2ps xmm1, xmm1 }
  __asm { vcvtpd2ps xmm0, xmm0 }
  v140 = 3 * (LODWORD(v185) >> 0x1F);
  *((_DWORD *)a1 + 0xA9) = v140;
  *((_DWORD *)a1 + 0xBB) = 3 - v140;
  v141 = 3 * ((unsigned int)_XMM1 >> 0x1F);
  *((_DWORD *)a1 + 0xAF) = v141 + 1;
  *((_DWORD *)a1 + 0xC1) = 4 - v141;
  v142 = 3 * ((unsigned int)_XMM0 >> 0x1F);
  result = v142 + 2;
  *((_DWORD *)a1 + 0xB5) = result;
  *((_DWORD *)a1 + 0xC7) = 5 - v142;
  v144 = *((float *)a1 + 0xCC);
  v145 = *((float *)a1 + 0xCA);
  v146 = *((float *)a1 + 0xCB);
  _XMM7 = a1[5];
  _XMM8 = a1[9];
  _XMM6 = a1[1];
  __asm { vcvtpd2ps xmm7, xmm7 }
  __asm { vcvtpd2ps xmm8, xmm8 }
  v152 = (float)(*(float *)&_XMM7 * v144) - (float)(_XMM8.m128_f32[0] * v146);
  v156 = _XMM8;
  __asm { vcvtpd2ps xmm6, xmm6 }
  v154 = (float)(_XMM8.m128_f32[0] * v145) - (float)(*(float *)&_XMM6 * v144);
  v155 = (float)(*(float *)&_XMM6 * v146) - (float)(*(float *)&_XMM7 * v145);
  v156.m128_f32[0] = (float)((float)(v154 * v154) + (float)(v152 * v152)) + (float)(v155 * v155);
  if ( v156.m128_f32[0] <= 0.00000011920929 )
  {
    _XMM4 = *a1;
    _XMM5 = a1[4];
    _XMM2 = a1[8];
    __asm
    {
      vcvtpd2ps xmm4, xmm4
      vcvtpd2ps xmm5, xmm5
      vcvtpd2ps xmm2, xmm2
    }
  }
  else
  {
    _XMM0 = _mm_shuffle_ps(v156, v156, 0);
    __asm { vrsqrtps xmm3, xmm0 }
    _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
    v159 = (float)(1.5 - (float)((float)((float)(_XMM3.m128_f32[0] * v156.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
         * _XMM3.m128_f32[0];
    *(float *)&_XMM4 = v159 * v152;
    *(float *)&_XMM5 = v159 * v154;
    *(float *)&_XMM2 = v159 * v155;
  }
  *((float *)a1 + 0xCA) = (float)(_XMM8.m128_f32[0] * *(float *)&_XMM5) - (float)(*(float *)&_XMM7 * *(float *)&_XMM2);
  *((float *)a1 + 0xCB) = (float)(*(float *)&_XMM6 * *(float *)&_XMM2) - (float)(_XMM8.m128_f32[0] * *(float *)&_XMM4);
  *((float *)a1 + 0xCC) = (float)(*(float *)&_XMM7 * *(float *)&_XMM4) - (float)(*(float *)&_XMM6 * *(float *)&_XMM5);
  return result;
}

// --- End Function: sub_140417420 (0x140417420) ---

// --- Function: sub_140418940 (0x140418940) ---
_BYTE *__fastcall sub_140418940(__int64 *a1, __int64 n0x7F_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0x7F; // rcx

  result = a1 + 3;
  if ( n0x7F_1 )
  {
    allocSize = n0x7F_1 + 1;
    if ( (unsigned __int64)(n0x7F_1 + 1) <= 0x80 )
    {
      n0x7F = 0x7F;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149C80C40 += allocSize;
      n0x7F = n0x7F_1;
    }
    a1[1] = n0x7F;
    *a1 = n0x7F_1;
    a1[2] = (__int64)result;
    result[n0x7F_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0x7F;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_140418940 (0x140418940) ---

// --- Function: sub_14041CEA0 (0x14041CEA0) ---
bool __fastcall sub_14041CEA0(__int64 a1)
{
  return (*(_DWORD *)(a1 + 8) & 0x10) != 0;
}

// --- End Function: sub_14041CEA0 (0x14041CEA0) ---

// --- Function: sub_1404214A0 (0x1404214A0) ---
__int64 __fastcall sub_1404214A0(__int64 a1, int a2, const void **a3)
{
  *(__m256i *)a1 = (__m256i)0LL;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(__m256i *)(a1 + 0x30) = (__m256i)0LL;
  *(__m256i *)(a1 + 0x50) = (__m256i)0LL;
  *(__m256i *)(a1 + 0x70) = (__m256i)0LL;
  *(__m256i *)(a1 + 0x90) = (__m256i)0LL;
  __asm { vzeroupper }
  sub_14035DE10((void **)(a1 + 0xB0), a3);
  *(_DWORD *)(a1 + 0xB8) = a2;
  *(_BYTE *)(a1 + 0xBC) = 0;
  sub_140421D90(a1);
  return a1;
}

// --- End Function: sub_1404214A0 (0x1404214A0) ---

// --- Function: sub_140421510 (0x140421510) ---
__int64 sub_140421510(__int64 a1, int a2, const char *Format_1, ...)
{
  _QWORD *v5; // rbx
  int v6; // eax
  __int64 v7; // rax
  char *Buffer[7]; // [rsp+30h] [rbp-38h] BYREF
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, Format_1);
  *(__m256i *)a1 = (__m256i)0LL;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(__m256i *)(a1 + 0x30) = (__m256i)0LL;
  *(__m256i *)(a1 + 0x50) = (__m256i)0LL;
  *(__m256i *)(a1 + 0x70) = (__m256i)0LL;
  *(__m256i *)(a1 + 0x90) = (__m256i)0LL;
  __asm { vzeroupper }
  sub_14035E090((_QWORD *)(a1 + 0xB0));
  *(_DWORD *)(a1 + 0xB8) = a2;
  *(_BYTE *)(a1 + 0xBC) = 0;
  sub_14035E090(Buffer);
  v5 = sub_1402A6BE0();
  v6 = _stdio_common_vsprintf(*v5 | 2LL, 0, 0, Format_1, 0, va);
  if ( v6 < 0 )
    v6 = 0xFFFFFFFF;
  sub_1403EDAA0((void **)Buffer, v6, 0x20);
  v7 = sub_1403EBE30(Buffer);
  _stdio_common_vsprintf(*v5 | 2LL, Buffer[0], v7 + 1, Format_1, 0, va);
  sub_14037AE80((void **)(a1 + 0xB0), (void **)Buffer);
  sub_140421D90(a1);
  sub_140373CC0(Buffer);
  return a1;
}

// --- End Function: sub_140421510 (0x140421510) ---

// --- Function: sub_140421990 (0x140421990) ---
_QWORD *__fastcall sub_140421990(_QWORD *a1, int a2)
{
  _BYTE *v3; // rdi
  __int64 v5; // [rsp+20h] [rbp-238h] BYREF
  __int64 n0x1FF; // [rsp+28h] [rbp-230h]
  _BYTE *v7; // [rsp+30h] [rbp-228h]
  _BYTE v8[520]; // [rsp+38h] [rbp-220h] BYREF

  v8[0] = 0;
  v5 = 0;
  v7 = v8;
  n0x1FF = 0x1FF;
  v3 = *(_BYTE **)(sub_1402A59F0((__int64)&v5, "@ui_error_message_%d", a2) + 0x10);
  sub_14035E090(a1);
  if ( v3 && *v3 == 0x40 )
    assignCStringToStringStructure((__int64)a1, (__int64)v3);
  if ( v7 != v8 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
    sub_147715880(v7);
  }
  return a1;
}

// --- End Function: sub_140421990 (0x140421990) ---

// --- Function: sub_140421D90 (0x140421D90) ---
int *__fastcall sub_140421D90(_OWORD *a1)
{
  int *ThreadLogContextSlot; // rax
  __int64 v3; // rdx
  char v4; // bl
  int *ThreadLogContextSlot_1; // rax

  ThreadLogContextSlot = getThreadLogContextSlot();
  v3 = 0;
  while ( !*((_BYTE *)ThreadLogContextSlot + v3) )
  {
    if ( (unsigned __int64)++v3 >= 0x10 )
    {
      v4 = 1;
      sub_1404D8FD0();
      goto LABEL_6;
    }
  }
  v4 = 0;
LABEL_6:
  ThreadLogContextSlot_1 = getThreadLogContextSlot();
  *a1 = *(_OWORD *)ThreadLogContextSlot_1;
  a1[1] = *((_OWORD *)ThreadLogContextSlot_1 + 1);
  a1[2] = *((_OWORD *)ThreadLogContextSlot_1 + 2);
  a1[3] = *((_OWORD *)ThreadLogContextSlot_1 + 3);
  a1[4] = *((_OWORD *)ThreadLogContextSlot_1 + 4);
  a1[5] = *((_OWORD *)ThreadLogContextSlot_1 + 5);
  a1[6] = *((_OWORD *)ThreadLogContextSlot_1 + 6);
  a1[7] = *((_OWORD *)ThreadLogContextSlot_1 + 7);
  a1[8] = *((_OWORD *)ThreadLogContextSlot_1 + 8);
  a1[9] = *((_OWORD *)ThreadLogContextSlot_1 + 9);
  a1[0xA] = *((_OWORD *)ThreadLogContextSlot_1 + 0xA);
  if ( qword_149C8E0F8 && qword_149C8DF30 )
    ThreadLogContextSlot_1 = (int *)(*(__int64 (__fastcall **)(__int64, _OWORD *))(*(_QWORD *)qword_149C8DF30 + 0xA0LL))(
                                      qword_149C8DF30,
                                      a1);
  if ( v4 )
    return (int *)sub_1404D5120();
  return ThreadLogContextSlot_1;
}

// --- End Function: sub_140421D90 (0x140421D90) ---

// --- Function: sub_140421EA0 (0x140421EA0) ---
__int64 __fastcall sub_140421EA0(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rdi
  __int64 i; // rbx

  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  result = (__int64)sub_1403E8680((void **)(a1 + 0x20));
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  v3 = *(_QWORD *)(a1 + 0x40);
  for ( i = *(_QWORD *)(a1 + 0x38); i != v3; i += 0x28 )
  {
    result = sub_1403EDAA0((void **)i, 0, 0x20);
    *(_QWORD *)(i + 8) = 0;
    *(_QWORD *)(i + 0x10) = 0;
    *(_QWORD *)(i + 0x18) = 0;
    *(_DWORD *)(i + 0x20) = 0;
  }
  return result;
}

// --- End Function: sub_140421EA0 (0x140421EA0) ---

// --- Function: sub_140422000 (0x140422000) ---
unsigned __int64 __fastcall sub_140422000(_DWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  int v3; // ebx

  result = (unsigned int)a1[1];
  v3 = a2;
  if ( a2 <= result )
  {
    *a1 = a2;
  }
  else
  {
    result = sub_140421F20();
    *a1 = v3;
  }
  return result;
}

// --- End Function: sub_140422000 (0x140422000) ---

// --- Function: sub_140422D90 (0x140422D90) ---
__int64 *sub_140422D90()
{
  if ( (dword_149C84EF0 & 1) == 0 )
  {
    dword_149C84EE8 = 1;
    dword_149C84EF0 |= 1u;
    qword_149C84EE0 = (__int64)&qword_149C84EA0;
    qword_149C84EC0 = 0;
    p_system = (__int64)"system";
    p_analytics = (__int64)"analytics";
    p_Analytics_system_configuration = (__int64)"Analytics system configuration";
    qword_149C84EA0 = (__int64)&off_1482DC368;
    qword_149C84ED0 = (__int64)off_1482E5170;   // "enable_new_analytics_service"
    qword_149C84ED8 = 0;
    qword_149C84EC8 = (__int64)&off_1482B51A8;
    atexit(nullsub_11);
  }
  return &qword_149C84EA0;
}

// --- End Function: sub_140422D90 (0x140422D90) ---

// --- Function: sub_140422EA0 (0x140422EA0) ---
void *sub_140422EA0()
{
  if ( (dword_149C84BF0 & 1) == 0 )
  {
    dword_149C84BF0 |= 1u;
    sub_14045BB60(&unk_149C84A60, 0);
    atexit(nullsub_13);
  }
  return &unk_149C84A60;
}

// --- End Function: sub_140422EA0 (0x140422EA0) ---

// --- Function: sub_140422EF0 (0x140422EF0) ---
void *sub_140422EF0()
{
  if ( (dword_149C84E30 & 1) == 0 )
  {
    dword_149C84E30 |= 1u;
    sub_14045C8E0(&unk_149C84C00, 0);
    atexit(nullsub_14);
  }
  return &unk_149C84C00;
}

// --- End Function: sub_140422EF0 (0x140422EF0) ---

// --- Function: sub_140425FD0 (0x140425FD0) ---
__int64 __fastcall sub_140425FD0(__int64 *a1, __int64 a2)
{
  __int64 v3; // r13
  __int64 v4; // rdx
  __int64 v5; // r15
  __int64 v6; // r12
  _QWORD *v7; // rsi
  __int64 v8; // rdi
  _QWORD *v9; // rbx
  _OWORD *v10; // r13
  __int64 v11; // rsi
  _QWORD *v12; // rdi
  _QWORD *i; // rbx
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 result; // rax

  v3 = a2;
  v4 = (a1[1] - *a1) / 0xD0;
  if ( v4 )
  {
    v5 = 2 * v4;
    if ( !(2 * v4) )
    {
      v6 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    v5 = 1;
  }
  v6 = sub_1402A65A0(0xD0 * v5);
LABEL_6:
  v7 = (_QWORD *)a1[1];
  v8 = v6;
  v9 = (_QWORD *)*a1;
  if ( (_QWORD *)*a1 != v7 )
  {
    v10 = v9 + 3;
    do
    {
      sub_14035DAD0((_QWORD *)v8, v9);
      *(_OWORD *)(v8 + 0x18) = *v10;
      *(_OWORD *)(v8 + 0x28) = v10[1];
      *(_OWORD *)(v8 + 0x38) = v10[2];
      *(_OWORD *)(v8 + 0x48) = v10[3];
      *(_OWORD *)(v8 + 0x58) = v10[4];
      *(_OWORD *)(v8 + 0x68) = v10[5];
      *(_OWORD *)(v8 + 0x78) = v10[6];
      *(_OWORD *)(v8 + 0x88) = v10[7];
      *(_OWORD *)(v8 + 0x98) = v10[8];
      *(_OWORD *)(v8 + 0xA8) = v10[9];
      *(_OWORD *)(v8 + 0xB8) = v10[0xA];
      v8 += 0xD0;
      v10 += 0xD;
      v9 += 0x1A;
    }
    while ( v9 != v7 );
    v3 = a2;
  }
  sub_14035DAD0((_QWORD *)v8, (_QWORD *)v3);
  *(_OWORD *)(v8 + 0x18) = *(_OWORD *)(v3 + 0x18);
  *(_OWORD *)(v8 + 0x28) = *(_OWORD *)(v3 + 0x28);
  *(_OWORD *)(v8 + 0x38) = *(_OWORD *)(v3 + 0x38);
  *(_OWORD *)(v8 + 0x48) = *(_OWORD *)(v3 + 0x48);
  *(_OWORD *)(v8 + 0x58) = *(_OWORD *)(v3 + 0x58);
  *(_OWORD *)(v8 + 0x68) = *(_OWORD *)(v3 + 0x68);
  *(_OWORD *)(v8 + 0x78) = *(_OWORD *)(v3 + 0x78);
  *(_OWORD *)(v8 + 0x88) = *(_OWORD *)(v3 + 0x88);
  *(_OWORD *)(v8 + 0x98) = *(_OWORD *)(v3 + 0x98);
  *(_OWORD *)(v8 + 0xA8) = *(_OWORD *)(v3 + 0xA8);
  v11 = v8 + 0xD0;
  *(_OWORD *)(v8 + 0xB8) = *(_OWORD *)(v3 + 0xB8);
  v12 = (_QWORD *)a1[1];
  for ( i = (_QWORD *)*a1; i != v12; i += 0x1A )
  {
    n2 = (void (__fastcall *)(__int64, _QWORD *))i[1];
    if ( (unsigned __int64)n2 >= 2 )
    {
      n2(2, i);
      i[1] = 0;
    }
    *i = 0;
  }
  if ( *a1 )
    sub_1402A6590(*a1);
  *a1 = v6;
  result = v6 + 0xD0 * v5;
  a1[1] = v11;
  a1[2] = result;
  return result;
}

// --- End Function: sub_140425FD0 (0x140425FD0) ---

// --- Function: sub_140445600 (0x140445600) ---
char __fastcall sub_140445600(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10)
{
  __int64 v11; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v16; // [rsp+A0h] [rbp-70h]
  const char *p_ErrorCode; // [rsp+A8h] [rbp-68h]
  __int64 v18; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EF3A0)(__int64, __int64, __int64); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EF3A0_1)(__int64, __int64, __int64); // [rsp+C0h] [rbp-50h]
  __int64 v21; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v23; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E9240)(__int64); // [rsp+E0h] [rbp-30h]
  _OWORD *(__fastcall *p_sub_1403E8F40)(_OWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v26; // [rsp+F0h] [rbp-20h]
  char v27; // [rsp+F8h] [rbp-18h]
  char v28; // [rsp+F9h] [rbp-17h]
  __int64 n0x10; // [rsp+100h] [rbp-10h]
  __int64 n0x15; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  n0x100 = 0x100;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  v16 = a10;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  p_ErrorCode = "ErrorCode";
  v28 = 0;
  v18 = *a10;
  p_sub_1403EF3A0 = sub_1403EF3A0;
  p_sub_1403EF3A0_1 = sub_1403EF3A0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E9240 = sub_1403E9240;
  p_sub_1403E8F40 = sub_1403E8F40;
  LODWORD(v11) = a6;
  v21 = 0;
  v23 = 0;
  v26 = 0xFFFFFFFFFFFFFFFFuLL;
  v27 = 0;
  n0x10 = 0x10;
  n0x15 = 0x15;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 2u, a5, v11, a7, a8);
}

// --- End Function: sub_140445600 (0x140445600) ---

// --- Function: sub_140451090 (0x140451090) ---
__int64 __fastcall sub_140451090(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rsi

  v2 = a1[1];
  if ( v2 >= a1[2] )
  {
    sub_140425FD0(a1, a2);
  }
  else
  {
    sub_14035DAD0((_QWORD *)a1[1], (_QWORD *)a2);
    *(_OWORD *)(v2 + 0x18) = *(_OWORD *)(a2 + 0x18);
    *(_OWORD *)(v2 + 0x28) = *(_OWORD *)(a2 + 0x28);
    *(_OWORD *)(v2 + 0x38) = *(_OWORD *)(a2 + 0x38);
    *(_OWORD *)(v2 + 0x48) = *(_OWORD *)(a2 + 0x48);
    *(_OWORD *)(v2 + 0x58) = *(_OWORD *)(a2 + 0x58);
    *(_OWORD *)(v2 + 0x68) = *(_OWORD *)(a2 + 0x68);
    *(_OWORD *)(v2 + 0x78) = *(_OWORD *)(a2 + 0x78);
    *(_OWORD *)(v2 + 0x88) = *(_OWORD *)(a2 + 0x88);
    *(_OWORD *)(v2 + 0x98) = *(_OWORD *)(a2 + 0x98);
    *(_OWORD *)(v2 + 0xA8) = *(_OWORD *)(a2 + 0xA8);
    *(_OWORD *)(v2 + 0xB8) = *(_OWORD *)(a2 + 0xB8);
    a1[1] += 0xD0;
  }
  return a1[1] - 0xD0;
}

// --- End Function: sub_140451090 (0x140451090) ---

// --- Function: sub_140454810 (0x140454810) ---
__int64 __fastcall sub_140454810(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  int v10; // eax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 0x2D;
    a4 = -a4 & 0x7FFFFFFF;
    v6 = 1;
  }
  else
  {
    v6 = 0xFFFFFFFF;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
      return 0xFFFFFFFFLL;
    ++v6;
    v10 = a4 % 0xA;
    a4 /= 0xA;
    *(_BYTE *)(v8 + v4) = v10 + 0x30;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_140454810 (0x140454810) ---

// --- Function: sub_140455020 (0x140455020) ---
unsigned __int64 *__fastcall sub_140455020(unsigned __int64 *a1, __int64 **a2)
{
  unsigned __int64 v3; // r14
  __int64 *v4; // rbx
  int v5; // ecx
  int v6; // r8d
  __int64 v7; // rbp
  int v8; // eax
  int v9; // edi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // rax
  _QWORD *v16; // rax
  _QWORD *i; // r8
  __int64 v18; // rcx
  int v20; // [rsp+50h] [rbp+8h] BYREF

  v3 = (unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL;
  *a1 = (unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL;
  v4 = *a2;
  v5 = *(_DWORD *)(((unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL) - 4);
  v6 = v5 & 0x7FFFFFFF;
  v7 = *((unsigned int *)*a2 + 0xFFFFFFFF);
  LODWORD(v7) = v7 & 0x7FFFFFFF;
  v8 = 8 * v5;
  v9 = (v5 & 0x7FFFFFFF) + v7;
  if ( v5 >= 0 )
    v10 = (unsigned __int64)v8 >> 3;
  else
    LODWORD(v10) = *(_DWORD *)(v3 + v8);
  v11 = (unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL;
  if ( v9 != (_DWORD)v10 )
  {
    v12 = 0;
    v20 = v6 + v7;
    if ( v5 )
      v12 = (unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL;
    v13 = sub_14035CDA0((__int64)a1, v12, v6, &v20, 8u, 0);
    *a1 = v13;
    v11 = v13;
    if ( !v13 )
    {
      *a1 = v3;
      goto LABEL_12;
    }
    LODWORD(v10) = v20;
  }
  v14 = 8 * v9;
  *(_DWORD *)(v11 - 4) = v9;
  if ( 8LL * (int)v10 >= (unsigned __int64)(v14 + 4) )
  {
    *(_DWORD *)(v11 - 4) = v9 | 0x80000000;
    *(_DWORD *)(v14 + v11) = v10;
  }
LABEL_12:
  v15 = *(unsigned int *)(*a1 - 4);
  LODWORD(v15) = v15 & 0x7FFFFFFF;
  v16 = (_QWORD *)(*a1 + 8 * (v15 - (unsigned int)v7));
  for ( i = &v16[v7]; v16 != i; ++v16 )
  {
    v18 = *v4++;
    *v16 = v18;
  }
  return a1;
}

// --- End Function: sub_140455020 (0x140455020) ---

// --- Function: sub_140455620 (0x140455620) ---
_QWORD *__fastcall sub_140455620(_QWORD *a1)
{
  a1[3] = 0x3FF0000000000000LL;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  return a1;
}

// --- End Function: sub_140455620 (0x140455620) ---

// --- Function: sub_140455660 (0x140455660) ---
__int64 __fastcall sub_140455660(__int64 a1, __int64 a2)
{
  _QWORD *v2; // r14
  _QWORD *v3; // rdi
  double v5; // xmm2_8
  __int64 v6; // rbx
  char v8; // [rsp+80h] [rbp+8h] BYREF
  char v9; // [rsp+88h] [rbp+10h] BYREF

  v2 = (_QWORD *)(a2 + 0x38);
  *(_QWORD *)(a1 + 0x18) = 0;
  v3 = (_QWORD *)(a2 + 0x40);
  *(_QWORD *)(a1 + 0x20) = 0;
  v5 = *(double *)(a2 + 0x30);
  *(_OWORD *)a1 = *(_OWORD *)(a2 + 0x20);
  *(double *)(a1 + 0x10) = v5;
  if ( !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a2 + 0x38))
    || (v6 = *v3,
        *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*v2 & 0xFFFFFFFFFFFFLL) + 8LL))(
                     *v2 & 0xFFFFFFFFFFFFLL,
                     &v8) != v6) )
  {
    *v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                       qword_149C8DFC0,
                       &v9,
                       *v3);
  }
  *(_QWORD *)(a1 + 0x18) = *v2;
  *(_QWORD *)(a1 + 0x20) = *v3;
  return a1;
}

// --- End Function: sub_140455660 (0x140455660) ---

// --- Function: sub_140459BF0 (0x140459BF0) ---
__int64 __fastcall sub_140459BF0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        __int64 a6,
        void *Src,
        unsigned __int8 n4_1,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int8 n4; // dl
  __int64 v13; // rcx

  *(_OWORD *)a1 = *(_OWORD *)a3;
  *(double *)(a1 + 0x10) = *(double *)(a3 + 0x10);
  *(double *)(a1 + 0x18) = *(double *)a4;
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a4 + 8);
  n4 = 4;
  *(_QWORD *)(a1 + 0x28) = a6;
  *(_DWORD *)(a1 + 0x30) = a5;
  *(_QWORD *)(a1 + 0x38) = a9;
  *(_BYTE *)(a1 + 0x34) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x98) = &p_Src;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_DWORD *)(a1 + 0x88) = 0;
  *(_DWORD *)(a1 + 0x8C) = 8;
  if ( n4_1 <= 4u )
    n4 = n4_1;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_DWORD *)(a1 + 0xA0) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0xA4) = 0;
  *(_BYTE *)(a1 + 0xA8) = n4;
  v13 = *a10;
  *(_QWORD *)(a1 + 0xB0) = *a10;
  if ( v13 )
    sub_140527EA0(v13);
  *(_QWORD *)(a1 + 0xB8) = a2;
  if ( Src )
    sub_14046E340((void *)(a1 + 0x40), Src);
  if ( *a10 )
    sub_140527EC0(*a10, 0);
  return a1;
}

// --- End Function: sub_140459BF0 (0x140459BF0) ---

// --- Function: sub_14045A0B0 (0x14045A0B0) ---
void **__fastcall sub_14045A0B0(void **a1)
{
  sub_14035E090(a1);
  sub_1403ED3F0(a1, 0x400u);
  return a1;
}

// --- End Function: sub_14045A0B0 (0x14045A0B0) ---

// --- Function: sub_14045BB60 (0x14045BB60) ---
__int64 __fastcall sub_14045BB60(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 result; // rax

  *(_QWORD *)(a1 + 0x20) = a2;
  *(_QWORD *)(a1 + 8) = "system";
  *(_QWORD *)(a1 + 0x40) = a1;
  *(_QWORD *)(a1 + 0x10) = "game";
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x18) = "Game settings";
  *(_QWORD *)a1 = &off_1482DD440;
  *(_QWORD *)(a1 + 0x30) = off_1482DCD80;       // "dll_common"
  *(_QWORD *)(a1 + 0x28) = &off_1482B5178;
  v3 = *(_QWORD *)(a1 + 0x20);
  if ( v3 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v3 + 0x60LL))(v3, a1, a1 + 0x28);
  *(_QWORD *)(a1 + 0x48) = "Game.dll";
  *(_QWORD *)(a1 + 0x28) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x58) = off_1482B5520;       // "dll_specific"
  *(_QWORD *)(a1 + 0x50) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = a1;
  v4 = *(_QWORD *)(a1 + 0x20);
  if ( v4 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 0x60LL))(v4, a1, a1 + 0x50);
  *(_QWORD *)(a1 + 0x50) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x70) = &p_Src;
  *(_QWORD *)(a1 + 0x78) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x80) = off_1482DCE60;       // "config_filename"
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = a1;
  v5 = *(_QWORD *)(a1 + 0x20);
  if ( v5 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 0x60LL))(v5, a1, a1 + 0x78);
  *(_QWORD *)(a1 + 0x78) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x98) = "user.cfg";
  *(_QWORD *)(a1 + 0xA8) = off_1482DCF40;       // "config_folder"
  *(_QWORD *)(a1 + 0xA0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = a1;
  v6 = *(_QWORD *)(a1 + 0x20);
  if ( v6 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 0x60LL))(v6, a1, a1 + 0xA0);
  *(_QWORD *)(a1 + 0xA0) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0xC0) = &p_Src;
  *(_QWORD *)(a1 + 0xC8) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xD0) = off_1482DD020;       // "user_folder"
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = a1;
  v7 = *(_QWORD *)(a1 + 0x20);
  if ( v7 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v7 + 0x60LL))(v7, a1, a1 + 0xC8);
  *(_QWORD *)(a1 + 0xC8) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0xE8) = &p_Src;
  *(_QWORD *)(a1 + 0xF0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xF8) = off_1482B5610;       // "split_data_folder"
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = a1;
  v8 = *(_QWORD *)(a1 + 0x20);
  if ( v8 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v8 + 0x60LL))(v8, a1, a1 + 0xF0);
  *(_QWORD *)(a1 + 0xF0) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x110) = &p_Src;
  *(_QWORD *)(a1 + 0x118) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x120) = off_1482DD110;      // "localization_folder"
  *(_QWORD *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x130) = a1;
  v9 = *(_QWORD *)(a1 + 0x20);
  if ( v9 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v9 + 0x60LL))(v9, a1, a1 + 0x118);
  *(_QWORD *)(a1 + 0x118) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x138) = "Localization";
  *(_QWORD *)(a1 + 0x140) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x148) = off_1482DD290;      // "additionalcfg"
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = a1;
  v10 = *(_QWORD *)(a1 + 0x20);
  if ( v10 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v10 + 0x60LL))(v10, a1, a1 + 0x140);
  *(_QWORD *)(a1 + 0x140) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x170) = off_1482DD370;      // "time_demo_snap_rate"
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = a1;
  v11 = *(_QWORD *)(a1 + 0x20);
  if ( v11 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v11 + 0x60LL))(v11, a1, a1 + 0x168);
  *(_QWORD *)(a1 + 0x168) = &off_1482CE430;
  result = a1;
  *(_DWORD *)(a1 + 0x188) = 1;
  return result;
}

// --- End Function: sub_14045BB60 (0x14045BB60) ---

// --- Function: sub_14045BE00 (0x14045BE00) ---
__int64 __fastcall sub_14045BE00(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 result; // rax

  *(_QWORD *)(a1 + 0x20) = a2;
  *(_QWORD *)(a1 + 8) = "system";
  *(_QWORD *)(a1 + 0x40) = a1;
  *(_QWORD *)(a1 + 0x10) = "log";
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x18) = "Engine log settings";
  *(_QWORD *)a1 = &off_1482DBAE0;
  *(_QWORD *)(a1 + 0x30) = off_1482B5310;       // "filename"
  *(_QWORD *)(a1 + 0x28) = &off_1482B5178;
  v3 = *(_QWORD *)(a1 + 0x20);
  if ( v3 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v3 + 0x60LL))(v3, a1, a1 + 0x28);
  *(_QWORD *)(a1 + 0x28) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x48) = &p_Src;
  *(_QWORD *)(a1 + 0x50) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x58) = off_1482DA5F0;       // "directory"
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = a1;
  v4 = *(_QWORD *)(a1 + 0x20);
  if ( v4 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 0x60LL))(v4, a1, a1 + 0x50);
  *(_QWORD *)(a1 + 0x50) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x70) = &p_Src;
  *(_QWORD *)(a1 + 0x80) = off_1482DA6F0;       // "stdout_filename"
  *(_QWORD *)(a1 + 0x78) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = a1;
  v5 = *(_QWORD *)(a1 + 0x20);
  if ( v5 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 0x60LL))(v5, a1, a1 + 0x78);
  *(_QWORD *)(a1 + 0x78) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x98) = &p_Src;
  *(_QWORD *)(a1 + 0xA0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xA8) = off_1482DA7D0;       // "stderr_filename"
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = a1;
  v6 = *(_QWORD *)(a1 + 0x20);
  if ( v6 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 0x60LL))(v6, a1, a1 + 0xA0);
  *(_QWORD *)(a1 + 0xA0) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0xC0) = &p_Src;
  *(_QWORD *)(a1 + 0xC8) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xD0) = off_1482DA890;       // "timestamp"
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = a1;
  v7 = *(_QWORD *)(a1 + 0x20);
  if ( v7 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v7 + 0x60LL))(v7, a1, a1 + 0xC8);
  *(_DWORD *)(a1 + 0xE8) = 0;
  *(_QWORD *)(a1 + 0xC8) = &off_1482CE430;
  *(_QWORD *)(a1 + 0xF0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xF8) = off_1482DAA50;       // "timestamp_file"
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = a1;
  v8 = *(_QWORD *)(a1 + 0x20);
  if ( v8 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v8 + 0x60LL))(v8, a1, a1 + 0xF0);
  *(_QWORD *)(a1 + 0xF0) = &off_1482CE430;
  *(_DWORD *)(a1 + 0x110) = 6;
  *(_QWORD *)(a1 + 0x118) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x120) = off_1482DAB80;      // "verbosity"
  *(_QWORD *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x130) = a1;
  v9 = *(_QWORD *)(a1 + 0x20);
  if ( v9 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v9 + 0x60LL))(v9, a1, a1 + 0x118);
  *(_QWORD *)(a1 + 0x118) = &off_1482CE430;
  *(_DWORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x148) = off_1482DAD40;      // "verbosity_trace"
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = a1;
  v10 = *(_QWORD *)(a1 + 0x20);
  if ( v10 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v10 + 0x60LL))(v10, a1, a1 + 0x140);
  *(_QWORD *)(a1 + 0x140) = &off_1482CE430;
  *(_DWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x170) = off_1482DAF20;      // "verbosity_file"
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = a1;
  v11 = *(_QWORD *)(a1 + 0x20);
  if ( v11 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v11 + 0x60LL))(v11, a1, a1 + 0x168);
  *(_QWORD *)(a1 + 0x168) = &off_1482CE430;
  *(_DWORD *)(a1 + 0x188) = 0xFFFFFFFE;
  *(_QWORD *)(a1 + 0x190) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x198) = off_1482DB0F0;      // "verbosity_remote"
  *(_QWORD *)(a1 + 0x1A0) = 0;
  *(_QWORD *)(a1 + 0x1A8) = a1;
  v12 = *(_QWORD *)(a1 + 0x20);
  if ( v12 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v12 + 0x60LL))(v12, a1, a1 + 0x190);
  *(_QWORD *)(a1 + 0x190) = &off_1482CE430;
  *(_DWORD *)(a1 + 0x1B0) = 4;
  *(_QWORD *)(a1 + 0x1B8) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x1C0) = off_1482DB2B0;      // "filter_mode"
  *(_QWORD *)(a1 + 0x1C8) = 0;
  *(_QWORD *)(a1 + 0x1D0) = a1;
  v13 = *(_QWORD *)(a1 + 0x20);
  if ( v13 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v13 + 0x60LL))(v13, a1, a1 + 0x1B8);
  *(_QWORD *)(a1 + 0x1B8) = &off_1482CE430;
  *(_DWORD *)(a1 + 0x1D8) = 0;
  *(_QWORD *)(a1 + 0x1E0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x1E8) = off_1482DB3B0;      // "filter"
  *(_QWORD *)(a1 + 0x1F0) = 0;
  *(_QWORD *)(a1 + 0x1F8) = a1;
  v14 = *(_QWORD *)(a1 + 0x20);
  if ( v14 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v14 + 0x60LL))(v14, a1, a1 + 0x1E0);
  *(_QWORD *)(a1 + 0x1E0) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x200) = &p_Src;
  *(_QWORD *)(a1 + 0x208) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x210) = off_1482DB580;      // "filter_module"
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = a1;
  v15 = *(_QWORD *)(a1 + 0x20);
  if ( v15 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v15 + 0x60LL))(v15, a1, a1 + 0x208);
  *(_QWORD *)(a1 + 0x208) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x228) = &p_Src;
  *(_QWORD *)(a1 + 0x230) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x238) = off_1482DB660;      // "write_to_file"
  *(_QWORD *)(a1 + 0x240) = 0;
  *(_QWORD *)(a1 + 0x248) = a1;
  v16 = *(_QWORD *)(a1 + 0x20);
  if ( v16 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v16 + 0x60LL))(v16, a1, a1 + 0x230);
  *(_DWORD *)(a1 + 0x250) = 1;
  *(_QWORD *)(a1 + 0x230) = &off_1482B51A8;
  *(_QWORD *)(a1 + 0x258) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x260) = off_1482DB730;      // "spam_delay"
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = a1;
  v17 = *(_QWORD *)(a1 + 0x20);
  if ( v17 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v17 + 0x60LL))(v17, a1, a1 + 0x258);
  *(_DWORD *)(a1 + 0x278) = 0;
  *(_QWORD *)(a1 + 0x258) = &off_1482DA510;
  *(_QWORD *)(a1 + 0x280) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x288) = off_1482DB840;      // "prepend_module"
  *(_QWORD *)(a1 + 0x290) = 0;
  *(_QWORD *)(a1 + 0x298) = a1;
  v18 = *(_QWORD *)(a1 + 0x20);
  if ( v18 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v18 + 0x60LL))(v18, a1, a1 + 0x280);
  *(_QWORD *)(a1 + 0x280) = &off_1482B51A8;
  *(_DWORD *)(a1 + 0x2A0) = 1;
  *(_QWORD *)(a1 + 0x2A8) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x2B0) = off_1482DB910;      // "tick"
  *(_QWORD *)(a1 + 0x2B8) = 0;
  *(_QWORD *)(a1 + 0x2C0) = a1;
  v19 = *(_QWORD *)(a1 + 0x20);
  if ( v19 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v19 + 0x60LL))(v19, a1, a1 + 0x2A8);
  *(_QWORD *)(a1 + 0x2A8) = &off_1482CE430;
  *(_DWORD *)(a1 + 0x2C8) = 0;
  *(_QWORD *)(a1 + 0x2D0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x2D8) = off_1482DBA20;      // "write_to_stdout"
  *(_QWORD *)(a1 + 0x2E0) = 0;
  *(_QWORD *)(a1 + 0x2E8) = a1;
  v20 = *(_QWORD *)(a1 + 0x20);
  if ( v20 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v20 + 0x60LL))(v20, a1, a1 + 0x2D0);
  result = a1;
  *(_DWORD *)(a1 + 0x2F0) = 0;
  *(_QWORD *)(a1 + 0x2D0) = &off_1482CE430;
  return result;
}

// --- End Function: sub_14045BE00 (0x14045BE00) ---

// --- Function: sub_14045C8E0 (0x14045C8E0) ---
__int64 __fastcall sub_14045C8E0(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 result; // rax

  *(_QWORD *)(a1 + 0x20) = a2;
  *(_QWORD *)(a1 + 8) = "system";
  *(_QWORD *)(a1 + 0x40) = a1;
  *(_QWORD *)(a1 + 0x10) = "startup";
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x18) = "General Engine startup settings";
  *(_QWORD *)a1 = &off_1482DA538;
  *(_QWORD *)(a1 + 0x30) = off_1482D9950;       // "no_prompt"
  *(_QWORD *)(a1 + 0x28) = &off_1482B5178;
  v3 = *(_QWORD *)(a1 + 0x20);
  if ( v3 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v3 + 0x60LL))(v3, a1, a1 + 0x28);
  *(_DWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x28) = &off_1482B51A8;
  *(_QWORD *)(a1 + 0x50) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x58) = off_1482D9A40;       // "no_random"
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = a1;
  v4 = *(_QWORD *)(a1 + 0x20);
  if ( v4 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 0x60LL))(v4, a1, a1 + 0x50);
  *(_QWORD *)(a1 + 0x50) = &off_1482B51A8;
  *(_DWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x80) = off_1482D9B20;       // "dev_team"
  *(_QWORD *)(a1 + 0x78) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = a1;
  v5 = *(_QWORD *)(a1 + 0x20);
  if ( v5 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 0x60LL))(v5, a1, a1 + 0x78);
  *(_QWORD *)(a1 + 0x98) = "QA";
  *(_QWORD *)(a1 + 0x78) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0xA8) = off_1482D9C70;       // "service_name"
  *(_QWORD *)(a1 + 0xA0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = a1;
  v6 = *(_QWORD *)(a1 + 0x20);
  if ( v6 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 0x60LL))(v6, a1, a1 + 0xA0);
  *(_QWORD *)(a1 + 0xA0) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0xC0) = &p_Src;
  *(_QWORD *)(a1 + 0xC8) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xD0) = off_1482B5230;       // "product_name"
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = a1;
  v7 = *(_QWORD *)(a1 + 0x20);
  if ( v7 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v7 + 0x60LL))(v7, a1, a1 + 0xC8);
  *(_QWORD *)(a1 + 0xC8) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0xE8) = "star-engine";
  *(_QWORD *)(a1 + 0xF0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0xF8) = off_1482D9D50;       // "env_tag"
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = a1;
  v8 = *(_QWORD *)(a1 + 0x20);
  if ( v8 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v8 + 0x60LL))(v8, a1, a1 + 0xF0);
  *(_QWORD *)(a1 + 0xF0) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x110) = "DEV";
  *(_QWORD *)(a1 + 0x118) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x120) = off_1482D9E70;      // "env_var_tag"
  *(_QWORD *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x130) = a1;
  v9 = *(_QWORD *)(a1 + 0x20);
  if ( v9 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v9 + 0x60LL))(v9, a1, a1 + 0x118);
  *(_QWORD *)(a1 + 0x118) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x138) = &p_Src;
  *(_QWORD *)(a1 + 0x140) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x148) = off_1482D9F60;      // "dump_folder"
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = a1;
  v10 = *(_QWORD *)(a1 + 0x20);
  if ( v10 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v10 + 0x60LL))(v10, a1, a1 + 0x140);
  *(_QWORD *)(a1 + 0x140) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x160) = &p_Src;
  *(_QWORD *)(a1 + 0x168) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x170) = off_1482DA050;      // "unit_folder"
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = a1;
  v11 = *(_QWORD *)(a1 + 0x20);
  if ( v11 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v11 + 0x60LL))(v11, a1, a1 + 0x168);
  *(_QWORD *)(a1 + 0x168) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x188) = &p_Src;
  *(_QWORD *)(a1 + 0x190) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x198) = off_1482DA150;      // "multi_instances"
  *(_QWORD *)(a1 + 0x1A0) = 0;
  *(_QWORD *)(a1 + 0x1A8) = a1;
  v12 = *(_QWORD *)(a1 + 0x20);
  if ( v12 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v12 + 0x60LL))(v12, a1, a1 + 0x190);
  *(_QWORD *)(a1 + 0x190) = &off_1482B51A8;
  *(_DWORD *)(a1 + 0x1B0) = 0;
  *(_QWORD *)(a1 + 0x1B8) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x1C0) = off_1482DA240;      // "build_version"
  *(_QWORD *)(a1 + 0x1C8) = 0;
  *(_QWORD *)(a1 + 0x1D0) = a1;
  v13 = *(_QWORD *)(a1 + 0x20);
  if ( v13 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v13 + 0x60LL))(v13, a1, a1 + 0x1B8);
  *(_QWORD *)(a1 + 0x1B8) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x1D8) = &p_Src;
  *(_QWORD *)(a1 + 0x1E0) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x1E8) = off_1482DA370;      // "product_config_path"
  *(_QWORD *)(a1 + 0x1F0) = 0;
  *(_QWORD *)(a1 + 0x1F8) = a1;
  v14 = *(_QWORD *)(a1 + 0x20);
  if ( v14 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v14 + 0x60LL))(v14, a1, a1 + 0x1E0);
  *(_QWORD *)(a1 + 0x1E0) = off_1482D9BE8;
  *(_QWORD *)(a1 + 0x200) = "star-services";
  *(_QWORD *)(a1 + 0x208) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x210) = off_1482DA480;      // "streaming_min_pixel"
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = a1;
  v15 = *(_QWORD *)(a1 + 0x20);
  if ( v15 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v15 + 0x60LL))(v15, a1, a1 + 0x208);
  *(_QWORD *)(a1 + 0x208) = &off_1482DA510;
  result = a1;
  *(_DWORD *)(a1 + 0x228) = 0x45A00000;
  return result;
}

// --- End Function: sub_14045C8E0 (0x14045C8E0) ---

// --- Function: sub_1404659E0 (0x1404659E0) ---
_QWORD *__fastcall sub_1404659E0(_QWORD *a1)
{
  a1[1] = "unknown";
  *a1 = off_1482D54C0;
  return a1;
}

// --- End Function: sub_1404659E0 (0x1404659E0) ---

// --- Function: sub_140465FA0 (0x140465FA0) ---
__int64 __fastcall sub_140465FA0(__int64 a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // rax
  const void *v3; // rcx

  result = a1 + 0x18;
  if ( *(_QWORD *)(a1 + 0x10) != a1 + 0x18 )
  {
    v2 = 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
    v3 = *(const void **)(a1 + 0x10);
    qword_149C850A8 += v2;
    return sub_147715880(v3);
  }
  return result;
}

// --- End Function: sub_140465FA0 (0x140465FA0) ---

// --- Function: sub_140466E20 (0x140466E20) ---
__int64 __fastcall sub_140466E20(unsigned __int64 *a1)
{
  unsigned __int64 v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    sub_1403A6820((__int64)a1, v2, 0x18 * ((__int64)(a1[2] - v2) / 0x18));
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140466E20 (0x140466E20) ---

// --- Function: sub_1404684E0 (0x1404684E0) ---
_UNKNOWN **__fastcall sub_1404684E0(__int64 a1)
{
  bool v1; // zf
  __int64 v3; // rcx
  __int64 v4; // rdx
  _BYTE *v5; // rdx
  __int64 v6; // rcx
  _UNKNOWN **result; // rax
  __m256 v8; // [rsp+20h] [rbp-68h]
  __int128 v9; // [rsp+20h] [rbp-68h]
  _BYTE v10[56]; // [rsp+40h] [rbp-48h] BYREF
  _BYTE *v11; // [rsp+78h] [rbp-10h]

  v1 = *(_DWORD *)(a1 + 0xC) == 0;
  *(_QWORD *)a1 = &off_1482EB650;
  if ( !v1 )
  {
    v3 = *(_QWORD *)(a1 + 0x158);
    if ( v3 )
    {
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0x88LL))(v3, *(unsigned int *)(a1 + 0xC));
      (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 0x158) + 0x90LL))(
        *(_QWORD *)(a1 + 0x158),
        *(unsigned int *)(a1 + 0xC));
    }
  }
  v11 = 0;
  sub_1402B6E50(a1 + 0x1C8, v10);
  if ( v11 )
  {
    v5 = v10;
    LOBYTE(v5) = v11 != v10;
    (*(void (__fastcall **)(_BYTE *, _BYTE *))(*(_QWORD *)v11 + 0x20LL))(v11, v5);
  }
  *(_QWORD *)&v8.m256_f32[4] = 0;
  *(_QWORD *)v8.m256_f32 = 0;
  *(__m256 *)(a1 + 0x130) = v8;
  *(_DWORD *)(a1 + 0x168) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x16C) = 0;
  *(_QWORD *)(a1 + 0x1C0) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x180) = 0;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x198) = 0;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)&v9 = 0;
  *((_QWORD *)&v9 + 1) = 0x7FFFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 0x1A0) = v9;
  *(double *)(a1 + 0x1B0) = 0;
  *(_QWORD *)(a1 + 8) = 2;
  v6 = *(_QWORD *)(a1 + 0x200);
  if ( v6 )
  {
    LOBYTE(v4) = v6 != a1 + 0x1C8;
    __asm { vzeroupper }
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x20LL))(v6, v4);
    *(_QWORD *)(a1 + 0x200) = 0;
  }
  __asm { vzeroupper }
  sub_140375A30((_DWORD *)(a1 + 0x28));
  sub_14034B470(a1 + 0x18, a1 + 0x18, *(_QWORD *)(*(_QWORD *)(a1 + 0x18) + 8LL));
  sub_1402A6590(*(_QWORD *)(a1 + 0x18));
  result = &off_1482EB640;
  *(_QWORD *)a1 = &off_1482EB640;
  return result;
}

// --- End Function: sub_1404684E0 (0x1404684E0) ---

// --- Function: sub_140468B50 (0x140468B50) ---
__int64 __fastcall sub_140468B50(__int64 a1)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 0xB0);
  if ( v2 )
    sub_140527EC0(v2, 0);
  return sub_140468A30(a1 + 0x40);
}

// --- End Function: sub_140468B50 (0x140468B50) ---

// --- Function: sub_14046C930 (0x14046C930) ---
__int64 __fastcall sub_14046C930(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  *(_OWORD *)(a1 + 0x20) = *(_OWORD *)(a2 + 0x20);
  *(double *)(a1 + 0x30) = *(double *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = *(_QWORD *)(a2 + 0x38);
  *(_QWORD *)(a1 + 0x40) = *(_QWORD *)(a2 + 0x40);
  return a1;
}

// --- End Function: sub_14046C930 (0x14046C930) ---

// --- Function: sub_14046F550 (0x14046F550) ---
__int64 __fastcall sub_14046F550(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 0x10) + 0x170 * a2;
}

// --- End Function: sub_14046F550 (0x14046F550) ---

// --- Function: sub_14048D530 (0x14048D530) ---
char __fastcall sub_14048D530(_QWORD *a1, _BYTE *a2)
{
  __int64 v2; // rax
  __int64 v5; // rax
  __int64 n6; // rax
  char v7; // cl
  __int64 v8; // rax
  __int64 v9; // rbp
  int v10; // ebx
  char *v11; // rax
  _QWORD v13[3]; // [rsp+20h] [rbp-18h] BYREF
  char v14; // [rsp+48h] [rbp+10h] BYREF

  v2 = qword_149C84E98;
  if ( !qword_149C84E98 )
  {
    v5 = *(_QWORD *)qword_149C8E0F8;
    v13[0] = &v14;
    v13[1] = sub_140422D90;
    v2 = (*(__int64 (__fastcall **)(__int64, __int64 *, const char *, _QWORD *))(v5 + 0x48))(
           qword_149C8E0F8,
           &qword_149C84E98,
           "SAnalyticsConfig",
           v13);
    v13[0] = 0xFFFFFFFFFFFFFFFFuLL;
  }
  if ( *(_DWORD *)(v2 + 0x48) )
  {
LABEL_9:
    if ( a2 )
      goto LABEL_10;
    return 0;
  }
  if ( !a2 )
    return 0;
  n6 = 0;
  while ( 1 )
  {
    v7 = a2[n6++];
    if ( v7 != aTmid[n6 - 1] )
      break;
    if ( n6 == 6 )
    {
      a2 += 5;
      goto LABEL_9;
    }
  }
LABEL_10:
  if ( !*a2 )
    return 0;
  v8 = sub_1403EBE30(a1);
  if ( v8 )
  {
    v9 = v8 - 1;
    if ( *(_BYTE *)std::unique_ptr<char [0]>::operator[](a1, v8 - 1) != 0x7D )
    {
      v10 = *(char *)std::unique_ptr<char [0]>::operator[](a1, v9);
      v11 = (char *)std::unique_ptr<char [0]>::operator[](a1, v9);
      LogFatalError("Expected '}' but found '%c' (%d)", (unsigned int)*v11, v10);
    }
    *(_BYTE *)std::unique_ptr<char [0]>::operator[](a1, v9) = 0x2C;
  }
  else
  {
    assignCStringToStringStructure((__int64)a1, (__int64)"{");
  }
  sub_140387CB0((__int64)a1, (__int64)"\"");
  sub_140387CB0((__int64)a1, (__int64)a2);
  sub_140387CB0((__int64)a1, (__int64)"\":");
  return 1;
}

// --- End Function: sub_14048D530 (0x14048D530) ---

// --- Function: sub_140492440 (0x140492440) ---
__int64 __fastcall sub_140492440(__int64 a1, _QWORD *a2)
{
  __int64 v4; // rsi
  size_t Size; // rbx
  char *v7[2]; // [rsp+20h] [rbp-C8h] BYREF
  _BYTE v8[8]; // [rsp+30h] [rbp-B8h] BYREF
  __int64 v9; // [rsp+38h] [rbp-B0h]
  char *v10; // [rsp+40h] [rbp-A8h]
  char v11; // [rsp+48h] [rbp-A0h] BYREF

  sub_140387C80(a1, 0x22);
  v4 = sub_1404C5990(a1, v8, *a2);
  sub_1403E4E90(v7);
  Size = *(_QWORD *)v4;
  if ( *(_QWORD *)v4 )
  {
    sub_1403E2480(v7, *(_QWORD *)v4);
    sub_1403E6390(v7[0], *(const void **)(v4 + 0x10), Size);
  }
  sub_140387C60(a1, v7);
  sub_140373CC0(v7);
  if ( v10 != &v11 )
  {
    qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - v9;
    sub_147715880(v10);
  }
  return sub_140387C80(a1, 0x22);
}

// --- End Function: sub_140492440 (0x140492440) ---

// --- Function: sub_1404928B0 (0x1404928B0) ---
_BYTE *__fastcall sub_1404928B0(__int64 a1, int a2)
{
  __int64 v3; // rax
  _BYTE *result; // rax
  __int64 v5; // [rsp+20h] [rbp-48h] BYREF
  __int64 n0x14; // [rsp+28h] [rbp-40h]
  _BYTE *v7; // [rsp+30h] [rbp-38h]
  _BYTE v8[24]; // [rsp+38h] [rbp-30h] BYREF

  v8[0] = 0;
  v5 = 0;
  v7 = v8;
  n0x14 = 0x14;
  v3 = sub_1404B0820(&v5, "%i", a2);
  sub_140387CB0(a1, *(_QWORD *)(v3 + 0x10));
  result = v8;
  if ( v7 != v8 )
  {
    qword_149C850C0 += 0xFFFFFFFFFFFFFFFFuLL - n0x14;
    return (_BYTE *)sub_147715880(v7);
  }
  return result;
}

// --- End Function: sub_1404928B0 (0x1404928B0) ---

// --- Function: sub_140492950 (0x140492950) ---
_BYTE *__fastcall sub_140492950(__int64 a1, int a2)
{
  __int64 v3; // rax
  _BYTE *result; // rax
  __int64 v5; // [rsp+20h] [rbp-48h] BYREF
  __int64 n0x14; // [rsp+28h] [rbp-40h]
  _BYTE *v7; // [rsp+30h] [rbp-38h]
  _BYTE v8[24]; // [rsp+38h] [rbp-30h] BYREF

  v8[0] = 0;
  v5 = 0;
  v7 = v8;
  n0x14 = 0x14;
  v3 = sub_1404B0820(&v5, "%u", a2);
  sub_140387CB0(a1, *(_QWORD *)(v3 + 0x10));
  result = v8;
  if ( v7 != v8 )
  {
    qword_149C850C0 += 0xFFFFFFFFFFFFFFFFuLL - n0x14;
    return (_BYTE *)sub_147715880(v7);
  }
  return result;
}

// --- End Function: sub_140492950 (0x140492950) ---

// --- Function: sub_1404929F0 (0x1404929F0) ---
_BYTE *__fastcall sub_1404929F0(__int64 a1)
{
  float v2; // xmm0_4
  __int64 v3; // rax
  _BYTE *result; // rax
  __int64 v5; // [rsp+20h] [rbp-178h] BYREF
  __int64 n0x145; // [rsp+28h] [rbp-170h]
  _BYTE *v7; // [rsp+30h] [rbp-168h]
  _BYTE v8[328]; // [rsp+38h] [rbp-160h] BYREF

  v8[0] = 0;
  v7 = v8;
  v5 = 0;
  n0x145 = 0x145;
  v2 = sub_140430F00(a1).m128_f32[0];
  v3 = sub_1404B06D0(&v5, &word_1482C1570, v2);
  sub_140387CB0(a1, *(_QWORD *)(v3 + 0x10));
  result = v8;
  if ( v7 != v8 )
  {
    qword_149C850B8 += 0xFFFFFFFFFFFFFFFFuLL - n0x145;
    return (_BYTE *)sub_147715880(v7);
  }
  return result;
}

// --- End Function: sub_1404929F0 (0x1404929F0) ---

// --- Function: sub_140492B70 (0x140492B70) ---
__int64 __fastcall sub_140492B70(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  size_t Size; // rdi
  char *v7[2]; // [rsp+20h] [rbp-C8h] BYREF
  _BYTE v8[8]; // [rsp+30h] [rbp-B8h] BYREF
  __int64 v9; // [rsp+38h] [rbp-B0h]
  char *v10; // [rsp+40h] [rbp-A8h]
  char v11; // [rsp+48h] [rbp-A0h] BYREF

  sub_140387C80(a1, 0x22);
  if ( a2 )
  {
    v4 = sub_1404C5990(a1, v8, a2);
    sub_1403E4E90(v7);
    Size = *(_QWORD *)v4;
    if ( *(_QWORD *)v4 )
    {
      sub_1403E2480(v7, *(_QWORD *)v4);
      sub_1403E6390(v7[0], *(const void **)(v4 + 0x10), Size);
    }
    sub_140387C60(a1, v7);
    sub_140373CC0(v7);
    if ( v10 != &v11 )
    {
      qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - v9;
      sub_147715880(v10);
    }
  }
  return sub_140387C80(a1, 0x22);
}

// --- End Function: sub_140492B70 (0x140492B70) ---

// --- Function: sub_140492C70 (0x140492C70) ---
_BYTE *__fastcall sub_140492C70(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  _BYTE *result; // rax
  __int64 v5; // [rsp+20h] [rbp-48h] BYREF
  __int64 n0x14; // [rsp+28h] [rbp-40h]
  _BYTE *v7; // [rsp+30h] [rbp-38h]
  _BYTE v8[24]; // [rsp+38h] [rbp-30h] BYREF

  v8[0] = 0;
  v5 = 0;
  v7 = v8;
  n0x14 = 0x14;
  v3 = sub_1404B0820(&v5, "%lli", a2);
  sub_140387CB0(a1, *(_QWORD *)(v3 + 0x10));
  result = v8;
  if ( v7 != v8 )
  {
    qword_149C850C0 += 0xFFFFFFFFFFFFFFFFuLL - n0x14;
    return (_BYTE *)sub_147715880(v7);
  }
  return result;
}

// --- End Function: sub_140492C70 (0x140492C70) ---

// --- Function: sub_14049CE70 (0x14049CE70) ---
__int64 __fastcall sub_14049CE70(__int64 a1, __int64 a2)
{
  return sub_1403C21C0(a2, *(_DWORD *)(*(_QWORD *)(a1 + 0x10) + 4LL), *(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_14049CE70 (0x14049CE70) ---

// --- Function: sub_14049D9C0 (0x14049D9C0) ---
void __fastcall sub_14049D9C0(
        int a1,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64, __int64); // rdi
  __int64 (__fastcall *v6)(__int64, __int64); // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v6 = (__int64 (__fastcall *)(__int64, __int64))sub_1402A65A0(8u);
        if ( v6 )
          *(_QWORD *)v6 = *(_QWORD *)v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_14049CE70;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))sub_14049D9C0;
      }
    }
  }
}

// --- End Function: sub_14049D9C0 (0x14049D9C0) ---

// --- Function: sub_14049FB00 (0x14049FB00) ---
const ULONG_PTR *__fastcall sub_14049FB00(__int64 a1, int a2)
{
  const ULONG_PTR *p_p_Src; // rax
  volatile signed __int32 *v4; // rbx
  int v5; // esi
  unsigned int v6; // eax
  int v7; // eax
  unsigned __int32 v8; // eax
  int v9; // [rsp+38h] [rbp+10h] BYREF

  v9 = a2;
  if ( *(_QWORD *)(a1 + 0x2B0) == *(_QWORD *)(a1 + 0x2B8)
    || (p_p_Src = (const ULONG_PTR *)sub_140505970(a1 + 0x250), !(_BYTE)p_p_Src) )
  {
    v4 = (volatile signed __int32 *)(a1 + 0x300);
    v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x310) == v5 )
    {
      ++*(_DWORD *)(a1 + 0x314);
    }
    else
    {
      v6 = _InterlockedCompareExchange(v4, 1, 0);
      if ( v6 )
        sub_1403C6E80(
          a1 + 0x300,
          v6,
          (__int64)"DeferredActionQueue<struct DefaultRayCaster<47>,struct RayCastRequest,struct RayCastResult,struct Def"
                   "aultContention>::Cancel",
          1);
      else
        *(_QWORD *)(a1 + 0x308) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x310) = v5;
    }
    sub_140505790(a1 + 0x228, &v9);
    v7 = *(_DWORD *)(a1 + 0x314);
    if ( v7 )
    {
      p_p_Src = (const ULONG_PTR *)(unsigned int)(v7 - 1);
      *(_DWORD *)(a1 + 0x314) = (_DWORD)p_p_Src;
    }
    else
    {
      *(_DWORD *)(a1 + 0x310) = 0xFFFFFFFF;
      v8 = _InterlockedCompareExchange(v4, 0, 1);
      if ( v8 == 1 )
      {
        p_p_Src = &p_Src;
        *(_QWORD *)(a1 + 0x308) = &p_Src;
      }
      else
      {
        return sub_1403DF590(a1 + 0x300, v8);
      }
    }
  }
  return p_p_Src;
}

// --- End Function: sub_14049FB00 (0x14049FB00) ---

// --- Function: sub_1404AD680 (0x1404AD680) ---
unsigned __int64 __fastcall sub_1404AD680(__int64 a1, __int64 a2)
{
  int v4; // ebx
  unsigned int v5; // eax
  char *v6; // rsi
  __int64 v7; // r14
  __int64 v8; // r13
  _QWORD *v9; // rbp
  _QWORD *v10; // r15
  _QWORD *v11; // rbp
  _QWORD *i; // rbx
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rbp
  _QWORD *v17; // rbx
  void (__fastcall *n2_1)(__int64, _QWORD *); // rax
  _QWORD *j; // rbx
  void (__fastcall *n2_2)(__int64, _QWORD *); // rax
  int v21; // eax
  unsigned __int64 p_p_Src; // rax
  __int64 v23; // rbx
  _QWORD *v24; // rax
  unsigned __int64 n0x10; // rcx
  _QWORD *v26; // rdx
  int v27; // eax
  void (*v28)(void); // rax
  unsigned __int128 v29; // kr00_16
  int v30; // ebx
  unsigned int v31; // eax
  unsigned __int64 v32; // rsi
  unsigned __int64 v33; // rbp
  __int64 v34; // rbx
  int v35; // eax
  unsigned __int32 v36; // eax
  _QWORD *k; // rbx
  _QWORD *m; // rbx
  unsigned __int128 v39; // [rsp+20h] [rbp-78h] BYREF
  __int64 v40; // [rsp+30h] [rbp-68h]
  char v41; // [rsp+38h] [rbp-60h] BYREF
  char v42; // [rsp+50h] [rbp-48h] BYREF

  v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v4 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v5 )
      sub_1403C6E80(a1, v5, (__int64)"CDeferredCallbackQueue<>::ExecuteCallbacks", 1);
    else
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x10) = v4;
  }
  v6 = (char *)(a1 + 0x18);
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( &v41 != (char *)(a1 + 0x18) )
  {
    v8 = *(_QWORD *)v6;
    *(_QWORD *)v6 = 0;
    v10 = *(_QWORD **)(a1 + 0x20);
    *(_QWORD *)(a1 + 0x20) = 0;
    *(_QWORD *)(a1 + 0x28) = 0;
  }
  if ( v6 != &v42 )
  {
    v11 = *(_QWORD **)(a1 + 0x20);
    for ( i = *(_QWORD **)v6; i != v11; i += 0x1A )
    {
      n2 = (void (__fastcall *)(__int64, _QWORD *))i[1];
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, i);
        i[1] = 0;
      }
      *i = 0;
    }
    v14 = *(_QWORD *)v6;
    *(_QWORD *)v6 = 0;
    v15 = *(_QWORD *)(a1 + 0x28);
    *(_QWORD *)(a1 + 0x28) = 0;
    v16 = *(_QWORD *)v6;
    *(_QWORD *)v6 = v14;
    *(_QWORD *)(a1 + 0x20) = v14;
    *(_QWORD *)(a1 + 0x28) = v15;
    if ( v16 )
    {
      v17 = (_QWORD *)v16;
      do
      {
        n2_1 = (void (__fastcall *)(__int64, _QWORD *))v17[1];
        if ( (unsigned __int64)n2_1 >= 2 )
        {
          n2_1(2, v17);
          v17[1] = 0;
        }
        *v17 = 0;
        v17 += 0x1A;
      }
      while ( v17 );
      sub_1402A6590(v16);
    }
    v7 = *(_QWORD *)v6;
    *(_QWORD *)v6 = 0;
    v9 = *(_QWORD **)(a1 + 0x20);
    *(_QWORD *)(a1 + 0x20) = 0;
    *(_QWORD *)(a1 + 0x28) = 0;
  }
  for ( j = (_QWORD *)v7; j != v9; j += 0x1A )
  {
    n2_2 = (void (__fastcall *)(__int64, _QWORD *))j[1];
    if ( (unsigned __int64)n2_2 >= 2 )
    {
      n2_2(2, j);
      j[1] = 0;
    }
    *j = 0;
  }
  if ( v7 )
    sub_1402A6590(v7);
  v21 = *(_DWORD *)(a1 + 0x14);
  if ( v21 )
  {
    p_p_Src = (unsigned int)(v21 - 1);
    *(_DWORD *)(a1 + 0x14) = p_p_Src;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    p_p_Src = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
    if ( (_DWORD)p_p_Src == 1 )
      *(_QWORD *)(a1 + 8) = &p_Src;
    else
      p_p_Src = (unsigned __int64)sub_1403DF590(a1, (unsigned int)p_p_Src);
  }
  v23 = v8;
  v40 = 0;
  v39 = 0;
  if ( (_QWORD *)v8 == v10 )
  {
LABEL_59:
    v29 = v39;
    goto LABEL_60;
  }
  do
  {
    v24 = sub_1404B8EB0();
    n0x10 = *v24 + 1LL;
    *v24 = n0x10;
    if ( n0x10 < 0x10 )
    {
      v26 = &v24[0x16 * n0x10];
      *(_OWORD *)(v26 + 1) = *(_OWORD *)(v23 + 0x18);
      *(_OWORD *)(v26 + 3) = *(_OWORD *)(v23 + 0x28);
      *(_OWORD *)(v26 + 5) = *(_OWORD *)(v23 + 0x38);
      *(_OWORD *)(v26 + 7) = *(_OWORD *)(v23 + 0x48);
      *(_OWORD *)(v26 + 9) = *(_OWORD *)(v23 + 0x58);
      *(_OWORD *)(v26 + 0xB) = *(_OWORD *)(v23 + 0x68);
      *(_OWORD *)(v26 + 0xD) = *(_OWORD *)(v23 + 0x78);
      *(_OWORD *)(v26 + 0xF) = *(_OWORD *)(v23 + 0x88);
      *(_OWORD *)(v26 + 0x11) = *(_OWORD *)(v23 + 0x98);
      *(_OWORD *)(v26 + 0x13) = *(_OWORD *)(v23 + 0xA8);
      *(_OWORD *)(v26 + 0x15) = *(_OWORD *)(v23 + 0xB8);
    }
    if ( *(_QWORD *)a2 && (v27 = (*(__int64 (**)(void))(a2 + 8))()) != 0 )
    {
      if ( v27 == 1 )
        sub_140451090((__int64 *)&v39, v23);
    }
    else
    {
      v28 = *(void (**)(void))v23;
      if ( *(_QWORD *)(v23 + 8) == 1 )
        v28();
      else
        ((void (__fastcall *)(__int64))v28)(v23);
    }
    p_p_Src = (unsigned __int64)sub_1404B8EB0();
    if ( *(_QWORD *)p_p_Src )
      --*(_QWORD *)p_p_Src;
    v23 += 0xD0;
  }
  while ( (_QWORD *)v23 != v10 );
  v29 = v39;
  if ( (_QWORD)v39 != *((_QWORD *)&v39 + 1) )
  {
    v30 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x10) == v30 )
    {
      ++*(_DWORD *)(a1 + 0x14);
    }
    else
    {
      v31 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
      if ( v31 )
        sub_1403C6E80(a1, v31, (__int64)"CDeferredCallbackQueue<>::ExecuteCallbacks", 1);
      else
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v32 = *((_QWORD *)&v39 + 1);
      v33 = v39;
      *(_DWORD *)(a1 + 0x10) = v30;
      v29 = __PAIR128__(v32, v33);
    }
    v34 = v29;
    do
    {
      sub_140451090((__int64 *)(a1 + 0x18), v34);
      v34 += 0xD0;
    }
    while ( v34 != *((_QWORD *)&v29 + 1) );
    v35 = *(_DWORD *)(a1 + 0x14);
    if ( v35 )
    {
      p_p_Src = (unsigned int)(v35 - 1);
      *(_DWORD *)(a1 + 0x14) = p_p_Src;
      goto LABEL_60;
    }
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    v36 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
    if ( v36 == 1 )
    {
      p_p_Src = (unsigned __int64)&p_Src;
      *(_QWORD *)(a1 + 8) = &p_Src;
    }
    else
    {
      p_p_Src = (unsigned __int64)sub_1403DF590(a1, v36);
    }
    goto LABEL_59;
  }
LABEL_60:
  for ( k = (_QWORD *)v29; k != *((_QWORD **)&v29 + 1); k += 0x1A )
  {
    p_p_Src = k[1];
    if ( p_p_Src >= 2 )
    {
      p_p_Src = ((__int64 (__fastcall *)(__int64, _QWORD *))p_p_Src)(2, k);
      k[1] = 0;
    }
    *k = 0;
  }
  if ( (_QWORD)v29 )
    p_p_Src = sub_1402A6590(v29);
  for ( m = (_QWORD *)v8; m != v10; m += 0x1A )
  {
    p_p_Src = m[1];
    if ( p_p_Src >= 2 )
    {
      p_p_Src = ((__int64 (__fastcall *)(__int64, _QWORD *))p_p_Src)(2, m);
      m[1] = 0;
    }
    *m = 0;
  }
  if ( v8 )
    return sub_1402A6590(v8);
  return p_p_Src;
}

// --- End Function: sub_1404AD680 (0x1404AD680) ---

// --- Function: sub_1404B0820 (0x1404B0820) ---
__int64 sub_1404B0820(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n0x14_1; // rbx
  size_t n0x14_2; // rax
  const void *v7; // rcx
  _BYTE *v8; // rsi
  __int64 n0x14; // rax
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 result; // rax
  char Buffer[4096]; // [rsp+40h] [rbp-1038h] BYREF
  va_list va; // [rsp+1090h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n0x14_1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0x14_1;
  while ( Buffer[n0x14_1] );
  n0x14_2 = *(_QWORD *)(a1 + 8);
  if ( n0x14_1 > n0x14_2 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149C850C0 += 0xFFFFFFFFFFFFFFFFuLL - n0x14_2;
      sub_147715880(v7);
    }
    *v8 = 0;
    n0x14 = 0x14;
    *(_QWORD *)(a1 + 8) = 0x14;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    if ( n0x14_1 )
    {
      if ( n0x14_1 + 1 > 0x15 )
      {
        v10 = allocWithProfilerInfo(n0x14_1 + 1, 0);
        qword_149C850C0 += n0x14_1 + 1;
        v8 = (_BYTE *)v10;
        n0x14 = n0x14_1;
      }
      *(_QWORD *)(a1 + 8) = n0x14;
      *(_QWORD *)(a1 + 0x10) = v8;
      v8[n0x14_1] = 0;
    }
  }
  memmove(*(void **)(a1 + 0x10), Buffer, n0x14_1);
  v11 = *(_QWORD *)(a1 + 0x10);
  result = a1;
  *(_QWORD *)a1 = n0x14_1;
  *(_BYTE *)(n0x14_1 + v11) = 0;
  return result;
}

// --- End Function: sub_1404B0820 (0x1404B0820) ---

// --- Function: sub_1404B0960 (0x1404B0960) ---
__int64 sub_1404B0960(__int64 a1, const char *Format_1, ...)
{
  size_t MaxCount; // rdi
  unsigned __int64 *v5; // rax
  int v6; // eax
  __int64 v8; // rcx
  __int64 v9; // rax
  va_list va; // [rsp+80h] [rbp+18h] BYREF

  va_start(va, Format_1);
  MaxCount = *(_QWORD *)(a1 + 8);
  v5 = (unsigned __int64 *)sub_1402A6BE0();
  v6 = _stdio_common_vsnprintf_s(*v5, *(char **)(a1 + 0x10), MaxCount + 1, MaxCount, Format_1, 0, va);
  if ( v6 < 0 )
    v6 = 0xFFFFFFFF;
  if ( v6 < 0 )
  {
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(_QWORD *)(a1 + 0x10);
    *(_QWORD *)a1 = v8;
    *(_BYTE *)(v8 + v9) = 0;
  }
  else
  {
    *(_QWORD *)a1 = v6;
  }
  return a1;
}

// --- End Function: sub_1404B0960 (0x1404B0960) ---

// --- Function: sub_1404B4DD0 (0x1404B4DD0) ---
unsigned __int64 __fastcall sub_1404B4DD0(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rdx
  bool v4; // cf
  bool v5; // zf

  v2 = (unsigned __int64)(a1[2] + 7LL) >> 3;
  v3 = a2 + 8 * v2;
  v4 = v3 < a1[1];
  v5 = v3 == a1[1];
  a1[2] = v3;
  return (v2 + *a1) * (v4 | (unsigned __int8)v5);
}

// --- End Function: sub_1404B4DD0 (0x1404B4DD0) ---

// --- Function: sub_1404B5460 (0x1404B5460) ---
double __fastcall sub_1404B5460(__int64 a1, double *a2)
{
  __int128 v2; // xmm6
  __int64 v3; // rbx
  __int64 (__fastcall *v5)(__int64, char *, __int64 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v7; // rdi
  __int64 v8; // rax
  __int16 n4_1; // dx
  __int64 v10; // r8
  double *v11; // rax
  double v12; // xmm3_8
  double v13; // xmm4_8
  __int128 v14; // kr00_16
  __int64 (__fastcall *v21)(__int64, char *, __int64 *); // rdi
  __int16 n0xFFFF_1; // ax
  __int64 v23; // rbx
  __int64 v24; // rax
  __int16 n4; // dx
  _BYTE v27[32]; // [rsp+20h] [rbp-58h] BYREF
  __int128 v28; // [rsp+40h] [rbp-38h]
  __int64 v29; // [rsp+80h] [rbp+8h] BYREF
  char v30; // [rsp+90h] [rbp+18h] BYREF
  char v31; // [rsp+98h] [rbp+20h] BYREF

  v28 = v2;
  v3 = a1 & 0xFFFFFFFFFFFFLL;
  v5 = *(__int64 (__fastcall **)(__int64, char *, __int64 *))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF = n0xFFFF_15;
  if ( n0xFFFF_15 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                          qword_149C8DFC8,
                          &v30,
                          "IProceduralEntity");
    n0xFFFF_15 = n0xFFFF;
  }
  LOWORD(v29) = n0xFFFF;
  v7 = *(_QWORD *)v5(v3, &v31, &v29);
  v29 = v7;
  if ( v7
    && (v8 = sub_1403B84E0(v7 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v8 + 4), n4_1 != 4)
    && *(_WORD *)(v8 + 2) == (HIWORD(v7) & 0xFFF)
    && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v29)) )
  {
    LOBYTE(v10) = 1;
    v11 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v3 + 0x2C8LL))(v3, v27, v10);
    v12 = a2[1] - v11[1];
    v13 = a2[2] - v11[2];
    *((_QWORD *)&v14 + 1) = 0;
    *(double *)&v14 = (*a2 - *v11) * (*a2 - *v11) + v12 * v12 + v13 * v13;
    _XMM2 = v14;
    __asm
    {
      vmovddup xmm1, xmm2
      vsqrtpd xmm6, xmm1
    }
    __asm { vunpckhpd xmm6, xmm6, xmm6 }
    *((_QWORD *)&v14 + 1) = *((_QWORD *)&_XMM6 + 1);
    *(double *)&v14 = *(double *)&_XMM6
                    - *(float *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v7 & 0xFFFFFFFFFFFFLL) + 0x5B8LL))(v7 & 0xFFFFFFFFFFFFLL)
                               + 0x78);
    _XMM1 = v14;
    __asm { vmaxsd  xmm0, xmm1, xmm0 }
  }
  else
  {
    v21 = *(__int64 (__fastcall **)(__int64, char *, __int64 *))(*(_QWORD *)v3 + 0x340LL);
    n0xFFFF_1 = n0xFFFF_16;
    if ( n0xFFFF_16 == (__int16)0xFFFF )
    {
      n0xFFFF_1 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                     + 0x10LL))(
                              qword_149C8DFC8,
                              &v30,
                              "IAsteroidFieldComponent");
      n0xFFFF_16 = n0xFFFF_1;
    }
    LOWORD(v29) = n0xFFFF_1;
    v23 = *(_QWORD *)v21(v3, &v31, &v29);
    v29 = v23;
    if ( v23
      && (v24 = sub_1403B84E0(v23 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v24 + 4), n4 != 4)
      && *(_WORD *)(v24 + 2) == (HIWORD(v23) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v29)) )
    {
      (*(void (__fastcall **)(__int64, double *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x580LL))(
        v23 & 0xFFFFFFFFFFFFLL,
        a2);
    }
    else
    {
      *(_QWORD *)&_XMM0 = 0x426D1A94A1FFE000LL;
    }
  }
  return *(double *)&_XMM0;
}

// --- End Function: sub_1404B5460 (0x1404B5460) ---

// --- Function: sub_1404B8EB0 (0x1404B8EB0) ---
_QWORD *sub_1404B8EB0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( !v0 )
  {
    sub_14053EF00("fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A65A0(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1481CF6E0);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B8EB0 (0x1404B8EB0) ---

// --- Function: sub_1404B90A0 (0x1404B90A0) ---
__int64 __fastcall sub_1404B90A0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x18);
}

// --- End Function: sub_1404B90A0 (0x1404B90A0) ---

// --- Function: sub_1404C0350 (0x1404C0350) ---
__int64 __fastcall sub_1404C0350(__int64 a1)
{
  return *(unsigned int *)(a1 + 0x16C);
}

// --- End Function: sub_1404C0350 (0x1404C0350) ---

// --- Function: getThreadLogContextSlot (0x1404C2CA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
int *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n0xF; // rax

  v0 = sub_1404B8EB0();
  v1 = v0;
  if ( !v0 )
    return &dword_149C83B90;
  n0xF = *v0;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (int *)&v1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404C2CA0) ---

// --- Function: sub_1404C5990 (0x1404C5990) ---
__int64 __fastcall sub_1404C5990(__int64 a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v4; // rdi
  char i; // dl
  __int64 n2; // r8
  const char *___; // rdx
  char v9; // [rsp+38h] [rbp+10h] BYREF

  *(_BYTE *)(a2 + 0x18) = 0;
  v4 = a3;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0x7F;
  for ( i = *a3; i; ++v4 )
  {
    switch ( i )
    {
      case 8:
        n2 = 2;
        ___ = "\\b";
        break;
      case 9:
        n2 = 2;
        ___ = "\\t";
        break;
      case 0xA:
        n2 = 2;
        ___ = "\\n";
        break;
      case 0xC:
        n2 = 2;
        ___ = "\\f";
        break;
      case 0xD:
        n2 = 2;
        ___ = "\\r";
        break;
      case 0x22:
        n2 = 2;
        ___ = "\\\"";
        break;
      case 0x2F:
        n2 = 2;
        ___ = "\\/";
        break;
      case 0x5C:
        n2 = 2;
        ___ = "\\\\";
        break;
      default:
        v9 = i;
        n2 = 1;
        ___ = &v9;
        break;
    }
    sub_140501250(a2, ___, n2);
    i = v4[1];
  }
  return a2;
}

// --- End Function: sub_1404C5990 (0x1404C5990) ---

// --- Function: sub_1404CAEB0 (0x1404CAEB0) ---
__int64 __fastcall sub_1404CAEB0(__int64 *a1)
{
  __int64 v1; // rax
  char v3[8]; // [rsp+20h] [rbp-59h] BYREF
  __int64 v4; // [rsp+28h] [rbp-51h]
  __int64 v5; // [rsp+30h] [rbp-49h]
  __int64 n0x8000; // [rsp+38h] [rbp-41h]
  __int64 n0x100000; // [rsp+40h] [rbp-39h]
  int n2; // [rsp+48h] [rbp-31h]
  int n2_1; // [rsp+4Ch] [rbp-2Dh]
  char v10; // [rsp+50h] [rbp-29h]
  float v11; // [rsp+54h] [rbp-25h]
  __int64 n0xBB8; // [rsp+58h] [rbp-21h]
  __int64 n0x7D0; // [rsp+60h] [rbp-19h]
  _QWORD v14[12]; // [rsp+70h] [rbp-9h] BYREF

  v3[0] = 1;
  memset(v14, 0, 0x58);
  v4 = 0;
  v5 = 0;
  v10 = 0;
  v1 = *a1;
  v11 = 10.0;
  n0x8000 = 0x8000;
  n0x100000 = 0x100000;
  n2 = 2;
  n2_1 = 2;
  n0xBB8 = 0xBB8;
  n0x7D0 = 0x7D0;
  (*(void (__fastcall **)(__int64 *, _QWORD *, char *))(v1 + 0x6F8))(a1, v14, v3);
  return sub_140302770((__int64)v14, (__int64)v3);
}

// --- End Function: sub_1404CAEB0 (0x1404CAEB0) ---

// --- Function: sub_1404D5120 (0x1404D5120) ---
unsigned __int64 *sub_1404D5120()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 n0xF; // rcx

  v0 = sub_1404B8EB0();
  n0xF = *v0;
  if ( *v0 )
    *v0 = --n0xF;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return &v0[0x16 * n0xF + 1];
}

// --- End Function: sub_1404D5120 (0x1404D5120) ---

// --- Function: sub_1404D8EF0 (0x1404D8EF0) ---
unsigned __int64 *__fastcall sub_1404D8EF0(_OWORD *a1)
{
  unsigned __int64 *v2; // rax
  unsigned __int64 *v3; // r9
  unsigned __int64 n0x10; // rdx
  unsigned __int64 *v5; // r8
  unsigned __int64 n0xF; // rax

  v2 = sub_1404B8EB0();
  v3 = v2;
  n0x10 = *v2 + 1;
  *v2 = n0x10;
  if ( n0x10 < 0x10 )
  {
    v5 = &v2[0x16 * n0x10];
    *(_OWORD *)(v5 + 1) = *a1;
    *(_OWORD *)(v5 + 3) = a1[1];
    *(_OWORD *)(v5 + 5) = a1[2];
    *(_OWORD *)(v5 + 7) = a1[3];
    *(_OWORD *)(v5 + 9) = a1[4];
    *(_OWORD *)(v5 + 0xB) = a1[5];
    *(_OWORD *)(v5 + 0xD) = a1[6];
    *(_OWORD *)(v5 + 0xF) = a1[7];
    *(_OWORD *)(v5 + 0x11) = a1[8];
    *(_OWORD *)(v5 + 0x13) = a1[9];
    *(_OWORD *)(v5 + 0x15) = a1[0xA];
  }
  n0xF = *v2;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return &v3[0x16 * n0xF + 1];
}

// --- End Function: sub_1404D8EF0 (0x1404D8EF0) ---

// --- Function: sub_1404F8A30 (0x1404F8A30) ---
__int64 __fastcall sub_1404F8A30(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x28] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x28] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x29] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x29] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x2A] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x2A] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x2B] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x2B] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x2C] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x2C] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x2D] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x2D] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x2E] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x2E] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x2F] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x2F] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F8A30 (0x1404F8A30) ---

// --- Function: sub_1404F8B80 (0x1404F8B80) ---
__int64 __fastcall sub_1404F8B80(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x10] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x10] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x11] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x11] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x12] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x12] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x13] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x13] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x14] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x14] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x15] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x15] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x16] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x16] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x17] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x17] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[0x18] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[0x18] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[0x19] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[0x19] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0x1A] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0x1A] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0x1B] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0x1B] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0x1C] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0x1C] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0x1D] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0x1D] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0x1E] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0x1E] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0x1F] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0x1F] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F8B80 (0x1404F8B80) ---

// --- Function: sub_1404F8DD0 (0x1404F8DD0) ---
__int64 __fastcall sub_1404F8DD0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x20] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x20] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x21] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x21] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x22] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x22] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x23] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x23] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x24] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x24] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x25] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x25] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x26] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x26] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x27] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x27] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F8DD0 (0x1404F8DD0) ---

// --- Function: sub_1404F91E0 (0x1404F91E0) ---
__int64 __fastcall sub_1404F91E0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[5] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[6] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[7] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[8] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[9] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0xA] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0xA] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0xB] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0xB] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0xC] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0xC] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0xD] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0xD] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0xE] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0xE] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0xF] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0xF] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F91E0 (0x1404F91E0) ---

// --- Function: sub_1405026C0 (0x1405026C0) ---
__int64 __fastcall sub_1405026C0(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _BYTE *v3; // rsi
  __int64 result; // rax

  v2 = (_QWORD *)a1[2];
  v3 = a1 + 3;
  if ( v2 != a1 + 3 )
  {
    qword_149C850A8 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
    result = sub_147715880(v2);
  }
  a1[2] = v3;
  *v3 = 0;
  *a1 = 0;
  a1[1] = 0x3F;
  return result;
}

// --- End Function: sub_1405026C0 (0x1405026C0) ---

// --- Function: sub_140502730 (0x140502730) ---
__int64 __fastcall sub_140502730(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _BYTE *v3; // rsi
  __int64 result; // rax

  v2 = (_QWORD *)a1[2];
  v3 = a1 + 3;
  if ( v2 != a1 + 3 )
  {
    qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
    result = sub_147715880(v2);
  }
  a1[2] = v3;
  *v3 = 0;
  *a1 = 0;
  a1[1] = 0x7F;
  return result;
}

// --- End Function: sub_140502730 (0x140502730) ---

// --- Function: sub_1405027A0 (0x1405027A0) ---
__int64 __fastcall sub_1405027A0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 n8; // rbx
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v5; // r15
  unsigned __int64 allocSize; // rcx
  __int64 v7; // rax
  _QWORD *v8; // r14
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx
  __int64 v11; // r12
  size_t Size; // rdi
  const void *v13; // rdx
  char *v14; // rdi
  size_t Size_1; // r8
  char *v16; // rcx
  __int64 result; // rax
  __int64 v18; // rcx

  n8 = 1;
  n8_1 = a1[2];
  if ( n8_1 )
    n8 = n8_1;
  while ( n8 - n8_1 < a2 || n8 < 8 )
  {
    if ( 0xFFFFFFFFFFFFFFFLL - n8 < n8 )
      unknown_libname_8();
    n8 *= 2LL;
  }
  v5 = a1[3] >> 2;
  if ( n8 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  allocSize = 8 * n8;
  if ( 8 * n8 < 0x1000 )
  {
    if ( allocSize )
      v8 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v8 = 0;
    goto LABEL_15;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_25:
    sub_1402E3880();
  v7 = sub_1402A65A0(allocSize + 0x27);
  if ( !v7 )
    goto LABEL_24;
  v8 = (_QWORD *)((v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v8[0xFFFFFFFF] = v7;
LABEL_15:
  v9 = a1[2];
  v10 = n8 - v9;
  v11 = 8 * v5;
  Size = 8 * v9 - 8 * v5;
  memmove(&v8[v5], (const void *)(a1[1] + 8 * v5), Size);
  v13 = (const void *)a1[1];
  v14 = (char *)&v8[v5] + Size;
  if ( v5 > v10 )
  {
    memmove(v14, v13, 8 * v10);
    memmove(v8, (const void *)(8 * v10 + a1[1]), v11 - 8 * v10);
    v16 = (char *)v8 + v11 - 8 * v10;
    Size_1 = 8 * v10;
  }
  else
  {
    memmove(v14, v13, 8 * v5);
    memset(&v14[v11], 0, 8 * (v10 - v5));
    Size_1 = 8 * v5;
    v16 = (char *)v8;
  }
  result = (__int64)memset(v16, 0, Size_1);
  v18 = a1[1];
  if ( v18 )
  {
    if ( (unsigned __int64)(8LL * a1[2]) < 0x1000 )
    {
LABEL_22:
      result = sub_1402A6590(v18);
      goto LABEL_23;
    }
    if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) <= 0x1F )
    {
      v18 = *(_QWORD *)(v18 - 8);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  a1[2] += v10;
  a1[1] = v8;
  return result;
}

// --- End Function: sub_1405027A0 (0x1405027A0) ---

// --- Function: sub_140502AC0 (0x140502AC0) ---
void __noreturn sub_140502AC0()
{
  stdext::exception *v0; // rax
  __int128 v1; // [rsp+20h] [rbp-18h] BYREF

  v1 = 0;
  v0 = (stdext::exception *)sub_1404659E0(&v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_140502AC0 (0x140502AC0) ---

// --- Function: sub_140505F80 (0x140505F80) ---
__int64 __fastcall sub_140505F80(__int64 *a1)
{
  if ( is_valid_handle_typeA(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_140505F80 (0x140505F80) ---

// --- Function: sub_140507C10 (0x140507C10) ---
unsigned __int64 __fastcall sub_140507C10(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdi
  void *v7; // rbx

  v3 = *(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1;
  result = (unsigned __int64)((unsigned __int128)(v3 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F;
  if ( a2 > v3 / 0x18 )
  {
    if ( a2 > 0xAAAAAAAAAAAAAAALL )
      unknown_libname_10();
    v6 = (__int64)((unsigned __int128)((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 2;
    v7 = (void *)sub_140394E70(a1, 0x18 * a2);
    memmove(v7, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    return sub_1403351C0((unsigned __int64 *)a1, (unsigned __int64)v7, (v6 >> 0x3F) + v6, a2);
  }
  return result;
}

// --- End Function: sub_140507C10 (0x140507C10) ---

// --- Function: sub_140508F90 (0x140508F90) ---
unsigned __int64 __fastcall sub_140508F90(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // r10
  int v6; // ecx
  int v7; // eax
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rdx
  int v10; // eax
  unsigned __int64 v11; // rax
  unsigned __int64 result; // rax
  __int64 v13; // rdx
  int v14; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v6 = *(_DWORD *)(*a1 - 4);
  v7 = 8 * v6;
  if ( v6 >= 0 )
    v8 = (unsigned __int64)v7 >> 3;
  else
    LODWORD(v8) = *(_DWORD *)(v7 + v3);
  v9 = 0;
  v10 = 0;
  if ( a3 )
    LOBYTE(v10) = a2 > (int)v8;
  else
    LOBYTE(v10) = a2 != (_DWORD)v8;
  if ( v10 )
  {
    v14 = a2;
    if ( v6 )
      v9 = v3;
    v11 = sub_14035CDA0((__int64)a1, v9, v6 & 0x7FFFFFFF, &v14, 8u, a3);
    *a1 = v11;
    v3 = v11;
    if ( !v11 )
    {
      result = (unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL;
      *a1 = (unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL;
      return result;
    }
    LODWORD(v8) = v14;
  }
  v13 = 8 * a2;
  *(_DWORD *)(v3 - 4) = a2;
  result = v13 + 4;
  if ( 8LL * (int)v8 >= (unsigned __int64)(v13 + 4) )
  {
    *(_DWORD *)(v3 - 4) = a2 | 0x80000000;
    *(_DWORD *)(v13 + v3) = v8;
  }
  return result;
}

// --- End Function: sub_140508F90 (0x140508F90) ---

// --- Function: sub_1405099D0 (0x1405099D0) ---
__int64 __fastcall sub_1405099D0(_QWORD *a1, __int64 a2, __int64 a3)
{
  return sub_14035D730(a2, a3, 0, *a1);
}

// --- End Function: sub_1405099D0 (0x1405099D0) ---

// --- Function: sub_1405099F0 (0x1405099F0) ---
int __fastcall sub_1405099F0(
        __int64 a1,
        char *DstBuf,
        size_t SizeInBytes,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  return snprintf_s(
           DstBuf,
           SizeInBytes,
           0xFFFFFFFFFFFFFFFFuLL,
           (const char *)&Format_,
           *(_QWORD *)(a1 + 8),
           a6,
           a7,
           a8,
           a9);
}

// --- End Function: sub_1405099F0 (0x1405099F0) ---

// --- Function: sub_140509A20 (0x140509A20) ---
__int64 __fastcall sub_140509A20(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_140454810(a2, a3, 0, *(_DWORD *)(a1 + 8));
}

// --- End Function: sub_140509A20 (0x140509A20) ---

// --- Function: sub_140509F20 (0x140509F20) ---
int __fastcall sub_140509F20(__int64 a1, char *DstBuf, size_t SizeInBytes, __int64 a4, __int64 a5, __int64 a6)
{
  __int128 v6; // xmm6
  __int64 v9; // xmm6_8
  int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 n0x20; // rax
  __int64 v15; // [rsp+38h] [rbp-60h] BYREF
  const char *p_f; // [rsp+40h] [rbp-58h] BYREF
  char Format_[32]; // [rsp+50h] [rbp-48h] BYREF
  __int128 v18; // [rsp+80h] [rbp-18h]

  v18 = v6;
  v9 = *(_QWORD *)(a1 + 8);
  v15 = a6;
  p_f = "f";
  if ( !a6 )
    return snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, (const char *)&::Format_, v9);
  Format_[0] = 0x25;
  v10 = sub_140454990((unsigned int)Format_, 0x1F, 1, (unsigned int)&v15, (__int64)&p_f);
  if ( v10 < 0 )
    return snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, (const char *)&::Format_, v9);
  n0x20 = v10 + 1LL;
  if ( n0x20 >= 0x20 )
    _report_rangecheckfailure(v12, v11);
  Format_[n0x20] = 0;
  return snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, Format_, v9);
}

// --- End Function: sub_140509F20 (0x140509F20) ---

// --- Function: sub_14052A3B0 (0x14052A3B0) ---
unsigned __int64 __fastcall sub_14052A3B0(__int64 a1)
{
  unsigned __int64 result; // rax

  result = (*(_QWORD *)(a1 + 8) + 0x27LL) & 0xFFFFFFFFFFFFFFF8uLL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_14052A3B0 (0x14052A3B0) ---

// --- Function: sub_14052A3D0 (0x14052A3D0) ---
unsigned __int64 __fastcall sub_14052A3D0(__int64 a1)
{
  unsigned __int64 result; // rax

  result = (*(_QWORD *)(a1 + 8) + 0x47LL) & 0xFFFFFFFFFFFFFFF8uLL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_14052A3D0 (0x14052A3D0) ---

// --- Function: sub_14052A590 (0x14052A590) ---
void __fastcall sub_14052A590(__int64 a1)
{
  ++*(_QWORD *)(a1 + 8);
}

// --- End Function: sub_14052A590 (0x14052A590) ---

// --- Function: sub_14052A620 (0x14052A620) ---
unsigned __int64 __fastcall sub_14052A620(__int64 a1, __int64 a2, _DWORD *a3)
{
  _QWORD *v3; // rdx
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  bool v6; // cf
  bool v7; // zf
  unsigned __int64 result; // rax
  unsigned __int64 v9; // r9

  v3 = *(_QWORD **)(a1 + 8);
  v4 = (unsigned __int64)(v3[2] + 7LL) >> 3;
  v5 = 8 * v4 + 0x20;
  v6 = v5 < v3[1];
  v7 = v5 == v3[1];
  v3[2] = v5;
  result = v4 + *v3;
  v9 = result * (v6 | (unsigned __int8)v7);
  if ( v9 )
  {
    result = *(unsigned int *)v9;
    *a3 = result;
  }
  return result;
}

// --- End Function: sub_14052A620 (0x14052A620) ---

// --- Function: sub_14052A660 (0x14052A660) ---
unsigned __int64 __fastcall sub_14052A660(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  _QWORD *v3; // rdx
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  bool v6; // cf
  bool v7; // zf
  unsigned __int64 result; // rax
  unsigned __int64 *v9; // r9

  v3 = *(_QWORD **)(a1 + 8);
  v4 = (unsigned __int64)(v3[2] + 7LL) >> 3;
  v5 = 8 * v4 + 0x40;
  v6 = v5 < v3[1];
  v7 = v5 == v3[1];
  v3[2] = v5;
  result = v4 + *v3;
  v9 = (unsigned __int64 *)(result * (v6 | (unsigned __int8)v7));
  if ( v9 )
  {
    result = *v9;
    *a3 = *v9;
  }
  return result;
}

// --- End Function: sub_14052A660 (0x14052A660) ---

// --- Function: sub_14052A720 (0x14052A720) ---
__int64 __fastcall sub_14052A720(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_14052E440(a1, a3);
}

// --- End Function: sub_14052A720 (0x14052A720) ---

// --- Function: serialize_int32 (0x14052AA30) ---
// Serializes a 32-bit integer `*value_ptr` into the buffer managed by
// `serializer_ctx`. Calculates the next 8-byte aligned offset within the buffer,
// writes the integer value to that offset, and updates the current offset in the
// context by adding 32 bytes. Returns the absolute offset within the buffer where
// the value was written.
unsigned __int64 __fastcall serialize_int32(__int64 a1, __int64 a2, int *a3)
{
  int v3; // r10d
  __int64 v4; // r9
  __int64 v5; // r8
  unsigned int v6; // eax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  bool v9; // cc
  unsigned __int64 result; // rax
  unsigned __int64 v11; // r9

  v3 = *a3;
  v4 = 0;
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(unsigned __int8 *)(v5 + 0x18);
  v7 = (unsigned __int64)(*(_QWORD *)(v5 + 0x10) + 7LL) >> 3;
  v8 = 8 * v7 + 0x20;
  v9 = v8 <= *(_QWORD *)(v5 + 8);
  *(_QWORD *)(v5 + 0x10) = v8;
  if ( v9 )
    v4 = v6;
  result = v7 + *(_QWORD *)v5;
  v11 = result * v4;
  if ( v11 )
    *(_DWORD *)v11 = v3;
  return result;
}

// --- End Function: serialize_int32 (0x14052AA30) ---

// --- Function: sub_14052AA80 (0x14052AA80) ---
unsigned __int64 __fastcall sub_14052AA80(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v3; // r9
  unsigned int v4; // xmm0_4
  __int64 v5; // r8
  unsigned int v6; // eax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  bool v9; // cc
  unsigned __int64 result; // rax
  unsigned __int64 v11; // r8

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *a3;
  v5 = 0;
  v6 = *(unsigned __int8 *)(v3 + 0x18);
  v7 = (unsigned __int64)(*(_QWORD *)(v3 + 0x10) + 7LL) >> 3;
  v8 = 8 * v7 + 0x20;
  v9 = v8 <= *(_QWORD *)(v3 + 8);
  *(_QWORD *)(v3 + 0x10) = v8;
  if ( v9 )
    v5 = v6;
  result = v7 + *(_QWORD *)v3;
  v11 = result * v5;
  if ( v11 )
  {
    result = v4;
    *(_DWORD *)v11 = v4;
  }
  return result;
}

// --- End Function: sub_14052AA80 (0x14052AA80) ---

// --- Function: sub_14052D0E0 (0x14052D0E0) ---
__int64 sub_14052D0E0()
{
  __int64 result; // rax
  unsigned int v1; // ebx
  const char *p_uint32; // rcx
  unsigned __int8 n0x75; // al
  unsigned int v4; // [rsp+20h] [rbp-58h] BYREF
  _BYTE v5[72]; // [rsp+28h] [rbp-50h] BYREF

  result = (unsigned int)dword_149C85618;
  if ( !dword_149C85618 )
  {
    sub_140530130(&v4);
    v1 = v4;
    p_uint32 = "uint32";
    n0x75 = 0x75;
    do
    {
      ++p_uint32;
      v1 = 0x1000193 * (v1 ^ n0x75);
      n0x75 = *p_uint32;
    }
    while ( *p_uint32 );
    v4 = v1;
    sub_140374120(v5);
    result = v1;
    dword_149C85618 = v1;
  }
  return result;
}

// --- End Function: sub_14052D0E0 (0x14052D0E0) ---

// --- Function: sub_14052D150 (0x14052D150) ---
__int64 sub_14052D150()
{
  __int64 result; // rax
  unsigned int v1; // ebx
  const char *p_f32; // rcx
  unsigned __int8 n0x66; // al
  unsigned int v4; // [rsp+20h] [rbp-58h] BYREF
  _BYTE v5[72]; // [rsp+28h] [rbp-50h] BYREF

  result = (unsigned int)dword_149C85630;
  if ( !dword_149C85630 )
  {
    sub_140530130((__int64)&v4);
    v1 = v4;
    p_f32 = "f32";
    n0x66 = 0x66;
    do
    {
      ++p_f32;
      v1 = 0x1000193 * (v1 ^ n0x66);
      n0x66 = *p_f32;
    }
    while ( *p_f32 );
    v4 = v1;
    sub_140374120(v5);
    result = v1;
    dword_149C85630 = v1;
  }
  return result;
}

// --- End Function: sub_14052D150 (0x14052D150) ---

// --- Function: sub_14052E440 (0x14052E440) ---
unsigned __int64 __fastcall sub_14052E440(__int64 a1, _DWORD *a2)
{
  _QWORD *v2; // r9
  __int64 v3; // r10
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rax
  bool v8; // cf
  bool v9; // zf
  unsigned __int64 v10; // rdx
  _QWORD *v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // r8
  _QWORD *v15; // rdx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rax
  unsigned __int64 result; // rax
  unsigned __int64 v19; // r10

  v2 = *(_QWORD **)(a1 + 8);
  v3 = 0;
  v6 = (unsigned __int64)(v2[2] + 7LL) >> 3;
  v7 = 8 * v6 + 0x20;
  v8 = v7 < v2[1];
  v9 = v7 == v2[1];
  v2[2] = v7;
  v10 = (v6 + *v2) * (v8 | (unsigned __int8)v9);
  if ( v10 )
    *a2 = *(_DWORD *)v10;
  v11 = *(_QWORD **)(a1 + 8);
  v12 = (unsigned __int64)(v11[2] + 7LL) >> 3;
  v13 = 8 * v12 + 0x20;
  v8 = v13 < v11[1];
  v9 = v13 == v11[1];
  v11[2] = v13;
  v14 = (v12 + *v11) * (v8 | (unsigned __int8)v9);
  if ( v14 )
    a2[1] = *(_DWORD *)v14;
  v15 = *(_QWORD **)(a1 + 8);
  v16 = (unsigned __int64)(v15[2] + 7LL) >> 3;
  v17 = 8 * v16 + 0x20;
  v8 = v17 < v15[1];
  v9 = v17 == v15[1];
  v15[2] = v17;
  LOBYTE(v3) = v8 || v9;
  result = v16 + *v15;
  v19 = result * v3;
  if ( v19 )
  {
    result = *(unsigned int *)v19;
    a2[2] = result;
  }
  return result;
}

// --- End Function: sub_14052E440 (0x14052E440) ---

// --- Function: sub_14052EDB0 (0x14052EDB0) ---
_BYTE *__fastcall sub_14052EDB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  size_t Size_4; // r12
  _BYTE *p_Src; // rdx
  unsigned __int64 v6; // rax
  size_t Size_1; // rdi
  _BYTE *p_Src_2; // r14
  unsigned __int64 n0x7F_1; // rax
  unsigned __int64 v10; // r15
  unsigned __int16 n0x800; // bx
  unsigned __int64 n0x7F_2; // rsi
  _BYTE *p_Src_15; // rcx
  _BYTE *p_Src_16; // rax
  char v15; // bl
  _BYTE *p_Src_11; // rcx
  _BYTE *p_Src_12; // rax
  size_t Size_3; // rsi
  size_t n0x7F_5; // rbx
  char v20; // di
  _BYTE *p_Src_8; // r15
  _BYTE *p_Src_13; // rcx
  size_t v23; // r14
  _BYTE *p_Src_14; // rax
  char v25; // bl
  _BYTE *p_Src_3; // rcx
  _BYTE *p_Src_4; // rax
  __int64 v28; // rsi
  size_t Size_2; // r14
  size_t n0x7F_3; // rdi
  char v31; // bl
  _BYTE *p_Src_5; // r15
  _BYTE *p_Src_6; // rcx
  size_t v34; // rsi
  _BYTE *p_Src_7; // rax
  char v36; // di
  size_t n0x7F_4; // rbx
  _BYTE *p_Src_9; // rcx
  size_t v39; // r14
  _BYTE *p_Src_10; // rax
  _BYTE *p_Src_17; // rax
  unsigned __int64 v42; // [rsp+28h] [rbp-E0h]
  unsigned __int64 v44; // [rsp+38h] [rbp-D0h]
  size_t Size; // [rsp+48h] [rbp-C0h] BYREF
  size_t n0x7F; // [rsp+50h] [rbp-B8h]
  void *p_Src_1; // [rsp+58h] [rbp-B0h]
  _BYTE Src[136]; // [rsp+60h] [rbp-A8h] BYREF

  v3 = a1;
  Size_4 = 0;
  p_Src = Src;
  Size = 0;
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  Src[0] = 0;
  p_Src_1 = Src;
  n0x7F = 0x7F;
  do
    ++v6;
  while ( *(_WORD *)(a1 + 2 * v6) );
  v44 = v6;
  if ( !v6 )
    goto LABEL_75;
  LOBYTE(a3) = 0x20;
  sub_140534900(&Size, v6, a3);
  Size_1 = Size;
  if ( Size )
  {
    if ( p_Src_1 != Src )
    {
      qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
      sub_147715880(p_Src_1);
    }
    p_Src_2 = Src;
    Src[0] = 0;
    n0x7F_1 = 0x7F;
    p_Src_1 = Src;
    n0x7F = 0x7F;
    Size_1 = 0;
    Size = 0;
  }
  else
  {
    p_Src_2 = p_Src_1;
    n0x7F_1 = n0x7F;
  }
  v42 = 0;
  v10 = 0;
  while ( 1 )
  {
    n0x800 = *(_WORD *)(v3 + 2 * v10);
    n0x7F_2 = Size_1 + 1;
    if ( n0x800 >= 0x80u )
    {
      if ( n0x800 >= 0x800u )
      {
        v25 = (n0x800 >> 0xC) | 0xE0;
        if ( n0x7F_2 < n0x7F_1 )
        {
          p_Src_2[Size_1] = v25;
          Size = Size_1 + 1;
          *((_BYTE *)p_Src_1 + Size_1 + 1) = 0;
        }
        else
        {
          if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
          {
            p_Src_3 = Src;
            Src[0] = 0;
            p_Src_1 = Src;
            Size = 0;
            n0x7F = 0x7F;
          }
          else
          {
            p_Src_4 = Src;
            if ( Size_1 + 2 <= 0x80 )
            {
              n0x7F = 0x7F;
            }
            else
            {
              p_Src_4 = (_BYTE *)allocWithProfilerInfo(Size_1 + 2, 0);
              qword_149C80C40 += Size_1 + 2;
              n0x7F = Size_1 + 1;
            }
            v10 = v42;
            p_Src_1 = p_Src_4;
            Size = Size_1 + 1;
            p_Src_4[n0x7F_2] = 0;
            p_Src_3 = p_Src_1;
          }
          memcpy(p_Src_3, p_Src_2, Size_1);
          *((_BYTE *)p_Src_1 + Size_1) = v25;
          if ( p_Src_2 != Src )
          {
            qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
            sub_147715880(p_Src_2);
          }
        }
        v28 = a1;
        Size_2 = Size;
        n0x7F_3 = Size + 1;
        v31 = (*(_WORD *)(a1 + 2 * v10) >> 6) & 0x3F | 0x80;
        if ( Size + 1 < n0x7F )
        {
          *((_BYTE *)p_Src_1 + Size) = v31;
          Size = Size_2 + 1;
          *((_BYTE *)p_Src_1 + Size_2 + 1) = 0;
        }
        else
        {
          p_Src_5 = p_Src_1;
          if ( Size == 0xFFFFFFFFFFFFFFFFuLL )
          {
            p_Src_6 = Src;
            Src[0] = 0;
            p_Src_1 = Src;
            Size = 0;
            n0x7F = 0x7F;
          }
          else
          {
            v34 = Size + 2;
            p_Src_7 = Src;
            if ( Size + 2 <= 0x80 )
            {
              n0x7F = 0x7F;
            }
            else
            {
              p_Src_7 = (_BYTE *)allocWithProfilerInfo(Size + 2, 0);
              qword_149C80C40 += v34;
              n0x7F = n0x7F_3;
            }
            v28 = a1;
            p_Src_1 = p_Src_7;
            Size = n0x7F_3;
            p_Src_7[n0x7F_3] = 0;
            p_Src_6 = p_Src_1;
          }
          memcpy(p_Src_6, p_Src_5, Size_2);
          *((_BYTE *)p_Src_1 + Size_2) = v31;
          if ( p_Src_5 != Src )
          {
            qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
            sub_147715880(p_Src_5);
          }
          v10 = v42;
        }
        v36 = *(_BYTE *)(v28 + 2 * v10);
        Size_3 = Size;
        v20 = v36 & 0x3F | 0x80;
        n0x7F_4 = Size + 1;
        if ( Size + 1 < n0x7F )
        {
LABEL_41:
          *((_BYTE *)p_Src_1 + Size_3) = v20;
          Size = Size_3 + 1;
          *((_BYTE *)p_Src_1 + Size_3 + 1) = 0;
          goto LABEL_72;
        }
        p_Src_8 = p_Src_1;
        if ( Size == 0xFFFFFFFFFFFFFFFFuLL )
        {
          p_Src_9 = Src;
          Src[0] = 0;
          p_Src_1 = Src;
          Size = 0;
          n0x7F = 0x7F;
        }
        else
        {
          v39 = Size + 2;
          p_Src_10 = Src;
          if ( Size + 2 <= 0x80 )
          {
            n0x7F = 0x7F;
          }
          else
          {
            p_Src_10 = (_BYTE *)allocWithProfilerInfo(Size + 2, 0);
            qword_149C80C40 += v39;
            n0x7F = n0x7F_4;
          }
          p_Src_1 = p_Src_10;
          Size = n0x7F_4;
          p_Src_10[n0x7F_4] = 0;
          p_Src_9 = p_Src_1;
        }
        memcpy(p_Src_9, p_Src_8, Size_3);
        *((_BYTE *)p_Src_1 + Size_3) = v20;
        if ( p_Src_8 == Src )
          goto LABEL_71;
      }
      else
      {
        v15 = (n0x800 >> 6) | 0xC0;
        if ( n0x7F_2 < n0x7F_1 )
        {
          p_Src_2[Size_1] = v15;
          Size = Size_1 + 1;
          *((_BYTE *)p_Src_1 + Size_1 + 1) = 0;
        }
        else
        {
          if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
          {
            p_Src_11 = Src;
            Src[0] = 0;
            p_Src_1 = Src;
            Size = 0;
            n0x7F = 0x7F;
          }
          else
          {
            p_Src_12 = Src;
            if ( Size_1 + 2 <= 0x80 )
            {
              n0x7F = 0x7F;
            }
            else
            {
              p_Src_12 = (_BYTE *)allocWithProfilerInfo(Size_1 + 2, 0);
              qword_149C80C40 += Size_1 + 2;
              n0x7F = Size_1 + 1;
            }
            v10 = v42;
            p_Src_1 = p_Src_12;
            Size = Size_1 + 1;
            p_Src_12[n0x7F_2] = 0;
            p_Src_11 = p_Src_1;
          }
          memcpy(p_Src_11, p_Src_2, Size_1);
          *((_BYTE *)p_Src_1 + Size_1) = v15;
          if ( p_Src_2 != Src )
          {
            qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
            sub_147715880(p_Src_2);
          }
        }
        Size_3 = Size;
        n0x7F_5 = Size + 1;
        v20 = *(_BYTE *)(a1 + 2 * v10) & 0x3F | 0x80;
        if ( Size + 1 < n0x7F )
          goto LABEL_41;
        p_Src_8 = p_Src_1;
        if ( Size == 0xFFFFFFFFFFFFFFFFuLL )
        {
          p_Src_13 = Src;
          Src[0] = 0;
          p_Src_1 = Src;
          Size = 0;
          n0x7F = 0x7F;
        }
        else
        {
          v23 = Size + 2;
          p_Src_14 = Src;
          if ( Size + 2 <= 0x80 )
          {
            n0x7F = 0x7F;
          }
          else
          {
            p_Src_14 = (_BYTE *)allocWithProfilerInfo(Size + 2, 0);
            qword_149C80C40 += v23;
            n0x7F = n0x7F_5;
          }
          p_Src_1 = p_Src_14;
          Size = n0x7F_5;
          p_Src_14[n0x7F_5] = 0;
          p_Src_13 = p_Src_1;
        }
        memcpy(p_Src_13, p_Src_8, Size_3);
        *((_BYTE *)p_Src_1 + Size_3) = v20;
        if ( p_Src_8 == Src )
          goto LABEL_71;
      }
      qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
      sub_147715880(p_Src_8);
LABEL_71:
      v10 = v42;
      goto LABEL_72;
    }
    if ( n0x7F_2 < n0x7F_1 )
    {
      p_Src_2[Size_1] = n0x800;
      Size = Size_1 + 1;
      *((_BYTE *)p_Src_1 + Size_1 + 1) = 0;
    }
    else
    {
      if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
      {
        p_Src_15 = Src;
        Src[0] = 0;
        p_Src_1 = Src;
        Size = 0;
        n0x7F = 0x7F;
      }
      else
      {
        p_Src_16 = Src;
        if ( Size_1 + 2 <= 0x80 )
        {
          n0x7F = 0x7F;
        }
        else
        {
          p_Src_16 = (_BYTE *)allocWithProfilerInfo(Size_1 + 2, 0);
          qword_149C80C40 += Size_1 + 2;
          n0x7F = Size_1 + 1;
        }
        v10 = v42;
        p_Src_1 = p_Src_16;
        Size = Size_1 + 1;
        p_Src_16[n0x7F_2] = 0;
        p_Src_15 = p_Src_1;
      }
      memcpy(p_Src_15, p_Src_2, Size_1);
      *((_BYTE *)p_Src_1 + Size_1) = n0x800;
      if ( p_Src_2 != Src )
      {
        qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
        sub_147715880(p_Src_2);
      }
    }
LABEL_72:
    v42 = ++v10;
    if ( v10 >= v44 )
      break;
    p_Src_2 = p_Src_1;
    n0x7F_1 = n0x7F;
    Size_1 = Size;
    v3 = a1;
  }
  p_Src = p_Src_1;
  Size_4 = Size;
LABEL_75:
  sub_1403E6AC0(a2, p_Src, Size_4);
  p_Src_17 = Src;
  if ( p_Src_1 != Src )
  {
    qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
    return (_BYTE *)sub_147715880(p_Src_1);
  }
  return p_Src_17;
}

// --- End Function: sub_14052EDB0 (0x14052EDB0) ---

// --- Function: sub_14053BDD0 (0x14053BDD0) ---
FARPROC __fastcall sub_14053BDD0(int a1, unsigned int a2)
{
  __int64 v2; // rdi
  FARPROC ModuleFunction; // rax
  _QWORD *v5; // rcx

  v2 = a2;
  sub_14053BEA0();
  ModuleFunction = (FARPROC)::ModuleFunction;
  if ( *(_QWORD *)(::ModuleFunction + 0x28) )
  {
    ModuleFunction = getModuleFunction((LPCSTR)&p_Src, "__cigApplyCPUSetToCurrentThread__", 0);
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        v5 = *(_QWORD **)(*(_QWORD *)(::ModuleFunction + 0x30) + 8 * v2);
        return (FARPROC)((__int64 (__fastcall *)(_QWORD, _QWORD))ModuleFunction)(v5[1], *v5);
      }
    }
    else
    {
      return (FARPROC)((__int64 (__fastcall *)(_QWORD, _QWORD))ModuleFunction)(
                        *(_QWORD *)(::ModuleFunction + 0x28),
                        *(_QWORD *)(::ModuleFunction + 0x20));
    }
  }
  return ModuleFunction;
}

// --- End Function: sub_14053BDD0 (0x14053BDD0) ---

// --- Function: sub_14053BEA0 (0x14053BEA0) ---
void sub_14053BEA0()
{
  __int64 (*ModuleFunction)(void); // rax
  __int64 ModuleFunction_1; // rax
  _QWORD *ModuleFunction_2; // rax
  unsigned __int64 v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  __int64 ModuleFunction_3; // rcx
  unsigned __int64 allocSize; // rax
  __int64 ModuleFunction_4; // rax

  if ( !::ModuleFunction )
  {
    ModuleFunction = getModuleFunction((LPCSTR)&p_Src, "__cigDetermineCPUTopology__", 0);
    if ( ModuleFunction )
    {
      ModuleFunction_1 = ModuleFunction();
      ::ModuleFunction = ModuleFunction_1;
    }
    else
    {
      ModuleFunction_1 = ::ModuleFunction;
    }
    if ( !ModuleFunction_1 )
    {
      _safe_get_tls_index();
      _XMM6 = 0;
      __asm { vroundss xmm6, xmm6, xmm0, 2 }
      ModuleFunction_2 = (_QWORD *)sub_1402A65A0(0x38u);
      v5 = 0;
      if ( ModuleFunction_2 )
      {
        *ModuleFunction_2 = 0;
        ModuleFunction_2[1] = 0;
        ModuleFunction_2[2] = 0;
        ModuleFunction_2[3] = 0;
        ModuleFunction_2[4] = 0;
        ModuleFunction_2[5] = 0;
        ModuleFunction_2[6] = 0;
      }
      else
      {
        ModuleFunction_2 = 0;
      }
      ::ModuleFunction = (__int64)ModuleFunction_2;
      *ModuleFunction_2 = _safe_get_tls_index();
      *(_QWORD *)(::ModuleFunction + 8) = (unsigned int)(int)*(float *)&_XMM6;
      v6 = sub_1402A65A0(saturated_mul(*(_QWORD *)::ModuleFunction, 4u));
      v7 = 0;
      *(_QWORD *)(::ModuleFunction + 0x10) = v6;
      for ( ModuleFunction_3 = ::ModuleFunction; v7 < *(_QWORD *)::ModuleFunction; ModuleFunction_3 = ::ModuleFunction )
      {
        *(_DWORD *)(*(_QWORD *)(ModuleFunction_3 + 0x10) + 4 * v7) = v7 >> 3;
        ++v7;
      }
      allocSize = 4LL * *(_QWORD *)(ModuleFunction_3 + 8);
      if ( !is_mul_ok(*(_QWORD *)(ModuleFunction_3 + 8), 4u) )
        allocSize = 0xFFFFFFFFFFFFFFFFuLL;
      *(_QWORD *)(::ModuleFunction + 0x18) = sub_1402A65A0(allocSize);
      ModuleFunction_4 = ::ModuleFunction;
      if ( *(_QWORD *)(::ModuleFunction + 8) )
      {
        do
        {
          *(_DWORD *)(*(_QWORD *)(ModuleFunction_4 + 0x18) + 4 * v5++) = 8;
          ModuleFunction_4 = ::ModuleFunction;
        }
        while ( v5 < *(_QWORD *)(::ModuleFunction + 8) );
      }
    }
  }
}

// --- End Function: sub_14053BEA0 (0x14053BEA0) ---

// --- Function: sub_14053EF00 (0x14053EF00) ---
FARPROC __fastcall sub_14053EF00(__int64 a1)
{
  FARPROC ModuleFunction; // rax

  ModuleFunction = getModuleFunction(0, "__InitializeThreadInfoBlock__", 0);
  if ( ModuleFunction )
    return (FARPROC)((__int64 (__fastcall *)(__int64))ModuleFunction)(a1);
  return ModuleFunction;
}

// --- End Function: sub_14053EF00 (0x14053EF00) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x14053EF50) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x14053EF50) ---

// --- Function: sub_14054B800 (0x14054B800) ---
void __fastcall sub_14054B800(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 1) |= 0x40u;
  *(_QWORD *)(a1 + 0x218) = a2;
}

// --- End Function: sub_14054B800 (0x14054B800) ---

// --- Function: sub_140564E90 (0x140564E90) ---
__int64 __fastcall sub_140564E90(__int64 *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rsi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 5 )
    {
      sub_140373CC0(v1 + 1);
      sub_140373CC0(v1);
    }
    v4 = *a1;
    if ( (unsigned __int64)(0x28 * ((a1[2] - *a1) / 0x28)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_1402A6590(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140564E90 (0x140564E90) ---

// --- Function: ??$_Partition_by_median_guess_unchecked@PEAPEAUFCCDConstraint@Chaos@@P6A_NPEBU12@0@Z@std@@YA?AU?$pair@PEAPEAUFCCDConstraint@Chaos@@PEAPEAU12@@0@PEAPEAUFCCDConstraint@Chaos@@0P6A_NPEBU23@1@Z@Z (0x14056CF60) ---
Chaos::FCCDConstraint ***__fastcall std::_Partition_by_median_guess_unchecked<Chaos::FCCDConstraint * *,bool (*)(Chaos::FCCDConstraint const *,Chaos::FCCDConstraint const *)>(
        Chaos::FCCDConstraint ***a1,
        Chaos::FCCDConstraint **_First,
        Chaos::FCCDConstraint **a3,
        bool (__fastcall *_Pred)(const Chaos::FCCDConstraint *, const Chaos::FCCDConstraint *))
{
  Chaos::FCCDConstraint **_Mid_3; // rcx
  Chaos::FCCDConstraint **_Mid_1; // rbx
  __int64 n0x28; // rax
  __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdi
  Chaos::FCCDConstraint **_Mid_2; // r15
  Chaos::FCCDConstraint **v14; // rsi
  Chaos::FCCDConstraint **_First_1; // rdi
  const Chaos::FCCDConstraint **v16; // rdi
  Chaos::FCCDConstraint **_Mid_4; // r15
  Chaos::FCCDConstraint *v18; // rcx
  bool v19; // zf
  Chaos::FCCDConstraint **_Mid_5; // r14
  Chaos::FCCDConstraint *v21; // rcx
  Chaos::FCCDConstraint *v22; // rcx
  Chaos::FCCDConstraint *v23; // rcx
  Chaos::FCCDConstraint *v24; // rcx
  Chaos::FCCDConstraint *v25; // rax
  Chaos::FCCDConstraint *v26; // rcx
  const Chaos::FCCDConstraint *v27; // rcx
  Chaos::FCCDConstraint ***result; // rax
  Chaos::FCCDConstraint **_Mid; // [rsp+68h] [rbp+10h]

  _Mid_3 = _First;
  _Mid_1 = &_First[((char *)a3 - (char *)_First) >> 4];
  n0x28 = a3 + 0xFFFFFFFF - _First;
  if ( n0x28 <= 0x28 )
  {
    _Mid_2 = a3 + 0xFFFFFFFF;
  }
  else
  {
    v10 = (n0x28 + 1) >> 3;
    v11 = 0x10 * v10;
    v12 = 8 * v10;
    _Mid = &_First[v10];
    std::_Med3_unchecked<Chaos::FCCDConstraint * *,bool (*)(Chaos::FCCDConstraint const *,Chaos::FCCDConstraint const *)>(
      _First,
      _Mid,
      &_First[2 * v10],
      _Pred);
    std::_Med3_unchecked<Chaos::FCCDConstraint * *,bool (*)(Chaos::FCCDConstraint const *,Chaos::FCCDConstraint const *)>(
      &_Mid_1[v12 / 0xFFFFFFFFFFFFFFF8uLL],
      _Mid_1,
      &_Mid_1[(unsigned __int64)v12 / 8],
      _Pred);
    _Mid_2 = &a3[v12 / 0xFFFFFFFFFFFFFFF8uLL + 0xFFFFFFFF];
    std::_Med3_unchecked<Chaos::FCCDConstraint * *,bool (*)(Chaos::FCCDConstraint const *,Chaos::FCCDConstraint const *)>(
      &a3[v11 / 0xFFFFFFFFFFFFFFF8uLL + 0xFFFFFFFF],
      _Mid_2,
      a3 + 0xFFFFFFFF,
      _Pred);
    _Mid_3 = _Mid;
  }
  std::_Med3_unchecked<Chaos::FCCDConstraint * *,bool (*)(Chaos::FCCDConstraint const *,Chaos::FCCDConstraint const *)>(
    _Mid_3,
    _Mid_1,
    _Mid_2,
    _Pred);
  v14 = _Mid_1 + 1;
  if ( _First < _Mid_1 )
  {
    do
    {
      _First_1 = _Mid_1 + 0xFFFFFFFF;
      if ( _Pred(_Mid_1[0xFFFFFFFF], *_Mid_1) )
        break;
      if ( _Pred(*_Mid_1, *_First_1) )
        break;
      _Mid_1 += 0xFFFFFFFF;
    }
    while ( _First < _First_1 );
  }
  for ( ; v14 < a3; ++v14 )
  {
    if ( _Pred(*v14, *_Mid_1) )
      break;
    if ( _Pred(*_Mid_1, *v14) )
      break;
  }
  v16 = v14;
  _Mid_4 = _Mid_1;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( ; v16 < a3; ++v16 )
      {
        if ( !_Pred(*_Mid_1, *v16) )
        {
          if ( _Pred(*v16, *_Mid_1) )
            break;
          if ( v14 != v16 )
          {
            v18 = *v14;
            *v14 = *v16;
            *v16 = v18;
          }
          ++v14;
        }
      }
      v19 = _Mid_4 == _First;
      if ( _Mid_4 > _First )
      {
        _Mid_5 = _Mid_4 + 0xFFFFFFFF;
        do
        {
          if ( !_Pred(*_Mid_5, *_Mid_1) )
          {
            if ( _Pred(*_Mid_1, *_Mid_5) )
              break;
            _Mid_1 += 0xFFFFFFFF;
            if ( _Mid_1 != _Mid_5 )
            {
              v21 = *_Mid_1;
              *_Mid_1 = *_Mid_5;
              *_Mid_5 = v21;
            }
          }
          _Mid_4 += 0xFFFFFFFF;
          _Mid_5 += 0xFFFFFFFF;
        }
        while ( _First < _Mid_4 );
        v19 = _Mid_4 == _First;
      }
      if ( v19 )
        break;
      _Mid_4 += 0xFFFFFFFF;
      if ( v16 == a3 )
      {
        _Mid_1 += 0xFFFFFFFF;
        if ( _Mid_4 != _Mid_1 )
        {
          v24 = *_Mid_4;
          *_Mid_4 = *_Mid_1;
          *_Mid_1 = v24;
        }
        v25 = v14[0xFFFFFFFF];
        v14 += 0xFFFFFFFF;
        v26 = *_Mid_1;
        *_Mid_1 = v25;
        *v14 = v26;
      }
      else
      {
        v27 = *v16;
        *v16++ = *_Mid_4;
        *_Mid_4 = v27;
      }
    }
    if ( v16 == a3 )
      break;
    if ( v14 != v16 )
    {
      v22 = *_Mid_1;
      *_Mid_1 = *v14;
      *v14 = v22;
    }
    ++v14;
    v23 = *_Mid_1;
    *_Mid_1++ = *v16;
    *v16++ = v23;
  }
  result = a1;
  *a1 = _Mid_1;
  a1[1] = v14;
  return result;
}

// --- End Function: ??$_Partition_by_median_guess_unchecked@PEAPEAUFCCDConstraint@Chaos@@P6A_NPEBU12@0@Z@std@@YA?AU?$pair@PEAPEAUFCCDConstraint@Chaos@@PEAPEAU12@@0@PEAPEAUFCCDConstraint@Chaos@@0P6A_NPEBU23@1@Z@Z (0x14056CF60) ---

// --- Function: GetCurrentThreadId (0x14056EBA0) ---
// attributes: thunk
DWORD __stdcall GetCurrentThreadId()
{
  return __imp_GetCurrentThreadId();
}

// --- End Function: GetCurrentThreadId (0x14056EBA0) ---

// --- Function: sub_14056ECD0 (0x14056ECD0) ---
__int64 __fastcall sub_14056ECD0(__int64 a1)
{
  __int64 result; // rax

  if ( qword_149C8E0F8 )
  {
    if ( qword_149C8DFE0 )
      return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DFE0 + 0x5B0LL))(qword_149C8DFE0, a1);
  }
  return result;
}

// --- End Function: sub_14056ECD0 (0x14056ECD0) ---

// --- Function: sub_14056F960 (0x14056F960) ---
char __fastcall sub_14056F960(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x56:
    case 0x57:
    case 0x58:
    case 0x59:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x42:
      n2 = 9;
      break;
    case 0x21:
    case 0x2C:
    case 0x2D:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x39:
    case 0x3A:
    case 0x3C:
    case 0x44:
    case 0x45:
    case 0x4C:
      n2 = 0x15;
      break;
    case 0x22:
    case 0x4D:
    case 0x62:
    case 0x63:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x3F:
      n2 = 0x1D;
      break;
    case 0x26:
    case 0x4A:
      n2 = 5;
      break;
    case 0x27:
      n2 = 6;
      break;
    case 0x28:
      n2 = 8;
      break;
    case 0x29:
    case 0x2A:
      n2 = 0x18;
      break;
    case 0x2B:
    case 0x2F:
    case 0x3E:
    case 0x41:
      n2 = 0x1B;
      break;
    case 0x2E:
      n2 = 0x1C;
      break;
    case 0x31:
    case 0x37:
    case 0x3B:
    case 0x40:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4F:
      n2 = 0x17;
      break;
    case 0x33:
    case 0x36:
    case 0x46:
    case 0x50:
      n2 = 0x1A;
      break;
    case 0x38:
    case 0x3D:
    case 0x51:
    case 0x52:
      n2 = 0x19;
      break;
    case 0x43:
      n2 = 0x11;
      break;
    case 0x4E:
      n2 = 0x13;
      break;
    case 0x53:
      n2 = 0x16;
      break;
    case 0x54:
    case 0x55:
      n2 = 0xA;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0x14;
      break;
    case 0x5C:
    case 0x5D:
      n2 = 0xB;
      break;
    case 0x5E:
      n2 = 0xC;
      break;
    case 0x5F:
    case 0x60:
    case 0x61:
      n2 = 0xD;
      break;
    case 0x64:
    case 0x65:
      n2 = 0xE;
      break;
    case 0x66:
      n2 = 0xF;
      break;
    case 0x67:
    case 0x68:
      n2 = 0x10;
      break;
    case 0x69:
      n2 = 0x12;
      break;
    case 0x6A:
      n2 = 0x1E;
      break;
    case 0x6B:
      n2 = 0x32;
      break;
    case 0x6C:
      n2 = 0x33;
      break;
    case 0x6D:
      n2 = 0x34;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056F960 (0x14056F960) ---

// --- Function: sub_140572030 (0x140572030) ---
__m128 sub_140572030()
{
  __int128 v0; // kr00_16

  v0 = 0;
  *(float *)&v0 = (float)(unsigned int)sub_1405722D0((__int64)&qword_149A6A5E0);
  *(float *)&v0 = *(float *)&v0 * 2.3283064e-10;
  return (__m128)v0;
}

// --- End Function: sub_140572030 (0x140572030) ---

// --- Function: sub_1405722D0 (0x1405722D0) ---
__int64 __fastcall sub_1405722D0(__int64 a1)
{
  int n0x270; // ecx
  int *v3; // r9
  __int64 n0xE3; // r10
  int v5; // edx
  int v6; // ecx
  int *v7; // r9
  __int64 n0x18C; // r10
  int v9; // edx
  int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx

  n0x270 = *(_DWORD *)(a1 + 0x9C8);
  *(_DWORD *)(a1 + 0x9C8) = n0x270 + 1;
  if ( n0x270 >= 0x270 )
  {
    if ( *(_BYTE *)a1 )
    {
      v3 = (int *)(a1 + 4);
      n0xE3 = 0xE3;
      do
      {
        v5 = *v3;
        v6 = v3[1];
        ++v3;
        v3[0xFFFFFFFF] = v3[0x18C]
                       ^ ((v6 & 1) != 0 ? 0x9908B0DF : 0)
                       ^ ((v3[0xFFFFFFFF] ^ (v6 ^ v5) & 0x7FFFFFFEu) >> 1);
        --n0xE3;
      }
      while ( n0xE3 );
      v7 = (int *)(a1 + 0x390);
      n0x18C = 0x18C;
      do
      {
        v9 = *v7;
        v10 = v7[1];
        ++v7;
        v7[0xFFFFFFFF] = v7[0xFFFFFF1C]
                       ^ ((v10 & 1) != 0 ? 0x9908B0DF : 0)
                       ^ ((v7[0xFFFFFFFF] ^ (v10 ^ v9) & 0x7FFFFFFEu) >> 1);
        --n0x18C;
      }
      while ( n0x18C );
      *(_DWORD *)(a1 + 0x9C0) = *(_DWORD *)(a1 + 0x634)
                              ^ ((*(_DWORD *)(a1 + 4) & 1) != 0 ? 0x9908B0DF : 0)
                              ^ ((*(_DWORD *)(a1 + 0x9C0) ^ (*(_DWORD *)(a1 + 4)
                                                           ^ *(_DWORD *)(a1 + 0x9C0))
                                                          & 0x7FFFFFFEu) >> 1);
    }
    *(_DWORD *)(a1 + 0x9C8) = 1;
    n0x270 = 0;
  }
  v11 = *(_DWORD *)(a1 + 4LL * n0x270 + 4);
  v12 = ((((v11 >> 0xB) ^ v11) & 0xFF3A58AD) << 7) ^ (v11 >> 0xB) ^ v11;
  return ((v12 & 0xFFFFDF8C) << 0xF) ^ v12 ^ ((((v12 & 0xFFFFDF8C) << 0xF) ^ v12) >> 0x12);
}

// --- End Function: sub_1405722D0 (0x1405722D0) ---

// --- Function: sub_140572410 (0x140572410) ---
__int64 __fastcall sub_140572410(__int64 a1, int a2)
{
  int v4; // r8d
  __int64 result; // rax
  __int64 n0x26F; // r9
  unsigned int v7; // edx
  int v8; // ecx

  memset((void *)(a1 + 4), 0, 0x9C0u);
  v4 = 1;
  *(_DWORD *)(a1 + 4) = a2;
  result = a1 + 8;
  n0x26F = 0x26F;
  do
  {
    v7 = *(_DWORD *)(result - 4);
    result += 4;
    v8 = v4 + 0x6C078965 * (*(_DWORD *)(result - 8) ^ (v7 >> 0x1E));
    ++v4;
    *(_DWORD *)(result - 4) = v8;
    --n0x26F;
  }
  while ( n0x26F );
  *(_DWORD *)(a1 + 0x9C8) = 0x270;
  return result;
}

// --- End Function: sub_140572410 (0x140572410) ---

// --- Function: sub_1405725F0 (0x1405725F0) ---
int sub_1405725F0()
{
  HMODULE hModule; // rax
  unsigned __int64 n0x104_1; // rdx
  __int64 n2; // rcx
  unsigned __int64 n0x104_2; // rax
  unsigned __int64 n0x104; // rdx
  WCHAR Filename[264]; // [rsp+20h] [rbp-228h] BYREF

  hModule = GetModuleHandleA(0);
  n0x104_1 = GetModuleFileNameW(hModule, Filename, 0x104u);
  n2 = 0;
  n0x104_2 = n0x104_1 - 1;
  if ( n0x104_1 != 1 )
  {
    do
    {
      if ( Filename[n0x104_2] == 0x5C )
      {
        n2 = (unsigned int)(n2 + 1);
        n0x104_1 = n0x104_2;
        if ( (_DWORD)n2 == 2 )
          break;
      }
      --n0x104_2;
    }
    while ( n0x104_2 );
    if ( (int)n2 > 0 )
    {
      n0x104 = n0x104_1;
      if ( n0x104 >= 0x104 )
        _report_rangecheckfailure(n2, n0x104 * 2);
      Filename[n0x104] = 0;
      LODWORD(n0x104_2) = SetCurrentDirectoryW(Filename);
    }
  }
  return n0x104_2;
}

// --- End Function: sub_1405725F0 (0x1405725F0) ---

// --- Function: sub_140572690 (0x140572690) ---
int __fastcall sub_140572690(const CHAR *lpText)
{
  return MessageBoxA(0, lpText, "Error", 0x20000u);
}

// --- End Function: sub_140572690 (0x140572690) ---

// --- Function: sub_1405726B0 (0x1405726B0) ---
void *sub_1405726B0()
{
  if ( (dword_149C88FD8 & 1) == 0 )
  {
    dword_149C88FD8 |= 1u;
    sub_14045BE00((__int64)&unk_149C88CE0, 0);
    atexit(nullsub_16);
  }
  return &unk_149C88CE0;
}

// --- End Function: sub_1405726B0 (0x1405726B0) ---

// --- Function: sub_140572750 (0x1405729FF) ---
__int64 __fastcall sub_140572750(__int64 a1, __int64 a2, void (__fastcall *a3)(void **, __int64))
{
  __int64 v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // r15
  __int64 v10; // rdx
  __int64 v11; // rbx
  __int64 v12; // rdx
  unsigned int v13; // esi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 (*ModuleFunction)(void); // rax
  const CHAR *Multiple_game_instances_are_running; // rcx
  __int64 v18; // rax
  __int64 v19; // rbx
  _QWORD *v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rcx
  _QWORD *v23; // rbx
  void *v25; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v26; // [rsp+28h] [rbp-D8h]
  __int64 v27; // [rsp+30h] [rbp-D0h]
  __int64 v28; // [rsp+38h] [rbp-C8h]
  __int64 v29; // [rsp+50h] [rbp-B0h]
  char v30; // [rsp+58h] [rbp-A8h]
  __int64 v31; // [rsp+60h] [rbp-A0h]
  int v32; // [rsp+68h] [rbp-98h]
  __int64 v33; // [rsp+6Ch] [rbp-94h]
  __int16 v34; // [rsp+74h] [rbp-8Ch]
  char v35; // [rsp+76h] [rbp-8Ah]
  __int64 v36; // [rsp+78h] [rbp-88h]
  __int128 v37; // [rsp+80h] [rbp-80h]
  __int128 v38; // [rsp+90h] [rbp-70h]
  __int128 v39; // [rsp+A0h] [rbp-60h]
  __time64_t Time; // [rsp+B0h] [rbp-50h] BYREF
  void *v41; // [rsp+B8h] [rbp-48h] BYREF
  void *v42[2]; // [rsp+C0h] [rbp-40h] BYREF
  _QWORD v43[2]; // [rsp+D0h] [rbp-30h] BYREF
  _QWORD v44[2]; // [rsp+E0h] [rbp-20h] BYREF
  _QWORD v45[2]; // [rsp+F0h] [rbp-10h] BYREF
  _QWORD v46[2]; // [rsp+100h] [rbp+0h] BYREF
  _BYTE v47[48]; // [rsp+110h] [rbp+10h] BYREF
  char v48; // [rsp+150h] [rbp+50h] BYREF
  char v49; // [rsp+160h] [rbp+60h] BYREF
  char v50; // [rsp+168h] [rbp+68h] BYREF

  sub_1405725F0();
  v6 = 0;
  v33 = 1;
  v26 = 0;
  v25 = &unk_1482B6E60;
  v27 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v34 = 0;
  v35 = 0;
  Time = 0;
  CreateStringObjectFromString(&v41, (const char *)&p_Src);
  CreateStringObjectFromString(v42, (const char *)&p_Src);
  v42[1] = (void *)0xFFFFFFFFFFFFFFFFLL;
  sub_14035E090(v43);
  _time64(&Time);
  v36 = a1;
  a3(&v25, a2);
  v7 = qword_149C84BF8;
  if ( !qword_149C84BF8 )
  {
    v8 = **((_QWORD **)&v39 + 1);
    v44[0] = &v48;
    v44[1] = sub_140422EF0;
    v7 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, const char *, _QWORD *))(v8 + 0x48))(
           *((_QWORD *)&v39 + 1),
           &qword_149C84BF8,
           "SEngineConfigStartup",
           v44);
    v44[0] = 0xFFFFFFFFFFFFFFFFuLL;
  }
  v9 = qword_149C84A58;
  if ( !qword_149C84A58 )
  {
    v10 = **((_QWORD **)&v39 + 1);
    v45[0] = &v49;
    v45[1] = sub_140422EA0;
    v9 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, const char *, _QWORD *))(v10 + 0x48))(
           *((_QWORD *)&v39 + 1),
           &qword_149C84A58,
           "SEngineConfigGame",
           v45);
    v45[0] = 0xFFFFFFFFFFFFFFFFuLL;
  }
  v11 = qword_149C88CD0;
  if ( !qword_149C88CD0 )
  {
    v12 = **((_QWORD **)&v39 + 1);
    v46[0] = &v50;
    v46[1] = sub_1405726B0;
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, const char *, _QWORD *))(v12 + 0x48))(
            *((_QWORD *)&v39 + 1),
            &qword_149C88CD0,
            "SEngineConfigLog",
            v46);
    v46[0] = 0xFFFFFFFFFFFFFFFFuLL;
  }
  v13 = 1;
  if ( **(_BYTE **)(v11 + 0x98) )
  {
    Stream = __acrt_iob_func(1u);
    freopen(*(const char **)(v11 + 0x98), "w+", Stream);
  }
  if ( **(_BYTE **)(v11 + 0xC0) )
  {
    Stream_1 = __acrt_iob_func(2u);
    freopen(*(const char **)(v11 + 0xC0), "w+", Stream_1);
  }
  ModuleFunction = getModuleFunction(*(LPCSTR *)(v9 + 0x48), "CreateGameStartup", 0);
  if ( ModuleFunction )
  {
    v18 = ModuleFunction();
    v19 = v18;
    if ( v18 )
    {
      if ( !BYTE6(v31)
        && !BYTE1(v31)
        && !*(_DWORD *)(v7 + 0x1B0)
        && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x40LL))(v18) )
      {
        if ( *(_DWORD *)(v7 + 0x48) )
          goto LABEL_27;
        Multiple_game_instances_are_running = "Multiple game instances are running!";
        goto LABEL_26;
      }
      v20 = *(_QWORD **)(*(__int64 (__fastcall **)(__int64, _BYTE *, void **))(*(_QWORD *)v19 + 8LL))(v19, v47, &v25);
      if ( v20 && *v20 )
      {
        sub_1404CAEB0((__int64 *)v39);
        (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v19 + 0x38LL))(v19, 0);
        v13 = 0;
        goto LABEL_27;
      }
    }
    if ( *(_DWORD *)(v7 + 0x48) )
      goto LABEL_27;
    Multiple_game_instances_are_running = "Failed to create the GameStartup Interface!";
  }
  else
  {
    if ( *(_DWORD *)(v7 + 0x48) )
      goto LABEL_27;
    Multiple_game_instances_are_running = "Specified Game DLL is not valid! Please make sure you are running the correct executable";
  }
LABEL_26:
  sub_140572690(Multiple_game_instances_are_running);
LABEL_27:
  sub_140373CC0(v43);
  sub_140373CC0(v42);
  sub_140373CC0(&v41);
  v21 = v28;
  if ( v28 )
  {
    v22 = (__int64)v25;
    do
    {
      if ( *(char *)(v22 + v6) >= 0 )
      {
        v23 = *(_QWORD **)(v26 + 8 * v6);
        sub_140373CC0(v23 + 2);
        sub_140373CC0(v23);
        sub_1402A6590((__int64)v23);
        v21 = v28;
        v22 = (__int64)v25;
      }
      ++v6;
    }
    while ( v6 != v21 );
    sub_1402A6590(v22);
  }
  return v13;
}

// --- End Function: sub_140572750 (0x1405729FF) ---

// --- Function: sub_140572BD0 (0x140572BD0) ---
char __fastcall sub_140572BD0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149C88FE0;
  if ( !qword_149C88FE0 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E7220("kernel32.dll", "VirtualAlloc");
    qword_149C88FE0 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_140572EA0(a3);
  return 0;
}

// --- End Function: sub_140572BD0 (0x140572BD0) ---

// --- Function: sub_140572D10 (0x140572D10) ---
__int64 __fastcall sub_140572D10(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 0x1000 )
        return 0x1000;
      if ( ++v1 == v2 )
        return 0x1000;
    }
  }
  return 0x1000;
}

// --- End Function: sub_140572D10 (0x140572D10) ---

// --- Function: sub_140572D50 (0x140572D50) ---
__int64 __fastcall sub_140572D50(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149C88FE0;
  if ( !qword_149C88FE0 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E7220("kernel32.dll", "VirtualAlloc");
    qword_149C88FE0 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_140572D50 (0x140572D50) ---

// --- Function: sub_140572EA0 (0x140572EA0) ---
// attributes: thunk
__int64 __fastcall sub_140572EA0(__int64 a1)
{
  return qword_149C8DBC0(a1);
}

// --- End Function: sub_140572EA0 (0x140572EA0) ---

// --- Function: sub_140592FE0 (0x140592FE0) ---
_QWORD *__fastcall sub_140592FE0(_QWORD *a1, int a2)
{
  _QWORD *result; // rax

  switch ( a2 )
  {
    case 1:
      sub_140361800(a1, "toggle_cursor_input");
      result = a1;
      break;
    case 2:
      sub_140361800(a1, "v_toggle_cursor_input");
      result = a1;
      break;
    case 3:
      sub_140361800(a1, "respawn");
      result = a1;
      break;
    case 4:
      sub_140361800(a1, "force_respawn");
      result = a1;
      break;
    case 5:
      sub_140361800(a1, "retry");
      result = a1;
      break;
    case 6:
      sub_140361800(a1, "ready");
      result = a1;
      break;
    case 7:
      sub_140361800(a1, "voice_chat_talk");
      result = a1;
      break;
    case 8:
      sub_140361800(a1, "pl_exit");
      result = a1;
      break;
    case 9:
      sub_140361800(a1, "mobiglas");
      result = a1;
      break;
    case 0xA:
      sub_140361800(a1, "mobiglas_close");
      result = a1;
      break;
    case 0xB:
      sub_140361800(a1, "toggle_contact");
      result = a1;
      break;
    case 0xC:
      sub_140361800(a1, "ship_recall");
      result = a1;
      break;
    case 0xD:
      sub_140361800(a1, "toggle_action_profile");
      result = a1;
      break;
    case 0xE:
      sub_140361800(a1, "view_enable_camview_mode");
      result = a1;
      break;
    case 0xF:
      sub_140361800(a1, "view_save_view_1");
      result = a1;
      break;
    case 0x10:
      sub_140361800(a1, "view_save_view_2");
      result = a1;
      break;
    case 0x11:
      sub_140361800(a1, "view_save_view_3");
      result = a1;
      break;
    case 0x12:
      sub_140361800(a1, "view_save_view_4");
      result = a1;
      break;
    case 0x13:
      sub_140361800(a1, "view_save_view_5");
      result = a1;
      break;
    case 0x14:
      sub_140361800(a1, "view_save_view_6");
      result = a1;
      break;
    case 0x15:
      sub_140361800(a1, "view_save_view_7");
      result = a1;
      break;
    case 0x16:
      sub_140361800(a1, "view_save_view_8");
      result = a1;
      break;
    case 0x17:
      sub_140361800(a1, "view_save_view_9");
      result = a1;
      break;
    case 0x18:
      sub_140361800(a1, "view_load_view_1");
      result = a1;
      break;
    case 0x19:
      sub_140361800(a1, "view_load_view_2");
      result = a1;
      break;
    case 0x1A:
      sub_140361800(a1, "view_load_view_3");
      result = a1;
      break;
    case 0x1B:
      sub_140361800(a1, "view_load_view_4");
      result = a1;
      break;
    case 0x1C:
      sub_140361800(a1, "view_load_view_5");
      result = a1;
      break;
    case 0x1D:
      sub_140361800(a1, "view_load_view_6");
      result = a1;
      break;
    case 0x1E:
      sub_140361800(a1, "view_load_view_7");
      result = a1;
      break;
    case 0x1F:
      sub_140361800(a1, "view_load_view_8");
      result = a1;
      break;
    case 0x20:
      sub_140361800(a1, "view_load_view_9");
      result = a1;
      break;
    case 0x21:
      sub_140361800(a1, "view_reset_saved");
      result = a1;
      break;
    case 0x22:
      sub_140361800(a1, "view_move_target_X_pos");
      result = a1;
      break;
    case 0x23:
      sub_140361800(a1, "view_move_target_X_neg");
      result = a1;
      break;
    case 0x24:
      sub_140361800(a1, "view_move_target_Y_pos");
      result = a1;
      break;
    case 0x25:
      sub_140361800(a1, "view_move_target_Y_neg");
      result = a1;
      break;
    case 0x26:
      sub_140361800(a1, "view_move_target_Z_pos");
      result = a1;
      break;
    case 0x27:
      sub_140361800(a1, "view_move_target_Z_neg");
      result = a1;
      break;
    case 0x28:
      sub_140361800(a1, "view_fov_in");
      result = a1;
      break;
    case 0x29:
      sub_140361800(a1, "view_fov_out");
      result = a1;
      break;
    case 0x2A:
      sub_140361800(a1, "view_fstop_in");
      result = a1;
      break;
    case 0x2B:
      sub_140361800(a1, "view_fstop_out");
      result = a1;
      break;
    case 0x2C:
      sub_140361800(a1, "view_restore_defaults");
      result = a1;
      break;
    case 0x2D:
      sub_140361800(a1, "view_switch_to_alternative");
      result = a1;
      break;
    case 0x2E:
      sub_140361800(a1, "moveleft");
      result = a1;
      break;
    case 0x2F:
      sub_140361800(a1, "moveright");
      result = a1;
      break;
    case 0x30:
      sub_140361800(a1, "moveforward");
      result = a1;
      break;
    case 0x31:
      sub_140361800(a1, "moveback");
      result = a1;
      break;
    case 0x32:
      sub_140361800(a1, "gp_movex");
      result = a1;
      break;
    case 0x33:
      sub_140361800(a1, "gp_movey");
      result = a1;
      break;
    case 0x34:
      sub_140361800(a1, "jump");
      result = a1;
      break;
    case 0x35:
      sub_140361800(a1, "jump_hold");
      result = a1;
      break;
    case 0x36:
      sub_140361800(a1, "jump_release");
      result = a1;
      break;
    case 0x37:
      sub_140361800(a1, "gp_jump");
      result = a1;
      break;
    case 0x38:
      sub_140361800(a1, "crouch");
      result = a1;
      break;
    case 0x39:
      sub_140361800(a1, "gp_crouch");
      result = a1;
      break;
    case 0x3A:
      sub_140361800(a1, "prone");
      result = a1;
      break;
    case 0x3B:
      sub_140361800(a1, "sprint");
      result = a1;
      break;
    case 0x3C:
      sub_140361800(a1, "walk");
      result = a1;
      break;
    case 0x3D:
      sub_140361800(a1, "special");
      result = a1;
      break;
    case 0x3E:
      sub_140361800(a1, "leanleft");
      result = a1;
      break;
    case 0x3F:
      sub_140361800(a1, "leanright");
      result = a1;
      break;
    case 0x40:
      sub_140361800(a1, "gp_lean");
      result = a1;
      break;
    case 0x41:
      sub_140361800(a1, "gp_leandir");
      result = a1;
      break;
    case 0x42:
      sub_140361800(a1, "visor_next_mode");
      result = a1;
      break;
    case 0x43:
      sub_140361800(a1, "visor_prev_mode");
      result = a1;
      break;
    case 0x44:
      sub_140361800(a1, "break_conversation_effects");
      result = a1;
      break;
    case 0x45:
      sub_140361800(a1, "fixed_speed_increment");
      result = a1;
      break;
    case 0x46:
      sub_140361800(a1, "fixed_speed_decrement");
      result = a1;
      break;
    case 0x47:
      sub_140361800(a1, "ledgegrab");
      result = a1;
      break;
    case 0x48:
      sub_140361800(a1, "rotateyaw");
      result = a1;
      break;
    case 0x49:
      sub_140361800(a1, "rotatepitch");
      result = a1;
      break;
    case 0x4A:
      sub_140361800(a1, "gp_rotateyaw");
      result = a1;
      break;
    case 0x4B:
      sub_140361800(a1, "gp_rotatepitch");
      result = a1;
      break;
    case 0x4C:
      sub_140361800(a1, "trackview_rotateyaw");
      result = a1;
      break;
    case 0x4D:
      sub_140361800(a1, "trackview_rotatepitch");
      result = a1;
      break;
    case 0x4E:
      sub_140361800(a1, "gp_trackview_rotateyaw");
      result = a1;
      break;
    case 0x4F:
      sub_140361800(a1, "gp_trackview_rotatepitch");
      result = a1;
      break;
    case 0x50:
      sub_140361800(a1, "hmd_rotateyaw");
      result = a1;
      break;
    case 0x51:
      sub_140361800(a1, "hmd_rotatepitch");
      result = a1;
      break;
    case 0x52:
      sub_140361800(a1, "hmd_rotateroll");
      result = a1;
      break;
    case 0x53:
      sub_140361800(a1, "spectate_gen_nextmode");
      result = a1;
      break;
    case 0x54:
      sub_140361800(a1, "spectate_gen_prevmode");
      result = a1;
      break;
    case 0x55:
      sub_140361800(a1, "spectate_gen_skipdeathcam");
      result = a1;
      break;
    case 0x56:
      sub_140361800(a1, "spectate_gen_nextcamera");
      result = a1;
      break;
    case 0x57:
      sub_140361800(a1, "spectate_next_target");
      result = a1;
      break;
    case 0x58:
      sub_140361800(a1, "spectate_prev_target");
      result = a1;
      break;
    case 0x59:
      sub_140361800(a1, "spectate_zoom");
      result = a1;
      break;
    case 0x5A:
      sub_140361800(a1, "spectate_zoom_in");
      result = a1;
      break;
    case 0x5B:
      sub_140361800(a1, "spectate_zoom_out");
      result = a1;
      break;
    case 0x5C:
      sub_140361800(a1, "spectate_rotateyaw_mouse");
      result = a1;
      break;
    case 0x5D:
      sub_140361800(a1, "spectate_rotatepitch_mouse");
      result = a1;
      break;
    case 0x5E:
      sub_140361800(a1, "spectate_rotateyaw");
      result = a1;
      break;
    case 0x5F:
      sub_140361800(a1, "spectate_rotatepitch");
      result = a1;
      break;
    case 0x60:
      sub_140361800(a1, "spectate_toggle_hud");
      result = a1;
      break;
    case 0x61:
      sub_140361800(a1, "spectate_toggle_lock_target");
      result = a1;
      break;
    case 0x62:
      sub_140361800(a1, "spectate_moveleft");
      result = a1;
      break;
    case 0x63:
      sub_140361800(a1, "spectate_moveright");
      result = a1;
      break;
    case 0x64:
      sub_140361800(a1, "spectate_moveforward");
      result = a1;
      break;
    case 0x65:
      sub_140361800(a1, "spectate_moveback");
      result = a1;
      break;
    case 0x66:
      sub_140361800(a1, "spectate_moveup");
      result = a1;
      break;
    case 0x67:
      sub_140361800(a1, "spectate_movedown");
      result = a1;
      break;
    case 0x68:
      sub_140361800(a1, "spectate_roll_left");
      result = a1;
      break;
    case 0x69:
      sub_140361800(a1, "spectate_roll_right");
      result = a1;
      break;
    case 0x6A:
      sub_140361800(a1, "spectate_freecam_sprint");
      result = a1;
      break;
    case 0x6B:
      sub_140361800(a1, "spectate_toggle_freecam");
      result = a1;
      break;
    case 0x6C:
      sub_140361800(a1, "spectate_toggle_thirdperson");
      result = a1;
      break;
    case 0x6D:
      sub_140361800(a1, "spectate_enterpuremode");
      result = a1;
      break;
    case 0x6E:
      sub_140361800(a1, "spectate_speed_increment");
      result = a1;
      break;
    case 0x6F:
      sub_140361800(a1, "spectate_speed_decrement");
      result = a1;
      break;
    case 0x70:
      sub_140361800(a1, "spectate_free_look");
      result = a1;
      break;
    case 0x71:
      sub_140361800(a1, "pl_hud_open_scoreboard");
      result = a1;
      break;
    case 0x72:
      sub_140361800(a1, "pl_hud_confirm");
      result = a1;
      break;
    case 0x73:
      sub_140361800(a1, "attack1");
      result = a1;
      break;
    case 0x74:
      sub_140361800(a1, "attackSecondary");
      result = a1;
      break;
    case 0x75:
      sub_140361800(a1, "attack1_cine");
      result = a1;
      break;
    case 0x76:
      sub_140361800(a1, "attack2_cine");
      result = a1;
      break;
    case 0x77:
      sub_140361800(a1, "weapon_melee");
      result = a1;
      break;
    case 0x78:
      sub_140361800(a1, "takedown_nonLethal");
      result = a1;
      break;
    case 0x79:
      sub_140361800(a1, "takedown_lethal");
      result = a1;
      break;
    case 0x7A:
      sub_140361800(a1, "useAttachmentBottom");
      result = a1;
      break;
    case 0x7B:
      sub_140361800(a1, "useAttachmentTop");
      result = a1;
      break;
    case 0x7C:
      sub_140361800(a1, "incapacitatedRespawn");
      result = a1;
      break;
    case 0x7D:
      sub_140361800(a1, "downedRevivalRequest");
      result = a1;
      break;
    case 0x7E:
      sub_140361800(a1, "reload");
      result = a1;
      break;
    case 0x7F:
      sub_140361800(a1, "reloadSecondary");
      result = a1;
      break;
    case 0x80:
      sub_140361800(a1, "ammoRepool");
      result = a1;
      break;
    case 0x81:
      sub_140361800(a1, "fixWeaponMisfire");
      result = a1;
      break;
    case 0x82:
      sub_140361800(a1, "selectUnarmedCombat");
      result = a1;
      break;
    case 0x83:
      sub_140361800(a1, "selectUtilityItem");
      result = a1;
      break;
    case 0x84:
      sub_140361800(a1, "select_meleeweapon_pit");
      result = a1;
      break;
    case 0x85:
      sub_140361800(a1, "select_gadget_pit");
      result = a1;
      break;
    case 0x86:
      sub_140361800(a1, "select_sidearm_pit");
      result = a1;
      break;
    case 0x87:
      sub_140361800(a1, "select_primary_pit");
      result = a1;
      break;
    case 0x88:
      sub_140361800(a1, "select_secondary_pit");
      result = a1;
      break;
    case 0x89:
      sub_140361800(a1, "nextitem");
      result = a1;
      break;
    case 0x8A:
      sub_140361800(a1, "previtem");
      result = a1;
      break;
    case 0x8B:
      sub_140361800(a1, "selectitem");
      result = a1;
      break;
    case 0x8C:
      sub_140361800(a1, "cancelselect");
      result = a1;
      break;
    case 0x8D:
      sub_140361800(a1, "nextweapon");
      result = a1;
      break;
    case 0x8E:
      sub_140361800(a1, "prevweapon");
      result = a1;
      break;
    case 0x8F:
      sub_140361800(a1, "drop");
      result = a1;
      break;
    case 0x90:
      sub_140361800(a1, "inspect");
      result = a1;
      break;
    case 0x91:
      sub_140361800(a1, "customize");
      result = a1;
      break;
    case 0x92:
      sub_140361800(a1, "carry");
      result = a1;
      break;
    case 0x93:
      sub_140361800(a1, "equip");
      result = a1;
      break;
    case 0x94:
      sub_140361800(a1, "toggleEquipHelmet");
      result = a1;
      break;
    case 0x95:
      sub_140361800(a1, "toggleAttachHelmet");
      result = a1;
      break;
    case 0x96:
      sub_140361800(a1, "toggleHelmetState");
      result = a1;
      break;
    case 0x97:
      sub_140361800(a1, "holster");
      result = a1;
      break;
    case 0x98:
      sub_140361800(a1, "stabilize");
      result = a1;
      break;
    case 0x99:
      sub_140361800(a1, "toggle_flashlight");
      result = a1;
      break;
    case 0x9A:
      sub_140361800(a1, "combathealtarget");
      result = a1;
      break;
    case 0x9B:
      sub_140361800(a1, "zoom");
      result = a1;
      break;
    case 0x9C:
      sub_140361800(a1, "weapon_change_firemode");
      result = a1;
      break;
    case 0x9D:
      sub_140361800(a1, "weapon_auxiliary_action");
      result = a1;
      break;
    case 0x9E:
      sub_140361800(a1, "weapon_zeroing_decrease");
      result = a1;
      break;
    case 0x9F:
      sub_140361800(a1, "weapon_zeroing_increase");
      result = a1;
      break;
    case 0xA0:
      sub_140361800(a1, "weapon_change_mining_throttle");
      result = a1;
      break;
    case 0xA1:
      sub_140361800(a1, "objectives");
      result = a1;
      break;
    case 0xA2:
      sub_140361800(a1, "grenade");
      result = a1;
      break;
    case 0xA3:
      sub_140361800(a1, "grenadeselect");
      result = a1;
      break;
    case 0xA4:
      sub_140361800(a1, "throw_overhand");
      result = a1;
      break;
    case 0xA5:
      sub_140361800(a1, "throw_underhand");
      result = a1;
      break;
    case 0xA6:
      sub_140361800(a1, "thirdperson");
      result = a1;
      break;
    case 0xA7:
      sub_140361800(a1, "use");
      result = a1;
      break;
    case 0xA8:
      sub_140361800(a1, "itemPickup");
      result = a1;
      break;
    case 0xA9:
      sub_140361800(a1, "zoom_toggle");
      result = a1;
      break;
    case 0xAA:
      sub_140361800(a1, "zoom_in");
      result = a1;
      break;
    case 0xAB:
      sub_140361800(a1, "zoom_out");
      result = a1;
      break;
    case 0xAC:
      sub_140361800(a1, "interact_with_scope");
      result = a1;
      break;
    case 0xAD:
      sub_140361800(a1, "toggle_lowered");
      result = a1;
      break;
    case 0xAE:
      sub_140361800(a1, "toggle_chat");
      result = a1;
      break;
    case 0xAF:
      sub_140361800(a1, "cycle_chat_lobby");
      result = a1;
      break;
    case 0xB0:
      sub_140361800(a1, "focus_on_chat_textinput");
      result = a1;
      break;
    case 0xB1:
      sub_140361800(a1, "fps_comm_open_chat");
      result = a1;
      break;
    case 0xB2:
      sub_140361800(a1, "fps_comm_open_team_chat");
      result = a1;
      break;
    case 0xB3:
      sub_140361800(a1, "toggle_ar_mode");
      result = a1;
      break;
    case 0xB4:
      sub_140361800(a1, "ar_mode_scroll_action_up");
      result = a1;
      break;
    case 0xB5:
      sub_140361800(a1, "ar_mode_scroll_action_down");
      result = a1;
      break;
    case 0xB6:
      sub_140361800(a1, "shop_camera_zoom_in");
      result = a1;
      break;
    case 0xB7:
      sub_140361800(a1, "shop_camera_zoom_out");
      result = a1;
      break;
    case 0xB8:
      sub_140361800(a1, "shop_camera_mouseyaw");
      result = a1;
      break;
    case 0xB9:
      sub_140361800(a1, "shop_camera_mousepitch");
      result = a1;
      break;
    case 0xBA:
      sub_140361800(a1, "port_modification_select");
      result = a1;
      break;
    case 0xBB:
      sub_140361800(a1, "melee_AttackLightLeft");
      result = a1;
      break;
    case 0xBC:
      sub_140361800(a1, "melee_AttackLightRight");
      result = a1;
      break;
    case 0xBD:
      sub_140361800(a1, "melee_AttackHeavyLeft");
      result = a1;
      break;
    case 0xBE:
      sub_140361800(a1, "melee_AttackHeavyRight");
      result = a1;
      break;
    case 0xBF:
      sub_140361800(a1, "melee_Block");
      result = a1;
      break;
    case 0xC0:
      sub_140361800(a1, "melee_AttackSyringeStab");
      result = a1;
      break;
    case 0xC1:
      sub_140361800(a1, "melee_dodgeLeft");
      result = a1;
      break;
    case 0xC2:
      sub_140361800(a1, "melee_dodgeRight");
      result = a1;
      break;
    case 0xC3:
      sub_140361800(a1, "melee_dodgeBack");
      result = a1;
      break;
    case 0xC4:
      sub_140361800(a1, "restrain");
      result = a1;
      break;
    case 0xC5:
      sub_140361800(a1, "consume");
      result = a1;
      break;
    case 0xC6:
      sub_140361800(a1, "visor_wipe");
      result = a1;
      break;
    case 0xC7:
      sub_140361800(a1, "dismiss_corpse_marker");
      result = a1;
      break;
    case 0xC8:
      sub_140361800(a1, "toggle_fps_scan_mode");
      result = a1;
      break;
    case 0xC9:
      sub_140361800(a1, "notification_accept");
      result = a1;
      break;
    case 0xCA:
      sub_140361800(a1, "notification_decline");
      result = a1;
      break;
    case 0xCB:
      sub_140361800(a1, "emote_agree");
      result = a1;
      break;
    case 0xCC:
      sub_140361800(a1, "emote_angry");
      result = a1;
      break;
    case 0xCD:
      sub_140361800(a1, "emote_atease");
      result = a1;
      break;
    case 0xCE:
      sub_140361800(a1, "emote_attention");
      result = a1;
      break;
    case 0xCF:
      sub_140361800(a1, "emote_blah");
      result = a1;
      break;
    case 0xD0:
      sub_140361800(a1, "emote_bored");
      result = a1;
      break;
    case 0xD1:
      sub_140361800(a1, "emote_bow");
      result = a1;
      break;
    case 0xD2:
      sub_140361800(a1, "emote_burp");
      result = a1;
      break;
    case 0xD3:
      sub_140361800(a1, "emote_cheer");
      result = a1;
      break;
    case 0xD4:
      sub_140361800(a1, "emote_chicken");
      result = a1;
      break;
    case 0xD5:
      sub_140361800(a1, "emote_clap");
      result = a1;
      break;
    case 0xD6:
      sub_140361800(a1, "emote_come");
      result = a1;
      break;
    case 0xD7:
      sub_140361800(a1, "emote_cry");
      result = a1;
      break;
    case 0xD8:
      sub_140361800(a1, "emote_dance");
      result = a1;
      break;
    case 0xD9:
      sub_140361800(a1, "emote_disagree");
      result = a1;
      break;
    case 0xDA:
      sub_140361800(a1, "emote_failure");
      result = a1;
      break;
    case 0xDB:
      sub_140361800(a1, "emote_flex");
      result = a1;
      break;
    case 0xDC:
      sub_140361800(a1, "emote_flirt");
      result = a1;
      break;
    case 0xDD:
      sub_140361800(a1, "emote_cs_forward");
      result = a1;
      break;
    case 0xDE:
      sub_140361800(a1, "emote_gasp");
      result = a1;
      break;
    case 0xDF:
      sub_140361800(a1, "emote_gloat");
      result = a1;
      break;
    case 0xE0:
      sub_140361800(a1, "emote_greet");
      result = a1;
      break;
    case 0xE1:
      sub_140361800(a1, "emote_laugh");
      result = a1;
      break;
    case 0xE2:
      sub_140361800(a1, "emote_cs_left");
      result = a1;
      break;
    case 0xE3:
      sub_140361800(a1, "emote_cs_no");
      result = a1;
      break;
    case 0xE4:
      sub_140361800(a1, "emote_point");
      result = a1;
      break;
    case 0xE5:
      sub_140361800(a1, "emote_cs_right");
      result = a1;
      break;
    case 0xE6:
      sub_140361800(a1, "emote_rude");
      result = a1;
      break;
    case 0xE7:
      sub_140361800(a1, "emote_salute");
      result = a1;
      break;
    case 0xE8:
      sub_140361800(a1, "emote_sit");
      result = a1;
      break;
    case 0xE9:
      sub_140361800(a1, "emote_sleep");
      result = a1;
      break;
    case 0xEA:
      sub_140361800(a1, "emote_smell");
      result = a1;
      break;
    case 0xEB:
      sub_140361800(a1, "emote_cs_stop");
      result = a1;
      break;
    case 0xEC:
      sub_140361800(a1, "emote_taunt");
      result = a1;
      break;
    case 0xED:
      sub_140361800(a1, "emote_threaten");
      result = a1;
      break;
    case 0xEE:
      sub_140361800(a1, "emote_wait");
      result = a1;
      break;
    case 0xEF:
      sub_140361800(a1, "emote_wave");
      result = a1;
      break;
    case 0xF0:
      sub_140361800(a1, "emote_whistle");
      result = a1;
      break;
    case 0xF1:
      sub_140361800(a1, "emote_cs_yes");
      result = a1;
      break;
    case 0xF2:
      sub_140361800(a1, "emote_launch");
      result = a1;
      break;
    case 0xF3:
      sub_140361800(a1, "flycam_movex");
      result = a1;
      break;
    case 0xF4:
      sub_140361800(a1, "flycam_movey");
      result = a1;
      break;
    case 0xF5:
      sub_140361800(a1, "flycam_movez");
      result = a1;
      break;
    case 0xF6:
      sub_140361800(a1, "flycam_moveleft");
      result = a1;
      break;
    case 0xF7:
      sub_140361800(a1, "flycam_moveright");
      result = a1;
      break;
    case 0xF8:
      sub_140361800(a1, "flycam_movefwd");
      result = a1;
      break;
    case 0xF9:
      sub_140361800(a1, "flycam_moveback");
      result = a1;
      break;
    case 0xFA:
      sub_140361800(a1, "flycam_moveup");
      result = a1;
      break;
    case 0xFB:
      sub_140361800(a1, "flycam_movedown");
      result = a1;
      break;
    case 0xFC:
      sub_140361800(a1, "flycam_speedup");
      result = a1;
      break;
    case 0xFD:
      sub_140361800(a1, "flycam_speeddown");
      result = a1;
      break;
    case 0xFE:
      sub_140361800(a1, "flycam_turbo");
      result = a1;
      break;
    case 0xFF:
      sub_140361800(a1, "flycam_rotateyaw");
      result = a1;
      break;
    case 0x100:
      sub_140361800(a1, "flycam_rotateyaw_mouse");
      result = a1;
      break;
    case 0x101:
      sub_140361800(a1, "flycam_rotatepitch");
      result = a1;
      break;
    case 0x102:
      sub_140361800(a1, "flycam_rotatepitch_mouse");
      result = a1;
      break;
    case 0x103:
      sub_140361800(a1, "flycam_setpoint");
      result = a1;
      break;
    case 0x104:
      sub_140361800(a1, "flycam_play");
      result = a1;
      break;
    case 0x105:
      sub_140361800(a1, "flycam_clear");
      result = a1;
      break;
    case 0x106:
      sub_140361800(a1, "free_thirdperson_camera");
      result = a1;
      break;
    case 0x107:
      sub_140361800(a1, "cam_toggle_cinematic");
      result = a1;
      break;
    case 0x108:
      sub_140361800(a1, "pan_thirdperson_up");
      result = a1;
      break;
    case 0x109:
      sub_140361800(a1, "pan_thirdperson_down");
      result = a1;
      break;
    case 0x10A:
      sub_140361800(a1, "toggle_opt_in_event");
      result = a1;
      break;
    case 0x10B:
      sub_140361800(a1, "eva_view_pitch_up");
      result = a1;
      break;
    case 0x10C:
      sub_140361800(a1, "eva_view_pitch_down");
      result = a1;
      break;
    case 0x10D:
      sub_140361800(a1, "eva_view_pitch");
      result = a1;
      break;
    case 0x10E:
      sub_140361800(a1, "eva_view_pitch_mouse");
      result = a1;
      break;
    case 0x10F:
      sub_140361800(a1, "eva_view_yaw_left");
      result = a1;
      break;
    case 0x110:
      sub_140361800(a1, "eva_view_yaw_right");
      result = a1;
      break;
    case 0x111:
      sub_140361800(a1, "eva_view_yaw");
      result = a1;
      break;
    case 0x112:
      sub_140361800(a1, "eva_view_yaw_mouse");
      result = a1;
      break;
    case 0x113:
      sub_140361800(a1, "eva_toggle_headlook_mode");
      result = a1;
      break;
    case 0x114:
      sub_140361800(a1, "eva_roll_left");
      result = a1;
      break;
    case 0x115:
      sub_140361800(a1, "eva_roll_right");
      result = a1;
      break;
    case 0x116:
      sub_140361800(a1, "eva_roll");
      result = a1;
      break;
    case 0x117:
      sub_140361800(a1, "eva_strafe_forward");
      result = a1;
      break;
    case 0x118:
      sub_140361800(a1, "eva_strafe_back");
      result = a1;
      break;
    case 0x119:
      sub_140361800(a1, "eva_strafe_longitudinal");
      result = a1;
      break;
    case 0x11A:
      sub_140361800(a1, "eva_strafe_left");
      result = a1;
      break;
    case 0x11B:
      sub_140361800(a1, "eva_strafe_right");
      result = a1;
      break;
    case 0x11C:
      sub_140361800(a1, "eva_strafe_lateral");
      result = a1;
      break;
    case 0x11D:
      sub_140361800(a1, "eva_strafe_up");
      result = a1;
      break;
    case 0x11E:
      sub_140361800(a1, "eva_strafe_down");
      result = a1;
      break;
    case 0x11F:
      sub_140361800(a1, "eva_strafe_vertical");
      result = a1;
      break;
    case 0x120:
      sub_140361800(a1, "eva_brake");
      result = a1;
      break;
    case 0x121:
      sub_140361800(a1, "eva_boost");
      result = a1;
      break;
    case 0x122:
      sub_140361800(a1, "eva_zgt_attach");
      result = a1;
      break;
    case 0x123:
      sub_140361800(a1, "eva_zgt_quick_attach");
      result = a1;
      break;
    case 0x124:
      sub_140361800(a1, "zgt_launch");
      result = a1;
      break;
    case 0x125:
      sub_140361800(a1, "zgt_detach");
      result = a1;
      break;
    case 0x126:
      sub_140361800(a1, "zgt_roll_left");
      result = a1;
      break;
    case 0x127:
      sub_140361800(a1, "zgt_roll_right");
      result = a1;
      break;
    case 0x128:
      sub_140361800(a1, "v_view_freelook_mode");
      result = a1;
      break;
    case 0x129:
      sub_140361800(a1, "v_view_yaw_right");
      result = a1;
      break;
    case 0x12A:
      sub_140361800(a1, "v_view_yaw_left");
      result = a1;
      break;
    case 0x12B:
      sub_140361800(a1, "v_view_yaw");
      result = a1;
      break;
    case 0x12C:
      sub_140361800(a1, "v_view_yaw_mouse");
      result = a1;
      break;
    case 0x12D:
      sub_140361800(a1, "v_view_yaw_absolute");
      result = a1;
      break;
    case 0x12E:
      sub_140361800(a1, "v_view_pitch_up");
      result = a1;
      break;
    case 0x12F:
      sub_140361800(a1, "v_view_pitch_down");
      result = a1;
      break;
    case 0x130:
      sub_140361800(a1, "v_view_pitch");
      result = a1;
      break;
    case 0x131:
      sub_140361800(a1, "v_view_pitch_mouse");
      result = a1;
      break;
    case 0x132:
      sub_140361800(a1, "v_view_pitch_absolute");
      result = a1;
      break;
    case 0x133:
      sub_140361800(a1, "v_view_roll_absolute");
      result = a1;
      break;
    case 0x134:
      sub_140361800(a1, "v_view_interact");
      result = a1;
      break;
    case 0x135:
      sub_140361800(a1, "v_view_cycle_fwd");
      result = a1;
      break;
    case 0x136:
      sub_140361800(a1, "v_view_option");
      result = a1;
      break;
    case 0x137:
      sub_140361800(a1, "v_view_zoom_in");
      result = a1;
      break;
    case 0x138:
      sub_140361800(a1, "v_view_zoom_out");
      result = a1;
      break;
    case 0x139:
      sub_140361800(a1, "v_view_dynamic_zoom_rel");
      result = a1;
      break;
    case 0x13A:
      sub_140361800(a1, "v_view_dynamic_zoom_rel_in");
      result = a1;
      break;
    case 0x13B:
      sub_140361800(a1, "v_view_dynamic_zoom_rel_out");
      result = a1;
      break;
    case 0x13C:
      sub_140361800(a1, "v_view_dynamic_zoom_abs");
      result = a1;
      break;
    case 0x13D:
      sub_140361800(a1, "v_view_dynamic_zoom_abs_toggle");
      result = a1;
      break;
    case 0x13E:
      sub_140361800(a1, "v_view_dynamic_zoom_aim");
      result = a1;
      break;
    case 0x13F:
      sub_140361800(a1, "v_view_turret_dynamic_zoom");
      result = a1;
      break;
    case 0x140:
      sub_140361800(a1, "v_view_look_behind");
      result = a1;
      break;
    case 0x141:
      sub_140361800(a1, "v_debug_target_view");
      result = a1;
      break;
    case 0x142:
      sub_140361800(a1, "v_attack_all");
      result = a1;
      break;
    case 0x143:
      sub_140361800(a1, "v_attack_group1");
      result = a1;
      break;
    case 0x144:
      sub_140361800(a1, "v_attack_group2");
      result = a1;
      break;
    case 0x145:
      sub_140361800(a1, "v_weapon_reload");
      result = a1;
      break;
    case 0x146:
      sub_140361800(a1, "v_weapon_preset_attack");
      result = a1;
      break;
    case 0x147:
      sub_140361800(a1, "v_weapon_preset_fire_guns0");
      result = a1;
      break;
    case 0x148:
      sub_140361800(a1, "v_weapon_preset_fire_guns1");
      result = a1;
      break;
    case 0x149:
      sub_140361800(a1, "v_weapon_preset_fire_guns2");
      result = a1;
      break;
    case 0x14A:
      sub_140361800(a1, "v_weapon_preset_fire_guns3");
      result = a1;
      break;
    case 0x14B:
      sub_140361800(a1, "v_weapon_preset_next");
      result = a1;
      break;
    case 0x14C:
      sub_140361800(a1, "v_weapon_preset_prev");
      result = a1;
      break;
    case 0x14D:
      sub_140361800(a1, "v_weapon_preset_next_overflow");
      result = a1;
      break;
    case 0x14E:
      sub_140361800(a1, "v_weapon_preset_prev_overflow");
      result = a1;
      break;
    case 0x14F:
      sub_140361800(a1, "v_weapon_preset_guns0");
      result = a1;
      break;
    case 0x150:
      sub_140361800(a1, "v_weapon_preset_guns1");
      result = a1;
      break;
    case 0x151:
      sub_140361800(a1, "v_weapon_preset_guns2");
      result = a1;
      break;
    case 0x152:
      sub_140361800(a1, "v_weapon_preset_guns3");
      result = a1;
      break;
    case 0x153:
      sub_140361800(a1, "v_weapon_preset_emp");
      result = a1;
      break;
    case 0x154:
      sub_140361800(a1, "v_weapon_preset_qid_jammer");
      result = a1;
      break;
    case 0x155:
      sub_140361800(a1, "v_weapon_preset_qid_pulse");
      result = a1;
      break;
    case 0x156:
      sub_140361800(a1, "v_weapon_preset_qid");
      result = a1;
      break;
    case 0x157:
      sub_140361800(a1, "v_lights");
      result = a1;
      break;
    case 0x158:
      sub_140361800(a1, "v_lights_on");
      result = a1;
      break;
    case 0x159:
      sub_140361800(a1, "v_lights_off");
      result = a1;
      break;
    case 0x15A:
      sub_140361800(a1, "v_horn");
      result = a1;
      break;
    case 0x15B:
      sub_140361800(a1, "v_toggle_vtol");
      result = a1;
      break;
    case 0x15C:
      sub_140361800(a1, "v_transform_deploy");
      result = a1;
      break;
    case 0x15D:
      sub_140361800(a1, "v_transform_retract");
      result = a1;
      break;
    case 0x15E:
      sub_140361800(a1, "v_transform_cycle");
      result = a1;
      break;
    case 0x15F:
      sub_140361800(a1, "v_emergency_exit");
      result = a1;
      break;
    case 0x160:
      sub_140361800(a1, "v_flightready");
      result = a1;
      break;
    case 0x161:
      sub_140361800(a1, "v_toggle_all_doors");
      result = a1;
      break;
    case 0x162:
      sub_140361800(a1, "v_open_all_doors");
      result = a1;
      break;
    case 0x163:
      sub_140361800(a1, "v_close_all_doors");
      result = a1;
      break;
    case 0x164:
      sub_140361800(a1, "v_toggle_all_doorlocks");
      result = a1;
      break;
    case 0x165:
      sub_140361800(a1, "v_lock_all_doors");
      result = a1;
      break;
    case 0x166:
      sub_140361800(a1, "v_unlock_all_doors");
      result = a1;
      break;
    case 0x167:
      sub_140361800(a1, "v_toggle_all_portlocks");
      result = a1;
      break;
    case 0x168:
      sub_140361800(a1, "v_lock_all_ports");
      result = a1;
      break;
    case 0x169:
      sub_140361800(a1, "v_unlock_all_ports");
      result = a1;
      break;
    case 0x16A:
      sub_140361800(a1, "v_mgv_switch_brake_on_idle");
      result = a1;
      break;
    case 0x16B:
      sub_140361800(a1, "v_yaw_left");
      result = a1;
      break;
    case 0x16C:
      sub_140361800(a1, "v_yaw_right");
      result = a1;
      break;
    case 0x16D:
      sub_140361800(a1, "v_yaw");
      result = a1;
      break;
    case 0x16E:
      sub_140361800(a1, "v_yaw_mouse");
      result = a1;
      break;
    case 0x16F:
      sub_140361800(a1, "v_move_forward");
      result = a1;
      break;
    case 0x170:
      sub_140361800(a1, "v_move_back");
      result = a1;
      break;
    case 0x171:
      sub_140361800(a1, "v_move");
      result = a1;
      break;
    case 0x172:
      sub_140361800(a1, "v_brake");
      result = a1;
      break;
    case 0x173:
      sub_140361800(a1, "v_boost");
      result = a1;
      break;
    case 0x174:
      sub_140361800(a1, "v_target_lock_selected");
      result = a1;
      break;
    case 0x175:
      sub_140361800(a1, "v_target_unlock_selected");
      result = a1;
      break;
    case 0x176:
      sub_140361800(a1, "v_target_unlock");
      result = a1;
      break;
    case 0x177:
      sub_140361800(a1, "v_target_pin_selected");
      result = a1;
      break;
    case 0x178:
      sub_140361800(a1, "v_target_unpin_selected");
      result = a1;
      break;
    case 0x179:
      sub_140361800(a1, "v_target_pin_selected_hold");
      result = a1;
      break;
    case 0x17A:
      sub_140361800(a1, "v_target_unpin_selected_hold");
      result = a1;
      break;
    case 0x17B:
      sub_140361800(a1, "v_target_cycle_pinned_fwd");
      result = a1;
      break;
    case 0x17C:
      sub_140361800(a1, "v_target_cycle_pinned_back");
      result = a1;
      break;
    case 0x17D:
      sub_140361800(a1, "v_target_cycle_pinned_reset");
      result = a1;
      break;
    case 0x17E:
      sub_140361800(a1, "v_target_toggle_lock_index_1");
      result = a1;
      break;
    case 0x17F:
      sub_140361800(a1, "v_target_toggle_lock_index_2");
      result = a1;
      break;
    case 0x180:
      sub_140361800(a1, "v_target_toggle_lock_index_3");
      result = a1;
      break;
    case 0x181:
      sub_140361800(a1, "v_target_toggle_pin_index_1");
      result = a1;
      break;
    case 0x182:
      sub_140361800(a1, "v_target_toggle_pin_index_2");
      result = a1;
      break;
    case 0x183:
      sub_140361800(a1, "v_target_toggle_pin_index_3");
      result = a1;
      break;
    case 0x184:
      sub_140361800(a1, "v_target_toggle_pin_index_1_hold");
      result = a1;
      break;
    case 0x185:
      sub_140361800(a1, "v_target_toggle_pin_index_2_hold");
      result = a1;
      break;
    case 0x186:
      sub_140361800(a1, "v_target_toggle_pin_index_3_hold");
      result = a1;
      break;
    case 0x187:
      sub_140361800(a1, "v_target_remove_all_pins");
      result = a1;
      break;
    case 0x188:
      sub_140361800(a1, "v_auto_targeting_swap_full_lock_long");
      result = a1;
      break;
    case 0x189:
      sub_140361800(a1, "v_auto_targeting_swap_full_lock_short");
      result = a1;
      break;
    case 0x18A:
      sub_140361800(a1, "v_auto_targeting_toggle_short");
      result = a1;
      break;
    case 0x18B:
      sub_140361800(a1, "v_auto_targeting_toggle_long");
      result = a1;
      break;
    case 0x18C:
      sub_140361800(a1, "v_auto_targeting_enable_short");
      result = a1;
      break;
    case 0x18D:
      sub_140361800(a1, "v_auto_targeting_enable_long");
      result = a1;
      break;
    case 0x18E:
      sub_140361800(a1, "v_auto_targeting_disable_short");
      result = a1;
      break;
    case 0x18F:
      sub_140361800(a1, "v_auto_targeting_disable_long");
      result = a1;
      break;
    case 0x190:
      sub_140361800(a1, "v_auto_targeting_cycle_in_view_back");
      result = a1;
      break;
    case 0x191:
      sub_140361800(a1, "v_auto_targeting_cycle_in_view_fwd");
      result = a1;
      break;
    case 0x192:
      sub_140361800(a1, "v_target_under_reticle");
      result = a1;
      break;
    case 0x193:
      sub_140361800(a1, "v_target_cycle_selection_legacy_fwd");
      result = a1;
      break;
    case 0x194:
      sub_140361800(a1, "v_target_cycle_selection_legacy_back");
      result = a1;
      break;
    case 0x195:
      sub_140361800(a1, "v_target_cycle_selection_legacy_reset");
      result = a1;
      break;
    case 0x196:
      sub_140361800(a1, "v_target_cycle_in_view_fwd");
      result = a1;
      break;
    case 0x197:
      sub_140361800(a1, "v_target_cycle_in_view_back");
      result = a1;
      break;
    case 0x198:
      sub_140361800(a1, "v_target_cycle_in_view_reset");
      result = a1;
      break;
    case 0x199:
      sub_140361800(a1, "v_target_cycle_attacker_fwd");
      result = a1;
      break;
    case 0x19A:
      sub_140361800(a1, "v_target_cycle_attacker_back");
      result = a1;
      break;
    case 0x19B:
      sub_140361800(a1, "v_target_cycle_attacker_reset");
      result = a1;
      break;
    case 0x19C:
      sub_140361800(a1, "v_target_cycle_hostile_fwd");
      result = a1;
      break;
    case 0x19D:
      sub_140361800(a1, "v_target_cycle_hostile_back");
      result = a1;
      break;
    case 0x19E:
      sub_140361800(a1, "v_target_cycle_hostile_reset");
      result = a1;
      break;
    case 0x19F:
      sub_140361800(a1, "v_target_cycle_hostile_in_view_fwd");
      result = a1;
      break;
    case 0x1A0:
      sub_140361800(a1, "v_target_cycle_hostile_in_view_back");
      result = a1;
      break;
    case 0x1A1:
      sub_140361800(a1, "v_target_cycle_hostile_in_view_reset");
      result = a1;
      break;
    case 0x1A2:
      sub_140361800(a1, "v_target_cycle_friendly_fwd");
      result = a1;
      break;
    case 0x1A3:
      sub_140361800(a1, "v_target_cycle_friendly_back");
      result = a1;
      break;
    case 0x1A4:
      sub_140361800(a1, "v_target_cycle_friendly_reset");
      result = a1;
      break;
    case 0x1A5:
      sub_140361800(a1, "v_target_cycle_all_fwd");
      result = a1;
      break;
    case 0x1A6:
      sub_140361800(a1, "v_target_cycle_all_back");
      result = a1;
      break;
    case 0x1A7:
      sub_140361800(a1, "v_target_cycle_all_reset");
      result = a1;
      break;
    case 0x1A8:
      sub_140361800(a1, "v_target_cycle_subitem_fwd");
      result = a1;
      break;
    case 0x1A9:
      sub_140361800(a1, "v_target_cycle_subitem_back");
      result = a1;
      break;
    case 0x1AA:
      sub_140361800(a1, "v_target_cycle_subitem_reset");
      result = a1;
      break;
    case 0x1AB:
      sub_140361800(a1, "v_target_cycle_subitem_category_fwd");
      result = a1;
      break;
    case 0x1AC:
      sub_140361800(a1, "v_target_cycle_subitem_category_back");
      result = a1;
      break;
    case 0x1AD:
      sub_140361800(a1, "v_enter_remote_turret_1");
      result = a1;
      break;
    case 0x1AE:
      sub_140361800(a1, "v_enter_remote_turret_2");
      result = a1;
      break;
    case 0x1AF:
      sub_140361800(a1, "v_enter_remote_turret_3");
      result = a1;
      break;
    case 0x1B0:
      sub_140361800(a1, "v_look_ahead_enable");
      result = a1;
      break;
    case 0x1B1:
      sub_140361800(a1, "v_look_ahead_start_target_tracking");
      result = a1;
      break;
    case 0x1B2:
      sub_140361800(a1, "v_target_tracking_auto_zoom");
      result = a1;
      break;
    case 0x1B3:
      sub_140361800(a1, "v_target_set_qt_destination_focused");
      result = a1;
      break;
    case 0x1B4:
      sub_140361800(a1, "v_target_unset_qt_destination");
      result = a1;
      break;
    case 0x1B5:
      sub_140361800(a1, "v_target_hail");
      result = a1;
      break;
    case 0x1B6:
      sub_140361800(a1, "v_ifcs_speed_limiter_up");
      result = a1;
      break;
    case 0x1B7:
      sub_140361800(a1, "v_ifcs_speed_limiter_down");
      result = a1;
      break;
    case 0x1B8:
      sub_140361800(a1, "v_ifcs_speed_limiter_increment");
      result = a1;
      break;
    case 0x1B9:
      sub_140361800(a1, "v_ifcs_speed_limiter_decrement");
      result = a1;
      break;
    case 0x1BA:
      sub_140361800(a1, "v_ifcs_speed_limiter_rel");
      result = a1;
      break;
    case 0x1BB:
      sub_140361800(a1, "v_ifcs_speed_limiter_abs");
      result = a1;
      break;
    case 0x1BC:
      sub_140361800(a1, "v_ifcs_speed_limiter_toggle");
      result = a1;
      break;
    case 0x1BD:
      sub_140361800(a1, "v_ifcs_speed_limiter_on");
      result = a1;
      break;
    case 0x1BE:
      sub_140361800(a1, "v_ifcs_speed_limiter_off");
      result = a1;
      break;
    case 0x1BF:
      sub_140361800(a1, "v_accel_range_up");
      result = a1;
      break;
    case 0x1C0:
      sub_140361800(a1, "v_accel_range_down");
      result = a1;
      break;
    case 0x1C1:
      sub_140361800(a1, "v_accel_range_increment");
      result = a1;
      break;
    case 0x1C2:
      sub_140361800(a1, "v_accel_range_decrement");
      result = a1;
      break;
    case 0x1C3:
      sub_140361800(a1, "v_accel_range_abs");
      result = a1;
      break;
    case 0x1C4:
      sub_140361800(a1, "v_accel_range_rel");
      result = a1;
      break;
    case 0x1C5:
      sub_140361800(a1, "v_pitch_up");
      result = a1;
      break;
    case 0x1C6:
      sub_140361800(a1, "v_pitch_down");
      result = a1;
      break;
    case 0x1C7:
      sub_140361800(a1, "v_pitch");
      result = a1;
      break;
    case 0x1C8:
      sub_140361800(a1, "v_pitch_mouse");
      result = a1;
      break;
    case 0x1C9:
      sub_140361800(a1, "v_roll_left");
      result = a1;
      break;
    case 0x1CA:
      sub_140361800(a1, "v_roll_right");
      result = a1;
      break;
    case 0x1CB:
      sub_140361800(a1, "v_roll");
      result = a1;
      break;
    case 0x1CC:
      sub_140361800(a1, "v_roll_mouse");
      result = a1;
      break;
    case 0x1CD:
      sub_140361800(a1, "v_toggle_yaw_roll_swap");
      result = a1;
      break;
    case 0x1CE:
      sub_140361800(a1, "v_strafe_longitudinal_invert");
      result = a1;
      break;
    case 0x1CF:
      sub_140361800(a1, "v_strafe_forward");
      result = a1;
      break;
    case 0x1D0:
      sub_140361800(a1, "v_strafe_back");
      result = a1;
      break;
    case 0x1D1:
      sub_140361800(a1, "v_strafe_longitudinal");
      result = a1;
      break;
    case 0x1D2:
      sub_140361800(a1, "v_strafe_trim_set_long");
      result = a1;
      break;
    case 0x1D3:
      sub_140361800(a1, "v_strafe_trim_set_short");
      result = a1;
      break;
    case 0x1D4:
      sub_140361800(a1, "v_strafe_trim_set_50_long");
      result = a1;
      break;
    case 0x1D5:
      sub_140361800(a1, "v_strafe_trim_set_50_short");
      result = a1;
      break;
    case 0x1D6:
      sub_140361800(a1, "v_strafe_trim_set_100_long");
      result = a1;
      break;
    case 0x1D7:
      sub_140361800(a1, "v_strafe_trim_set_100_short");
      result = a1;
      break;
    case 0x1D8:
      sub_140361800(a1, "v_strafe_trim_reset_long");
      result = a1;
      break;
    case 0x1D9:
      sub_140361800(a1, "v_strafe_trim_reset_short");
      result = a1;
      break;
    case 0x1DA:
      sub_140361800(a1, "v_strafe_left");
      result = a1;
      break;
    case 0x1DB:
      sub_140361800(a1, "v_strafe_right");
      result = a1;
      break;
    case 0x1DC:
      sub_140361800(a1, "v_strafe_lateral");
      result = a1;
      break;
    case 0x1DD:
      sub_140361800(a1, "v_strafe_up");
      result = a1;
      break;
    case 0x1DE:
      sub_140361800(a1, "v_strafe_down");
      result = a1;
      break;
    case 0x1DF:
      sub_140361800(a1, "v_strafe_vertical");
      result = a1;
      break;
    case 0x1E0:
      sub_140361800(a1, "v_ifcs_throttle_swap_mode");
      result = a1;
      break;
    case 0x1E1:
      sub_140361800(a1, "v_ifcs_throttle_set_sticky");
      result = a1;
      break;
    case 0x1E2:
      sub_140361800(a1, "v_ifcs_throttle_set_normal");
      result = a1;
      break;
    case 0x1E3:
      sub_140361800(a1, "v_lock_rotation");
      result = a1;
      break;
    case 0x1E4:
      sub_140361800(a1, "v_space_brake");
      result = a1;
      break;
    case 0x1E5:
      sub_140361800(a1, "ulammo");
      result = a1;
      break;
    case 0x1E6:
      sub_140361800(a1, "v_use_docking");
      result = a1;
      break;
    case 0x1E7:
      sub_140361800(a1, "v_gforce_save");
      result = a1;
      break;
    case 0x1E8:
      sub_140361800(a1, "v_gforce_lock");
      result = a1;
      break;
    case 0x1E9:
      sub_140361800(a1, "v_gforce_movex");
      result = a1;
      break;
    case 0x1EA:
      sub_140361800(a1, "v_gforce_movey");
      result = a1;
      break;
    case 0x1EB:
      sub_140361800(a1, "v_gforce_toggle");
      result = a1;
      break;
    case 0x1EC:
      sub_140361800(a1, "v_gforce_mag_up");
      result = a1;
      break;
    case 0x1ED:
      sub_140361800(a1, "v_gforce_mag_down");
      result = a1;
      break;
    case 0x1EE:
      sub_140361800(a1, "v_gforce_body_toggle");
      result = a1;
      break;
    case 0x1EF:
      sub_140361800(a1, "v_gforce_head_toggle");
      result = a1;
      break;
    case 0x1F0:
      sub_140361800(a1, "v_gforce_toggle_menu");
      result = a1;
      break;
    case 0x1F1:
      sub_140361800(a1, "v_gforce_menu_down");
      result = a1;
      break;
    case 0x1F2:
      sub_140361800(a1, "v_gforce_menu_up");
      result = a1;
      break;
    case 0x1F3:
      sub_140361800(a1, "v_gforce_param_inc");
      result = a1;
      break;
    case 0x1F4:
      sub_140361800(a1, "v_gforce_parem_dec");
      result = a1;
      break;
    case 0x1F5:
      sub_140361800(a1, "v_ifcs_a");
      result = a1;
      break;
    case 0x1F6:
      sub_140361800(a1, "v_ifcs_b");
      result = a1;
      break;
    case 0x1F7:
      sub_140361800(a1, "v_ifcs_x");
      result = a1;
      break;
    case 0x1F8:
      sub_140361800(a1, "v_ifcs_y");
      result = a1;
      break;
    case 0x1F9:
      sub_140361800(a1, "v_toggle_cabin_lights");
      result = a1;
      break;
    case 0x1FA:
      sub_140361800(a1, "v_toggle_running_lights");
      result = a1;
      break;
    case 0x1FB:
      sub_140361800(a1, "v_ifcs_gsafe_on");
      result = a1;
      break;
    case 0x1FC:
      sub_140361800(a1, "v_ifcs_gsafe_off");
      result = a1;
      break;
    case 0x1FD:
      sub_140361800(a1, "v_ifcs_toggle_gforce_safety");
      result = a1;
      break;
    case 0x1FE:
      sub_140361800(a1, "v_ifcs_toggle_vector_decoupling");
      result = a1;
      break;
    case 0x1FF:
      sub_140361800(a1, "v_ifcs_hold_vector_decoupling");
      result = a1;
      break;
    case 0x200:
      sub_140361800(a1, "v_auto_precision_mode_toggle");
      result = a1;
      break;
    case 0x201:
      sub_140361800(a1, "v_auto_precision_mode_on");
      result = a1;
      break;
    case 0x202:
      sub_140361800(a1, "v_auto_precision_mode_off");
      result = a1;
      break;
    case 0x203:
      sub_140361800(a1, "v_ifcs_toggle_gravity_compensation");
      result = a1;
      break;
    case 0x204:
      sub_140361800(a1, "v_ifcs_gravity_compensation_on");
      result = a1;
      break;
    case 0x205:
      sub_140361800(a1, "v_ifcs_gravity_compensation_off");
      result = a1;
      break;
    case 0x206:
      sub_140361800(a1, "v_ifcs_proximity_assist_toggle");
      result = a1;
      break;
    case 0x207:
      sub_140361800(a1, "v_ifcs_proximity_assist_on");
      result = a1;
      break;
    case 0x208:
      sub_140361800(a1, "v_ifcs_proximity_assist_off");
      result = a1;
      break;
    case 0x209:
      sub_140361800(a1, "v_ifcs_stability_toggle");
      result = a1;
      break;
    case 0x20A:
      sub_140361800(a1, "v_ifcs_stability_on");
      result = a1;
      break;
    case 0x20B:
      sub_140361800(a1, "v_ifcs_stability_off");
      result = a1;
      break;
    case 0x20C:
      sub_140361800(a1, "v_ifcs_core_toggle");
      result = a1;
      break;
    case 0x20D:
      sub_140361800(a1, "v_ifcs_core_on");
      result = a1;
      break;
    case 0x20E:
      sub_140361800(a1, "v_ifcs_core_off");
      result = a1;
      break;
    case 0x20F:
      sub_140361800(a1, "v_ifcs_toggle_control_surface_mode");
      result = a1;
      break;
    case 0x210:
      sub_140361800(a1, "v_ifcs_toggle_esp");
      result = a1;
      break;
    case 0x211:
      sub_140361800(a1, "v_ifcs_esp_hold");
      result = a1;
      break;
    case 0x212:
      sub_140361800(a1, "v_ifcs_thrusters_disconnect_hold");
      result = a1;
      break;
    case 0x213:
      sub_140361800(a1, "v_eject");
      result = a1;
      break;
    case 0x214:
      sub_140361800(a1, "v_eject_cinematic");
      result = a1;
      break;
    case 0x215:
      sub_140361800(a1, "v_self_destruct");
      result = a1;
      break;
    case 0x216:
      sub_140361800(a1, "v_starmap");
      result = a1;
      break;
    case 0x217:
      sub_140361800(a1, "v_hud_vjoy_cycle");
      result = a1;
      break;
    case 0x218:
      sub_140361800(a1, "v_toggle_missile_mode");
      result = a1;
      break;
    case 0x219:
      sub_140361800(a1, "v_set_missile_mode");
      result = a1;
      break;
    case 0x21A:
      sub_140361800(a1, "v_toggle_guns_mode");
      result = a1;
      break;
    case 0x21B:
      sub_140361800(a1, "v_set_guns_mode");
      result = a1;
      break;
    case 0x21C:
      sub_140361800(a1, "v_toggle_flight_mode");
      result = a1;
      break;
    case 0x21D:
      sub_140361800(a1, "v_set_flight_mode");
      result = a1;
      break;
    case 0x21E:
      sub_140361800(a1, "v_operator_mode_cycle_forward");
      result = a1;
      break;
    case 0x21F:
      sub_140361800(a1, "v_operator_mode_cycle_back");
      result = a1;
      break;
    case 0x220:
      sub_140361800(a1, "v_ifcs_reset_gmeter_max");
      result = a1;
      break;
    case 0x221:
      sub_140361800(a1, "v_flight_advanced_hud_toggle");
      result = a1;
      break;
    case 0x222:
      sub_140361800(a1, "v_flight_advanced_hud_on");
      result = a1;
      break;
    case 0x223:
      sub_140361800(a1, "v_flight_advanced_hud_off");
      result = a1;
      break;
    case 0x224:
      sub_140361800(a1, "v_ads_hold");
      result = a1;
      break;
    case 0x225:
      sub_140361800(a1, "v_ads_toggle");
      result = a1;
      break;
    case 0x226:
      sub_140361800(a1, "v_ads_stable_max_zoom_hold");
      result = a1;
      break;
    case 0x227:
      sub_140361800(a1, "v_ads_cycle_tracking");
      result = a1;
      break;
    case 0x228:
      sub_140361800(a1, "v_view_cycle_internal_fwd");
      result = a1;
      break;
    case 0x229:
      sub_140361800(a1, "v_view_mode");
      result = a1;
      break;
    case 0x22A:
      sub_140361800(a1, "v_afterburner");
      result = a1;
      break;
    case 0x22B:
      sub_140361800(a1, "v_toggle_relative_mouse_mode");
      result = a1;
      break;
    case 0x22C:
      sub_140361800(a1, "v_toggle_quantum_mode");
      result = a1;
      break;
    case 0x22D:
      sub_140361800(a1, "v_set_quantum_mode");
      result = a1;
      break;
    case 0x22E:
      sub_140361800(a1, "v_toggle_jump_request");
      result = a1;
      break;
    case 0x22F:
      sub_140361800(a1, "v_dock_toggle_view");
      result = a1;
      break;
    case 0x230:
      sub_140361800(a1, "v_master_mode_cycle");
      result = a1;
      break;
    case 0x231:
      sub_140361800(a1, "v_master_mode_cycle_long");
      result = a1;
      break;
    case 0x232:
      sub_140361800(a1, "v_master_mode_set_nav");
      result = a1;
      break;
    case 0x233:
      sub_140361800(a1, "v_master_mode_set_scm");
      result = a1;
      break;
    case 0x234:
      sub_140361800(a1, "v_enter_formation_flying_mode");
      result = a1;
      break;
    case 0x235:
      sub_140361800(a1, "v_toggle_qdrive_engagement");
      result = a1;
      break;
    case 0x236:
      sub_140361800(a1, "v_exit_quantum_travel");
      result = a1;
      break;
    case 0x237:
      sub_140361800(a1, "v_clear_qdrive_target");
      result = a1;
      break;
    case 0x238:
      sub_140361800(a1, "v_quantum_boost_hold");
      result = a1;
      break;
    case 0x239:
      sub_140361800(a1, "v_quantum_boost_long");
      result = a1;
      break;
    case 0x23A:
      sub_140361800(a1, "v_toggle_docking_mode");
      result = a1;
      break;
    case 0x23B:
      sub_140361800(a1, "v_invoke_docking");
      result = a1;
      break;
    case 0x23C:
      sub_140361800(a1, "v_aim_yaw_mouse");
      result = a1;
      break;
    case 0x23D:
      sub_140361800(a1, "v_aim_yaw");
      result = a1;
      break;
    case 0x23E:
      sub_140361800(a1, "v_aim_yaw_right");
      result = a1;
      break;
    case 0x23F:
      sub_140361800(a1, "v_aim_yaw_left");
      result = a1;
      break;
    case 0x240:
      sub_140361800(a1, "v_aim_pitch_mouse");
      result = a1;
      break;
    case 0x241:
      sub_140361800(a1, "v_aim_pitch");
      result = a1;
      break;
    case 0x242:
      sub_140361800(a1, "v_aim_pitch_up");
      result = a1;
      break;
    case 0x243:
      sub_140361800(a1, "v_aim_pitch_down");
      result = a1;
      break;
    case 0x244:
      sub_140361800(a1, "v_aim_snap");
      result = a1;
      break;
    case 0x245:
      sub_140361800(a1, "v_weapon_cycle_missile_fwd");
      result = a1;
      break;
    case 0x246:
      sub_140361800(a1, "v_weapon_cycle_missile_back");
      result = a1;
      break;
    case 0x247:
      sub_140361800(a1, "v_weapon_increase_max_missiles");
      result = a1;
      break;
    case 0x248:
      sub_140361800(a1, "v_weapon_decrease_max_missiles");
      result = a1;
      break;
    case 0x249:
      sub_140361800(a1, "v_weapon_reset_max_missiles");
      result = a1;
      break;
    case 0x24A:
      sub_140361800(a1, "v_weapon_toggle_launch_missile");
      result = a1;
      break;
    case 0x24B:
      sub_140361800(a1, "v_weapon_launch_missile");
      result = a1;
      break;
    case 0x24C:
      sub_140361800(a1, "v_weapon_launch_missile_cinematic");
      result = a1;
      break;
    case 0x24D:
      sub_140361800(a1, "v_weapon_launch_missile_cinematic_hold");
      result = a1;
      break;
    case 0x24E:
      sub_140361800(a1, "v_weapon_bombing_toggle_desired_impact_point");
      result = a1;
      break;
    case 0x24F:
      sub_140361800(a1, "v_weapon_bombing_toggle_desired_impact_point_hold");
      result = a1;
      break;
    case 0x250:
      sub_140361800(a1, "v_weapon_bombing_hud_range_increase");
      result = a1;
      break;
    case 0x251:
      sub_140361800(a1, "v_weapon_bombing_hud_range_decrease");
      result = a1;
      break;
    case 0x252:
      sub_140361800(a1, "v_weapon_bombing_hud_range_reset");
      result = a1;
      break;
    case 0x253:
      sub_140361800(a1, "v_weapon_countermeasure_cinematic");
      result = a1;
      break;
    case 0x254:
      sub_140361800(a1, "v_weapon_countermeasure_decoy_launch");
      result = a1;
      break;
    case 0x255:
      sub_140361800(a1, "v_weapon_countermeasure_decoy_burst_increase");
      result = a1;
      break;
    case 0x256:
      sub_140361800(a1, "v_weapon_countermeasure_decoy_burst_decrease");
      result = a1;
      break;
    case 0x257:
      sub_140361800(a1, "v_weapon_countermeasure_decoy_launch_panic");
      result = a1;
      break;
    case 0x258:
      sub_140361800(a1, "v_weapon_countermeasure_noise_launch");
      result = a1;
      break;
    case 0x259:
      sub_140361800(a1, "v_weapon_toggle_ai");
      result = a1;
      break;
    case 0x25A:
      sub_140361800(a1, "v_weapon_change_firemode");
      result = a1;
      break;
    case 0x25B:
      sub_140361800(a1, "v_weapon_manual_gimbal_cycle_source");
      result = a1;
      break;
    case 0x25C:
      sub_140361800(a1, "v_weapon_manual_gimbal_lock_vector");
      result = a1;
      break;
    case 0x25D:
      sub_140361800(a1, "v_weapon_gimbal_mode_cycle_all");
      result = a1;
      break;
    case 0x25E:
      sub_140361800(a1, "v_weapon_gimbal_modes_cycle_assisted");
      result = a1;
      break;
    case 0x25F:
      sub_140361800(a1, "v_weapon_gimbal_mode_set_fixed");
      result = a1;
      break;
    case 0x260:
      sub_140361800(a1, "v_weapon_gimbal_mode_set_fixed_long");
      result = a1;
      break;
    case 0x261:
      sub_140361800(a1, "v_weapon_gimbal_mode_set_auto");
      result = a1;
      break;
    case 0x262:
      sub_140361800(a1, "v_weapon_gimbal_mode_set_auto_long");
      result = a1;
      break;
    case 0x263:
      sub_140361800(a1, "v_weapon_gimbal_mode_set_manual");
      result = a1;
      break;
    case 0x264:
      sub_140361800(a1, "v_weapon_gimbal_mode_set_manual_long");
      result = a1;
      break;
    case 0x265:
      sub_140361800(a1, "v_weapon_suppress_aim_assists_hold");
      result = a1;
      break;
    case 0x266:
      sub_140361800(a1, "v_weapon_pip_toggle_lead_lag");
      result = a1;
      break;
    case 0x267:
      sub_140361800(a1, "v_weapon_pip_set_lag");
      result = a1;
      break;
    case 0x268:
      sub_140361800(a1, "v_weapon_pip_set_lead");
      result = a1;
      break;
    case 0x269:
      sub_140361800(a1, "v_weapon_pip_combination_type_toggle");
      result = a1;
      break;
    case 0x26A:
      sub_140361800(a1, "v_weapon_pip_combination_type_set_single");
      result = a1;
      break;
    case 0x26B:
      sub_140361800(a1, "v_weapon_pip_combination_type_set_combined_weapon_group");
      result = a1;
      break;
    case 0x26C:
      sub_140361800(a1, "v_weapon_pip_prec_line_toggle");
      result = a1;
      break;
    case 0x26D:
      sub_140361800(a1, "v_weapon_pip_prec_line_on");
      result = a1;
      break;
    case 0x26E:
      sub_140361800(a1, "v_weapon_pip_prec_line_off");
      result = a1;
      break;
    case 0x26F:
      sub_140361800(a1, "v_weapon_pip_fade_toggle");
      result = a1;
      break;
    case 0x270:
      sub_140361800(a1, "v_weapon_pip_fade_on");
      result = a1;
      break;
    case 0x271:
      sub_140361800(a1, "v_weapon_pip_fade_off");
      result = a1;
      break;
    case 0x272:
      sub_140361800(a1, "v_weapon_ui_scale_toggle");
      result = a1;
      break;
    case 0x273:
      sub_140361800(a1, "v_weapon_ui_scale_on");
      result = a1;
      break;
    case 0x274:
      sub_140361800(a1, "v_weapon_ui_scale_off");
      result = a1;
      break;
    case 0x275:
      sub_140361800(a1, "v_weapon_convergence_distance_rel");
      result = a1;
      break;
    case 0x276:
      sub_140361800(a1, "v_weapon_convergence_distance_rel_increase");
      result = a1;
      break;
    case 0x277:
      sub_140361800(a1, "v_weapon_convergence_distance_rel_decrease");
      result = a1;
      break;
    case 0x278:
      sub_140361800(a1, "v_weapon_convergence_distance_abs");
      result = a1;
      break;
    case 0x279:
      sub_140361800(a1, "v_weapon_convergence_distance_set_default");
      result = a1;
      break;
    case 0x27A:
      sub_140361800(a1, "v_shield_raise_level_forward");
      result = a1;
      break;
    case 0x27B:
      sub_140361800(a1, "v_shield_raise_level_back");
      result = a1;
      break;
    case 0x27C:
      sub_140361800(a1, "v_shield_raise_level_left");
      result = a1;
      break;
    case 0x27D:
      sub_140361800(a1, "v_shield_raise_level_right");
      result = a1;
      break;
    case 0x27E:
      sub_140361800(a1, "v_shield_raise_level_up");
      result = a1;
      break;
    case 0x27F:
      sub_140361800(a1, "v_shield_raise_level_down");
      result = a1;
      break;
    case 0x280:
      sub_140361800(a1, "v_shield_reset_level");
      result = a1;
      break;
    case 0x281:
      sub_140361800(a1, "v_shield_toggle_standby");
      result = a1;
      break;
    case 0x282:
      sub_140361800(a1, "v_capacitor_assignment_engine_increase");
      result = a1;
      break;
    case 0x283:
      sub_140361800(a1, "v_capacitor_assignment_engine_decrease");
      result = a1;
      break;
    case 0x284:
      sub_140361800(a1, "v_capacitor_assignment_engine_max");
      result = a1;
      break;
    case 0x285:
      sub_140361800(a1, "v_capacitor_assignment_engine_min");
      result = a1;
      break;
    case 0x286:
      sub_140361800(a1, "v_capacitor_assignment_engine_combined_increase_max");
      result = a1;
      break;
    case 0x287:
      sub_140361800(a1, "v_capacitor_assignment_engine_combined_decrease_min");
      result = a1;
      break;
    case 0x288:
      sub_140361800(a1, "v_capacitor_assignment_weapon_decrease");
      result = a1;
      break;
    case 0x289:
      sub_140361800(a1, "v_capacitor_assignment_weapon_increase");
      result = a1;
      break;
    case 0x28A:
      sub_140361800(a1, "v_capacitor_assignment_weapon_max");
      result = a1;
      break;
    case 0x28B:
      sub_140361800(a1, "v_capacitor_assignment_weapon_min");
      result = a1;
      break;
    case 0x28C:
      sub_140361800(a1, "v_capacitor_assignment_weapon_combined_increase_max");
      result = a1;
      break;
    case 0x28D:
      sub_140361800(a1, "v_capacitor_assignment_weapon_combined_decrease_min");
      result = a1;
      break;
    case 0x28E:
      sub_140361800(a1, "v_capacitor_assignment_shield_increase");
      result = a1;
      break;
    case 0x28F:
      sub_140361800(a1, "v_capacitor_assignment_shield_decrease");
      result = a1;
      break;
    case 0x290:
      sub_140361800(a1, "v_capacitor_assignment_shield_max");
      result = a1;
      break;
    case 0x291:
      sub_140361800(a1, "v_capacitor_assignment_shield_min");
      result = a1;
      break;
    case 0x292:
      sub_140361800(a1, "v_capacitor_assignment_shield_combined_increase_max");
      result = a1;
      break;
    case 0x293:
      sub_140361800(a1, "v_capacitor_assignment_shield_combined_decrease_min");
      result = a1;
      break;
    case 0x294:
      sub_140361800(a1, "v_capacitor_assignment_reset");
      result = a1;
      break;
    case 0x295:
      sub_140361800(a1, "v_engineering_assignment_engine_increase");
      result = a1;
      break;
    case 0x296:
      sub_140361800(a1, "v_engineering_assignment_engine_decrease");
      result = a1;
      break;
    case 0x297:
      sub_140361800(a1, "v_engineering_assignment_engine_max");
      result = a1;
      break;
    case 0x298:
      sub_140361800(a1, "v_engineering_assignment_engine_min");
      result = a1;
      break;
    case 0x299:
      sub_140361800(a1, "v_engineering_assignment_shields_increase");
      result = a1;
      break;
    case 0x29A:
      sub_140361800(a1, "v_engineering_assignment_shields_decrease");
      result = a1;
      break;
    case 0x29B:
      sub_140361800(a1, "v_engineering_assignment_shields_max");
      result = a1;
      break;
    case 0x29C:
      sub_140361800(a1, "v_engineering_assignment_shields_min");
      result = a1;
      break;
    case 0x29D:
      sub_140361800(a1, "v_engineering_assignment_weapons_increase");
      result = a1;
      break;
    case 0x29E:
      sub_140361800(a1, "v_engineering_assignment_weapons_decrease");
      result = a1;
      break;
    case 0x29F:
      sub_140361800(a1, "v_engineering_assignment_weapons_max");
      result = a1;
      break;
    case 0x2A0:
      sub_140361800(a1, "v_engineering_assignment_weapons_min");
      result = a1;
      break;
    case 0x2A1:
      sub_140361800(a1, "v_engineering_assignment_reset");
      result = a1;
      break;
    case 0x2A2:
      sub_140361800(a1, "v_cooler_throttle_up");
      result = a1;
      break;
    case 0x2A3:
      sub_140361800(a1, "v_cooler_throttle_down");
      result = a1;
      break;
    case 0x2A4:
      sub_140361800(a1, "v_power_focus_weapons");
      result = a1;
      break;
    case 0x2A5:
      sub_140361800(a1, "v_power_focus_shields");
      result = a1;
      break;
    case 0x2A6:
      sub_140361800(a1, "v_power_focus_thrusters");
      result = a1;
      break;
    case 0x2A7:
      sub_140361800(a1, "v_power_reset_focus");
      result = a1;
      break;
    case 0x2A8:
      sub_140361800(a1, "v_power_throttle_up");
      result = a1;
      break;
    case 0x2A9:
      sub_140361800(a1, "v_power_throttle_down");
      result = a1;
      break;
    case 0x2AA:
      sub_140361800(a1, "v_power_throttle_max");
      result = a1;
      break;
    case 0x2AB:
      sub_140361800(a1, "v_power_throttle_min");
      result = a1;
      break;
    case 0x2AC:
      sub_140361800(a1, "v_power_toggle_weapons");
      result = a1;
      break;
    case 0x2AD:
      sub_140361800(a1, "v_power_toggle_shields");
      result = a1;
      break;
    case 0x2AE:
      sub_140361800(a1, "v_power_toggle_thrusters");
      result = a1;
      break;
    case 0x2AF:
      sub_140361800(a1, "v_power_toggle");
      result = a1;
      break;
    case 0x2B0:
      sub_140361800(a1, "v_power_set_on");
      result = a1;
      break;
    case 0x2B1:
      sub_140361800(a1, "v_power_set_off");
      result = a1;
      break;
    case 0x2B2:
      sub_140361800(a1, "v_power_set_weapons_on");
      result = a1;
      break;
    case 0x2B3:
      sub_140361800(a1, "v_power_set_weapons_off");
      result = a1;
      break;
    case 0x2B4:
      sub_140361800(a1, "v_power_set_shields_on");
      result = a1;
      break;
    case 0x2B5:
      sub_140361800(a1, "v_power_set_shields_off");
      result = a1;
      break;
    case 0x2B6:
      sub_140361800(a1, "v_power_set_thrusters_on");
      result = a1;
      break;
    case 0x2B7:
      sub_140361800(a1, "v_power_set_thrusters_off");
      result = a1;
      break;
    case 0x2B8:
      sub_140361800(a1, "v_radar_toggle_onoff");
      result = a1;
      break;
    case 0x2B9:
      sub_140361800(a1, "v_radar_toggle_active_or_passive");
      result = a1;
      break;
    case 0x2BA:
      sub_140361800(a1, "v_radar_cycle_mode_fwd");
      result = a1;
      break;
    case 0x2BB:
      sub_140361800(a1, "v_radar_cycle_mode_back");
      result = a1;
      break;
    case 0x2BC:
      sub_140361800(a1, "v_radar_cycle_zoom_fwd");
      result = a1;
      break;
    case 0x2BD:
      sub_140361800(a1, "v_radar_cycle_zoom_back");
      result = a1;
      break;
    case 0x2BE:
      sub_140361800(a1, "v_radar_cycle_focus_fwd");
      result = a1;
      break;
    case 0x2BF:
      sub_140361800(a1, "v_radar_cycle_focus_back");
      result = a1;
      break;
    case 0x2C0:
      sub_140361800(a1, "v_radar_toggle_view_focus");
      result = a1;
      break;
    case 0x2C1:
      sub_140361800(a1, "v_invoke_ping");
      result = a1;
      break;
    case 0x2C2:
      sub_140361800(a1, "v_toggle_scan_mode");
      result = a1;
      break;
    case 0x2C3:
      sub_140361800(a1, "v_set_scan_mode");
      result = a1;
      break;
    case 0x2C4:
      sub_140361800(a1, "v_toggle_fps_scan_mode");
      result = a1;
      break;
    case 0x2C5:
      sub_140361800(a1, "v_scanning_trigger_scan");
      result = a1;
      break;
    case 0x2C6:
      sub_140361800(a1, "v_inc_scan_focus_level");
      result = a1;
      break;
    case 0x2C7:
      sub_140361800(a1, "v_dec_scan_focus_level");
      result = a1;
      break;
    case 0x2C8:
      sub_140361800(a1, "v_ui_next_scan_tab");
      result = a1;
      break;
    case 0x2C9:
      sub_140361800(a1, "v_ui_prev_scan_tab");
      result = a1;
      break;
    case 0x2CA:
      sub_140361800(a1, "v_ui_next_scan_page");
      result = a1;
      break;
    case 0x2CB:
      sub_140361800(a1, "v_ui_prev_scan_page");
      result = a1;
      break;
    case 0x2CC:
      sub_140361800(a1, "v_ui_next_contact");
      result = a1;
      break;
    case 0x2CD:
      sub_140361800(a1, "v_ui_prev_contact");
      result = a1;
      break;
    case 0x2CE:
      sub_140361800(a1, "v_ui_next_contact_page");
      result = a1;
      break;
    case 0x2CF:
      sub_140361800(a1, "v_ui_prev_contact_page");
      result = a1;
      break;
    case 0x2D0:
      sub_140361800(a1, "v_comm_open_chat");
      result = a1;
      break;
    case 0x2D1:
      sub_140361800(a1, "v_comm_open_team_chat");
      result = a1;
      break;
    case 0x2D2:
      sub_140361800(a1, "v_comm_show_chat");
      result = a1;
      break;
    case 0x2D3:
      sub_140361800(a1, "v_comm_open_precanned");
      result = a1;
      break;
    case 0x2D4:
      sub_140361800(a1, "v_comm_select_precanned_1");
      result = a1;
      break;
    case 0x2D5:
      sub_140361800(a1, "v_comm_select_precanned_2");
      result = a1;
      break;
    case 0x2D6:
      sub_140361800(a1, "v_comm_select_precanned_3");
      result = a1;
      break;
    case 0x2D7:
      sub_140361800(a1, "v_comm_select_precanned_4");
      result = a1;
      break;
    case 0x2D8:
      sub_140361800(a1, "v_comm_select_precanned_5");
      result = a1;
      break;
    case 0x2D9:
      sub_140361800(a1, "v_toggle_mining_mode");
      result = a1;
      break;
    case 0x2DA:
      sub_140361800(a1, "v_set_mining_mode");
      result = a1;
      break;
    case 0x2DB:
      sub_140361800(a1, "v_toggle_mining_laser_type");
      result = a1;
      break;
    case 0x2DC:
      sub_140361800(a1, "v_toggle_mining_laser_fire");
      result = a1;
      break;
    case 0x2DD:
      sub_140361800(a1, "v_increase_mining_throttle");
      result = a1;
      break;
    case 0x2DE:
      sub_140361800(a1, "v_decrease_mining_throttle");
      result = a1;
      break;
    case 0x2DF:
      sub_140361800(a1, "v_mining_throttle");
      result = a1;
      break;
    case 0x2E0:
      sub_140361800(a1, "v_mining_use_consumable1");
      result = a1;
      break;
    case 0x2E1:
      sub_140361800(a1, "v_mining_use_consumable2");
      result = a1;
      break;
    case 0x2E2:
      sub_140361800(a1, "v_mining_use_consumable3");
      result = a1;
      break;
    case 0x2E3:
      sub_140361800(a1, "v_mining_use_permanent_modifier");
      result = a1;
      break;
    case 0x2E4:
      sub_140361800(a1, "v_jettison_volatile_cargo");
      result = a1;
      break;
    case 0x2E5:
      sub_140361800(a1, "v_toggle_salvage_mode");
      result = a1;
      break;
    case 0x2E6:
      sub_140361800(a1, "v_set_salvage_mode");
      result = a1;
      break;
    case 0x2E7:
      sub_140361800(a1, "v_salvage_toggle_fire_focused");
      result = a1;
      break;
    case 0x2E8:
      sub_140361800(a1, "v_salvage_toggle_fire_left");
      result = a1;
      break;
    case 0x2E9:
      sub_140361800(a1, "v_salvage_toggle_fire_right");
      result = a1;
      break;
    case 0x2EA:
      sub_140361800(a1, "v_salvage_toggle_fire_fracture");
      result = a1;
      break;
    case 0x2EB:
      sub_140361800(a1, "v_salvage_toggle_fire_disintegrate");
      result = a1;
      break;
    case 0x2EC:
      sub_140361800(a1, "v_salvage_toggle_gimbal_mode");
      result = a1;
      break;
    case 0x2ED:
      sub_140361800(a1, "v_salvage_reset_gimbal");
      result = a1;
      break;
    case 0x2EE:
      sub_140361800(a1, "v_salvage_increase_beam_spacing");
      result = a1;
      break;
    case 0x2EF:
      sub_140361800(a1, "v_salvage_decrease_beam_spacing");
      result = a1;
      break;
    case 0x2F0:
      sub_140361800(a1, "v_salvage_beam_spacing_rel");
      result = a1;
      break;
    case 0x2F1:
      sub_140361800(a1, "v_salvage_beam_spacing_abs");
      result = a1;
      break;
    case 0x2F2:
      sub_140361800(a1, "v_salvage_toggle_beam_spacing_axis");
      result = a1;
      break;
    case 0x2F3:
      sub_140361800(a1, "v_salvage_cycle_modifiers_focused");
      result = a1;
      break;
    case 0x2F4:
      sub_140361800(a1, "v_salvage_cycle_modifiers_left");
      result = a1;
      break;
    case 0x2F5:
      sub_140361800(a1, "v_salvage_cycle_modifiers_right");
      result = a1;
      break;
    case 0x2F6:
      sub_140361800(a1, "v_salvage_cycle_modifiers_structural");
      result = a1;
      break;
    case 0x2F7:
      sub_140361800(a1, "v_salvage_focus_all_heads");
      result = a1;
      break;
    case 0x2F8:
      sub_140361800(a1, "v_salvage_focus_left");
      result = a1;
      break;
    case 0x2F9:
      sub_140361800(a1, "v_salvage_focus_right");
      result = a1;
      break;
    case 0x2FA:
      sub_140361800(a1, "v_salvage_focus_fracture");
      result = a1;
      break;
    case 0x2FB:
      sub_140361800(a1, "v_salvage_focus_disintegrate");
      result = a1;
      break;
    case 0x2FC:
      sub_140361800(a1, "v_salvage_nudge_up__left");
      result = a1;
      break;
    case 0x2FD:
      sub_140361800(a1, "v_salvage_nudge_down__left");
      result = a1;
      break;
    case 0x2FE:
      sub_140361800(a1, "v_salvage_nudge_left__left");
      result = a1;
      break;
    case 0x2FF:
      sub_140361800(a1, "v_salvage_nudge_right__left");
      result = a1;
      break;
    case 0x300:
      sub_140361800(a1, "v_salvage_nudge_up__right");
      result = a1;
      break;
    case 0x301:
      sub_140361800(a1, "v_salvage_nudge_down__right");
      result = a1;
      break;
    case 0x302:
      sub_140361800(a1, "v_salvage_nudge_left__right");
      result = a1;
      break;
    case 0x303:
      sub_140361800(a1, "v_salvage_nudge_right__right");
      result = a1;
      break;
    case 0x304:
      sub_140361800(a1, "v_hud_cycle_mode_fwd");
      result = a1;
      break;
    case 0x305:
      sub_140361800(a1, "v_hud_cycle_mode_back");
      result = a1;
      break;
    case 0x306:
      sub_140361800(a1, "v_hud_focused_cycle_mode_fwd");
      result = a1;
      break;
    case 0x307:
      sub_140361800(a1, "v_hud_focused_cycle_mode_back");
      result = a1;
      break;
    case 0x308:
      sub_140361800(a1, "v_hud_open_scoreboard");
      result = a1;
      break;
    case 0x309:
      sub_140361800(a1, "v_hud_confirm");
      result = a1;
      break;
    case 0x30A:
      sub_140361800(a1, "v_hud_cancel");
      result = a1;
      break;
    case 0x30B:
      sub_140361800(a1, "v_hud_left_panel_up");
      result = a1;
      break;
    case 0x30C:
      sub_140361800(a1, "v_hud_left_panel_down");
      result = a1;
      break;
    case 0x30D:
      sub_140361800(a1, "v_hud_left_panel_left");
      result = a1;
      break;
    case 0x30E:
      sub_140361800(a1, "v_hud_left_panel_right");
      result = a1;
      break;
    case 0x30F:
      sub_140361800(a1, "v_hud_interact_toggle");
      result = a1;
      break;
    case 0x310:
      sub_140361800(a1, "v_hud_stick_x");
      result = a1;
      break;
    case 0x311:
      sub_140361800(a1, "v_hud_stick_y");
      result = a1;
      break;
    case 0x312:
      sub_140361800(a1, "v_toggle_landing_system");
      result = a1;
      break;
    case 0x313:
      sub_140361800(a1, "v_deploy_landing_system");
      result = a1;
      break;
    case 0x314:
      sub_140361800(a1, "v_retract_landing_system");
      result = a1;
      break;
    case 0x315:
      sub_140361800(a1, "v_autoland");
      result = a1;
      break;
    case 0x316:
      sub_140361800(a1, "v_atc_request");
      result = a1;
      break;
    case 0x317:
      sub_140361800(a1, "v_atc_loading_area_request");
      result = a1;
      break;
    case 0x318:
      sub_140361800(a1, "turret_pitch_up");
      result = a1;
      break;
    case 0x319:
      sub_140361800(a1, "turret_pitch_down");
      result = a1;
      break;
    case 0x31A:
      sub_140361800(a1, "turret_pitch");
      result = a1;
      break;
    case 0x31B:
      sub_140361800(a1, "turret_pitch_mouse");
      result = a1;
      break;
    case 0x31C:
      sub_140361800(a1, "turret_yaw_left");
      result = a1;
      break;
    case 0x31D:
      sub_140361800(a1, "turret_yaw_right");
      result = a1;
      break;
    case 0x31E:
      sub_140361800(a1, "turret_yaw");
      result = a1;
      break;
    case 0x31F:
      sub_140361800(a1, "turret_yaw_mouse");
      result = a1;
      break;
    case 0x320:
      sub_140361800(a1, "turret_mouse_mode_cycle");
      result = a1;
      break;
    case 0x321:
      sub_140361800(a1, "turret_mouse_mode_set_vjoy");
      result = a1;
      break;
    case 0x322:
      sub_140361800(a1, "turret_mouse_mode_set_1to1");
      result = a1;
      break;
    case 0x323:
      sub_140361800(a1, "turret_mouse_mode_set_pointer");
      result = a1;
      break;
    case 0x324:
      sub_140361800(a1, "turret_recenter");
      result = a1;
      break;
    case 0x325:
      sub_140361800(a1, "turret_limiter_toggle");
      result = a1;
      break;
    case 0x326:
      sub_140361800(a1, "turret_limiter_rel");
      result = a1;
      break;
    case 0x327:
      sub_140361800(a1, "turret_limiter_rel_increase");
      result = a1;
      break;
    case 0x328:
      sub_140361800(a1, "turret_limiter_rel_decrease");
      result = a1;
      break;
    case 0x329:
      sub_140361800(a1, "turret_limiter_abs");
      result = a1;
      break;
    case 0x32A:
      sub_140361800(a1, "turret_change_firemode");
      result = a1;
      break;
    case 0x32B:
      sub_140361800(a1, "turret_esp_toggle");
      result = a1;
      break;
    case 0x32C:
      sub_140361800(a1, "turret_esp_hold");
      result = a1;
      break;
    case 0x32D:
      sub_140361800(a1, "turret_gyromode");
      result = a1;
      break;
    case 0x32E:
      sub_140361800(a1, "turret_remote_exit");
      result = a1;
      break;
    case 0x32F:
      sub_140361800(a1, "turret_instant_zoom");
      result = a1;
      break;
    case 0x330:
      sub_140361800(a1, "turret_change_position");
      result = a1;
      break;
    case 0x331:
      sub_140361800(a1, "turret_change_movement_type");
      result = a1;
      break;
    case 0x332:
      sub_140361800(a1, "turret_remote_zoom_in");
      result = a1;
      break;
    case 0x333:
      sub_140361800(a1, "turret_remote_zoom_out");
      result = a1;
      break;
    case 0x334:
      sub_140361800(a1, "turret_remote_zoom_toggle");
      result = a1;
      break;
    case 0x335:
      sub_140361800(a1, "prone_rollleft");
      result = a1;
      break;
    case 0x336:
      sub_140361800(a1, "prone_rollright");
      result = a1;
      break;
    case 0x337:
      sub_140361800(a1, "tractor_beam_increase_distance");
      result = a1;
      break;
    case 0x338:
      sub_140361800(a1, "tractor_beam_decrease_distance");
      result = a1;
      break;
    case 0x339:
      sub_140361800(a1, "tractor_beam_vehicle_increase_distance");
      result = a1;
      break;
    case 0x33A:
      sub_140361800(a1, "tractor_beam_vehicle_decrease_distance");
      result = a1;
      break;
    case 0x33B:
      sub_140361800(a1, "tractor_beam_rotate");
      result = a1;
      break;
    case 0x33C:
      sub_140361800(a1, "tractor_beam_rotate_x");
      result = a1;
      break;
    case 0x33D:
      sub_140361800(a1, "tractor_beam_rotate_y");
      result = a1;
      break;
    case 0x33E:
      sub_140361800(a1, "tractor_beam_rotate_z_up");
      result = a1;
      break;
    case 0x33F:
      sub_140361800(a1, "tractor_beam_rotate_z_down");
      result = a1;
      break;
    case 0x340:
      sub_140361800(a1, "tractor_beam_detach");
      result = a1;
      break;
    case 0x341:
      sub_140361800(a1, "tractor_beam_throw");
      result = a1;
      break;
    case 0x342:
      sub_140361800(a1, "tractor_beam_reset_rotation");
      result = a1;
      break;
    case 0x343:
      sub_140361800(a1, "move_overlay_enable");
      result = a1;
      break;
    case 0x344:
      sub_140361800(a1, "move_overlay_disable");
      result = a1;
      break;
    case 0x345:
      sub_140361800(a1, "move_overlay_weight");
      result = a1;
      break;
    case 0x346:
      sub_140361800(a1, "move_overlay_x");
      result = a1;
      break;
    case 0x347:
      sub_140361800(a1, "move_overlay_y");
      result = a1;
      break;
    case 0x348:
      sub_140361800(a1, "skip_cutscene");
      result = a1;
      break;
    case 0x349:
      sub_140361800(a1, "skip_loadingscreen");
      result = a1;
      break;
    case 0x34A:
      sub_140361800(a1, "skip_loadingscreen_switched");
      result = a1;
      break;
    case 0x34B:
      sub_140361800(a1, "menu_open_customizeweapon");
      result = a1;
      break;
    case 0x34C:
      sub_140361800(a1, "menu_close_customizeweapon");
      result = a1;
      break;
    case 0x34D:
      sub_140361800(a1, "menu_up");
      result = a1;
      break;
    case 0x34E:
      sub_140361800(a1, "menu_down");
      result = a1;
      break;
    case 0x34F:
      sub_140361800(a1, "menu_left");
      result = a1;
      break;
    case 0x350:
      sub_140361800(a1, "menu_right");
      result = a1;
      break;
    case 0x351:
      sub_140361800(a1, "menu_map_zoomout");
      result = a1;
      break;
    case 0x352:
      sub_140361800(a1, "menu_map_zoomin");
      result = a1;
      break;
    case 0x353:
      sub_140361800(a1, "menu_scrollup");
      result = a1;
      break;
    case 0x354:
      sub_140361800(a1, "menu_scrolldown");
      result = a1;
      break;
    case 0x355:
      sub_140361800(a1, "menu_fcommand1");
      result = a1;
      break;
    case 0x356:
      sub_140361800(a1, "menu_fcommand2");
      result = a1;
      break;
    case 0x357:
      sub_140361800(a1, "menu_confirm");
      result = a1;
      break;
    case 0x358:
      sub_140361800(a1, "menu_confirm2");
      result = a1;
      break;
    case 0x359:
      sub_140361800(a1, "menu_back");
      result = a1;
      break;
    case 0x35A:
      sub_140361800(a1, "menu_exit");
      result = a1;
      break;
    case 0x35B:
      sub_140361800(a1, "menu_delete");
      result = a1;
      break;
    case 0x35C:
      sub_140361800(a1, "menu_apply");
      result = a1;
      break;
    case 0x35D:
      sub_140361800(a1, "menu_default");
      result = a1;
      break;
    case 0x35E:
      sub_140361800(a1, "menu_back_select");
      result = a1;
      break;
    case 0x35F:
      sub_140361800(a1, "menu_tab");
      result = a1;
      break;
    case 0x360:
      sub_140361800(a1, "menu_input_1");
      result = a1;
      break;
    case 0x361:
      sub_140361800(a1, "menu_input_2");
      result = a1;
      break;
    case 0x362:
      sub_140361800(a1, "menu_switchtab_left");
      result = a1;
      break;
    case 0x363:
      sub_140361800(a1, "menu_switchtab_right");
      result = a1;
      break;
    case 0x364:
      sub_140361800(a1, "menu_toggle_barrel");
      result = a1;
      break;
    case 0x365:
      sub_140361800(a1, "menu_toggle_bottom");
      result = a1;
      break;
    case 0x366:
      sub_140361800(a1, "menu_toggle_scope");
      result = a1;
      break;
    case 0x367:
      sub_140361800(a1, "menu_toggle_ammo");
      result = a1;
      break;
    case 0x368:
      sub_140361800(a1, "ui_notification_accept");
      result = a1;
      break;
    case 0x369:
      sub_140361800(a1, "ui_notification_decline");
      result = a1;
      break;
    case 0x36A:
      sub_140361800(a1, "ui_notification_ignore");
      result = a1;
      break;
    case 0x36B:
      sub_140361800(a1, "menu_assetpause");
      result = a1;
      break;
    case 0x36C:
      sub_140361800(a1, "menu_assetzoom");
      result = a1;
      break;
    case 0x36D:
      sub_140361800(a1, "menu_toggle_index_finger");
      result = a1;
      break;
    case 0x36E:
      sub_140361800(a1, "menu_toggle_middle_finger");
      result = a1;
      break;
    case 0x36F:
      sub_140361800(a1, "menu_toggle_ring_finger");
      result = a1;
      break;
    case 0x370:
      sub_140361800(a1, "menu_toggle_ring_finger_switched");
      result = a1;
      break;
    case 0x371:
      sub_140361800(a1, "menu_toggle_pink");
      result = a1;
      break;
    case 0x372:
      sub_140361800(a1, "ui_toggle_pause");
      result = a1;
      break;
    case 0x373:
      sub_140361800(a1, "ui_up");
      result = a1;
      break;
    case 0x374:
      sub_140361800(a1, "ui_down");
      result = a1;
      break;
    case 0x375:
      sub_140361800(a1, "ui_left");
      result = a1;
      break;
    case 0x376:
      sub_140361800(a1, "ui_right");
      result = a1;
      break;
    case 0x377:
      sub_140361800(a1, "ui_click");
      result = a1;
      break;
    case 0x378:
      sub_140361800(a1, "ui_back");
      result = a1;
      break;
    case 0x379:
      sub_140361800(a1, "ui_confirm");
      result = a1;
      break;
    case 0x37A:
      sub_140361800(a1, "ui_reset");
      result = a1;
      break;
    case 0x37B:
      sub_140361800(a1, "ui_skip_video");
      result = a1;
      break;
    case 0x37C:
      sub_140361800(a1, "ui_hide_hint");
      result = a1;
      break;
    case 0x37D:
      sub_140361800(a1, "ui_hold_to_delete");
      result = a1;
      break;
    case 0x37E:
      sub_140361800(a1, "ui_copy");
      result = a1;
      break;
    case 0x37F:
      sub_140361800(a1, "ui_cut");
      result = a1;
      break;
    case 0x380:
      sub_140361800(a1, "ui_paste");
      result = a1;
      break;
    case 0x381:
      sub_140361800(a1, "ui_radialmenu_pageleft");
      result = a1;
      break;
    case 0x382:
      sub_140361800(a1, "ui_radialmenu_pageright");
      result = a1;
      break;
    case 0x383:
      sub_140361800(a1, "flashui_mouse");
      result = a1;
      break;
    case 0x384:
      sub_140361800(a1, "flashui_return");
      result = a1;
      break;
    case 0x385:
      sub_140361800(a1, "flashui_backspace");
      result = a1;
      break;
    case 0x386:
      sub_140361800(a1, "flashui_tab");
      result = a1;
      break;
    case 0x387:
      sub_140361800(a1, "flashui_kp_2");
      result = a1;
      break;
    case 0x388:
      sub_140361800(a1, "flashui_kp_3");
      result = a1;
      break;
    case 0x389:
      sub_140361800(a1, "flashui_kp_4");
      result = a1;
      break;
    case 0x38A:
      sub_140361800(a1, "flashui_kp_7");
      result = a1;
      break;
    case 0x38B:
      sub_140361800(a1, "flashui_up");
      result = a1;
      break;
    case 0x38C:
      sub_140361800(a1, "flashui_down");
      result = a1;
      break;
    case 0x38D:
      sub_140361800(a1, "flashui_left");
      result = a1;
      break;
    case 0x38E:
      sub_140361800(a1, "flashui_right");
      result = a1;
      break;
    case 0x38F:
      sub_140361800(a1, "flashui_spacebar");
      result = a1;
      break;
    case 0x390:
      sub_140361800(a1, "ui_3d_display_select");
      result = a1;
      break;
    case 0x391:
      sub_140361800(a1, "ui_3d_display_center");
      result = a1;
      break;
    case 0x392:
      sub_140361800(a1, "ui_3d_display_decenter");
      result = a1;
      break;
    case 0x393:
      sub_140361800(a1, "ui_3d_display_zoom_in_button");
      result = a1;
      break;
    case 0x394:
      sub_140361800(a1, "ui_3d_display_zoom_in_analog");
      result = a1;
      break;
    case 0x395:
      sub_140361800(a1, "ui_3d_display_zoom_out_button");
      result = a1;
      break;
    case 0x396:
      sub_140361800(a1, "ui_3d_display_zoom_out_analog");
      result = a1;
      break;
    case 0x397:
      sub_140361800(a1, "ui_3d_display_pan_toggle");
      result = a1;
      break;
    case 0x398:
      sub_140361800(a1, "ui_3d_display_rotate_toggle");
      result = a1;
      break;
    case 0x399:
      sub_140361800(a1, "ui_3d_display_zoom_toggle");
      result = a1;
      break;
    case 0x39A:
      sub_140361800(a1, "ui_3d_display_toggledPanX");
      result = a1;
      break;
    case 0x39B:
      sub_140361800(a1, "ui_3d_display_toggledPanY");
      result = a1;
      break;
    case 0x39C:
      sub_140361800(a1, "ui_3d_display_toggledYaw");
      result = a1;
      break;
    case 0x39D:
      sub_140361800(a1, "ui_3d_display_toggledPitch");
      result = a1;
      break;
    case 0x39E:
      sub_140361800(a1, "ui_3d_display_toggledZoom");
      result = a1;
      break;
    case 0x39F:
      sub_140361800(a1, "ui_3d_display_pinMode");
      result = a1;
      break;
    case 0x3A0:
      sub_140361800(a1, "ui_3d_display_pinSelect");
      result = a1;
      break;
    case 0x3A1:
      sub_140361800(a1, "ui_3d_display_zoom_in_wheel");
      result = a1;
      break;
    case 0x3A2:
      sub_140361800(a1, "ui_3d_display_zoom_out_wheel");
      result = a1;
      break;
    case 0x3A3:
      sub_140361800(a1, "ui_3d_display_nonToggledPanUp");
      result = a1;
      break;
    case 0x3A4:
      sub_140361800(a1, "ui_3d_display_nonToggledPanDown");
      result = a1;
      break;
    case 0x3A5:
      sub_140361800(a1, "ui_3d_display_nonToggledPanLeft");
      result = a1;
      break;
    case 0x3A6:
      sub_140361800(a1, "ui_3d_display_nonToggledPanRight");
      result = a1;
      break;
    case 0x3A7:
      sub_140361800(a1, "ui_3d_display_nonToggledYawUp");
      result = a1;
      break;
    case 0x3A8:
      sub_140361800(a1, "ui_3d_display_nonToggledYawDown");
      result = a1;
      break;
    case 0x3A9:
      sub_140361800(a1, "ui_3d_display_nonToggledPitchLeft");
      result = a1;
      break;
    case 0x3AA:
      sub_140361800(a1, "ui_3d_display_nonToggledPitchRight");
      result = a1;
      break;
    case 0x3AB:
      sub_140361800(a1, "ui_3d_display_reorient");
      result = a1;
      break;
    case 0x3AC:
      sub_140361800(a1, "ui_textfield_enter");
      result = a1;
      break;
    case 0x3AD:
      sub_140361800(a1, "ui_textfield_backspace");
      result = a1;
      break;
    case 0x3AE:
      sub_140361800(a1, "ui_textfield_arrow_up");
      result = a1;
      break;
    case 0x3AF:
      sub_140361800(a1, "ui_textfield_arrow_down");
      result = a1;
      break;
    case 0x3B0:
      sub_140361800(a1, "ui_textfield_arrow_left");
      result = a1;
      break;
    case 0x3B1:
      sub_140361800(a1, "ui_textfield_arrow_right");
      result = a1;
      break;
    case 0x3B2:
      sub_140361800(a1, "minigame_decrypt_input_1");
      result = a1;
      break;
    case 0x3B3:
      sub_140361800(a1, "minigame_decrypt_input_2");
      result = a1;
      break;
    case 0x3B4:
      sub_140361800(a1, "minigame_decrypt_input_3");
      result = a1;
      break;
    case 0x3B5:
      sub_140361800(a1, "minigame_decrypt_input_4");
      result = a1;
      break;
    case 0x3B6:
      sub_140361800(a1, "minigame_decrypt_quit");
      result = a1;
      break;
    case 0x3B7:
      sub_140361800(a1, "minigame_waveddr_lockon");
      result = a1;
      break;
    case 0x3B8:
      sub_140361800(a1, "minigame_ingame_quit");
      result = a1;
      break;
    case 0x3B9:
      sub_140361800(a1, "hacking_minigame_abort");
      result = a1;
      break;
    case 0x3BA:
      sub_140361800(a1, "hacking_minigame_help_window_toggle");
      result = a1;
      break;
    case 0x3BB:
      sub_140361800(a1, "hacking_minigame_mouse_lmb");
      result = a1;
      break;
    case 0x3BC:
      sub_140361800(a1, "hacking_minigame_mouse_rmb");
      result = a1;
      break;
    case 0x3BD:
      sub_140361800(a1, "hacking_minigame_camera_control");
      result = a1;
      break;
    case 0x3BE:
      sub_140361800(a1, "hacking_minigame_camera_x");
      result = a1;
      break;
    case 0x3BF:
      sub_140361800(a1, "hacking_minigame_camera_y");
      result = a1;
      break;
    case 0x3C0:
      sub_140361800(a1, "hacking_minigame_movement_up");
      result = a1;
      break;
    case 0x3C1:
      sub_140361800(a1, "hacking_minigame_movement_down");
      result = a1;
      break;
    case 0x3C2:
      sub_140361800(a1, "hacking_minigame_movement_left");
      result = a1;
      break;
    case 0x3C3:
      sub_140361800(a1, "hacking_minigame_movement_right");
      result = a1;
      break;
    case 0x3C4:
      sub_140361800(a1, "hacking_minigame_swap_rotate_cw");
      result = a1;
      break;
    case 0x3C5:
      sub_140361800(a1, "hacking_minigame_swap_rotate_ccw");
      result = a1;
      break;
    case 0x3C6:
      sub_140361800(a1, "hacking_minigame_ability_inject");
      result = a1;
      break;
    case 0x3C7:
      sub_140361800(a1, "hacking_minigame_ability_ping");
      result = a1;
      break;
    case 0x3C8:
      sub_140361800(a1, "hacking_minigame_ability_slowdown");
      result = a1;
      break;
    case 0x3C9:
      sub_140361800(a1, "hacking_minigame_ability_swap");
      result = a1;
      break;
    case 0x3CA:
      sub_140361800(a1, "hacking_minigame_ability_wraparound");
      result = a1;
      break;
    case 0x3CB:
      sub_140361800(a1, "hacking_minigame_cycle_input_mode");
      result = a1;
      break;
    case 0x3CC:
      sub_140361800(a1, "mapui_pan_left");
      result = a1;
      break;
    case 0x3CD:
      sub_140361800(a1, "mapui_pan_right");
      result = a1;
      break;
    case 0x3CE:
      sub_140361800(a1, "mapui_pan_forward");
      result = a1;
      break;
    case 0x3CF:
      sub_140361800(a1, "mapui_pan_back");
      result = a1;
      break;
    case 0x3D0:
      sub_140361800(a1, "mapui_pan_up");
      result = a1;
      break;
    case 0x3D1:
      sub_140361800(a1, "mapui_pan_down");
      result = a1;
      break;
    case 0x3D2:
      sub_140361800(a1, "mapui_cycle_zone_forward");
      result = a1;
      break;
    case 0x3D3:
      sub_140361800(a1, "mapui_cycle_zone_backward");
      result = a1;
      break;
    case 0x3D4:
      sub_140361800(a1, "mapui_cycle_section_forward");
      result = a1;
      break;
    case 0x3D5:
      sub_140361800(a1, "mapui_cycle_section_backward");
      result = a1;
      break;
    case 0x3D6:
      sub_140361800(a1, "mapui_action_planroute");
      result = a1;
      break;
    case 0x3D7:
      sub_140361800(a1, "mapui_action_clearroute");
      result = a1;
      break;
    case 0x3D8:
      sub_140361800(a1, "mapui_action_togglepin");
      result = a1;
      break;
    case 0x3D9:
      sub_140361800(a1, "mapui_action_mylocation");
      result = a1;
      break;
    case 0x3DA:
      sub_140361800(a1, "mapui_action_toggle_view_entire_zone");
      result = a1;
      break;
    case 0x3DB:
      sub_140361800(a1, "mapui_action_toggleQTActions");
      result = a1;
      break;
    case 0x3DC:
      sub_140361800(a1, "mapui_action_goto_selection");
      result = a1;
      break;
    case 0x3DD:
      sub_140361800(a1, "mapui_action_step_back");
      result = a1;
      break;
    case 0x3DE:
      sub_140361800(a1, "mapui_action_goto_localmap");
      result = a1;
      break;
    case 0x3DF:
      sub_140361800(a1, "mannequin_debugai");
      result = a1;
      break;
    case 0x3E0:
      sub_140361800(a1, "mannequin_debugplayer");
      result = a1;
      break;
    case 0x3E1:
      sub_140361800(a1, "ai_debugCenterViewAgent");
      result = a1;
      break;
    case 0x3E2:
      sub_140361800(a1, "foip_viewownplayer");
      result = a1;
      break;
    case 0x3E3:
      sub_140361800(a1, "foip_pushtotalk");
      result = a1;
      break;
    case 0x3E4:
      sub_140361800(a1, "foip_recalibrate");
      result = a1;
      break;
    case 0x3E5:
      sub_140361800(a1, "foip_cyclechannel");
      result = a1;
      break;
    case 0x3E6:
      sub_140361800(a1, "foip_pushtotalk_proximity");
      result = a1;
      break;
    case 0x3E7:
      sub_140361800(a1, "headtrack_enabled");
      result = a1;
      break;
    case 0x3E8:
      sub_140361800(a1, "headtrack_hold");
      result = a1;
      break;
    case 0x3E9:
      sub_140361800(a1, "headtrack_recenter_device");
      result = a1;
      break;
    case 0x3EA:
      sub_140361800(a1, "headtrack_camera_enabled");
      result = a1;
      break;
    case 0x3EB:
      sub_140361800(a1, "flymode");
      result = a1;
      break;
    case 0x3EC:
      sub_140361800(a1, "flymode_strafe_up");
      result = a1;
      break;
    case 0x3ED:
      sub_140361800(a1, "flymode_strafe_down");
      result = a1;
      break;
    case 0x3EE:
      sub_140361800(a1, "flymode_roll_left");
      result = a1;
      break;
    case 0x3EF:
      sub_140361800(a1, "flymode_roll_right");
      result = a1;
      break;
    case 0x3F0:
      sub_140361800(a1, "godmode");
      result = a1;
      break;
    case 0x3F1:
      sub_140361800(a1, "pause_and_fly");
      result = a1;
      break;
    case 0x3F2:
      sub_140361800(a1, "toggleaidebugdraw");
      result = a1;
      break;
    case 0x3F3:
      sub_140361800(a1, "togglepdrawhelpers");
      result = a1;
      break;
    case 0x3F4:
      sub_140361800(a1, "toggledmode");
      result = a1;
      break;
    case 0x3F5:
      sub_140361800(a1, "debug");
      result = a1;
      break;
    case 0x3F6:
      sub_140361800(a1, "debug_ag_step");
      result = a1;
      break;
    case 0x3F7:
      sub_140361800(a1, "pl_result_state_debug_target");
      result = a1;
      break;
    case 0x3F8:
      sub_140361800(a1, "mov_advance_all_sequences");
      result = a1;
      break;
    case 0x3F9:
      sub_140361800(a1, "mov_pause_resume_all_sequences");
      result = a1;
      break;
    case 0x3FA:
      sub_140361800(a1, "tweakenter");
      result = a1;
      break;
    case 0x3FB:
      sub_140361800(a1, "tweakup");
      result = a1;
      break;
    case 0x3FC:
      sub_140361800(a1, "tweakdown");
      result = a1;
      break;
    case 0x3FD:
      sub_140361800(a1, "tweakleft");
      result = a1;
      break;
    case 0x3FE:
      sub_140361800(a1, "tweakright");
      result = a1;
      break;
    case 0x3FF:
      sub_140361800(a1, "tweakincrement");
      result = a1;
      break;
    case 0x400:
      sub_140361800(a1, "tweakdecrement");
      result = a1;
      break;
    case 0x401:
      sub_140361800(a1, "hacking_minigame_debug_toggle_command_input");
      result = a1;
      break;
    case 0x402:
      sub_140361800(a1, "hacking_minigame_debug_mouse_x");
      result = a1;
      break;
    case 0x403:
      sub_140361800(a1, "hacking_minigame_debug_mouse_y");
      result = a1;
      break;
    case 0x404:
      sub_140361800(a1, "hmd_toggle");
      result = a1;
      break;
    case 0x405:
      sub_140361800(a1, "hmd_center");
      result = a1;
      break;
    case 0x406:
      sub_140361800(a1, "pc_zoom_in");
      result = a1;
      break;
    case 0x407:
      sub_140361800(a1, "pc_zoom_out");
      result = a1;
      break;
    case 0x408:
      sub_140361800(a1, "pc_interaction_mode");
      result = a1;
      break;
    case 0x409:
      sub_140361800(a1, "gp_interaction_mode_on_foot");
      result = a1;
      break;
    case 0x40A:
      sub_140361800(a1, "gp_interaction_mode_on_ship");
      result = a1;
      break;
    case 0x40B:
      sub_140361800(a1, "pc_interaction_select");
      result = a1;
      break;
    case 0x40C:
      sub_140361800(a1, "pc_select");
      result = a1;
      break;
    case 0x40D:
      sub_140361800(a1, "pc_focus");
      result = a1;
      break;
    case 0x40E:
      sub_140361800(a1, "pc_screen_focus_left");
      result = a1;
      break;
    case 0x40F:
      sub_140361800(a1, "pc_screen_focus_right");
      result = a1;
      break;
    case 0x410:
      sub_140361800(a1, "pc_screen_focus_up");
      result = a1;
      break;
    case 0x411:
      sub_140361800(a1, "pc_screen_focus_down");
      result = a1;
      break;
    case 0x412:
      sub_140361800(a1, "pc_ui_back");
      result = a1;
      break;
    case 0x413:
      sub_140361800(a1, "pc_item_primary");
      result = a1;
      break;
    case 0x414:
      sub_140361800(a1, "pc_item_secondary");
      result = a1;
      break;
    case 0x415:
      sub_140361800(a1, "pc_conversation_option1");
      result = a1;
      break;
    case 0x416:
      sub_140361800(a1, "pc_conversation_option2");
      result = a1;
      break;
    case 0x417:
      sub_140361800(a1, "pc_conversation_option3");
      result = a1;
      break;
    case 0x418:
      sub_140361800(a1, "pc_conversation_option4");
      result = a1;
      break;
    case 0x419:
      sub_140361800(a1, "pc_conversation_option5");
      result = a1;
      break;
    case 0x41A:
      sub_140361800(a1, "pc_conversation_option_up");
      result = a1;
      break;
    case 0x41B:
      sub_140361800(a1, "pc_conversation_option_down");
      result = a1;
      break;
    case 0x41C:
      sub_140361800(a1, "pc_conversation_option_select");
      result = a1;
      break;
    case 0x41D:
      sub_140361800(a1, "pc_personal_thought");
      result = a1;
      break;
    case 0x41E:
      sub_140361800(a1, "pc_camera_orbit");
      result = a1;
      break;
    case 0x41F:
      sub_140361800(a1, "pc_personal_back");
      result = a1;
      break;
    case 0x420:
      sub_140361800(a1, "pc_pit_inventory");
      result = a1;
      break;
    case 0x421:
      sub_140361800(a1, "pc_pit_looting");
      result = a1;
      break;
    case 0x422:
      sub_140361800(a1, "pc_pit_looting_toggle_view");
      result = a1;
      break;
    case 0x423:
      sub_140361800(a1, "pc_pit_looting_toggle_weapon_attachments");
      result = a1;
      break;
    case 0x424:
      sub_140361800(a1, "pc_pit_item_unstown");
      result = a1;
      break;
    case 0x425:
      sub_140361800(a1, "pc_pit_item_drop");
      result = a1;
      break;
    case 0x426:
      sub_140361800(a1, "pc_pit_player_actions");
      result = a1;
      break;
    case 0x427:
      sub_140361800(a1, "pc_pit_emotes");
      result = a1;
      break;
    case 0x428:
      sub_140361800(a1, "pc_pit_ship_systems");
      result = a1;
      break;
    case 0x429:
      sub_140361800(a1, "pc_pit_flight_systems");
      result = a1;
      break;
    case 0x42A:
      sub_140361800(a1, "pc_pit_vehicle_actions");
      result = a1;
      break;
    case 0x42B:
      sub_140361800(a1, "pc_pit_weapons_systems");
      result = a1;
      break;
    case 0x42C:
      sub_140361800(a1, "pc_pit_remote_turrets");
      result = a1;
      break;
    case 0x42D:
      sub_140361800(a1, "pc_pit_item_actions");
      result = a1;
      break;
    case 0x42E:
      sub_140361800(a1, "pc_pit_weapon_selection");
      result = a1;
      break;
    case 0x42F:
      sub_140361800(a1, "pc_pit_mobiglas_actions");
      result = a1;
      break;
    case 0x430:
      sub_140361800(a1, "pc_pit_miningmode_actions");
      result = a1;
      break;
    case 0x431:
      sub_140361800(a1, "pc_qs_flight_mode");
      result = a1;
      break;
    case 0x432:
      sub_140361800(a1, "pc_qs_open_wingman_commands");
      result = a1;
      break;
    case 0x433:
      sub_140361800(a1, "pc_qs_grenades");
      result = a1;
      break;
    case 0x434:
      sub_140361800(a1, "pc_qs_consumables");
      result = a1;
      break;
    case 0x435:
      sub_140361800(a1, "pc_qs_weapons_pit_primary");
      result = a1;
      break;
    case 0x436:
      sub_140361800(a1, "pc_qs_weapons_pit_secondary");
      result = a1;
      break;
    case 0x437:
      sub_140361800(a1, "pc_qs_weapons_pit_sidearm");
      result = a1;
      break;
    case 0x438:
      sub_140361800(a1, "character_customizer_yaw");
      result = a1;
      break;
    case 0x439:
      sub_140361800(a1, "character_customizer_pitch");
      result = a1;
      break;
    case 0x43A:
      sub_140361800(a1, "character_customizer_zoom_in");
      result = a1;
      break;
    case 0x43B:
      sub_140361800(a1, "character_customizer_zoom_out");
      result = a1;
      break;
    case 0x43C:
      sub_140361800(a1, "character_customizer_select");
      result = a1;
      break;
    case 0x43D:
      sub_140361800(a1, "character_customizer_enable_dna_edit");
      result = a1;
      break;
    case 0x43E:
      sub_140361800(a1, "character_customizer_enable_rotation");
      result = a1;
      break;
    case 0x43F:
      sub_140361800(a1, "character_customizer_enable_mouse_rotation");
      result = a1;
      break;
    case 0x440:
      sub_140361800(a1, "character_customizer_library_scroll_up");
      result = a1;
      break;
    case 0x441:
      sub_140361800(a1, "character_customizer_library_scroll_down");
      result = a1;
      break;
    case 0x442:
      sub_140361800(a1, "character_customizer_edit_dna_pos");
      result = a1;
      break;
    case 0x443:
      sub_140361800(a1, "character_customizer_edit_dna_neg");
      result = a1;
      break;
    case 0x444:
      sub_140361800(a1, "character_customizer_yaw_left");
      result = a1;
      break;
    case 0x445:
      sub_140361800(a1, "character_customizer_yaw_right");
      result = a1;
      break;
    case 0x446:
      sub_140361800(a1, "character_customizer_pitch_up");
      result = a1;
      break;
    case 0x447:
      sub_140361800(a1, "character_customizer_pitch_down");
      result = a1;
      break;
    case 0x448:
      sub_140361800(a1, "character_customizer_step_up");
      result = a1;
      break;
    case 0x449:
      sub_140361800(a1, "character_customizer_step_down");
      result = a1;
      break;
    case 0x44A:
      sub_140361800(a1, "character_customizer_feature_up");
      result = a1;
      break;
    case 0x44B:
      sub_140361800(a1, "character_customizer_feature_down");
      result = a1;
      break;
    case 0x44C:
      sub_140361800(a1, "character_customizer_dnamode_up");
      result = a1;
      break;
    case 0x44D:
      sub_140361800(a1, "character_customizer_dnamode_down");
      result = a1;
      break;
    case 0x44E:
      sub_140361800(a1, "character_customizer_next_material_region");
      result = a1;
      break;
    case 0x44F:
      sub_140361800(a1, "character_customizer_toggle_face_tracking");
      result = a1;
      break;
    case 0x450:
      sub_140361800(a1, "tag_target");
      result = a1;
      break;
    case 0x451:
      sub_140361800(a1, "remote_moveForward");
      result = a1;
      break;
    case 0x452:
      sub_140361800(a1, "remote_moveBack");
      result = a1;
      break;
    case 0x453:
      sub_140361800(a1, "remote_moveLeft");
      result = a1;
      break;
    case 0x454:
      sub_140361800(a1, "remote_moveRight");
      result = a1;
      break;
    case 0x455:
      sub_140361800(a1, "remote_moveUp");
      result = a1;
      break;
    case 0x456:
      sub_140361800(a1, "remote_moveDown");
      result = a1;
      break;
    case 0x457:
      sub_140361800(a1, "remote_stopControl");
      result = a1;
      break;
    case 0x458:
      sub_140361800(a1, "remote_switchControl");
      result = a1;
      break;
    case 0x459:
      sub_140361800(a1, "remote_scaleUp");
      result = a1;
      break;
    case 0x45A:
      sub_140361800(a1, "remote_scaleDown");
      result = a1;
      break;
    case 0x45B:
      sub_140361800(a1, "remote_rollLeft");
      result = a1;
      break;
    case 0x45C:
      sub_140361800(a1, "remote_rollRight");
      result = a1;
      break;
    case 0x45D:
      sub_140361800(a1, "remote_rotatePitch");
      result = a1;
      break;
    case 0x45E:
      sub_140361800(a1, "remote_rotateYaw");
      result = a1;
      break;
    case 0x45F:
      sub_140361800(a1, "remote_action1");
      result = a1;
      break;
    case 0x460:
      sub_140361800(a1, "remote_action2");
      result = a1;
      break;
    case 0x461:
      sub_140361800(a1, "remote_switchTarget");
      result = a1;
      break;
    case 0x462:
      sub_140361800(a1, "mobiGlas_3d_Display_rotate_toggle");
      result = a1;
      break;
    case 0x463:
      sub_140361800(a1, "mobiGlas_3d_Display_Yaw");
      result = a1;
      break;
    case 0x464:
      sub_140361800(a1, "mobiGlas_3d_Display_Pitch");
      result = a1;
      break;
    case 0x465:
      sub_140361800(a1, "mobiGlas_framework_next_app");
      result = a1;
      break;
    case 0x466:
      sub_140361800(a1, "mobiGlas_framework_previous_app");
      result = a1;
      break;
    case 0x467:
      sub_140361800(a1, "mobiGlas_framework_next_tab");
      result = a1;
      break;
    case 0x468:
      sub_140361800(a1, "mobiGlas_framework_previous_tab");
      result = a1;
      break;
    case 0x469:
      sub_140361800(a1, "stopwatch_reset");
      result = a1;
      break;
    case 0x46A:
      sub_140361800(a1, "stopwatch_trigger");
      result = a1;
      break;
    case 0x46B:
      sub_140361800(a1, "v_mfd_interact_cycle_forwards_short");
      result = a1;
      break;
    case 0x46C:
      sub_140361800(a1, "v_mfd_interact_cycle_forwards_long");
      result = a1;
      break;
    case 0x46D:
      sub_140361800(a1, "v_mfd_interact_cycle_backwards_short");
      result = a1;
      break;
    case 0x46E:
      sub_140361800(a1, "v_mfd_interact_cycle_backwards_long");
      result = a1;
      break;
    case 0x46F:
      sub_140361800(a1, "v_mfd_interact_hard_select_short");
      result = a1;
      break;
    case 0x470:
      sub_140361800(a1, "v_mfd_interact_hard_select_long");
      result = a1;
      break;
    case 0x471:
      sub_140361800(a1, "v_mfd_interact_cancel_short");
      result = a1;
      break;
    case 0x472:
      sub_140361800(a1, "v_mfd_interact_cancel_long");
      result = a1;
      break;
    case 0x473:
      sub_140361800(a1, "v_mfd_interact_power_toggle_short");
      result = a1;
      break;
    case 0x474:
      sub_140361800(a1, "v_mfd_interact_power_toggle_long");
      result = a1;
      break;
    case 0x475:
      sub_140361800(a1, "v_mfd_interact_power_on_short");
      result = a1;
      break;
    case 0x476:
      sub_140361800(a1, "v_mfd_interact_power_on_long");
      result = a1;
      break;
    case 0x477:
      sub_140361800(a1, "v_mfd_interact_power_off_short");
      result = a1;
      break;
    case 0x478:
      sub_140361800(a1, "v_mfd_interact_power_off_long");
      result = a1;
      break;
    case 0x479:
      sub_140361800(a1, "v_mfd_movement_up_short");
      result = a1;
      break;
    case 0x47A:
      sub_140361800(a1, "v_mfd_movement_up_long");
      result = a1;
      break;
    case 0x47B:
      sub_140361800(a1, "v_mfd_movement_down_short");
      result = a1;
      break;
    case 0x47C:
      sub_140361800(a1, "v_mfd_movement_down_long");
      result = a1;
      break;
    case 0x47D:
      sub_140361800(a1, "v_mfd_movement_left_short");
      result = a1;
      break;
    case 0x47E:
      sub_140361800(a1, "v_mfd_movement_left_long");
      result = a1;
      break;
    case 0x47F:
      sub_140361800(a1, "v_mfd_movement_right_short");
      result = a1;
      break;
    case 0x480:
      sub_140361800(a1, "v_mfd_movement_right_long");
      result = a1;
      break;
    case 0x481:
      sub_140361800(a1, "v_mfd_soft_select_mfd_primary_short");
      result = a1;
      break;
    case 0x482:
      sub_140361800(a1, "v_mfd_soft_select_mfd_primary_long");
      result = a1;
      break;
    case 0x483:
      sub_140361800(a1, "v_mfd_soft_select_cast_left_short");
      result = a1;
      break;
    case 0x484:
      sub_140361800(a1, "v_mfd_soft_select_cast_left_long");
      result = a1;
      break;
    case 0x485:
      sub_140361800(a1, "v_mfd_soft_select_cast_right_short");
      result = a1;
      break;
    case 0x486:
      sub_140361800(a1, "v_mfd_soft_select_cast_right_long");
      result = a1;
      break;
    case 0x487:
      sub_140361800(a1, "v_mfd_soft_select_mfd_1_short");
      result = a1;
      break;
    case 0x488:
      sub_140361800(a1, "v_mfd_soft_select_mfd_1_long");
      result = a1;
      break;
    case 0x489:
      sub_140361800(a1, "v_mfd_soft_select_mfd_2_short");
      result = a1;
      break;
    case 0x48A:
      sub_140361800(a1, "v_mfd_soft_select_mfd_2_long");
      result = a1;
      break;
    case 0x48B:
      sub_140361800(a1, "v_mfd_soft_select_mfd_3_short");
      result = a1;
      break;
    case 0x48C:
      sub_140361800(a1, "v_mfd_soft_select_mfd_3_long");
      result = a1;
      break;
    case 0x48D:
      sub_140361800(a1, "v_mfd_soft_select_mfd_4_short");
      result = a1;
      break;
    case 0x48E:
      sub_140361800(a1, "v_mfd_soft_select_mfd_4_long");
      result = a1;
      break;
    case 0x48F:
      sub_140361800(a1, "v_mfd_soft_select_mfd_5_short");
      result = a1;
      break;
    case 0x490:
      sub_140361800(a1, "v_mfd_soft_select_mfd_5_long");
      result = a1;
      break;
    case 0x491:
      sub_140361800(a1, "v_mfd_soft_select_mfd_6_short");
      result = a1;
      break;
    case 0x492:
      sub_140361800(a1, "v_mfd_soft_select_mfd_6_long");
      result = a1;
      break;
    case 0x493:
      sub_140361800(a1, "v_mfd_soft_select_mfd_7_short");
      result = a1;
      break;
    case 0x494:
      sub_140361800(a1, "v_mfd_soft_select_mfd_7_long");
      result = a1;
      break;
    case 0x495:
      sub_140361800(a1, "v_mfd_soft_select_mfd_8_short");
      result = a1;
      break;
    case 0x496:
      sub_140361800(a1, "v_mfd_soft_select_mfd_8_long");
      result = a1;
      break;
    case 0x497:
      sub_140361800(a1, "v_mfd_soft_select_mfd_9_short");
      result = a1;
      break;
    case 0x498:
      sub_140361800(a1, "v_mfd_soft_select_mfd_9_long");
      result = a1;
      break;
    case 0x499:
      sub_140361800(a1, "v_mfd_soft_select_mfd_10_short");
      result = a1;
      break;
    case 0x49A:
      sub_140361800(a1, "v_mfd_soft_select_mfd_10_long");
      result = a1;
      break;
    case 0x49B:
      sub_140361800(a1, "v_mfd_hard_select_mfd_primary_short");
      result = a1;
      break;
    case 0x49C:
      sub_140361800(a1, "v_mfd_hard_select_mfd_primary_long");
      result = a1;
      break;
    case 0x49D:
      sub_140361800(a1, "v_mfd_hard_select_cast_left_short");
      result = a1;
      break;
    case 0x49E:
      sub_140361800(a1, "v_mfd_hard_select_cast_left_long");
      result = a1;
      break;
    case 0x49F:
      sub_140361800(a1, "v_mfd_hard_select_cast_right_short");
      result = a1;
      break;
    case 0x4A0:
      sub_140361800(a1, "v_mfd_hard_select_cast_right_long");
      result = a1;
      break;
    case 0x4A1:
      sub_140361800(a1, "v_mfd_hard_select_mfd_1_short");
      result = a1;
      break;
    case 0x4A2:
      sub_140361800(a1, "v_mfd_hard_select_mfd_1_long");
      result = a1;
      break;
    case 0x4A3:
      sub_140361800(a1, "v_mfd_hard_select_mfd_2_short");
      result = a1;
      break;
    case 0x4A4:
      sub_140361800(a1, "v_mfd_hard_select_mfd_2_long");
      result = a1;
      break;
    case 0x4A5:
      sub_140361800(a1, "v_mfd_hard_select_mfd_3_short");
      result = a1;
      break;
    case 0x4A6:
      sub_140361800(a1, "v_mfd_hard_select_mfd_3_long");
      result = a1;
      break;
    case 0x4A7:
      sub_140361800(a1, "v_mfd_hard_select_mfd_4_short");
      result = a1;
      break;
    case 0x4A8:
      sub_140361800(a1, "v_mfd_hard_select_mfd_4_long");
      result = a1;
      break;
    case 0x4A9:
      sub_140361800(a1, "v_mfd_hard_select_mfd_5_short");
      result = a1;
      break;
    case 0x4AA:
      sub_140361800(a1, "v_mfd_hard_select_mfd_5_long");
      result = a1;
      break;
    case 0x4AB:
      sub_140361800(a1, "v_mfd_hard_select_mfd_6_short");
      result = a1;
      break;
    case 0x4AC:
      sub_140361800(a1, "v_mfd_hard_select_mfd_6_long");
      result = a1;
      break;
    case 0x4AD:
      sub_140361800(a1, "v_mfd_hard_select_mfd_7_short");
      result = a1;
      break;
    case 0x4AE:
      sub_140361800(a1, "v_mfd_hard_select_mfd_7_long");
      result = a1;
      break;
    case 0x4AF:
      sub_140361800(a1, "v_mfd_hard_select_mfd_8_short");
      result = a1;
      break;
    case 0x4B0:
      sub_140361800(a1, "v_mfd_hard_select_mfd_8_long");
      result = a1;
      break;
    case 0x4B1:
      sub_140361800(a1, "v_mfd_hard_select_mfd_9_short");
      result = a1;
      break;
    case 0x4B2:
      sub_140361800(a1, "v_mfd_hard_select_mfd_9_long");
      result = a1;
      break;
    case 0x4B3:
      sub_140361800(a1, "v_mfd_hard_select_mfd_10_short");
      result = a1;
      break;
    case 0x4B4:
      sub_140361800(a1, "v_mfd_hard_select_mfd_10_long");
      result = a1;
      break;
    case 0x4B5:
      sub_140361800(a1, "v_mfd_select_view_self_status_short");
      result = a1;
      break;
    case 0x4B6:
      sub_140361800(a1, "v_mfd_select_view_self_status_long");
      result = a1;
      break;
    case 0x4B7:
      sub_140361800(a1, "v_mfd_select_view_target_status_short");
      result = a1;
      break;
    case 0x4B8:
      sub_140361800(a1, "v_mfd_select_view_target_status_long");
      result = a1;
      break;
    case 0x4B9:
      sub_140361800(a1, "v_mfd_select_view_scanning_short");
      result = a1;
      break;
    case 0x4BA:
      sub_140361800(a1, "v_mfd_select_view_scanning_long");
      result = a1;
      break;
    case 0x4BB:
      sub_140361800(a1, "v_mfd_select_view_configuration_short");
      result = a1;
      break;
    case 0x4BC:
      sub_140361800(a1, "v_mfd_select_view_configuration_long");
      result = a1;
      break;
    case 0x4BD:
      sub_140361800(a1, "v_mfd_select_view_comms_short");
      result = a1;
      break;
    case 0x4BE:
      sub_140361800(a1, "v_mfd_select_view_comms_long");
      result = a1;
      break;
    case 0x4BF:
      sub_140361800(a1, "v_mfd_select_view_ifcs_short");
      result = a1;
      break;
    case 0x4C0:
      sub_140361800(a1, "v_mfd_select_view_ifcs_long");
      result = a1;
      break;
    case 0x4C1:
      sub_140361800(a1, "v_mfd_select_view_diagnostics_short");
      result = a1;
      break;
    case 0x4C2:
      sub_140361800(a1, "v_mfd_select_view_diagnostics_long");
      result = a1;
      break;
    case 0x4C3:
      sub_140361800(a1, "v_mfd_select_view_resource_network_short");
      result = a1;
      break;
    case 0x4C4:
      sub_140361800(a1, "v_mfd_select_view_resource_network_long");
      result = a1;
      break;
    case 0x4C5:
      sub_140361800(a1, "simpod_scroll_up");
      result = a1;
      break;
    case 0x4C6:
      sub_140361800(a1, "simpod_scroll_down");
      result = a1;
      break;
    case 0x4C7:
      sub_140361800(a1, "mg_moveleft");
      result = a1;
      break;
    case 0x4C8:
      sub_140361800(a1, "mg_moveright");
      result = a1;
      break;
    case 0x4C9:
      sub_140361800(a1, "mg_moveup");
      result = a1;
      break;
    case 0x4CA:
      sub_140361800(a1, "mg_movedown");
      result = a1;
      break;
    case 0x4CB:
      sub_140361800(a1, "mg_fire1");
      result = a1;
      break;
    case 0x4CC:
      sub_140361800(a1, "mg_fire2");
      result = a1;
      break;
    case 0x4CD:
      sub_140361800(a1, "mg_exit");
      result = a1;
      break;
    default:
      sub_140361800(a1, "INVALID");
      result = a1;
      break;
  }
  return result;
}

// --- End Function: sub_140592FE0 (0x140592FE0) ---

// --- Function: sub_14059BE10 (0x14059BE10) ---
_QWORD *__fastcall sub_14059BE10(_QWORD *a1)
{
  *a1 = 0xFFFFFFFFFF676980uLL;
  return a1;
}

// --- End Function: sub_14059BE10 (0x14059BE10) ---

// --- Function: sub_14059BF00 (0x14059BF00) ---
bool __fastcall sub_14059BF00(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  bool result; // al
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF

  v5 = 0;
  result = 0;
  if ( (unsigned __int8)sub_14059CB00(a1, &v5) )
  {
    v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x2E8LL))(qword_149C8DFE0);
    v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0x38LL))(v2, 0);
    if ( (unsigned __int8)sub_14059CB00(v3, a1) )
      return 1;
  }
  return result;
}

// --- End Function: sub_14059BF00 (0x14059BF00) ---

// --- Function: sub_14059C4A0 (0x14059C4A0) ---
_QWORD *__fastcall sub_14059C4A0(_QWORD *a1, float a2, float a3)
{
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbx
  _QWORD *result; // rax
  _BYTE v10[8]; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v11[8]; // [rsp+28h] [rbp-30h] BYREF
  __int128 v12; // [rsp+30h] [rbp-28h]
  __int128 v13; // [rsp+40h] [rbp-18h]
  __int64 v14; // [rsp+60h] [rbp+8h] BYREF
  __int64 v15; // [rsp+78h] [rbp+20h] BYREF

  v13 = v3;
  v12 = v4;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x2E8LL))(qword_149C8DFE0);
  v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x38LL))(v6, 0);
  v14 = (unsigned int)(int)(float)(a2 * 10000000.0);
  v8 = sub_14059CA80(v7, v10, &v14);
  v15 = (unsigned int)(int)(float)((float)(sub_140572030().m128_f32[0] * a3) * 10000000.0);
  result = (_QWORD *)sub_14059CA80(v8, v11, &v15);
  *a1 = *result;
  return result;
}

// --- End Function: sub_14059C4A0 (0x14059C4A0) ---

// --- Function: sub_14059CA60 (0x14059CA60) ---
_QWORD *__fastcall sub_14059CA60(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_14059CA60 (0x14059CA60) ---

// --- Function: sub_14059CA80 (0x14059CA80) ---
_QWORD *__fastcall sub_14059CA80(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 + *a3;
  return a2;
}

// --- End Function: sub_14059CA80 (0x14059CA80) ---

// --- Function: sub_14059CAD0 (0x14059CAD0) ---
bool __fastcall sub_14059CAD0(_QWORD *a1, _QWORD *a2)
{
  return *a1 < *a2;
}

// --- End Function: sub_14059CAD0 (0x14059CAD0) ---

// --- Function: sub_14059CAE0 (0x14059CAE0) ---
bool __fastcall sub_14059CAE0(_QWORD *a1, _QWORD *a2)
{
  return *a1 <= *a2;
}

// --- End Function: sub_14059CAE0 (0x14059CAE0) ---

// --- Function: sub_14059CAF0 (0x14059CAF0) ---
bool __fastcall sub_14059CAF0(_QWORD *a1, _QWORD *a2)
{
  return *a1 > *a2;
}

// --- End Function: sub_14059CAF0 (0x14059CAF0) ---

// --- Function: sub_14059CB00 (0x14059CB00) ---
bool __fastcall sub_14059CB00(_QWORD *a1, _QWORD *a2)
{
  return *a1 >= *a2;
}

// --- End Function: sub_14059CB00 (0x14059CB00) ---

// --- Function: sub_14059CB30 (0x14059CB30) ---
_QWORD *__fastcall sub_14059CB30(_QWORD *a1, _QWORD *a2)
{
  *a1 -= *a2;
  return a1;
}

// --- End Function: sub_14059CB30 (0x14059CB30) ---

// --- Function: sub_14059CC00 (0x14059CC00) ---
__m128 sub_14059CC00()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_14059CC00 (0x14059CC00) ---

// --- Function: sub_1405A0C10 (0x1405A0C10) ---
void *sub_1405A0C10()
{
  return off_149A6BAF8;
}

// --- End Function: sub_1405A0C10 (0x1405A0C10) ---

// --- Function: sub_1405A0C20 (0x1405A0C20) ---
_QWORD **__fastcall sub_1405A0C20(_QWORD *a1)
{
  _QWORD **result; // rax
  _QWORD **v2; // r8
  _QWORD *i; // rdx
  _QWORD *v4; // rcx

  result = (_QWORD **)a1[2];
  if ( result[2] == a1 && !*((_BYTE *)a1 + 0x18) )
    return (_QWORD **)*a1;
  v2 = (_QWORD **)a1[1];
  if ( v2 )
  {
    for ( i = *v2; i; i = (_QWORD *)*i )
      v2 = (_QWORD **)i;
    return v2;
  }
  else if ( a1 == result[1] )
  {
    do
    {
      v4 = result;
      result = (_QWORD **)result[2];
    }
    while ( v4 == result[1] );
  }
  return result;
}

// --- End Function: sub_1405A0C20 (0x1405A0C20) ---

// --- Function: sub_1405A0C80 (0x1405A0C80) ---
__int64 __fastcall sub_1405A0C80(__int64 **n0x10_13, __int64 ***a2)
{
  __int64 *n0x10_9; // rdx
  __int64 n0x10_7; // rcx
  __int64 n0x10_3; // rdi
  __int64 *n0x10_8; // rax
  __int64 *n0x10_6; // rbx
  __int64 *n0x10_14; // rax
  __int64 *v10; // rax
  __int64 n0x10; // rax
  __int64 *v12; // rdx
  __int64 n0x10_1; // rcx
  __int64 *n0x10_2; // rcx
  __int64 *n0x10_4; // rdx
  __int64 *v16; // rax
  char v17; // cl
  __int64 *n0x10_10; // r8
  __int64 n0x10_5; // rcx
  __int64 *n0x10_15; // rcx
  __int64 *n0x10_11; // rdx
  __int64 v22; // rax
  __int64 **v23; // rax
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 **n0x10_16; // rcx
  __int64 **n0x10_12; // rdx
  __int64 **v28; // rax
  _BYTE *v29; // rdx
  __int64 v30; // rax
  __int64 v31; // rax

  n0x10_9 = (__int64 *)n0x10_13;
  n0x10_7 = (__int64)n0x10_13[1];
  if ( !n0x10_7 )
  {
    n0x10_3 = *n0x10_9;
    goto LABEL_8;
  }
  n0x10_9 = *n0x10_13;
  if ( !*n0x10_13 )
  {
    n0x10_8 = n0x10_13[2];
    n0x10_3 = n0x10_7;
    n0x10_6 = n0x10_8;
    goto LABEL_9;
  }
  for ( n0x10_14 = (__int64 *)n0x10_9[1]; n0x10_14; n0x10_14 = (__int64 *)n0x10_14[1] )
    n0x10_9 = n0x10_14;
  n0x10_3 = *n0x10_9;
  if ( n0x10_9 == (__int64 *)n0x10_13 )
  {
LABEL_8:
    n0x10_8 = (__int64 *)n0x10_9[2];
    n0x10_6 = n0x10_8;
    if ( !n0x10_3 )
    {
LABEL_10:
      if ( n0x10_13 == a2[2] )
      {
        a2[2] = (__int64 **)n0x10_3;
      }
      else
      {
        v10 = n0x10_13[2];
        if ( n0x10_13 == (__int64 **)v10[1] )
          v10[1] = n0x10_3;
        else
          *v10 = n0x10_3;
      }
      n0x10 = 0x10;
      v12 = (__int64 *)(n0x10_13 + 2);
      if ( n0x10_13 == a2[1] )
      {
        if ( *n0x10_13 && n0x10_3 )
        {
          n0x10 = *(_QWORD *)(n0x10_3 + 8);
          for ( n0x10_1 = n0x10_3; n0x10; n0x10 = *(_QWORD *)(n0x10 + 8) )
            n0x10_1 = n0x10;
          a2[1] = (__int64 **)n0x10_1;
        }
        else
        {
          n0x10 = *v12;
          a2[1] = (__int64 **)*v12;
        }
      }
      if ( n0x10_13 == *a2 )
      {
        if ( n0x10_13[1] && n0x10_3 )
        {
          n0x10_2 = *(__int64 **)n0x10_3;
          n0x10_4 = (__int64 *)n0x10_3;
          if ( *(_QWORD *)n0x10_3 )
          {
            do
            {
              n0x10 = *n0x10_2;
              n0x10_4 = n0x10_2;
              n0x10_2 = (__int64 *)n0x10;
            }
            while ( n0x10 );
          }
          *a2 = (__int64 **)n0x10_4;
        }
        else
        {
          n0x10 = *v12;
          *a2 = (__int64 **)*v12;
        }
      }
      goto LABEL_40;
    }
LABEL_9:
    *(_QWORD *)(n0x10_3 + 0x10) = n0x10_8;
    goto LABEL_10;
  }
  *(_QWORD *)(n0x10_7 + 0x10) = n0x10_9;
  n0x10_9[1] = (__int64)n0x10_13[1];
  if ( n0x10_9 == *n0x10_13 )
  {
    n0x10_6 = n0x10_9;
  }
  else
  {
    n0x10_6 = (__int64 *)n0x10_9[2];
    if ( n0x10_3 )
      *(_QWORD *)(n0x10_3 + 0x10) = n0x10_6;
    n0x10_6[1] = n0x10_3;
    *n0x10_9 = (__int64)*n0x10_13;
    (*n0x10_13)[2] = (__int64)n0x10_9;
  }
  if ( n0x10_13 == a2[2] )
  {
    a2[2] = (__int64 **)n0x10_9;
  }
  else
  {
    v16 = n0x10_13[2];
    if ( n0x10_13 == (__int64 **)v16[1] )
      v16[1] = (__int64)n0x10_9;
    else
      *v16 = (__int64)n0x10_9;
  }
  v17 = *((_BYTE *)n0x10_9 + 0x18);
  n0x10_9[2] = (__int64)n0x10_13[2];
  n0x10 = *((unsigned __int8 *)n0x10_13 + 0x18);
  *((_BYTE *)n0x10_9 + 0x18) = n0x10;
  *((_BYTE *)n0x10_13 + 0x18) = v17;
LABEL_40:
  if ( *((_BYTE *)n0x10_13 + 0x18) == 1 )
  {
    if ( (__int64 **)n0x10_3 != a2[2] )
    {
      do
      {
        n0x10_10 = n0x10_6;
        if ( n0x10_3 && *(_BYTE *)(n0x10_3 + 0x18) != 1 )
          goto LABEL_87;
        n0x10_5 = n0x10_6[1];
        if ( n0x10_3 == n0x10_5 )
        {
          n0x10_5 = *n0x10_6;
          if ( !*(_BYTE *)(*n0x10_6 + 0x18) )
          {
            *(_BYTE *)(n0x10_5 + 0x18) = 1;
            n0x10_15 = (__int64 *)*n0x10_6;
            *((_BYTE *)n0x10_6 + 0x18) = 0;
            n0x10_11 = (__int64 *)a2[2];
            *n0x10_6 = n0x10_15[1];
            v22 = n0x10_15[1];
            if ( v22 )
              *(_QWORD *)(v22 + 0x10) = n0x10_6;
            n0x10_15[2] = n0x10_6[2];
            if ( n0x10_6 == n0x10_11 )
            {
              n0x10_11 = n0x10_15;
            }
            else
            {
              v23 = (__int64 **)n0x10_6[2];
              if ( n0x10_6 == v23[1] )
                v23[1] = n0x10_15;
              else
                *v23 = n0x10_15;
            }
            n0x10_15[1] = (__int64)n0x10_6;
            n0x10_6[2] = (__int64)n0x10_15;
            a2[2] = (__int64 **)n0x10_11;
            n0x10_5 = *n0x10_6;
          }
          v24 = *(_QWORD *)(n0x10_5 + 8);
          v25 = v24;
          if ( v24 && *(_BYTE *)(v24 + 0x18) != 1 || (n0x10 = *(_QWORD *)n0x10_5) != 0 && *(_BYTE *)(n0x10 + 0x18) != 1 )
          {
            if ( !*(_QWORD *)n0x10_5 || *(_BYTE *)(*(_QWORD *)n0x10_5 + 0x18LL) == 1 )
            {
              *(_BYTE *)(v25 + 0x18) = 1;
              *(_BYTE *)(n0x10_5 + 0x18) = 0;
              a2[2] = (__int64 **)sub_1405A1370(n0x10_5, a2[2], n0x10_6);
              n0x10_5 = *n0x10_6;
            }
            *(_BYTE *)(n0x10_5 + 0x18) = *((_BYTE *)n0x10_6 + 0x18);
            *((_BYTE *)n0x10_6 + 0x18) = 1;
            if ( *(_QWORD *)n0x10_5 )
              *(_BYTE *)(*(_QWORD *)n0x10_5 + 0x18LL) = 1;
            n0x10 = sub_1405A1310(n0x10_6, a2[2], n0x10_10);
LABEL_85:
            a2[2] = (__int64 **)n0x10;
            break;
          }
        }
        else
        {
          if ( !*(_BYTE *)(n0x10_5 + 0x18) )
          {
            *(_BYTE *)(n0x10_5 + 0x18) = 1;
            n0x10_16 = (__int64 **)n0x10_6[1];
            *((_BYTE *)n0x10_6 + 0x18) = 0;
            n0x10_12 = a2[2];
            n0x10_6[1] = (__int64)*n0x10_16;
            if ( *n0x10_16 )
              (*n0x10_16)[2] = (__int64)n0x10_6;
            n0x10_16[2] = (__int64 *)n0x10_6[2];
            if ( n0x10_6 == (__int64 *)n0x10_12 )
            {
              n0x10_12 = n0x10_16;
            }
            else
            {
              v28 = (__int64 **)n0x10_6[2];
              if ( n0x10_6 == *v28 )
                *v28 = (__int64 *)n0x10_16;
              else
                v28[1] = (__int64 *)n0x10_16;
            }
            *n0x10_16 = n0x10_6;
            n0x10_6[2] = (__int64)n0x10_16;
            a2[2] = n0x10_12;
            n0x10_5 = n0x10_6[1];
          }
          v29 = (_BYTE *)(*(_QWORD *)n0x10_5 + 0x18LL);
          if ( *(_QWORD *)n0x10_5 && *v29 != 1
            || (n0x10 = *(_QWORD *)(n0x10_5 + 8)) != 0 && *(_BYTE *)(n0x10 + 0x18) != 1 )
          {
            v30 = *(_QWORD *)(n0x10_5 + 8);
            if ( !v30 || *(_BYTE *)(v30 + 0x18) == 1 )
            {
              *v29 = 1;
              *(_BYTE *)(n0x10_5 + 0x18) = 0;
              a2[2] = (__int64 **)sub_1405A1310(n0x10_5, a2[2], n0x10_6);
              n0x10_5 = n0x10_6[1];
            }
            *(_BYTE *)(n0x10_5 + 0x18) = *((_BYTE *)n0x10_6 + 0x18);
            *((_BYTE *)n0x10_6 + 0x18) = 1;
            v31 = *(_QWORD *)(n0x10_5 + 8);
            if ( v31 )
              *(_BYTE *)(v31 + 0x18) = 1;
            n0x10 = sub_1405A1370(n0x10_6, a2[2], n0x10_10);
            goto LABEL_85;
          }
        }
        *(_BYTE *)(n0x10_5 + 0x18) = 0;
        n0x10_3 = (__int64)n0x10_6;
        n0x10_6 = (__int64 *)n0x10_6[2];
      }
      while ( n0x10_10 != (__int64 *)a2[2] );
    }
    if ( n0x10_3 )
LABEL_87:
      *(_BYTE *)(n0x10_3 + 0x18) = 1;
  }
  return n0x10;
}

// --- End Function: sub_1405A0C80 (0x1405A0C80) ---

// --- Function: sub_1405A1070 (0x1405A1070) ---
_QWORD *__fastcall sub_1405A1070(_QWORD *a1)
{
  _QWORD *v1; // rdx
  _QWORD *result; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rcx

  v1 = (_QWORD *)*a1;
  result = a1;
  if ( *a1 )
  {
    v3 = (_QWORD *)v1[1];
    if ( v3 )
    {
      do
      {
        result = v3;
        v3 = (_QWORD *)v3[1];
      }
      while ( v3 );
    }
    else
    {
      return v1;
    }
  }
  else
  {
    v4 = (_QWORD *)a1[2];
    if ( result == (_QWORD *)*v4 )
    {
      do
      {
        result = v4;
        v4 = (_QWORD *)v4[2];
      }
      while ( result == (_QWORD *)*v4 );
      v1 = (_QWORD *)*result;
    }
    if ( v1 != v4 )
      return v4;
  }
  return result;
}

// --- End Function: sub_1405A1070 (0x1405A1070) ---

// --- Function: sub_1405A10C0 (0x1405A10C0) ---
__int64 __fastcall sub_1405A10C0(__int64 a1, _QWORD *a2, _QWORD *a3, int a4)
{
  __int64 result; // rax
  __int64 v6; // r10
  _QWORD *v7; // r9
  __int64 v8; // rdx
  __int64 v9; // rbx
  __int64 v10; // rcx
  _QWORD *v11; // rcx
  _QWORD *v12; // r8
  __int64 v13; // rcx
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  _QWORD *v17; // rcx
  _QWORD *v18; // r8
  _QWORD **v19; // rdx
  _QWORD *v20; // rcx
  __int64 v21; // rcx
  _QWORD *v22; // rcx

  result = 0;
  *(_QWORD *)(a1 + 0x10) = a2;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = a1;
  *(_BYTE *)(a1 + 0x18) = 0;
  if ( a4 )
  {
    *a2 = a1;
    if ( a2 != (_QWORD *)*a3 )
      goto LABEL_8;
    goto LABEL_7;
  }
  a2[1] = a1;
  if ( a2 == a3 )
  {
    a3[2] = a1;
LABEL_7:
    *a3 = a1;
    goto LABEL_8;
  }
  if ( a2 == (_QWORD *)a3[1] )
    a3[1] = a1;
LABEL_8:
  v7 = (_QWORD *)a3[2];
  if ( (_QWORD *)a1 != v7 )
  {
    while ( 1 )
    {
      v8 = *(_QWORD *)(v6 + 0x10);
      if ( *(_BYTE *)(v8 + 0x18) )
      {
LABEL_54:
        *((_BYTE *)v7 + 0x18) = 1;
        return result;
      }
      result = *(_QWORD *)(v8 + 0x10);
      v9 = v8 + 0x10;
      v10 = *(_QWORD *)(result + 8);
      if ( v8 == v10 )
      {
        v11 = *(_QWORD **)result;
        if ( !*(_QWORD *)result || *((_BYTE *)v11 + 0x18) )
        {
          if ( v8 )
          {
            v12 = *(_QWORD **)v8;
            if ( v6 == *(_QWORD *)v8 )
            {
              v6 = *(_QWORD *)(v6 + 0x10);
              *(_QWORD *)v8 = v12[1];
              v13 = v12[1];
              if ( v13 )
                *(_QWORD *)(v13 + 0x10) = v8;
              v12[2] = *(_QWORD *)v9;
              if ( (_QWORD *)v8 == v7 )
              {
                v7 = v12;
              }
              else
              {
                v14 = *(_QWORD **)v9;
                if ( v8 == *(_QWORD *)(*(_QWORD *)v9 + 8LL) )
                  v14[1] = v12;
                else
                  *v14 = v12;
              }
              v12[1] = v8;
              *(_QWORD *)v9 = v12;
              a3[2] = v7;
            }
          }
          *(_BYTE *)(*(_QWORD *)(v6 + 0x10) + 0x18LL) = 1;
          v15 = *(_QWORD **)(result + 8);
          *(_BYTE *)(result + 0x18) = 0;
          v16 = (_QWORD *)a3[2];
          *(_QWORD *)(result + 8) = *v15;
          if ( *v15 )
            *(_QWORD *)(*v15 + 0x10LL) = result;
          v15[2] = *(_QWORD *)(result + 0x10);
          if ( (_QWORD *)result == v16 )
          {
            v16 = v15;
            *v15 = result;
          }
          else
          {
            v17 = *(_QWORD **)(result + 0x10);
            if ( result == *v17 )
              *v17 = v15;
            else
              v17[1] = v15;
            *v15 = result;
          }
LABEL_52:
          *(_QWORD *)(result + 0x10) = v15;
          a3[2] = v16;
          goto LABEL_53;
        }
        *(_BYTE *)(v8 + 0x18) = 1;
        v6 = result;
        *((_BYTE *)v11 + 0x18) = 1;
        *(_BYTE *)(result + 0x18) = 0;
      }
      else
      {
        if ( !v10 || *(_BYTE *)(v10 + 0x18) )
        {
          v18 = *(_QWORD **)(v8 + 8);
          if ( (_QWORD *)v6 == v18 )
          {
            v6 = *(_QWORD *)(v6 + 0x10);
            *(_QWORD *)(v8 + 8) = *v18;
            v19 = (_QWORD **)(v8 + 0x10);
            if ( *v18 )
            {
              *(_QWORD *)(*v18 + 0x10LL) = v6;
              v19 = (_QWORD **)(v6 + 0x10);
            }
            v18[2] = *(_QWORD *)v9;
            if ( (_QWORD *)v6 == v7 )
            {
              v7 = v18;
            }
            else
            {
              v20 = *v19;
              if ( v6 == **v19 )
                *v20 = v18;
              else
                v20[1] = v18;
            }
            *v18 = v6;
            *v19 = v18;
            a3[2] = v7;
          }
          *(_BYTE *)(*(_QWORD *)(v6 + 0x10) + 0x18LL) = 1;
          v15 = *(_QWORD **)result;
          *(_BYTE *)(result + 0x18) = 0;
          v16 = (_QWORD *)a3[2];
          *(_QWORD *)result = v15[1];
          v21 = v15[1];
          if ( v21 )
            *(_QWORD *)(v21 + 0x10) = result;
          v15[2] = *(_QWORD *)(result + 0x10);
          if ( (_QWORD *)result == v16 )
          {
            v16 = v15;
          }
          else
          {
            v22 = *(_QWORD **)(result + 0x10);
            if ( result == v22[1] )
              v22[1] = v15;
            else
              *v22 = v15;
          }
          v15[1] = result;
          goto LABEL_52;
        }
        *(_BYTE *)(v8 + 0x18) = 1;
        v6 = result;
        *(_BYTE *)(v10 + 0x18) = 1;
        *(_BYTE *)(result + 0x18) = 0;
      }
LABEL_53:
      v7 = (_QWORD *)a3[2];
      if ( (_QWORD *)v6 == v7 )
        goto LABEL_54;
    }
  }
  *((_BYTE *)v7 + 0x18) = 1;
  return result;
}

// --- End Function: sub_1405A10C0 (0x1405A10C0) ---

// --- Function: sub_1405A1310 (0x1405A1310) ---
__int64 __fastcall sub_1405A1310(__int64 *n0x10, __int64 *n0x10_1, __int64 *a3)
{
  __int64 n0x10_3; // r8
  __int64 v4; // rax
  __int64 n0x10_2; // rax
  __int64 *v6; // rax

  n0x10_3 = *n0x10;
  *n0x10 = *(_QWORD *)(*n0x10 + 8);
  v4 = *(_QWORD *)(n0x10_3 + 8);
  if ( v4 )
    *(_QWORD *)(v4 + 0x10) = n0x10;
  *(_QWORD *)(n0x10_3 + 0x10) = n0x10[2];
  if ( n0x10 == n0x10_1 )
  {
    *(_QWORD *)(n0x10_3 + 8) = n0x10;
    n0x10_2 = n0x10_3;
    n0x10[2] = n0x10_3;
  }
  else
  {
    v6 = (__int64 *)n0x10[2];
    if ( n0x10 == (__int64 *)v6[1] )
      v6[1] = n0x10_3;
    else
      *v6 = n0x10_3;
    n0x10_2 = (__int64)n0x10_1;
    *(_QWORD *)(n0x10_3 + 8) = n0x10;
    n0x10[2] = n0x10_3;
  }
  return n0x10_2;
}

// --- End Function: sub_1405A1310 (0x1405A1310) ---

// --- Function: sub_1405A1370 (0x1405A1370) ---
_QWORD *__fastcall sub_1405A1370(__int64 n0x10, __int64 n0x10_1, __int64 *a3)
{
  _QWORD *n0x10_3; // r8
  _QWORD *n0x10_2; // rax
  _QWORD *v5; // rax

  n0x10_3 = *(_QWORD **)(n0x10 + 8);
  *(_QWORD *)(n0x10 + 8) = *n0x10_3;
  if ( *n0x10_3 )
    *(_QWORD *)(*n0x10_3 + 0x10LL) = n0x10;
  n0x10_3[2] = *(_QWORD *)(n0x10 + 0x10);
  if ( n0x10 == n0x10_1 )
  {
    *n0x10_3 = n0x10;
    n0x10_2 = n0x10_3;
    *(_QWORD *)(n0x10 + 0x10) = n0x10_3;
  }
  else
  {
    v5 = *(_QWORD **)(n0x10 + 0x10);
    if ( n0x10 == *v5 )
      *v5 = n0x10_3;
    else
      v5[1] = n0x10_3;
    n0x10_2 = (_QWORD *)n0x10_1;
    *n0x10_3 = n0x10;
    *(_QWORD *)(n0x10 + 0x10) = n0x10_3;
  }
  return n0x10_2;
}

// --- End Function: sub_1405A1370 (0x1405A1370) ---

// --- Function: sub_1405A9140 (0x1405A9140) ---
__int64 __fastcall sub_1405A9140(__int64 a1)
{
  unsigned __int64 v1; // rax
  _QWORD *v2; // rdi
  unsigned __int64 v3; // rax
  __int64 v4; // rbx
  bool v5; // al
  __int64 v6; // rax

  v1 = *(_QWORD *)(a1 + 0x28);
  v2 = (_QWORD *)(a1 + 0x28);
  if ( !v1 )
    return 0xFFFFFFFFLL;
  v3 = HIWORD(v1);
  if ( (v3 & 0xF000) != 0 )
    v4 = *(_QWORD *)(a1 + 0x28) & 0xFFFFFF000000LL;
  else
    v4 = (*(_QWORD *)(a1 + 0x28) & 0xFFFFFFFFFFFFLL) - 6;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v5 = is_thread_privileged_or_bypass_mode()) )
    v5 = 1;
  if ( (*(_WORD *)(v4 + 4) == 2 && v5 || sub_140395410(v2))
    && (v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*v2 & 0xFFFFFFFFFFFFLL) + 0x668LL))(*v2 & 0xFFFFFFFFFFFFLL)) != 0 )
  {
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x1F8LL))(v6);
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

// --- End Function: sub_1405A9140 (0x1405A9140) ---

// --- Function: sub_1405B53B0 (0x1405B53B0) ---
bool __fastcall sub_1405B53B0(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a1 == *(_QWORD *)a2
      && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(_QWORD *)(a1 + 0x10) == *(_QWORD *)(a2 + 0x10);
}

// --- End Function: sub_1405B53B0 (0x1405B53B0) ---

// --- Function: sub_1405B5980 (0x1405B5980) ---
__int64 __fastcall sub_1405B5980(__int64 a1, __int64 a2)
{
  size_t n0x1FF; // rbx
  Location **p_UNDEFINED; // r9

  *(_BYTE *)(a2 + 0x18) = 0;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_QWORD *)a2 = 0;
  n0x1FF = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a2 + 8) = 0x1FF;
  do
    ++n0x1FF;
  while ( aInvalid_0[n0x1FF] );
  if ( n0x1FF )
  {
    sub_1402A63B0((__int64 *)a2, n0x1FF);
    memcpy(*(void **)(a2 + 0x10), "INVALID", n0x1FF);
  }
  if ( *(_QWORD *)a1 && *(_DWORD *)(a1 + 8) != 9 )
  {
    switch ( *(_DWORD *)(a1 + 8) )
    {
      case 0:
        p_UNDEFINED = "Container";
        break;
      case 1:
        p_UNDEFINED = "Debug";
        break;
      case 2:
        p_UNDEFINED = "Entitlement";
        break;
      case 3:
        p_UNDEFINED = "Location";
        break;
      case 4:
        p_UNDEFINED = "PlayerInventory";
        break;
      case 5:
        p_UNDEFINED = "Prison";
        break;
      case 6:
        p_UNDEFINED = "PersonalEntityInventory";
        break;
      case 7:
        p_UNDEFINED = "Hangar";
        break;
      case 8:
        p_UNDEFINED = "Undefined";
        break;
      default:
        p_UNDEFINED = "UNDEFINED";
        break;
    }
    sub_1402A59F0(a2, "%llu:%s:%llu", *(_QWORD *)a1, p_UNDEFINED, *(_QWORD *)(a1 + 0x10));
  }
  return a2;
}

// --- End Function: sub_1405B5980 (0x1405B5980) ---

// --- Function: LogFatalError (0x1405C60F0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149C8DEA0;
  if ( !qword_149C8DEA0 )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&qword_149C8DEA0);
    v1 = (__int64 (*)(void))qword_149C8DEA0;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149C8E0F8 || !qword_149C8DFE0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A6BE0();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149C8DFE0 + 0x118LL))(
                      qword_149C8DFE0,
                      &format_string_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C60F0) ---

// --- Function: sub_1405C6220 (0x1405C6220) ---
__int64 sub_1405C6220(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149C8E0F8 && qword_149C8DFE0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149C8DFE0 + 0x158LL))(
               qword_149C8DFE0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C6220 (0x1405C6220) ---

// --- Function: sub_1405C6400 (0x1405C6400) ---
unsigned __int64 __fastcall sub_1405C6400(__int64 a1)
{
  sub_14052A480(a1, "transform_zs");
  return sub_14052A3D0(a1);
}

// --- End Function: sub_1405C6400 (0x1405C6400) ---

// --- Function: sub_1405CC240 (0x1405CC240) ---
char __fastcall sub_1405CC240(_QWORD *a1, _BYTE *a2, int *a3)
{
  char result; // al

  result = sub_14048D530(a1, a2);
  if ( result )
  {
    sub_140492950((__int64)a1, *a3);
    return sub_140387CB0((__int64)a1, (__int64)&unk_1482C0F54);
  }
  return result;
}

// --- End Function: sub_1405CC240 (0x1405CC240) ---

// --- Function: sub_1405CCF40 (0x1405CCF40) ---
__int64 __fastcall sub_1405CCF40(__int64 a1, _BYTE *a2)
{
  size_t Size; // rbx

  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0xFF;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( Size )
  {
    sub_1405DE3D0(a1, Size);
    memcpy(*(void **)(a1 + 0x10), a2, Size);
  }
  return a1;
}

// --- End Function: sub_1405CCF40 (0x1405CCF40) ---

// --- Function: sub_1405CCFD0 (0x1405CCFD0) ---
__int64 __fastcall sub_1405CCFD0(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  result = a1;
  *(_QWORD *)(a1 + 8) = 0x3F;
  return result;
}

// --- End Function: sub_1405CCFD0 (0x1405CCFD0) ---

// --- Function: sub_1405CEDF0 (0x1405CEDF0) ---
__int64 __fastcall sub_1405CEDF0(__int64 a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // rax
  const void *v3; // rcx

  result = a1 + 0x18;
  if ( *(_QWORD *)(a1 + 0x10) != a1 + 0x18 )
  {
    v2 = 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
    v3 = *(const void **)(a1 + 0x10);
    qword_149C8EBB0 += v2;
    return sub_147715880(v3);
  }
  return result;
}

// --- End Function: sub_1405CEDF0 (0x1405CEDF0) ---

// --- Function: sub_1405CF3F0 (0x1405CF3F0) ---
__int64 __fastcall sub_1405CF3F0(__int64 a1, _BYTE *a2)
{
  size_t Size; // rbx
  char *v5; // r14
  size_t Size_1; // r15
  unsigned __int64 v7; // r12
  unsigned __int64 n8; // rdx
  __int64 v9; // rax

  if ( a2 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a2[Size] );
    if ( Size )
    {
      v5 = *(char **)(a1 + 0x10);
      Size_1 = *(_QWORD *)a1;
      v7 = *(_QWORD *)a1 + Size;
      if ( v7 <= *(_QWORD *)(a1 + 8) )
      {
        memcpy(&v5[Size_1], a2, Size);
        *(_QWORD *)a1 += Size;
        *(_BYTE *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 0x10)) = 0;
      }
      else
      {
        n8 = 2 * Size_1;
        if ( 2 * Size_1 <= v7 )
          n8 = *(_QWORD *)a1 + Size;
        if ( n8 )
        {
          if ( n8 < 8 )
            n8 = 8;
          sub_1405DE3D0(a1, n8);
          memcpy(*(void **)(a1 + 0x10), v5, Size_1);
          memcpy((void *)(Size_1 + *(_QWORD *)(a1 + 0x10)), a2, Size);
          v9 = *(_QWORD *)(a1 + 0x10);
          *(_QWORD *)a1 = v7;
          *(_BYTE *)(Size_1 + Size + v9) = 0;
        }
        if ( v5 != (char *)(a1 + 0x18) )
        {
          qword_149C8EBB0 += 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
          sub_147715880(v5);
        }
      }
    }
  }
  return a1;
}

// --- End Function: sub_1405CF3F0 (0x1405CF3F0) ---

// --- Function: sub_1405D40E0 (0x1405D40E0) ---
__int64 sub_1405D40E0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n0x3F_1; // rbx
  size_t n0x3F_2; // rax
  const void *v7; // rcx
  _BYTE *v8; // rsi
  __int64 n0x3F; // rax
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 result; // rax
  char Buffer[4096]; // [rsp+40h] [rbp-1038h] BYREF
  va_list va; // [rsp+1090h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n0x3F_1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0x3F_1;
  while ( Buffer[n0x3F_1] );
  n0x3F_2 = *(_QWORD *)(a1 + 8);
  if ( n0x3F_1 > n0x3F_2 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149C850A8 += 0xFFFFFFFFFFFFFFFFuLL - n0x3F_2;
      sub_147715880(v7);
    }
    *v8 = 0;
    n0x3F = 0x3F;
    *(_QWORD *)(a1 + 8) = 0x3F;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    if ( n0x3F_1 )
    {
      if ( n0x3F_1 + 1 > 0x40 )
      {
        v10 = allocWithProfilerInfo(n0x3F_1 + 1, 0);
        qword_149C850A8 += n0x3F_1 + 1;
        v8 = (_BYTE *)v10;
        n0x3F = n0x3F_1;
      }
      *(_QWORD *)(a1 + 8) = n0x3F;
      *(_QWORD *)(a1 + 0x10) = v8;
      v8[n0x3F_1] = 0;
    }
  }
  memmove(*(void **)(a1 + 0x10), Buffer, n0x3F_1);
  v11 = *(_QWORD *)(a1 + 0x10);
  result = a1;
  *(_QWORD *)a1 = n0x3F_1;
  *(_BYTE *)(n0x3F_1 + v11) = 0;
  return result;
}

// --- End Function: sub_1405D40E0 (0x1405D40E0) ---

// --- Function: sub_1405DE3D0 (0x1405DE3D0) ---
_BYTE *__fastcall sub_1405DE3D0(__int64 *a1, __int64 n0xFF_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0xFF; // rcx

  result = a1 + 3;
  if ( n0xFF_1 )
  {
    allocSize = n0xFF_1 + 1;
    if ( (unsigned __int64)(n0xFF_1 + 1) <= 0x100 )
    {
      n0xFF = 0xFF;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149C8EBB0 += allocSize;
      n0xFF = n0xFF_1;
    }
    a1[1] = n0xFF;
    *a1 = n0xFF_1;
    a1[2] = (__int64)result;
    result[n0xFF_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0xFF;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1405DE3D0 (0x1405DE3D0) ---

// --- Function: sub_1405DE870 (0x1405DE870) ---
__int64 __fastcall sub_1405DE870(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 v5; // rdi

  *(_QWORD *)a2 = a1;
  v2 = a1 + 0x10;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_QWORD *)(a2 + 8) = a1 + 0x10;
  *(_DWORD *)(a2 + 0x18) = 1;
  if ( *(_DWORD *)(a1 + 0x20) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v2 + 0x14);
    return a2;
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)v2);
    if ( (v5 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v2, v5, (const char *)&p_Src, (const char *)&p_Src, 1);
    return a2;
  }
}

// --- End Function: sub_1405DE870 (0x1405DE870) ---

// --- Function: sub_1405F1730 (0x1405F1730) ---
char *__fastcall sub_1405F1730(void **a1, char *a2, unsigned __int64 a3)
{
  char *v3; // rdi
  char *v7; // rdi
  char *result; // rax
  unsigned __int64 v9; // rbp
  char *v10; // rdi
  __int64 v11; // rbx

  v3 = (char *)*a1;
  if ( a3 <= ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3 )
  {
    v9 = ((_BYTE *)a1[1] - v3) >> 3;
    if ( a3 <= v9 )
    {
      v11 = 8 * a3;
      memmove(v3, a2, 8 * a3);
      result = &v3[v11];
    }
    else
    {
      memmove(v3, a2, 8 * v9);
      v10 = (char *)a1[1];
      memmove(v10, &a2[8 * v9], 8 * (a3 - v9));
      result = &v10[8 * (a3 - v9)];
    }
    a1[1] = result;
  }
  else
  {
    sub_1407EDF30(a1, a3);
    v7 = (char *)*a1;
    memmove(*a1, a2, 8 * a3);
    result = &v7[8 * a3];
    a1[1] = result;
  }
  return result;
}

// --- End Function: sub_1405F1730 (0x1405F1730) ---

// --- Function: sub_1405F1C30 (0x1405F1C30) ---
unsigned __int64 __fastcall sub_1405F1C30(unsigned __int64 *a1, __int64 a2)
{
  double *v2; // rsi
  unsigned __int64 v4; // r8
  unsigned __int64 result; // rax
  __int64 v7; // rdi
  __int64 v8; // r15
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  char *v12; // rax
  unsigned __int64 v13; // r14
  double *v14; // r15
  void *v15; // rcx
  unsigned __int64 v16; // r8
  const void *v17; // rdx
  size_t Size; // r8

  v2 = (double *)a1[1];
  v4 = a1[2];
  if ( v2 == (double *)v4 )
  {
    v7 = 0xAAAAAAAAAAAAAAALL;
    v8 = (__int64)((__int64)v2 - *a1) / 0x18;
    if ( v8 == 0xAAAAAAAAAAAAAAALL )
      unknown_libname_10();
    v9 = v8 + 1;
    v10 = (__int64)(v4 - *a1) / 0x18;
    v11 = v10 >> 1;
    if ( v10 <= 0xAAAAAAAAAAAAAAALL - (v10 >> 1) )
    {
      v7 = v11 + v10;
      if ( v11 + v10 < v9 )
        v7 = v8 + 1;
    }
    v12 = (char *)sub_140394E70((__int64)a1, 0x18 * v7);
    v13 = (unsigned __int64)v12;
    *(_OWORD *)&v12[0x18 * v8] = *(_OWORD *)a2;
    v14 = (double *)&v12[0x18 * v8];
    v15 = v12;
    v14[2] = *(double *)(a2 + 0x10);
    v16 = a1[1];
    v17 = (const void *)*a1;
    if ( v2 == (double *)v16 )
    {
      Size = v16 - (_QWORD)v17;
    }
    else
    {
      memmove(v12, v17, (char *)v2 - (_BYTE *)v17);
      v15 = v14 + 3;
      Size = a1[1] - (_QWORD)v2;
      v17 = v2;
    }
    memmove(v15, v17, Size);
    sub_1403351C0(a1, v13, v9, v7);
    return (unsigned __int64)v14;
  }
  else
  {
    *(_OWORD *)v2 = *(_OWORD *)a2;
    v2[2] = *(double *)(a2 + 0x10);
    result = a1[1];
    a1[1] = result + 0x18;
  }
  return result;
}

// --- End Function: sub_1405F1C30 (0x1405F1C30) ---

// --- Function: ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QEAAAEAV01@_N@Z (0x140624A90) ---
int **__fastcall std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int>>>::operator=(int **this, bool _Val)
{
  int *v2; // r8
  int v3; // r9d
  int v4; // eax

  v2 = *this;
  v3 = *((_DWORD *)this + 2);
  v4 = **this;
  if ( _Val )
    *v2 = v4 | (1 << v3);
  else
    *v2 = v4 & ~(1 << v3);
  return this;
}

// --- End Function: ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QEAAAEAV01@_N@Z (0x140624A90) ---

// --- Function: sub_1406279E0 (0x1406279E0) ---
_QWORD *__fastcall sub_1406279E0(__int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rcx
  _QWORD *result; // rax

  v3 = *a1;
  a2[1] = a3 & 0x1F;
  v4 = v3 + 4 * (a3 >> 5);
  result = a2;
  *a2 = v4;
  return result;
}

// --- End Function: sub_1406279E0 (0x1406279E0) ---

// --- Function: sub_140627B40 (0x140627B40) ---
bool __fastcall sub_140627B40(__int64 a1)
{
  return ((1 << *(_QWORD *)(a1 + 8)) & **(_DWORD **)a1) != 0;
}

// --- End Function: sub_140627B40 (0x140627B40) ---

// --- Function: sub_140627B80 (0x140627B80) ---
__int64 **__fastcall sub_140627B80(__int64 **a1)
{
  __int64 *v1; // rdx
  __int64 *v4; // rcx
  __int64 *v5; // rax
  __int64 *v6; // rcx
  __int64 *v7; // r9
  __int64 *i; // rax

  v1 = *a1;
  if ( *((_BYTE *)*a1 + 0x19) )
  {
    *a1 = (__int64 *)v1[2];
    return a1;
  }
  v4 = (__int64 *)*v1;
  if ( *(_BYTE *)(*v1 + 0x19) )
  {
    v5 = (__int64 *)v1[1];
    if ( !*((_BYTE *)v5 + 0x19) )
    {
      v6 = v1;
      v7 = v1;
      do
      {
        v1 = v7;
        if ( v6 != (__int64 *)*v5 )
          break;
        v6 = v5;
        *a1 = v5;
        v5 = (__int64 *)v5[1];
        v7 = v6;
        v1 = v6;
      }
      while ( !*((_BYTE *)v5 + 0x19) );
    }
    if ( !*((_BYTE *)v1 + 0x19) )
    {
      *a1 = v5;
      return a1;
    }
  }
  else
  {
    for ( i = (__int64 *)v4[2]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[2] )
      v4 = i;
    *a1 = v4;
  }
  return a1;
}

// --- End Function: sub_140627B80 (0x140627B80) ---

// --- Function: sub_140718D50 (0x140718D50) ---
__int64 __fastcall sub_140718D50(unsigned __int64 *a1, __int64 a2)
{
  float v22[14]; // [rsp+20h] [rbp-38h] BYREF

  _XMM0 = *a1;
  _XMM1 = a1[1];
  __asm { vcvtpd2ps xmm0, xmm0 }
  v22[0] = *(float *)&_XMM0;
  _XMM0 = a1[2];
  __asm
  {
    vcvtpd2ps xmm0, xmm0
    vcvtpd2ps xmm1, xmm1
  }
  v22[2] = *(float *)&_XMM0;
  _XMM0 = a1[5];
  v22[1] = *(float *)&_XMM1;
  _XMM1 = a1[4];
  __asm
  {
    vcvtpd2ps xmm0, xmm0
    vcvtpd2ps xmm1, xmm1
  }
  v22[4] = *(float *)&_XMM0;
  _XMM0 = a1[8];
  v22[3] = *(float *)&_XMM1;
  _XMM1 = a1[6];
  __asm
  {
    vcvtpd2ps xmm0, xmm0
    vcvtpd2ps xmm1, xmm1
  }
  v22[6] = *(float *)&_XMM0;
  _XMM0 = a1[0xA];
  v22[5] = *(float *)&_XMM1;
  _XMM1 = a1[9];
  __asm
  {
    vcvtpd2ps xmm0, xmm0
    vcvtpd2ps xmm1, xmm1
  }
  v22[8] = *(float *)&_XMM0;
  v22[7] = *(float *)&_XMM1;
  sub_140404C10(a2, v22);
  return a2;
}

// --- End Function: sub_140718D50 (0x140718D50) ---

// --- Function: sub_1407EDF30 (0x1407EDF30) ---
unsigned __int64 __fastcall sub_1407EDF30(unsigned __int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // r9
  unsigned __int64 allocSize; // rbx
  __int64 v8; // rax
  unsigned __int64 result; // rax

  v2 = 0x1FFFFFFFFFFFFFFFLL;
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v4 = *a1;
  v5 = (__int64)(a1[2] - v4) >> 3;
  v6 = v5 >> 1;
  if ( v5 <= 0x1FFFFFFFFFFFFFFFLL - (v5 >> 1) )
  {
    v2 = v6 + v5;
    if ( v6 + v5 < a2 )
      v2 = a2;
  }
  if ( v4 )
  {
    sub_1403A6820((__int64)a1, v4, 8 * v5);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  allocSize = 8 * v2;
  v8 = sub_140394E70((__int64)a1, allocSize);
  *a1 = v8;
  a1[1] = v8;
  result = allocSize + v8;
  a1[2] = result;
  return result;
}

// --- End Function: sub_1407EDF30 (0x1407EDF30) ---

// --- Function: sub_1408000B0 (0x1408000B0) ---
__int64 __fastcall sub_1408000B0(volatile __int32 *a1, unsigned __int32 a2)
{
  _InterlockedExchange(a1, a2);
  return a2;
}

// --- End Function: sub_1408000B0 (0x1408000B0) ---

// --- Function: sub_14084B650 (0x14084B650) ---
float *__fastcall sub_14084B650(float *a1, float *a2, float *a3, _DWORD *a4, float Y)
{
  __int128 v6; // kr00_16
  __int128 v9; // kr00_16
  __int128 v12; // xmm12
  __int128 v14; // kr00_16
  int v15; // xmm14_4
  __int128 v17; // kr00_16
  float v19; // xmm7_4
  float v22; // xmm9_4
  float v23; // xmm11_4
  float *result; // rax
  int v26; // [rsp+C0h] [rbp+8h]
  int v27; // [rsp+C8h] [rbp+10h]
  int v28; // [rsp+D0h] [rbp+18h]
  float v29; // [rsp+D8h] [rbp+20h]

  v26 = a4[3] & 0x7FFFFFFF;
  v6 = *((unsigned int *)a3 + 2);
  *(float *)&v6 = a3[2] - a2[2];
  _XMM3 = v6;
  v9 = *((unsigned int *)a3 + 3);
  *(float *)&v9 = a3[3] - a2[3];
  _XMM6 = v9;
  v12 = *((unsigned int *)a3 + 1);
  v14 = v12;
  *(float *)&v14 = *(float *)&v12 - a2[1];
  _XMM2 = v14;
  v15 = *a4 & 0x7FFFFFFF;
  v17 = *(unsigned int *)a3;
  *(float *)&v17 = *a3 - *a2;
  _XMM0 = v17;
  __asm { vmaxss  xmm0, xmm0, xmm4 }
  v19 = (float)((float)(1.6666666 / *(float *)&_XMM0) * *(float *)&v15) * *a2;
  __asm { vmaxss  xmm0, xmm2, xmm4 }
  __asm { vmaxss  xmm2, xmm3, xmm4 }
  v27 = a4[1] & 0x7FFFFFFF;
  v22 = (float)((float)(1.6666666 / *(float *)&_XMM0) * *(float *)&v27) * a2[1];
  v23 = (float)((float)(1.6666666 / *(float *)&_XMM2) * COERCE_FLOAT(a4[2] & 0x7FFFFFFF)) * a2[2];
  __asm { vmaxss  xmm1, xmm6, xmm4 }
  v28 = a4[2] & 0x7FFFFFFF;
  v29 = (float)((float)(1.6666666 / *(float *)&_XMM1) * *(float *)&v26) * a2[3];
  *(float *)&_XMM6 = (float)(powf(*a3, Y) * (float)(*(float *)&v15 + v19)) * 1.0471976;
  *a1 = *(float *)&_XMM6 - (float)((float)(powf(*a2, Y) * v19) * 1.0471976);
  *(float *)&_XMM6 = (float)(powf(*(float *)&v12, Y) * (float)(v22 + *(float *)&v27)) * 1.0471976;
  *(float *)&v17 = powf(a2[1], Y) * v22;
  *(float *)&_XMM0 = a3[2];
  a1[1] = *(float *)&_XMM6 - (float)(*(float *)&v17 * 1.0471976);
  *(float *)&_XMM6 = (float)(powf(*(float *)&_XMM0, Y) * (float)(v23 + *(float *)&v28)) * 1.0471976;
  *(float *)&v17 = powf(a2[2], Y) * v23;
  *(float *)&_XMM0 = a3[3];
  a1[2] = *(float *)&_XMM6 - (float)(*(float *)&v17 * 1.0471976);
  *(float *)&v17 = (float)(powf(*(float *)&_XMM0, Y) * (float)(v29 + *(float *)&v26)) * 1.0471976;
  *(float *)&_XMM0 = powf(a2[3], Y);
  result = a1;
  a1[3] = *(float *)&v17 - (float)((float)(*(float *)&_XMM0 * v29) * 1.0471976);
  return result;
}

// --- End Function: sub_14084B650 (0x14084B650) ---

// --- Function: sub_140850F90 (0x140850F90) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_140850F90(int a1, __int64 a2, char n2, double a4, float a5, float a6, float a7, int a8)
{
  __int128 v8; // xmm6
  __int128 v9; // xmm7
  __int128 v10; // xmm8
  __int128 v11; // xmm9
  __int128 v12; // xmm10
  __int128 v13; // xmm11
  __int128 v14; // xmm12
  __int128 v15; // xmm13
  __int128 v16; // xmm14
  __int128 v17; // xmm15
  float v23; // xmm7_4
  __int64 v25; // rax
  float *v26; // rax
  int v27; // r9d
  float *v28; // rbx
  float v29; // xmm2_4
  float v30; // xmm3_4
  float v31; // xmm4_4
  float v32; // xmm5_4
  float v33; // xmm10_4
  float v34; // xmm11_4
  float v35; // xmm12_4
  float v36; // xmm13_4
  float v37; // xmm14_4
  float v38; // xmm15_4
  float v39; // xmm0_4
  float v42; // xmm14_4
  float v43; // xmm11_4
  float v44; // xmm12_4
  float v45; // xmm13_4
  float v46; // xmm0_4
  float v47; // xmm2_4
  __int128 v49; // kr00_16
  int v53; // [rsp+48h] [rbp-C0h] BYREF
  float v54; // [rsp+4Ch] [rbp-BCh]
  float v55; // [rsp+50h] [rbp-B8h]
  float v56; // [rsp+54h] [rbp-B4h]
  float v57; // [rsp+58h] [rbp-B0h]
  float v58; // [rsp+5Ch] [rbp-ACh]
  float v59; // [rsp+60h] [rbp-A8h]
  float v60; // [rsp+64h] [rbp-A4h]
  float v61; // [rsp+68h] [rbp-A0h]
  float v62; // [rsp+6Ch] [rbp-9Ch]
  float v63; // [rsp+70h] [rbp-98h]
  _QWORD v64[3]; // [rsp+74h] [rbp-94h]
  int v65; // [rsp+8Ch] [rbp-7Ch]
  __int64 v66; // [rsp+90h] [rbp-78h]
  float v67; // [rsp+98h] [rbp-70h]
  float v68; // [rsp+9Ch] [rbp-6Ch]
  float v69; // [rsp+A0h] [rbp-68h]
  int v70; // [rsp+A4h] [rbp-64h]
  int n0x900; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v72; // [rsp+ACh] [rbp-5Ch]
  int v73; // [rsp+B4h] [rbp-54h]
  unsigned __int64 v74; // [rsp+B8h] [rbp-50h]
  unsigned __int64 v75; // [rsp+C0h] [rbp-48h]
  __int64 v76; // [rsp+C8h] [rbp-40h]
  __int64 v77; // [rsp+D0h] [rbp-38h]
  __int128 v78; // [rsp+F8h] [rbp-10h]
  __int128 v79; // [rsp+108h] [rbp+0h]
  __int128 v80; // [rsp+118h] [rbp+10h]
  __int128 v81; // [rsp+128h] [rbp+20h]
  __int128 v82; // [rsp+138h] [rbp+30h]
  __int128 v83; // [rsp+148h] [rbp+40h]
  __int128 v84; // [rsp+158h] [rbp+50h]
  __int128 v85; // [rsp+168h] [rbp+60h]
  __int128 v86; // [rsp+178h] [rbp+70h]
  __int128 v87; // [rsp+188h] [rbp+80h]
  float v88; // [rsp+1D0h] [rbp+C8h]
  float v89; // [rsp+1D8h] [rbp+D0h]
  float v90; // [rsp+1E8h] [rbp+E0h]
  float v91; // [rsp+1F0h] [rbp+E8h]
  float v92; // [rsp+200h] [rbp+F8h]

  v87 = v8;
  v86 = v9;
  v85 = v10;
  v84 = v11;
  v83 = v12;
  v82 = v13;
  v81 = v14;
  v80 = v15;
  v79 = v16;
  v78 = v17;
  _XMM9 = *(_OWORD *)&a4;
  n0x900 = 0x900;
  v72 = 0;
  v73 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v74 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFA8,
    "CDamageMap::MT_CalculateWeaponDamage",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xEA);
  HIWORD(n0x900) = word_149D7FFA8;
  v66 = 0;
  LOBYTE(v53) = n2;
  v70 = a8;
  _XMM6 = LODWORD(a5);
  v23 = a6;
  *(_OWORD *)&v64[1] = xmmword_148341EA0;
  v65 = dword_149D7FEA0;
  v67 = 0.0;
  v68 = 0.0;
  v69 = 0.0;
  if ( n2 == 1 && (a6 < 0.001 || a5 < 0.001) )
  {
    __asm { vmaxss  xmm0, xmm6, xmm7 }
    v23 = *(float *)&_XMM0 * 0.5;
    *(float *)&_XMM6 = *(float *)&_XMM0 * 0.5;
  }
  v25 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))(qword_149C8E018);
  v26 = (float *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x10LL))(v25);
  v28 = v26;
  if ( n2 == 2 )
  {
    v29 = v26[0x2A];
    v30 = v26[0x2B];
    v31 = v26[0x2C];
    v32 = v26[0x2D];
    v33 = v26[0x30];
    v34 = v26[0x31];
    v35 = v26[0x32];
    v36 = v26[0x33];
    v37 = v26[0x36];
    v38 = v26[0x37];
    v89 = v26[0x38];
    v91 = v26[0x39];
    v90 = v26[0x3C];
    v92 = v26[0x3D];
    v88 = v26[0x3E];
    v39 = v26[0x3F];
  }
  else
  {
    v29 = v26[8];
    v30 = v26[9];
    v31 = v26[0xA];
    v32 = v26[0xB];
    v33 = v26[0xE];
    v34 = v26[0xF];
    v35 = v26[0x10];
    v36 = v26[0x11];
    v37 = v26[0x14];
    v38 = v26[0x15];
    v89 = v26[0x16];
    v91 = v26[0x17];
    v90 = v26[0x1A];
    v92 = v26[0x1B];
    v88 = v26[0x1C];
    v39 = v26[0x1D];
  }
  __asm { vcmpltss xmm1, xmm9, cs:dword_1482BB398 }
  __asm { vblendvps xmm9, xmm9, xmm0, xmm1 }
  v58 = v37 * *(float *)&_XMM9;
  v60 = *(float *)&_XMM9 * v89;
  v62 = *(float *)&_XMM9 * v90;
  *(float *)v64 = *(float *)&_XMM9 * v88;
  v59 = v38 * *(float *)&_XMM9;
  v61 = *(float *)&_XMM9 * v91;
  v63 = *(float *)&_XMM9 * v92;
  v42 = (float)(v29 * *(float *)&_XMM6) + (float)(v33 * v23);
  *((float *)v64 + 1) = *(float *)&_XMM9 * v39;
  v43 = (float)(v30 * *(float *)&_XMM6) + (float)(v34 * v23);
  v44 = (float)(v35 * v23) + (float)(v31 * *(float *)&_XMM6);
  v45 = (float)(v32 * *(float *)&_XMM6) + (float)(v36 * v23);
  v57 = v45;
  v54 = v42;
  v55 = v43;
  v56 = v44;
  if ( n2 != 2 )
  {
    v46 = powf(*(float *)&_XMM9, *(float *)&dword_149A71264);
    v47 = 1.0 / (float)(v46 * 3.1415927);
    v57 = (float)(v47 * v45) * *(float *)&dword_149A71260;
    v54 = (float)(v42 / (float)(v46 * 3.1415927)) * *(float *)&dword_149A71260;
    v55 = (float)(v47 * v43) * *(float *)&dword_149A71260;
    v56 = (float)(v47 * v44) * *(float *)&dword_149A71260;
  }
  sub_140854340(a1, a2, (unsigned int)&v53, v27, 0);
  if ( n2 == 1 )
  {
    *(float *)(a2 + 0x10) = v23 * v28[0x48];
    if ( a7 > 0.0 )
    {
      __asm { vmaxss  xmm2, xmm9, cs:dword_1482C3BC0 }
      v49 = LODWORD(a7);
      *(float *)&v49 = (float)((float)((float)(a7 * a7) * a7)
                             / (float)((float)(*(float *)&_XMM2 * *(float *)&_XMM2) * *(float *)&_XMM2))
                     * v28[0x49];
      _XMM3 = v49;
      __asm { vminss  xmm4, xmm3, xmm10 }
      *(__m128 *)(a2 + 4) = _mm_mul_ps(_mm_shuffle_ps(_XMM4, _XMM4, 0), *(__m128 *)(a2 + 4));
    }
  }
  v75 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return a2;
}

// --- End Function: sub_140850F90 (0x140850F90) ---

// --- Function: sub_140850F90 (0x140851367) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_140850F90(int a1, __int64 a2, char n2, double a4, float a5, float a6, float a7, int a8)
{
  __int128 v8; // xmm6
  __int128 v9; // xmm7
  __int128 v10; // xmm8
  __int128 v11; // xmm9
  __int128 v12; // xmm10
  __int128 v13; // xmm11
  __int128 v14; // xmm12
  __int128 v15; // xmm13
  __int128 v16; // xmm14
  __int128 v17; // xmm15
  float v23; // xmm7_4
  __int64 v25; // rax
  float *v26; // rax
  int v27; // r9d
  float *v28; // rbx
  float v29; // xmm2_4
  float v30; // xmm3_4
  float v31; // xmm4_4
  float v32; // xmm5_4
  float v33; // xmm10_4
  float v34; // xmm11_4
  float v35; // xmm12_4
  float v36; // xmm13_4
  float v37; // xmm14_4
  float v38; // xmm15_4
  float v39; // xmm0_4
  float v42; // xmm14_4
  float v43; // xmm11_4
  float v44; // xmm12_4
  float v45; // xmm13_4
  float v46; // xmm0_4
  float v47; // xmm2_4
  __int128 v49; // kr00_16
  int v53; // [rsp+48h] [rbp-C0h] BYREF
  float v54; // [rsp+4Ch] [rbp-BCh]
  float v55; // [rsp+50h] [rbp-B8h]
  float v56; // [rsp+54h] [rbp-B4h]
  float v57; // [rsp+58h] [rbp-B0h]
  float v58; // [rsp+5Ch] [rbp-ACh]
  float v59; // [rsp+60h] [rbp-A8h]
  float v60; // [rsp+64h] [rbp-A4h]
  float v61; // [rsp+68h] [rbp-A0h]
  float v62; // [rsp+6Ch] [rbp-9Ch]
  float v63; // [rsp+70h] [rbp-98h]
  _QWORD v64[3]; // [rsp+74h] [rbp-94h]
  int v65; // [rsp+8Ch] [rbp-7Ch]
  __int64 v66; // [rsp+90h] [rbp-78h]
  float v67; // [rsp+98h] [rbp-70h]
  float v68; // [rsp+9Ch] [rbp-6Ch]
  float v69; // [rsp+A0h] [rbp-68h]
  int v70; // [rsp+A4h] [rbp-64h]
  int n0x900; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v72; // [rsp+ACh] [rbp-5Ch]
  int v73; // [rsp+B4h] [rbp-54h]
  unsigned __int64 v74; // [rsp+B8h] [rbp-50h]
  unsigned __int64 v75; // [rsp+C0h] [rbp-48h]
  __int64 v76; // [rsp+C8h] [rbp-40h]
  __int64 v77; // [rsp+D0h] [rbp-38h]
  __int128 v78; // [rsp+F8h] [rbp-10h]
  __int128 v79; // [rsp+108h] [rbp+0h]
  __int128 v80; // [rsp+118h] [rbp+10h]
  __int128 v81; // [rsp+128h] [rbp+20h]
  __int128 v82; // [rsp+138h] [rbp+30h]
  __int128 v83; // [rsp+148h] [rbp+40h]
  __int128 v84; // [rsp+158h] [rbp+50h]
  __int128 v85; // [rsp+168h] [rbp+60h]
  __int128 v86; // [rsp+178h] [rbp+70h]
  __int128 v87; // [rsp+188h] [rbp+80h]
  float v88; // [rsp+1D0h] [rbp+C8h]
  float v89; // [rsp+1D8h] [rbp+D0h]
  float v90; // [rsp+1E8h] [rbp+E0h]
  float v91; // [rsp+1F0h] [rbp+E8h]
  float v92; // [rsp+200h] [rbp+F8h]

  v87 = v8;
  v86 = v9;
  v85 = v10;
  v84 = v11;
  v83 = v12;
  v82 = v13;
  v81 = v14;
  v80 = v15;
  v79 = v16;
  v78 = v17;
  _XMM9 = *(_OWORD *)&a4;
  n0x900 = 0x900;
  v72 = 0;
  v73 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v74 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFA8,
    "CDamageMap::MT_CalculateWeaponDamage",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xEA);
  HIWORD(n0x900) = word_149D7FFA8;
  v66 = 0;
  LOBYTE(v53) = n2;
  v70 = a8;
  _XMM6 = LODWORD(a5);
  v23 = a6;
  *(_OWORD *)&v64[1] = xmmword_148341EA0;
  v65 = dword_149D7FEA0;
  v67 = 0.0;
  v68 = 0.0;
  v69 = 0.0;
  if ( n2 == 1 && (a6 < 0.001 || a5 < 0.001) )
  {
    __asm { vmaxss  xmm0, xmm6, xmm7 }
    v23 = *(float *)&_XMM0 * 0.5;
    *(float *)&_XMM6 = *(float *)&_XMM0 * 0.5;
  }
  v25 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x5A0LL))(qword_149C8E018);
  v26 = (float *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x10LL))(v25);
  v28 = v26;
  if ( n2 == 2 )
  {
    v29 = v26[0x2A];
    v30 = v26[0x2B];
    v31 = v26[0x2C];
    v32 = v26[0x2D];
    v33 = v26[0x30];
    v34 = v26[0x31];
    v35 = v26[0x32];
    v36 = v26[0x33];
    v37 = v26[0x36];
    v38 = v26[0x37];
    v89 = v26[0x38];
    v91 = v26[0x39];
    v90 = v26[0x3C];
    v92 = v26[0x3D];
    v88 = v26[0x3E];
    v39 = v26[0x3F];
  }
  else
  {
    v29 = v26[8];
    v30 = v26[9];
    v31 = v26[0xA];
    v32 = v26[0xB];
    v33 = v26[0xE];
    v34 = v26[0xF];
    v35 = v26[0x10];
    v36 = v26[0x11];
    v37 = v26[0x14];
    v38 = v26[0x15];
    v89 = v26[0x16];
    v91 = v26[0x17];
    v90 = v26[0x1A];
    v92 = v26[0x1B];
    v88 = v26[0x1C];
    v39 = v26[0x1D];
  }
  __asm { vcmpltss xmm1, xmm9, cs:dword_1482BB398 }
  __asm { vblendvps xmm9, xmm9, xmm0, xmm1 }
  v58 = v37 * *(float *)&_XMM9;
  v60 = *(float *)&_XMM9 * v89;
  v62 = *(float *)&_XMM9 * v90;
  *(float *)v64 = *(float *)&_XMM9 * v88;
  v59 = v38 * *(float *)&_XMM9;
  v61 = *(float *)&_XMM9 * v91;
  v63 = *(float *)&_XMM9 * v92;
  v42 = (float)(v29 * *(float *)&_XMM6) + (float)(v33 * v23);
  *((float *)v64 + 1) = *(float *)&_XMM9 * v39;
  v43 = (float)(v30 * *(float *)&_XMM6) + (float)(v34 * v23);
  v44 = (float)(v35 * v23) + (float)(v31 * *(float *)&_XMM6);
  v45 = (float)(v32 * *(float *)&_XMM6) + (float)(v36 * v23);
  v57 = v45;
  v54 = v42;
  v55 = v43;
  v56 = v44;
  if ( n2 != 2 )
  {
    v46 = powf(*(float *)&_XMM9, *(float *)&dword_149A71264);
    v47 = 1.0 / (float)(v46 * 3.1415927);
    v57 = (float)(v47 * v45) * *(float *)&dword_149A71260;
    v54 = (float)(v42 / (float)(v46 * 3.1415927)) * *(float *)&dword_149A71260;
    v55 = (float)(v47 * v43) * *(float *)&dword_149A71260;
    v56 = (float)(v47 * v44) * *(float *)&dword_149A71260;
  }
  sub_140854340(a1, a2, (unsigned int)&v53, v27, 0);
  if ( n2 == 1 )
  {
    *(float *)(a2 + 0x10) = v23 * v28[0x48];
    if ( a7 > 0.0 )
    {
      __asm { vmaxss  xmm2, xmm9, cs:dword_1482C3BC0 }
      v49 = LODWORD(a7);
      *(float *)&v49 = (float)((float)((float)(a7 * a7) * a7)
                             / (float)((float)(*(float *)&_XMM2 * *(float *)&_XMM2) * *(float *)&_XMM2))
                     * v28[0x49];
      _XMM3 = v49;
      __asm { vminss  xmm4, xmm3, xmm10 }
      *(__m128 *)(a2 + 4) = _mm_mul_ps(_mm_shuffle_ps(_XMM4, _XMM4, 0), *(__m128 *)(a2 + 4));
    }
  }
  v75 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return a2;
}

// --- End Function: sub_140850F90 (0x140851367) ---

// --- Function: sub_140854340 (0x140854340) ---
__int64 __fastcall sub_140854340(__int64 a1, __int64 a2, __m256 *a3, float a4, unsigned int a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  __int128 v8; // xmm9
  __int128 v9; // xmm10
  __int128 v10; // xmm11
  __int128 v11; // xmm12
  __int128 v12; // xmm13
  __int128 v13; // xmm14
  __int128 v14; // xmm15
  __m256 v18; // ymm1
  __int64 v20; // rax
  __int128 n0x3F800000_1; // xmm3
  __int128 n0x3F800000; // kr00_16
  __int128 n0x3F800000_2; // xmm4
  unsigned int v27; // xmm7_4
  unsigned int v28; // xmm5_4
  __int128 n0x3F800000_4; // xmm15
  __int128 n0x3F800000_3; // kr00_16
  float v31; // xmm11_4
  float v32; // xmm12_4
  float v33; // xmm13_4
  float v34; // xmm14_4
  __m256i v40; // ymm1
  __int128 v41; // xmm3
  __int128 v42; // kr00_16
  __m256i v43; // ymm0
  __int128 v47; // kr00_16
  __int128 v50; // kr00_16
  __int128 v53; // kr00_16
  _DWORD v74[4]; // [rsp+30h] [rbp-D0h] BYREF
  __m256 v75; // [rsp+40h] [rbp-C0h] BYREF
  __m256 v76; // [rsp+60h] [rbp-A0h] BYREF
  __m256 v77; // [rsp+80h] [rbp-80h]
  __m256 v78; // [rsp+A0h] [rbp-60h] BYREF
  int n0x900; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v80; // [rsp+C4h] [rbp-3Ch]
  int v81; // [rsp+CCh] [rbp-34h]
  unsigned __int64 v82; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v83; // [rsp+D8h] [rbp-28h]
  __int64 v84; // [rsp+E0h] [rbp-20h]
  __int64 v85; // [rsp+E8h] [rbp-18h]
  _BYTE v86[64]; // [rsp+110h] [rbp+10h] BYREF
  __int128 v87; // [rsp+150h] [rbp+50h]
  __int128 v88; // [rsp+160h] [rbp+60h]
  __int128 v89; // [rsp+170h] [rbp+70h]
  __int128 v90; // [rsp+180h] [rbp+80h]
  __int128 v91; // [rsp+190h] [rbp+90h]
  __int128 v92; // [rsp+1A0h] [rbp+A0h]
  __int128 v93; // [rsp+1B0h] [rbp+B0h]
  __int128 v94; // [rsp+1C0h] [rbp+C0h]
  __int128 v95; // [rsp+1D0h] [rbp+D0h]
  __int128 v96; // [rsp+1E0h] [rbp+E0h]

  v96 = v5;
  v95 = v6;
  v94 = v7;
  v93 = v8;
  v92 = v9;
  v91 = v10;
  v90 = v11;
  v89 = v12;
  v88 = v13;
  v87 = v14;
  n0x900 = 0x900;
  v80 = 0;
  v81 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v82 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149D7FFA4,
    "CDamageMap::MT_ExpandImpactToMinimumRadius",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xAF);
  v18 = a3[1];
  v75 = *a3;
  v78 = a3[2];
  v77 = v78;
  HIWORD(n0x900) = word_149D7FFA4;
  v76 = v18;
  __asm { vzeroupper }
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x140)) )
    _XMM0 = *(unsigned __int64 *)((*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL)
                                                                                       + 0x1E8LL))(
                                    *(_QWORD *)(a1 + 0x140) & 0xFFFFFFFFFFFFLL,
                                    v86,
                                    2)
                                + 0x38);
  else
    _XMM0 = 0x3FF0000000000000uLL;
  v20 = *(_QWORD *)(a1 + 0x120);
  __asm
  {
    vcvtsd2ss xmm0, xmm0, xmm0
    vmaxss  xmm2, xmm0, cs:dword_1482BB398
  }
  _XMM0 = (unsigned int)dword_149A71268;
  n0x3F800000 = 0x3F800000u;
  *(float *)&n0x3F800000 = 1.0 / *(float *)&_XMM2;
  n0x3F800000_1 = n0x3F800000;
  *(float *)&n0x3F800000 = (float)(1.0 / *(float *)&_XMM2) * v75.m256_f32[7];
  n0x3F800000_2 = n0x3F800000;
  n0x3F800000_3 = n0x3F800000_1;
  *(float *)&n0x3F800000_3 = *(float *)&n0x3F800000_1 * v76.m256_f32[0];
  n0x3F800000_4 = n0x3F800000_3;
  _XMM2 = a5;
  v75.m256_f32[5] = *(float *)&n0x3F800000_1 * v75.m256_f32[5];
  v27 = LODWORD(v75.m256_f32[5]);
  v75.m256_f32[6] = *(float *)&n0x3F800000_1 * v75.m256_f32[6];
  v28 = LODWORD(v75.m256_f32[6]);
  v75.m256_f32[7] = *(float *)&n0x3F800000_2;
  v76.m256_f32[0] = *(float *)&n0x3F800000_1 * v76.m256_f32[0];
  v76.m256_f32[1] = *(float *)&n0x3F800000_1 * v76.m256_f32[1];
  v31 = v76.m256_f32[1];
  v76.m256_f32[2] = *(float *)&n0x3F800000_1 * v76.m256_f32[2];
  v32 = v76.m256_f32[2];
  v76.m256_f32[3] = *(float *)&n0x3F800000_1 * v76.m256_f32[3];
  v33 = v76.m256_f32[3];
  v76.m256_f32[4] = *(float *)&n0x3F800000_1 * v76.m256_f32[4];
  v34 = v76.m256_f32[4];
  __asm
  {
    vcmpneqss xmm1, xmm2, xmm10
    vblendvps xmm2, xmm0, xmm2, xmm1
  }
  _XMM1 = *(unsigned int *)(v20 + 0x70);
  __asm { vmaxss  xmm0, xmm1, cs:dword_1482BB398 }
  v40 = (__m256i)v76;
  v42 = _XMM2;
  *(float *)&v42 = *(float *)&_XMM2 * *(float *)&_XMM0;
  v41 = v42;
  *(__m256 *)a2 = v75;
  v43 = (__m256i)v78;
  *(__m256i *)(a2 + 0x20) = v40;
  *(__m256i *)(a2 + 0x40) = v43;
  *(float *)&v42 = (float)(*(float *)&_XMM2 * *(float *)&_XMM0) - (float)(v34 - *(float *)&n0x3F800000_4);
  _XMM1 = v42;
  __asm { vmaxss  xmm9, xmm1, xmm10 }
  v47 = v41;
  *(float *)&v47 = *(float *)&v41 - (float)(v33 - *(float *)&n0x3F800000_2);
  _XMM2 = v47;
  __asm { vmaxss  xmm8, xmm2, xmm10 }
  v50 = v41;
  *(float *)&v50 = *(float *)&v41 - (float)(v32 - *(float *)&v28);
  _XMM1 = v50;
  __asm { vmaxss  xmm6, xmm1, xmm10 }
  v53 = v41;
  *(float *)&v53 = *(float *)&v41 - (float)(v31 - *(float *)&v27);
  _XMM2 = v53;
  __asm { vmaxss  xmm3, xmm2, xmm10 }
  _XMM0 = v27;
  __asm { vminss  xmm2, xmm0, xmm3 }
  *(float *)(a2 + 0x14) = *(float *)&v27 - *(float *)&_XMM2;
  _XMM1 = v28;
  __asm { vminss  xmm5, xmm4, xmm8 }
  LODWORD(_XMM0) = n0x3F800000_2;
  __asm { vminss  xmm4, xmm1, xmm6 }
  *(float *)(a2 + 0x18) = *(float *)&_XMM1 - *(float *)&_XMM4;
  *(float *)(a2 + 0x1C) = *(float *)&_XMM0 - *(float *)&_XMM5;
  __asm { vminss  xmm7, xmm15, xmm9 }
  *(float *)(a2 + 0x20) = *(float *)&n0x3F800000_4 - *(float *)&_XMM7;
  *(float *)(a2 + 0x24) = (float)(*(float *)&_XMM3 - *(float *)&_XMM2) + v31;
  *(float *)(a2 + 0x28) = (float)(*(float *)&_XMM6 - *(float *)&_XMM4) + v32;
  *(float *)(a2 + 0x2C) = (float)(*(float *)&_XMM8 - *(float *)&_XMM5) + v33;
  *(float *)(a2 + 0x30) = (float)(*(float *)&_XMM9 - *(float *)&_XMM7) + v34;
  _XMM2 = LODWORD(a4);
  _XMM0 = (unsigned int)dword_149A71264;
  __asm
  {
    vcmpneqss xmm1, xmm2, xmm10
    vblendvps xmm6, xmm0, xmm2, xmm1
  }
  __asm { vzeroupper }
  sub_14084B650(
    (unsigned int)&v78,
    (unsigned int)&v75.m256_f32[5],
    (unsigned int)&v76.m256_f32[1],
    (unsigned int)&v75.m256_f32[1],
    _XMM6);
  sub_14084B650((unsigned int)v74, a2 + 0x14, a2 + 0x24, a2 + 4, _XMM6);
  _XMM0 = v74[1];
  __asm { vmaxss  xmm2, xmm0, xmm9 }
  _XMM0 = v74[2];
  *(float *)&_XMM8 = v78.m256_f32[1] / *(float *)&_XMM2;
  __asm { vmaxss  xmm3, xmm0, xmm9 }
  _XMM0 = v74[3];
  *(float *)&v53 = v78.m256_f32[2] / *(float *)&_XMM3;
  __asm { vmaxss  xmm2, xmm0, xmm9 }
  _XMM0 = v74[0];
  *(float *)&_XMM6 = v78.m256_f32[3] / *(float *)&_XMM2;
  __asm { vmaxss  xmm2, xmm0, xmm9 }
  *(float *)(a2 + 4) = (float)(v78.m256_f32[0] / *(float *)&_XMM2) * *(float *)(a2 + 4);
  *(float *)(a2 + 8) = *(float *)&_XMM8 * *(float *)(a2 + 8);
  *(float *)(a2 + 0xC) = *(float *)&v53 * *(float *)(a2 + 0xC);
  *(float *)(a2 + 0x10) = *(float *)&_XMM6 * *(float *)(a2 + 0x10);
  v83 = __rdtsc();
  qword_149C89AA8(&n0x900);
  return a2;
}

// --- End Function: sub_140854340 (0x140854340) ---

// --- Function: sub_140885420 (0x140885420) ---
__int64 __fastcall sub_140885420(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x160);
}

// --- End Function: sub_140885420 (0x140885420) ---

// --- Function: sub_140976B00 (0x140976B00) ---
__int64 __fastcall sub_140976B00(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xE8);
}

// --- End Function: sub_140976B00 (0x140976B00) ---

// --- Function: sub_1409A4020 (0x1409A4020) ---
char __fastcall sub_1409A4020(_QWORD *a1, _BYTE *a2)
{
  char result; // al

  result = sub_14048D530(a1, a2);
  if ( result )
  {
    sub_1404929F0((__int64)a1);
    return sub_140387CB0((__int64)a1, (__int64)&unk_1482C0F54);
  }
  return result;
}

// --- End Function: sub_1409A4020 (0x1409A4020) ---

// --- Function: sub_1409A6A30 (0x1409A6A30) ---
__int64 __fastcall sub_1409A6A30(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 0x19); result = sub_1402A6590(v6) )
  {
    sub_1409A6A30(a1, a2, *(_QWORD *)(i + 0x10));
    v6 = i;
    i = *(_QWORD *)i;
    sub_140373CC0((_QWORD *)(v6 + 0x20));
  }
  return result;
}

// --- End Function: sub_1409A6A30 (0x1409A6A30) ---

// --- Function: sub_1409AA870 (0x1409AA870) ---
__int64 __fastcall sub_1409AA870(__int64 a1, int a2, __int64 a3, unsigned __int16 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // r11
  __int64 v6; // rbx
  char v7; // r8
  char *v8; // r9
  __int64 v9; // rax
  char v10; // dl
  char v11; // r8

  v4 = 0;
  v5 = 0;
  do
  {
    v6 = (int)v4;
    if ( (int)v4 >= a2 || v5 < 0 )
      return 0xFFFFFFFFLL;
    v7 = a4;
    ++v4;
    a4 /= 0xAu;
    *(_BYTE *)(v5 + a1) = v7 - 0xA * a4 + 0x30;
    ++v5;
  }
  while ( a4 );
  if ( (int)v6 > 0 )
  {
    v8 = (char *)(v6 + a1);
    v9 = -a1;
    do
    {
      v10 = *v8--;
      v11 = *(_BYTE *)a1;
      *(_BYTE *)a1++ = v10;
      v8[1] = v11;
    }
    while ( v9 + a1 < (__int64)&v8[v9] );
  }
  return v4;
}

// --- End Function: sub_1409AA870 (0x1409AA870) ---

// --- Function: sub_1409ADF50 (0x1409ADF50) ---
__int64 __fastcall sub_1409ADF50(__int64 *a1)
{
  sub_1409A6A30((__int64)a1, (__int64)a1, *(_QWORD *)(*a1 + 8));
  return sub_1402A6590(*a1);
}

// --- End Function: sub_1409ADF50 (0x1409ADF50) ---

// --- Function: sub_1409E0AF0 (0x1409E0AF0) ---
__int64 sub_1409E0AF0(
        __int64 a1,
        __int64 a2,
        float a3,
        __int128 *a4,
        unsigned __int8 a5,
        unsigned __int8 a6,
        __int64 a7,
        ...)
{
  int v8; // [rsp+30h] [rbp-38h] BYREF
  __int128 v9; // [rsp+34h] [rbp-34h]
  float v10; // [rsp+44h] [rbp-24h]
  float v11; // [rsp+48h] [rbp-20h]
  va_list va; // [rsp+A8h] [rbp+40h] BYREF

  va_start(va, a7);
  v8 = (0x20 * a5) | a6 | 0x40;
  v11 = a3;
  v10 = a3;
  v9 = xmmword_1482BB410;
  if ( a4 )
    v9 = *a4;
  return (*(__int64 (__fastcall **)(__int64, __int64, int *, __int64, char *))(*(_QWORD *)a1 + 0x560LL))(
           a1,
           a2,
           &v8,
           a7,
           va);
}

// --- End Function: sub_1409E0AF0 (0x1409E0AF0) ---

// --- Function: sub_140A38BB0 (0x140A38BB0) ---
__int64 __fastcall sub_140A38BB0(unsigned __int16 *a1, __int64 a2, int a3)
{
  return sub_1409AA870(a2, a3, 0, *a1);
}

// --- End Function: sub_140A38BB0 (0x140A38BB0) ---

// --- Function: ?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z (0x140AAB900) ---
void __fastcall std::_Func_class<void,>::_Reset_move(std::_Func_class<void> *this, std::_Func_class<void> *_Right)
{
  std::_Func_class<void> *_Right_2; // rcx
  __int64 v5; // rdx
  std::_Func_class<void> *_Right_1; // rcx

  _Right_2 = (std::_Func_class<void> *)*((_QWORD *)_Right + 7);
  if ( _Right_2 )
  {
    if ( _Right_2 == _Right )
    {
      *((_QWORD *)this + 7) = (*(__int64 (__fastcall **)(std::_Func_class<void> *, std::_Func_class<void> *))(*(_QWORD *)_Right_2 + 8LL))(
                                _Right_2,
                                this);
      _Right_1 = (std::_Func_class<void> *)*((_QWORD *)_Right + 7);
      if ( _Right_1 )
      {
        LOBYTE(v5) = _Right_1 != _Right;
        (*(void (__fastcall **)(std::_Func_class<void> *, __int64))(*(_QWORD *)_Right_1 + 0x20LL))(_Right_1, v5);
        *((_QWORD *)_Right + 7) = 0;
      }
    }
    else
    {
      *((_QWORD *)this + 7) = _Right_2;
      *((_QWORD *)_Right + 7) = 0;
    }
  }
}

// --- End Function: ?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z (0x140AAB900) ---

// --- Function: sub_140ABBCA0 (0x140ABBCA0) ---
bool __fastcall sub_140ABBCA0(_BYTE *a1, _BYTE *a2)
{
  return *a1 == *a2;
}

// --- End Function: sub_140ABBCA0 (0x140ABBCA0) ---

// --- Function: sub_140ABCC50 (0x140ABCC50) ---
__int64 __fastcall sub_140ABCC50(_BYTE *a1, void *a2, size_t Size_1)
{
  size_t Size; // rbx
  const char *p_true; // rdx

  Size = 0xFFFFFFFFFFFFFFFFuLL;
  p_true = "false";
  if ( *a1 )
    p_true = "true";
  do
    ++Size;
  while ( p_true[Size] );
  if ( Size >= Size_1 )
    return 0xFFFFFFFFLL;
  if ( Size )
  {
    if ( !a2 )
    {
      *errno() = 0x16;
      invalid_parameter_noinfo();
      return (unsigned int)Size;
    }
    memcpy(a2, p_true, Size);
  }
  return (unsigned int)Size;
}

// --- End Function: sub_140ABCC50 (0x140ABCC50) ---

// --- Function: sub_140ABCDB0 (0x140ABCDB0) ---
__int64 __fastcall sub_140ABCDB0(_BYTE *a1, __int64 a2, __int64 a3)
{
  return sub_140454810(a2, a3, 0, *a1 != 0);
}

// --- End Function: sub_140ABCDB0 (0x140ABCDB0) ---

// --- Function: sub_140B1A1CC (0x140B1A1CC) ---
__int64 __fastcall sub_140B1A1CC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
}

// --- End Function: sub_140B1A1CC (0x140B1A1CC) ---

// --- Function: sub_140B5EA90 (0x140B5EA90) ---
__int64 __fastcall sub_140B5EA90(__int64 a1, __int64 a2, const char **a3)
{
  unsigned __int64 v4; // rax
  const char *p_null_1; // rcx
  const char *p_null; // rdx

  *(_QWORD *)a1 = a2;
  *(_WORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 8) = "Unnamed_ULong";
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1405099D0;
  *(_QWORD *)(a1 + 0x20) = sub_1405099D0;
  *(_QWORD *)(a1 + 0x30) = std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  v4 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x60) = 8;
  *(_QWORD *)(a1 + 0x68) = 0x15;
  p_null_1 = *a3;
  *(_QWORD *)(a1 + 0x78) = "Unnamed_Text";
  *(_QWORD *)(a1 + 0x70) = p_null_1;
  *(_QWORD *)(a1 + 0x88) = sub_1403EF740;
  *(_QWORD *)(a1 + 0x90) = sub_1403EF1F0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403EB9C0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9230;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F30;
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  *(_WORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 8;
  do
    ++v4;
  while ( p_null[v4] );
  *(_QWORD *)(a1 + 0xD8) = v4 + 2;
  return 2;
}

// --- End Function: sub_140B5EA90 (0x140B5EA90) ---

// --- Function: sub_140BA3C90 (0x140BA3C90) ---
__int64 *__fastcall sub_140BA3C90(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rdi

  v6 = a2;
  if ( a2 == a3 )
  {
    *a1 = a2;
  }
  else
  {
    do
    {
      if ( sub_1405B53B0(v6, a4) )
        break;
      v6 += 0x18;
    }
    while ( v6 != a3 );
    *a1 = v6;
  }
  return a1;
}

// --- End Function: sub_140BA3C90 (0x140BA3C90) ---

// --- Function: sub_140BF8F00 (0x140BF8F00) ---
char *__fastcall sub_140BF8F00(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // rdx
  char *result; // rax

  v3 = a1[1];
  if ( v3 == a1[2] )
    return sub_14030A110(a1, (_BYTE *)v3, a2);
  *(_OWORD *)v3 = *(_OWORD *)a2;
  *(double *)(v3 + 0x10) = *(double *)(a2 + 0x10);
  a1[1] += 0x18LL;
  return result;
}

// --- End Function: sub_140BF8F00 (0x140BF8F00) ---

// --- Function: sub_140C0B920 (0x140C0B920) ---
_QWORD *__fastcall sub_140C0B920(_QWORD *a1, _QWORD *a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // r11
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rax
  __int64 v6; // r8
  __int64 *v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx

  v3 = *a3;
  v4 = (unsigned __int8)BYTE1(*a3) ^ (0x100000001B3LL * ((unsigned __int8)*a3 ^ 0xCBF29CE484222325uLL));
  v5 = *a3 >> 0x10;
  v6 = a1[1];
  v7 = (__int64 *)(a1[3]
                 + 0x10
                 * ((0x100000001B3LL
                   * (HIBYTE(v3)
                    ^ (0x100000001B3LL
                     * (BYTE6(v3)
                      ^ (0x100000001B3LL
                       * (BYTE5(v3)
                        ^ (0x100000001B3LL
                         * (BYTE4(v3)
                          ^ (0x100000001B3LL
                           * (BYTE3(v3) ^ (0x100000001B3LL * ((unsigned __int8)v5 ^ (0x100000001B3LL * v4)))))))))))))
                  & a1[6]));
  v8 = v7[1];
  if ( v8 == v6 )
  {
LABEL_8:
    v8 = 0;
    goto LABEL_9;
  }
  v9 = *v7;
  if ( v3 != *(_QWORD *)(v8 + 0x10) )
  {
    while ( v8 != v9 )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( v3 == *(_QWORD *)(v8 + 0x10) )
      {
        if ( !v8 )
          v8 = v6;
        *a2 = v8;
        return a2;
      }
    }
    goto LABEL_8;
  }
LABEL_9:
  if ( !v8 )
    v8 = v6;
  *a2 = v8;
  return a2;
}

// --- End Function: sub_140C0B920 (0x140C0B920) ---

// --- Function: sub_140D19250 (0x140D19250) ---
void sub_140D19250(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+48h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149C8E0F8
    && qword_149C8DFE0
    && qword_149C8DFF0
    && (*(int (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFF0 + 0x98LL))(qword_149C8DFF0) >= 3 )
  {
    (*(void (__fastcall **)(__int64, _QWORD, __int64, __int64 *))(*(_QWORD *)qword_149C8DFF0 + 8LL))(
      qword_149C8DFF0,
      0,
      a3,
      (__int64 *)va);
  }
}

// --- End Function: sub_140D19250 (0x140D19250) ---

// --- Function: sub_140DCD410 (0x140DCD410) ---
__int64 __fastcall sub_140DCD410(_QWORD *a1)
{
  if ( *a1 )
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)*a1 + 8LL) + 8 * (a1[2] & (*(_QWORD *)(*(_QWORD *)*a1 + 0x10LL) - 1LL)));
  else
    return *(_QWORD *)(MEMORY[8] + 8 * (a1[2] & (MEMORY[0x10] - 1LL)));
}

// --- End Function: sub_140DCD410 (0x140DCD410) ---

// --- Function: sub_140DEFD80 (0x140DEFD80) ---
__int64 __fastcall sub_140DEFD80(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 n8; // rbx
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v5; // r12
  unsigned __int64 allocSize; // rcx
  __int64 v7; // rax
  _QWORD *v8; // r14
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx
  __int64 v11; // r15
  size_t Size; // rdi
  const void *v13; // rdx
  char *v14; // rdi
  size_t Size_1; // r8
  char *v16; // rcx
  __int64 result; // rax
  __int64 v18; // rcx

  n8 = 1;
  n8_1 = a1[2];
  if ( n8_1 )
    n8 = n8_1;
  while ( n8 - n8_1 < a2 || n8 < 8 )
  {
    if ( 0xFFFFFFFFFFFFFFFLL - n8 < n8 )
      unknown_libname_8();
    n8 *= 2LL;
  }
  v5 = a1[3];
  if ( n8 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  allocSize = 8 * n8;
  if ( 8 * n8 < 0x1000 )
  {
    if ( allocSize )
      v8 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v8 = 0;
    goto LABEL_15;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_25:
    sub_1402E3880();
  v7 = sub_1402A65A0(allocSize + 0x27);
  if ( !v7 )
    goto LABEL_24;
  v8 = (_QWORD *)((v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v8[0xFFFFFFFF] = v7;
LABEL_15:
  v9 = a1[2];
  v10 = n8 - v9;
  v11 = 8 * v5;
  Size = 8 * v9 - 8 * v5;
  memmove(&v8[v5], (const void *)(a1[1] + 8 * v5), Size);
  v13 = (const void *)a1[1];
  v14 = (char *)&v8[v5] + Size;
  if ( v5 > v10 )
  {
    memmove(v14, v13, 8 * v10);
    memmove(v8, (const void *)(8 * v10 + a1[1]), v11 - 8 * v10);
    v16 = (char *)v8 + v11 - 8 * v10;
    Size_1 = 8 * v10;
  }
  else
  {
    memmove(v14, v13, 8 * v5);
    memset(&v14[v11], 0, 8 * (v10 - v5));
    Size_1 = 8 * v5;
    v16 = (char *)v8;
  }
  result = (__int64)memset(v16, 0, Size_1);
  v18 = a1[1];
  if ( v18 )
  {
    if ( (unsigned __int64)(8LL * a1[2]) < 0x1000 )
    {
LABEL_22:
      result = sub_1402A6590(v18);
      goto LABEL_23;
    }
    if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) <= 0x1F )
    {
      v18 = *(_QWORD *)(v18 - 8);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  a1[2] += v10;
  a1[1] = v8;
  return result;
}

// --- End Function: sub_140DEFD80 (0x140DEFD80) ---

// --- Function: sub_140E51DA0 (0x140E51DA0) ---
__int64 __fastcall sub_140E51DA0(__int64 a1, char a2)
{
  __int64 v2; // rcx
  char v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  v2 = *(_QWORD *)(a1 + 0x38);
  if ( !v2 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x140E51DC6LL);
  }
  return (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v2 + 0x10LL))(v2, &v4);
}

// --- End Function: sub_140E51DA0 (0x140E51DA0) ---

// --- Function: sub_141237460 (0x141237460) ---
__int64 __fastcall sub_141237460(__int64 a1, __int64 a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(double *)(a1 + 0x10) = *(double *)(a2 + 0x10);
  return a1;
}

// --- End Function: sub_141237460 (0x141237460) ---

// --- Function: sub_141237480 (0x141237480) ---
__int64 __fastcall sub_141237480(__int64 a1, int a2, _OWORD *a3)
{
  *(_OWORD *)(a1 + 8) = *a3;
  *(_DWORD *)a1 = a2;
  return a1;
}

// --- End Function: sub_141237480 (0x141237480) ---

// --- Function: sub_141279340 (0x141279340) ---
void __fastcall sub_141279340(int a1, _QWORD *a2, _QWORD *a3)
{
  int v5; // ecx
  __int64 v6; // rdi
  __int64 v7; // rax

  if ( a1 )
  {
    v5 = a1 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v6 = a2[2];
        if ( v6 )
        {
          sub_140373CC0((_QWORD *)(v6 + 0x10));
          sub_1402A6590(v6);
        }
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
      return;
    }
  }
  else
  {
    LogFatalError("Can not request a copy for a CigMoveOnlyFunction, something's broken in the implementation");
  }
  if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      v7 = 1;
    }
    else
    {
      a2[2] = a3[2];
      *a2 = *a3;
      v7 = a3[1];
    }
    a2[1] = v7;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
  }
}

// --- End Function: sub_141279340 (0x141279340) ---

// --- Function: sub_1412AF9F0 (0x1412AF9F0) ---
__int64 __fastcall sub_1412AF9F0(_QWORD *a1)
{
  return (a1[1] - *a1) / 0x98LL;
}

// --- End Function: sub_1412AF9F0 (0x1412AF9F0) ---

// --- Function: sub_1412B19F0 (0x1412B19F0) ---
_QWORD *__fastcall sub_1412B19F0(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v5)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+50h] [rbp+18h] BYREF
  char v9; // [rsp+58h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(qword_149C8DFC0);
  v3 = v2;
  if ( v2 )
  {
    n0xFFFF = n0xFFFF_14;
    v5 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v2 + 0x340LL);
    if ( n0xFFFF_14 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                            qword_149C8DFC8,
                            &v8,
                            "IItemPortContainer");
      n0xFFFF_14 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v5(v3, &v9, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1412B19F0 (0x1412B19F0) ---

// --- Function: sub_1413B5210 (0x1413B5210) ---
char *__fastcall sub_1413B5210(__int64 *a1, _BYTE *a2, _QWORD *a3, _DWORD *a4)
{
  unsigned __int64 v5; // r14
  __int64 v6; // rbp
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rdi
  unsigned __int64 allocSize; // rdi
  __int64 v15; // rax
  _QWORD *v16; // rbx
  char *v17; // r14
  void *v18; // rcx
  _BYTE *v19; // r8
  _BYTE *v20; // rdx
  size_t Size; // r8
  __int64 v22; // rcx
  char *result; // rax

  v5 = (unsigned __int64)&a2[-*a1];
  v6 = (a1[1] - *a1) >> 4;
  if ( v6 == 0xFFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v10 = v6 + 1;
  v11 = (a1[2] - *a1) >> 4;
  v12 = v11 >> 1;
  if ( v11 > 0xFFFFFFFFFFFFFFFLL - (v11 >> 1) )
    goto LABEL_24;
  v13 = v10;
  if ( v12 + v11 >= v10 )
    v13 = v12 + v11;
  if ( v13 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 0x10 * v13;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v16 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v16 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E3880();
  v15 = sub_1402A65A0(allocSize + 0x27);
  if ( !v15 )
    goto LABEL_22;
  v16 = (_QWORD *)((v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v16[0xFFFFFFFF] = v15;
LABEL_13:
  v17 = (char *)v16 + (v5 & 0xFFFFFFFFFFFFFFF0uLL);
  v18 = v16;
  *(_QWORD *)v17 = *a3;
  *((_DWORD *)v17 + 2) = *a4;
  v19 = (_BYTE *)a1[1];
  v20 = (_BYTE *)*a1;
  if ( a2 == v19 )
  {
    Size = v19 - v20;
  }
  else
  {
    memmove(v16, v20, a2 - v20);
    v18 = v17 + 0x10;
    Size = a1[1] - (_QWORD)a2;
    v20 = a2;
  }
  memmove(v18, v20, Size);
  v22 = *a1;
  if ( *a1 )
  {
    if ( ((a1[2] - v22) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v22);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v22 - *(_QWORD *)(v22 - 8) - 8) <= 0x1F )
    {
      v22 = *(_QWORD *)(v22 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v16;
  result = v17;
  a1[1] = (__int64)&v16[2 * v10];
  a1[2] = (__int64)&v16[allocSize / 8];
  return result;
}

// --- End Function: sub_1413B5210 (0x1413B5210) ---

// --- Function: sub_1413B53B0 (0x1413B53B0) ---
void __fastcall sub_1413B53B0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rdi
  _QWORD *v6; // rbx
  __int64 v7; // rcx

  v3 = a3;
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    sub_1413B53B0(a1, a2, v3[2]);
    v6 = v3;
    v3 = (__int64 *)*v3;
    v7 = v6[5];
    if ( v7 )
    {
      if ( ((v6[7] - v7) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v7 - *(_QWORD *)(v7 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v7 = *(_QWORD *)(v7 - 8);
      }
      sub_1402A6590(v7);
      v6[5] = 0;
      v6[6] = 0;
      v6[7] = 0;
    }
    sub_1402A6590((__int64)v6);
  }
}

// --- End Function: sub_1413B53B0 (0x1413B53B0) ---

// --- Function: sub_141541D70 (0x141541D70) ---
_QWORD *__fastcall sub_141541D70(_QWORD *a1, __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  a1[2] = a2;
  if ( a2 )
  {
    memcpy(a1, a4, Size);
    if ( Size < 8 )
      memset((char *)a1 + Size, 0, 8 - Size);
    return a1;
  }
  else
  {
    *a1 = a3;
    return a1;
  }
}

// --- End Function: sub_141541D70 (0x141541D70) ---

// --- Function: sub_14154ABF0 (0x14154ABF0) ---
__int64 __fastcall sub_14154ABF0(__int64 a1, __int64 a2)
{
  return sub_1403C21C0(a2, *(_DWORD *)(*(_QWORD *)(a1 + 0x10) + 8LL), *(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_14154ABF0 (0x14154ABF0) ---

// --- Function: sub_1415770C0 (0x1415770C0) ---
bool __fastcall sub_1415770C0(__int64 a1, int a2)
{
  return *(_DWORD *)(a1 + 8) != a2;
}

// --- End Function: sub_1415770C0 (0x1415770C0) ---

// --- Function: sub_14159F620 (0x14159F620) ---
void __fastcall sub_14159F620(
        int a1,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64, __int64); // rdi
  __int64 v6; // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v6 = sub_1402A65A0(0xCu);
        if ( v6 )
        {
          *(double *)v6 = *(double *)v5;
          *(_DWORD *)(v6 + 8) = *((_DWORD *)v5 + 2);
        }
        else
        {
          v6 = 0;
        }
        a2[2] = (__int64 (__fastcall *)(__int64, __int64))v6;
        *a2 = sub_14154ABF0;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))sub_14159F620;
      }
    }
  }
}

// --- End Function: sub_14159F620 (0x14159F620) ---

// --- Function: sub_1415E4370 (0x1415E4370) ---
__int64 __fastcall sub_1415E4370(__int64 a1, char a2, int *a3, __int64 a4, __m256 *a5, __int64 a6)
{
  int n2; // edi
  __int64 (__fastcall **p_p_sub_14159E930)(); // rbx
  int v12; // esi
  __m256 *v13; // rax
  __m256 *v14; // rax
  bool v15; // zf
  unsigned int v16; // ebx
  __int64 (__fastcall *v17)(); // r9
  __int64 (__fastcall *p_sub_14154B2E0)(); // [rsp+20h] [rbp-E0h] BYREF
  __int64 (__fastcall *p_sub_14154C1E0)(); // [rsp+28h] [rbp-D8h]
  __m256 *v21; // [rsp+30h] [rbp-D0h]
  __int64 v22; // [rsp+38h] [rbp-C8h] BYREF
  void (__fastcall *n2_3)(__int64, __int64 *); // [rsp+40h] [rbp-C0h]
  __int64 v24; // [rsp+48h] [rbp-B8h]
  __int64 (__fastcall *p_sub_14159E930)(); // [rsp+50h] [rbp-B0h] BYREF
  __int64 (__fastcall *p_sub_1415A1290)(); // [rsp+58h] [rbp-A8h]
  __m256 *v27; // [rsp+60h] [rbp-A0h]
  __m256 v28; // [rsp+70h] [rbp-90h]
  int v29; // [rsp+90h] [rbp-70h] BYREF
  _BYTE v30[64]; // [rsp+98h] [rbp-68h] BYREF
  _BYTE v31[112]; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v32; // [rsp+148h] [rbp+48h]
  __int64 (__fastcall *p_sub_14154B2E0_1)(); // [rsp+158h] [rbp+58h] BYREF
  __int128 n2_2; // [rsp+160h] [rbp+60h]
  __int64 (__fastcall *p_sub_14159E930_1)(); // [rsp+170h] [rbp+70h] BYREF
  unsigned __int64 n2_1; // [rsp+178h] [rbp+78h]
  __int64 v37; // [rsp+180h] [rbp+80h]
  char v38; // [rsp+188h] [rbp+88h]

  n2 = 0;
  if ( *(_QWORD *)(a6 + 0x10) || *(_QWORD *)a6 )
  {
    v28 = *(__m256 *)a6;
    __asm { vzeroupper }
    v13 = (__m256 *)sub_1402A65A0(0x20u);
    if ( v13 )
    {
      *v13 = v28;
      v27 = v13;
    }
    else
    {
      v27 = 0;
    }
    v12 = 1;
    p_sub_14159E930 = sub_14159E930;
    p_p_sub_14159E930 = &p_sub_14159E930;
    p_sub_1415A1290 = sub_1415A1290;
  }
  else
  {
    v22 = 0;
    p_p_sub_14159E930 = (__int64 (__fastcall **)())&v22;
    n2_3 = 0;
    v12 = 0;
    v24 = 0;
    n2 = 2;
  }
  v28 = *a5;
  __asm { vzeroupper }
  v14 = (__m256 *)sub_1402A65A0(0x20u);
  if ( v14 )
  {
    *v14 = v28;
    v21 = v14;
  }
  else
  {
    v21 = 0;
  }
  v15 = *p_p_sub_14159E930 == 0;
  p_sub_14154B2E0 = sub_14154B2E0;
  p_sub_14154C1E0 = sub_14154C1E0;
  if ( !v15 )
    goto LABEL_14;
  __asm { vzeroupper }
  if ( (unsigned __int8)sub_1404FDC40(a4) )
  {
LABEL_14:
    v29 = *a3;
    __asm { vzeroupper }
    sub_14158C4F0(v30, a4);
    p_sub_14154B2E0_1 = 0;
    n2_2 = 0;
    if ( p_sub_14154C1E0 == (__int64 (__fastcall *)())1 )
    {
      p_sub_14154B2E0_1 = p_sub_14154B2E0;
      *(_QWORD *)&n2_2 = 1;
    }
    else if ( p_sub_14154C1E0 )
    {
      ((void (__fastcall *)(_QWORD, __int64 (__fastcall **)(), __int64 (__fastcall **)()))p_sub_14154C1E0)(
        0,
        &p_sub_14154B2E0_1,
        &p_sub_14154B2E0);
    }
    v17 = p_p_sub_14159E930[1];
    p_sub_14159E930_1 = 0;
    n2_1 = 0;
    v37 = 0;
    if ( v17 == (__int64 (__fastcall *)())1 )
    {
      p_sub_14159E930_1 = *p_p_sub_14159E930;
      n2_1 = 1;
    }
    else if ( v17 )
    {
      ((void (__fastcall *)(_QWORD, __int64 (__fastcall **)(), __int64 (__fastcall **)()))v17)(
        0,
        &p_sub_14159E930_1,
        p_p_sub_14159E930);
    }
    v38 = a2;
    v16 = sub_1416044C0(a1 + 0x250, &v29);
    if ( n2_1 >= 2 )
    {
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2_1)(2, &p_sub_14159E930_1);
      n2_1 = 0;
    }
    p_sub_14159E930_1 = 0;
    if ( (unsigned __int64)n2_2 >= 2 )
    {
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2_2)(2, &p_sub_14154B2E0_1);
      *(_QWORD *)&n2_2 = 0;
    }
    p_sub_14154B2E0_1 = 0;
    if ( v32 )
      sub_140527EC0(v32, 0);
    sub_140468A30(v31);
  }
  else
  {
    v16 = 0;
  }
  if ( (unsigned __int64)p_sub_14154C1E0 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))p_sub_14154C1E0)(2, &p_sub_14154B2E0);
    p_sub_14154C1E0 = 0;
  }
  p_sub_14154B2E0 = 0;
  if ( n2 )
  {
    if ( (unsigned __int64)n2_3 >= 2 )
    {
      n2_3(2, &v22);
      n2_3 = 0;
    }
    v22 = 0;
  }
  if ( v12 && (unsigned __int64)p_sub_1415A1290 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))p_sub_1415A1290)(2, &p_sub_14159E930);
  return v16;
}

// --- End Function: sub_1415E4370 (0x1415E4370) ---

// --- Function: sub_1415FF470 (0x1415FF470) ---
__int64 __fastcall sub_1415FF470(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rdi
  __int64 v10; // r8
  __int64 result; // rax

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v4 != i; v4 += 5 )
      sub_140373CC0(v4);
    v10 = *a1;
    if ( (unsigned __int64)(0x28 * ((a1[2] - *a1) / 0x28)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v10 - *(_QWORD *)(v10 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = *(_QWORD *)(v10 - 8);
    }
    sub_1402A6590(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 0x28 * a3;
  result = 5 * a4;
  a1[2] = a2 + 0x28 * a4;
  return result;
}

// --- End Function: sub_1415FF470 (0x1415FF470) ---

// --- Function: sub_1416150C0 (0x1416150C0) ---
_QWORD *__fastcall sub_1416150C0(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v5)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+50h] [rbp+18h] BYREF
  char v9; // [rsp+58h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(qword_149C8DFC0);
  v3 = v2;
  if ( v2 )
  {
    n0xFFFF = n0xFFFF_17;
    v5 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v2 + 0x340LL);
    if ( n0xFFFF_17 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                            qword_149C8DFC8,
                            &v8,
                            "IEntityAreaProxy");
      n0xFFFF_17 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v5(v3, &v9, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1416150C0 (0x1416150C0) ---

// --- Function: sub_14166EB00 (0x14166EB00) ---
__int64 *__fastcall sub_14166EB00(std::_Tree_val<std::_Tree_simple_types<int> > *a1, __int64 *a2, __int64 *_Wherenode)
{
  __int64 _Wherenode_2; // rbx
  __int64 *_Wherenode_1; // rax
  __int64 _Wherenode_3; // rcx
  __int64 *v8; // rax

  _Wherenode_2 = _Wherenode[2];
  _Wherenode_1 = _Wherenode;
  if ( *(_BYTE *)(_Wherenode_2 + 0x19) )
  {
    for ( _Wherenode_2 = _Wherenode[1]; !*(_BYTE *)(_Wherenode_2 + 0x19); _Wherenode_2 = *(_QWORD *)(_Wherenode_2 + 8) )
    {
      if ( _Wherenode_1 != *(__int64 **)(_Wherenode_2 + 0x10) )
        break;
      _Wherenode_1 = (__int64 *)_Wherenode_2;
    }
  }
  else
  {
    for ( _Wherenode_3 = *(_QWORD *)_Wherenode_2; !*(_BYTE *)(_Wherenode_3 + 0x19); _Wherenode_3 = *(_QWORD *)_Wherenode_3 )
      _Wherenode_2 = _Wherenode_3;
  }
  v8 = sub_1402E2560(a1, _Wherenode);
  sub_1402A6590((__int64)v8);
  *a2 = _Wherenode_2;
  return a2;
}

// --- End Function: sub_14166EB00 (0x14166EB00) ---

// --- Function: sub_141672DD0 (0x141672DD0) ---
_QWORD *__fastcall sub_141672DD0(_QWORD *a1, __int64 a2)
{
  char *v3; // rcx
  __int64 v4; // rax
  __int64 v6; // rdi
  __int64 v7; // rdi

  v3 = 0;
  v4 = (__int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3;
  if ( v4 )
  {
    v6 = 8 * v4;
    v3 = (char *)sub_1402A65A0(8 * v4);
  }
  else
  {
    v6 = 0;
  }
  *a1 = v3;
  a1[2] = &v3[v6];
  a1[1] = v3;
  v7 = *(_QWORD *)(a2 + 8);
  if ( *(_QWORD *)a2 == v7 )
    a1[1] = v3;
  else
    a1[1] = (char *)memmove(v3, *(const void **)a2, v7 - *(_QWORD *)a2) + 8 * ((v7 - a2) >> 3);
  return a1;
}

// --- End Function: sub_141672DD0 (0x141672DD0) ---

// --- Function: sub_1418215F0 (0x1418215F0) ---
__int64 __fastcall sub_1418215F0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x100);
}

// --- End Function: sub_1418215F0 (0x1418215F0) ---

// --- Function: sub_14185AD70 (0x14185AD70) ---
_BYTE *__fastcall sub_14185AD70(_BYTE *p_pExceptionObject)
{
  *((_QWORD *)p_pExceptionObject + 1) = "bad allocation";
  *(_QWORD *)p_pExceptionObject = off_1482B6D28;
  return p_pExceptionObject;
}

// --- End Function: sub_14185AD70 (0x14185AD70) ---

// --- Function: sub_14189C120 (0x14189C120) ---
_QWORD *__fastcall sub_14189C120(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rcx
  int v5; // eax
  _QWORD *result; // rax

  if ( *a1 != a2 )
  {
    if ( a2 )
      _InterlockedIncrement((volatile signed __int32 *)(a2 + 8));
    v4 = *a1;
    if ( v4 )
    {
      v5 = _InterlockedDecrement((volatile signed __int32 *)(v4 + 8));
      if ( !v5 )
      {
        (**(void (__fastcall ***)(__int64, __int64))v4)(v4, 1);
        result = a1;
        *a1 = a2;
        return result;
      }
      if ( v5 < 0 )
        LogFatalError("Deleting Reference Counted Object Twice");
    }
    *a1 = a2;
  }
  return a1;
}

// --- End Function: sub_14189C120 (0x14189C120) ---

// --- Function: sub_1419439A0 (0x1419439A0) ---
void __fastcall sub_1419439A0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 0x318) = a2;
}

// --- End Function: sub_1419439A0 (0x1419439A0) ---

// --- Function: sub_1419A7020 (0x1419A7020) ---
__int64 __fastcall sub_1419A7020(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 result; // rax

  v4 = sub_1419AF770();
  if ( v4 )
  {
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 0x150LL))(v4, a2, a1);
    return a2;
  }
  else
  {
    *(_QWORD *)(a2 + 0x18) = *(_QWORD *)(a1 + 0x18);
    *(_QWORD *)a2 = *(_QWORD *)a1;
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 0x10) = *(_QWORD *)(a1 + 0x10);
    result = a2;
    *(_OWORD *)(a2 + 0x20) = *(_OWORD *)(a1 + 0x20);
    *(double *)(a2 + 0x30) = *(double *)(a1 + 0x30);
  }
  return result;
}

// --- End Function: sub_1419A7020 (0x1419A7020) ---

// --- Function: sub_1419AA8C0 (0x1419AA8C0) ---
__int64 __fastcall sub_1419AA8C0(__int64 a1)
{
  return a1 + 0x1D8;
}

// --- End Function: sub_1419AA8C0 (0x1419AA8C0) ---

// --- Function: sub_1419AF770 (0x1419AF770) ---
__int64 __fastcall sub_1419AF770(__int64 a1)
{
  unsigned __int64 *v1; // rsi
  _QWORD *v2; // rdi
  __int64 v3; // rbx
  unsigned __int64 v5; // [rsp+40h] [rbp+8h] BYREF
  char v6; // [rsp+48h] [rbp+10h] BYREF

  v1 = (unsigned __int64 *)(a1 + 0x38);
  v2 = (_QWORD *)(a1 + 0x40);
  if ( !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x38))
    || (v3 = *v2,
        *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(*v1 & 0xFFFFFFFFFFFFLL) + 8LL))(
                     *v1 & 0xFFFFFFFFFFFFLL,
                     &v6) != v3) )
  {
    *v1 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                       qword_149C8DFC0,
                       &v6,
                       *v2);
  }
  v5 = *v1;
  if ( is_entity_descriptor_valid_or_accessible(&v5) )
    return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v5 & 0xFFFFFFFFFFFFLL);
  else
    return 0;
}

// --- End Function: sub_1419AF770 (0x1419AF770) ---

// --- Function: sub_141AEA010 (0x141AEA010) ---
void __fastcall sub_141AEA010(__int64 a1)
{
  bool v1; // zf
  _QWORD *v3; // rdx
  _QWORD *v4; // rbx
  _QWORD *i; // rax
  size_t Size; // rdi
  _BYTE *v7; // rbx
  __int64 v8; // rcx

  v1 = (*(_QWORD *)(a1 + 0x18))-- == 1;
  if ( v1 && *(_BYTE *)(a1 + 0x20) )
  {
    v3 = *(_QWORD **)(a1 + 8);
    v4 = *(_QWORD **)a1;
    if ( *(_QWORD **)a1 != v3 )
    {
      do
      {
        if ( !*v4 )
          break;
        ++v4;
      }
      while ( v4 != v3 );
      if ( v4 != v3 )
      {
        for ( i = v4 + 1; i != v3; ++i )
        {
          if ( *i )
            *v4++ = *i;
        }
        if ( v4 != v3 )
        {
          Size = *(_QWORD *)(a1 + 8) - (_QWORD)v3;
          memmove(v4, v3, Size);
          *(_QWORD *)(a1 + 8) = (char *)v4 + Size;
        }
      }
    }
    v7 = (_BYTE *)(a1 + 0x21);
    if ( *(_BYTE *)(a1 + 0x21) )
    {
      v8 = *(_QWORD *)a1;
      v7 = (_BYTE *)(a1 + 0x21);
      if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) )
      {
        v7 = (_BYTE *)(a1 + 0x21);
        if ( v8 )
        {
          v7 = (_BYTE *)(a1 + 0x21);
          if ( ((*(_QWORD *)(a1 + 0x10) - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
          {
            if ( (unsigned __int64)(v8 - *(_QWORD *)(v8 - 8) - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
            v8 = *(_QWORD *)(v8 - 8);
            v7 = (_BYTE *)(a1 + 0x21);
          }
          sub_1402A6590(v8);
        }
        *(_QWORD *)a1 = 0;
        *(_QWORD *)(a1 + 8) = 0;
        *(_QWORD *)(a1 + 0x10) = 0;
      }
    }
    *v7 = 0;
    *(_BYTE *)(a1 + 0x20) = 0;
  }
}

// --- End Function: sub_141AEA010 (0x141AEA010) ---

// --- Function: sub_141C986E0 (0x141C986E0) ---
unsigned __int8 __fastcall sub_141C986E0(_QWORD *a1, unsigned __int64 a2)
{
  int v2; // ecx

  v2 = *(_DWORD *)(*a1 + 4 * (a2 >> 5));
  return _bittest(&v2, a2 & 0x1F);
}

// --- End Function: sub_141C986E0 (0x141C986E0) ---

// --- Function: sub_141D12710 (0x141D12710) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_141D12710(char a1, double a2, double a3, double a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // kr00_16
  __int128 v8; // kr00_16
  __int128 v9; // kr00_16
  float v10; // xmm2_4
  __int128 v11; // kr00_16
  __int128 v12; // kr00_16
  __int128 v13; // kr00_16
  __int128 v14; // kr00_16
  __int128 v15; // kr00_16
  bool v16; // cf
  float v17; // xmm3_4
  __int128 n0x40000000; // xmm0
  __int128 n0x40000000_1; // kr00_16
  __int128 n0x3F800000; // kr00_16
  float v21; // kr00_4
  float v22; // xmm8_4
  float v23; // kr00_4
  __int128 n0x40000000_3; // xmm0
  __int128 n0x40000000_4; // kr00_16
  float v26; // xmm0_4
  __int128 n0x40000000_2; // kr00_16

  v4 = *(_OWORD *)&a3;
  v5 = *(_OWORD *)&a2;
  switch ( a1 )
  {
    case 0:
      v6 = *(_OWORD *)&a3;
      *(float *)&v6 = (float)((float)(*(float *)&a3 - *(float *)&a2) * *(float *)&a4) + *(float *)&a2;
      return (__m128)v6;
    case 1:
      v8 = *(_OWORD *)&a3;
      *(float *)&v8 = (float)((float)((float)(*(float *)&a3 - *(float *)&a2) * *(float *)&a4) * *(float *)&a4)
                    + *(float *)&a2;
      return (__m128)v8;
    case 2:
      v9 = *(_OWORD *)&a2;
      *(float *)&v9 = *(float *)&a2
                    - (float)((float)((float)(*(float *)&a3 - *(float *)&a2) * *(float *)&a4)
                            * (float)(*(float *)&a4 - 2.0));
      return (__m128)v9;
    case 3:
      v10 = *(float *)&a4 + *(float *)&a4;
      v11 = v4;
      *(float *)&v11 = (float)(*(float *)&v4 - *(float *)&a2) * 0.5;
      if ( (float)(*(float *)&a4 + *(float *)&a4) >= 1.0 )
      {
        v12 = *(_OWORD *)&a2;
        *(float *)&v12 = *(float *)&a2
                       - (float)((float)((float)((float)(v10 - 1.0) * (float)(v10 - 3.0)) - 1.0)
                               * (float)((float)(*(float *)&v4 - *(float *)&a2) * 0.5));
        return (__m128)v12;
      }
      else
      {
        *(float *)&v11 = (float)((float)(*(float *)&v11 * v10) * v10) + *(float *)&a2;
        return (__m128)v11;
      }
    case 4:
      v13 = *(_OWORD *)&a3;
      *(float *)&v13 = (float)((float)((float)(*(float *)&a3 - *(float *)&a2) * *(float *)&a4)
                             * (float)(*(float *)&a4 * *(float *)&a4))
                     + *(float *)&a2;
      return (__m128)v13;
    case 5:
      v14 = *(_OWORD *)&a4;
      *(float *)&v14 = (float)((float)((float)((float)((float)(*(float *)&a4 - 1.0) * (float)(*(float *)&a4 - 1.0))
                                             * (float)(*(float *)&a4 - 1.0))
                                     + 1.0)
                             * (float)(*(float *)&a3 - *(float *)&a2))
                     + *(float *)&a2;
      return (__m128)v14;
    case 6:
      v15 = *(_OWORD *)&a4;
      *(float *)&v15 = *(float *)&a4 + *(float *)&a4;
      v16 = (float)(*(float *)&a4 + *(float *)&a4) < 1.0;
      v17 = (float)(*(float *)&a3 - *(float *)&a2) * 0.5;
      if ( v16 )
      {
        *(float *)&v15 = (float)((float)(*(float *)&v15 * *(float *)&v15) * (float)(*(float *)&v15 * v17))
                       + *(float *)&a2;
        return (__m128)v15;
      }
      else
      {
        *(float *)&v15 = (float)((float)((float)((float)((float)(*(float *)&v15 + -2.0) * (float)(*(float *)&v15 + -2.0))
                                               * (float)(*(float *)&v15 + -2.0))
                                       + 2.0)
                               * v17)
                       + *(float *)&a2;
        return (__m128)v15;
      }
    case 7:
      if ( *(float *)&a4 != 0.0 )
      {
        n0x40000000 = 0x40000000u;
        *(float *)&n0x40000000 = powf(2.0, (float)(*(float *)&a4 - 1.0) * 10.0);
        n0x40000000_1 = n0x40000000;
        *(float *)&n0x40000000_1 = (float)(*(float *)&n0x40000000 * (float)(*(float *)&a3 - *(float *)&a2))
                                 + *(float *)&a2;
        return (__m128)n0x40000000_1;
      }
      return (__m128)v5;
    case 8:
      if ( *(float *)&a4 != 1.0 )
      {
        n0x3F800000 = 0x3F800000u;
        *(float *)&n0x3F800000 = (float)((float)(1.0 - powf(2.0, *(float *)&a4 * -10.0))
                                       * (float)(*(float *)&a3 - *(float *)&a2))
                               + *(float *)&a2;
        return (__m128)n0x3F800000;
      }
      return (__m128)v4;
    case 9:
      v21 = *(float *)&a4 + *(float *)&a4;
      if ( (float)(*(float *)&a4 + *(float *)&a4) == 0.0 )
        return (__m128)v5;
      if ( v21 == 1.0 )
      {
        return *(__m128 *)&a3;
      }
      else
      {
        v22 = (float)(*(float *)&a3 - *(float *)&a2) * 0.5;
        v23 = v21 - 1.0;
        if ( (float)(*(float *)&a4 + *(float *)&a4) >= 1.0 )
        {
          v26 = powf(2.0, v23 * -10.0);
          n0x40000000_2 = 0x40000000u;
          *(float *)&n0x40000000_2 = (float)((float)(2.0 - v26) * v22) + *(float *)&a2;
          return (__m128)n0x40000000_2;
        }
        else
        {
          n0x40000000_3 = 0x40000000u;
          *(float *)&n0x40000000_3 = powf(2.0, v23 * 10.0);
          n0x40000000_4 = n0x40000000_3;
          *(float *)&n0x40000000_4 = (float)(*(float *)&n0x40000000_3 * v22) + *(float *)&a2;
          return (__m128)n0x40000000_4;
        }
      }
    default:
      return (__m128)v4;
  }
}

// --- End Function: sub_141D12710 (0x141D12710) ---

// --- Function: sub_141DA59D0 (0x141DA59D0) ---
__int64 __fastcall sub_141DA59D0(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx
  __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 8);
  if ( v3 == *(_QWORD *)(a1 + 0x10) )
    return sub_1405F39F0(a1, v3, a2, a1);
  *(double *)v3 = *(double *)a2;
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = result + 0xC;
  return result;
}

// --- End Function: sub_141DA59D0 (0x141DA59D0) ---

// --- Function: sub_14214BEA0 (0x14214BEA0) ---
int *__fastcall sub_14214BEA0(__int64 a1)
{
  int *result; // rax
  int n0x25; // r13d
  volatile signed __int64 *v4; // rdi
  signed __int64 v5; // rbx
  _QWORD *v6; // rdi
  _QWORD *v7; // rbx
  __int128 n0x3F800000; // xmm8
  __int128 n0x466A6000; // xmm11
  __int64 v10; // r15
  float *v11; // r14
  __int64 v12; // rax
  __int64 v13; // rsi
  const char *p_[EXPIRED_ZONE]; // rbp
  float v15; // xmm1_4
  const char *p_km; // r12
  int v17; // r14d
  __int64 *v20; // rsi
  const char *v21; // rax
  __int128 v23; // [rsp+60h] [rbp-E8h] BYREF
  __int64 v24; // [rsp+70h] [rbp-D8h]
  __int64 p_rw_lock_state; // [rsp+78h] [rbp-D0h]
  int *v26; // [rsp+80h] [rbp-C8h]
  int v27; // [rsp+88h] [rbp-C0h] BYREF
  _UNKNOWN *retaddr; // [rsp+148h] [rbp+0h] BYREF

  result = (int *)&retaddr;
  if ( dword_149F04160 )
  {
    v23 = xmmword_1482BB410;
    sub_1402C7510(
      (__int64 *)qword_149C8E018,
      25.0,
      25.0,
      1.2,
      &v23,
      0,
      (__int64)"%-32s | %7s | %s",
      "Queued asteroid queries",
      "Radius",
      "Zone");
    n0x25 = 0x25;
    v4 = (volatile signed __int64 *)(a1 + 0xB8);
    v24 = a1 + 0xA0;
    p_rw_lock_state = a1 + 0xB8;
    v26 = &v27;
    v27 = 1;
    if ( *(_DWORD *)(a1 + 0xC8) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0xCC);
    }
    else
    {
      v5 = _InterlockedIncrement64(v4);
      if ( (v5 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch((__int64)v4, v5, (const char *)&p_Src, (const char *)&p_Src, 1);
    }
    v6 = *(_QWORD **)(v24 + 8);
    v7 = *(_QWORD **)v24;
    if ( *(_QWORD **)v24 != v6 )
    {
      n0x3F800000 = 0x3F800000u;
      n0x466A6000 = 0x466A6000u;
      *(float *)&v23 = 1.0;
      *((float *)&v23 + 3) = 1.0;
      do
      {
        v10 = *v7;
        v11 = (float *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v7 + 0x10LL))(*v7);
        v12 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL))(
                qword_149C8DF28,
                *(unsigned int *)v11);
        v13 = v12;
        if ( v12 )
          p_[EXPIRED_ZONE] = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x1F0LL))(v12);
        else
          p_[EXPIRED_ZONE] = "[EXPIRED ZONE]";
        v15 = v11[8];
        *((float *)&v23 + 1) = 1.0;
        *((float *)&v23 + 2) = 1.0;
        p_km = (char *)&stru_1484DE754.EstablisherFrame + 4;
        v17 = (int)v15;
        if ( v15 > 7500.0 )
        {
          v17 = (int)(float)(v15 * 0.001);
          __asm
          {
            vcmpltss xmm0, xmm11, xmm1
            vblendvps xmm0, xmm8, xmm7, xmm0
          }
          *((float *)&v23 + 1) = *(float *)&_XMM0;
          *((float *)&v23 + 2) = 0.0;
          p_km = "km";
        }
        if ( !v13 )
        {
          *((float *)&v23 + 1) = 0.0;
          *((float *)&v23 + 2) = 0.0;
        }
        v20 = (__int64 *)qword_149C8E018;
        v21 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
        sub_1402C7510(
          v20,
          25.0,
          (float)n0x25,
          1.2,
          &v23,
          0,
          (__int64)"%-32s | %5i%2s | %s",
          v21,
          v17,
          p_km,
          p_[EXPIRED_ZONE]);
        ++v7;
        n0x25 = (int)(float)((float)n0x25 + 12.0);
      }
      while ( v7 != v6 );
    }
    result = v26;
    if ( (*v26)-- == 1 )
      return (int *)rw_lock_release_read_lock(p_rw_lock_state);
  }
  return result;
}

// --- End Function: sub_14214BEA0 (0x14214BEA0) ---

// --- Function: sub_14215A470 (0x14215A470) ---
__int64 __fastcall sub_14215A470(__int64 a1)
{
  __int64 v1; // rbx
  int n0x7FFFFFFF; // esi
  signed __int64 v4; // rbp
  __int64 *v5; // r8
  __int64 *v6; // rcx
  __int64 v7; // rax
  int n0x7FFFFFFF_1; // edx
  int n0x5700; // [rsp+30h] [rbp-58h] BYREF
  __int64 v11; // [rsp+34h] [rbp-54h]
  int v12; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v13; // [rsp+40h] [rbp-48h]
  unsigned __int64 v14; // [rsp+48h] [rbp-40h]
  __int64 v15; // [rsp+50h] [rbp-38h]
  __int64 v16; // [rsp+58h] [rbp-30h]

  v1 = 0;
  n0x5700 = 0x5700;
  v11 = 1;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v13 = __rdtsc();
  qword_149C89AA0(
    &n0x5700,
    &word_149F043D0,
    "CAsteroidFieldManager::MT_Update",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Environment/AsteroidFieldManager.cpp",
    0x64);
  HIWORD(n0x5700) = word_149F043D0;
  if ( BYTE1(qword_149C8E516) )
  {
    if ( !byte_149C8E514 )
      goto LABEL_18;
  }
  else if ( BYTE2(qword_149C8E516) )
  {
    goto LABEL_18;
  }
  n0x7FFFFFFF = 0x7FFFFFFF;
  if ( *(_DWORD *)(a1 + 0x20) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x24);
  }
  else
  {
    v4 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x10));
    if ( (v4 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0x10, v4, "CAsteroidFieldManager::MT_Update", "m_fieldListLock", 1);
  }
  v5 = *(__int64 **)(a1 + 0x28);
  v6 = *(__int64 **)(a1 + 0x30);
  if ( v5 != v6 )
  {
    do
    {
      v7 = *v5;
      n0x7FFFFFFF_1 = *(_DWORD *)(*v5 + 0xC8);
      if ( n0x7FFFFFFF_1 >= n0x7FFFFFFF )
        v7 = v1;
      ++v5;
      v1 = v7;
      if ( n0x7FFFFFFF_1 >= n0x7FFFFFFF )
        n0x7FFFFFFF_1 = n0x7FFFFFFF;
      n0x7FFFFFFF = n0x7FFFFFFF_1;
    }
    while ( v5 != v6 );
    if ( v7 )
      sub_1403D30D0(v7, 2u);
  }
  rw_lock_release_read_lock(a1 + 0x10);
LABEL_18:
  sub_14214BEA0(a1);
  v14 = __rdtsc();
  return qword_149C89AA8(&n0x5700);
}

// --- End Function: sub_14215A470 (0x14215A470) ---

// --- Function: sub_142181BD0 (0x142181BD0) ---
__int64 __fastcall sub_142181BD0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 8);
  if ( v2 == *(_QWORD *)(a1 + 0x10) )
    return sub_142187310(a1, *(_QWORD *)(a1 + 8), a2);
  *(_QWORD *)v2 = *(_QWORD *)a2;
  sub_14035DDF0((_QWORD *)(v2 + 8), (__int64 *)(a2 + 8));
  *(_DWORD *)(v2 + 0x10) = *(_DWORD *)(a2 + 0x10);
  *(_DWORD *)(v2 + 0x14) = *(_DWORD *)(a2 + 0x14);
  *(_DWORD *)(v2 + 0x18) = *(_DWORD *)(a2 + 0x18);
  *(_DWORD *)(v2 + 0x1C) = *(_DWORD *)(a2 + 0x1C);
  *(_DWORD *)(v2 + 0x20) = *(_DWORD *)(a2 + 0x20);
  *(_DWORD *)(v2 + 0x24) = *(_DWORD *)(a2 + 0x24);
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = result + 0x28;
  return result;
}

// --- End Function: sub_142181BD0 (0x142181BD0) ---

// --- Function: sub_142187310 (0x142187310) ---
unsigned __int64 __fastcall sub_142187310(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rsi
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v13; // rax
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // r8
  __int64 v17; // rdx
  __int64 v18; // rcx

  v6 = (a2 - *a1) / 0x28;
  v7 = (a1[1] - *a1) / 0x28;
  if ( v7 == 0x666666666666666LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x28;
  v10 = v9 >> 1;
  if ( v9 > 0x666666666666666LL - (v9 >> 1) )
    goto LABEL_18;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0x666666666666666LL )
    goto LABEL_18;
  allocSize = 0x28 * v11;
  if ( 0x28 * v11 < 0x1000 )
  {
    if ( allocSize )
      v14 = sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_14;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_18:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    invalid_parameter_noinfo_noreturn();
  v14 = (v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_14:
  v15 = v14 + 0x28 * v6;
  *(_QWORD *)v15 = *(_QWORD *)a3;
  sub_14035DDF0((_QWORD *)(v15 + 8), (__int64 *)(a3 + 8));
  v16 = v14;
  *(_DWORD *)(v15 + 0x10) = *(_DWORD *)(a3 + 0x10);
  *(_DWORD *)(v15 + 0x14) = *(_DWORD *)(a3 + 0x14);
  *(_DWORD *)(v15 + 0x18) = *(_DWORD *)(a3 + 0x18);
  *(_DWORD *)(v15 + 0x1C) = *(_DWORD *)(a3 + 0x1C);
  *(_DWORD *)(v15 + 0x20) = *(_DWORD *)(a3 + 0x20);
  *(_DWORD *)(v15 + 0x24) = *(_DWORD *)(a3 + 0x24);
  v17 = a1[1];
  v18 = *a1;
  if ( a2 != v17 )
  {
    sub_142199780(v18, a2, v14, a1);
    v17 = a1[1];
    v16 = v15 + 0x28;
    v18 = a2;
  }
  sub_142199780(v18, v17, v16, a1);
  sub_14231A9D0(a1, v14, v8, v11);
  return v15;
}

// --- End Function: sub_142187310 (0x142187310) ---

// --- Function: sub_142188690 (0x142188690) ---
__int64 __fastcall sub_142188690(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 0x19); result = sub_1402A6590(v6) )
  {
    sub_142188690(a1, a2, *(_QWORD *)(i + 0x10));
    v6 = i;
    i = *(_QWORD *)i;
    sub_14231CE10(v6 + 0x28);
  }
  return result;
}

// --- End Function: sub_142188690 (0x142188690) ---

// --- Function: sub_14218BB00 (0x14218BB00) ---
void __fastcall sub_14218BB00(__int64 a1, __int64 a2, unsigned __int8 (__fastcall *a3)(_QWORD, __int64))
{
  __int64 v5; // r13
  __int64 v6; // rbp
  __int64 v7; // rdx
  __int64 v8; // r14
  __int64 v9; // r15
  __int64 v10; // rbx
  __int64 v11; // rcx
  __int64 v12; // rdi

  v5 = (a2 - a1) >> 3;
  v6 = (a2 - a1) >> 4;
  if ( v6 > 0 )
  {
    v7 = v5 - 1;
    v8 = (v5 - 1) >> 1;
    do
    {
      v9 = *(_QWORD *)(a1 + 8 * v6-- - 8);
      v10 = v6;
      v11 = v6;
      if ( v6 < v8 )
      {
        do
        {
          v11 = 2 * v11 + 2LL - (a3(*(_QWORD *)(a1 + 0x10 * v11 + 0x10), *(_QWORD *)(a1 + 0x10 * v11 + 8)) != 0);
          *(_QWORD *)(a1 + 8 * v10) = *(_QWORD *)(a1 + 8 * v11);
          v10 = v11;
        }
        while ( v11 < v8 );
        v7 = v5 - 1;
      }
      if ( v10 == v8 && (v5 & 1) == 0 )
      {
        *(_QWORD *)(a1 + 8 * v10) = *(_QWORD *)(a1 + 8 * v5 - 8);
        v10 = v7;
      }
      if ( v6 < v10 )
      {
        do
        {
          v12 = (v10 - 1) >> 1;
          if ( !a3(*(_QWORD *)(a1 + 8 * v12), v9) )
            break;
          *(_QWORD *)(a1 + 8 * v10) = *(_QWORD *)(a1 + 8 * v12);
          v10 = (v10 - 1) >> 1;
        }
        while ( v6 < v12 );
      }
      *(_QWORD *)(a1 + 8 * v10) = v9;
      v7 = v5 - 1;
    }
    while ( v6 > 0 );
  }
}

// --- End Function: sub_14218BB00 (0x14218BB00) ---

// --- Function: sub_1421941F0 (0x1421941F0) ---
signed __int64 __fastcall sub_1421941F0(__int64 *a1, __int64 a2, __int64 a3)
{
  signed __int64 n0x10; // rax
  __int64 *v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // [rsp+40h] [rbp+8h] BYREF

  n0x10 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  if ( n0x10 >= 0x10 )
  {
    v6 = (__int64 *)(a2 - 8);
    v7 = 8LL - (_QWORD)a1;
    do
    {
      v8 = *v6;
      *v6 = *a1;
      sub_14056D430((_DWORD)a1, 0, v6 - a1, (unsigned int)&v8, a3);
      v6 += 0xFFFFFFFF;
      n0x10 = ((unsigned __int64)v6 + v7) & 0xFFFFFFFFFFFFFFF8uLL;
    }
    while ( n0x10 >= 0x10 );
  }
  return n0x10;
}

// --- End Function: sub_1421941F0 (0x1421941F0) ---

// --- Function: sub_1421949A0 (0x1421949A0) ---
signed __int64 __fastcall sub_1421949A0(
        char *_First_2,
        Chaos::FCCDConstraint **_First_7,
        __int64 a3,
        bool (__fastcall *_Pred)(const Chaos::FCCDConstraint *, const Chaos::FCCDConstraint *))
{
  signed __int64 n0x100; // rax
  Chaos::FCCDConstraint **_First_3; // r12
  Chaos::FCCDConstraint **_First; // r15
  Chaos::FCCDConstraint **_First_5; // rsi
  Chaos::FCCDConstraint **_First_1; // rdi
  Chaos::FCCDConstraint **_First_8; // rdi
  Chaos::FCCDConstraint *v12; // rsi
  Chaos::FCCDConstraint **_First_9; // r14
  char *v14; // r8
  Chaos::FCCDConstraint **_First_10; // rbx
  Chaos::FCCDConstraint *v16; // rdx
  Chaos::FCCDConstraint **_First_6; // [rsp+20h] [rbp-28h] BYREF
  Chaos::FCCDConstraint **_First_4; // [rsp+28h] [rbp-20h]

  n0x100 = ((char *)_First_7 - _First_2) & 0xFFFFFFFFFFFFFFF8uLL;
  _First_3 = _First_7;
  _First = (Chaos::FCCDConstraint **)_First_2;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( _First != _First_3 )
    {
      _First_8 = _First + 1;
      while ( _First_8 != _First_3 )
      {
        v12 = *_First_8;
        _First_9 = _First_8;
        if ( _Pred(*_First_8, *_First) )
        {
          v14 = (char *)_First_8++;
          n0x100 = (signed __int64)memmove((char *)_First_8 - (v14 - (char *)_First), _First, v14 - (char *)_First);
          *_First = v12;
        }
        else
        {
          _First_10 = _First_8 + 0xFFFFFFFF;
          for ( n0x100 = ((__int64 (__fastcall *)(Chaos::FCCDConstraint *, Chaos::FCCDConstraint *))_Pred)(
                           v12,
                           _First_8[0xFFFFFFFF]);
                (_BYTE)n0x100;
                n0x100 = ((__int64 (__fastcall *)(Chaos::FCCDConstraint *, Chaos::FCCDConstraint *))_Pred)(v12, v16) )
          {
            *_First_9 = *_First_10;
            _First_9 = _First_10;
            v16 = _First_10[0xFFFFFFFF];
            _First_10 += 0xFFFFFFFF;
          }
          *_First_9 = v12;
          ++_First_8;
        }
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      std::_Partition_by_median_guess_unchecked<Chaos::FCCDConstraint * *,bool (*)(Chaos::FCCDConstraint const *,Chaos::FCCDConstraint const *)>(
        &_First_6,
        _First,
        _First_3,
        _Pred);
      _First_5 = _First_6;
      _First_1 = _First_4;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)_First_6 - (char *)_First) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)(((char *)_First_3
                                                                                              - (char *)_First_4)
                                                                                             & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1421949A0(_First_4, _First_3, a3, _Pred);
        _First_3 = _First_5;
      }
      else
      {
        sub_1421949A0(_First, _First_6, a3, _Pred);
        _First = _First_1;
      }
      n0x100 = ((char *)_First_3 - (char *)_First) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    sub_14218BB00((__int64)_First, (__int64)_First_3, (unsigned __int8 (__fastcall *)(_QWORD, __int64))_Pred);
    return sub_1421941F0((__int64 *)_First, (__int64)_First_3, (__int64)_Pred);
  }
  return n0x100;
}

// --- End Function: sub_1421949A0 (0x1421949A0) ---

// --- Function: sub_142199780 (0x142199780) ---
_QWORD *__fastcall sub_142199780(_DWORD *a1, _DWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rdi
  _DWORD *v5; // rbx
  char *v6; // rsi

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = a1 + 4;
    v6 = (char *)((char *)a3 - (char *)a1);
    do
    {
      *v3 = *((_QWORD *)v5 + 0xFFFFFFFE);
      sub_14035DDF0(&v6[(_QWORD)v5 + 0xFFFFFFF8LL], (__int64 *)v5 + 0xFFFFFFFF);
      v3 += 5;
      *(_DWORD *)&v6[(_QWORD)v5] = *v5;
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 4) = v5[1];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 8) = v5[2];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 0xC) = v5[3];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 0x10) = v5[4];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 0x14) = v5[5];
      v5 += 0xA;
    }
    while ( v5 + 0xFFFFFFFC != a2 );
  }
  return v3;
}

// --- End Function: sub_142199780 (0x142199780) ---

// --- Function: sub_14219AD20 (0x14219AD20) ---
char __fastcall sub_14219AD20(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14)
{
  void *v18; // rsp
  __int64 v20; // [rsp+18h] [rbp-2B8h]
  _BYTE __Val_0___[592]; // [rsp+30h] [rbp-2A0h] BYREF

  v18 = alloca(0x2A0);
  sub_14219FD60((unsigned int)__Val_0___, a9, a10, a11, a12, a13, a14);
  LODWORD(v20) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 6u, a5, v20, a7, a8);
}

// --- End Function: sub_14219AD20 (0x14219AD20) ---

// --- Function: sub_14219DF00 (0x14219DF00) ---
char __fastcall sub_14219DF00(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17)
{
  void *v21; // rsp
  const char *p_null; // r8
  unsigned __int64 v23; // rax
  const char *p_null_1; // rdx
  unsigned __int64 v25; // rcx
  __int64 v27; // [rsp+18h] [rbp-408h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-3F0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-398h]
  __int64 n0xB0; // [rsp+90h] [rbp-390h]
  __int64 n0xA8; // [rsp+98h] [rbp-388h]
  _QWORD *v32; // [rsp+A0h] [rbp-380h]
  const char *p_Name; // [rsp+A8h] [rbp-378h]
  __int64 v34; // [rsp+B0h] [rbp-370h]
  __int64 (__fastcall *p_sub_1403EF810)(__int64, void *, size_t, __int64, char); // [rsp+B8h] [rbp-368h]
  __int64 (__fastcall *p_sub_1403EF370)(__int64, __int64, __int64, __int64); // [rsp+C0h] [rbp-360h]
  __int64 v37; // [rsp+C8h] [rbp-358h]
  bool (__fastcall *p_sub_1403EBA20)(__int64, __int64); // [rsp+D0h] [rbp-350h]
  __int64 v39; // [rsp+D8h] [rbp-348h]
  __int64 (__fastcall *p_sub_1403E9250)(__int64); // [rsp+E0h] [rbp-340h]
  _QWORD *(__fastcall *p_sub_1403E8F70)(_QWORD *); // [rsp+E8h] [rbp-338h]
  unsigned __int64 v42; // [rsp+F0h] [rbp-330h]
  char v43; // [rsp+F8h] [rbp-328h]
  char v44; // [rsp+F9h] [rbp-327h]
  __int64 n0x18; // [rsp+100h] [rbp-320h]
  unsigned __int64 v46; // [rsp+108h] [rbp-318h]
  _QWORD *v47; // [rsp+110h] [rbp-310h]
  const char *p_NetworkNodeId; // [rsp+118h] [rbp-308h]
  __int64 v49; // [rsp+120h] [rbp-300h]
  __int64 (__fastcall *p_sub_1403EF810_1)(__int64, void *, size_t, __int64, char); // [rsp+128h] [rbp-2F8h]
  __int64 (__fastcall *p_sub_1403EF370_1)(__int64, __int64, __int64, __int64); // [rsp+130h] [rbp-2F0h]
  __int64 v52; // [rsp+138h] [rbp-2E8h]
  bool (__fastcall *p_sub_1403EBA20_1)(__int64, __int64); // [rsp+140h] [rbp-2E0h]
  __int64 v54; // [rsp+148h] [rbp-2D8h]
  __int64 (__fastcall *p_sub_1403E9250_1)(__int64); // [rsp+150h] [rbp-2D0h]
  _QWORD *(__fastcall *p_sub_1403E8F70_1)(_QWORD *); // [rsp+158h] [rbp-2C8h]
  unsigned __int64 v57; // [rsp+160h] [rbp-2C0h]
  char v58; // [rsp+168h] [rbp-2B8h]
  char v59; // [rsp+169h] [rbp-2B7h]
  __int64 n0x18_1; // [rsp+170h] [rbp-2B0h]
  unsigned __int64 v61; // [rsp+178h] [rbp-2A8h]
  __int64 v62; // [rsp+180h] [rbp-2A0h] BYREF

  v21 = alloca(0x3F0);
  p_null = "null";
  __Val_0___[0] = a9;
  p_Name = "Name";
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  v32 = a10;
  __Val_0___[9] = sub_1403E8F30;
  v23 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v44 = 0;
  v34 = *a10;
  p_sub_1403EF810 = sub_1403EF810;
  p_sub_1403EF370 = sub_1403EF370;
  p_sub_1403EBA20 = sub_1403EBA20;
  p_sub_1403E9250 = sub_1403E9250;
  p_sub_1403E8F70 = sub_1403E8F70;
  v37 = 0;
  v39 = 0;
  v42 = 0xFFFFFFFFFFFFFFFFuLL;
  v43 = 0;
  n0x18 = 0x18;
  p_null_1 = "null";
  if ( a10[1] )
    p_null_1 = (const char *)a10[1];
  v25 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v25;
  while ( p_null_1[v25] );
  v46 = v25;
  p_NetworkNodeId = "NetworkNodeId";
  v47 = a11;
  v59 = 0;
  v49 = *a11;
  p_sub_1403EF810_1 = sub_1403EF810;
  p_sub_1403EF370_1 = sub_1403EF370;
  p_sub_1403EBA20_1 = sub_1403EBA20;
  p_sub_1403E9250_1 = sub_1403E9250;
  p_sub_1403E8F70_1 = sub_1403E8F70;
  v52 = 0;
  v54 = 0;
  v57 = 0xFFFFFFFFFFFFFFFFuLL;
  v58 = 0;
  n0x18_1 = 0x18;
  if ( a11[1] )
    p_null = (const char *)a11[1];
  do
    ++v23;
  while ( p_null[v23] );
  v61 = v23;
  sub_1421A1760((unsigned int)&v62, a12, a13, a14, a15, a16, a17);
  LODWORD(v27) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 9u, a5, v27, a7, a8);
}

// --- End Function: sub_14219DF00 (0x14219DF00) ---

// --- Function: sub_14219FD60 (0x14219FD60) ---
__int64 __fastcall sub_14219FD60(
        __int64 __Val_0__,
        __int64 a2,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        _QWORD *a7)
{
  unsigned __int64 v7; // r10
  const char *p_null; // r8
  const char *p_null_1; // rdx
  unsigned __int64 v10; // rax
  __int64 n6; // rax

  *(_QWORD *)__Val_0__ = a2;
  v7 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(__Val_0__ + 0x70) = a3;
  *(_WORD *)(__Val_0__ + 0x58) = 0x100;
  *(_QWORD *)(__Val_0__ + 0x10) = 0;
  *(_QWORD *)(__Val_0__ + 8) = "TraceContext";
  *(_QWORD *)(__Val_0__ + 0x28) = 0;
  *(_QWORD *)(__Val_0__ + 0x18) = sub_1403EF930;
  *(_QWORD *)(__Val_0__ + 0x38) = 0;
  *(_QWORD *)(__Val_0__ + 0x20) = sub_1403EF4D0;
  *(_QWORD *)(__Val_0__ + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(__Val_0__ + 0x30) = sub_1403EBBC0;
  *(_QWORD *)(__Val_0__ + 0x60) = 0xB0;
  *(_QWORD *)(__Val_0__ + 0x40) = sub_1403E9230;
  *(_QWORD *)(__Val_0__ + 0x48) = sub_1403E8F30;
  *(_QWORD *)(__Val_0__ + 0x68) = 0xA8;
  *(_QWORD *)(__Val_0__ + 0x78) = "UInt";
  *(_BYTE *)(__Val_0__ + 0xC9) = 0;
  *(_QWORD *)(__Val_0__ + 0x80) = *a3;
  *(_QWORD *)(__Val_0__ + 0xB8) = sub_1403E8F40;
  *(_QWORD *)(__Val_0__ + 0xB0) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x88) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x90) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x98) = 0;
  *(_QWORD *)(__Val_0__ + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0xA8) = 0;
  *(_QWORD *)(__Val_0__ + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0xC8) = 0;
  *(_QWORD *)(__Val_0__ + 0xD0) = 0x10;
  *(_QWORD *)(__Val_0__ + 0xD8) = 0x15;
  *(_QWORD *)(__Val_0__ + 0xE0) = a4;
  *(_QWORD *)(__Val_0__ + 0xE8) = "UInt";
  *(_BYTE *)(__Val_0__ + 0x139) = 0;
  *(_QWORD *)(__Val_0__ + 0xF0) = *a4;
  *(_QWORD *)(__Val_0__ + 0x150) = a5;
  *(_QWORD *)(__Val_0__ + 0x128) = sub_1403E8F40;
  *(_QWORD *)(__Val_0__ + 0xF8) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x100) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x108) = 0;
  *(_QWORD *)(__Val_0__ + 0x110) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0x118) = 0;
  *(_QWORD *)(__Val_0__ + 0x120) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x138) = 0;
  *(_QWORD *)(__Val_0__ + 0x140) = 0x10;
  *(_QWORD *)(__Val_0__ + 0x148) = 0x15;
  *(_QWORD *)(__Val_0__ + 0x158) = "EntityId";
  *(_BYTE *)(__Val_0__ + 0x1A9) = 1;
  *(_QWORD *)(__Val_0__ + 0x160) = *a5;
  *(_QWORD *)(__Val_0__ + 0x168) = sub_1403EF7E0;
  *(_QWORD *)(__Val_0__ + 0x170) = sub_1403EF240;
  *(_QWORD *)(__Val_0__ + 0x180) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0x190) = sub_1403E9280;
  *(_QWORD *)(__Val_0__ + 0x198) = sub_1403E9050;
  *(_QWORD *)(__Val_0__ + 0x178) = 0;
  *(_QWORD *)(__Val_0__ + 0x188) = 0;
  *(_QWORD *)(__Val_0__ + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x1A8) = 0;
  *(_QWORD *)(__Val_0__ + 0x1C8) = "Name";
  p_null = "null";
  *(_QWORD *)(__Val_0__ + 0x1C0) = a6;
  *(_QWORD *)(__Val_0__ + 0x1B0) = 0x18;
  *(_QWORD *)(__Val_0__ + 0x1B8) = 0x17;
  *(_BYTE *)(__Val_0__ + 0x219) = 0;
  *(_QWORD *)(__Val_0__ + 0x1D0) = *a6;
  *(_QWORD *)(__Val_0__ + 0x1D8) = sub_1403EF810;
  *(_QWORD *)(__Val_0__ + 0x1E0) = sub_1403EF370;
  *(_QWORD *)(__Val_0__ + 0x1F0) = sub_1403EBA20;
  *(_QWORD *)(__Val_0__ + 0x200) = sub_1403E9250;
  *(_QWORD *)(__Val_0__ + 0x208) = sub_1403E8F70;
  *(_QWORD *)(__Val_0__ + 0x1E8) = 0;
  *(_QWORD *)(__Val_0__ + 0x1F8) = 0;
  *(_QWORD *)(__Val_0__ + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x218) = 0;
  *(_QWORD *)(__Val_0__ + 0x220) = 0x18;
  p_null_1 = "null";
  if ( a6[1] )
    p_null_1 = (const char *)a6[1];
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( p_null_1[v10] );
  *(_QWORD *)(__Val_0__ + 0x228) = v10;
  *(_QWORD *)(__Val_0__ + 0x238) = "NetworkNodeId";
  *(_QWORD *)(__Val_0__ + 0x230) = a7;
  *(_BYTE *)(__Val_0__ + 0x289) = 0;
  *(_QWORD *)(__Val_0__ + 0x240) = *a7;
  *(_QWORD *)(__Val_0__ + 0x248) = sub_1403EF810;
  *(_QWORD *)(__Val_0__ + 0x250) = sub_1403EF370;
  *(_QWORD *)(__Val_0__ + 0x260) = sub_1403EBA20;
  *(_QWORD *)(__Val_0__ + 0x270) = sub_1403E9250;
  *(_QWORD *)(__Val_0__ + 0x278) = sub_1403E8F70;
  *(_QWORD *)(__Val_0__ + 0x258) = 0;
  *(_QWORD *)(__Val_0__ + 0x268) = 0;
  *(_QWORD *)(__Val_0__ + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x288) = 0;
  *(_QWORD *)(__Val_0__ + 0x290) = 0x18;
  if ( a7[1] )
    p_null = (const char *)a7[1];
  do
    ++v7;
  while ( p_null[v7] );
  n6 = 6;
  *(_QWORD *)(__Val_0__ + 0x298) = v7;
  return n6;
}

// --- End Function: sub_14219FD60 (0x14219FD60) ---

// --- Function: sub_1421A1760 (0x1421A1760) ---
__int64 __fastcall sub_1421A1760(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6, __int64 a7)
{
  const char *p_null; // rdx
  const char *p_null_2; // rax
  const char *p_null_1; // r8
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  __int64 n6; // rax

  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 8) = "EntityId";
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF7E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF240;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x30) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9280;
  p_null = "null";
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x48) = sub_1403E9050;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  *(_QWORD *)(a1 + 0x68) = 0x17;
  *(_QWORD *)(a1 + 0x78) = "Text";
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EF810;
  *(_QWORD *)(a1 + 0x90) = sub_1403EF370;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403EBA20;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9250;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F70;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  p_null_2 = (const char *)a3[1];
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( p_null_1[v10] );
  *(_QWORD *)(a1 + 0xD8) = v10;
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_QWORD *)(a1 + 0xE8) = "Text";
  *(_BYTE *)(a1 + 0x139) = 0;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EF810;
  *(_QWORD *)(a1 + 0x100) = sub_1403EF370;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = sub_1403EBA20;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_1403E9250;
  *(_QWORD *)(a1 + 0x128) = sub_1403E8F70;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x18;
  if ( a4[1] )
    p_null = (const char *)a4[1];
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v11;
  while ( p_null[v11] );
  *(_QWORD *)(a1 + 0x148) = v11;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_QWORD *)(a1 + 0x158) = "Int";
  *(_BYTE *)(a1 + 0x1A9) = 0;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x168) = sub_140509A20;
  *(_QWORD *)(a1 + 0x170) = sub_140509A20;
  *(_QWORD *)(a1 + 0x180) = FH4::HandlerMap4::iterator::operator==;
  *(_QWORD *)(a1 + 0x190) = sub_1403E9240;
  *(_QWORD *)(a1 + 0x198) = sub_1403E8F40;
  *(_QWORD *)(a1 + 0x1C0) = a6;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1C8) = "Boolean";
  *(_BYTE *)(a1 + 0x219) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x1B0) = 0x10;
  *(_QWORD *)(a1 + 0x1B8) = 0x15;
  *(_QWORD *)(a1 + 0x1D0) = *(_QWORD *)(a6 + 8);
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_BYTE *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x230) = a7;
  *(_QWORD *)(a1 + 0x238) = "Boolean";
  *(_BYTE *)(a1 + 0x289) = 0;
  *(_QWORD *)(a1 + 0x1D8) = sub_140ABCDB0;
  *(_QWORD *)(a1 + 0x1E0) = sub_140ABCC50;
  *(_QWORD *)(a1 + 0x1F0) = sub_140ABBCA0;
  *(_QWORD *)(a1 + 0x200) = sub_1403E9240;
  *(_QWORD *)(a1 + 0x208) = sub_1403E8F40;
  *(_QWORD *)(a1 + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x220) = 0x10;
  *(_QWORD *)(a1 + 0x228) = 0x15;
  *(_QWORD *)(a1 + 0x240) = *(_QWORD *)(a7 + 8);
  n6 = 6;
  *(_QWORD *)(a1 + 0x258) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_BYTE *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x248) = sub_140ABCDB0;
  *(_QWORD *)(a1 + 0x250) = sub_140ABCC50;
  *(_QWORD *)(a1 + 0x260) = sub_140ABBCA0;
  *(_QWORD *)(a1 + 0x270) = sub_1403E9240;
  *(_QWORD *)(a1 + 0x278) = sub_1403E8F40;
  *(_QWORD *)(a1 + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x290) = 0x10;
  *(_QWORD *)(a1 + 0x298) = 0x15;
  return n6;
}

// --- End Function: sub_1421A1760 (0x1421A1760) ---

// --- Function: sub_1421C74A0 (0x1421C74A0) ---
_QWORD *__fastcall sub_1421C74A0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  Chaos::FCCDConstraint **_First; // r13
  __int64 v4; // rbp
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 *v7; // r15
  __int64 *v8; // r14
  __int64 *v9; // rbx
  __int64 *v10; // rsi
  bool (__fastcall *_Pred)(const Chaos::FCCDConstraint *, const Chaos::FCCDConstraint *); // r12
  Chaos::FCCDConstraint *v12; // rax
  __int64 v13; // rdi
  __int64 v14; // rbp
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // r15
  __int64 v18; // rbx
  __int64 v19; // rbx
  __int64 v20; // rdi
  Chaos::FCCDConstraint **_First_1; // rdi
  _QWORD *result; // rax
  __int64 (__fastcall *v23)(Chaos::FCCDConstraint *); // rsi
  Chaos::FCCDConstraint *v24; // rbx
  __int64 v25; // rdx
  __int64 *v26; // [rsp+20h] [rbp-B8h]
  __int64 v29; // [rsp+38h] [rbp-A0h]
  Chaos::FCCDConstraint *_First_; // [rsp+40h] [rbp-98h] BYREF
  __m256 v31; // [rsp+48h] [rbp-90h]
  __m256 v32; // [rsp+68h] [rbp-70h]
  __int64 v33; // [rsp+88h] [rbp-50h]
  _QWORD v34[9]; // [rsp+90h] [rbp-48h] BYREF

  v2 = *((int *)a1 + 2);
  _First = &_First_;
  _First_ = 0;
  v4 = a2;
  v31 = (__m256)0LL;
  v5 = *a1;
  v6 = a2 + 6 * v2;
  v32 = (__m256)0LL;
  v7 = a1;
  v8 = (__int64 *)(v5 + 0x18 * (v6 + 2));
  v33 = 0;
  v9 = *(__int64 **)(v5 + 0x20);
  v10 = *(__int64 **)(v5 + 0x18);
  _Pred = (bool (__fastcall *)(const Chaos::FCCDConstraint *, const Chaos::FCCDConstraint *))qword_149F044B0[2 * v6];
  v26 = v9;
  if ( v10 != v9 )
  {
    do
    {
      if ( _First == v34 )
        break;
      v12 = (Chaos::FCCDConstraint *)*v10++;
      *_First++ = v12;
    }
    while ( v10 != v9 );
    __asm { vzeroupper }
    sub_14218BB00(&_First_, _First, (unsigned __int8 (__fastcall *)(_QWORD, __int64))_Pred);
    if ( v10 != v9 )
    {
      do
      {
        if ( _Pred((const Chaos::FCCDConstraint *)*v10, _First_) )
        {
          v13 = 0;
          v14 = _First - &_First_;
          v15 = 0;
          v16 = v14 - 1;
          v17 = (v14 - 1) >> 1;
          if ( v17 > 0 )
          {
            do
            {
              v15 = 2 * v15
                  + 2LL
                  - _Pred(
                      *(const Chaos::FCCDConstraint **)&v31.m256_f32[4 * v15 + 2],
                      *(const Chaos::FCCDConstraint **)&v31.m256_f32[4 * v15]);
              *(&_First_ + v13) = *(&_First_ + v15);
              v13 = v15;
            }
            while ( v15 < v17 );
            v16 = v14 - 1;
          }
          if ( v13 == v17 && (v14 & 1) == 0 )
          {
            *(&_First_ + v13) = (Chaos::FCCDConstraint *)*(&v29 + v14);
            v13 = v16;
          }
          if ( v13 > 0 )
          {
            do
            {
              v18 = (v13 - 1) >> 1;
              if ( !_Pred(*(&_First_ + v18), (const Chaos::FCCDConstraint *)*v10) )
                break;
              *(&_First_ + v13) = *(&_First_ + v18);
              v13 = (v13 - 1) >> 1;
            }
            while ( v18 > 0 );
          }
          v9 = v26;
          *(&_First_ + v13) = (Chaos::FCCDConstraint *)*v10;
        }
        ++v10;
      }
      while ( v10 != v9 );
      v7 = a1;
      v4 = a2;
    }
    sub_1421941F0((__int64 *)&_First_, _First, _Pred);
  }
  v19 = *v8;
  v20 = v8[1];
  if ( *v8 != v20 )
  {
    do
    {
      __asm { vzeroupper }
      sub_140373CC0((_QWORD *)(v19 + 8));
      v19 += 0x78;
    }
    while ( v19 != v20 );
    v8[1] = *v8;
  }
  _First_1 = &_First_;
  result = (_QWORD *)(2 * (v4 + 6LL * *((int *)v7 + 2)));
  v23 = (__int64 (__fastcall *)(Chaos::FCCDConstraint *))qword_149F044B0[0xC * *((int *)v7 + 2) + 1 + 2 * v4];
  do
  {
    v24 = *_First_1;
    if ( !*_First_1 )
      break;
    __asm { vzeroupper }
    result = (_QWORD *)v23(*_First_1);
    if ( !(_BYTE)result )
      break;
    v25 = v8[1];
    if ( v25 == v8[2] )
    {
      sub_142183A70(v8, v25, v24);
    }
    else
    {
      sub_1421A3350(v8, v25, v24);
      v8[1] += 0x78;
    }
    ++_First_1;
    result = v34;
  }
  while ( _First_1 != v34 );
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1421C74A0 (0x1421C74A0) ---

// --- Function: sub_1421D7030 (0x1421D7030) ---
__int64 __fastcall sub_1421D7030(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned int v5; // r14d
  char *v6; // rax
  char *v7; // rax
  char *v8; // rdi
  _OWORD *v9; // rax
  __int64 v10; // rbx
  __int128 Src; // [rsp+30h] [rbp-D0h] BYREF
  int n0x6500; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v14; // [rsp+44h] [rbp-BCh]
  int v15; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v16; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v17; // [rsp+58h] [rbp-A8h]
  __int64 v18; // [rsp+60h] [rbp-A0h]
  __int64 v19; // [rsp+68h] [rbp-98h]
  __int64 v20; // [rsp+90h] [rbp-70h] BYREF
  void (__fastcall *n2_2)(__int64, __int64 *); // [rsp+98h] [rbp-68h]
  __int64 (__fastcall *p_sub_1421EE7B0)(); // [rsp+A8h] [rbp-58h] BYREF
  __int64 (__fastcall *n2)(); // [rsp+B0h] [rbp-50h]
  _OWORD *v24; // [rsp+B8h] [rbp-48h]
  __int64 v25; // [rsp+C0h] [rbp-40h] BYREF
  void (__fastcall *n2_1)(__int64, __int64 *); // [rsp+C8h] [rbp-38h]
  unsigned int v27; // [rsp+D8h] [rbp-28h]
  void *v28[2]; // [rsp+E0h] [rbp-20h] BYREF
  char *v29; // [rsp+F0h] [rbp-10h]

  v14 = 0;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  n0x6500 = 0x6500;
  v16 = __rdtsc();
  qword_149C89AA0(
    &n0x6500,
    &word_149F08650,
    "CSerializedProfileMetrics::AcculumateComponentMetrics",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
    0x1F2);
  HIWORD(n0x6500) = word_149F08650;
  v5 = 8 * (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x18LL))(qword_149C8E038);
  if ( (unsigned int)((__int64)(a2[4] - a2[3]) >> 3) < v5 )
    v5 = (__int64)(a2[4] - a2[3]) >> 3;
  sub_1402B3B60((__int64)&v20, 0x65, 0, "CSerializedProfileMetrics::AcculumateComponentMetrics - %s", *a2);
  v27 = v5;
  *(_QWORD *)&Src = a3;
  if ( (v29 - (char *)v28[0]) >> 3 )
  {
    if ( ((char *)v28[1] - (char *)v28[0]) >> 3 )
    {
      v7 = (char *)v28[0] + 8;
      *(_QWORD *)v28[0] = a3;
    }
    else
    {
      memmove(v28[0], &Src, 0);
      v8 = (char *)v28[1];
      memmove(v28[1], &Src, 8u);
      v7 = v8 + 8;
    }
  }
  else
  {
    if ( v28[0] )
    {
      sub_1403A6820((__int64)v28, (unsigned __int64)v28[0], 0);
      *(_OWORD *)v28 = 0;
      v29 = 0;
    }
    v6 = (char *)sub_140394E70((__int64)v28, 8u);
    v28[0] = v6;
    v29 = v6 + 8;
    *(_QWORD *)v6 = Src;
    v7 = v6 + 8;
  }
  v28[1] = v7;
  LODWORD(Src) = v5;
  *((_QWORD *)&Src + 1) = a2;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2)(2, &p_sub_1421EE7B0);
    n2 = 0;
  }
  p_sub_1421EE7B0 = 0;
  v9 = (_OWORD *)sub_1402A65A0(0x10u);
  if ( v9 )
  {
    *v9 = Src;
    v24 = v9;
  }
  else
  {
    v24 = 0;
  }
  p_sub_1421EE7B0 = sub_1421EE7B0;
  n2 = sub_1421F1F40;
  v10 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, &v20);
  if ( v28[0] )
  {
    sub_1403A6820((__int64)v28, (unsigned __int64)v28[0], (v29 - (char *)v28[0]) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_OWORD *)v28 = 0;
    v29 = 0;
  }
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, &v25);
    n2_1 = 0;
  }
  v25 = 0;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2)(2, &p_sub_1421EE7B0);
    n2 = 0;
  }
  p_sub_1421EE7B0 = 0;
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, &v20);
    n2_2 = 0;
  }
  v20 = 0;
  v17 = __rdtsc();
  qword_149C89AA8(&n0x6500);
  return v10;
}

// --- End Function: sub_1421D7030 (0x1421D7030) ---

// --- Function: sub_1421EEF70 (0x1421EEF70) ---
_QWORD *__fastcall sub_1421EEF70(__int64 a1, __int64 a2)
{
  __int64 *v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rbp
  _QWORD *v5; // rdi
  _QWORD *result; // rax
  __int64 (__fastcall *v7)(__int64); // rbp
  __int64 *v8; // rsi
  __int64 v9; // rbx
  __int64 v10; // rdx
  __int64 v11; // [rsp+30h] [rbp-78h] BYREF
  __m256 v12; // [rsp+38h] [rbp-70h]
  __m256 v13; // [rsp+58h] [rbp-50h]
  __int64 v14; // [rsp+78h] [rbp-30h]
  _QWORD v15[5]; // [rsp+80h] [rbp-28h] BYREF

  v2 = *(__int64 **)(a1 + 0x10);
  v11 = 0;
  v12 = (__m256)0LL;
  v3 = *v2;
  v13 = (__m256)0LL;
  v4 = 2 * a2;
  v5 = (_QWORD *)(v3 + 0x18 * a2);
  v14 = 0;
  __asm { vzeroupper }
  sub_1421A70C0(
    *(_QWORD *)(v3 + 0x28),
    *(_QWORD *)(v3 + 0x30),
    (unsigned int)&v11,
    (unsigned int)v15,
    qword_149F04450[2 * a2]);
  result = (_QWORD *)v5[8];
  if ( result != (_QWORD *)v5[9] )
    v5[9] = result;
  v7 = (__int64 (__fastcall *)(__int64))qword_149F04450[v4 + 1];
  v8 = &v11;
  do
  {
    v9 = *v8;
    if ( !*v8 )
      break;
    __asm { vzeroupper }
    result = (_QWORD *)v7(*v8);
    if ( !(_BYTE)result )
      break;
    v10 = v5[9];
    if ( v10 == v5[0xA] )
    {
      sub_14059D320(v5 + 8, v10, v9);
    }
    else
    {
      *(__m256i *)v10 = *(__m256i *)v9;
      *(_OWORD *)(v10 + 0x20) = *(_OWORD *)(v9 + 0x20);
      *(double *)(v10 + 0x30) = *(double *)(v9 + 0x30);
      *(_DWORD *)(v10 + 0x38) = *(_DWORD *)(v9 + 0x38);
      v5[9] += 0x3CLL;
    }
    ++v8;
    result = v15;
  }
  while ( v8 != v15 );
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1421EEF70 (0x1421EEF70) ---

// --- Function: sub_1421EF0A0 (0x1421EF0A0) ---
_QWORD *__fastcall sub_1421EF0A0(__int64 a1, __int64 a2)
{
  return sub_1421C74A0(*(__int64 **)(a1 + 0x10), a2);
}

// --- End Function: sub_1421EF0A0 (0x1421EF0A0) ---

// --- Function: sub_1421EF250 (0x1421EF250) ---
unsigned __int64 __fastcall sub_1421EF250(__int64 a1, __int64 a2)
{
  unsigned int *v2; // r10
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // r9

  v2 = *(unsigned int **)(a1 + 0x10);
  v3 = (__int64)(*(_QWORD *)(*(_QWORD *)v2 + 0x30LL) - *(_QWORD *)(*(_QWORD *)v2 + 0x28LL)) >> 3;
  result = (v3 + v2[2] - 1LL) / v2[2];
  v5 = a2 * result;
  v6 = a2 * result + result;
  if ( v3 < v6 )
    v6 = (__int64)(*(_QWORD *)(*(_QWORD *)v2 + 0x30LL) - *(_QWORD *)(*(_QWORD *)v2 + 0x28LL)) >> 3;
  for ( ; v5 < v6; *(_QWORD *)(result + 0x28) = 0 )
  {
    result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 0x28LL) + 8 * v5++);
    *(_QWORD *)(result + 0x18) = 0;
    *(_QWORD *)(result + 0x20) = 0;
  }
  return result;
}

// --- End Function: sub_1421EF250 (0x1421EF250) ---

// --- Function: sub_1421EF2B0 (0x1421EF2B0) ---
unsigned __int64 __fastcall sub_1421EF2B0(__int64 a1, __int64 a2)
{
  unsigned int *v2; // r10
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // r9
  _DWORD *v7; // r8
  __int64 v8; // rdx

  v2 = *(unsigned int **)(a1 + 0x10);
  v3 = (__int64)(*(_QWORD *)(*((_QWORD *)v2 + 1) + 0x20LL) - *(_QWORD *)(*((_QWORD *)v2 + 1) + 0x18LL)) >> 3;
  result = (v3 + *v2 - 1LL) / *v2;
  v5 = a2 * result;
  v6 = a2 * result + result;
  if ( v3 < v6 )
    v6 = (__int64)(*(_QWORD *)(*((_QWORD *)v2 + 1) + 0x20LL) - *(_QWORD *)(*((_QWORD *)v2 + 1) + 0x18LL)) >> 3;
  for ( ; v5 < v6; v7[v8 + 0x14] = result )
  {
    v7 = *(_DWORD **)(*(_QWORD *)(*((_QWORD *)v2 + 1) + 0x18LL) + 8 * v5++);
    v8 = 7LL * (int)v2[4];
    v7[v8 + 0xF] = v7[8];
    v7[v8 + 0x10] = v7[9];
    v7[v8 + 0x11] = v7[0xA];
    v7[v8 + 0x12] = v7[0xB];
    v7[v8 + 0x13] = v7[0xC];
    result = (unsigned int)v7[0xD];
  }
  return result;
}

// --- End Function: sub_1421EF2B0 (0x1421EF2B0) ---

// --- Function: sub_1421F1F40 (0x1421F1F40) ---
void __fastcall sub_1421F1F40(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx
  _OWORD *v5; // rdi
  _OWORD *v6; // rax
  _OWORD *v7; // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = (_OWORD *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        v6 = (_OWORD *)sub_1402A65A0(0x10u);
        v7 = v6;
        if ( v6 )
          *v6 = *v5;
        else
          v7 = 0;
        a2[2] = v7;
        *a2 = sub_1421EE7B0;
        a2[1] = sub_1421F1F40;
      }
    }
  }
}

// --- End Function: sub_1421F1F40 (0x1421F1F40) ---

// --- Function: sub_1421F2DE0 (0x1421F2DE0) ---
void __fastcall sub_1421F2DE0(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx
  _QWORD *v5; // rdi
  _QWORD *v6; // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = (_QWORD *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        v6 = (_QWORD *)sub_1402A65A0(8u);
        if ( v6 )
          *v6 = *v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_1421EEF70;
        a2[1] = sub_1421F2DE0;
      }
    }
  }
}

// --- End Function: sub_1421F2DE0 (0x1421F2DE0) ---

// --- Function: sub_1421F2F00 (0x1421F2F00) ---
void __fastcall sub_1421F2F00(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx
  _OWORD *v5; // rdi
  _OWORD *v6; // rax
  _OWORD *v7; // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = (_OWORD *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        v6 = (_OWORD *)sub_1402A65A0(0x10u);
        v7 = v6;
        if ( v6 )
          *v6 = *v5;
        else
          v7 = 0;
        a2[2] = v7;
        *a2 = sub_1421EF0A0;
        a2[1] = sub_1421F2F00;
      }
    }
  }
}

// --- End Function: sub_1421F2F00 (0x1421F2F00) ---

// --- Function: sub_1421F33F0 (0x1421F33F0) ---
void __fastcall sub_1421F33F0(
        int a1,
        unsigned __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        unsigned __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  unsigned __int64 (__fastcall *v5)(__int64, __int64); // rdi
  unsigned __int64 (__fastcall *v6)(__int64, __int64); // rax
  unsigned __int64 (__fastcall *v7)(__int64, __int64); // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v6 = (unsigned __int64 (__fastcall *)(__int64, __int64))sub_1402A65A0(0x10u);
        v7 = v6;
        if ( v6 )
          *(_OWORD *)v6 = *(_OWORD *)v5;
        else
          v7 = 0;
        a2[2] = v7;
        *a2 = sub_1421EF250;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))sub_1421F33F0;
      }
    }
  }
}

// --- End Function: sub_1421F33F0 (0x1421F33F0) ---

// --- Function: sub_1421F3510 (0x1421F3510) ---
void __fastcall sub_1421F3510(
        int a1,
        unsigned __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        unsigned __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  unsigned __int64 (__fastcall *v5)(__int64, __int64); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v6 = sub_1402A65A0(0x18u);
        v7 = v6;
        if ( v6 )
        {
          *(_OWORD *)v6 = *(_OWORD *)v5;
          *(double *)(v6 + 0x10) = *((double *)v5 + 2);
        }
        else
        {
          v7 = 0;
        }
        a2[2] = (unsigned __int64 (__fastcall *)(__int64, __int64))v7;
        *a2 = sub_1421EF2B0;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))sub_1421F3510;
      }
    }
  }
}

// --- End Function: sub_1421F3510 (0x1421F3510) ---

// --- Function: sub_14225A120 (0x14225A120) ---
const char *__fastcall sub_14225A120(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // r8

  v2 = *(_QWORD *)(a1 + 0xF0);
  if ( a2 < (unsigned __int64)((*(_QWORD *)(a1 + 0xF8) - v2) / 0x38) )
    return *(const char **)(0x38LL * a2 + v2);
  else
    return "Unknown method";
}

// --- End Function: sub_14225A120 (0x14225A120) ---

// --- Function: sub_142283380 (0x142283380) ---
__int64 __fastcall sub_142283380(__int64 a1, __int64 a2)
{
  __int64 v4; // r8

  *(_QWORD *)a1 = 0;
  sub_14035E090((_QWORD *)(a1 + 8));
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)a1 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                    qword_149C8DFC8,
                    *(unsigned __int16 *)(a2 + 0x10));
  copyStringStructure((void **)(a1 + 8), (const void **)(a2 + 8), v4);
  *(_DWORD *)(a1 + 0x10) = *(_DWORD *)(a2 + 0x20) - *(_DWORD *)(a2 + 0x58);
  *(_DWORD *)(a1 + 0x14) = *(_DWORD *)(a2 + 0x24) - *(_DWORD *)(a2 + 0x5C);
  *(_DWORD *)(a1 + 0x18) = *(_DWORD *)(a2 + 0x28) - *(_DWORD *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x1C) = *(_DWORD *)(a2 + 0x2C) - *(_DWORD *)(a2 + 0x64);
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x30) - *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x24) = *(_DWORD *)(a2 + 0x34) - *(_DWORD *)(a2 + 0x6C);
  return a1;
}

// --- End Function: sub_142283380 (0x142283380) ---

// --- Function: sub_1422B75B0 (0x1422B75B0) ---
__int64 __fastcall sub_1422B75B0(__int64 a1, unsigned __int64 *a2)
{
  _QWORD *v4; // rax
  int n0x6500; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v7; // [rsp+34h] [rbp-CCh]
  int v8; // [rsp+3Ch] [rbp-C4h]
  unsigned __int64 v9; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v10; // [rsp+48h] [rbp-B8h]
  __int64 v11; // [rsp+50h] [rbp-B0h]
  __int64 v12; // [rsp+58h] [rbp-A8h]
  __int64 v13; // [rsp+80h] [rbp-80h] BYREF
  void (__fastcall *n2_2)(__int64, __int64 *); // [rsp+88h] [rbp-78h]
  _QWORD *(__fastcall *p_sub_1421EEF70)(__int64, __int64); // [rsp+98h] [rbp-68h] BYREF
  void (__fastcall *n2)(__int64, _QWORD *(__fastcall **)(__int64, __int64)); // [rsp+A0h] [rbp-60h]
  _QWORD *v17; // [rsp+A8h] [rbp-58h]
  __int64 v18; // [rsp+B0h] [rbp-50h] BYREF
  void (__fastcall *n2_1)(__int64, __int64 *); // [rsp+B8h] [rbp-48h]
  int n6; // [rsp+C8h] [rbp-38h]
  unsigned __int64 v21; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v22; // [rsp+D8h] [rbp-28h]
  unsigned __int64 v23; // [rsp+E0h] [rbp-20h]

  n0x6500 = 0x6500;
  v7 = 0;
  v8 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v9 = __rdtsc();
  qword_149C89AA0(
    &n0x6500,
    &word_149F08660,
    "CSerializedProfileMetrics::RankComponentMetrics",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
    0x275);
  HIWORD(n0x6500) = word_149F08660;
  sub_1402B3B60((__int64)&v13, 0x65, 0, "CSerializedProfileMetrics::RankComponentMetrics");
  if ( &v21 != a2 )
  {
    if ( v21 )
      sub_1403A6820((__int64)&v21, v21, (v23 - v21) & 0xFFFFFFFFFFFFFFF8uLL);
    v21 = *a2;
    v22 = a2[1];
    v23 = a2[2];
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  n6 = 6;
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, &p_sub_1421EEF70);
    n2 = 0;
  }
  p_sub_1421EEF70 = 0;
  v4 = (_QWORD *)sub_1402A65A0(8u);
  if ( v4 )
  {
    *v4 = a1;
    v17 = v4;
  }
  else
  {
    v17 = 0;
  }
  p_sub_1421EEF70 = sub_1421EEF70;
  n2 = (void (__fastcall *)(__int64, _QWORD *(__fastcall **)(__int64, __int64)))sub_1421F2DE0;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, &v13);
  if ( v21 )
  {
    sub_1403A6820((__int64)&v21, v21, (v23 - v21) & 0xFFFFFFFFFFFFFFF8uLL);
    v21 = 0;
    v22 = 0;
    v23 = 0;
  }
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, &v18);
    n2_1 = 0;
  }
  v18 = 0;
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, &p_sub_1421EEF70);
    n2 = 0;
  }
  p_sub_1421EEF70 = 0;
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, &v13);
    n2_2 = 0;
  }
  v13 = 0;
  v10 = __rdtsc();
  return qword_149C89AA8(&n0x6500);
}

// --- End Function: sub_1422B75B0 (0x1422B75B0) ---

// --- Function: sub_1422BC170 (0x1422BC170) ---
__int64 __fastcall sub_1422BC170(unsigned __int64 *a1, __int64 a2, unsigned __int16 *a3)
{
  unsigned __int64 *v3; // rsi
  __int128 *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rcx
  int v9; // eax
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rcx
  int v13; // r12d
  _BYTE *v14; // r14
  unsigned __int64 v15; // rax
  size_t Size; // r15
  char *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rax
  signed __int64 v21; // rcx
  int *ThreadLogContextSlot; // rax
  unsigned __int64 v23; // r14
  unsigned int v24; // r15d
  __int64 v25; // rax
  unsigned __int64 v26; // rcx
  __int64 v27; // rax
  bool v28; // bl
  __int64 v29; // rcx
  char v30; // al
  int v31; // edx
  int v32; // edx
  int v33; // r15d
  __int64 v34; // rcx
  char v35; // al
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // rcx
  __int64 v40; // rax
  int *ThreadLogContextSlot_1; // rax
  _QWORD *v42; // rcx
  __int128 v43; // xmm0
  __int64 v44; // rax
  char n0x65; // r12
  __int16 *v46; // rbx
  __int16 v47; // bx
  __int64 v48; // rcx
  int v49; // eax
  __int64 v50; // rcx
  const char *v51; // r14
  const char *v52; // r12
  const char *v53; // rbx
  __int16 v55; // [rsp+90h] [rbp-80h] BYREF
  int n0xD6; // [rsp+98h] [rbp-78h] BYREF
  int n0x67; // [rsp+9Ch] [rbp-74h]
  __int128 *v58; // [rsp+A0h] [rbp-70h] BYREF
  __int64 v59; // [rsp+A8h] [rbp-68h] BYREF
  size_t v60[2]; // [rsp+B0h] [rbp-60h] BYREF
  __int64 v61; // [rsp+C0h] [rbp-50h] BYREF
  const char *v62; // [rsp+C8h] [rbp-48h]
  __int64 v63; // [rsp+D0h] [rbp-40h]
  __int64 v64; // [rsp+D8h] [rbp-38h] BYREF
  __int64 v65; // [rsp+E0h] [rbp-30h]
  __int64 v66; // [rsp+E8h] [rbp-28h] BYREF
  __int64 v67; // [rsp+F0h] [rbp-20h]
  __int64 v68; // [rsp+F8h] [rbp-18h]
  __int128 v69; // [rsp+100h] [rbp-10h] BYREF
  __int128 v70; // [rsp+110h] [rbp+0h] BYREF
  __int128 v71; // [rsp+120h] [rbp+10h] BYREF
  __int64 v72; // [rsp+130h] [rbp+20h]
  _BYTE v73[2]; // [rsp+140h] [rbp+30h] BYREF
  __int16 v74; // [rsp+142h] [rbp+32h]
  int v75; // [rsp+144h] [rbp+34h]
  __int64 v76; // [rsp+148h] [rbp+38h]
  unsigned __int64 v77; // [rsp+150h] [rbp+40h]
  unsigned __int64 v78; // [rsp+158h] [rbp+48h]
  __int64 v79; // [rsp+160h] [rbp+50h]
  __int64 v80; // [rsp+168h] [rbp+58h]
  _DWORD v81[2]; // [rsp+190h] [rbp+80h] BYREF
  __int64 v82; // [rsp+198h] [rbp+88h]
  unsigned __int64 v83; // [rsp+1A0h] [rbp+90h]
  unsigned __int64 v84; // [rsp+1A8h] [rbp+98h]
  __int64 v85; // [rsp+1B0h] [rbp+A0h]
  __int64 v86; // [rsp+1B8h] [rbp+A8h]
  _QWORD v87[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  __int64 v88; // [rsp+1F0h] [rbp+E0h]
  _QWORD v89[2]; // [rsp+1F8h] [rbp+E8h] BYREF
  __int64 v90; // [rsp+208h] [rbp+F8h]
  _QWORD v91[2]; // [rsp+210h] [rbp+100h] BYREF
  _QWORD v92[2]; // [rsp+220h] [rbp+110h] BYREF
  _QWORD v93[2]; // [rsp+230h] [rbp+120h] BYREF
  _QWORD v94[2]; // [rsp+240h] [rbp+130h] BYREF
  _QWORD v95[2]; // [rsp+250h] [rbp+140h] BYREF
  size_t v96; // [rsp+260h] [rbp+150h]
  char v97; // [rsp+268h] [rbp+158h]
  _QWORD v98[2]; // [rsp+270h] [rbp+160h] BYREF
  char v99; // [rsp+280h] [rbp+170h]
  int n2; // [rsp+288h] [rbp+178h] BYREF
  __int128 v101; // [rsp+290h] [rbp+180h]
  char v102[8]; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 v103; // [rsp+2A8h] [rbp+198h]
  char *v104; // [rsp+2B0h] [rbp+1A0h]
  char v105; // [rsp+2B8h] [rbp+1A8h] BYREF
  char v106[8]; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 v107; // [rsp+2E8h] [rbp+1D8h]
  const char *v108; // [rsp+2F0h] [rbp+1E0h]
  char v109; // [rsp+2F8h] [rbp+1E8h] BYREF
  char v110[8]; // [rsp+320h] [rbp+210h] BYREF
  __int64 v111; // [rsp+328h] [rbp+218h]
  char *v112; // [rsp+330h] [rbp+220h]
  char v113; // [rsp+338h] [rbp+228h] BYREF

  v3 = a1 + 1;
  v58 = (__int128 *)a2;
  v6 = (__int128 *)a2;
  v7 = 0;
  if ( is_entity_descriptor_valid_or_accessible(a1 + 1) )
    v8 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v8 = 0;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 0x708LL))(v8, 0xFFFFFFFFFFFFLL);
  v81[0] = 0x6500;
  v82 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v81[1] = v9;
  v83 = __rdtsc();
  qword_149C89AA0(
    v81,
    &word_149F0860C,
    "CSerializedComponent::RecvRemoteMethodCall",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedComponent.cpp",
    0x327);
  v10 = a3[8];
  v11 = a1[0x1E];
  v12 = a1[0x1F];
  HIWORD(v81[0]) = word_149F0860C;
  v59 = v10;
  if ( v10 >= (__int64)(v12 - v11) / 0x38 )
  {
    n0xD6 = 0xD6;
    v91[0] = &n0xD6;
    n0x67 = 0x67;
    v91[1] = &v58;
    v13 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v91,
            (__int64)"Recv Invalid Remote Method Id",
            "Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$] fromNodeId=[$$]");
    if ( (v13 & 0xFFFFF) == 0 )
      goto LABEL_66;
    v70 = *v6;
    v14 = *(_BYTE **)(sub_1402C6D50((__int64)v110, (__int64)&v70) + 0x10);
    v61 = 0;
    sub_1402A6590(0);
    v15 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v14[++v15] != 0 )
      ;
    Size = v15 + 1;
    v18 = (char *)sub_1402A65A0(v15 + 1);
    v63 = (__int64)v18;
    v62 = v18;
    if ( !Size )
      goto LABEL_14;
    if ( v18 )
    {
      if ( v14 )
      {
        memcpy(v18, v14, Size);
LABEL_14:
        if ( v112 != &v113 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v111;
          sub_147715880(v112);
        }
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v19 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v19 = 0;
        v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x70LL))(v19);
        *(_QWORD *)&v71 = 0;
        *((_QWORD *)&v71 + 1) = v20;
        v72 = 0;
        sub_1403B43F0(v3, &v58);
        v67 = (__int64)v58;
        v21 = a1[0x1F] - a1[0x1E];
        v66 = 0;
        LOBYTE(v68) = 0;
        v60[0] = 0;
        v65 = v59;
        v60[1] = v21 / 0x38;
        v64 = 0;
        ThreadLogContextSlot = getThreadLogContextSlot();
        n0xD6 = 0xD6;
        v92[0] = &n0xD6;
        n0x67 = 0x67;
        v92[1] = &v58;
        v69 = 0;
        sub_14219AD20(
          2,
          (__int64)v92,
          "Recv Invalid Remote Method Id",
          (__int64)"Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$]"
                   " fromNodeId=[$$]",
          1,
          v13,
          &v69,
          0,
          (__int64)ThreadLogContextSlot,
          (__int64)&v64,
          (__int64)v60,
          (__int64)&v66,
          (__int64)&v71,
          (__int64)&v61);
        sub_1402A6590(v72);
        sub_1402A6590(v63);
        goto LABEL_66;
      }
      memset(v18, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
    goto LABEL_14;
  }
  v23 = v11 + 0x38 * v10;
  v24 = 8 * **(_DWORD **)a3;
  v25 = *(_QWORD *)(v23 + 0x20);
  if ( v25 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v25 + 0x20));
    _InterlockedAdd((volatile signed __int32 *)(v25 + 0x24), v24);
  }
  v26 = a1[0x1C];
  if ( v26 )
    (*(void (__fastcall **)(unsigned __int64, _QWORD, _QWORD))(*(_QWORD *)v26 + 0x40LL))(v26, (unsigned int)v10, v24);
  if ( BYTE1(qword_149C8E516) )
  {
    v27 = *(_QWORD *)(v23 + 0x28);
    v28 = v27 && *(_BYTE *)(v27 + 0x8D);
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v29 = *v3 & 0xFFFFFFFFFFFFLL;
    else
      v29 = 0;
    v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x720LL))(v29);
    v31 = *(_DWORD *)(v23 + 0x10);
    if ( v31 )
    {
      v32 = v31 - 1;
      if ( v32 )
      {
        if ( v32 != 1 )
          goto LABEL_39;
      }
      else
      {
        v30 = v28;
      }
    }
    else
    {
      v30 = v30 == 0;
    }
    if ( !v30 )
    {
LABEL_39:
      n0xD6 = 0xD6;
      v93[0] = &n0xD6;
      n0x67 = 0xD6;
      v93[1] = &v58;
      v33 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)v93,
              (__int64)"Remote Method Criteria",
              "Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], entit"
              "yId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]");
      if ( (v33 & 0xFFFFF) != 0 )
      {
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v34 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v34 = 0;
        v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x720LL))(v34);
        v65 = 0;
        LOBYTE(v64) = v35;
        DWORD2(v70) = *(_DWORD *)(v23 + 0x10);
        LOBYTE(v69) = v28;
        *((_QWORD *)&v69 + 1) = 0;
        *(_QWORD *)&v70 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v36 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v36 = 0;
        v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x20LL))(v36);
        v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x18LL))(v37);
        v66 = 0;
        v67 = v38;
        v68 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v39 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v39 = 0;
        v40 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x70LL))(v39);
        v89[0] = 0;
        v89[1] = v40;
        v90 = 0;
        sub_1403B43F0(v3, v60);
        v98[1] = v60[0];
        v98[0] = 0;
        v99 = 0;
        sub_1402C6D50((__int64)v102, (__int64)v58);
        v87[1] = v104;
        v62 = *(const char **)v23;
        v87[0] = 0;
        v88 = 0;
        v61 = 0;
        v63 = 0;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v59 = 0xD6000000D6LL;
        v94[0] = &v59;
        v94[1] = v60;
        v71 = 0;
        sub_14219DF00(
          3,
          (__int64)v94,
          "Remote Method Criteria",
          (__int64)"Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], "
                   "entityId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]",
          1,
          v33,
          &v71,
          0,
          (__int64)ThreadLogContextSlot_1,
          &v61,
          v87,
          (__int64)v98,
          (__int64)v89,
          (__int64)&v66,
          (__int64)&v70,
          (__int64)&v69,
          (__int64)&v64);
        sub_1402A6590(v63);
        sub_1402A6590(v88);
        if ( v104 != &v105 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v103;
          sub_147715880(v104);
        }
        sub_1402A6590(v90);
        sub_1402A6590(v68);
      }
      goto LABEL_66;
    }
    v6 = v58;
  }
  v42 = (_QWORD *)(*(_QWORD *)a3 + 8LL);
  if ( *(_DWORD *)(*(_QWORD *)a3 + 4LL) > 0x10u )
    v42 = (_QWORD *)*v42;
  v43 = *v6;
  v95[1] = v24;
  v95[0] = v42;
  v96 = 0;
  v97 = 1;
  v44 = *(_QWORD *)(v23 + 0x20);
  n2 = 2;
  v101 = v43;
  if ( v44 )
  {
    n0x65 = *(_BYTE *)(v44 + 0x12);
    v46 = (__int16 *)(v44 + 0x70);
  }
  else
  {
    n0x65 = 0x65;
    v46 = &word_1486949F4;
  }
  v47 = *v46;
  if ( is_entity_descriptor_valid_or_accessible(v3) )
    v48 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v48 = 0;
  v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x708LL))(v48);
  v55 = v47;
  v74 = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v75 = v49;
  v77 = __rdtsc();
  v73[1] = n0x65;
  v73[0] = 0;
  qword_149C89AA0(v73, &v55, &p_Src, &p_Src, 0);
  v50 = *(_QWORD *)(v23 + 0x18);
  v74 = v55;
  (*(void (__fastcall **)(__int64, int *, _QWORD *))(*(_QWORD *)v50 + 0x10LL))(v50, &n2, v95);
  v78 = __rdtsc();
  qword_149C89AA8(v73);
  v60[0] = v96;
  if ( ((v96 + 7) & 0xFFFFFFFFFFFFFFF8uLL) != v24 )
  {
    v51 = *(const char **)v23;
    sub_1402C6D50((__int64)v106, (__int64)v58);
    v52 = v108;
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v7 = *v3 & 0xFFFFFFFFFFFFLL;
    v53 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x70LL))(v7);
    sub_1403B43F0(v3, &v58);
    LogFatalError(
      "Remote Method deserializing stream size mismatch entityId=%llu, entityName=\"%s\", fromNodeId=%s, methodName=\"%s\""
      ", streamSize=%zu, bufferSize=%u",
      v58,
      v53,
      v52,
      v51,
      v60[0],
      v24);
    if ( v108 != &v109 )
    {
      qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v107;
      sub_147715880(v108);
    }
  }
LABEL_66:
  v84 = __rdtsc();
  return qword_149C89AA8(v81);
}

// --- End Function: sub_1422BC170 (0x1422BC170) ---

// --- Function: sub_1422BC170 (0x1422BC915) ---
__int64 __fastcall sub_1422BC170(unsigned __int64 *a1, __int64 a2, unsigned __int16 *a3)
{
  unsigned __int64 *v3; // rsi
  __int128 *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rcx
  int v9; // eax
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rcx
  int v13; // r12d
  _BYTE *v14; // r14
  unsigned __int64 v15; // rax
  size_t Size; // r15
  char *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rax
  signed __int64 v21; // rcx
  int *ThreadLogContextSlot; // rax
  unsigned __int64 v23; // r14
  unsigned int v24; // r15d
  __int64 v25; // rax
  unsigned __int64 v26; // rcx
  __int64 v27; // rax
  bool v28; // bl
  __int64 v29; // rcx
  char v30; // al
  int v31; // edx
  int v32; // edx
  int v33; // r15d
  __int64 v34; // rcx
  char v35; // al
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // rcx
  __int64 v40; // rax
  int *ThreadLogContextSlot_1; // rax
  _QWORD *v42; // rcx
  __int128 v43; // xmm0
  __int64 v44; // rax
  char n0x65; // r12
  __int16 *v46; // rbx
  __int16 v47; // bx
  __int64 v48; // rcx
  int v49; // eax
  __int64 v50; // rcx
  const char *v51; // r14
  const char *v52; // r12
  const char *v53; // rbx
  __int16 v55; // [rsp+90h] [rbp-80h] BYREF
  int n0xD6; // [rsp+98h] [rbp-78h] BYREF
  int n0x67; // [rsp+9Ch] [rbp-74h]
  __int128 *v58; // [rsp+A0h] [rbp-70h] BYREF
  __int64 v59; // [rsp+A8h] [rbp-68h] BYREF
  size_t v60[2]; // [rsp+B0h] [rbp-60h] BYREF
  __int64 v61; // [rsp+C0h] [rbp-50h] BYREF
  const char *v62; // [rsp+C8h] [rbp-48h]
  __int64 v63; // [rsp+D0h] [rbp-40h]
  __int64 v64; // [rsp+D8h] [rbp-38h] BYREF
  __int64 v65; // [rsp+E0h] [rbp-30h]
  __int64 v66; // [rsp+E8h] [rbp-28h] BYREF
  __int64 v67; // [rsp+F0h] [rbp-20h]
  __int64 v68; // [rsp+F8h] [rbp-18h]
  __int128 v69; // [rsp+100h] [rbp-10h] BYREF
  __int128 v70; // [rsp+110h] [rbp+0h] BYREF
  __int128 v71; // [rsp+120h] [rbp+10h] BYREF
  __int64 v72; // [rsp+130h] [rbp+20h]
  _BYTE v73[2]; // [rsp+140h] [rbp+30h] BYREF
  __int16 v74; // [rsp+142h] [rbp+32h]
  int v75; // [rsp+144h] [rbp+34h]
  __int64 v76; // [rsp+148h] [rbp+38h]
  unsigned __int64 v77; // [rsp+150h] [rbp+40h]
  unsigned __int64 v78; // [rsp+158h] [rbp+48h]
  __int64 v79; // [rsp+160h] [rbp+50h]
  __int64 v80; // [rsp+168h] [rbp+58h]
  _DWORD v81[2]; // [rsp+190h] [rbp+80h] BYREF
  __int64 v82; // [rsp+198h] [rbp+88h]
  unsigned __int64 v83; // [rsp+1A0h] [rbp+90h]
  unsigned __int64 v84; // [rsp+1A8h] [rbp+98h]
  __int64 v85; // [rsp+1B0h] [rbp+A0h]
  __int64 v86; // [rsp+1B8h] [rbp+A8h]
  _QWORD v87[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  __int64 v88; // [rsp+1F0h] [rbp+E0h]
  _QWORD v89[2]; // [rsp+1F8h] [rbp+E8h] BYREF
  __int64 v90; // [rsp+208h] [rbp+F8h]
  _QWORD v91[2]; // [rsp+210h] [rbp+100h] BYREF
  _QWORD v92[2]; // [rsp+220h] [rbp+110h] BYREF
  _QWORD v93[2]; // [rsp+230h] [rbp+120h] BYREF
  _QWORD v94[2]; // [rsp+240h] [rbp+130h] BYREF
  _QWORD v95[2]; // [rsp+250h] [rbp+140h] BYREF
  size_t v96; // [rsp+260h] [rbp+150h]
  char v97; // [rsp+268h] [rbp+158h]
  _QWORD v98[2]; // [rsp+270h] [rbp+160h] BYREF
  char v99; // [rsp+280h] [rbp+170h]
  int n2; // [rsp+288h] [rbp+178h] BYREF
  __int128 v101; // [rsp+290h] [rbp+180h]
  char v102[8]; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 v103; // [rsp+2A8h] [rbp+198h]
  char *v104; // [rsp+2B0h] [rbp+1A0h]
  char v105; // [rsp+2B8h] [rbp+1A8h] BYREF
  char v106[8]; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 v107; // [rsp+2E8h] [rbp+1D8h]
  const char *v108; // [rsp+2F0h] [rbp+1E0h]
  char v109; // [rsp+2F8h] [rbp+1E8h] BYREF
  char v110[8]; // [rsp+320h] [rbp+210h] BYREF
  __int64 v111; // [rsp+328h] [rbp+218h]
  char *v112; // [rsp+330h] [rbp+220h]
  char v113; // [rsp+338h] [rbp+228h] BYREF

  v3 = a1 + 1;
  v58 = (__int128 *)a2;
  v6 = (__int128 *)a2;
  v7 = 0;
  if ( is_entity_descriptor_valid_or_accessible(a1 + 1) )
    v8 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v8 = 0;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 0x708LL))(v8, 0xFFFFFFFFFFFFLL);
  v81[0] = 0x6500;
  v82 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v81[1] = v9;
  v83 = __rdtsc();
  qword_149C89AA0(
    v81,
    &word_149F0860C,
    "CSerializedComponent::RecvRemoteMethodCall",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedComponent.cpp",
    0x327);
  v10 = a3[8];
  v11 = a1[0x1E];
  v12 = a1[0x1F];
  HIWORD(v81[0]) = word_149F0860C;
  v59 = v10;
  if ( v10 >= (__int64)(v12 - v11) / 0x38 )
  {
    n0xD6 = 0xD6;
    v91[0] = &n0xD6;
    n0x67 = 0x67;
    v91[1] = &v58;
    v13 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v91,
            (__int64)"Recv Invalid Remote Method Id",
            "Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$] fromNodeId=[$$]");
    if ( (v13 & 0xFFFFF) == 0 )
      goto LABEL_66;
    v70 = *v6;
    v14 = *(_BYTE **)(sub_1402C6D50((__int64)v110, (__int64)&v70) + 0x10);
    v61 = 0;
    sub_1402A6590(0);
    v15 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v14[++v15] != 0 )
      ;
    Size = v15 + 1;
    v18 = (char *)sub_1402A65A0(v15 + 1);
    v63 = (__int64)v18;
    v62 = v18;
    if ( !Size )
      goto LABEL_14;
    if ( v18 )
    {
      if ( v14 )
      {
        memcpy(v18, v14, Size);
LABEL_14:
        if ( v112 != &v113 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v111;
          sub_147715880(v112);
        }
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v19 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v19 = 0;
        v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x70LL))(v19);
        *(_QWORD *)&v71 = 0;
        *((_QWORD *)&v71 + 1) = v20;
        v72 = 0;
        sub_1403B43F0(v3, &v58);
        v67 = (__int64)v58;
        v21 = a1[0x1F] - a1[0x1E];
        v66 = 0;
        LOBYTE(v68) = 0;
        v60[0] = 0;
        v65 = v59;
        v60[1] = v21 / 0x38;
        v64 = 0;
        ThreadLogContextSlot = getThreadLogContextSlot();
        n0xD6 = 0xD6;
        v92[0] = &n0xD6;
        n0x67 = 0x67;
        v92[1] = &v58;
        v69 = 0;
        sub_14219AD20(
          2,
          (__int64)v92,
          "Recv Invalid Remote Method Id",
          (__int64)"Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$]"
                   " fromNodeId=[$$]",
          1,
          v13,
          &v69,
          0,
          (__int64)ThreadLogContextSlot,
          (__int64)&v64,
          (__int64)v60,
          (__int64)&v66,
          (__int64)&v71,
          (__int64)&v61);
        sub_1402A6590(v72);
        sub_1402A6590(v63);
        goto LABEL_66;
      }
      memset(v18, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
    goto LABEL_14;
  }
  v23 = v11 + 0x38 * v10;
  v24 = 8 * **(_DWORD **)a3;
  v25 = *(_QWORD *)(v23 + 0x20);
  if ( v25 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v25 + 0x20));
    _InterlockedAdd((volatile signed __int32 *)(v25 + 0x24), v24);
  }
  v26 = a1[0x1C];
  if ( v26 )
    (*(void (__fastcall **)(unsigned __int64, _QWORD, _QWORD))(*(_QWORD *)v26 + 0x40LL))(v26, (unsigned int)v10, v24);
  if ( BYTE1(qword_149C8E516) )
  {
    v27 = *(_QWORD *)(v23 + 0x28);
    v28 = v27 && *(_BYTE *)(v27 + 0x8D);
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v29 = *v3 & 0xFFFFFFFFFFFFLL;
    else
      v29 = 0;
    v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x720LL))(v29);
    v31 = *(_DWORD *)(v23 + 0x10);
    if ( v31 )
    {
      v32 = v31 - 1;
      if ( v32 )
      {
        if ( v32 != 1 )
          goto LABEL_39;
      }
      else
      {
        v30 = v28;
      }
    }
    else
    {
      v30 = v30 == 0;
    }
    if ( !v30 )
    {
LABEL_39:
      n0xD6 = 0xD6;
      v93[0] = &n0xD6;
      n0x67 = 0xD6;
      v93[1] = &v58;
      v33 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)v93,
              (__int64)"Remote Method Criteria",
              "Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], entit"
              "yId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]");
      if ( (v33 & 0xFFFFF) != 0 )
      {
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v34 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v34 = 0;
        v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x720LL))(v34);
        v65 = 0;
        LOBYTE(v64) = v35;
        DWORD2(v70) = *(_DWORD *)(v23 + 0x10);
        LOBYTE(v69) = v28;
        *((_QWORD *)&v69 + 1) = 0;
        *(_QWORD *)&v70 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v36 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v36 = 0;
        v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x20LL))(v36);
        v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x18LL))(v37);
        v66 = 0;
        v67 = v38;
        v68 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v39 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v39 = 0;
        v40 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x70LL))(v39);
        v89[0] = 0;
        v89[1] = v40;
        v90 = 0;
        sub_1403B43F0(v3, v60);
        v98[1] = v60[0];
        v98[0] = 0;
        v99 = 0;
        sub_1402C6D50((__int64)v102, (__int64)v58);
        v87[1] = v104;
        v62 = *(const char **)v23;
        v87[0] = 0;
        v88 = 0;
        v61 = 0;
        v63 = 0;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v59 = 0xD6000000D6LL;
        v94[0] = &v59;
        v94[1] = v60;
        v71 = 0;
        sub_14219DF00(
          3,
          (__int64)v94,
          "Remote Method Criteria",
          (__int64)"Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], "
                   "entityId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]",
          1,
          v33,
          &v71,
          0,
          (__int64)ThreadLogContextSlot_1,
          &v61,
          v87,
          (__int64)v98,
          (__int64)v89,
          (__int64)&v66,
          (__int64)&v70,
          (__int64)&v69,
          (__int64)&v64);
        sub_1402A6590(v63);
        sub_1402A6590(v88);
        if ( v104 != &v105 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v103;
          sub_147715880(v104);
        }
        sub_1402A6590(v90);
        sub_1402A6590(v68);
      }
      goto LABEL_66;
    }
    v6 = v58;
  }
  v42 = (_QWORD *)(*(_QWORD *)a3 + 8LL);
  if ( *(_DWORD *)(*(_QWORD *)a3 + 4LL) > 0x10u )
    v42 = (_QWORD *)*v42;
  v43 = *v6;
  v95[1] = v24;
  v95[0] = v42;
  v96 = 0;
  v97 = 1;
  v44 = *(_QWORD *)(v23 + 0x20);
  n2 = 2;
  v101 = v43;
  if ( v44 )
  {
    n0x65 = *(_BYTE *)(v44 + 0x12);
    v46 = (__int16 *)(v44 + 0x70);
  }
  else
  {
    n0x65 = 0x65;
    v46 = &word_1486949F4;
  }
  v47 = *v46;
  if ( is_entity_descriptor_valid_or_accessible(v3) )
    v48 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v48 = 0;
  v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x708LL))(v48);
  v55 = v47;
  v74 = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v75 = v49;
  v77 = __rdtsc();
  v73[1] = n0x65;
  v73[0] = 0;
  qword_149C89AA0(v73, &v55, &p_Src, &p_Src, 0);
  v50 = *(_QWORD *)(v23 + 0x18);
  v74 = v55;
  (*(void (__fastcall **)(__int64, int *, _QWORD *))(*(_QWORD *)v50 + 0x10LL))(v50, &n2, v95);
  v78 = __rdtsc();
  qword_149C89AA8(v73);
  v60[0] = v96;
  if ( ((v96 + 7) & 0xFFFFFFFFFFFFFFF8uLL) != v24 )
  {
    v51 = *(const char **)v23;
    sub_1402C6D50((__int64)v106, (__int64)v58);
    v52 = v108;
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v7 = *v3 & 0xFFFFFFFFFFFFLL;
    v53 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x70LL))(v7);
    sub_1403B43F0(v3, &v58);
    LogFatalError(
      "Remote Method deserializing stream size mismatch entityId=%llu, entityName=\"%s\", fromNodeId=%s, methodName=\"%s\""
      ", streamSize=%zu, bufferSize=%u",
      v58,
      v53,
      v52,
      v51,
      v60[0],
      v24);
    if ( v108 != &v109 )
    {
      qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v107;
      sub_147715880(v108);
    }
  }
LABEL_66:
  v84 = __rdtsc();
  return qword_149C89AA8(v81);
}

// --- End Function: sub_1422BC170 (0x1422BC915) ---

// --- Function: sub_1422E0F10 (0x1422E0F10) ---
__int64 __fastcall sub_1422E0F10(__int64 a1, _QWORD *a2, int a3, void **a4)
{
  unsigned int v6; // r12d
  char *v7; // r15
  unsigned __int64 v8; // rsi
  char *v9; // rdi
  unsigned __int64 v10; // r14
  char *v11; // rdi
  char *v12; // rbx
  __int64 v13; // rax
  double v14; // xmm1_8
  _QWORD v17[2]; // [rsp+44h] [rbp-C4h] BYREF
  int v18; // [rsp+54h] [rbp-B4h]
  unsigned __int64 v19; // [rsp+58h] [rbp-B0h]
  unsigned __int64 v20; // [rsp+60h] [rbp-A8h]
  __int64 v21; // [rsp+68h] [rbp-A0h]
  __int64 v22; // [rsp+70h] [rbp-98h]
  __int128 v23; // [rsp+98h] [rbp-70h]
  double v24; // [rsp+A8h] [rbp-60h]
  _QWORD v25[3]; // [rsp+B8h] [rbp-50h] BYREF
  unsigned __int64 (__fastcall *p_sub_1421EF2B0)(__int64, __int64); // [rsp+D0h] [rbp-38h] BYREF
  void (__fastcall *n2)(int, unsigned __int64 (__fastcall **)(__int64, __int64), unsigned __int64 (__fastcall **)(__int64, __int64)); // [rsp+D8h] [rbp-30h]
  __int64 v28; // [rsp+E0h] [rbp-28h]
  unsigned int v29; // [rsp+100h] [rbp-8h]
  void *v30; // [rsp+108h] [rbp+0h] BYREF
  void *v31; // [rsp+110h] [rbp+8h]
  __int64 v32; // [rsp+118h] [rbp+10h]

  HIDWORD(v17[0]) = 0x6500;
  v17[1] = 0;
  v18 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v19 = __rdtsc();
  qword_149C89AA0(
    (char *)v17 + 4,
    &word_149F08654,
    "CSerializedProfileMetrics::ResetMetrics",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
    0x227);
  HIWORD(v17[0]) = word_149F08654;
  v6 = 8 * (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x18LL))(qword_149C8E038);
  if ( (unsigned int)((__int64)(a2[4] - a2[3]) >> 3) < v6 )
    v6 = (__int64)(a2[4] - a2[3]) >> 3;
  sub_1402B3B60((__int64)v25, 0x65, 0, "CSerializedProfileMetrics::ResetMetrics - %s", *a2);
  if ( &v30 != a4 )
  {
    v7 = (char *)*a4;
    v8 = ((_BYTE *)a4[1] - (_BYTE *)*a4) >> 3;
    if ( v8 <= (v32 - (__int64)v30) >> 3 )
    {
      v10 = ((_BYTE *)v31 - (_BYTE *)v30) >> 3;
      if ( v8 <= v10 )
      {
        v12 = (char *)v30 + 8 * v8;
        memmove(v30, v7, 8 * v8);
        v31 = v12;
      }
      else
      {
        memmove(v30, v7, 8 * v10);
        v11 = (char *)v31;
        memmove(v31, &v7[8 * v10], 8 * (v8 - v10));
        v31 = &v11[8 * (v8 - v10)];
      }
    }
    else
    {
      sub_1407EDF30((unsigned __int64 *)&v30, v8);
      v9 = (char *)v30;
      memmove(v30, v7, 8 * v8);
      v31 = &v9[8 * v8];
    }
  }
  LODWORD(v24) = a3;
  v29 = v6;
  LODWORD(v23) = v6;
  *((_QWORD *)&v23 + 1) = a2;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, unsigned __int64 (__fastcall **)(__int64, __int64)))n2)(2, &p_sub_1421EF2B0);
    n2 = 0;
  }
  p_sub_1421EF2B0 = 0;
  v13 = sub_1402A65A0(0x18u);
  if ( v13 )
  {
    v14 = v24;
    *(_OWORD *)v13 = v23;
    *(double *)(v13 + 0x10) = v14;
    v28 = v13;
  }
  else
  {
    v28 = 0;
  }
  p_sub_1421EF2B0 = sub_1421EF2B0;
  n2 = sub_1421F3510;
  (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, v25);
  sub_1402B6C70(v25);
  v20 = __rdtsc();
  return qword_149C89AA8((char *)v17 + 4);
}

// --- End Function: sub_1422E0F10 (0x1422E0F10) ---

// --- Function: sub_1422E4CA0 (0x1422E4CA0) ---
void __fastcall sub_1422E4CA0(__int64 a1, _BYTE *a2, int n3, int n6, unsigned int a5)
{
  __int64 v7; // r13
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // r14
  __int64 v11; // rbx
  __int64 v12; // r15
  int v13; // edi
  int v14; // esi
  __int64 v15; // rax
  __int64 v16; // rbx
  void *v17; // [rsp+20h] [rbp-48h] BYREF
  __int64 v18; // [rsp+28h] [rbp-40h]
  __int64 v19; // [rsp+30h] [rbp-38h]
  int v20; // [rsp+78h] [rbp+10h]

  if ( a2 && *a2 && n3 < 3 && n6 < 6 )
  {
    v7 = a1 + 0x18 * (n6 + 0xELL * n3);
    v8 = *(_QWORD *)(v7 + 0x108) - *(_QWORD *)(v7 + 0x100);
    v9 = (unsigned __int128)(v8 * (__int128)(__int64)0x8888888888888889uLL) >> 0x40;
    v10 = v8 / 0x78;
    if ( a5 < (unsigned int)(v8 / 0x78) )
      LODWORD(v10) = a5;
    if ( (_DWORD)v10 )
    {
      v11 = *(_QWORD *)(v7 + 0x100);
      v12 = 0;
      v20 = 0;
      while ( 1 )
      {
        switch ( n6 )
        {
          case 0:
          case 1:
            v13 = *(_DWORD *)(v11 + 0x24) - *(_DWORD *)(v11 + 0x40);
            v14 = *(_DWORD *)(v11 + 0x20) - *(_DWORD *)(v11 + 0x3C);
            goto LABEL_13;
          case 2:
          case 3:
            v13 = *(_DWORD *)(v11 + 0x2C) - *(_DWORD *)(v11 + 0x48);
            v14 = *(_DWORD *)(v11 + 0x28) - *(_DWORD *)(v11 + 0x44);
            goto LABEL_13;
          case 4:
          case 5:
            v13 = *(_DWORD *)(v11 + 0x34) - *(_DWORD *)(v11 + 0x50);
            v14 = *(_DWORD *)(v11 + 0x30) - *(_DWORD *)(v11 + 0x4C);
LABEL_13:
            if ( !v13 )
              return;
            v15 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                    qword_149C8DFC8,
                    *(unsigned __int16 *)(v11 + 0x10));
            v16 = *(_QWORD *)(v11 + 8);
            v18 = v15;
            v19 = qword_149C8E060;
            sub_14045A0B0(&v17);
            if ( sub_14048D530(&v17, "component") )
            {
              sub_140492B70((__int64)&v17, v18);
              sub_140387CB0((__int64)&v17, (__int64)&unk_1482C0F54);
            }
            if ( sub_14048D530(&v17, "name") )
            {
              sub_140492B70((__int64)&v17, v16);
              sub_140387CB0((__int64)&v17, (__int64)&unk_1482C0F54);
            }
            if ( sub_14048D530(&v17, "bits") )
            {
              sub_140492950((__int64)&v17, v13);
              sub_140387CB0((__int64)&v17, (__int64)&unk_1482C0F54);
            }
            if ( sub_14048D530(&v17, "count") )
            {
              sub_140492950((__int64)&v17, v14);
              sub_140387CB0((__int64)&v17, (__int64)&unk_1482C0F54);
            }
            (*(void (__fastcall **)(__int64, const char *, _BYTE *, void **))(*(_QWORD *)v19 + 0x40LL))(
              v19,
              "void __cdecl CSerializedProfileMetrics::SendRankedProfileAnalytics(const char *,enum CSerializedProfileMet"
              "rics::EProfileCategory,enum CSerializedProfileMetrics::ERanking,unsigned int)",
              a2,
              &v17);
            sub_140373CC0(&v17);
            v12 += 0x78;
            v9 = (unsigned int)(v20 + 1);
            v20 = v9;
            if ( (unsigned int)v9 >= (unsigned int)v10 )
              return;
            v11 = v12 + *(_QWORD *)(v7 + 0x100);
            break;
          default:
            LogFatalError("unhandled ranking", v9);
            return;
        }
      }
    }
  }
}

// --- End Function: sub_1422E4CA0 (0x1422E4CA0) ---

// --- Function: sub_142305E10 (0x142305E10) ---
__int64 __fastcall sub_142305E10(__int64 a1)
{
  unsigned int n5; // ebx
  __int64 result; // rax

  n5 = dword_149F0443C - 1;
  if ( dword_149F0443C - 1 > 5 )
    n5 = 5;
  if ( dword_149F0443C > 0 )
    sub_14230CE30(a1, n5);
  result = sub_14230BA30(a1);
  if ( dword_149F0443C > 0 )
    return sub_14230CAC0(a1, n5);
  return result;
}

// --- End Function: sub_142305E10 (0x142305E10) ---

// --- Function: sub_142305E70 (0x142305E70) ---
__int64 __fastcall sub_142305E70(__int64 a1)
{
  _QWORD *v2; // rsi
  _QWORD *v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // r14
  bool v6; // al
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 (__fastcall *v9)(__int64, _BYTE *, __int16 *); // r14
  __int16 n0xFFFF_2; // cx
  __int64 v11; // rdi
  __int64 v12; // rax
  __int16 n4_1; // cx
  _QWORD *v14; // rax
  _QWORD *v15; // r12
  _QWORD *v16; // r14
  __int64 v17; // rax
  __int64 v18; // rdi
  __int64 (__fastcall *v19)(__int64, _BYTE *, __int16 *); // r15
  __int16 n0xFFFF; // cx
  __int64 v21; // rdi
  __int64 v22; // rax
  __int16 n4; // dx
  __int64 v24; // rax
  __int64 **v25; // rax
  __int64 i; // rax
  __int64 *v27; // rcx
  __int64 *v28; // rax
  unsigned int v30; // [rsp+30h] [rbp-69h] BYREF
  __int64 v31; // [rsp+38h] [rbp-61h] BYREF
  __int64 v32; // [rsp+40h] [rbp-59h] BYREF
  _QWORD *v33; // [rsp+48h] [rbp-51h]
  _BYTE v34[8]; // [rsp+50h] [rbp-49h] BYREF
  _QWORD *v35; // [rsp+58h] [rbp-41h]
  int n0x3500; // [rsp+60h] [rbp-39h] BYREF
  __int64 v37; // [rsp+64h] [rbp-35h]
  int v38; // [rsp+6Ch] [rbp-2Dh]
  unsigned __int64 v39; // [rsp+70h] [rbp-29h]
  unsigned __int64 v40; // [rsp+78h] [rbp-21h]
  __int64 v41; // [rsp+80h] [rbp-19h]
  __int64 v42; // [rsp+88h] [rbp-11h]
  _BYTE v43[8]; // [rsp+B0h] [rbp+17h] BYREF
  _BYTE v44[8]; // [rsp+B8h] [rbp+1Fh] BYREF
  __int16 n0xFFFF_3; // [rsp+100h] [rbp+67h] BYREF
  __int16 n0xFFFF_1; // [rsp+110h] [rbp+77h] BYREF
  char v47; // [rsp+118h] [rbp+7Fh] BYREF

  n0x3500 = 0x3500;
  v38 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v37 = 1;
  v39 = __rdtsc();
  qword_149C89AA0(
    &n0x3500,
    &word_149F0525C,
    "CSolarSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\SolarSystem/SolarSystem.cpp",
    0x13D);
  HIWORD(n0x3500) = word_149F0525C;
  if ( *(_DWORD *)(a1 + 0x78) )
  {
    if ( BYTE1(qword_149C8E516) )
    {
      if ( !byte_149C8E514 )
        goto LABEL_52;
    }
    else if ( BYTE2(qword_149C8E516) )
    {
      goto LABEL_52;
    }
    v2 = *(_QWORD **)(a1 + 0xE0);
    v35 = v2;
    v3 = (_QWORD *)*v2;
    v33 = v3;
    if ( v3 != v2 )
    {
      while ( 1 )
      {
        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
          qword_149C8DFC0,
          &v31,
          v3[4]);
        v4 = v31;
        if ( v31 )
        {
          v5 = (v31 & 0xF000000000000000uLL) != 0 ? v31 & 0xFFFFFF000000LL : (v31 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v5 + 2) == (HIWORD(v31) & 0xFFF) )
          {
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v6 = is_thread_privileged_or_bypass_mode(), v4 = v31, v6) )
              v6 = 1;
            if ( *(_WORD *)(v5 + 4) == 2 && v6 )
              goto LABEL_19;
            if ( sub_140395410(&v31) )
              break;
          }
        }
LABEL_43:
        v25 = (__int64 **)v3[2];
        if ( *((_BYTE *)v25 + 0x19) )
        {
          for ( i = v3[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
          {
            if ( v3 != *(_QWORD **)(i + 0x10) )
              break;
            v3 = (_QWORD *)i;
          }
          v3 = (_QWORD *)i;
          v33 = (_QWORD *)i;
        }
        else
        {
          v27 = *v25;
          v3 = (_QWORD *)v3[2];
          v33 = v25;
          if ( !*((_BYTE *)v27 + 0x19) )
          {
            do
            {
              v28 = (__int64 *)*v27;
              v3 = v27;
              v33 = v27;
              v27 = v28;
            }
            while ( !*((_BYTE *)v28 + 0x19) );
          }
        }
        if ( v3 == v2 )
          goto LABEL_52;
      }
      v4 = v31;
LABEL_19:
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 0x50LL))(v4 & 0xFFFFFFFFFFFFLL) )
      {
        v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(qword_149C8DFC0, v3[4]);
        v8 = v7;
        if ( v7 )
        {
          v9 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v7 + 0x340LL);
          n0xFFFF_2 = n0xFFFF_18;
          if ( n0xFFFF_18 == (__int16)0xFFFF )
          {
            n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                           + 0x10LL))(
                                    qword_149C8DFC8,
                                    &v47,
                                    "IActionAreaComponent");
            n0xFFFF_18 = n0xFFFF_2;
          }
          n0xFFFF_3 = n0xFFFF_2;
          v11 = *(_QWORD *)v9(v8, v43, &n0xFFFF_3);
          v32 = v11;
          if ( v11 )
          {
            v12 = sub_1403B84E0(v11 & 0xFFFFFFFFFFFFLL);
            n4_1 = *(_WORD *)(v12 + 4);
            if ( n4_1 != 4
              && *(_WORD *)(v12 + 2) == (HIWORD(v11) & 0xFFF)
              && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v32)) )
            {
              v14 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v11 & 0xFFFFFFFFFFFFLL) + 0x5A8LL))(v11 & 0xFFFFFFFFFFFFLL);
              v15 = (_QWORD *)v14[1];
              v16 = (_QWORD *)*v14;
              if ( (_QWORD *)*v14 != v15 )
              {
                do
                {
                  v17 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(
                          qword_149C8DFC0,
                          *v16);
                  v18 = v17;
                  if ( v17 )
                  {
                    v19 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v17 + 0x340LL);
                    n0xFFFF = n0xFFFF_17;
                    if ( n0xFFFF_17 == (__int16)0xFFFF )
                    {
                      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                                            qword_149C8DFC8,
                                            v34,
                                            "IEntityAreaProxy");
                      n0xFFFF_17 = n0xFFFF;
                    }
                    n0xFFFF_1 = n0xFFFF;
                    v21 = *(_QWORD *)v19(v18, v44, &n0xFFFF_1);
                    v32 = v21;
                    if ( v21 )
                    {
                      v22 = sub_1403B84E0(v21 & 0xFFFFFFFFFFFFLL);
                      n4 = *(_WORD *)(v22 + 4);
                      if ( n4 != 4
                        && *(_WORD *)(v22 + 2) == (HIWORD(v21) & 0xFFF)
                        && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v32)) )
                      {
                        v24 = *(_QWORD *)(v21 & 0xFFFFFFFFFFFFLL);
                        v30 = 0xFFEC9463;
                        (*(void (__fastcall **)(__int64, unsigned int *, _QWORD, _QWORD))(v24 + 0x7C0))(
                          v21 & 0xFFFFFFFFFFFFLL,
                          &v30,
                          0,
                          0);
                      }
                    }
                  }
                  else
                  {
                    v32 = 0;
                  }
                  ++v16;
                }
                while ( v16 != v15 );
                v3 = v33;
                v2 = v35;
              }
            }
          }
        }
        else
        {
          v32 = 0;
        }
      }
      goto LABEL_43;
    }
  }
LABEL_52:
  v40 = __rdtsc();
  return qword_149C89AA8(&n0x3500);
}

// --- End Function: sub_142305E70 (0x142305E70) ---

// --- Function: sub_14230BA30 (0x14230BA30) ---
__int64 __fastcall sub_14230BA30(__int64 p_rw_lock_state_1)
{
  unsigned int v1; // r14d
  __int64 p_rw_lock_state; // r13
  __int64 *v3; // rax
  bool v4; // di
  _QWORD *v5; // r15
  bool v6; // bl
  bool v9; // si
  signed __int64 v12; // rdx
  __int64 v13; // rdi
  unsigned int v14; // ebx
  _OWORD *v15; // rax
  __int64 v16; // rbx
  unsigned int n2_1; // r15d
  __int64 v18; // rax
  __int64 v19; // r13
  void *v20; // rsi
  signed __int64 v21; // rbx
  unsigned __int64 v22; // r12
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rdx
  __int64 v25; // rax
  char *v26; // rdi
  char *v27; // rcx
  const void *v28; // rdx
  char *Size; // r8
  _BYTE *v30; // rax
  unsigned int n2_4; // esi
  const char **v32; // rbx
  unsigned int n2_3; // r15d
  _OWORD *v34; // rax
  __int64 v35; // r13
  void *v36; // rsi
  signed __int64 v37; // rdi
  unsigned __int64 v38; // r12
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // rdx
  __int64 v41; // rax
  char *v42; // rbx
  char *v43; // rcx
  const void *v44; // rdx
  char *Size_1; // r8
  char *v46; // rax
  _QWORD *v47; // rdi
  _QWORD *v48; // rbx
  _BYTE *v49; // rdx
  __int64 v50; // rbx
  __int64 v51; // rdi
  __int64 v52; // rax
  unsigned int v53; // r8d
  unsigned int v54; // esi
  int v55; // eax
  __int64 v56; // rbx
  __int64 v57; // rdx
  int v58; // edi
  int v59; // r12d
  __int64 v60; // r15
  __int64 v61; // r13
  unsigned int v62; // esi
  unsigned int v63; // eax
  __int64 v64; // rbx
  __int64 v65; // rdx
  int v66; // edi
  int v67; // r12d
  __int64 v68; // r15
  __int64 v69; // r13
  unsigned int v70; // r8d
  unsigned int v71; // r12d
  int v72; // eax
  __int64 v73; // rbx
  __int64 v74; // rdi
  int v75; // esi
  int v76; // r15d
  __int64 v77; // rax
  __int64 v78; // r13
  __int64 v79; // rdi
  unsigned int v80; // r8d
  unsigned int v81; // r12d
  int v82; // eax
  __int64 v83; // rbx
  __int64 v84; // rdi
  int v85; // esi
  int v86; // r15d
  __int64 v87; // rax
  __int64 v88; // r13
  __int64 v89; // rdi
  __int64 v90; // rbx
  __int64 v91; // rdi
  int v92; // esi
  int v93; // r15d
  __int64 v94; // rax
  __int64 v95; // r12
  __int64 v96; // rdi
  __int64 v97; // r13
  unsigned int n2_5; // [rsp+30h] [rbp-D0h]
  unsigned int v100; // [rsp+30h] [rbp-D0h]
  unsigned int v101; // [rsp+30h] [rbp-D0h]
  unsigned int v102; // [rsp+30h] [rbp-D0h]
  unsigned int v103; // [rsp+30h] [rbp-D0h]
  unsigned int v104; // [rsp+30h] [rbp-D0h]
  _WORD v105[2]; // [rsp+34h] [rbp-CCh] BYREF
  void *v106; // [rsp+38h] [rbp-C8h] BYREF
  void *v107; // [rsp+40h] [rbp-C0h] BYREF
  void *v108; // [rsp+48h] [rbp-B8h] BYREF
  void *v109; // [rsp+50h] [rbp-B0h] BYREF
  void *v110; // [rsp+58h] [rbp-A8h] BYREF
  __int64 p_rw_lock_state_2; // [rsp+60h] [rbp-A0h]
  void *Src[2]; // [rsp+70h] [rbp-90h] BYREF
  char *v113; // [rsp+80h] [rbp-80h]
  void *v114[2]; // [rsp+88h] [rbp-78h] BYREF
  char *v115; // [rsp+98h] [rbp-68h]
  _WORD *v116; // [rsp+A0h] [rbp-60h]
  __int64 v117; // [rsp+A8h] [rbp-58h]
  __int64 v118; // [rsp+B0h] [rbp-50h]
  __int128 v119; // [rsp+B8h] [rbp-48h]
  __int64 v120; // [rsp+C8h] [rbp-38h] BYREF
  __int128 n0x6500_1; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v122; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v123; // [rsp+E8h] [rbp-18h]
  __int64 v124; // [rsp+F0h] [rbp-10h]
  __int64 v125; // [rsp+F8h] [rbp-8h]
  _QWORD *v126; // [rsp+120h] [rbp+20h]
  __int64 v127; // [rsp+128h] [rbp+28h] BYREF
  __int64 v128; // [rsp+130h] [rbp+30h]
  int n0x6500; // [rsp+140h] [rbp+40h] BYREF
  __int64 v130; // [rsp+144h] [rbp+44h]
  int v131; // [rsp+14Ch] [rbp+4Ch]
  unsigned __int64 v132; // [rsp+150h] [rbp+50h]
  unsigned __int64 v133; // [rsp+158h] [rbp+58h]
  __int64 v134; // [rsp+160h] [rbp+60h]
  __int64 v135; // [rsp+168h] [rbp+68h]
  __int128 v136; // [rsp+190h] [rbp+90h]
  _QWORD v137[3]; // [rsp+1A0h] [rbp+A0h] BYREF
  unsigned __int64 (__fastcall *p_sub_1421EF250)(__int64, __int64); // [rsp+1B8h] [rbp+B8h] BYREF
  void (__fastcall *n2)(int, unsigned __int64 (__fastcall **)(__int64, __int64), unsigned __int64 (__fastcall **)(__int64, __int64)); // [rsp+1C0h] [rbp+C0h]
  _OWORD *v140; // [rsp+1C8h] [rbp+C8h]
  unsigned int v141; // [rsp+1E8h] [rbp+E8h]
  __int64 v142; // [rsp+208h] [rbp+108h]
  _QWORD v143[3]; // [rsp+260h] [rbp+160h] BYREF
  _QWORD *(__fastcall *p_sub_1421EF0A0)(__int64, __int64); // [rsp+278h] [rbp+178h] BYREF
  void (__fastcall *n2_2)(__int64, _QWORD *(__fastcall **)(__int64, __int64)); // [rsp+280h] [rbp+180h]
  _OWORD *v146; // [rsp+288h] [rbp+188h]
  int n6; // [rsp+2A8h] [rbp+1A8h]
  __int64 v148; // [rsp+2C8h] [rbp+1C8h]

  v1 = 0;
  p_rw_lock_state_2 = p_rw_lock_state_1;
  v130 = 0;
  p_rw_lock_state = p_rw_lock_state_1;
  v131 = 0;
  v133 = 0;
  v134 = 0;
  v135 = 0;
  n0x6500 = 0x6500;
  v132 = __rdtsc();
  qword_149C89AA0(
    &n0x6500,
    &word_149F08644,
    "CSerializedProfileMetrics::UpdateDatasets",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
    0x134);
  HIWORD(n0x6500) = word_149F08644;
  v3 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                    qword_149C8DF80,
                    2);
  v105[0] = 0;
  v120 = *v3;
  v4 = byte_149C8E1C0 != byte_149C8E515 && *(float *)&dword_149F04570 > 0.0;
  v5 = (_QWORD *)(p_rw_lock_state + 0x4C0);
  v126 = (_QWORD *)(p_rw_lock_state + 0x4C0);
  v6 = dword_149F0443C > 0;
  sub_14059CA60(&v120, &v127, (_QWORD *)(p_rw_lock_state + 0x4C0));
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  v9 = 0;
  if ( *(float *)&_XMM1 >= *(float *)&dword_149F04570 )
    v9 = v4;
  LOBYTE(v105[0]) = v9;
  sub_14059CA60(&v120, &v127, (_QWORD *)(p_rw_lock_state + 0x4C8));
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  HIBYTE(v105[0]) = v6 && *(float *)&_XMM1 >= *(float *)&dword_149F04574;
  if ( __PAIR16__(HIBYTE(v105[0]), v9) )
  {
    if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(p_rw_lock_state + 0x14);
    }
    else
    {
      v12 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
      if ( (v12 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(
          p_rw_lock_state,
          v12,
          "CSerializedProfileMetrics::UpdateDatasets",
          "m_lock",
          1);
    }
    v117 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x60LL))(qword_149C8E038);
    v13 = v117;
    if ( v9 )
    {
      n0x6500_1 = 0x6500u;
      v123 = 0;
      v124 = 0;
      v125 = 0;
      v122 = __rdtsc();
      qword_149C89AA0(
        &n0x6500_1,
        &word_149F08658,
        "CSerializedProfileMetrics::ResetComponentMetrics",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
        0x240);
      WORD1(n0x6500_1) = word_149F08658;
      v14 = 8 * (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x18LL))(qword_149C8E038);
      if ( (unsigned int)((__int64)(*(_QWORD *)(p_rw_lock_state + 0x30) - *(_QWORD *)(p_rw_lock_state + 0x28)) >> 3) < v14 )
        v14 = (__int64)(*(_QWORD *)(p_rw_lock_state + 0x30) - *(_QWORD *)(p_rw_lock_state + 0x28)) >> 3;
      sub_1402B3B60((__int64)v137, 0x65, 0, "CSerializedProfileMetrics::ResetComponentMetrics");
      v142 = v117;
      v141 = v14;
      *(_QWORD *)&v119 = p_rw_lock_state;
      DWORD2(v119) = v14;
      if ( (unsigned __int64)n2 >= 2 )
      {
        ((void (__fastcall *)(__int64, unsigned __int64 (__fastcall **)(__int64, __int64)))n2)(2, &p_sub_1421EF250);
        n2 = 0;
      }
      p_sub_1421EF250 = 0;
      v15 = (_OWORD *)sub_1402A65A0(0x10u);
      if ( v15 )
      {
        *v15 = v119;
        v140 = v15;
      }
      else
      {
        v140 = 0;
      }
      p_sub_1421EF250 = sub_1421EF250;
      n2 = sub_1421F33F0;
      v116 = (_WORD *)(*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(
                        qword_149C8E038,
                        v137);
      v16 = (__int64)v116;
      sub_1402B6C70(v137);
      v123 = __rdtsc();
      qword_149C89AA8(&n0x6500_1);
      v113 = 0;
      n2_1 = 0;
      *(_OWORD *)Src = 0;
      do
      {
        if ( n2_1 != 2 )
        {
          v18 = sub_1421D7030(p_rw_lock_state, (_QWORD *)(p_rw_lock_state + 0x150LL * n2_1 + 0xD0), v16);
          v19 = v18;
          v20 = Src[1];
          if ( Src[1] == v113 )
          {
            v21 = ((char *)Src[1] - (char *)Src[0]) >> 3;
            if ( v21 == 0x1FFFFFFFFFFFFFFFLL )
              unknown_libname_10();
            v22 = v21 + 1;
            v23 = (v113 - (char *)Src[0]) >> 3;
            v24 = v23 >> 1;
            if ( v23 <= 0x1FFFFFFFFFFFFFFFLL - (v23 >> 1) )
            {
              v25 = v23 + v24;
              if ( v23 + v24 < v22 )
                v25 = v21 + 1;
            }
            else
            {
              v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v118 = 8 * v25;
            v26 = (char *)sub_140394E70((__int64)Src, 8 * v25);
            v27 = v26;
            *(_QWORD *)&v26[8 * v21] = v19;
            v28 = Src[0];
            if ( v20 == Src[1] )
            {
              Size = (char *)((char *)Src[1] - (char *)Src[0]);
            }
            else
            {
              memmove(v26, Src[0], (size_t)v20 - (unsigned __int64)Src[0]);
              v27 = &v26[8 * v21 + 8];
              Size = (char *)((char *)Src[1] - (char *)v20);
              v28 = v20;
            }
            memmove(v27, v28, (size_t)Size);
            if ( Src[0] )
              sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], (v113 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
            v16 = (__int64)v116;
            Src[1] = &v26[8 * v22];
            Src[0] = v26;
            v113 = &v26[v118];
          }
          else
          {
            *(_QWORD *)Src[1] = v18;
            Src[1] = (char *)Src[1] + 8;
          }
          p_rw_lock_state = p_rw_lock_state_2;
        }
        ++n2_1;
      }
      while ( n2_1 < 3 );
      sub_1422B75B0(p_rw_lock_state, (unsigned __int64 *)Src);
      if ( Src[0] )
        sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], (v113 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
      v13 = v117;
      v5 = (_QWORD *)(p_rw_lock_state + 0x4C0);
    }
    v30 = v105;
    n2_5 = 0;
    v116 = v105;
    n2_4 = 0;
    while ( 1 )
    {
      if ( *v30 )
      {
        v115 = 0;
        *(_OWORD *)v114 = 0;
        *(_QWORD *)&v119 = p_rw_lock_state + 0xD0;
        v32 = (const char **)(p_rw_lock_state + 0xD0);
        v118 = p_rw_lock_state + 0xD0;
        for ( n2_3 = 0; n2_3 < 3; ++n2_3 )
        {
          if ( n2_3 != 2 )
          {
            n0x6500_1 = 0x6500u;
            v123 = 0;
            v124 = 0;
            v125 = 0;
            v122 = __rdtsc();
            qword_149C89AA0(
              &n0x6500_1,
              &word_149F0865C,
              "CSerializedProfileMetrics::RankMetrics",
              "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
              0x259);
            WORD1(n0x6500_1) = word_149F0865C;
            sub_1402B3B60((__int64)v143, 0x65, 0, "CSerializedProfileMetrics::RankMetrics - %s", *v32);
            v148 = v13;
            n6 = 6;
            *(_QWORD *)&v136 = v32;
            DWORD2(v136) = n2_4;
            if ( (unsigned __int64)n2_2 >= 2 )
            {
              n2_2(2, &p_sub_1421EF0A0);
              n2_2 = 0;
            }
            p_sub_1421EF0A0 = 0;
            v34 = (_OWORD *)sub_1402A65A0(0x10u);
            if ( v34 )
            {
              *v34 = v136;
              v146 = v34;
            }
            else
            {
              v146 = 0;
            }
            p_sub_1421EF0A0 = sub_1421EF0A0;
            n2_2 = (void (__fastcall *)(__int64, _QWORD *(__fastcall **)(__int64, __int64)))sub_1421F2F00;
            v35 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(
                    qword_149C8E038,
                    v143);
            sub_1402B6C70(v143);
            v123 = __rdtsc();
            qword_149C89AA8(&n0x6500_1);
            v36 = v114[1];
            if ( v114[1] == v115 )
            {
              v37 = ((char *)v114[1] - (char *)v114[0]) >> 3;
              if ( v37 == 0x1FFFFFFFFFFFFFFFLL )
                unknown_libname_10();
              v38 = v37 + 1;
              v39 = (v115 - (char *)v114[0]) >> 3;
              v40 = v39 >> 1;
              if ( v39 <= 0x1FFFFFFFFFFFFFFFLL - (v39 >> 1) )
              {
                v41 = v40 + v39;
                if ( v40 + v39 < v38 )
                  v41 = v37 + 1;
              }
              else
              {
                v41 = 0x1FFFFFFFFFFFFFFFLL;
              }
              v128 = 8 * v41;
              v42 = (char *)sub_140394E70((__int64)v114, 8 * v41);
              v43 = v42;
              *(_QWORD *)&v42[8 * v37] = v35;
              v44 = v114[0];
              if ( v36 == v114[1] )
              {
                Size_1 = (char *)((char *)v114[1] - (char *)v114[0]);
              }
              else
              {
                memmove(v42, v114[0], (size_t)v36 - (unsigned __int64)v114[0]);
                v43 = &v42[8 * v37 + 8];
                Size_1 = (char *)((char *)v114[1] - (char *)v36);
                v44 = v36;
              }
              memmove(v43, v44, (size_t)Size_1);
              if ( v114[0] )
                sub_1403A6820(
                  (__int64)v114,
                  (unsigned __int64)v114[0],
                  (v115 - (char *)v114[0]) & 0xFFFFFFFFFFFFFFF8uLL);
              v114[0] = v42;
              v114[1] = &v42[8 * v38];
              v46 = &v42[v128];
              v32 = (const char **)v118;
              v115 = v46;
            }
            else
            {
              *(_QWORD *)v114[1] = v35;
              v114[1] = (char *)v114[1] + 8;
            }
            n2_4 = n2_5;
          }
          v13 = v117;
          v32 += 0x2A;
          v118 = (__int64)v32;
        }
        v47 = (_QWORD *)v119;
        p_rw_lock_state = p_rw_lock_state_2;
        v48 = (_QWORD *)(v119 + 0x3F0);
        do
        {
          sub_1422E0F10(p_rw_lock_state, v47, n2_4, v114);
          v47 += 0x2A;
        }
        while ( v47 != v48 );
        v5 = v126;
        v49 = v114[0];
        *v126 = v120;
        if ( v49 )
          sub_1403A6820((__int64)v114, (unsigned __int64)v49, (v115 - v49) & 0xFFFFFFFFFFFFFFF8uLL);
        v30 = v116;
      }
      ++n2_4;
      ++v5;
      ++v30;
      n2_5 = n2_4;
      v126 = v5;
      v116 = v30;
      if ( n2_4 >= 2 )
        break;
      v13 = v117;
    }
    v50 = qword_149C8E038;
    v51 = *(_QWORD *)qword_149C8E038;
    v52 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x60LL))(qword_149C8E038);
    (*(void (__fastcall **)(__int64, __int64))(v51 + 0x68))(v50, v52);
    if ( LOBYTE(v105[0]) )
    {
      v53 = dword_149F04578;
      v54 = 0;
      v55 = dword_149F04578;
      if ( dword_149F04578 >= (unsigned int)((*(_QWORD *)(p_rw_lock_state + 0x60) - *(_QWORD *)(p_rw_lock_state + 0x58))
                                           / 0x3CLL) )
        v55 = (*(_QWORD *)(p_rw_lock_state + 0x60) - *(_QWORD *)(p_rw_lock_state + 0x58)) / 0x3CLL;
      v100 = v55;
      if ( v55 )
      {
        v56 = 0;
        do
        {
          v57 = *(_QWORD *)(p_rw_lock_state + 0x58);
          v58 = *(_DWORD *)(v56 + v57 + 0x1C);
          v59 = *(_DWORD *)(v56 + v57 + 0x18);
          if ( !v58 )
            break;
          v60 = qword_149C8E060;
          v61 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                  qword_149C8DFC8,
                  *(unsigned __int16 *)(v56 + v57));
          sub_14045A0B0(&v109);
          if ( sub_14048D530(&v109, "component") )
          {
            sub_140492B70((__int64)&v109, v61);
            sub_140387CB0((__int64)&v109, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v109, "bits") )
          {
            sub_140492950((__int64)&v109, v58);
            sub_140387CB0((__int64)&v109, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v109, "count") )
          {
            sub_140492950((__int64)&v109, v59);
            sub_140387CB0((__int64)&v109, (__int64)&unk_1482C0F54);
          }
          (*(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v60 + 0x40LL))(
            v60,
            "void __cdecl CSerializedProfileMetrics::SendRankedComponentAnalytics(const char *,enum CSerializedProfileMet"
            "rics::ERanking,unsigned int,bool)",
            "Serialized.Component.Read",
            &v109);
          sub_140373CC0(&v109);
          p_rw_lock_state = p_rw_lock_state_2;
          ++v54;
          v56 += 0x3C;
        }
        while ( v54 < v100 );
        v53 = dword_149F04578;
      }
      v62 = 0;
      v63 = v53;
      if ( v53 >= (unsigned int)((*(_QWORD *)(p_rw_lock_state + 0x90) - *(_QWORD *)(p_rw_lock_state + 0x88)) / 0x3CLL) )
        v63 = (*(_QWORD *)(p_rw_lock_state + 0x90) - *(_QWORD *)(p_rw_lock_state + 0x88)) / 0x3CLL;
      v101 = v63;
      if ( v63 )
      {
        v64 = 0;
        do
        {
          v65 = *(_QWORD *)(p_rw_lock_state + 0x88);
          v66 = *(_DWORD *)(v64 + v65 + 0x24);
          v67 = *(_DWORD *)(v64 + v65 + 0x20);
          if ( !v66 )
            break;
          v68 = qword_149C8E060;
          v69 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                  qword_149C8DFC8,
                  *(unsigned __int16 *)(v64 + v65));
          sub_14045A0B0(&v110);
          if ( sub_14048D530(&v110, "component") )
          {
            sub_140492B70((__int64)&v110, v69);
            sub_140387CB0((__int64)&v110, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v110, "bits") )
          {
            sub_140492950((__int64)&v110, v66);
            sub_140387CB0((__int64)&v110, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v110, "count") )
          {
            sub_140492950((__int64)&v110, v67);
            sub_140387CB0((__int64)&v110, (__int64)&unk_1482C0F54);
          }
          (*(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v68 + 0x40LL))(
            v68,
            "void __cdecl CSerializedProfileMetrics::SendRankedComponentAnalytics(const char *,enum CSerializedProfileMet"
            "rics::ERanking,unsigned int,bool)",
            "Serialized.Component.Write",
            &v110);
          sub_140373CC0(&v110);
          p_rw_lock_state = p_rw_lock_state_2;
          ++v62;
          v64 += 0x3C;
        }
        while ( v62 < v101 );
        v53 = dword_149F04578;
      }
      sub_1422E4CA0(p_rw_lock_state, "Serialized.SV.Read", 0, 1, v53);
      v70 = dword_149F04578;
      v71 = 0;
      v72 = dword_149F04578;
      if ( dword_149F04578 >= (unsigned int)((*(_QWORD *)(p_rw_lock_state + 0x150) - *(_QWORD *)(p_rw_lock_state + 0x148))
                                           / 0x78LL) )
        v72 = (*(_QWORD *)(p_rw_lock_state + 0x150) - *(_QWORD *)(p_rw_lock_state + 0x148)) / 0x78LL;
      v102 = v72;
      if ( v72 )
      {
        v73 = 0;
        do
        {
          v74 = *(_QWORD *)(p_rw_lock_state + 0x148);
          v75 = *(_DWORD *)(v73 + v74 + 0x2C) - *(_DWORD *)(v73 + v74 + 0x48);
          v76 = *(_DWORD *)(v73 + v74 + 0x28) - *(_DWORD *)(v73 + v74 + 0x44);
          if ( *(_DWORD *)(v73 + v74 + 0x2C) == *(_DWORD *)(v73 + v74 + 0x48) )
            break;
          v77 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                  qword_149C8DFC8,
                  *(unsigned __int16 *)(v73 + v74 + 0x10));
          v78 = qword_149C8E060;
          v79 = *(_QWORD *)(v73 + v74 + 8);
          *(_QWORD *)&v119 = v77;
          sub_14045A0B0(&v106);
          if ( sub_14048D530(&v106, "component") )
          {
            sub_140492B70((__int64)&v106, v119);
            sub_140387CB0((__int64)&v106, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v106, "name") )
          {
            sub_140492B70((__int64)&v106, v79);
            sub_140387CB0((__int64)&v106, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v106, "bits") )
          {
            sub_140492950((__int64)&v106, v75);
            sub_140387CB0((__int64)&v106, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v106, "count") )
          {
            sub_140492950((__int64)&v106, v76);
            sub_140387CB0((__int64)&v106, (__int64)&unk_1482C0F54);
          }
          (*(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v78 + 0x40LL))(
            v78,
            "void __cdecl CSerializedProfileMetrics::SendRankedProfileAnalytics(const char *,enum CSerializedProfileMetri"
            "cs::EProfileCategory,enum CSerializedProfileMetrics::ERanking,unsigned int)",
            "Serialized.SV.Write",
            &v106);
          sub_140373CC0(&v106);
          p_rw_lock_state = p_rw_lock_state_2;
          ++v71;
          v73 += 0x78;
        }
        while ( v71 < v102 );
        v70 = dword_149F04578;
      }
      sub_1422E4CA0(p_rw_lock_state, "Serialized.RM.Read", 1, 1, v70);
      v80 = dword_149F04578;
      v81 = 0;
      v82 = dword_149F04578;
      if ( dword_149F04578 >= (unsigned int)((*(_QWORD *)(p_rw_lock_state + 0x2A0) - *(_QWORD *)(p_rw_lock_state + 0x298))
                                           / 0x78LL) )
        v82 = (*(_QWORD *)(p_rw_lock_state + 0x2A0) - *(_QWORD *)(p_rw_lock_state + 0x298)) / 0x78LL;
      v103 = v82;
      if ( v82 )
      {
        v83 = 0;
        do
        {
          v84 = *(_QWORD *)(p_rw_lock_state + 0x298);
          v85 = *(_DWORD *)(v83 + v84 + 0x2C) - *(_DWORD *)(v83 + v84 + 0x48);
          v86 = *(_DWORD *)(v83 + v84 + 0x28) - *(_DWORD *)(v83 + v84 + 0x44);
          if ( *(_DWORD *)(v83 + v84 + 0x2C) == *(_DWORD *)(v83 + v84 + 0x48) )
            break;
          v87 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                  qword_149C8DFC8,
                  *(unsigned __int16 *)(v83 + v84 + 0x10));
          v88 = qword_149C8E060;
          v89 = *(_QWORD *)(v83 + v84 + 8);
          *(_QWORD *)&v119 = v87;
          sub_14045A0B0(&v107);
          if ( sub_14048D530(&v107, "component") )
          {
            sub_140492B70((__int64)&v107, v119);
            sub_140387CB0((__int64)&v107, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v107, "name") )
          {
            sub_140492B70((__int64)&v107, v89);
            sub_140387CB0((__int64)&v107, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v107, "bits") )
          {
            sub_140492950((__int64)&v107, v85);
            sub_140387CB0((__int64)&v107, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v107, "count") )
          {
            sub_140492950((__int64)&v107, v86);
            sub_140387CB0((__int64)&v107, (__int64)&unk_1482C0F54);
          }
          (*(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v88 + 0x40LL))(
            v88,
            "void __cdecl CSerializedProfileMetrics::SendRankedProfileAnalytics(const char *,enum CSerializedProfileMetri"
            "cs::EProfileCategory,enum CSerializedProfileMetrics::ERanking,unsigned int)",
            "Serialized.RM.Write",
            &v107);
          sub_140373CC0(&v107);
          p_rw_lock_state = p_rw_lock_state_2;
          ++v81;
          v83 += 0x78;
        }
        while ( v81 < v103 );
        v80 = dword_149F04578;
      }
      if ( byte_149C8E1C0 )
      {
        if ( v80 >= (unsigned int)((*(_QWORD *)(p_rw_lock_state + 0x168) - *(_QWORD *)(p_rw_lock_state + 0x160)) / 0x78LL) )
          v80 = (*(_QWORD *)(p_rw_lock_state + 0x168) - *(_QWORD *)(p_rw_lock_state + 0x160)) / 0x78LL;
        v104 = v80;
        if ( v80 )
        {
          v90 = 0;
          do
          {
            v91 = *(_QWORD *)(p_rw_lock_state + 0x160);
            v92 = *(_DWORD *)(v90 + v91 + 0x34) - *(_DWORD *)(v90 + v91 + 0x50);
            v93 = *(_DWORD *)(v90 + v91 + 0x30) - *(_DWORD *)(v90 + v91 + 0x4C);
            if ( *(_DWORD *)(v90 + v91 + 0x34) == *(_DWORD *)(v90 + v91 + 0x50) )
              break;
            v94 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                    qword_149C8DFC8,
                    *(unsigned __int16 *)(v90 + v91 + 0x10));
            v95 = qword_149C8E060;
            v96 = *(_QWORD *)(v90 + v91 + 8);
            v97 = v94;
            sub_14045A0B0(&v108);
            if ( sub_14048D530(&v108, "component") )
            {
              sub_140492B70((__int64)&v108, v97);
              sub_140387CB0((__int64)&v108, (__int64)&unk_1482C0F54);
            }
            if ( sub_14048D530(&v108, "name") )
            {
              sub_140492B70((__int64)&v108, v96);
              sub_140387CB0((__int64)&v108, (__int64)&unk_1482C0F54);
            }
            if ( sub_14048D530(&v108, "bits") )
            {
              sub_140492950((__int64)&v108, v92);
              sub_140387CB0((__int64)&v108, (__int64)&unk_1482C0F54);
            }
            if ( sub_14048D530(&v108, "count") )
            {
              sub_140492950((__int64)&v108, v93);
              sub_140387CB0((__int64)&v108, (__int64)&unk_1482C0F54);
            }
            (*(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v95 + 0x40LL))(
              v95,
              "void __cdecl CSerializedProfileMetrics::SendRankedProfileAnalytics(const char *,enum CSerializedProfileMet"
              "rics::EProfileCategory,enum CSerializedProfileMetrics::ERanking,unsigned int)",
              "Serialized.SV.Persistence.Write",
              &v108);
            sub_140373CC0(&v108);
            p_rw_lock_state = p_rw_lock_state_2;
            ++v1;
            v90 += 0x78;
          }
          while ( v1 < v104 );
        }
      }
    }
    rw_lock_release_read_lock(p_rw_lock_state);
  }
  v133 = __rdtsc();
  return qword_149C89AA8(&n0x6500);
}

// --- End Function: sub_14230BA30 (0x14230BA30) ---

// --- Function: sub_14230CAC0 (0x14230CAC0) ---
__int64 __fastcall sub_14230CAC0(__int64 a1, signed int n5)
{
  signed int n5_1; // r14d
  __int64 v4; // rax
  __int64 v5; // rbx
  _QWORD *v6; // rax
  __int64 **v7; // r13
  __int64 *v8; // rbx
  unsigned __int64 *v9; // r12
  unsigned int n2; // r15d
  __int64 *v11; // rdi
  unsigned __int64 v12; // rbx
  __int64 *v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rax
  __int128 v16; // xmm0
  __int64 *v17; // rsi
  __int64 *v18; // rbx
  __int64 v19; // r14
  __int64 v20; // rbx
  __int64 v21; // rdx
  __int64 v22; // r8
  __int64 *v23; // rdi
  __int64 v25; // [rsp+30h] [rbp-79h] BYREF
  void *v26; // [rsp+38h] [rbp-71h] BYREF
  __int64 v27; // [rsp+40h] [rbp-69h]
  __int64 v28; // [rsp+48h] [rbp-61h]
  __int64 v29; // [rsp+50h] [rbp-59h]
  __int128 v30; // [rsp+60h] [rbp-49h] BYREF
  int n0x6500; // [rsp+80h] [rbp-29h] BYREF
  __int64 v32; // [rsp+84h] [rbp-25h]
  int v33; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v34; // [rsp+90h] [rbp-19h]
  unsigned __int64 v35; // [rsp+98h] [rbp-11h]
  __int64 v36; // [rsp+A0h] [rbp-9h]
  __int64 v37; // [rsp+A8h] [rbp-1h]
  __int64 **v39; // [rsp+120h] [rbp+77h]

  n0x6500 = 0x6500;
  v32 = 0;
  n5_1 = n5;
  v33 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v34 = __rdtsc();
  qword_149C89AA0(
    &n0x6500,
    &word_149F08668,
    "CSerializedProfileMetrics::UpdateDebugRenderer_Rankings",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
    0x2DD);
  HIWORD(n0x6500) = word_149F08668;
  if ( Parameter_0 )
  {
    v4 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_0 + 0x50LL))(Parameter_0);
    v5 = v4;
    if ( v4 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x20LL))(v4) )
      {
        v6 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                         qword_149C8DF80,
                         2);
        if ( !unknown_libname_23((_QWORD *)(a1 + 0x4C8), v6) )
        {
          v39 = (__int64 **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x28LL))(v5);
          v7 = v39;
          v8 = *v39;
          sub_142188690((__int64)v39, (__int64)v39, (*v39)[1]);
          v8[1] = (__int64)v8;
          v9 = (unsigned __int64 *)(a1 + 0xD0);
          *v8 = (__int64)v8;
          v8[2] = (__int64)v8;
          n2 = 0;
          v39[1] = 0;
          do
          {
            if ( n2 != 2 )
            {
              v11 = *v7;
              v12 = *v9;
              v13 = v11;
              DWORD2(v30) = 0;
              v14 = v11[1];
              *(_QWORD *)&v30 = v14;
              while ( !*(_BYTE *)(v14 + 0x19) )
              {
                *(_QWORD *)&v30 = v14;
                if ( *(_QWORD *)(v14 + 0x20) >= v12 )
                {
                  v13 = (__int64 *)v14;
                  DWORD2(v30) = 1;
                  v14 = *(_QWORD *)v14;
                }
                else
                {
                  v14 = *(_QWORD *)(v14 + 0x10);
                  DWORD2(v30) = 0;
                }
              }
              if ( *((_BYTE *)v13 + 0x19) || v12 < v13[4] )
              {
                if ( v7[1] == (__int64 *)0x3FFFFFFFFFFFFFFLL )
                  unknown_libname_7();
                v15 = sub_1402A65A0(0x40u);
                v16 = v30;
                *(_QWORD *)(v15 + 0x20) = v12;
                *(_QWORD *)(v15 + 0x28) = 0;
                *(_QWORD *)(v15 + 0x30) = 0;
                *(_QWORD *)(v15 + 0x38) = 0;
                *(_QWORD *)v15 = v11;
                *(_QWORD *)(v15 + 8) = v11;
                *(_QWORD *)(v15 + 0x10) = v11;
                *(_WORD *)(v15 + 0x18) = 0;
                v30 = v16;
                v17 = (__int64 *)(std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                                    v7,
                                    (__int64)&v30,
                                    v15)
                                + 0x28);
                v18 = (__int64 *)&v9[3 * n5_1 + 0x18];
                sub_142324720(v17, (v18[1] - *v18) / 0x78);
                v19 = v18[1];
                v20 = *v18;
                if ( v20 != v19 )
                {
                  do
                  {
                    v25 = 0;
                    sub_14035E090(&v26);
                    v21 = *(unsigned __int16 *)(v20 + 0x10);
                    v27 = 0;
                    v28 = 0;
                    v29 = 0;
                    v25 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(
                            qword_149C8DFC8,
                            v21);
                    copyStringStructure(&v26, (const void **)(v20 + 8), v22);
                    v23 = (__int64 *)v17[1];
                    LODWORD(v27) = *(_DWORD *)(v20 + 0x20) - *(_DWORD *)(v20 + 0x58);
                    HIDWORD(v27) = *(_DWORD *)(v20 + 0x24) - *(_DWORD *)(v20 + 0x5C);
                    LODWORD(v28) = *(_DWORD *)(v20 + 0x28) - *(_DWORD *)(v20 + 0x60);
                    HIDWORD(v28) = *(_DWORD *)(v20 + 0x2C) - *(_DWORD *)(v20 + 0x64);
                    LODWORD(v29) = *(_DWORD *)(v20 + 0x30) - *(_DWORD *)(v20 + 0x68);
                    HIDWORD(v29) = *(_DWORD *)(v20 + 0x34) - *(_DWORD *)(v20 + 0x6C);
                    if ( v23 == (__int64 *)v17[2] )
                    {
                      sub_142187310(v17, (__int64)v23, (__int64)&v25);
                    }
                    else
                    {
                      *v23 = v25;
                      sub_14035DDF0(v23 + 1, (__int64 *)&v26);
                      v23[2] = v27;
                      v23[3] = v28;
                      v23[4] = v29;
                      v17[1] += 0x28;
                    }
                    sub_140373CC0(&v26);
                    v20 += 0x78;
                  }
                  while ( v20 != v19 );
                  v7 = v39;
                }
                n5_1 = n5;
              }
            }
            ++n2;
            v9 += 0x2A;
          }
          while ( n2 < 3 );
        }
      }
    }
  }
  v35 = __rdtsc();
  return qword_149C89AA8(&n0x6500);
}

// --- End Function: sub_14230CAC0 (0x14230CAC0) ---

// --- Function: sub_14230CE30 (0x14230CE30) ---
__int64 __fastcall sub_14230CE30(__int64 a1, int n5)
{
  __int64 n2; // r12
  __int64 v4; // rax
  __int64 v5; // rdi
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r15
  __int64 v11; // r14
  _QWORD *v12; // rsi
  _QWORD **v13; // rax
  _QWORD *_First_1; // r10
  __int64 **v15; // r13
  _QWORD *_First; // r15
  __int64 *m; // rdi
  __int64 *v18; // rbx
  __int64 *v19; // rax
  __int64 v20; // r14
  unsigned __int64 v21; // rcx
  __int64 v22; // r12
  __int64 *j; // rbx
  __int64 **v24; // rax
  __int64 *i; // rax
  __int64 *v26; // rcx
  __int64 **v27; // rax
  __int64 *k; // rax
  __int64 *v29; // rcx
  _QWORD *_First_2; // rbx
  __int64 v31; // rax
  void *Src[2]; // [rsp+30h] [rbp-79h] BYREF
  char *v34; // [rsp+40h] [rbp-69h]
  _QWORD **v35; // [rsp+48h] [rbp-61h]
  int n0x6500; // [rsp+50h] [rbp-59h] BYREF
  __int64 v37; // [rsp+54h] [rbp-55h]
  int v38; // [rsp+5Ch] [rbp-4Dh]
  unsigned __int64 v39; // [rsp+60h] [rbp-49h]
  unsigned __int64 v40; // [rsp+68h] [rbp-41h]
  __int64 v41; // [rsp+70h] [rbp-39h]
  __int64 v42; // [rsp+78h] [rbp-31h]
  __int64 v43; // [rsp+A0h] [rbp-9h] BYREF
  char v44[8]; // [rsp+A8h] [rbp-1h] BYREF
  __int64 v45[10]; // [rsp+B0h] [rbp+7h] BYREF
  __int64 v47; // [rsp+120h] [rbp+77h] BYREF
  __int64 n2_1; // [rsp+128h] [rbp+7Fh]

  LODWORD(n2) = 0;
  n0x6500 = 0x6500;
  n2_1 = 0;
  v37 = 0;
  v38 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v39 = __rdtsc();
  qword_149C89AA0(
    &n0x6500,
    &word_149F08664,
    "CSerializedProfileMetrics::UpdateDebugRenderer_SelectedComponents",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedProfileMetrics.cpp",
    0x2A2);
  HIWORD(n0x6500) = word_149F08664;
  if ( Parameter_0 )
  {
    v4 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_0 + 0x50LL))(Parameter_0);
    v5 = v4;
    if ( v4 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x20LL))(v4) )
      {
        v47 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                           qword_149C8DF80,
                           2);
        sub_14059CA60(&v47, &v43, (_QWORD *)(a1 + 0x4C8));
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        if ( *(float *)&_XMM1 >= *(float *)&dword_149F04574 )
        {
          v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x28LL))(v5);
          v9 = *(_QWORD *)(v8 + 0x10);
          v10 = v8;
          v11 = *(_QWORD *)(v8 + 0x18);
          v12 = (_QWORD *)(v8 + 0x10);
          if ( v9 != v11 )
          {
            do
            {
              sub_140373CC0((_QWORD *)(v9 + 8));
              v9 += 0x28;
            }
            while ( v9 != v11 );
            v12[1] = *v12;
          }
          *(_QWORD *)(v10 + 0x28) = v47;
          v13 = (_QWORD **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x30LL))(v5);
          v35 = v13;
          if ( v13 )
          {
            *(_OWORD *)Src = 0;
            _First_1 = 0;
            v15 = (__int64 **)(a1 + 0xD8);
            _First = 0;
            v34 = 0;
            do
            {
              if ( (_DWORD)n2 != 2 )
              {
                m = (__int64 *)**v13;
                if ( !*((_BYTE *)m + 0x19) )
                {
                  do
                  {
                    v18 = *v15;
                    v19 = (__int64 *)(*v15)[1];
                    while ( !*((_BYTE *)v19 + 0x19) )
                    {
                      if ( *((_WORD *)v19 + 0x10) >= *((_WORD *)m + 0xD) )
                      {
                        v18 = v19;
                        v19 = (__int64 *)*v19;
                      }
                      else
                      {
                        v19 = (__int64 *)v19[2];
                      }
                    }
                    if ( !*((_BYTE *)v18 + 0x19) && *((_WORD *)m + 0xD) >= *((_WORD *)v18 + 0x10) && v18 != *v15 )
                    {
                      v20 = _First_1 - _First;
                      v21 = v20 + v18[6];
                      if ( v21 > (v34 - (char *)_First) >> 3 )
                      {
                        if ( v21 > 0x1FFFFFFFFFFFFFFFLL )
                          unknown_libname_10();
                        v22 = v21;
                        _First = (_QWORD *)sub_140394E70((__int64)Src, 8 * v21);
                        memmove(_First, Src[0], (char *)Src[1] - (char *)Src[0]);
                        if ( Src[0] )
                          sub_1403A6820(
                            (__int64)Src,
                            (unsigned __int64)Src[0],
                            (v34 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
                        _First_1 = &_First[v20];
                        Src[0] = _First;
                        Src[1] = _First_1;
                        v34 = (char *)&_First[v22];
                      }
                      j = *(__int64 **)v18[5];
                      if ( !*((_BYTE *)j + 0x19) )
                      {
                        do
                        {
                          sub_1402A8EB0(Src, j + 5);
                          v24 = (__int64 **)j[2];
                          if ( *((_BYTE *)v24 + 0x19) )
                          {
                            for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
                            {
                              if ( j != (__int64 *)i[2] )
                                break;
                              j = i;
                            }
                            j = i;
                          }
                          else
                          {
                            v26 = *v24;
                            for ( j = (__int64 *)j[2]; !*((_BYTE *)v26 + 0x19); v26 = (__int64 *)*v26 )
                              j = v26;
                          }
                        }
                        while ( !*((_BYTE *)j + 0x19) );
                        _First_1 = Src[1];
                        _First = Src[0];
                      }
                    }
                    v27 = (__int64 **)m[2];
                    if ( *((_BYTE *)v27 + 0x19) )
                    {
                      for ( k = (__int64 *)m[1]; !*((_BYTE *)k + 0x19); k = (__int64 *)k[1] )
                      {
                        if ( m != (__int64 *)k[2] )
                          break;
                        m = k;
                      }
                      m = k;
                    }
                    else
                    {
                      v29 = *v27;
                      for ( m = (__int64 *)m[2]; !*((_BYTE *)v29 + 0x19); v29 = (__int64 *)*v29 )
                        m = v29;
                    }
                  }
                  while ( !*((_BYTE *)m + 0x19) );
                  LODWORD(n2) = n2_1;
                  v13 = v35;
                }
              }
              n2 = (unsigned int)(n2 + 1);
              v15 += 0x2A;
              n2_1 = n2;
            }
            while ( (unsigned int)n2 < 3 );
            if ( _First != _First_1 )
            {
              sub_1421949A0(
                (char *)_First,
                (Chaos::FCCDConstraint **)_First_1,
                _First_1 - _First,
                (bool (__fastcall *)(const Chaos::FCCDConstraint *, const Chaos::FCCDConstraint *))qword_149F04510[2 * n5]);
              sub_142324720(v12, ((char *)Src[1] - (char *)Src[0]) >> 3);
              _First = Src[0];
              _First_2 = Src[1];
              if ( Src[0] != Src[1] )
              {
                do
                {
                  v31 = sub_142283380((__int64)v44, *_First);
                  sub_142181BD0((__int64)v12, v31);
                  sub_140373CC0(v45);
                  ++_First;
                }
                while ( _First != _First_2 );
                _First = Src[0];
              }
            }
            if ( _First )
              sub_1403A6820((__int64)Src, (unsigned __int64)_First, (v34 - (char *)_First) & 0xFFFFFFFFFFFFFFF8uLL);
          }
        }
      }
    }
  }
  v40 = __rdtsc();
  return qword_149C89AA8(&n0x6500);
}

// --- End Function: sub_14230CE30 (0x14230CE30) ---

// --- Function: sub_14231A9D0 (0x14231A9D0) ---
__int64 __fastcall sub_14231A9D0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 i; // rdi
  __int64 v10; // r8
  __int64 result; // rax

  v4 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v4 != i; v4 += 0x28 )
      sub_140373CC0((_QWORD *)(v4 + 8));
    v10 = *a1;
    if ( (unsigned __int64)(0x28 * ((a1[2] - *a1) / 0x28)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v10 - *(_QWORD *)(v10 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = *(_QWORD *)(v10 - 8);
    }
    sub_1402A6590(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 0x28 * a3;
  result = 5 * a4;
  a1[2] = a2 + 0x28 * a4;
  return result;
}

// --- End Function: sub_14231A9D0 (0x14231A9D0) ---

// --- Function: sub_14231CE10 (0x14231CE10) ---
__int64 __fastcall sub_14231CE10(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 i; // rdi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != i; v1 += 0x28 )
      sub_140373CC0((_QWORD *)(v1 + 8));
    v4 = *a1;
    if ( (unsigned __int64)(0x28 * ((a1[2] - *a1) / 0x28)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_1402A6590(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_14231CE10 (0x14231CE10) ---

// --- Function: sub_142324720 (0x142324720) ---
unsigned __int64 __fastcall sub_142324720(__int64 *a1, unsigned __int64 a2)
{
  __int64 v3; // r8
  unsigned __int64 result; // rax
  __int64 v6; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rbx

  v3 = a1[2] - *a1;
  result = (unsigned __int64)((unsigned __int128)(v3 * (__int128)0x6666666666666667LL) >> 0x40) >> 0x3F;
  if ( a2 > v3 / 0x28 )
  {
    if ( a2 > 0x666666666666666LL )
      unknown_libname_10();
    v6 = (a1[1] - *a1) / 0x28;
    allocSize = 0x28 * a2;
    if ( 0x28 * a2 < 0x1000 )
    {
      if ( allocSize )
        v9 = (_QWORD *)sub_1402A65A0(allocSize);
      else
        v9 = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E3880();
      v8 = sub_1402A65A0(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      v9 = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      v9[0xFFFFFFFF] = v8;
    }
    sub_142199780((_DWORD *)*a1, (_DWORD *)a1[1], v9);
    return sub_14231A9D0(a1, (__int64)v9, v6, a2);
  }
  return result;
}

// --- End Function: sub_142324720 (0x142324720) ---

// --- Function: sub_142347EC0 (0x142347EC0) ---
void __fastcall sub_142347EC0(__int64 a1)
{
  *(_BYTE *)(a1 + 1) |= 0x10u;
}

// --- End Function: sub_142347EC0 (0x142347EC0) ---

// --- Function: sub_14234CA40 (0x14234CA40) ---
__int64 __fastcall sub_14234CA40(__int64 a1)
{
  return a1 + 0x320;
}

// --- End Function: sub_14234CA40 (0x14234CA40) ---

// --- Function: sub_142371B60 (0x142371B60) ---
__int64 __fastcall sub_142371B60(__int64 a1)
{
  __int64 v2; // rdx
  int n0x6200; // [rsp+30h] [rbp-58h] BYREF
  __int64 v5; // [rsp+34h] [rbp-54h]
  int v6; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+40h] [rbp-48h]
  unsigned __int64 v8; // [rsp+48h] [rbp-40h]
  __int64 v9; // [rsp+50h] [rbp-38h]
  __int64 v10; // [rsp+58h] [rbp-30h]

  n0x6200 = 0x6200;
  v5 = 1;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = __rdtsc();
  qword_149C89AA0(
    &n0x6200,
    &word_149F09110,
    "CEntityAudioControllerManager::SyncUpdate",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Sound/EntityAudioControllerManager.cpp",
    0x5D);
  v2 = *(_QWORD *)(a1 + 0x70);
  HIWORD(n0x6200) = word_149F09110;
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x48LL))(qword_149C8E038, v2);
  v8 = __rdtsc();
  return qword_149C89AA8(&n0x6200);
}

// --- End Function: sub_142371B60 (0x142371B60) ---

// --- Function: sub_14237CCF0 (0x14237CCF0) ---
__int64 __fastcall sub_14237CCF0(__int64 a1)
{
  __int64 _Wherenode_8; // rax
  __int64 *_Wherenode_2; // rbx
  __int64 v4; // r15
  _QWORD *v5; // rsi
  _BYTE *v6; // rdx
  char v7; // cl
  __int64 *_Wherenode_9; // rcx
  __int64 *_Wherenode_1; // rdi
  __int64 _Wherenode_3; // rax
  __int64 _Wherenode_4; // rcx
  __int64 *_Wherenode_7; // r8
  __int64 *_Wherenode_5; // rax
  __int64 *_Wherenode_10; // rcx
  __int64 **v15; // r8
  __int64 *_Wherenode; // rdx
  __int64 *_Wherenode_6; // rcx
  __int64 *i; // r8
  __int64 *v19; // rax
  __int64 *v20; // rax

  _Wherenode_8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x100LL))(qword_149C8DFE0);
  if ( (_DWORD)_Wherenode_8 == 1 )
  {
    _Wherenode_8 = *(_QWORD *)(a1 + 0x18);
    _Wherenode_2 = *(__int64 **)_Wherenode_8;
    v4 = qword_149C8DFC0;
    if ( *(_QWORD *)_Wherenode_8 != _Wherenode_8 )
    {
      do
      {
        v5 = _Wherenode_2 + 4;
        _Wherenode_8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 0x118LL))(v4, _Wherenode_2[4]);
        v6 = (_BYTE *)_Wherenode_2[2];
        v7 = v6[0x19];
        if ( _Wherenode_8 )
        {
          if ( v7 )
          {
            for ( _Wherenode_8 = _Wherenode_2[1];
                  !*(_BYTE *)(_Wherenode_8 + 0x19);
                  _Wherenode_8 = *(_QWORD *)(_Wherenode_8 + 8) )
            {
              if ( _Wherenode_2 != *(__int64 **)(_Wherenode_8 + 0x10) )
                break;
              _Wherenode_2 = (__int64 *)_Wherenode_8;
            }
            _Wherenode_2 = (__int64 *)_Wherenode_8;
          }
          else
          {
            _Wherenode_9 = *(__int64 **)v6;
            _Wherenode_2 = (__int64 *)_Wherenode_2[2];
            if ( !*(_BYTE *)(*(_QWORD *)v6 + 0x19LL) )
            {
              do
              {
                _Wherenode_8 = *_Wherenode_9;
                _Wherenode_2 = _Wherenode_9;
                _Wherenode_9 = (__int64 *)_Wherenode_8;
              }
              while ( !*(_BYTE *)(_Wherenode_8 + 0x19) );
            }
          }
        }
        else
        {
          _Wherenode_1 = _Wherenode_2;
          if ( v7 )
          {
            for ( _Wherenode_3 = _Wherenode_2[1];
                  !*(_BYTE *)(_Wherenode_3 + 0x19);
                  _Wherenode_3 = *(_QWORD *)(_Wherenode_3 + 8) )
            {
              if ( _Wherenode_2 != *(__int64 **)(_Wherenode_3 + 0x10) )
                break;
              _Wherenode_2 = (__int64 *)_Wherenode_3;
            }
            _Wherenode_2 = (__int64 *)_Wherenode_3;
          }
          else
          {
            _Wherenode_4 = *(_QWORD *)v6;
            for ( _Wherenode_2 = (__int64 *)_Wherenode_2[2];
                  !*(_BYTE *)(_Wherenode_4 + 0x19);
                  _Wherenode_4 = *(_QWORD *)_Wherenode_4 )
            {
              _Wherenode_2 = (__int64 *)_Wherenode_4;
            }
          }
          _Wherenode_7 = *(__int64 **)(a1 + 0x28);
          _Wherenode_5 = _Wherenode_7;
          _Wherenode_10 = (__int64 *)_Wherenode_7[1];
          while ( !*((_BYTE *)_Wherenode_10 + 0x19) )
          {
            if ( (unsigned __int64)_Wherenode_10[4] >= *v5 )
            {
              _Wherenode_5 = _Wherenode_10;
              _Wherenode_10 = (__int64 *)*_Wherenode_10;
            }
            else
            {
              _Wherenode_10 = (__int64 *)_Wherenode_10[2];
            }
          }
          if ( !*((_BYTE *)_Wherenode_5 + 0x19)
            && *v5 >= (unsigned __int64)_Wherenode_5[4]
            && _Wherenode_5 != _Wherenode_7 )
          {
            v15 = (__int64 **)_Wherenode_5[2];
            _Wherenode = _Wherenode_5;
            if ( *((_BYTE *)v15 + 0x19) )
            {
              for ( _Wherenode_6 = (__int64 *)_Wherenode_5[1];
                    !*((_BYTE *)_Wherenode_6 + 0x19);
                    _Wherenode_6 = (__int64 *)_Wherenode_6[1] )
              {
                if ( _Wherenode_5 != (__int64 *)_Wherenode_6[2] )
                  break;
                _Wherenode_5 = _Wherenode_6;
              }
            }
            else
            {
              for ( i = *v15; !*((_BYTE *)i + 0x19); i = (__int64 *)*i )
                ;
            }
            v19 = sub_1402E2560((std::_Tree_val<std::_Tree_simple_types<int> > *)(a1 + 0x28), _Wherenode);
            sub_1402A6590((__int64)v19);
          }
          v20 = sub_1402E2560((std::_Tree_val<std::_Tree_simple_types<int> > *)(a1 + 0x18), _Wherenode_1);
          _Wherenode_8 = sub_1402A6590((__int64)v20);
        }
      }
      while ( _Wherenode_2 != *(__int64 **)(a1 + 0x18) );
    }
  }
  return _Wherenode_8;
}

// --- End Function: sub_14237CCF0 (0x14237CCF0) ---

// --- Function: sub_142382B50 (0x142382B50) ---
char __fastcall sub_142382B50(__int64 a1, const char **a2)
{
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  void **v8; // rcx
  __int64 v9; // rdx
  void **v10; // rcx
  const char *v11; // [rsp+40h] [rbp+8h] BYREF

  if ( (*(_BYTE *)(a1 + 0x28) & 1) == 0 )
  {
    if ( !*a2 )
    {
      sub_1405C6220(0xAu, 2u, "No level specified: not changing context");
      return 0;
    }
    v5 = sub_1426182E0(*(_QWORD *)(a1 + 0x10));
    if ( !(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v5 + 8LL))(v5, *a2) )
    {
      sub_1405C6220(0xAu, 2u, "Level %s not found", *a2);
      v6 = sub_1426182E0(*(_QWORD *)(a1 + 0x10));
      sub_142386E00(v6, *a2);
      return 0;
    }
    CreateStringObjectFromString((void **)&v11, a2[1]);
    v7 = sub_1426182E0(*(_QWORD *)(a1 + 0x10));
    if ( !(unsigned __int8)sub_142389720(v7, *a2, v11)
      && !(_BYTE)qword_149C8E516
      && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x388LL))(qword_149C8DFE0) )
    {
      sub_1405C6220(0xAu, 2u, "Level %s does not support %s game rules.", *a2, v11);
      sub_140373CC0(&v11);
      return 0;
    }
    sub_140373CC0(&v11);
  }
  if ( (*(_DWORD *)(a1 + 0x28) & 0x10) == 0 && !a2[1] )
  {
    sub_1405C6220(0xAu, 2u, "No rules specified: not changing context");
    return 0;
  }
  if ( a2 )
  {
    v8 = (void **)(a1 + 0x18);
    if ( *a2 )
      assignCStringToStringStructure((__int64)v8, (__int64)*a2);
    else
      sub_1403E8680(v8);
    v9 = (__int64)a2[1];
    v10 = (void **)(a1 + 0x20);
    if ( v9 )
    {
      assignCStringToStringStructure((__int64)v10, v9);
      return 1;
    }
    sub_1403E8680(v10);
  }
  return 1;
}

// --- End Function: sub_142382B50 (0x142382B50) ---

// --- Function: sub_142384210 (0x142384210) ---
__int64 __fastcall sub_142384210(__int64 a1, const char *String2)
{
  _QWORD *v2; // rax
  _QWORD *j; // rbx
  const char **v6; // rdi
  __int64 **v7; // rax
  __int64 i; // rax
  __int64 *v9; // rcx

  v2 = *(_QWORD **)(a1 + 0x38);
  j = (_QWORD *)*v2;
  if ( (_QWORD *)*v2 == v2 )
    return 0;
  while ( _stricmp((const char *)j[4], String2) )
  {
    v6 = (const char **)j[6];
    if ( v6 != (const char **)j[7] )
    {
      while ( _stricmp(*v6, String2) )
      {
        if ( ++v6 == (const char **)j[7] )
          goto LABEL_6;
      }
      return j[4];
    }
LABEL_6:
    v7 = (__int64 **)j[2];
    if ( *((_BYTE *)v7 + 0x19) )
    {
      for ( i = j[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
      {
        if ( j != *(_QWORD **)(i + 0x10) )
          break;
        j = (_QWORD *)i;
      }
      j = (_QWORD *)i;
    }
    else
    {
      v9 = *v7;
      for ( j = (_QWORD *)j[2]; !*((_BYTE *)v9 + 0x19); v9 = (__int64 *)*v9 )
        j = v9;
    }
    if ( j == *(_QWORD **)(a1 + 0x38) )
      return 0;
  }
  return j[4];
}

// --- End Function: sub_142384210 (0x142384210) ---

// --- Function: sub_142384310 (0x142384310) ---
// attributes: thunk
__int64 sub_142384310()
{
  return sub_142384320();
}

// --- End Function: sub_142384310 (0x142384310) ---

// --- Function: sub_142384320 (0x142384320) ---
__int64 __fastcall sub_142384320(__int64 a1, const char *String2_1)
{
  const char **v4; // rax
  int v5; // ebx
  unsigned __int64 v6; // rbx
  __int64 v8; // rax
  void **v9; // rax
  __int64 v10; // rbx
  char *String2; // [rsp+40h] [rbp+8h] BYREF
  void *v12; // [rsp+50h] [rbp+18h] BYREF
  __int64 v13; // [rsp+58h] [rbp+20h] BYREF

  if ( !_stricmp(*(const char **)(a1 + 0x18), String2_1) )
    return a1 + 0x10;
  CreateStringObjectFromString(&v12, *(const char **)(a1 + 0x18));
  v4 = (const char **)sub_1403B27D0(&v13, &v12);
  v5 = _stricmp(*v4, String2_1);
  sub_140373CC0(&v13);
  sub_140373CC0(&v12);
  if ( !v5 )
    return a1 + 0x10;
  CreateStringObjectFromString((void **)&String2, String2_1);
  v6 = sub_1403EA670((__int64 *)&String2, 0x5C, 0xFFFFFFFFFFFFFFFFuLL);
  if ( v6 == 0xFFFFFFFFFFFFFFFFuLL
    && (v6 = sub_1403EA670((__int64 *)&String2, 0x2F, 0xFFFFFFFFFFFFFFFFuLL), v6 == 0xFFFFFFFFFFFFFFFFuLL) )
  {
    sub_140373CC0(&String2);
    return 0;
  }
  else
  {
    v8 = sub_1403EBE30(&String2);
    v9 = sub_1403EF0C0((__int64 *)&String2, &v12, v6 + 1, v8 - v6 - 1);
    sub_14037AE80((void **)&String2, v9);
    sub_140373CC0(&v12);
    v10 = sub_142384320(a1, String2);
    sub_140373CC0(&String2);
    return v10;
  }
}

// --- End Function: sub_142384320 (0x142384320) ---

// --- Function: sub_142386E00 (0x142386E00) ---
__int64 __fastcall sub_142386E00(__int64 a1, __int64 a2)
{
  _QWORD *i; // rbx
  __int64 result; // rax

  for ( i = *(_QWORD **)(a1 + 0x70); i != *(_QWORD **)(a1 + 0x78); ++i )
    result = (*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)*i + 8LL))(*i, a2);
  return result;
}

// --- End Function: sub_142386E00 (0x142386E00) ---

// --- Function: sub_142389720 (0x142389720) ---
char __fastcall sub_142389720(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 v5; // r15
  size_t Size; // rdi
  __int64 v7; // rcx
  unsigned __int64 size; // rcx
  void *v9; // rsp
  void *v10; // rsp
  int v11; // edi
  __int64 (__fastcall ***v12)(_QWORD, __int128 *); // rax
  __int64 (__fastcall ***v13)(_QWORD); // rax
  __int64 (__fastcall ***v14)(_QWORD); // rcx
  __int64 (__fastcall **v15)(_QWORD); // rax
  __int64 v16; // rax
  __int64 v17; // rbx
  _QWORD *v18; // rdx
  __int64 v19; // rax
  __int128 v21; // [rsp+20h] [rbp+0h] BYREF
  __int128 v22; // [rsp+30h] [rbp+10h] BYREF
  _QWORD *v23; // [rsp+40h] [rbp+20h]
  __int128 v24; // [rsp+48h] [rbp+28h] BYREF
  __int64 v25; // [rsp+58h] [rbp+38h]

  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0);
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a3[Size] );
  v7 = Size + 0x19;
  if ( Size + 0x19 <= Size + 0xA )
    v7 = 0xFFFFFFFFFFFFFF0LL;
  size = v7 & 0xFFFFFFFFFFFFFFF0uLL;
  v9 = alloca(size);
  v10 = alloca(size);
  *(_QWORD *)&v21 = *(_QWORD *)"GameMode";
  BYTE8(v21) = 0x2E;
  memcpy((char *)&v21 + 9, a3, Size);
  *((_BYTE *)&v21 + Size + 9) = 0;
  *(_QWORD *)&v21 = &v21;
  sub_14035DDD0((_QWORD *)&v21 + 1, &v21);
  lookup_entry_in_hashtable((_QWORD *)(v5 + 0x40), &v22, (const char **)&v21 + 1);
  *((_QWORD *)&v21 + 1) = (char *)&qword_149C78E84 + 4;
  sub_140373CC0((_QWORD *)&v21 + 1);
  v11 = 0;
  if ( (_QWORD)v22 == *(_QWORD *)(v5 + 0x40) + *(_QWORD *)(v5 + 0x58) )
  {
    v21 = 0u;
    sub_14035EC10(&v24, &v21);
    if ( !qword_149C8DFE0
      || !(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0)
      || (v12 = (__int64 (__fastcall ***)(_QWORD, __int128 *))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0
                                                                                                 + 0x240LL))(qword_149C8DFE0),
          v13 = (__int64 (__fastcall ***)(_QWORD))(**v12)(v12, &v24),
          (v14 = v13) == 0) )
    {
      v16 = 0;
      goto LABEL_13;
    }
    v15 = *v13;
  }
  else
  {
    v17 = *((_QWORD *)&v22 + 1);
    sub_14035EC10(&v24, (_OWORD *)(*((_QWORD *)&v22 + 1) + 0x10LL));
    v14 = *(__int64 (__fastcall ****)(_QWORD))(v17 + 8);
    v15 = *v14;
  }
  v16 = (*v15)(v14);
LABEL_13:
  v25 = v16;
  if ( !v16 )
    return 0;
  sub_1404AE960(&v22, a2);
  if ( v23 && (v23[8] || v23[0xC]) && !sub_1402B7260(v23 + 6, &v24) )
  {
    v18 = v23;
    if ( v23[0xC] )
    {
      v19 = 0;
      while ( !sub_1402B7260((_QWORD *)(v18[0xB] + 0x18 * v19), &v24) )
      {
        v18 = v23;
        v19 = ++v11;
        if ( (unsigned __int64)v11 >= v23[0xC] )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

// --- End Function: sub_142389720 (0x142389720) ---

// --- Function: sub_142389F40 (0x142389F40) ---
void __fastcall sub_142389F40(__int64 *a1)
{
  __int64 v2; // rcx
  int v3; // eax

  v2 = *a1;
  if ( v2 )
  {
    v3 = _InterlockedDecrement((volatile signed __int32 *)(v2 + 8));
    if ( !v3 )
    {
      (**(void (__fastcall ***)(__int64, __int64))v2)(v2, 1);
      *a1 = 0;
      return;
    }
    if ( v3 < 0 )
      LogFatalError("Deleting Reference Counted Object Twice");
  }
  *a1 = 0;
}

// --- End Function: sub_142389F40 (0x142389F40) ---

// --- Function: sub_1423A3F10 (0x1423A3F10) ---
void __fastcall sub_1423A3F10(__int64 *a1, __int64 *a2, _DWORD *a3)
{
  __int64 v3; // rbx
  int v7; // edi
  unsigned int v8; // eax
  __int64 v9; // rcx
  __int64 v10; // rdi
  void (__fastcall *v11)(_DWORD *); // rax
  void (__fastcall *n2)(__int64, __int64); // rax
  int v13; // eax
  unsigned __int32 v14; // eax
  volatile signed __int32 *v15; // rbx
  volatile signed __int32 *v16; // rbx
  __int64 v17; // [rsp+50h] [rbp+8h]

  v3 = *a1;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v8 )
      sub_1403C6E80(v3, v8, (__int64)"future_detail::ResolveImpl", 1);
    else
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v3 + 0x10) = v7;
  }
  if ( !*(_BYTE *)(*a1 + 0x39) )
  {
    *(_BYTE *)(*a1 + 0x38) = 1;
    v9 = *a2;
    v10 = *a2 + 0xB0;
    if ( *(_QWORD *)v10 )
    {
      sub_1404D8EF0((_OWORD *)v9);
      v11 = *(void (__fastcall **)(_DWORD *))v10;
      if ( *(_QWORD *)(v10 + 8) == 1 )
        v11(a3);
      else
        ((void (__fastcall *)(__int64, _DWORD *))v11)(v10, a3);
      n2 = *(void (__fastcall **)(__int64, __int64))(v10 + 8);
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v10);
        *(_QWORD *)(v10 + 8) = 0;
      }
      *(_QWORD *)v10 = 0;
      sub_1404D5120();
    }
    else
    {
      LODWORD(v17) = *a3;
      BYTE4(v17) = 1;
      *(_QWORD *)(v9 + 0xC8) = v17;
    }
  }
  v13 = *(_DWORD *)(v3 + 0x14);
  if ( v13 )
  {
    *(_DWORD *)(v3 + 0x14) = v13 - 1;
  }
  else
  {
    *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
    v14 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 0, 1);
    if ( v14 == 1 )
      *(_QWORD *)(v3 + 8) = &p_Src;
    else
      sub_1403DF590(v3, v14);
  }
  v15 = (volatile signed __int32 *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  if ( v15 )
  {
    if ( _InterlockedExchangeAdd(v15 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
      if ( _InterlockedExchangeAdd(v15 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8LL))(v15);
    }
  }
  sub_1403C83B0((volatile signed __int32 *)(*a1 + 0x18));
  v16 = (volatile signed __int32 *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if ( v16 && _InterlockedExchangeAdd(v16 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v16)(v16);
    if ( _InterlockedExchangeAdd(v16 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v16 + 8LL))(v16);
  }
}

// --- End Function: sub_1423A3F10 (0x1423A3F10) ---

// --- Function: sub_1423AAE80 (0x1423AAE80) ---
char *__fastcall sub_1423AAE80(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdi
  __int64 v9; // rax
  _QWORD *v10; // rbx
  unsigned __int64 v11; // rcx
  _WORD *v12; // rax
  _QWORD *v13; // r8
  char *result; // rax

  if ( a2 > 0x555555555555555LL )
    unknown_libname_10();
  v4 = (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) / 0x30LL;
  v5 = (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) / 0x30LL;
  v6 = v5 >> 1;
  if ( v5 > 0x555555555555555LL - (v5 >> 1) )
    goto LABEL_24;
  v7 = v6 + v5;
  if ( v6 + v5 >= a2 )
  {
    if ( v7 > 0x555555555555555LL )
      goto LABEL_24;
  }
  else
  {
    v7 = a2;
  }
  v8 = 0x30 * v7;
  if ( 0x30 * v7 < 0x1000 )
  {
    if ( v8 )
      v10 = (_QWORD *)sub_1402A65A0(0x30 * v7);
    else
      v10 = 0;
    goto LABEL_13;
  }
  if ( v8 + 0x27 < v8 )
LABEL_24:
    sub_1402E3880();
  v9 = sub_1402A65A0(v8 + 0x27);
  if ( !v9 )
    goto LABEL_22;
  v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v10[0xFFFFFFFF] = v9;
LABEL_13:
  v11 = a2 - v4;
  if ( a2 != v4 )
  {
    v12 = &v10[6 * v4 + 5];
    do
    {
      *v12 = 0x8000;
      v12 += 0x18;
      --v11;
    }
    while ( v11 );
  }
  memmove(v10, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v13 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( (unsigned __int64)(0x30 * ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v13) / 0x30LL)) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590((__int64)v13);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v13 - v13[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v13 = (_QWORD *)v13[0xFFFFFFFF];
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = &v10[6 * a2];
  result = (char *)&v10[v8 / 8];
  *(_QWORD *)(a1 + 0x10) = &v10[v8 / 8];
  return result;
}

// --- End Function: sub_1423AAE80 (0x1423AAE80) ---

// --- Function: sub_1423C48B0 (0x1423C48B0) ---
__int64 __fastcall sub_1423C48B0(__int64 a1, __int64 a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 0x10) = *(_OWORD *)(a2 + 0x10);
  *(_OWORD *)(a1 + 0x20) = *(_OWORD *)(a2 + 0x20);
  *(_OWORD *)(a1 + 0x30) = *(_OWORD *)(a2 + 0x30);
  *(_OWORD *)(a1 + 0x40) = *(_OWORD *)(a2 + 0x40);
  *(_OWORD *)(a1 + 0x50) = *(_OWORD *)(a2 + 0x50);
  *(_OWORD *)(a1 + 0x60) = *(_OWORD *)(a2 + 0x60);
  *(_OWORD *)(a1 + 0x70) = *(_OWORD *)(a2 + 0x70);
  *(_OWORD *)(a1 + 0x80) = *(_OWORD *)(a2 + 0x80);
  *(_OWORD *)(a1 + 0x90) = *(_OWORD *)(a2 + 0x90);
  *(_OWORD *)(a1 + 0xA0) = *(_OWORD *)(a2 + 0xA0);
  sub_14035DE10((void **)(a1 + 0xB0), (const void **)(a2 + 0xB0));
  *(_DWORD *)(a1 + 0xB8) = *(_DWORD *)(a2 + 0xB8);
  *(_BYTE *)(a1 + 0xBC) = *(_BYTE *)(a2 + 0xBC);
  return a1;
}

// --- End Function: sub_1423C48B0 (0x1423C48B0) ---

// --- Function: sub_1423C9640 (0x1423C9640) ---
__int64 __fastcall sub_1423C9640(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 result; // rax
  __int64 v8; // r8
  __int64 v9; // rcx

  v1 = a1[0xD];
  if ( v1 )
  {
    do
      a1[0xD] = --v1;
    while ( v1 );
    a1[0xC] = 0;
  }
  if ( a1[0xA] )
  {
    v3 = a1[0xB];
    while ( v3 )
    {
      --v3;
      v4 = *(_QWORD *)(a1[0xA] + 8 * v3);
      if ( v4 )
        sub_1402A6590(v4);
    }
    v5 = a1[0xA];
    if ( (unsigned __int64)(8 * a1[0xB]) >= 0x1000 )
    {
      if ( (unsigned __int64)(v5 - *(_QWORD *)(v5 - 8) - 8) > 0x1F )
        goto LABEL_23;
      v5 = *(_QWORD *)(v5 - 8);
    }
    sub_1402A6590(v5);
  }
  v6 = a1[9];
  a1[9] = 0;
  a1[0xB] = 0;
  a1[0xA] = 0;
  sub_1402A6590(v6);
  result = sub_142453DE0(a1);
  v8 = a1[6];
  if ( v8 )
  {
    if ( (unsigned __int64)(0x30 * ((a1[8] - v8) / 0x30)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v8 - *(_QWORD *)(v8 - 8) - 8) > 0x1F )
        goto LABEL_23;
      v8 = *(_QWORD *)(v8 - 8);
    }
    result = sub_1402A6590(v8);
    a1[6] = 0;
    a1[7] = 0;
    a1[8] = 0;
  }
  v9 = *a1;
  if ( !*a1 )
    return result;
  if ( (unsigned __int64)(2 * ((a1[2] - v9) >> 1)) >= 0x1000 )
  {
    if ( (unsigned __int64)(v9 - *(_QWORD *)(v9 - 8) - 8) <= 0x1F )
    {
      v9 = *(_QWORD *)(v9 - 8);
      goto LABEL_22;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  result = sub_1402A6590(v9);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return result;
}

// --- End Function: sub_1423C9640 (0x1423C9640) ---

// --- Function: sub_142432A30 (0x142432BA3) ---
__int64 __fastcall sub_142432A30(__int64 a1, __int128 *a2, unsigned __int16 *a3)
{
  int v6; // r14d
  unsigned int v7; // eax
  __int64 v8; // rcx
  unsigned __int64 *v9; // rcx
  int v10; // eax
  unsigned __int32 v11; // eax
  int v12; // ebx
  int *ThreadLogContextSlot; // rax
  int n0x6400; // [rsp+50h] [rbp-89h] BYREF
  __int64 v16; // [rsp+54h] [rbp-85h]
  int v17; // [rsp+5Ch] [rbp-7Dh]
  unsigned __int64 v18; // [rsp+60h] [rbp-79h]
  unsigned __int64 v19; // [rsp+68h] [rbp-71h]
  __int64 v20; // [rsp+70h] [rbp-69h]
  __int64 v21; // [rsp+78h] [rbp-61h]
  _QWORD v22[2]; // [rsp+A0h] [rbp-39h] BYREF
  _QWORD v23[2]; // [rsp+B0h] [rbp-29h] BYREF
  __int128 v24; // [rsp+C0h] [rbp-19h] BYREF
  __int128 v25; // [rsp+D0h] [rbp-9h] BYREF
  unsigned __int64 v26; // [rsp+E0h] [rbp+7h] BYREF
  int n0x8A; // [rsp+E8h] [rbp+Fh]
  _BYTE v28[4]; // [rsp+ECh] [rbp+13h] BYREF

  n0x6400 = 0x6400;
  v17 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v16 = 1;
  v18 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_149F0991C,
    "CEntityComponentNetwork::RecvRemoteMethodCall",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Network/EntityComponentNetwork.cpp",
    0x109);
  HIWORD(n0x6400) = word_149F0991C;
  if ( *(_QWORD *)(a1 + 0x98) && (v26 = *(_QWORD *)(a1 + 8), is_entity_descriptor_valid_or_accessible(&v26)) )
  {
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x80) == v6 )
    {
      ++*(_DWORD *)(a1 + 0x84);
    }
    else
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x70), 1, 0);
      if ( v7 )
        sub_1403C6E80(a1 + 0x70, v7, (__int64)"CEntityComponentNetwork::RecvRemoteMethodCall", 1);
      else
        *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x80) = v6;
    }
    if ( *(_DWORD *)(a1 + 0xA0) != 1
      || (is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8))
        ? (v8 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
        : (v8 = 0),
          (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x58LL))(v8)) )
    {
      sub_14225A120(*(_QWORD *)(a1 + 0x98), a3[8]);
    }
    else
    {
      v9 = *(unsigned __int64 **)(a1 + 0x98);
      v24 = *a2;
      sub_1422BC170(v9, (__int64)&v24, a3);
    }
    v10 = *(_DWORD *)(a1 + 0x84);
    if ( v10 )
    {
      *(_DWORD *)(a1 + 0x84) = v10 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x80) = 0xFFFFFFFF;
      v11 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x70), 0, 1);
      if ( v11 == 1 )
        *(_QWORD *)(a1 + 0x78) = &p_Src;
      else
        sub_1403DF590(a1 + 0x70, v11);
    }
  }
  else
  {
    v26 = 0x67000000D6LL;
    v22[0] = &v26;
    v22[1] = v28;
    n0x8A = 0x8A;
    v12 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v22,
            (__int64)"Received Remote Method Wrong EntityId",
            "Remote method dispatch to incorrect network component");
    if ( (v12 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot = getThreadLogContextSlot();
      v23[0] = &v26;
      v23[1] = v28;
      v26 = 0x67000000D6LL;
      v25 = 0;
      n0x8A = 0x8A;
      sub_140354250(
        2,
        (__int64)v23,
        "Received Remote Method Wrong EntityId",
        (__int64)"Remote method dispatch to incorrect network component",
        1,
        v12,
        &v25,
        0,
        (__int64)ThreadLogContextSlot);
    }
  }
  v19 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_142432A30 (0x142432BA3) ---

// --- Function: sub_14244C930 (0x14244C930) ---
__int64 __fastcall sub_14244C930(__int64 a1)
{
  return sub_14260F030(a1 + 0x10);
}

// --- End Function: sub_14244C930 (0x14244C930) ---

// --- Function: sub_142453DE0 (0x142453DE0) ---
char *__fastcall sub_142453DE0(__int64 a1)
{
  __int64 *v2; // r14
  unsigned __int64 v3; // rbp
  unsigned __int64 v4; // rbx
  __int64 v5; // r15
  __int64 v6; // rsi
  void (__fastcall *n2)(__int64, __int64); // rax
  _BYTE *v8; // rdx
  __int64 v9; // rax
  __int64 v10; // r9
  __int64 v11; // r10
  __int64 v12; // kr00_8
  char *result; // rax
  unsigned __int64 v14; // rcx
  __int64 v15; // r8
  unsigned __int64 i; // rbx
  __int16 v17; // [rsp+50h] [rbp+8h] BYREF

  if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  v2 = (__int64 *)(a1 + 0x30);
  v3 = 0;
  v4 = (*(_QWORD *)(a1 + 0x38) - *(_QWORD *)(a1 + 0x30)) / 0x30LL;
  if ( v4 )
  {
    v5 = 0;
    do
    {
      v6 = v5 + *v2;
      if ( *(__int16 *)(v6 + 0x28) >= 0 )
      {
        n2 = *(void (__fastcall **)(__int64, __int64))(v6 + 0x10);
        if ( (unsigned __int64)n2 >= 2 )
        {
          n2(2, v6 + 8);
          *(_QWORD *)(v6 + 0x10) = 0;
        }
        *(_QWORD *)(v6 + 8) = 0;
      }
      v8 = *(_BYTE **)(a1 + 8);
      v17 = v4 - v3 - 1;
      if ( v8 == *(_BYTE **)(a1 + 0x10) )
      {
        sub_140347770((const void **)a1, v8, &v17);
      }
      else
      {
        *(_WORD *)v8 = v4 - v3 - 1;
        *(_QWORD *)(a1 + 8) += 2LL;
      }
      ++v3;
      v5 += 0x30;
    }
    while ( v3 < v4 );
  }
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  v9 = *v2;
  v10 = v2[1];
  if ( *v2 != v10 )
  {
    v2[1] = v9;
    v10 = v9;
  }
  v11 = v9;
  v12 = v10 - v9;
  result = (char *)((unsigned __int64)((unsigned __int128)((v10 - v9) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F);
  v14 = v12 / 0x30;
  if ( v4 >= v12 / 0x30 )
  {
    if ( v4 > v14 )
    {
      v15 = v2[2] - v11;
      result = (char *)((unsigned __int64)((unsigned __int128)(v15 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F);
      if ( v4 <= v15 / 0x30 )
      {
        for ( i = v4 - v14; i; --i )
        {
          *(_WORD *)(v10 + 0x28) = 0x8000;
          v10 += 0x30;
        }
        v2[1] = v10;
      }
      else
      {
        return sub_1423AAE80((__int64)v2, v4);
      }
    }
  }
  else
  {
    result = (char *)(v11 + 0x30 * v4);
    v2[1] = (__int64)result;
  }
  return result;
}

// --- End Function: sub_142453DE0 (0x142453DE0) ---

// --- Function: sub_1424BC8F0 (0x1424BC8F0) ---
_DWORD *__fastcall sub_1424BC8F0(__int64 a1, unsigned __int64 *a2)
{
  __int64 *v4; // rsi
  __int64 v5; // r15
  __int64 v6; // rcx
  __int64 v7; // rax
  const char *v8; // rax
  __int64 inserted; // rdi
  __int64 v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // rsi
  __int128 v13; // xmm0
  __int64 **v14; // rcx
  __int64 v15; // rcx
  unsigned __int64 v16; // rbx
  __int64 (__fastcall *v17)(unsigned __int64, char *, unsigned __int64 *); // rdi
  __int16 n0xFFFF; // ax
  unsigned __int64 v19; // rbx
  __int64 v20; // rax
  __int16 n4; // cx
  __int64 v22; // rcx
  _DWORD *result; // rax
  unsigned __int64 v24; // rbx
  __int64 v25; // rax
  __int16 n4_1; // cx
  __int128 v27; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 v28; // [rsp+90h] [rbp+48h] BYREF
  __int64 **v29; // [rsp+98h] [rbp+50h] BYREF
  unsigned __int64 v30; // [rsp+A0h] [rbp+58h] BYREF
  char v31; // [rsp+A8h] [rbp+60h] BYREF

  ++**(_DWORD **)a1;
  v4 = *(__int64 **)(a1 + 8);
  v29 = (__int64 **)v4;
  v5 = 0;
  if ( is_entity_descriptor_valid_or_accessible(a2 + 1) )
    v6 = a2[1] & 0xFFFFFFFFFFFFLL;
  else
    v6 = 0;
  v7 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x20LL))(v6, 0xFFFFFFFFFFFFLL);
  v8 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x18LL))(v7);
  CreateStringObjectFromString((void **)&v28, v8);
  inserted = *v4;
  DWORD2(v27) = 0;
  v10 = *(_QWORD *)(inserted + 8);
  *(_QWORD *)&v27 = v10;
  while ( !*(_BYTE *)(v10 + 0x19) )
  {
    *(_QWORD *)&v27 = v10;
    if ( (int)sub_1403E8B60((unsigned __int8 **)(v10 + 0x20), &v28) >= 0 )
    {
      inserted = v10;
      DWORD2(v27) = 1;
      v10 = *(_QWORD *)v10;
    }
    else
    {
      v10 = *(_QWORD *)(v10 + 0x10);
      DWORD2(v27) = 0;
    }
  }
  if ( *(_BYTE *)(inserted + 0x19) || (int)sub_1403E8B60((unsigned __int8 **)&v28, (_QWORD *)(inserted + 0x20)) < 0 )
  {
    if ( v4[1] == 0x555555555555555LL )
      unknown_libname_7();
    v11 = *v4;
    v12 = sub_1402A65A0(0x30u);
    sub_14035DDF0((_QWORD *)(v12 + 0x20), (__int64 *)&v28);
    v13 = v27;
    v14 = v29;
    *(_DWORD *)(v12 + 0x28) = 0;
    *(_QWORD *)v12 = v11;
    *(_QWORD *)(v12 + 8) = v11;
    *(_QWORD *)(v12 + 0x10) = v11;
    *(_WORD *)(v12 + 0x18) = 0;
    v27 = v13;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 v14,
                 (__int64)&v27,
                 v12);
  }
  ++*(_DWORD *)(inserted + 0x28);
  sub_140373CC0(&v28);
  if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64 *))(*a2 + 0x6E0))(a2) )
    ++**(_DWORD **)(a1 + 0x10);
  if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64 *))(*a2 + 0x8F8))(a2) )
    ++**(_DWORD **)(a1 + 0x18);
  if ( is_entity_descriptor_valid_or_accessible(a2 + 1) )
    v15 = a2[1] & 0xFFFFFFFFFFFFLL;
  else
    v15 = 0;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v15 + 0x628LL))(
         v15,
         *(_QWORD *)(a1 + 0x20),
         0) )
  {
    ++**(_DWORD **)(a1 + 0x28);
  }
  v30 = a2[1];
  if ( is_entity_descriptor_valid_or_accessible(&v30) )
  {
    v16 = v30 & 0xFFFFFFFFFFFFLL;
    v17 = *(__int64 (__fastcall **)(unsigned __int64, char *, unsigned __int64 *))(*(_QWORD *)(v30 & 0xFFFFFFFFFFFFLL)
                                                                                 + 0x340LL);
    n0xFFFF = n0xFFFF_19;
    if ( n0xFFFF_19 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 ***, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                        + 0x10LL))(
                            qword_149C8DFC8,
                            &v29,
                            "ISCItemPurchasable");
      n0xFFFF_19 = n0xFFFF;
    }
    LOWORD(v28) = n0xFFFF;
    v19 = *(_QWORD *)v17(v16, &v31, &v28);
    v28 = v19;
    if ( v19 )
    {
      v20 = sub_1403B84E0(v19 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v20 + 4);
      if ( n4 != 4
        && *(_WORD *)(v20 + 2) == (HIWORD(v19) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140395350(&v28)) )
      {
        if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v19 & 0xFFFFFFFFFFFFLL) + 0x570LL))(v19 & 0xFFFFFFFFFFFFLL) )
          ++**(_DWORD **)(a1 + 0x30);
      }
    }
  }
  if ( is_entity_descriptor_valid_or_accessible(a2 + 1) )
    v22 = a2[1] & 0xFFFFFFFFFFFFLL;
  else
    v22 = 0;
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x60LL))(v22) )
    ++**(_DWORD **)(a1 + 0x38);
  if ( is_entity_descriptor_valid_or_accessible(a2 + 1) )
    v5 = a2[1] & 0xFFFFFFFFFFFFLL;
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x58LL))(v5) )
    ++**(_DWORD **)(a1 + 0x40);
  if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64 *))(*a2 + 0x7B8))(a2) )
  {
    ++**(_DWORD **)(a1 + 0x48);
    result = (_DWORD *)(*(__int64 (__fastcall **)(unsigned __int64 *))(*a2 + 0x8F8))(a2);
    if ( !(_BYTE)result )
      return result;
    result = *(_DWORD **)(a1 + 0x50);
  }
  else
  {
    (*(void (__fastcall **)(unsigned __int64 *, unsigned __int64 *))(*a2 + 0x7F8))(a2, &v28);
    if ( v28
      && (v24 = HIWORD(v28), v25 = sub_1403B84E0(v28 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v25 + 4), n4_1 != 4)
      && *(_WORD *)(v25 + 2) == (v24 & 0xFFF)
      && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140395350(&v28)) )
    {
      if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v28 & 0xFFFFFFFFFFFFLL) + 0x650LL))(v28 & 0xFFFFFFFFFFFFLL) )
        result = *(_DWORD **)(a1 + 0x58);
      else
        result = *(_DWORD **)(a1 + 0x60);
    }
    else
    {
      result = *(_DWORD **)(a1 + 0x68);
    }
  }
  ++*result;
  return result;
}

// --- End Function: sub_1424BC8F0 (0x1424BC8F0) ---

// --- Function: sub_1424BEBA0 (0x1424BEBA0) ---
_DWORD *__fastcall sub_1424BEBA0(__int64 a1, unsigned __int64 *a2)
{
  return sub_1424BC8F0(*(_QWORD *)(a1 + 0x10), a2);
}

// --- End Function: sub_1424BEBA0 (0x1424BEBA0) ---

// --- Function: sub_1424BEF20 (0x1424BEF20) ---
void __fastcall sub_1424BEF20(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( !a1 )
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
        __asm { vzeroupper }
        return;
      }
      v6 = sub_1402A65A0(0x70u);
      v7 = v6;
      if ( v6 )
      {
        *(__m256i *)v6 = *(__m256i *)v5;
        *(__m256i *)(v6 + 0x20) = *(__m256i *)(v5 + 0x20);
        *(__m256i *)(v6 + 0x40) = *(__m256i *)(v5 + 0x40);
        *(_OWORD *)(v6 + 0x60) = *(_OWORD *)(v5 + 0x60);
      }
      else
      {
        v7 = 0;
      }
      a2[2] = v7;
      *a2 = sub_1424BEBA0;
      a2[1] = sub_1424BEF20;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      sub_1402A6590(a2[2]);
      a2[2] = 0;
      *a2 = 0;
      a2[1] = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == 1 )
  {
    a2[2] = 0;
    *a2 = *a3;
    a2[1] = 1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    a2[2] = a3[2];
    *a2 = *a3;
    a2[1] = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_1424BEF20 (0x1424BEF20) ---

// --- Function: sub_1424C0CD0 (0x1424C0CD0) ---
int *__fastcall sub_1424C0CD0(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  _QWORD **v5; // rdi
  _QWORD *j; // rbx
  __int64 v7; // rsi
  void (__fastcall *v8)(_QWORD); // rax
  __int64 **v9; // rax
  __int64 i; // rax
  __int64 *v11; // rcx
  int *result; // rax
  _QWORD **v13; // [rsp+30h] [rbp-38h]
  __int64 p_rw_lock_state; // [rsp+38h] [rbp-30h]
  int v15; // [rsp+48h] [rbp-20h] BYREF

  v13 = (_QWORD **)(a1 + 8);
  v3 = a1 + 0x18;
  p_rw_lock_state = a1 + 0x18;
  v15 = 1;
  if ( *(_DWORD *)(a1 + 0x28) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v4 = _InterlockedIncrement64((volatile signed __int64 *)v3);
    if ( (v4 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v3, v4, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  v5 = (_QWORD **)*v13;
  j = (_QWORD *)**v13;
  if ( j != *v13 )
  {
    do
    {
      v7 = j[5];
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(v7 + 8))
        && (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFLL) != 0 )
      {
        v8 = *(void (__fastcall **)(_QWORD))a2;
        if ( *(_QWORD *)(a2 + 8) == 1 )
          v8(j[5]);
        else
          ((void (__fastcall *)(__int64, _QWORD))v8)(a2, j[5]);
      }
      v9 = (__int64 **)j[2];
      if ( *((_BYTE *)v9 + 0x19) )
      {
        for ( i = j[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
        {
          if ( j != *(_QWORD **)(i + 0x10) )
            break;
          j = (_QWORD *)i;
        }
        j = (_QWORD *)i;
      }
      else
      {
        v11 = *v9;
        for ( j = (_QWORD *)j[2]; !*((_BYTE *)v11 + 0x19); v11 = (__int64 *)*v11 )
          j = v11;
      }
    }
    while ( j != v5 );
  }
  result = &v15;
  if ( !--v15 )
    return (int *)rw_lock_release_read_lock(p_rw_lock_state);
  return result;
}

// --- End Function: sub_1424C0CD0 (0x1424C0CD0) ---

// --- Function: sub_1424C3170 (0x1424C3170) ---
__int64 __fastcall sub_1424C3170(__int64 a1, _DWORD *a2)
{
  __int64 v4; // rax
  _QWORD *v5; // rax
  __int64 *v6; // rbx
  __int64 v7; // r8
  __int64 v8; // rcx
  __int64 v9; // rdi
  __int64 v10; // rbx
  int v12; // [rsp+20h] [rbp-60h] BYREF
  int v13; // [rsp+24h] [rbp-5Ch] BYREF
  int v14; // [rsp+28h] [rbp-58h] BYREF
  int v15; // [rsp+2Ch] [rbp-54h] BYREF
  int v16; // [rsp+30h] [rbp-50h] BYREF
  int v17; // [rsp+34h] [rbp-4Ch] BYREF
  int v18; // [rsp+38h] [rbp-48h] BYREF
  int v19; // [rsp+3Ch] [rbp-44h] BYREF
  int v20; // [rsp+40h] [rbp-40h] BYREF
  int v21; // [rsp+44h] [rbp-3Ch] BYREF
  __int64 v22; // [rsp+48h] [rbp-38h] BYREF
  __int64 v23; // [rsp+50h] [rbp-30h]
  _DWORD *(__fastcall *p_sub_1424BEBA0)(__int64, unsigned __int64 *); // [rsp+58h] [rbp-28h] BYREF
  void (__fastcall *p_sub_1424BEF20)(__int64, _DWORD *(__fastcall **)(__int64, unsigned __int64 *)); // [rsp+60h] [rbp-20h]
  _QWORD *v26; // [rsp+68h] [rbp-18h]
  _BYTE v27[16]; // [rsp+70h] [rbp-10h] BYREF
  int v28; // [rsp+B0h] [rbp+30h] BYREF
  int v29; // [rsp+B8h] [rbp+38h] BYREF

  v28 = 0;
  v29 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v23 = 0;
  v4 = sub_1402A65A0(0x30u);
  *(_QWORD *)v4 = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)(v4 + 0x10) = v4;
  *(_WORD *)(v4 + 0x18) = 0x101;
  v22 = v4;
  (*(void (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DF38 + 0x28LL))(
    qword_149C8DF38,
    v27,
    "Engine.SpawningManager.SpawnedEntity");
  v5 = (_QWORD *)sub_1402A65A0(0x70u);
  if ( v5 )
  {
    *v5 = &v28;
    v5[1] = &v22;
    v5[2] = &v29;
    v5[3] = &v19;
    v5[4] = v27;
    v5[5] = &v20;
    v5[6] = &v21;
    v5[7] = &v18;
    v5[8] = &v17;
    v5[9] = &v15;
    v5[0xA] = &v16;
    v5[0xB] = &v12;
    v5[0xC] = &v13;
    v5[0xD] = &v14;
    v26 = v5;
  }
  else
  {
    v26 = 0;
  }
  p_sub_1424BEBA0 = sub_1424BEBA0;
  p_sub_1424BEF20 = (void (__fastcall *)(__int64, _DWORD *(__fastcall **)(__int64, unsigned __int64 *)))sub_1424BEF20;
  sub_1424C0CD0(a1, (__int64)&p_sub_1424BEBA0);
  if ( (unsigned __int64)p_sub_1424BEF20 >= 2 )
    p_sub_1424BEF20(2, &p_sub_1424BEBA0);
  *a2 = v28;
  a2[1] = v29;
  a2[2] = v12;
  a2[3] = v13;
  a2[4] = v14;
  a2[5] = v15;
  a2[6] = v16;
  a2[7] = v17;
  a2[8] = v18;
  a2[9] = v19;
  a2[0xA] = v20;
  a2[0xB] = v21;
  v6 = (__int64 *)(a2 + 0xE);
  if ( v6 == &v22 )
  {
    v7 = v22;
  }
  else
  {
    v7 = *v6;
    v8 = v6[1];
    *v6 = v22;
    v6[1] = v23;
    v22 = v7;
    v23 = v8;
  }
  v9 = *(_QWORD *)(v7 + 8);
  if ( !*(_BYTE *)(v9 + 0x19) )
  {
    do
    {
      sub_1409A6A30((__int64)&v22, (__int64)&v22, *(_QWORD *)(v9 + 0x10));
      v10 = v9;
      v9 = *(_QWORD *)v9;
      sub_140373CC0((_QWORD *)(v10 + 0x20));
      sub_1402A6590(v10);
    }
    while ( !*(_BYTE *)(v9 + 0x19) );
    v7 = v22;
  }
  return sub_1402A6590(v7);
}

// --- End Function: sub_1424C3170 (0x1424C3170) ---

// --- Function: sub_1424C66F0 (0x1424C66F0) ---
void __fastcall sub_1424C66F0(__int64 a1)
{
  _QWORD *v4; // rax
  __int64 v7; // r15
  _QWORD *v8; // rax
  void (__fastcall *v9)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v10)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v11)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v12)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v13)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v14)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v15)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v16)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v17)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v18)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v19)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v20)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v21)(__int64, void *, _QWORD); // rbx
  __int64 *j; // rbx
  unsigned int v23; // esi
  void (__fastcall *v24)(__int64, void *, _QWORD); // r14
  __int64 **v25; // rax
  __int64 *i; // rax
  __int64 *v27; // rcx
  __int64 v28; // [rsp+20h] [rbp-49h] BYREF
  __int64 v29; // [rsp+28h] [rbp-41h]
  __int64 v30; // [rsp+30h] [rbp-39h]
  __int64 v31; // [rsp+38h] [rbp-31h]
  __int64 v32; // [rsp+40h] [rbp-29h]
  __int64 v33; // [rsp+48h] [rbp-21h]
  unsigned int v34; // [rsp+50h] [rbp-19h]
  __int64 **v35; // [rsp+58h] [rbp-11h] BYREF
  __int64 v36; // [rsp+60h] [rbp-9h]
  void *v37; // [rsp+70h] [rbp+7h] BYREF
  __int64 v38; // [rsp+78h] [rbp+Fh] BYREF
  __int64 v39; // [rsp+80h] [rbp+17h] BYREF
  __int64 v40; // [rsp+88h] [rbp+1Fh] BYREF
  const void *v41; // [rsp+E0h] [rbp+77h] BYREF
  void *v42; // [rsp+E8h] [rbp+7Fh] BYREF

  if ( (dword_149F0A918 & 1) == 0 )
  {
    dword_149F0A918 |= 1u;
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
      qword_149C8DF80,
      &qword_149F0A910);
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v38);
  sub_14059CA60(&v38, &v41, &qword_149F0A910);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  if ( *(float *)&_XMM1 > 2.0 )
  {
    qword_149F0A910 = v38;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v36 = 0;
    v4 = (_QWORD *)sub_1402A65A0(0x30u);
    *v4 = v4;
    v4[1] = v4;
    v4[2] = v4;
    *((_WORD *)v4 + 0xC) = 0x101;
    v35 = (__int64 **)v4;
    sub_1424C3170(a1, &v28);
    qword_149C89AF8((unsigned int)v28, &unk_149F0A91C, "CryAction/VehSystem / 0_Total_Vehicles");
    qword_149C89AF8(HIDWORD(v28), &unk_149F0A920, "CryAction/VehSystem / 1_Num_Ships");
    qword_149C89AF8((unsigned int)v29, &unk_149F0A924, "CryAction/VehSystem / 2_Num_Other");
    qword_149C89AF8(HIDWORD(v29), &unk_149F0A928, "CryAction/VehSystem / 3_AI_Drivers");
    qword_149C89AF8((unsigned int)v30, &unk_149F0A92C, "CryAction/VehSystem / 4_NO_Drivers");
    qword_149C89AF8(HIDWORD(v30), &unk_149F0A930, "CryAction/VehSystem / 5_Destroyed");
    qword_149C89AF8((unsigned int)v31, &unk_149F0A934, "CryAction/VehSystem / 6_Destroyed_Selector_Spawned");
    qword_149C89AF8(HIDWORD(v31), &unk_149F0A938, "CryAction/VehSystem / 7_Removing");
    sub_1409A6A30((__int64)&v35, (__int64)&v35, (__int64)v35[1]);
    sub_1402A6590((__int64)v35);
  }
  if ( BYTE1(qword_149C8E516) && qword_149C8E050 )
  {
    if ( (dword_149F0A918 & 2) == 0 )
    {
      dword_149F0A918 |= 2u;
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
        qword_149C8DF80,
        &qword_149F0A940);
    }
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v39);
    sub_14059CA60(&v39, &v40, &qword_149F0A940);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    if ( *(float *)&_XMM1 > 60.0 )
    {
      qword_149F0A940 = v39;
      v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E050 + 0xA8LL))(qword_149C8E050);
      if ( v7 )
      {
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v31 = 0;
        v32 = 0;
        v33 = 0;
        v34 = 0;
        v36 = 0;
        v8 = (_QWORD *)sub_1402A65A0(0x30u);
        *v8 = v8;
        v8[1] = v8;
        v8[2] = v8;
        *((_WORD *)v8 + 0xC) = 0x101;
        v35 = (__int64 **)v8;
        sub_1424C3170(a1, &v28);
        sub_14035E090(&v41);
        (*(void (__fastcall **)(__int64, const void **))(*(_QWORD *)v7 + 0x20LL))(v7, &v41);
        v9 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.total");
        v9(v7, v42, (unsigned int)v28);
        sub_140373CC0(&v42);
        v10 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.ships");
        v10(v7, v42, HIDWORD(v28));
        sub_140373CC0(&v42);
        v11 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.player");
        v11(v7, v42, (unsigned int)v29);
        sub_140373CC0(&v42);
        v12 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.ai");
        v12(v7, v42, HIDWORD(v29));
        sub_140373CC0(&v42);
        v13 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.no_driver");
        v13(v7, v42, (unsigned int)v30);
        sub_140373CC0(&v42);
        v14 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.destroyed");
        v14(v7, v42, HIDWORD(v30));
        sub_140373CC0(&v42);
        v15 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.destroyedselectorspawned");
        v15(v7, v42, (unsigned int)v31);
        sub_140373CC0(&v42);
        v16 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.removing");
        v16(v7, v42, HIDWORD(v31));
        sub_140373CC0(&v42);
        v17 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.garbage");
        v17(v7, v42, (unsigned int)v32);
        sub_140373CC0(&v42);
        v18 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.selectorspawned");
        v18(v7, v42, HIDWORD(v32));
        sub_140373CC0(&v42);
        v19 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.missionSpawned");
        v19(v7, v42, (unsigned int)v33);
        sub_140373CC0(&v42);
        v20 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.shopspawned");
        v20(v7, v42, HIDWORD(v33));
        sub_140373CC0(&v42);
        v21 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
        sub_14035DE10(&v42, &v41);
        sub_140387CB0((__int64)&v42, (__int64)"vehicles.bedLoggingOut");
        v21(v7, v42, v34);
        sub_140373CC0(&v42);
        j = *v35;
        while ( !*((_BYTE *)j + 0x19) )
        {
          v23 = *((_DWORD *)j + 0xA);
          v24 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v7 + 8LL);
          sub_14035DE10(&v37, &v41);
          sub_140387CB0((__int64)&v37, (__int64)"vehicles.by_class.");
          sub_14035DE10(&v42, (const void **)&v37);
          sub_140387C60((__int64)&v42, j + 4);
          v24(v7, v42, v23);
          sub_140373CC0(&v42);
          sub_140373CC0(&v37);
          v25 = (__int64 **)j[2];
          if ( *((_BYTE *)v25 + 0x19) )
          {
            for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
            {
              if ( j != (__int64 *)i[2] )
                break;
              j = i;
            }
            j = i;
          }
          else
          {
            v27 = *v25;
            for ( j = (__int64 *)j[2]; !*((_BYTE *)v27 + 0x19); v27 = (__int64 *)*v27 )
              j = v27;
          }
        }
        sub_140373CC0(&v41);
        sub_1409A6A30((__int64)&v35, (__int64)&v35, (__int64)v35[1]);
        sub_1402A6590((__int64)v35);
      }
    }
  }
}

// --- End Function: sub_1424C66F0 (0x1424C66F0) ---

// --- Function: sub_1424C9F20 (0x1424C9F20) ---
__int64 __fastcall sub_1424C9F20(__int64 a1)
{
  signed __int64 v2; // rbx
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v9; // [rsp+30h] [rbp-69h] BYREF
  __int64 p_rw_lock_state; // [rsp+38h] [rbp-61h]
  int *v11; // [rsp+40h] [rbp-59h]
  int v12; // [rsp+48h] [rbp-51h] BYREF
  int n0x5100_1; // [rsp+50h] [rbp-49h] BYREF
  __int64 v14; // [rsp+54h] [rbp-45h]
  int v15; // [rsp+5Ch] [rbp-3Dh]
  unsigned __int64 v16; // [rsp+60h] [rbp-39h]
  unsigned __int64 v17; // [rsp+68h] [rbp-31h]
  __int64 v18; // [rsp+70h] [rbp-29h]
  __int64 v19; // [rsp+78h] [rbp-21h]
  int n0x5100; // [rsp+A0h] [rbp+7h] BYREF
  __int64 v21; // [rsp+A4h] [rbp+Bh]
  int v22; // [rsp+ACh] [rbp+13h]
  unsigned __int64 v23; // [rsp+B0h] [rbp+17h]
  unsigned __int64 v24; // [rsp+B8h] [rbp+1Fh]
  __int64 v25; // [rsp+C0h] [rbp+27h]
  __int64 v26; // [rsp+C8h] [rbp+2Fh]

  n0x5100 = 0x5100;
  v22 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  v23 = __rdtsc();
  qword_149C89AA0(
    &n0x5100,
    &word_149F0A948,
    "CVehicleSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\VehicleSystem.cpp",
    0x2A9);
  HIWORD(n0x5100) = word_149F0A948;
  if ( !Parameter_0 )
    goto LABEL_15;
  n0x5100_1 = 0x5100;
  v14 = 1;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v16 = __rdtsc();
  qword_149C89AA0(
    &n0x5100_1,
    &word_149F0A94C,
    "CVehicleSystem::Update - DevTools",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\VehicleSystem.cpp",
    0x2CC);
  HIWORD(n0x5100_1) = word_149F0A94C;
  v9 = a1 + 8;
  p_rw_lock_state = a1 + 0x18;
  v11 = &v12;
  v12 = 1;
  if ( *(_DWORD *)(a1 + 0x28) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x2C);
  }
  else
  {
    v2 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x18));
    if ( (v2 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0x18, v2, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  v3 = *(_QWORD *)(a1 + 0x410);
  if ( v3 )
    goto LABEL_9;
  v4 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x13000000);
  *(_QWORD *)(a1 + 0x410) = v4;
  if ( v4 )
  {
    LOBYTE(v5) = *(_DWORD *)(qword_149F0A6A0 + 0x60) != 0;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 0x10LL))(v4, v5);
    (***(void (__fastcall ****)(_QWORD))(a1 + 0x410))(*(_QWORD *)(a1 + 0x410));
    v3 = *(_QWORD *)(a1 + 0x410);
LABEL_9:
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v3 + 8LL))(v3, &v9);
  }
  v6 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x13000003);
  if ( v6 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
  if ( (*v11)-- == 1 )
    rw_lock_release_read_lock(p_rw_lock_state);
  v17 = __rdtsc();
  qword_149C89AA8(&n0x5100_1);
LABEL_15:
  v24 = __rdtsc();
  return qword_149C89AA8(&n0x5100);
}

// --- End Function: sub_1424C9F20 (0x1424C9F20) ---

// --- Function: sub_1424CB2C0 (0x1424CB2C0) ---
__int64 *__fastcall sub_1424CB2C0(__int64 *a1, __int64 *a2)
{
  __int64 *v3; // rdi
  _QWORD **v4; // rcx
  _QWORD *v5; // rcx
  _QWORD *v6; // rbx
  __int64 *result; // rax

  if ( a1 != a2 )
  {
    v3 = a1 + 7;
    do
    {
      v4 = (_QWORD **)*v3;
      **(_QWORD **)(*v3 + 8) = 0;
      v5 = *v4;
      if ( v5 )
      {
        do
        {
          v6 = (_QWORD *)*v5;
          sub_1402A6590((__int64)v5);
          v5 = v6;
        }
        while ( v6 );
      }
      sub_1402A6590(*v3);
      v3 += 9;
      result = v3 + 0xFFFFFFF9;
    }
    while ( v3 + 0xFFFFFFF9 != a2 );
  }
  return result;
}

// --- End Function: sub_1424CB2C0 (0x1424CB2C0) ---

// --- Function: sub_1424CB590 (0x1424CB590) ---
char *__fastcall sub_1424CB590(__int64 *a1, _BYTE *a2, __int64 a3)
{
  __int64 v6; // rbp
  __int64 v7; // rdx
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  _QWORD *v13; // rbx
  void *v14; // rcx
  char *v15; // rbp
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  size_t Size; // r8
  __int64 v19; // r8
  char *result; // rax

  v6 = (__int64)&a2[-*a1] / 0x38;
  v7 = (a1[1] - *a1) / 0x38;
  if ( v7 == 0x492492492492492LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x38;
  if ( v9 > 0x492492492492492LL - (v9 >> 1) )
    goto LABEL_24;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x492492492492492LL )
    goto LABEL_24;
  v11 = 0x38 * v10;
  if ( 0x38 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = (_QWORD *)sub_1402A65A0(0x38 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_24:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_22;
  v13 = (_QWORD *)((v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v13[0xFFFFFFFF] = v12;
LABEL_13:
  v14 = v13;
  v15 = (char *)&v13[7 * v6];
  *(__m256i *)v15 = *(__m256i *)a3;
  *((_OWORD *)v15 + 2) = *(_OWORD *)(a3 + 0x20);
  *((double *)v15 + 6) = *(double *)(a3 + 0x30);
  v16 = (_BYTE *)a1[1];
  v17 = (_BYTE *)*a1;
  if ( a2 == v16 )
  {
    Size = v16 - v17;
    __asm { vzeroupper }
  }
  else
  {
    __asm { vzeroupper }
    memmove(v13, v17, a2 - v17);
    v14 = v15 + 0x38;
    Size = a1[1] - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v14, v17, Size);
  v19 = *a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(0x38 * ((a1[2] - v19) / 0x38)) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v19);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v19 - *(_QWORD *)(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(_QWORD *)(v19 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v13;
  result = v15;
  a1[1] = (__int64)&v13[7 * v8];
  a1[2] = (__int64)&v13[v11 / 8];
  return result;
}

// --- End Function: sub_1424CB590 (0x1424CB590) ---

// --- Function: sub_1424CB7A0 (0x1424CB7A0) ---
unsigned __int64 __fastcall sub_1424CB7A0(unsigned __int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbx
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r15
  __int64 v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // r13
  unsigned __int64 v15; // rbp
  unsigned __int64 v16; // rbx
  __int64 *i; // rdi
  __int64 *v18; // r8
  unsigned __int64 result; // rax

  v6 = (__int64)(a2 - *a1) / 0x48;
  v7 = (__int64)(a1[1] - *a1) / 0x48;
  if ( v7 == 0x38E38E38E38E38ELL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (__int64)(a1[2] - *a1) / 0x48;
  if ( v9 > 0x38E38E38E38E38ELL - (v9 >> 1) )
    goto LABEL_26;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x38E38E38E38E38ELL )
    goto LABEL_26;
  v11 = 0x48 * v10;
  if ( 0x48 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = sub_1402A65A0(0x48 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_26:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_24;
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_13:
  v14 = v13 + 0x48 * v6;
  sub_1424CF010(v14, a3);
  v15 = a1[1];
  v16 = *a1;
  if ( a2 == v15 )
  {
    for ( i = (__int64 *)v13; v16 != v15; v16 += 0x48LL )
    {
      sub_1424CF010(i, v16);
      i += 9;
    }
    sub_1424CB2C0(i, i);
  }
  else
  {
    sub_1424CD580(*a1, a2, v13, a1);
    sub_1424CD580(a2, a1[1], v14 + 0x48, a1);
  }
  if ( *a1 )
  {
    sub_1424CB2C0((__int64 *)*a1, (__int64 *)a1[1]);
    v18 = (__int64 *)*a1;
    if ( (unsigned __int64)(0x48 * ((__int64)(a1[2] - *a1) / 0x48)) < 0x1000 )
    {
LABEL_22:
      sub_1402A6590((__int64)v18);
      goto LABEL_23;
    }
    if ( (unsigned __int64)v18 - v18[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v18 = (__int64 *)v18[0xFFFFFFFF];
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *a1 = v13;
  a1[1] = v13 + 0x48 * v8;
  result = v14;
  a1[2] = v11 + v13;
  return result;
}

// --- End Function: sub_1424CB7A0 (0x1424CB7A0) ---

// --- Function: sub_1424CD580 (0x1424CD580) ---
__int64 __fastcall sub_1424CD580(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v5; // rbx
  __int64 v6; // rsi
  _QWORD *v7; // rax
  __int64 v8; // rdx

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = a1 + 0x38;
    v6 = a3 - a1;
    do
    {
      *(__m256i *)v3 = *(__m256i *)(v5 - 0x38);
      *(_OWORD *)(v3 + 0x20) = *(_OWORD *)(v5 - 0x18);
      *(double *)(v3 + 0x30) = *(double *)(v5 - 8);
      *(_QWORD *)(v5 + v6) = 0;
      *(_QWORD *)(v6 + v5 + 8) = 0;
      __asm { vzeroupper }
      v7 = (_QWORD *)sub_1402A65A0(0x18u);
      v5 += 0x48;
      v3 += 0x48;
      *v7 = v7;
      v7[1] = v7;
      *(_QWORD *)(v5 + v6 - 0x48) = v7;
      *(_QWORD *)(v5 + v6 - 0x48) = *(_QWORD *)(v5 - 0x48);
      *(_QWORD *)(v5 - 0x48) = v7;
      v8 = *(_QWORD *)(v6 + v5 - 0x40);
      *(_QWORD *)(v6 + v5 - 0x40) = *(_QWORD *)(v5 - 0x40);
      *(_QWORD *)(v5 - 0x40) = v8;
    }
    while ( v5 - 0x38 != a2 );
  }
  sub_1424CB2C0((__int64 *)v3, (__int64 *)v3);
  return v3;
}

// --- End Function: sub_1424CD580 (0x1424CD580) ---

// --- Function: sub_1424CEFC0 (0x1424CEFC0) ---
__int64 __fastcall sub_1424CEFC0(__int64 a1)
{
  __int64 result; // rax

  sub_14030CB30((_DWORD *)a1);
  *(_DWORD *)(a1 + 4) = 0;
  _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
    (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)(a1 + 0x10),
    (const struct __crt_stdio_stream *)&p_Src);
  result = a1;
  *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x1C) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_WORD *)(a1 + 0x30) = 0;
  return result;
}

// --- End Function: sub_1424CEFC0 (0x1424CEFC0) ---

// --- Function: sub_1424CF010 (0x1424CF010) ---
__int64 __fastcall sub_1424CF010(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  _QWORD *v4; // rsi
  _QWORD *v5; // r15
  _QWORD *v6; // rdi
  _QWORD *v7; // rbx
  _QWORD *i; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rax

  *(__m256i *)a1 = *(__m256i *)a2;
  *(_OWORD *)(a1 + 0x20) = *(_OWORD *)(a2 + 0x20);
  v2 = 0;
  *(double *)(a1 + 0x30) = *(double *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = 0;
  v4 = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  v5 = 0;
  v6 = *(_QWORD **)(a2 + 0x38);
  v7 = (_QWORD *)*v6;
  if ( (_QWORD *)*v6 != v6 )
  {
    __asm { vzeroupper }
    v4 = (_QWORD *)sub_1402A65A0(0x18u);
    v2 = 1;
    v5 = v4;
    v4[2] = v7[2];
    for ( i = (_QWORD *)*v7; i != v6; i = (_QWORD *)*i )
    {
      v9 = sub_1402A65A0(0x18u);
      ++v2;
      *(_QWORD *)(v9 + 0x10) = i[2];
      *v4 = v9;
      *(_QWORD *)(v9 + 8) = v4;
      v4 = (_QWORD *)v9;
    }
  }
  __asm { vzeroupper }
  v10 = (_QWORD *)sub_1402A65A0(0x18u);
  if ( v2 )
  {
    *v10 = v5;
    v10[1] = v4;
    v5[1] = v10;
    *v4 = v10;
  }
  else
  {
    *v10 = v10;
    v10[1] = v10;
  }
  *(_QWORD *)(a1 + 0x40) = v2;
  *(_QWORD *)(a1 + 0x38) = v10;
  return a1;
}

// --- End Function: sub_1424CF010 (0x1424CF010) ---

// --- Function: sub_1424D09A0 (0x1424D09A0) ---
_QWORD *__fastcall sub_1424D09A0(_QWORD *a1, char a2)
{
  __int64 v4; // rcx

  v4 = a1[8];
  if ( v4 )
  {
    if ( ((a1[0xA] - v4) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_1402A6590(v4);
    a1[8] = 0;
    a1[9] = 0;
    a1[0xA] = 0;
  }
  if ( (a2 & 1) != 0 )
    sub_1402A6590((__int64)a1);
  return a1;
}

// --- End Function: sub_1424D09A0 (0x1424D09A0) ---

// --- Function: sub_1424D0A20 (0x1424D0A20) ---
__int64 __fastcall sub_1424D0A20(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  _QWORD **v5; // rdi
  _QWORD *j; // rbx
  __int64 v7; // rbp
  __int64 **v8; // rax
  __int64 i; // rax
  __int64 *v10; // rcx
  unsigned __int8 v11; // bl
  __int64 v13; // rcx
  _QWORD **v14; // [rsp+30h] [rbp-38h]
  __int64 p_rw_lock_state; // [rsp+38h] [rbp-30h]
  __int64 v16; // [rsp+70h] [rbp+8h] BYREF

  v14 = (_QWORD **)(a1 + 0xB0);
  v3 = a1 + 0xC0;
  p_rw_lock_state = a1 + 0xC0;
  if ( *(_DWORD *)(a1 + 0xD0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v4 = _InterlockedIncrement64((volatile signed __int64 *)v3);
    if ( (v4 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v3, v4, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  v5 = (_QWORD **)*v14;
  j = (_QWORD *)**v14;
  if ( j == *v14 )
  {
LABEL_16:
    v11 = 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = j[5];
      if ( *(_BYTE *)(v7 + 8) )
      {
        sub_1424ED690(v7 + 0x20, &v16, a2);
        if ( (*(_DWORD *)(v7 + 0x30) == 0) == (v16 == *(_QWORD *)(v7 + 0x20)) )
          break;
      }
      v8 = (__int64 **)j[2];
      if ( *((_BYTE *)v8 + 0x19) )
      {
        for ( i = j[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
        {
          if ( j != *(_QWORD **)(i + 0x10) )
            break;
          j = (_QWORD *)i;
        }
        j = (_QWORD *)i;
      }
      else
      {
        v10 = *v8;
        for ( j = (_QWORD *)j[2]; !*((_BYTE *)v10 + 0x19); v10 = (__int64 *)*v10 )
          j = v10;
      }
      if ( j == v5 )
        goto LABEL_16;
    }
    if ( (dword_149F0A9B0 & 1) != 0 )
    {
      v13 = qword_149F0A9A8;
    }
    else
    {
      dword_149F0A9B0 |= 1u;
      v13 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
              qword_149C8DFD0,
              "i_debug");
      qword_149F0A9A8 = v13;
    }
    if ( v13 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x10LL))(v13) )
      sub_1403A63E0("Action %s is filtered by %s");
    v11 = 1;
  }
  rw_lock_release_read_lock(p_rw_lock_state);
  return v11;
}

// --- End Function: sub_1424D0A20 (0x1424D0A20) ---

// --- Function: sub_1424D26B0 (0x1424D26B0) ---
__int64 __fastcall sub_1424D26B0(_QWORD *a1, __int64 a2, __int64 a3)
{
  int v3; // r10d
  __int64 result; // rax
  _QWORD *v7; // rbx
  __int64 v8; // rdx
  _QWORD *v9; // r8
  __int64 v10; // r9
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rcx
  __int128 v14; // xmm1
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rax
  bool v17; // zf
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rdi
  __int64 v21; // rsi
  __m256i *v22; // rcx
  __int64 v23; // rax
  __int64 v24; // rdi
  __m256i *v25; // rcx
  _BYTE v26[64]; // [rsp+20h] [rbp-48h] BYREF

  v3 = *(_DWORD *)(a3 + 4);
  result = (unsigned int)(v3 - 1);
  if ( (unsigned int)result <= 1 )
  {
    v7 = a1 + 0x3D;
    v8 = a1[0x40];
    v9 = (_QWORD *)a1[0x3D];
    v10 = v8 + a1[0x41];
    if ( v8 == v10 )
    {
LABEL_12:
      sub_14030CB30(&v26[8]);
      *(_DWORD *)&v26[0xC] = 0;
      _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&v26[0x18],
        (const struct __crt_stdio_stream *)&p_Src);
      v14 = *(_OWORD *)(a3 + 0x20);
      v15 = v7[2];
      v16 = v7[4] + 1LL;
      v17 = *(_DWORD *)(a3 + 4) == 2;
      *(__m256i *)&v26[8] = *(__m256i *)a3;
      *(_QWORD *)&v26[0x38] = *(_QWORD *)(a3 + 0x30);
      *(_QWORD *)v26 = a2;
      *(_OWORD *)&v26[0x28] = v14;
      if ( v17 )
      {
        if ( v15 <= v16 )
        {
          __asm { vzeroupper }
          sub_140CB5840(v7, 1);
        }
        v18 = v7[2];
        v19 = v7[3] & (v18 - 1);
        v7[3] = v19;
        if ( !v19 )
          v19 = v18;
        v20 = v19 - 1;
        v21 = v20 & (v18 - 1);
        if ( !*(_QWORD *)(v7[1] + 8 * v21) )
        {
          __asm { vzeroupper }
          *(_QWORD *)(v7[1] + 8 * v21) = sub_1402A65A0(0x40u);
        }
        result = v7[1];
        v22 = *(__m256i **)(result + 8 * v21);
        *v22 = *(__m256i *)v26;
        v22[1] = *(__m256i *)&v26[0x20];
        v7[3] = v20;
      }
      else
      {
        if ( v15 <= v16 )
        {
          __asm { vzeroupper }
          sub_140CB5840(v7, 1);
        }
        v23 = v7[2] - 1LL;
        v7[3] &= v23;
        v24 = v23 & (v7[3] + v7[4]);
        if ( !*(_QWORD *)(v7[1] + 8 * v24) )
        {
          __asm { vzeroupper }
          *(_QWORD *)(v7[1] + 8 * v24) = sub_1402A65A0(0x40u);
        }
        result = v7[1];
        v25 = *(__m256i **)(result + 8 * v24);
        *v25 = *(__m256i *)v26;
        v25[1] = *(__m256i *)&v26[0x20];
      }
      ++v7[4];
    }
    else
    {
      while ( 1 )
      {
        v11 = v9 ? *v9 : 0LL;
        if ( **(_QWORD **)(*(_QWORD *)(v11 + 8) + 8 * (v8 & (*(_QWORD *)(v11 + 0x10) - 1LL))) == a2 )
        {
          v12 = v9 ? *v9 : 0LL;
          v13 = *(_QWORD *)(v12 + 0x10);
          result = *(_QWORD *)(v12 + 8);
          if ( *(_DWORD *)(*(_QWORD *)(result + 8 * (v8 & (v13 - 1))) + 0xCLL) == v3 )
            break;
        }
        if ( ++v8 == v10 )
          goto LABEL_12;
      }
    }
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1424D26B0 (0x1424D26B0) ---

// --- Function: sub_1424D2B80 (0x1424D2B80) ---
__m128 __fastcall sub_1424D2B80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _BYTE *a6)
{
  __int64 v6; // r14
  _WORD *v8; // rcx
  __int64 v11; // rax
  __m128 result; // xmm0
  int v13; // r15d
  __int16 v14; // ax
  __int64 v15; // rcx
  __int16 v16; // di
  __int64 v17; // rax
  __int64 **v18; // rbx
  __int64 v19; // rax
  __int64 **v20; // rbp
  __int64 *v21; // rsi
  __int16 v22; // ax
  _DWORD *v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rax
  __int128 v28; // kr00_16
  __int128 v29; // kr00_16
  unsigned __int16 v30[4]; // [rsp+20h] [rbp-38h] BYREF
  _DWORD v31[12]; // [rsp+28h] [rbp-30h] BYREF

  v6 = a5;
  v8 = (_WORD *)a5;
  LODWORD(a5) = *(_DWORD *)(a5 + 0x20);
  if ( sub_1403826E0(v8, 0xFFFFu) )
    return (__m128)(unsigned int)a5;
  v11 = *(_QWORD *)(v6 + 0x28);
  if ( !v11 )
    return (__m128)(unsigned int)a5;
  if ( *(_DWORD *)(v11 + 0x18) == 3 && *(_DWORD *)(v6 + 4) == 2 )
  {
    result = (__m128)(unsigned int)a5;
    *a6 = 1;
    return result;
  }
  *a6 = 0;
  *(_DWORD *)v30 = *(_DWORD *)v6;
  v13 = (unsigned __int16)sub_1403B1A80((__int64)v30);
  v14 = sub_140311590(v30);
  v15 = *(_QWORD *)(a1 + 0xA0);
  v16 = v14;
  v17 = *(int *)(a1 + 0xA8);
  if ( (int)v17 >= (*(_DWORD *)(v15 - 4) & 0x7FFFFFFF) )
    __debugbreak();
  v18 = *(__int64 ***)(v15 + 0x18 * v17 + 8);
  v19 = *((unsigned int *)v18 + 0xFFFFFFFF);
  LODWORD(v19) = v19 & 0x7FFFFFFF;
  v20 = &v18[v19];
  if ( v18 == v20 )
    return (__m128)(unsigned int)a5;
  while ( 1 )
  {
    v21 = *v18;
    v31[0] = 0xFFFFFFFF;
    v22 = (*(__int64 (__fastcall **)(__int64 *, _DWORD *))(*v21 + 0x20))(v21, v31);
    if ( v22 != v16 )
    {
      if ( v22 )
      {
        if ( v22 != 1 || v16 )
          goto LABEL_16;
      }
      else if ( v16 != 1 )
      {
        goto LABEL_16;
      }
    }
    if ( v31[0] == v13 )
      break;
LABEL_16:
    if ( ++v18 == v20 )
      return (__m128)(unsigned int)a5;
  }
  if ( !v21 )
    return (__m128)(unsigned int)a5;
  v24 = (_DWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a3 + 0x60LL))(a3);
  if ( *v24
    && (v25 = *v21,
        v31[0] = 0,
        v26 = (*(__int64 (__fastcall **)(__int64 *, _DWORD *, _DWORD *))(v25 + 0x38))(v21, v24, v31),
        (*(unsigned __int8 (__fastcall **)(__int64 *, __int64, __int64 *))(*v21 + 0x40))(v21, v26, &a5))
    && *(_DWORD *)(*(_QWORD *)(v6 + 0x28) + 0x18LL) == 4 )
  {
    _XMM1 = (unsigned int)a5;
    if ( *(float *)&a5 < 0.0 )
    {
      __asm { vmaxss  xmm0, xmm1, cs:dword_1482B6380 }
      v28 = _XMM0;
      *(float *)&v28 = *(float *)&_XMM0 + 1.0;
      _XMM1 = v28;
      *(float *)&a5 = *(float *)&_XMM0 + 1.0;
    }
  }
  else
  {
    _XMM1 = (unsigned int)a5;
  }
  if ( (*(_BYTE *)(a4 + 0xC4) & 7) != 0 && *(_DWORD *)(*(_QWORD *)(v6 + 0x28) + 0x18LL) == 3 )
  {
    v29 = _XMM1;
    *(float *)&v29 = (float)(*(float *)&_XMM1 + 1.0) * 0.5;
    return (__m128)v29;
  }
  return (__m128)_XMM1;
}

// --- End Function: sub_1424D2B80 (0x1424D2B80) ---

// --- Function: sub_1424D2F90 (0x1424D2F90) ---
__int64 __fastcall sub_1424D2F90(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rbx
  int v8; // r12d
  int v9; // r14d
  __int64 v10; // rax
  __int64 v11; // rax
  int *v12; // rsi
  _QWORD *v13; // r15
  _QWORD *v14; // rax
  bool v15; // zf
  unsigned int v16; // r15d
  int v17; // ecx
  __int64 v18; // rcx
  int v19; // esi
  int v20; // r14d
  __int64 v21; // r8
  __int64 v22; // rdx
  int n4; // esi
  int v24; // eax
  __int128 v25; // xmm1
  int v26; // eax
  __int64 v28; // [rsp+30h] [rbp-81h] BYREF
  int n0x1F00; // [rsp+40h] [rbp-71h] BYREF
  __int64 v30; // [rsp+44h] [rbp-6Dh]
  int v31; // [rsp+4Ch] [rbp-65h]
  unsigned __int64 v32; // [rsp+50h] [rbp-61h]
  unsigned __int64 v33; // [rsp+58h] [rbp-59h]
  __int64 v34; // [rsp+60h] [rbp-51h]
  __int64 v35; // [rsp+68h] [rbp-49h]
  __int64 v36; // [rsp+90h] [rbp-21h] BYREF
  __m256 v37; // [rsp+98h] [rbp-19h] BYREF
  __int128 v38; // [rsp+B8h] [rbp+7h]
  __int64 v39; // [rsp+C8h] [rbp+17h]
  __int64 v40; // [rsp+110h] [rbp+5Fh] BYREF
  __int64 v41; // [rsp+120h] [rbp+6Fh]
  __int64 v42; // [rsp+128h] [rbp+77h]

  v42 = a4;
  v41 = a3;
  v5 = a5;
  v31 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  n0x1F00 = 0x1F00;
  v30 = 1;
  v32 = __rdtsc();
  v8 = 1;
  qword_149C89AA0(
    &n0x1F00,
    &word_149F0AA38,
    "CActionMap::CanProcessInput",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\ActionMap.cpp",
    0x3B8);
  v9 = 0;
  HIWORD(n0x1F00) = word_149F0AA38;
  v40 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                     qword_149C8DF80,
                     0);
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
  if ( v10 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x58LL))(v10) )
  {
    v11 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                       qword_149C8DF80,
                       1);
    v40 = v11;
  }
  else
  {
    v11 = v40;
  }
  if ( !*(_BYTE *)(a1 + 8) )
  {
LABEL_60:
    v16 = v9;
    goto LABEL_61;
  }
  v12 = (int *)(a2 + 4);
  v13 = (_QWORD *)(v5 + 0xD8);
  if ( *(int *)(v5 + 0xC8) <= 1 )
    goto LABEL_15;
  if ( *v12 == 1 )
  {
    if ( *(int *)(v5 + 0x10C) > 0
      && (v14 = sub_14059CA60(&v40, &v36, (_QWORD *)(v5 + 0xD8)),
          v28 = (unsigned int)(int)(float)(*(float *)(*(_QWORD *)(a1 + 0x10) + 0x210LL) * 10000000.0),
          v15 = !sub_14059CAF0(v14, &v28),
          v11 = v40,
          v15) )
    {
      ++*(_DWORD *)(v5 + 0x10C);
    }
    else
    {
      *(_DWORD *)(v5 + 0x10C) = 1;
    }
    *v13 = v11;
    v12 = (int *)(a2 + 4);
  }
  if ( *(_DWORD *)(v5 + 0x10C) >= *(_DWORD *)(v5 + 0xC8) )
  {
LABEL_15:
    v17 = *(_DWORD *)(v5 + 0xC4);
    if ( (v17 & 0x80u) == 0 )
    {
      if ( *v12 == 1 )
      {
        *v13 = v11;
        if ( (v17 & 4) != 0 )
        {
          *(_QWORD *)(v5 + 0xE8) = v11;
          *(_BYTE *)(v5 + 0x118) = *(float *)(v5 + 0xF4) <= 0.0;
          *(_DWORD *)(v5 + 0xF8) = 0;
        }
      }
      v9 = sub_1424DE280(a1, a2, v41, v42, v5);
      goto LABEL_42;
    }
    switch ( *(_DWORD *)(v5 + 0x114) )
    {
      case 1:
        if ( fabs(*(float *)(a2 + 0x20) - *(float *)(v5 + 0xF0)) < 0.00000011920929 )
        {
          v18 = *(_QWORD *)(a1 + 0x10);
          goto LABEL_25;
        }
        goto LABEL_24;
      case 2:
        if ( fabs(*(float *)(a2 + 0x20) - *(float *)(v5 + 0xF0)) < 0.00000011920929 )
          goto LABEL_24;
        break;
      case 3:
        if ( *(float *)(v5 + 0xF0) >= *(float *)(a2 + 0x20) )
          goto LABEL_24;
        break;
      default:
        if ( *(_DWORD *)(v5 + 0x114) == 4 && *(float *)(v5 + 0xF0) > *(float *)(a2 + 0x20) )
        {
          v18 = *(_QWORD *)(a1 + 0x10);
          goto LABEL_25;
        }
LABEL_24:
        v18 = *(_QWORD *)(a1 + 0x10);
        if ( !v9 )
        {
          if ( !*(_BYTE *)(v18 + 0x1A9) && *(_BYTE *)(v5 + 0x119) )
          {
            v21 = v42;
            v22 = v41;
            *(_BYTE *)(v5 + 0x119) = 0;
            sub_1424E7700(*(_QWORD *)(a1 + 0x10), v22, v21, v5);
          }
          v12 = (int *)(a2 + 4);
          *(_DWORD *)(v5 + 0xF8) = 0;
          goto LABEL_42;
        }
LABEL_25:
        v19 = v42;
        v20 = v41;
        if ( !*(_BYTE *)(v18 + 0x1A9) )
        {
          sub_1424EBD70(v18, a2, v41, v42, v5);
          v11 = v40;
        }
        if ( *(_BYTE *)(v5 + 0x119) != 1 )
        {
          *(_QWORD *)(v5 + 0xD8) = v11;
          *(_QWORD *)(v5 + 0xE8) = v11;
          *(_WORD *)(v5 + 0x118) = 0x100;
          *(_DWORD *)(v5 + 0xF8) = 0;
        }
        v9 = sub_1424DE280(a1, a2, v20, v19, v5);
        v12 = (int *)(a2 + 4);
LABEL_42:
        n4 = *v12;
        if ( *(_BYTE *)(v5 + 0x11B) )
        {
          if ( !v9 && n4 == 4 && *(_DWORD *)(v5 + 0x110) == 2 )
          {
            v24 = *(_DWORD *)(v5 + 0xC4);
            if ( (v24 & 2) != 0 && (v24 & 4) == 0 )
            {
              v25 = *(_OWORD *)(a2 + 0x20);
              v37 = *(__m256 *)a2;
              v39 = *(_QWORD *)(a2 + 0x30);
              v38 = v25;
              LODWORD(v37.m256_f32[1]) = 1;
              __asm { vzeroupper }
              v26 = sub_1424DE280(a1, (unsigned int)&v37, v41, v42, v5);
              if ( v26 )
              {
                v9 = v26;
                n4 = 1;
              }
            }
          }
        }
        *(_BYTE *)(v5 + 0x11B) = 0;
        if ( v9 == 1 )
        {
          if ( ((n4 - 4) & 0xFFFFFFFB) == 0 || (*(_BYTE *)(v5 + 0xC4) & 3) != 0 && (unsigned int)(n4 - 1) <= 1 )
            *(_DWORD *)(v5 + 0x110) = n4;
        }
        else
        {
          if ( n4 != 4 || *(_DWORD *)(v5 + 0x110) != 1 || (*(_BYTE *)(v5 + 0xC4) & 2) == 0 )
            v8 = 0;
          *(_DWORD *)(v5 + 0x110) = v8;
        }
        goto LABEL_60;
    }
    v9 = 1;
    goto LABEL_24;
  }
  v16 = 0;
LABEL_61:
  v33 = __rdtsc();
  qword_149C89AA8(&n0x1F00);
  return v16;
}

// --- End Function: sub_1424D2F90 (0x1424D2F90) ---

// --- Function: sub_1424D43F0 (0x1424D43F0) ---
__int64 __fastcall sub_1424D43F0(__int64 a1, __int64 a2, __int64 **a3)
{
  unsigned int v5; // r14d
  __int64 *v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // r8
  int v9; // eax
  __int64 *v10; // rdi
  unsigned int v11; // eax
  __int64 *j; // rbx
  __int64 *v13; // rcx
  signed __int64 v14; // rdx
  __int64 v15; // r15
  unsigned __int8 **v16; // rsi
  bool v17; // zf
  __int64 v18; // rsi
  __int64 *v19; // r15
  const char *p_PlayerUICursor_1; // rax
  __int64 v21; // rax
  unsigned int v22; // r10d
  unsigned __int8 v23; // r9
  unsigned int v24; // eax
  unsigned __int8 v25; // cl
  char v26; // cl
  unsigned int v27; // r15d
  int n2_1; // edx
  bool v29; // cc
  bool v30; // cc
  gte::Vector<3,double> *v31; // rax
  __int64 *v32; // rdx
  gte::Vector<3,double> *v33; // rcx
  gte::Vector<3,double> **v34; // rax
  __int64 v35; // rsi
  gte::Vector<3,double> *v36; // rax
  __int64 *v37; // rdx
  gte::Vector<3,double> *v38; // rcx
  gte::Vector<3,double> **v39; // rax
  __int64 v40; // rax
  __int128 v41; // xmm1
  int v42; // eax
  __int64 *v43; // r15
  _QWORD *v44; // rcx
  _QWORD *v45; // rax
  __int64 v46; // rsi
  __int64 v47; // rax
  __int64 *v48; // rdx
  _QWORD *v49; // rcx
  _QWORD *v50; // rax
  __int64 **v51; // rax
  __int64 *i; // rax
  __int64 *v53; // rcx
  unsigned __int8 v54; // r15
  __int64 v55; // rdi
  __int64 v56; // rbx
  __int64 *v57; // r9
  __int64 v58; // rsi
  int v59; // eax
  __int64 v60; // rax
  const char *p_PlayerUICursor_2; // r8
  __int64 PlayerUICursor; // rcx
  __int64 v63; // r14
  __int64 v64; // rsi
  __int64 *v65; // rdi
  _QWORD *v66; // rcx
  _QWORD *v67; // rbx
  __int64 *v69; // rdi
  __int64 v70; // rbx
  __int64 v71; // rdx
  int v72; // eax
  char v73; // [rsp+30h] [rbp-79h]
  char v74; // [rsp+31h] [rbp-78h]
  int n2; // [rsp+34h] [rbp-75h]
  int v76; // [rsp+38h] [rbp-71h]
  int v77; // [rsp+3Ch] [rbp-6Dh]
  __int64 *v78; // [rsp+40h] [rbp-69h] BYREF
  __int64 v79; // [rsp+48h] [rbp-61h]
  __int64 v80; // [rsp+50h] [rbp-59h]
  const char *p_PlayerUICursor; // [rsp+58h] [rbp-51h] BYREF
  unsigned __int8 *v82[2]; // [rsp+60h] [rbp-49h] BYREF
  __int64 *v83; // [rsp+70h] [rbp-39h]
  unsigned int v84; // [rsp+78h] [rbp-31h]
  int v85; // [rsp+7Ch] [rbp-2Dh]
  __m256 v86; // [rsp+80h] [rbp-29h] BYREF
  __int128 v87; // [rsp+A0h] [rbp-9h]
  __int64 v88; // [rsp+B0h] [rbp+7h]
  _QWORD v89[9]; // [rsp+B8h] [rbp+Fh] BYREF
  char v91; // [rsp+128h] [rbp+7Fh]

  v91 = 0;
  v5 = sub_1424E7BF0();
  v77 = 0;
  v76 = 0;
  v73 = 0;
  v80 = 0;
  v79 = 0;
  v6 = (__int64 *)sub_1402A65A0(0x18u);
  v83 = v6;
  *v6 = (__int64)v6;
  v6[1] = (__int64)v6;
  v7 = sub_1402A4EC0(a2 + 0x10);
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v8;
  while ( *(_BYTE *)(v7 + v8) );
  v9 = psub_140338B20(0xFFFFFFFFLL, v7, v8);
  v10 = *(__int64 **)(a1 + 0xD8);
  v11 = ~v9;
  v84 = v11;
  j = v10;
  v13 = (__int64 *)v10[1];
  while ( !*((_BYTE *)v13 + 0x19) )
  {
    if ( *((_DWORD *)v13 + 8) >= v11 )
    {
      j = v13;
      v13 = (__int64 *)*v13;
    }
    else
    {
      v13 = (__int64 *)v13[2];
    }
  }
  LODWORD(v86.m256_f32[6]) = 1;
  *(_QWORD *)v86.m256_f32 = a1 + 0xB0;
  *(_QWORD *)&v86.m256_f32[2] = a1 + 0xC0;
  *(_QWORD *)&v86.m256_f32[4] = &v86.m256_f32[6];
  if ( *(_DWORD *)(a1 + 0xD0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0xD4);
  }
  else
  {
    v14 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0xC0));
    if ( (v14 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0xC0, v14, (const char *)&p_Src, (const char *)&p_Src, 1);
    v80 = v79;
  }
  p_PlayerUICursor = "PlayerUICursor";
  sub_14035DDD0(v82, &p_PlayerUICursor);
  v78 = *(__int64 **)v86.m256_f32;
  v15 = **(_QWORD **)v86.m256_f32;
  v16 = *(unsigned __int8 ***)(**(_QWORD **)v86.m256_f32 + 8LL);
  while ( !*((_BYTE *)v16 + 0x19) )
  {
    if ( (int)sub_1403E8B60(v16 + 4, v82) >= 0 )
    {
      v15 = (__int64)v16;
      v16 = (unsigned __int8 **)*v16;
    }
    else
    {
      v16 = (unsigned __int8 **)v16[2];
    }
  }
  if ( *(_BYTE *)(v15 + 0x19) || (int)sub_1403E8B60(v82, (_QWORD *)(v15 + 0x20)) < 0 )
    v15 = *v78;
  v82[0] = (unsigned __int8 *)&qword_149C78E84 + 4;
  sub_140373CC0(v82);
  if ( v15 == **(_QWORD **)v86.m256_f32 )
  {
    v17 = (**(_DWORD **)&v86.m256_f32[4])-- == 1;
    if ( v17 )
      rw_lock_release_read_lock(*(__int64 *)&v86.m256_f32[2]);
    v74 = 0;
  }
  else
  {
    v74 = *(_BYTE *)(*(_QWORD *)(v15 + 0x28) + 8LL);
    v17 = (**(_DWORD **)&v86.m256_f32[4])-- == 1;
    if ( v17 )
      rw_lock_release_read_lock(*(__int64 *)&v86.m256_f32[2]);
  }
  if ( j == v10 )
  {
    v54 = 0;
  }
  else
  {
    while ( *((_DWORD *)j + 8) == v84 )
    {
      v18 = j[5];
      v19 = (__int64 *)j[6];
      p_PlayerUICursor_1 = (const char *)j[7];
      v78 = v19;
      p_PlayerUICursor = p_PlayerUICursor_1;
      if ( sub_1402A5430((_DWORD *)v18, (_DWORD *)a2)
        && (!sub_1403826E0((_WORD *)v18, 0) || !sub_1403826E0((_WORD *)a2, 1u))
        && (!sub_1403826E0((_WORD *)v18, 1u) || !sub_1403826E0((_WORD *)a2, 0))
        || v74
        && sub_1403826E0((_WORD *)a2, 1u)
        && (*(unsigned int (__fastcall **)(__int64 *))(*v19 + 0x30))(v19) != 0x383 )
      {
        goto LABEL_98;
      }
      if ( !p_PlayerUICursor[8]
        || (v21 = (*(__int64 (__fastcall **)(__int64 *))(*v19 + 0x28))(v19), (unsigned __int8)sub_1424D0A20(a1, v21)) )
      {
        if ( (*(_BYTE *)(v18 + 0xC4) & 0x10) == 0 )
          goto LABEL_97;
      }
      else
      {
        if ( *(int *)(v18 + 0x10C) < 0 )
        {
          if ( *(_DWORD *)(a2 + 4) == 2 )
            *(_DWORD *)(v18 + 0x10C) = 0;
          goto LABEL_98;
        }
        v22 = *(_DWORD *)(v18 + 0x104);
        if ( v22 && (v22 & *(_DWORD *)(a2 + 0x1C)) != v22 )
        {
          sub_1424E5D10(p_PlayerUICursor, v19, 0);
          goto LABEL_98;
        }
        n2 = *(_DWORD *)(v18 + 0x110);
        v23 = (((v22 & 0x55) + (((unsigned __int8)v22 >> 1) & 0x55)) & 0x33)
            + (((unsigned __int8)((v22 & 0x55) + (((unsigned __int8)v22 >> 1) & 0x55)) >> 2) & 0x33);
        v24 = HIWORD(v22);
        v25 = (((HIBYTE(v22) & 0x55) + ((HIBYTE(v22) >> 1) & 0x55)) & 0x33)
            + (((unsigned __int8)((HIBYTE(v22) & 0x55) + ((HIBYTE(v22) >> 1) & 0x55)) >> 2) & 0x33);
        v26 = ((unsigned __int8)((((v24 & 0x55) + (((unsigned __int8)v24 >> 1) & 0x55)) & 0x33)
                               + (((unsigned __int8)((v24 & 0x55) + (((unsigned __int8)v24 >> 1) & 0x55)) >> 2) & 0x33)) >> 4)
            + (((((v24 & 0x55) + (((unsigned __int8)v24 >> 1) & 0x55)) & 0x33)
              + (((unsigned __int8)((v24 & 0x55) + (((unsigned __int8)v24 >> 1) & 0x55)) >> 2) & 0x33))
             & 0xF)
            + (v25 >> 4)
            + (v25 & 0xF);
        LOBYTE(v24) = (((BYTE1(v22) & 0x55) + ((BYTE1(v22) >> 1) & 0x55)) & 0x33)
                    + (((unsigned __int8)((BYTE1(v22) & 0x55) + ((BYTE1(v22) >> 1) & 0x55)) >> 2) & 0x33);
        v27 = (unsigned __int8)(((unsigned __int8)v24 >> 4) + (v24 & 0xF) + (v23 >> 4) + (v23 & 0xF) + v26);
        n2_1 = sub_1424D2F90((__int64)p_PlayerUICursor, a2, (__int64)p_PlayerUICursor, (__int64)v78, v18);
        if ( !n2_1 )
        {
          if ( v5 > v27 )
          {
            if ( *(_DWORD *)(a2 + 4) != 4 || n2 != 1 || *(_DWORD *)(v18 + 0x110) == 2 )
              goto LABEL_70;
LABEL_61:
            sub_1424E5D10(p_PlayerUICursor, v78, 0);
            goto LABEL_98;
          }
          if ( *(_DWORD *)(a2 + 4) != 4
            || (v40 = *(_QWORD *)(a2 + 0x28)) == 0
            || !*(_DWORD *)(v40 + 0x20)
            || v27 <= 1
            || n2 != 2 )
          {
LABEL_70:
            v30 = *(_DWORD *)(v18 + 0x10C) <= 0;
LABEL_71:
            if ( v30 || !*(_BYTE *)(v18 + 0xCC) )
            {
              if ( v27 > v5 )
              {
                if ( *(_DWORD *)(a1 + 0x218) )
                {
                  v5 = v27;
                }
                else if ( *(_DWORD *)(v18 + 0x110) == 1 )
                {
                  v5 = v27;
                }
              }
            }
            else
            {
              v78 = *a3;
              if ( a3[1] == (__int64 *)0xAAAAAAAAAAAAAAALL )
                goto LABEL_140;
              v31 = std::allocator<gte::Vector<3,double>>::allocate((std::allocator<gte::Vector<3,double> > *)a3, 1u);
              v32 = v78;
              v33 = v31;
              *((_QWORD *)v31 + 2) = j + 5;
              a3[1] = (__int64 *)((char *)a3[1] + 1);
              v34 = (gte::Vector<3,double> **)v32[1];
              v35 = v80;
              *((_QWORD *)v33 + 1) = v34;
              *(_QWORD *)v33 = v32;
              v32[1] = (__int64)v33;
              *v34 = v33;
              if ( v35 == 0xAAAAAAAAAAAAAAALL )
LABEL_140:
                std::_Xlength_error("list too long");
              v36 = std::allocator<gte::Vector<3,double>>::allocate((std::allocator<gte::Vector<3,double> > *)&v78, 1u);
              v37 = v83;
              v38 = v36;
              v80 = v35 + 1;
              *((_DWORD *)v36 + 4) = n2;
              if ( v27 > v5 )
                v5 = v27;
              v39 = (gte::Vector<3,double> **)v37[1];
              ++v77;
              *(_QWORD *)v38 = v37;
              *((_QWORD *)v38 + 1) = v39;
              v37[1] = (__int64)v38;
              *v39 = v38;
            }
            goto LABEL_98;
          }
          v30 = *(_DWORD *)(v18 + 0x10C) <= 0;
          if ( *(_DWORD *)(v18 + 0x10C) )
            goto LABEL_71;
          v41 = *(_OWORD *)(a2 + 0x20);
          v42 = *(_DWORD *)(v18 + 0x110);
          v86 = *(__m256 *)a2;
          v88 = *(_QWORD *)(a2 + 0x30);
          v87 = v41;
          LODWORD(v86.m256_f32[1]) = 1;
          v85 = v42;
          __asm { vzeroupper }
          n2_1 = sub_1424D2F90((__int64)p_PlayerUICursor, (__int64)&v86, (__int64)p_PlayerUICursor, (__int64)v78, v18);
          if ( !n2_1 )
          {
            *(_DWORD *)(v18 + 0x110) = v85;
            goto LABEL_98;
          }
          v5 = v27;
LABEL_86:
          if ( n2_1 == 1 )
            goto LABEL_87;
          goto LABEL_98;
        }
        if ( n2_1 == 1 )
        {
          if ( *(_BYTE *)(a2 + 0x31) && !n2 && (*(_BYTE *)(v18 + 0xC4) & 0x10) == 0 )
          {
LABEL_97:
            *(_DWORD *)(v18 + 0x110) = 0;
            goto LABEL_98;
          }
          if ( v27 >= v5 )
          {
            if ( v27 > v5 )
              v5 = v27;
            if ( *(int *)(v18 + 0x10C) > 0 )
            {
              ++v76;
              v73 |= *(_BYTE *)(v18 + 0xCC);
            }
LABEL_87:
            v43 = *a3;
            if ( a3[1] == (__int64 *)0xAAAAAAAAAAAAAAALL )
              goto LABEL_140;
            v44 = (_QWORD *)sub_1402A65A0(0x18u);
            v44[2] = j + 5;
            a3[1] = (__int64 *)((char *)a3[1] + 1);
            v45 = (_QWORD *)v43[1];
            v46 = v80;
            v44[1] = v45;
            *v44 = v43;
            v43[1] = (__int64)v44;
            *v45 = v44;
            if ( v46 == 0xAAAAAAAAAAAAAAALL )
              goto LABEL_140;
            v47 = sub_1402A65A0(0x18u);
            v48 = v83;
            v49 = (_QWORD *)v47;
            v80 = v46 + 1;
            v91 = 1;
            *(_DWORD *)(v47 + 0x10) = n2;
            v50 = (_QWORD *)v48[1];
            *v49 = v48;
            v49[1] = v50;
            v48[1] = (__int64)v49;
            *v50 = v49;
            goto LABEL_98;
          }
          *(_DWORD *)(v18 + 0x110) = n2;
          goto LABEL_61;
        }
        if ( n2_1 != 2 )
          goto LABEL_86;
        v29 = v27 <= v5;
        if ( v27 >= v5 )
          goto LABEL_54;
        if ( *(_DWORD *)(a2 + 4) != 4 || n2 != 1 || *(_DWORD *)(v18 + 0x110) == 2 )
        {
          v29 = v27 <= v5;
LABEL_54:
          if ( !v29 )
            v5 = v27;
          goto LABEL_98;
        }
        sub_1424E7700(a1, p_PlayerUICursor, v78, v18);
      }
LABEL_98:
      v51 = (__int64 **)j[2];
      if ( *((_BYTE *)v51 + 0x19) )
      {
        for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
        {
          if ( j != (__int64 *)i[2] )
            break;
          j = i;
        }
        j = i;
      }
      else
      {
        v53 = *v51;
        for ( j = (__int64 *)j[2]; !*((_BYTE *)v53 + 0x19); v53 = (__int64 *)*v53 )
          j = v53;
      }
      if ( j == v10 )
        break;
    }
    v54 = v91;
    if ( v91 && v76 )
    {
      v55 = *v83;
      v56 = **a3;
      if ( (__int64 *)v56 != *a3 )
      {
        while ( 1 )
        {
          v57 = *(__int64 **)(v56 + 0x10);
          v78 = v57;
          v58 = *v57;
          v59 = *(_DWORD *)(*v57 + 0x10C);
          if ( v59 <= 0 )
            break;
          if ( v59 < *(_DWORD *)(v58 + 0xC8) )
            goto LABEL_125;
          v60 = *(_QWORD *)(a1 + 0x200);
          p_PlayerUICursor_2 = *(const char **)(a1 + 0x1E8);
          if ( v60 != v60 + *(_QWORD *)(a1 + 0x208) )
          {
            do
            {
              if ( p_PlayerUICursor_2 )
                PlayerUICursor = *(_QWORD *)p_PlayerUICursor_2;
              else
                PlayerUICursor = 0;
              if ( **(_QWORD **)(*(_QWORD *)(PlayerUICursor + 8) + 8
                                                                 * (v60 & (*(_QWORD *)(PlayerUICursor + 0x10) - 1LL))) == v58 )
              {
                p_PlayerUICursor = p_PlayerUICursor_2;
                v82[1] = (unsigned __int8 *)(v60 + 1);
                v89[0] = p_PlayerUICursor_2;
                v82[0] = 0;
                v89[1] = 0;
                v89[2] = v60;
                sub_1424ED480(a1 + 0x1E8, &v86, v89, &p_PlayerUICursor);
                p_PlayerUICursor_2 = *(const char **)v86.m256_f32;
                v60 = *(_QWORD *)&v86.m256_f32[4];
              }
              else
              {
                ++v60;
              }
            }
            while ( v60 != *(_QWORD *)(a1 + 0x208) + *(_QWORD *)(a1 + 0x200) );
            v57 = v78;
          }
          if ( *(_DWORD *)(a2 + 4) != 2 )
            goto LABEL_124;
          *(_DWORD *)(*v57 + 0x10C) = 0;
          v56 = *(_QWORD *)v56;
          v55 = *(_QWORD *)v55;
LABEL_126:
          if ( (__int64 *)v56 == *a3 )
            goto LABEL_127;
        }
        if ( v73 || (*(_BYTE *)(v58 + 0xC4) & 0x10) == 0 )
        {
LABEL_125:
          *(_DWORD *)(v58 + 0x110) = *(_DWORD *)(v55 + 0x10);
          sub_1424E5D10(v57[2], v57[1], 0);
          v63 = *(_QWORD *)v56;
          **(_QWORD **)(v56 + 8) = *(_QWORD *)v56;
          *(_QWORD *)(*(_QWORD *)v56 + 8LL) = *(_QWORD *)(v56 + 8);
          a3[1] = (__int64 *)((char *)a3[1] + 0xFFFFFFFF);
          sub_1402A6590(v56);
          v64 = *(_QWORD *)v55;
          **(_QWORD **)(v55 + 8) = *(_QWORD *)v55;
          *(_QWORD *)(*(_QWORD *)v55 + 8LL) = *(_QWORD *)(v55 + 8);
          sub_1402A6590(v55);
          v56 = v63;
          v55 = v64;
          goto LABEL_126;
        }
LABEL_124:
        v56 = *(_QWORD *)v56;
        v55 = *(_QWORD *)v55;
        goto LABEL_126;
      }
      goto LABEL_127;
    }
    if ( v77 )
    {
      v69 = *a3;
      v70 = **a3;
      if ( (__int64 *)v70 == *a3 )
      {
LABEL_127:
        v54 = v91;
        goto LABEL_128;
      }
      do
      {
        v71 = **(_QWORD **)(v70 + 0x10);
        v72 = *(_DWORD *)(v71 + 0x10C);
        if ( v72 <= 0 || v72 >= *(_DWORD *)(v71 + 0xC8) )
        {
          v54 = v91;
        }
        else
        {
          sub_1424D26B0((_QWORD *)a1, v71, a2);
          v54 = 0;
          v91 = 0;
        }
        v70 = *(_QWORD *)v70;
      }
      while ( (__int64 *)v70 != v69 );
    }
  }
LABEL_128:
  v65 = v83;
  *(_QWORD *)v83[1] = 0;
  v66 = (_QWORD *)*v65;
  if ( *v65 )
  {
    do
    {
      v67 = (_QWORD *)*v66;
      sub_1402A6590((__int64)v66);
      v66 = v67;
    }
    while ( v67 );
  }
  sub_1402A6590((__int64)v65);
  return v54;
}

// --- End Function: sub_1424D43F0 (0x1424D43F0) ---

// --- Function: sub_1424D4DF0 (0x1424D4DF0) ---
__int64 __fastcall sub_1424D4DF0(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, __int64 *a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  __int64 v8; // rbx
  unsigned __int8 v9; // si
  __int64 v10; // rdi
  __int64 *v11; // rbp
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // r15
  const char *p_PlayerUICursor; // r13
  _QWORD *v19; // rax
  __int64 v20; // rbp
  _QWORD *v21; // rax
  _QWORD *v22; // rcx
  __int64 v23; // rbp
  _QWORD *v24; // rax
  _QWORD *v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rsi
  _QWORD *v28; // rax
  _QWORD *v29; // rcx
  __int64 v31; // [rsp+30h] [rbp-88h] BYREF
  __int64 v32; // [rsp+38h] [rbp-80h]
  __int64 v33; // [rsp+40h] [rbp-78h] BYREF
  __int64 v34; // [rsp+48h] [rbp-70h] BYREF
  __int128 v35; // [rsp+50h] [rbp-68h]
  __int128 v36; // [rsp+60h] [rbp-58h]
  __int128 v37; // [rsp+70h] [rbp-48h]
  char v39; // [rsp+C8h] [rbp+10h]

  v8 = *(_QWORD *)(a2 + 0x40);
  v9 = 0;
  v10 = *(_QWORD *)(a2 + 0x48);
  v11 = a4;
  v32 = a2 + 8;
  v39 = 0;
  v31 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                     qword_149C8DF80,
                     0);
  v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
  if ( v13 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x58LL))(v13) )
    v31 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                       qword_149C8DF80,
                       1);
  v37 = v5;
  v36 = v6;
  v35 = v7;
  if ( v8 != v10 )
  {
    while ( *(_BYTE *)(v8 + 0x18) )
    {
      *(_BYTE *)(v8 + 0x18) = 0;
LABEL_20:
      v8 += 0x20;
      if ( v8 == v10 )
        return v9;
    }
    v14 = *(_QWORD *)v8;
    v15 = *(_QWORD *)(v8 + 8);
    p_PlayerUICursor = *(const char **)(v8 + 0x10);
    if ( *(_DWORD *)(v32 + 4) == 1 )
    {
      _XMM0 = *(unsigned int *)(v14 + 0xE0);
      __asm { vmaxss  xmm6, xmm0, dword ptr [rsi+0B8h] }
      if ( *(float *)&_XMM6 >= 0.00000011920929 )
      {
        v19 = sub_14059CA60(&v31, &v34, (_QWORD *)(v14 + 0xD8));
        v33 = (unsigned int)(int)(float)(*(float *)&_XMM6 * 10000000.0);
        if ( !sub_14059CB00(v19, &v33) )
        {
LABEL_19:
          v9 = v39;
          goto LABEL_20;
        }
        v20 = *v11;
        if ( a4[1] == 0xAAAAAAAAAAAAAAALL )
          goto LABEL_22;
        v21 = (_QWORD *)sub_1402A65A0(0x18u);
        v21[2] = v8;
        ++a4[1];
        v22 = *(_QWORD **)(v20 + 8);
        *v21 = v20;
        v21[1] = v22;
        *(_QWORD *)(v20 + 8) = v21;
        *v22 = v21;
        if ( *(_BYTE *)(v8 + 0x19) )
        {
          v23 = *a5;
          if ( a5[1] == 0xAAAAAAAAAAAAAAALL )
            goto LABEL_22;
          v24 = (_QWORD *)sub_1402A65A0(0x18u);
          v24[2] = v8;
          ++a5[1];
          v25 = *(_QWORD **)(v23 + 8);
          *v24 = v23;
          v24[1] = v25;
          *(_QWORD *)(v23 + 8) = v24;
          *v25 = v24;
        }
        v11 = a4;
      }
    }
    v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x28LL))(v15);
    if ( !(unsigned __int8)sub_1424D0A20(a1, v26)
      && (unsigned int)sub_1424D2F90(p_PlayerUICursor, v32, p_PlayerUICursor, v15, v14) )
    {
      v27 = *a3;
      if ( a3[1] == 0xAAAAAAAAAAAAAAALL )
LABEL_22:
        std::_Xlength_error("list too long");
      v28 = (_QWORD *)sub_1402A65A0(0x18u);
      v28[2] = v8;
      ++a3[1];
      v29 = *(_QWORD **)(v27 + 8);
      *v28 = v27;
      v28[1] = v29;
      *(_QWORD *)(v27 + 8) = v28;
      v9 = 1;
      v39 = 1;
      *v29 = v28;
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  return v9;
}

// --- End Function: sub_1424D4DF0 (0x1424D4DF0) ---

// --- Function: sub_1424DB390 (0x1424DB390) ---
const ULONG_PTR *__fastcall sub_1424DB390(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int128 v3; // xmm6
  __int64 v4; // rbx
  int v8; // esi
  unsigned int v9; // eax
  __int64 v10; // r8
  int v11; // ebp
  unsigned __int64 v12; // rdx
  __int64 v13; // rsi
  char v14; // cl
  int v15; // eax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int32 v17; // eax
  _BYTE v18[2]; // [rsp+30h] [rbp-88h] BYREF
  __int16 v19; // [rsp+32h] [rbp-86h]
  __int64 v20; // [rsp+34h] [rbp-84h]
  int v21; // [rsp+3Ch] [rbp-7Ch]
  unsigned __int64 v22; // [rsp+40h] [rbp-78h]
  unsigned __int64 v23; // [rsp+48h] [rbp-70h]
  __int64 v24; // [rsp+50h] [rbp-68h]
  __int64 v25; // [rsp+58h] [rbp-60h]
  __int128 v26; // [rsp+80h] [rbp-38h]

  v26 = v3;
  v4 = a1 + 0x28;
  v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v8 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
    if ( v9 )
      sub_1403C6E80(v4, v9, (__int64)"CActionMapManager::ForwardActionToListeners", 1);
    else
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v4 + 0x10) = v8;
  }
  ++*(_DWORD *)(a1 + 0x238);
  v10 = *(_QWORD *)(a1 + 0x10);
  v11 = 0;
  v12 = (*(_QWORD *)(a1 + 0x18) - v10) / 0x18;
  if ( v12 )
  {
    v13 = 0;
    do
    {
      v14 = *(_BYTE *)(v13 + v10 + 0x11);
      v19 = 0;
      v20 = 1;
      v21 = 0;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v18[1] = v14;
      v22 = __rdtsc();
      v18[0] = 0;
      qword_149C89AA0(
        v18,
        &word_149F0AA60,
        "ForwardActionToListeners",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\ActionMapManager.cpp",
        0xF77);
      v19 = word_149F0AA60;
      (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v13 + *(_QWORD *)(a1 + 0x10)) + 8LL))(
        *(_QWORD *)(v13 + *(_QWORD *)(a1 + 0x10)),
        a2,
        a3);
      v23 = __rdtsc();
      qword_149C89AA8(v18);
      v10 = *(_QWORD *)(a1 + 0x10);
      v13 += 0x18;
      ++v11;
      v12 = (*(_QWORD *)(a1 + 0x18) - v10) / 0x18;
    }
    while ( v11 < v12 );
    v4 = a1 + 0x28;
  }
  if ( *(_DWORD *)(a1 + 0x238) == 1 && *(_QWORD *)(a1 + 0x220) != *(_QWORD *)(a1 + 0x228) )
    sub_1424DDDD0(a1, v12);
  --*(_DWORD *)(a1 + 0x238);
  v15 = *(_DWORD *)(v4 + 0x14);
  if ( v15 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v15 - 1);
    *(_DWORD *)(v4 + 0x14) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
    v17 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
    if ( v17 == 1 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(v4 + 8) = &p_Src;
    }
    else
    {
      return sub_1403DF590(v4, v17);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_1424DB390 (0x1424DB390) ---

// --- Function: sub_1424DD9D0 (0x1424DD9D0) ---
char __fastcall sub_1424DD9D0(__int64 a1, __int64 a2, __int64 **a3)
{
  __int64 v5; // rsi
  __int64 v6; // rax
  char v7; // r15
  __int64 v8; // rbx
  __int64 *v9; // rax
  __int64 v10; // rbp
  __int64 v11; // r14
  __int64 v12; // rdi
  unsigned __int32 v13; // xmm0_4
  _QWORD *v14; // rdi
  char v15; // r14
  unsigned int v16; // esi
  int n2; // eax
  __int64 v18; // rbp
  __int64 *v19; // rdi
  __int64 *v20; // rbx
  __int64 *v21; // rax
  __int64 v22; // r14
  __int64 v23; // r15
  __int64 v24; // rbp
  unsigned int v25; // r12d
  unsigned __int32 v26; // xmm0_4
  __int64 v28; // rdi
  void (__fastcall *v29)(__int64, const ULONG_PTR *, _QWORD, _QWORD, _QWORD); // rbx
  const ULONG_PTR **v30; // rax
  const ULONG_PTR *p_p_Src; // rdx
  unsigned int v32; // [rsp+30h] [rbp-78h]
  __int64 v33; // [rsp+38h] [rbp-70h]
  const char *v34; // [rsp+B0h] [rbp+8h] BYREF
  __int64 v35; // [rsp+B8h] [rbp+10h]
  unsigned int v36; // [rsp+C8h] [rbp+20h]

  v35 = a2;
  v5 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(qword_149C8DF80, 0);
  v33 = v5;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
  if ( v6 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x58LL))(v6) )
  {
    v5 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                      qword_149C8DF80,
                      1);
    v33 = v5;
  }
  if ( *(_QWORD *)(a1 + 0x40) != *(_QWORD *)(a1 + 0x48) )
  {
    v7 = 0;
    v8 = **a3;
    if ( (__int64 *)v8 != *a3 )
    {
      do
      {
        v9 = *(__int64 **)(v8 + 0x10);
        v10 = v9[2];
        if ( *(_BYTE *)(v10 + 8) )
        {
          v11 = v9[1];
          v12 = *v9;
          v36 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x30LL))(v11);
          if ( !*(_BYTE *)(v35 + 0x31) || (*(_BYTE *)(v12 + 0xC4) & 0x10) != 0 )
          {
            sub_1424DDE80(a1, v35, v12, v5);
            v32 = *(_DWORD *)(v12 + 0x110);
            v13 = sub_1424D2B80(a1, v10, v11, v12, v35, &v34).m128_u32[0];
            if ( !*(_BYTE *)(v35 + 0x30) || COERCE_FLOAT(v13 & 0x7FFFFFFF) >= 0.00000011920929 )
            {
              v14 = *(_QWORD **)(a1 + 0x40);
              v15 = 0;
              if ( v14 != *(_QWORD **)(a1 + 0x48) )
              {
                v16 = v36;
                do
                {
                  n2 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*v14 + 8LL))(*v14, v16, v32);
                  if ( n2 == 3 )
                  {
                    v7 = 1;
                  }
                  else if ( n2 == 2 && !v7 && !v15 )
                  {
                    v18 = *(_QWORD *)v8;
                    **(_QWORD **)(v8 + 8) = *(_QWORD *)v8;
                    *(_QWORD *)(*(_QWORD *)v8 + 8LL) = *(_QWORD *)(v8 + 8);
                    a3[1] = (__int64 *)((char *)a3[1] + 0xFFFFFFFF);
                    sub_1402A6590(v8);
                    v15 = 1;
                    v8 = v18;
                  }
                  ++v14;
                }
                while ( v14 != *(_QWORD **)(a1 + 0x48) );
                v5 = v33;
                if ( v15 )
                  continue;
              }
            }
          }
        }
        v8 = *(_QWORD *)v8;
      }
      while ( (__int64 *)v8 != *a3 );
      if ( v7 )
        return 1;
    }
  }
  v19 = *a3;
  v20 = (__int64 *)**a3;
  if ( v20 != *a3 )
  {
    do
    {
      v21 = (__int64 *)v20[2];
      v22 = v21[2];
      if ( *(_BYTE *)(v22 + 8) )
      {
        v23 = v21[1];
        v24 = *v21;
        v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x30LL))(v23);
        if ( !*(_BYTE *)(v35 + 0x31) || (*(_BYTE *)(v24 + 0xC4) & 0x10) != 0 )
        {
          sub_1424DDE80(a1, v35, v24, v5);
          v36 = *(_DWORD *)(v24 + 0x110);
          LOBYTE(v34) = 0;
          v26 = sub_1424D2B80(a1, v22, v23, v24, v35, &v34).m128_u32[0];
          if ( !(_BYTE)v34 && (!*(_BYTE *)(v35 + 0x30) || COERCE_FLOAT(v26 & 0x7FFFFFFF) >= 0.00000011920929) )
          {
            if ( (*(_BYTE *)(v24 + 0xC4) & 0x40) != 0 )
            {
              v28 = qword_149C8DFD0;
              v29 = *(void (__fastcall **)(__int64, const ULONG_PTR *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149C8DFD0
                                                                                              + 0x130LL);
              v30 = (const ULONG_PTR **)sub_140592FE0(&v34, v25);
              p_p_Src = &p_Src;
              if ( *v30 )
                p_p_Src = *v30;
              v29(v28, p_p_Src, 0, 0, 0);
              sub_1403E63B0((__int64)&v34, v34);
              sub_1424DB390(a1, v25, v36);
              return 1;
            }
            sub_1424DB390(a1, v25, v36);
            sub_1424E4210(v22, v25, v36);
          }
        }
      }
      v20 = (__int64 *)*v20;
    }
    while ( v20 != v19 );
  }
  return 0;
}

// --- End Function: sub_1424DD9D0 (0x1424DD9D0) ---

// --- Function: sub_1424DDDD0 (0x1424DDDD0) ---
__int64 __fastcall sub_1424DDDD0(__int64 a1)
{
  __int64 *v1; // rsi
  __int64 *i; // rbx
  __int64 v4; // rdx
  __int64 result; // rax
  __int64 v6; // rbx
  __int64 v7; // rsi

  v1 = *(__int64 **)(a1 + 0x228);
  for ( i = *(__int64 **)(a1 + 0x220); i != v1; i += 3 )
  {
    v4 = *i;
    if ( *((_BYTE *)i + 0x12) )
      result = sub_1424D16C0(a1, v4, i[1], *((unsigned __int8 *)i + 0x11), *((_BYTE *)i + 0x10), 0xFF);
    else
      result = sub_1424E6580(a1, v4);
  }
  v6 = *(_QWORD *)(a1 + 0x220);
  v7 = *(_QWORD *)(a1 + 0x228);
  if ( v6 != v7 )
  {
    do
    {
      sub_140373CC0((_QWORD *)(v6 + 8));
      v6 += 0x18;
    }
    while ( v6 != v7 );
    result = *(_QWORD *)(a1 + 0x220);
    *(_QWORD *)(a1 + 0x228) = result;
  }
  return result;
}

// --- End Function: sub_1424DDDD0 (0x1424DDDD0) ---

// --- Function: sub_1424DDE80 (0x1424DDE80) ---
void sub_1424DDE80(__int64 a1, unsigned int *a2, __int64 a3, ...)
{
  int n4; // ecx
  _QWORD *v7; // rax
  bool v8; // al
  int *v9; // rdi
  __int64 v10; // rax
  int *i; // rbp
  _QWORD v12[5]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v13; // [rsp+60h] [rbp+8h] BYREF
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( (!*(_BYTE *)(a1 + 0x1A9)
     || !(*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 0x98) + 0x1D0LL))(
           *(_QWORD *)(a1 + 0x98),
           a2[6],
           *a2))
    && *(_DWORD *)(a3 + 0x98) )
  {
    n4 = a2[1];
    if ( n4 == 8 )
    {
      if ( *(_BYTE *)(a3 + 0x119) )
      {
        v7 = sub_14059CA60((__int64 *)va, v12, (_QWORD *)(a3 + 0xD8));
        v13 = 0;
        v8 = sub_14059CB00(v7, &v13);
        n4 = 4;
        if ( !v8 )
          n4 = 1;
      }
      else
      {
        n4 = 2;
      }
    }
    if ( (n4 & *(_DWORD *)(a3 + 0xAC)) != 0 )
    {
      if ( *(_DWORD *)(a3 + 0x98) == 1 )
      {
        v9 = *(int **)(a3 + 0xA0);
        v10 = (unsigned int)v9[0xFFFFFFFF];
        LODWORD(v10) = v10 & 0x7FFFFFFF;
        for ( i = &v9[v10]; v9 != i; ++v9 )
        {
          sub_14036FB80((__int64)v12, *v9, *(float *)(a3 + 0xA8), *(_BYTE *)(a3 + 0xB1), *(_BYTE *)(a3 + 0xB0));
          (*(void (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 0x98) + 0x1A8LL))(*(_QWORD *)(a1 + 0x98), v12);
        }
      }
      else if ( *(_DWORD *)(a3 + 0x98) == 2 )
      {
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x98) + 0x1C8LL))(*(_QWORD *)(a1 + 0x98));
      }
    }
  }
}

// --- End Function: sub_1424DDE80 (0x1424DDE80) ---

// --- Function: sub_1424E4210 (0x1424E4210) ---
void __fastcall sub_1424E4210(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  __int64 **v3; // rdi
  __int64 *v6; // r8
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rdx
  __int64 v9; // r10
  __int64 *v10; // rax
  unsigned __int64 v11; // r9
  __int64 *v12; // rax

  v3 = (__int64 **)(a1 + 0x1B);
  ++a1[0x1E];
  v6 = (__int64 *)a1[0x1B];
  v7 = 0;
  v8 = (__int64)(a1[0x1C] - (_QWORD)v6) >> 3;
  if ( !v8 || (v9 = *v6) == 0 )
  {
    v9 = 0;
    v7 = 1;
    if ( v8 > 1 )
    {
      v10 = v6 + 1;
      while ( !*v10 )
      {
        ++v7;
        ++v10;
        if ( v7 >= v8 )
          goto LABEL_9;
      }
      v9 = *v10;
    }
  }
LABEL_9:
  v11 = (__int64)(a1[0x1C] - (_QWORD)v6) >> 3;
LABEL_10:
  while ( 1 )
  {
    if ( !v9 )
    {
      if ( v7 >= v11 )
        break;
      v9 = v6[v7];
      if ( !v9 )
        break;
    }
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD, unsigned __int64))(*(_QWORD *)v9 + 8LL))(v9, a2, a3, v11);
    v6 = *v3;
    v9 = 0;
    v11 = v3[1] - *v3;
    if ( ++v7 < v11 )
    {
      v12 = &v6[v7];
      while ( !*v12 )
      {
        ++v7;
        ++v12;
        if ( v7 >= v11 )
          goto LABEL_10;
      }
      v9 = *v12;
    }
  }
  sub_141AEA010((__int64)v3);
}

// --- End Function: sub_1424E4210 (0x1424E4210) ---

// --- Function: sub_1424E5D10 (0x1424E5D10) ---
void __fastcall sub_1424E5D10(_QWORD *a1, __int64 a2, char a3)
{
  __int128 v3; // xmm7
  char v6; // r14
  char v7; // bp
  __int64 v8; // rax
  int v9; // edi
  int v10; // r12d
  __int64 v11; // rbx
  int n4; // esi
  bool v13; // cl
  _QWORD *v14; // rax
  _QWORD *v15; // rax
  char v16; // al
  int n2; // eax
  _QWORD *v18; // r14
  char v19; // bl
  unsigned int v20; // esi
  __int64 v21; // rcx
  _QWORD *v22; // rbp
  _QWORD *v23; // rdi
  __int64 v24; // [rsp+20h] [rbp-78h] BYREF
  __int64 v25; // [rsp+28h] [rbp-70h] BYREF
  __int64 v26; // [rsp+30h] [rbp-68h] BYREF
  __int128 v27; // [rsp+40h] [rbp-58h]
  __int64 v29; // [rsp+A8h] [rbp+10h] BYREF
  __int64 v30; // [rsp+B8h] [rbp+20h] BYREF

  v6 = 0;
  v7 = 0;
  v29 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                     qword_149C8DF80,
                     0);
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
  if ( v8 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x58LL))(v8) )
    v29 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                       qword_149C8DF80,
                       1);
  v9 = 0;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 0x10LL))(a2);
  if ( v10 > 0 )
  {
    v27 = v3;
    do
    {
      v11 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a2 + 0x20LL))(a2, (unsigned int)v9);
      n4 = *(_DWORD *)(v11 + 0x110);
      v13 = n4 == 1 || n4 == 4;
      if ( (*(_DWORD *)(v11 + 0xC4) & 2) != 0 && v13 )
      {
        v6 = 1;
        if ( *(float *)(v11 + 0xBC) > 0.0 )
        {
          v14 = sub_14059CA60(&v29, &v25, (_QWORD *)(v11 + 0xD8));
          v30 = (unsigned int)(int)(float)(10000000.0 * *(float *)(v11 + 0xBC));
          if ( !sub_14059CB00(v14, &v30) )
            v6 = 0;
        }
        if ( *(float *)(v11 + 0xC0) > 0.0 )
        {
          v15 = sub_14059CA60(&v29, &v26, (_QWORD *)(v11 + 0xD8));
          v24 = (unsigned int)(int)(float)(10000000.0 * *(float *)(v11 + 0xC0));
          v6 &= sub_14059CAE0(v15, &v24);
        }
      }
      v16 = 1;
      if ( n4 == 8 )
        v7 = 1;
      *(_DWORD *)(v11 + 0xF8) = 0;
      *(_DWORD *)(v11 + 0x10C) = 0;
      if ( !a3 || !*(_BYTE *)(v11 + 0x11B) && *(_DWORD *)(v11 + 0x110) == 2 )
        v16 = 0;
      *(_BYTE *)(v11 + 0x11B) = v16;
      if ( *(_DWORD *)(v11 + 0x110) )
      {
        n2 = 2;
        if ( n4 == 8 )
          n2 = 0;
        *(_DWORD *)(v11 + 0x110) = n2;
      }
      ++v9;
    }
    while ( v9 < v10 );
    if ( v6 || v7 )
    {
      v18 = a1;
      v19 = 0;
      v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 0x30LL))(a2);
      v21 = a1[2];
      v22 = *(_QWORD **)(v21 + 0x48);
      v23 = *(_QWORD **)(v21 + 0x40);
      if ( v23 == v22 )
        goto LABEL_36;
      do
      {
        if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))(*(_QWORD *)*v23 + 8LL))(*v23, v20, 2) - 2 <= 1 )
          v19 = 1;
        ++v23;
      }
      while ( v23 != v22 );
      v18 = a1;
      if ( !v19 )
      {
LABEL_36:
        sub_1424DB390(v18[2], v20, 2u);
        sub_1424E4210(v18, v20, 2u);
      }
    }
  }
}

// --- End Function: sub_1424E5D10 (0x1424E5D10) ---

// --- Function: sub_1424E6B60 (0x1424E6B60) ---
void __fastcall sub_1424E6B60(__int64 a1)
{
  __int64 v2; // rdi
  int v3; // esi
  unsigned int v4; // eax
  __int64 _Al; // r14
  _QWORD *v6; // rsi
  _QWORD *j; // rbx
  _QWORD *v8; // rbp
  __int64 v9; // rcx
  __int64 **v10; // rax
  __int64 i; // rax
  __int64 *v12; // rcx
  _QWORD *v13; // rsi
  __int64 v14; // rbx
  __int64 v15; // rcx
  int v16; // eax
  unsigned __int32 v17; // eax

  if ( *(_BYTE *)(a1 + 0x1A9) )
  {
    *(_BYTE *)(a1 + 0x1AA) = 1;
  }
  else
  {
    v2 = a1 + 0x100;
    v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v2 + 0x10) == v3 )
    {
      ++*(_DWORD *)(v2 + 0x14);
    }
    else
    {
      v4 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 1, 0);
      if ( v4 )
        sub_1403C6E80(v2, v4, (__int64)"CActionMapManager::RemoveAllRefireData", 1);
      else
        *(_QWORD *)(v2 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v2 + 0x10) = v3;
    }
    _Al = a1 + 0x118;
    v6 = *(_QWORD **)(a1 + 0x118);
    j = (_QWORD *)*v6;
    while ( j != v6 )
    {
      v8 = (_QWORD *)j[5];
      if ( v8 )
      {
        v9 = v8[8];
        if ( v9 )
        {
          if ( ((v8[0xA] - v9) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
          {
            if ( (unsigned __int64)(v9 - *(_QWORD *)(v9 - 8) - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
            v9 = *(_QWORD *)(v9 - 8);
          }
          sub_1402A6590(v9);
          v8[8] = 0;
          v8[9] = 0;
          v8[0xA] = 0;
        }
        sub_1402A6590((__int64)v8);
      }
      v10 = (__int64 **)j[2];
      if ( *((_BYTE *)v10 + 0x19) )
      {
        for ( i = j[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
        {
          if ( j != *(_QWORD **)(i + 0x10) )
            break;
          j = (_QWORD *)i;
        }
        j = (_QWORD *)i;
      }
      else
      {
        v12 = *v10;
        for ( j = (_QWORD *)j[2]; !*((_BYTE *)v12 + 0x19); v12 = (__int64 *)*v12 )
          j = v12;
      }
    }
    v13 = *(_QWORD **)_Al;
    v14 = *(_QWORD *)(*(_QWORD *)_Al + 8LL);
    while ( !*(_BYTE *)(v14 + 0x19) )
    {
      std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
        (std::_Tree_val<std::_Tree_simple_types<std::pair<double const ,int> > > *)_Al,
        (std::allocator<std::_Tree_node<std::pair<double const ,int>,void *> > *)_Al,
        *(_QWORD *)(v14 + 0x10));
      v15 = v14;
      v14 = *(_QWORD *)v14;
      sub_1402A6590(v15);
    }
    v13[1] = v13;
    *v13 = v13;
    v13[2] = v13;
    *(_QWORD *)(_Al + 8) = 0;
    v16 = *(_DWORD *)(v2 + 0x14);
    if ( v16 )
    {
      *(_DWORD *)(v2 + 0x14) = v16 - 1;
    }
    else
    {
      *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
      v17 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 0, 1);
      if ( v17 == 1 )
        *(_QWORD *)(v2 + 8) = &p_Src;
      else
        sub_1403DF590(v2, v17);
    }
  }
}

// --- End Function: sub_1424E6B60 (0x1424E6B60) ---

// --- Function: sub_1424E7700 (0x1424E7700) ---
char __fastcall sub_1424E7700(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // r10d
  std::_Tree_val<std::_Tree_simple_types<int> > *v7; // r14
  __int64 *_Wherenode_1; // rcx
  __int64 *_Wherenode; // rbx
  __int64 *_Wherenode_2; // rax
  __int64 v11; // rdi
  char *v12; // rdx
  char *v13; // r8
  char *v14; // rcx
  __int64 v16; // [rsp+48h] [rbp+20h] BYREF

  v4 = *(_DWORD *)(a4 + 0xD0);
  if ( !v4 )
    return 0;
  v7 = (std::_Tree_val<std::_Tree_simple_types<int> > *)(a1 + 0x118);
  _Wherenode_1 = *(__int64 **)(a1 + 0x118);
  _Wherenode = _Wherenode_1;
  _Wherenode_2 = (__int64 *)_Wherenode_1[1];
  while ( !*((_BYTE *)_Wherenode_2 + 0x19) )
  {
    if ( *((_DWORD *)_Wherenode_2 + 8) >= v4 )
    {
      _Wherenode = _Wherenode_2;
      _Wherenode_2 = (__int64 *)*_Wherenode_2;
    }
    else
    {
      _Wherenode_2 = (__int64 *)_Wherenode_2[2];
    }
  }
  if ( *((_BYTE *)_Wherenode + 0x19) )
    return 0;
  if ( v4 < *((_DWORD *)_Wherenode + 8) )
    return 0;
  if ( _Wherenode == _Wherenode_1 )
    return 0;
  v11 = _Wherenode[5];
  v12 = *(char **)(v11 + 0x40);
  v13 = *(char **)(v11 + 0x48);
  v14 = v12;
  if ( v12 == v13 )
    return 0;
  while ( *((_QWORD *)v14 + 2) != a2 || *((_QWORD *)v14 + 1) != a3 || *(_QWORD *)v14 != a4 )
  {
    v14 += 0x20;
    if ( v14 == v13 )
      return 0;
  }
  if ( (unsigned __int64)((v13 - v12) >> 5) <= 1 )
  {
    if ( v11 )
      sub_1424D09A0((_QWORD *)_Wherenode[5], 1);
    sub_14166EB00(v7, &v16, _Wherenode);
    return 1;
  }
  else
  {
    memmove(v14, v14 + 0x20, v13 - (v14 + 0x20));
    *(_QWORD *)(v11 + 0x48) -= 0x20LL;
    return 1;
  }
}

// --- End Function: sub_1424E7700 (0x1424E7700) ---

// --- Function: sub_1424E7BF0 (0x1424E7BF0) ---
__int64 __fastcall sub_1424E7BF0(__int64 a1, unsigned int *a2)
{
  unsigned int v2; // ebx
  unsigned int *v3; // rdi
  __int64 v5; // rax
  int v6; // r12d
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // r10
  unsigned __int8 v9; // cl
  unsigned __int8 v10; // r8
  unsigned __int8 v11; // cl
  unsigned __int8 v12; // al
  __int64 v13; // rax
  unsigned __int64 n0x20; // rdx
  __int64 *v15; // r8
  int v16; // r13d
  __int64 v17; // rcx
  int v18; // eax
  __int64 v19; // r14
  __int64 v20; // rax
  unsigned __int64 v21; // r8
  int v22; // eax
  __int64 *v23; // rdi
  unsigned int v24; // ebp
  __int64 *j; // rbx
  __int64 *v26; // rax
  __int64 v27; // rsi
  __int64 v28; // rax
  __int64 **v29; // rax
  __int64 *i; // rax
  __int64 *v31; // rcx
  int v32; // ecx
  int v34; // edx
  unsigned __int8 v35; // bl
  char v36; // r8
  char v37; // bl
  unsigned __int8 v38; // r11
  char v39; // r9
  char v40; // r11
  char v41; // r10
  char v42; // dl
  unsigned __int8 v43; // al
  char v44; // cl
  __int64 v45; // [rsp+20h] [rbp-58h]
  __int64 *v46; // [rsp+28h] [rbp-50h]
  int v47; // [rsp+80h] [rbp+8h]
  unsigned int v49; // [rsp+90h] [rbp+18h]
  unsigned __int64 n0x20_1; // [rsp+98h] [rbp+20h]

  v2 = 0;
  v3 = a2;
  v49 = 0;
  if ( !*(_DWORD *)(a1 + 0x214) )
    return 0;
  v5 = *((_QWORD *)a2 + 5);
  if ( !v5 )
    return 0;
  v6 = *(_DWORD *)(v5 + 0x20);
  if ( !v6 )
    return 0;
  if ( a2[1] == 2 )
    return 0;
  v7 = (a2[7] & 0x55) + ((*((_BYTE *)a2 + 0x1C) >> 1) & 0x55);
  v8 = (v7 & 0x33) + ((v7 >> 2) & 0x33);
  v9 = (((unsigned __int16)(a2[7] & 0xF8FF) >> 8) & 0x55)
     + (((unsigned __int8)((unsigned __int16)(a2[7] & 0xF8FF) >> 8) >> 1) & 0x55);
  v10 = (v9 & 0x33) + ((v9 >> 2) & 0x33);
  v11 = (((a2[7] & 0xFFFFF8FF) >> 0x10) & 0x55) + (((unsigned __int8)((a2[7] & 0xFFFFF8FF) >> 0x10) >> 1) & 0x55);
  v12 = (((((a2[7] & 0xFFFFF8FF) >> 0x18) & 0x55) + (((unsigned __int8)((a2[7] & 0xFFFFF8FF) >> 0x18) >> 1) & 0x55))
       & 0x33)
      + (((unsigned __int8)((((a2[7] & 0xFFFFF8FF) >> 0x18) & 0x55)
                          + (((unsigned __int8)((a2[7] & 0xFFFFF8FF) >> 0x18) >> 1) & 0x55)) >> 2)
       & 0x33);
  if ( (unsigned __int8)((v8 >> 4)
                       + (v8 & 0xF)
                       + (v10 >> 4)
                       + (v10 & 0xF)
                       + ((unsigned __int8)((v11 & 0x33) + ((v11 >> 2) & 0x33)) >> 4)
                       + (((v11 & 0x33) + ((v11 >> 2) & 0x33)) & 0xF)
                       + (v12 >> 4)
                       + (v12 & 0xF)) <= 1u )
    return 0;
  v13 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF50 + 0x168LL))(qword_149C8DF50, *a2);
  n0x20 = 0;
  n0x20_1 = 0;
  v15 = (__int64 *)v13;
  v46 = (__int64 *)v13;
  v16 = 1;
  v17 = *(_QWORD *)(v13 + 8);
  v45 = v17;
  v18 = v3[7] & ~(v6 | 0x700);
  v47 = v18;
  do
  {
    if ( !v18 || v3[1] == 2 )
      break;
    if ( (v16 & v18) != 0 )
    {
      v19 = *v15;
      if ( *v15 != v17 )
      {
        do
        {
          if ( v3[1] == 2 )
            break;
          if ( v16 == *(_DWORD *)(*(_QWORD *)v19 + 0x20LL) )
          {
            v20 = sub_1402A4EC0(*(_QWORD *)v19 + 8LL);
            v21 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++v21;
            while ( *(_BYTE *)(v20 + v21) );
            v22 = psub_140338B20(0xFFFFFFFFLL, v20, v21);
            v23 = *(__int64 **)(a1 + 0xD8);
            v24 = ~v22;
            j = v23;
            v26 = (__int64 *)v23[1];
            while ( !*((_BYTE *)v26 + 0x19) )
            {
              if ( *((_DWORD *)v26 + 8) >= v24 )
              {
                j = v26;
                v26 = (__int64 *)*v26;
              }
              else
              {
                v26 = (__int64 *)v26[2];
              }
            }
            if ( j != v23 )
            {
              while ( *((_DWORD *)j + 8) == v24 )
              {
                v27 = j[5];
                if ( (v6 & *(_DWORD *)(v27 + 0x104)) != 0 )
                {
                  if ( *(_BYTE *)(j[7] + 8) )
                  {
                    v28 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)j[6] + 0x28LL))(j[6]);
                    if ( !(unsigned __int8)sub_1424D0A20(a1, v28) )
                    {
                      if ( *(_DWORD *)(v27 + 0x110) )
                      {
                        v34 = *(_DWORD *)(v27 + 0x104);
                        v3 = a2;
                        v35 = (((v34 & 0x55) + (((unsigned __int8)v34 >> 1) & 0x55)) & 0x33)
                            + (((unsigned __int8)((v34 & 0x55) + (((unsigned __int8)v34 >> 1) & 0x55)) >> 2) & 0x33);
                        v36 = v35 >> 4;
                        v37 = v35 & 0xF;
                        v38 = (((BYTE1(v34) & 0x55) + ((BYTE1(v34) >> 1) & 0x55)) & 0x33)
                            + (((unsigned __int8)((BYTE1(v34) & 0x55) + ((BYTE1(v34) >> 1) & 0x55)) >> 2) & 0x33);
                        v39 = v38 >> 4;
                        v40 = v38 & 0xF;
                        LOBYTE(v34) = (((BYTE2(v34) & 0x55) + ((BYTE2(v34) >> 1) & 0x55)) & 0x33)
                                    + (((unsigned __int8)((BYTE2(v34) & 0x55) + ((BYTE2(v34) >> 1) & 0x55)) >> 2) & 0x33);
                        v41 = (unsigned __int8)v34 >> 4;
                        v42 = v34 & 0xF;
                        v43 = (((HIBYTE(v34) & 0x55) + ((HIBYTE(v34) >> 1) & 0x55)) & 0x33)
                            + (((unsigned __int8)((HIBYTE(v34) & 0x55) + ((HIBYTE(v34) >> 1) & 0x55)) >> 2) & 0x33);
                        v44 = (v43 >> 4) + (v43 & 0xF);
                        if ( v49 > (unsigned __int8)(v44 + v42 + v41 + v40 + v39 + v37 + v36) )
                          goto LABEL_35;
                        v2 = (unsigned __int8)(v44 + v42 + v41 + v40 + v39 + v37 + v36);
                        v49 = v2;
                        goto LABEL_36;
                      }
                    }
                  }
                }
                v29 = (__int64 **)j[2];
                if ( *((_BYTE *)v29 + 0x19) )
                {
                  for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
                  {
                    if ( j != (__int64 *)i[2] )
                      break;
                    j = i;
                  }
                  j = i;
                }
                else
                {
                  v31 = *v29;
                  for ( j = (__int64 *)j[2]; !*((_BYTE *)v31 + 0x19); v31 = (__int64 *)*v31 )
                    j = v31;
                }
                if ( j == v23 )
                  break;
              }
            }
            v3 = a2;
LABEL_35:
            v2 = v49;
          }
LABEL_36:
          v19 += 8;
        }
        while ( v19 != v45 );
        v18 = v47;
        n0x20 = n0x20_1;
        v15 = v46;
      }
    }
    ++n0x20;
    v32 = ~v16;
    v16 = __ROL4__(v16, 1);
    v18 &= v32;
    n0x20_1 = n0x20;
    v17 = v45;
    v47 = v18;
  }
  while ( n0x20 < 0x20 );
  return v2;
}

// --- End Function: sub_1424E7BF0 (0x1424E7BF0) ---

// --- Function: sub_1424EA790 (0x1424EA790) ---
char __fastcall sub_1424EA790(__int64 a1)
{
  __int128 v1; // xmm12
  _UNKNOWN **v2; // rax
  __int64 v3; // r13
  RtAudio::Api *_Whereptr_2; // rsi
  RtAudio::Api *_Whereptr_1; // rbx
  RtAudio::Api *_Whereptr; // rcx
  RtAudio::Api *__Val_0_; // r8
  int n2_1; // ebx
  __int64 v9; // rax
  __int64 v10; // r15
  __int128 v11; // kr00_16
  __int128 v12; // xmm6
  bool v13; // zf
  _QWORD **v15; // rdi
  _QWORD *j; // rbx
  char v17; // r14
  const char *p_blocking_inputs; // rax
  const char *p_$7; // r8
  __int64 v20; // r9
  __int128 n0x40A00000_1; // xmm1
  __int128 n0x40A00000; // kr00_16
  __int128 v23; // kr00_16
  __int64 **v24; // rax
  __int64 i; // rax
  __int64 *v26; // rcx
  int v27; // eax
  __int64 v28; // r15
  __int128 v29; // kr00_16
  __int128 v30; // xmm6
  __int64 v31; // rax
  void *v32; // r13
  _QWORD *v33; // rdi
  __int64 v34; // rax
  _QWORD *v35; // r12
  __int64 v36; // rsi
  char v37; // al
  char v38; // r14
  __int64 *v39; // rbx
  const char *v40; // rax
  const char *p_enabled; // r8
  const char *p_$3; // rdx
  __int128 v43; // kr00_16
  _QWORD *v44; // rbx
  __int128 v45; // kr00_16
  __int128 k; // xmm7
  __int64 *v47; // r15
  const char *v48; // r14
  const char *p_p_Src_1; // rdi
  const char *v50; // rsi
  double v51; // xmm6_8
  const char *v52; // rax
  const char *p_p_Src; // rdi
  __int64 *v54; // rsi
  double v55; // kr00_8
  const char *v56; // rax
  __int128 v57; // kr00_16
  _UNKNOWN **v58; // r14
  __int64 *v59; // rsi
  int v60; // edi
  __int64 v61; // rbx
  const char *v62; // rax
  __int128 v64; // [rsp+68h] [rbp-A0h] BYREF
  _QWORD **v65; // [rsp+78h] [rbp-90h] BYREF
  __int64 p_rw_lock_state; // [rsp+80h] [rbp-88h] BYREF
  void *v67[2]; // [rsp+88h] [rbp-80h] BYREF
  _DWORD v68[3]; // [rsp+98h] [rbp-70h] BYREF
  __int128 v69; // [rsp+A4h] [rbp-64h]
  float v70; // [rsp+B4h] [rbp-54h]
  int v71; // [rsp+B8h] [rbp-50h]
  _BYTE v72[5]; // [rsp+BCh] [rbp-4Ch]
  __int128 v73; // [rsp+C8h] [rbp-40h]
  _UNKNOWN *retaddr; // [rsp+170h] [rbp+68h] BYREF
  int n2; // [rsp+180h] [rbp+78h]
  void *v77; // [rsp+188h] [rbp+80h] BYREF
  __int64 v78; // [rsp+190h] [rbp+88h] BYREF

  v2 = &retaddr;
  v3 = a1;
  if ( *(_BYTE *)(a1 + 0x1A8) )
  {
    sub_1424EC000();
    sub_1424EB4E0(v3);
    *(_DWORD *)(v3 + 0x70) = *(_DWORD *)(v3 + 0x74);
    if ( ((*(_QWORD *)(v3 + 0x80) - *(_QWORD *)(v3 + 0x78)) & 0xFFFFFFFFFFFFFFFCuLL) == 0
      || (LOBYTE(v2) = sub_1402A5430((_DWORD *)(*(_QWORD *)(v3 + 0x80) - 4LL), (_DWORD *)(v3 + 0x70)), (_BYTE)v2) )
    {
      _Whereptr_2 = *(RtAudio::Api **)(v3 + 0x80);
      for ( _Whereptr_1 = *(RtAudio::Api **)(v3 + 0x78);
            _Whereptr_1 != _Whereptr_2;
            _Whereptr_1 = (RtAudio::Api *)((char *)_Whereptr_1 + 4) )
      {
        if ( unknown_libname_19(_Whereptr_1, (_DWORD *)(v3 + 0x70)) )
          break;
      }
      _Whereptr = *(RtAudio::Api **)(v3 + 0x80);
      if ( _Whereptr_1 != _Whereptr )
      {
        memmove(_Whereptr_1, (char *)_Whereptr_1 + 4, _Whereptr - (RtAudio::Api *)((char *)_Whereptr_1 + 4));
        *(_QWORD *)(v3 + 0x80) -= 4LL;
        _Whereptr = *(RtAudio::Api **)(v3 + 0x80);
      }
      __Val_0_ = (RtAudio::Api *)(v3 + 0x70);
      if ( _Whereptr == *(RtAudio::Api **)(v3 + 0x88) )
      {
        LOBYTE(v2) = (unsigned __int8)std::vector<enum RtAudio::Api>::_Emplace_reallocate<enum RtAudio::Api>(
                                        (std::vector<enum RtAudio::Api> *)(v3 + 0x78),
                                        _Whereptr,
                                        __Val_0_);
      }
      else
      {
        LODWORD(v2) = *(_DWORD *)__Val_0_;
        *(_DWORD *)_Whereptr = *(_DWORD *)__Val_0_;
        *(_QWORD *)(v3 + 0x80) += 4LL;
      }
    }
    n2_1 = *(_DWORD *)(v3 + 0x188);
    n2 = n2_1;
    if ( *(_QWORD *)(v3 + 0x188) )
    {
      v9 = *(_QWORD *)qword_149C8DF88;
      v64 = xmmword_1482BB410;
      v10 = (*(__int64 (__fastcall **)(__int64, const wchar_t *))(v9 + 0x18))(qword_149C8DF88, "default");
      v11 = 0;
      *(float *)&v11 = (float)(*(int (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x180LL))(qword_149C8E018)
                     - 100.0;
      v12 = v11;
      *(_DWORD *)&v72[1] = 0;
      v68[0] = 0;
      v71 = 0;
      LOBYTE(v2) = v72[0] & 0xE0 | 3;
      v13 = *(_DWORD *)(v3 + 0x188) == 0;
      v69 = xmmword_1482F8900;
      LODWORD(_XMM7) = 0;
      v70 = 0.0;
      *(float *)&v68[1] = 9.1199999;
      *(float *)&v68[2] = 9.1199999;
      *(_DWORD *)v72 = (unsigned __int8)v2;
      if ( !v13 )
      {
        if ( v10 )
        {
          sub_1405DE870(v3 + 0xB0, (__int64)&v65);
          v15 = (_QWORD **)*v65;
          j = (_QWORD *)**v65;
          if ( j != *v65 )
          {
            v73 = v1;
            do
            {
              v17 = *(_BYTE *)(j[5] + 8LL);
              if ( n2 != 2 || v17 )
              {
                sub_14035E090(&v77);
                p_blocking_inputs = "allowing inputs";
                p_$7 = "$5";
                if ( v17 )
                {
                  p_blocking_inputs = "blocking inputs";
                  p_$7 = "$7";
                }
                sub_1403ACC80(&v77, "%sFilter '%s' %s", p_$7, *(_QWORD *)(j[5] + 0x38LL), p_blocking_inputs);
                LOBYTE(v20) = 1;
                n0x40A00000 = 0x40A00000u;
                *(float *)&n0x40A00000 = *(float *)(*(__int64 (__fastcall **)(__int64, __int64 *, void *, __int64, _DWORD *))(*(_QWORD *)v10 + 0x48LL))(
                                                     v10,
                                                     &v78,
                                                     v77,
                                                     v20,
                                                     v68)
                                       + 5.0;
                n0x40A00000_1 = n0x40A00000;
                __asm { vmaxss  xmm7, xmm1, xmm7 }
                sub_1403A78C0(
                  (__int64 *)qword_149C8E018,
                  40.0,
                  *(float *)&v12,
                  1.2,
                  &v64,
                  0,
                  (__int64)&format_string_,
                  v77);
                v23 = v12;
                *(float *)&v23 = *(float *)&v12 + -12.0;
                v12 = v23;
                sub_140373CC0(&v77);
              }
              v24 = (__int64 **)j[2];
              if ( *((_BYTE *)v24 + 0x19) )
              {
                for ( i = j[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
                {
                  if ( j != *(_QWORD **)(i + 0x10) )
                    break;
                  j = (_QWORD *)i;
                }
                j = (_QWORD *)i;
              }
              else
              {
                v26 = *v24;
                for ( j = (_QWORD *)j[2]; !*((_BYTE *)v26 + 0x19); v26 = (__int64 *)*v26 )
                  j = v26;
              }
            }
            while ( j != v15 );
            v3 = a1;
          }
          LOBYTE(v2) = v67[0];
          v13 = (*(_DWORD *)v67[0])-- == 1;
          if ( v13 )
            LOBYTE(v2) = rw_lock_release_read_lock(p_rw_lock_state);
          n2_1 = n2;
        }
        if ( *(_DWORD *)(v3 + 0x188) )
        {
          v27 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x180LL))(qword_149C8E018);
          v28 = *(_QWORD *)(v3 + 0xA0);
          v29 = 0;
          *(float *)&v29 = (float)v27 - 100.0;
          v30 = v29;
          v31 = *(unsigned int *)(v28 - 4);
          LODWORD(v31) = v31 & 0x7FFFFFFF;
          v78 = v28;
          v2 = (_UNKNOWN **)(v28 + 0x18 * v31);
          v77 = v2;
          if ( (_UNKNOWN **)v28 != v2 )
          {
            v32 = v2;
            do
            {
              sub_140455020((unsigned __int64 *)&v65, (__int64 **)v28);
              sub_140455020((unsigned __int64 *)&p_rw_lock_state, (__int64 **)(v28 + 8));
              sub_14035DE10(v67, (const void **)(v28 + 0x10));
              v33 = v65;
              v34 = *((unsigned int *)v65 + 0xFFFFFFFF);
              LODWORD(v34) = v34 & 0x7FFFFFFF;
              v35 = &v65[v34];
              if ( v65 != v35 )
              {
                do
                {
                  v36 = *v33;
                  v37 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v33 + 0xB8LL))(*v33);
                  v38 = v37;
                  if ( n2_1 != 2 || !v37 )
                  {
                    v39 = (__int64 *)qword_149C8E018;
                    v40 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x90LL))(v36);
                    p_enabled = "disabled";
                    if ( v38 )
                      p_enabled = "enabled";
                    p_$3 = "$4";
                    if ( v38 )
                      p_$3 = "$3";
                    sub_1403A78C0(
                      v39,
                      *(float *)&_XMM7 + 40.0,
                      *(float *)&v30,
                      1.2,
                      &v64,
                      0,
                      (__int64)"%sAction map '%s' %s",
                      p_$3,
                      v40,
                      p_enabled);
                    n2_1 = n2;
                    v43 = v30;
                    *(float *)&v43 = *(float *)&v30 + -12.0;
                    v30 = v43;
                  }
                  ++v33;
                }
                while ( v33 != v35 );
                v28 = v78;
                v32 = v77;
              }
              sub_140373CC0(v67);
              sub_140508F90((unsigned __int64 *)&p_rw_lock_state, 0, 0);
              LOBYTE(v2) = sub_140508F90((unsigned __int64 *)&v65, 0, 0);
              v28 += 0x18;
              v78 = v28;
            }
            while ( (void *)v28 != v32 );
            v3 = a1;
          }
        }
      }
      if ( *(_DWORD *)(v3 + 0x18C) )
      {
        LODWORD(v2) = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x180LL))(qword_149C8E018);
        v44 = *(_QWORD **)(v3 + 0x190);
        v45 = 0;
        *(float *)&v45 = (float)(int)v2 - 40.0;
        for ( k = v45; v44 != *(_QWORD **)(v3 + 0x198); k = v57 )
        {
          if ( *((_WORD *)v44 + 0xC) == 0xFFFF )
          {
            p_p_Src = (const char *)&p_Src;
            v54 = (__int64 *)qword_149C8E018;
            if ( v44[1] )
              p_p_Src = (const char *)v44[1];
            v55 = *((float *)v44 + 5);
            v56 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v44 + 0x90LL))(*v44);
            LOBYTE(v2) = sub_1403A78C0(
                           v54,
                           40.0,
                           *(float *)&k,
                           1.2,
                           &v64,
                           0,
                           (__int64)"%s:%s %.2f triggered by Unknown",
                           v56,
                           p_p_Src,
                           v55);
          }
          else
          {
            v47 = (__int64 *)qword_149C8E018;
            v48 = (const char *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 0x98) + 0xF8LL))(
                                  *(_QWORD *)(v3 + 0x98),
                                  *((unsigned int *)v44 + 4));
            p_p_Src_1 = (const char *)&p_Src;
            v50 = sub_1403B1A90(*((_WORD *)v44 + 0xC));
            v51 = *((float *)v44 + 5);
            if ( v44[1] )
              p_p_Src_1 = (const char *)v44[1];
            v52 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v44 + 0x90LL))(*v44);
            LOBYTE(v2) = sub_1403A78C0(
                           v47,
                           40.0,
                           *(float *)&k,
                           1.2,
                           &v64,
                           0,
                           (__int64)"%s:%s %.2f triggered by %s:%s",
                           v52,
                           p_p_Src_1,
                           v51,
                           v50,
                           v48);
          }
          v44 += 4;
          v57 = k;
          *(float *)&v57 = *(float *)&k + -12.0;
        }
        if ( *(_QWORD *)(v3 + 0x98) )
        {
          LOBYTE(v2) = sub_1403828E0((_WORD *)(v3 + 0x70), 0xFFFFu);
          if ( (_BYTE)v2 )
          {
            v2 = (_UNKNOWN **)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 0x98) + 0x78LL))(
                                *(_QWORD *)(v3 + 0x98),
                                *(unsigned int *)(v3 + 0x70));
            v58 = v2;
            if ( v2 )
            {
              v59 = (__int64 *)qword_149C8E018;
              v60 = (*((__int64 (__fastcall **)(_UNKNOWN **))*v2 + 4))(v2);
              v61 = (*((__int64 (__fastcall **)(_UNKNOWN **))*v58 + 3))(v58);
              v62 = (const char *)(*((__int64 (__fastcall **)(_UNKNOWN **))*v58 + 1))(v58);
              LOBYTE(v2) = sub_1403A78C0(
                             v59,
                             40.0,
                             25.0,
                             1.2,
                             &v64,
                             0,
                             (__int64)"Preferred device: %s (%llu:%d)",
                             v62,
                             v61,
                             v60);
            }
          }
        }
      }
    }
  }
  return (char)v2;
}

// --- End Function: sub_1424EA790 (0x1424EA790) ---

// --- Function: sub_1424EB4E0 (0x1424EB4E0) ---
_UNKNOWN **__fastcall sub_1424EB4E0(_QWORD *a1)
{
  _UNKNOWN **result; // rax
  __int64 v2; // r15
  __int64 v3; // rax
  __int64 v4; // r10
  __int64 v5; // rdi
  __int64 *p_PlayerUICursor_1; // rbx
  __int64 v7; // rcx
  __int64 v8; // r12
  __int64 v9; // r13
  __int64 v10; // r14
  __int64 v11; // rax
  __int64 PlayerUICursor; // rax
  __int64 PlayerUICursor_3; // rax
  _QWORD *v14; // rax
  __int64 PlayerUICursor_4; // rax
  __int64 PlayerUICursor_1; // rax
  bool v17; // r8
  unsigned __int64 v18; // r15
  int *v19; // r14
  int v20; // r12d
  int v21; // ecx
  bool v22; // zf
  __int64 PlayerUICursor_2; // rax
  __int64 v24; // r8
  __int64 v25; // rax
  __int64 v26; // r13
  __int64 *p_PlayerUICursor_4; // rax
  __int64 v28; // r14
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 **p_PlayerUICursor_5; // rax
  __int64 *PlayerUICursor_5; // rbx
  char v33; // r13
  __int64 v34; // rsi
  __int64 *v35; // rax
  __int64 v36; // r12
  __int64 v37; // r15
  __int64 v38; // rdi
  int v39; // eax
  __int64 v40; // r8
  unsigned __int32 v41; // xmm0_4
  _QWORD *v42; // rdi
  char v43; // r12
  __int64 v44; // rsi
  unsigned int v45; // r14d
  int n2; // eax
  __int64 *PlayerUICursor_6; // r15
  __int64 *PlayerUICursor_7; // rbx
  __int64 *v49; // rax
  __int64 v50; // r12
  __int64 v51; // r15
  __int64 v52; // rdi
  unsigned int v53; // r13d
  __int64 v54; // r8
  unsigned __int32 v55; // xmm0_4
  __int64 v56; // rdi
  void (__fastcall *v57)(__int64, const ULONG_PTR *, _QWORD, _QWORD, _QWORD); // rbx
  const ULONG_PTR **v58; // rax
  const ULONG_PTR *p_p_Src; // rdx
  __int64 *p_PlayerUICursor_6; // rbx
  _QWORD *PlayerUICursor_8; // rcx
  _QWORD *PlayerUICursor_9; // rbx
  __int64 v63; // rax
  __int64 v64; // [rsp+38h] [rbp-D0h]
  __int64 *p_PlayerUICursor_3; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v66; // [rsp+48h] [rbp-C0h]
  __int64 v67; // [rsp+50h] [rbp-B8h]
  __int64 v68; // [rsp+58h] [rbp-B0h]
  __int128 v69; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v70; // [rsp+70h] [rbp-98h]
  __int64 v71; // [rsp+78h] [rbp-90h] BYREF
  __int64 v72; // [rsp+80h] [rbp-88h] BYREF
  __int64 v73; // [rsp+88h] [rbp-80h]
  __int64 v74; // [rsp+90h] [rbp-78h]
  const char *v75; // [rsp+98h] [rbp-70h] BYREF
  const char *p_PlayerUICursor_2; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v77; // [rsp+A8h] [rbp-60h]
  __int64 v78; // [rsp+B0h] [rbp-58h]
  const char *p_PlayerUICursor; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v80; // [rsp+C0h] [rbp-48h]
  __int64 v81; // [rsp+C8h] [rbp-40h]
  _QWORD v82[4]; // [rsp+D0h] [rbp-38h] BYREF
  _UNKNOWN *retaddr; // [rsp+160h] [rbp+58h] BYREF
  __int64 v85; // [rsp+170h] [rbp+68h] BYREF
  unsigned __int64 v86; // [rsp+178h] [rbp+70h]
  __int64 v87; // [rsp+180h] [rbp+78h]

  result = &retaddr;
  v2 = (__int64)a1;
  if ( a1[0x41] )
  {
    v72 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                       qword_149C8DF80,
                       0);
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
    if ( v3 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3) )
      v72 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                         qword_149C8DF80,
                         1);
    v4 = v2 + 0x1E8;
    v5 = *(_QWORD *)(v2 + 0x200);
    p_PlayerUICursor_1 = *(__int64 **)(v2 + 0x1E8);
    v7 = v5 + *(_QWORD *)(v2 + 0x208);
    v8 = 0;
    v68 = 0;
    v70 = 0;
    v87 = v2 + 0x1E8;
    v66 = 0;
    v67 = v5;
    p_PlayerUICursor_3 = p_PlayerUICursor_1;
    v69 = 0;
    v9 = 0;
    v10 = 0;
    if ( v5 != v7 )
    {
      while ( 1 )
      {
        v11 = p_PlayerUICursor_1 ? *p_PlayerUICursor_1 : 0LL;
        if ( !*(_DWORD *)(**(_QWORD **)(*(_QWORD *)(v11 + 8) + 8 * (v5 & (*(_QWORD *)(v11 + 0x10) - 1LL))) + 0x10CLL) )
          break;
        if ( p_PlayerUICursor_1 )
          PlayerUICursor = *p_PlayerUICursor_1;
        else
          PlayerUICursor = 0;
        if ( *(_DWORD *)(**(_QWORD **)(*(_QWORD *)(PlayerUICursor + 8)
                                     + 8 * (v5 & (*(_QWORD *)(PlayerUICursor + 0x10) - 1LL)))
                       + 0x10CLL) == 0xFFFFFFFF
          || (!p_PlayerUICursor_1 ? (PlayerUICursor_3 = 0) : (PlayerUICursor_3 = *p_PlayerUICursor_1),
              (v14 = sub_14059CA60(
                       &v72,
                       &v71,
                       (_QWORD *)(**(_QWORD **)(*(_QWORD *)(PlayerUICursor_3 + 8)
                                              + 8 * (v5 & (*(_QWORD *)(PlayerUICursor_3 + 0x10) - 1LL)))
                                + 0xD8LL)),
               v85 = (unsigned int)(int)(float)(10000000.0 * *(float *)(v2 + 0x210)),
               sub_14059CAF0(v14, &v85))
           && (!p_PlayerUICursor_1 ? (PlayerUICursor_4 = 0) : (PlayerUICursor_4 = *p_PlayerUICursor_1),
               *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(PlayerUICursor_4 + 8)
                                     + 8 * (v5 & (*(_QWORD *)(PlayerUICursor_4 + 0x10) - 1LL)))
                         + 0xCLL) != 2)) )
        {
          if ( p_PlayerUICursor_1 )
            PlayerUICursor_1 = *p_PlayerUICursor_1;
          else
            PlayerUICursor_1 = 0;
          v17 = 0;
          v18 = 0;
          *(_DWORD *)(**(_QWORD **)(*(_QWORD *)(PlayerUICursor_1 + 8)
                                  + 8 * (v5 & (*(_QWORD *)(PlayerUICursor_1 + 0x10) - 1LL)))
                    + 0x10CLL) = 0xFFFFFFFF;
          v86 = (v9 - v10) / 0x38;
          if ( v86 )
          {
            v19 = (int *)(v10 + 0x18);
            do
            {
              if ( v17 )
              {
                v8 = v68;
                goto LABEL_39;
              }
              v20 = *v19;
              v21 = *(_DWORD *)(sub_140DCD410(&p_PlayerUICursor_3) + 0x20);
              v17 = v20 == v21;
              ++v18;
              v19 += 0xE;
            }
            while ( v18 < v86 );
            v10 = v69;
            v22 = v20 == v21;
            v8 = v68;
            if ( v22 )
              goto LABEL_40;
          }
          if ( p_PlayerUICursor_1 )
            PlayerUICursor_2 = *p_PlayerUICursor_1;
          else
            PlayerUICursor_2 = 0;
          v24 = *(_QWORD *)(*(_QWORD *)(PlayerUICursor_2 + 8) + 8 * (v5 & (*(_QWORD *)(PlayerUICursor_2 + 0x10) - 1LL)))
              + 8LL;
          if ( v9 == v8 )
          {
            sub_1424CB590((__int64 *)&v69, (_BYTE *)v9, v24);
            v8 = v70;
            v9 = *((_QWORD *)&v69 + 1);
            v68 = v70;
LABEL_39:
            v10 = v69;
          }
          else
          {
            *(__m256i *)v9 = *(__m256i *)v24;
            *(_OWORD *)(v9 + 0x20) = *(_OWORD *)(v24 + 0x20);
            *(double *)(v9 + 0x30) = *(double *)(v24 + 0x30);
            v9 += 0x38;
            *((_QWORD *)&v69 + 1) = v9;
          }
LABEL_40:
          v81 = v5 + 1;
          v80 = 0;
          p_PlayerUICursor = (const char *)p_PlayerUICursor_1;
          v77 = 0;
          p_PlayerUICursor_2 = (const char *)p_PlayerUICursor_1;
          v78 = v5;
          __asm { vzeroupper }
          sub_1424ED480(v87, v82, &p_PlayerUICursor_2, &p_PlayerUICursor);
          v2 = (__int64)a1;
          goto LABEL_41;
        }
        ++v5;
LABEL_42:
        v4 = v2 + 0x1E8;
        v25 = *(_QWORD *)(v2 + 0x200) + *(_QWORD *)(v2 + 0x208);
        v67 = v5;
        if ( v5 == v25 )
          goto LABEL_43;
      }
      v77 = 0;
      v78 = v5 + 1;
      p_PlayerUICursor_2 = (const char *)p_PlayerUICursor_1;
      v80 = 0;
      p_PlayerUICursor = (const char *)p_PlayerUICursor_1;
      v81 = v5;
      sub_1424ED480(v4, v82, &p_PlayerUICursor, &p_PlayerUICursor_2);
LABEL_41:
      p_PlayerUICursor_1 = (__int64 *)v82[0];
      v5 = v82[2];
      p_PlayerUICursor_3 = (__int64 *)v82[0];
      goto LABEL_42;
    }
LABEL_43:
    v26 = v9 - v10;
    result = (_UNKNOWN **)((unsigned __int64)((unsigned __int128)(v26 * (__int128)0x4924924924924925LL) >> 0x40) >> 0x3F);
    v71 = v26 / 0x38;
    if ( v26 / 0x38 )
    {
      v64 = v10;
      while ( 1 )
      {
        v66 = 0;
        p_PlayerUICursor_4 = (__int64 *)sub_1402A65A0(0x18u);
        p_PlayerUICursor_3 = p_PlayerUICursor_4;
        *p_PlayerUICursor_4 = (__int64)p_PlayerUICursor_4;
        p_PlayerUICursor_4[1] = (__int64)p_PlayerUICursor_4;
        if ( !(unsigned __int8)sub_1424D43F0(v2, v10, &p_PlayerUICursor_3) )
          goto LABEL_87;
        v28 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                           qword_149C8DF80,
                           0);
        v29 = *(_QWORD *)qword_149C8DFB8;
        v74 = v28;
        v30 = (*(__int64 (__fastcall **)(__int64))(v29 + 0xA0))(qword_149C8DFB8);
        if ( v30 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x58LL))(v30) )
        {
          v28 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                             qword_149C8DF80,
                             1);
          v74 = v28;
        }
        p_PlayerUICursor_5 = (__int64 **)p_PlayerUICursor_3;
        if ( *(_QWORD *)(v2 + 0x40) != *(_QWORD *)(v2 + 0x48) )
        {
          PlayerUICursor_5 = (__int64 *)*p_PlayerUICursor_3;
          v33 = 0;
          if ( (__int64 *)*p_PlayerUICursor_3 != p_PlayerUICursor_3 )
          {
            v34 = v64;
            v73 = v66;
            while ( 1 )
            {
              v35 = (__int64 *)PlayerUICursor_5[2];
              v36 = v35[2];
              if ( *(_BYTE *)(v36 + 8) )
              {
                v37 = v35[1];
                v38 = *v35;
                v39 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x30LL))(v37);
                v22 = *(_BYTE *)(v34 + 0x31) == 0;
                LODWORD(v86) = v39;
                if ( v22 || (*(_BYTE *)(v38 + 0xC4) & 0x10) != 0 )
                {
                  sub_1424DDE80((__int64)a1, (unsigned int *)v34, v38, v28);
                  v40 = v37;
                  v2 = (__int64)a1;
                  LODWORD(v87) = *(_DWORD *)(v38 + 0x110);
                  v41 = sub_1424D2B80((__int64)a1, v36, v40, v38, v34, &v85).m128_u32[0];
                  if ( !*(_BYTE *)(v34 + 0x30) || COERCE_FLOAT(v41 & 0x7FFFFFFF) >= 0.00000011920929 )
                  {
                    v42 = (_QWORD *)a1[8];
                    v43 = 0;
                    if ( v42 != (_QWORD *)a1[9] )
                    {
                      v44 = v73;
                      v45 = v86;
                      do
                      {
                        n2 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*v42 + 8LL))(
                               *v42,
                               v45,
                               (unsigned int)v87);
                        if ( n2 == 3 )
                        {
                          v33 = 1;
                        }
                        else if ( n2 == 2 && !v33 && !v43 )
                        {
                          --v44;
                          PlayerUICursor_6 = (__int64 *)*PlayerUICursor_5;
                          *(_QWORD *)PlayerUICursor_5[1] = *PlayerUICursor_5;
                          *(_QWORD *)(*PlayerUICursor_5 + 8) = PlayerUICursor_5[1];
                          sub_1402A6590((__int64)PlayerUICursor_5);
                          PlayerUICursor_5 = PlayerUICursor_6;
                          v43 = 1;
                          v2 = (__int64)a1;
                        }
                        ++v42;
                      }
                      while ( v42 != *(_QWORD **)(v2 + 0x48) );
                      v28 = v74;
                      v73 = v44;
                      v34 = v64;
                      if ( v43 )
                        goto LABEL_69;
                    }
                  }
                }
                else
                {
                  v2 = (__int64)a1;
                }
              }
              PlayerUICursor_5 = (__int64 *)*PlayerUICursor_5;
LABEL_69:
              p_PlayerUICursor_5 = (__int64 **)p_PlayerUICursor_3;
              if ( PlayerUICursor_5 == p_PlayerUICursor_3 )
              {
                if ( v33 )
                  goto LABEL_86;
                break;
              }
            }
          }
        }
        PlayerUICursor_7 = *p_PlayerUICursor_5;
        if ( *p_PlayerUICursor_5 == (__int64 *)p_PlayerUICursor_5 )
          goto LABEL_86;
        while ( 1 )
        {
          v49 = (__int64 *)PlayerUICursor_7[2];
          v50 = v49[2];
          if ( *(_BYTE *)(v50 + 8) )
            break;
LABEL_81:
          PlayerUICursor_7 = (__int64 *)*PlayerUICursor_7;
          if ( PlayerUICursor_7 == p_PlayerUICursor_3 )
            goto LABEL_86;
        }
        v51 = v49[1];
        v52 = *v49;
        v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v51 + 0x30LL))(v51);
        if ( *(_BYTE *)(v64 + 0x31) && (*(_BYTE *)(v52 + 0xC4) & 0x10) == 0 )
        {
          v2 = (__int64)a1;
          goto LABEL_81;
        }
        sub_1424DDE80((__int64)a1, (unsigned int *)v64, v52, v28);
        v54 = v51;
        v2 = (__int64)a1;
        LODWORD(v86) = *(_DWORD *)(v52 + 0x110);
        LOBYTE(v85) = 0;
        v55 = sub_1424D2B80((__int64)a1, v50, v54, v52, v64, &v85).m128_u32[0];
        if ( (_BYTE)v85 || *(_BYTE *)(v64 + 0x30) && COERCE_FLOAT(v55 & 0x7FFFFFFF) < 0.00000011920929 )
          goto LABEL_81;
        if ( (*(_BYTE *)(v52 + 0xC4) & 0x40) == 0 )
          break;
        v56 = qword_149C8DFD0;
        v57 = *(void (__fastcall **)(__int64, const ULONG_PTR *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149C8DFD0
                                                                                        + 0x130LL);
        v58 = (const ULONG_PTR **)sub_140592FE0(&v75, v53);
        p_p_Src = &p_Src;
        if ( *v58 )
          p_p_Src = *v58;
        v57(v56, p_p_Src, 0, 0, 0);
        sub_1403E63B0((__int64)&v75, v75);
        sub_1424DB390((__int64)a1, v53, v86);
LABEL_86:
        v10 = v64;
LABEL_87:
        p_PlayerUICursor_6 = p_PlayerUICursor_3;
        *(_QWORD *)p_PlayerUICursor_3[1] = 0;
        PlayerUICursor_8 = (_QWORD *)*p_PlayerUICursor_6;
        if ( *p_PlayerUICursor_6 )
        {
          do
          {
            PlayerUICursor_9 = (_QWORD *)*PlayerUICursor_8;
            sub_1402A6590((__int64)PlayerUICursor_8);
            PlayerUICursor_8 = PlayerUICursor_9;
          }
          while ( PlayerUICursor_9 );
          p_PlayerUICursor_6 = p_PlayerUICursor_3;
        }
        result = (_UNKNOWN **)sub_1402A6590((__int64)p_PlayerUICursor_6);
        v10 += 0x38;
        v22 = v71-- == 1;
        v64 = v10;
        if ( v22 )
        {
          v10 = v69;
          goto LABEL_92;
        }
      }
      sub_1424DB390((__int64)a1, v53, v86);
      sub_1424E4210((_QWORD *)v50, v53, v86);
      goto LABEL_81;
    }
LABEL_92:
    if ( v10 )
    {
      v63 = v10;
      if ( (unsigned __int64)(0x38 * ((v68 - v10) / 0x38)) >= 0x1000 )
      {
        v10 = *(_QWORD *)(v10 - 8);
        if ( (unsigned __int64)(v63 - v10 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      return (_UNKNOWN **)sub_1402A6590(v10);
    }
  }
  return result;
}

// --- End Function: sub_1424EB4E0 (0x1424EB4E0) ---

// --- Function: sub_1424EC000 (0x1424EC000) ---
__int64 __fastcall sub_1424EC000(__int64 a1)
{
  __int64 v1; // r13
  __int64 v2; // rax
  __int64 *v3; // r15
  gte::Vector<3,double> *v4; // r14
  __int64 v5; // r12
  _QWORD *v6; // rsi
  _QWORD *k; // rdi
  __int64 v8; // rbx
  __int64 *v9; // rax
  gte::Vector<3,double> *v10; // rax
  __int64 v11; // r14
  gte::Vector<3,double> *v12; // r15
  __int128 v13; // xmm1
  _QWORD *v14; // rcx
  _QWORD *v15; // rbx
  gte::Vector<3,double> *v16; // rcx
  gte::Vector<3,double> **v17; // rax
  __int64 v18; // r12
  gte::Vector<3,double> *v19; // rbx
  __int64 v20; // r12
  _QWORD *v21; // r15
  _QWORD *v22; // r13
  _QWORD *i; // rbx
  __int64 v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rax
  _QWORD *v27; // rbx
  _QWORD *v28; // rcx
  __int64 *v29; // r14
  _QWORD *v30; // rcx
  _QWORD *v31; // rbx
  __int64 **v32; // rax
  __int64 j; // rax
  __int64 *v34; // rcx
  __int64 *v35; // rsi
  __int64 v36; // rdi
  __int64 v37; // rbx
  __int64 *v38; // rdi
  _QWORD **v39; // rcx
  _QWORD *v40; // rcx
  _QWORD *v41; // rbx
  gte::Vector<3,double> *m; // rbx
  gte::Vector<3,double> *v43; // rcx
  gte::Vector<3,double> *v44; // rbx
  __int64 *v45; // rax
  gte::Vector<3,double> *v46; // rcx
  gte::Vector<3,double> *v47; // rbx
  __int128 v49; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v50; // [rsp+40h] [rbp-C0h]
  gte::Vector<3,double> *v51; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v52; // [rsp+50h] [rbp-B0h]
  __int64 *v53[2]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v54[3]; // [rsp+68h] [rbp-98h] BYREF
  __m256 v55; // [rsp+80h] [rbp-80h] BYREF
  __int128 v56; // [rsp+A0h] [rbp-60h]
  __int64 v57; // [rsp+B0h] [rbp-50h]
  gte::Vector<3,double> *v58; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v59; // [rsp+C0h] [rbp-40h]
  int n0x4500; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v61; // [rsp+D4h] [rbp-2Ch]
  int v62; // [rsp+DCh] [rbp-24h]
  unsigned __int64 v63; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v64; // [rsp+E8h] [rbp-18h]
  __int64 v65; // [rsp+F0h] [rbp-10h]
  __int64 v66; // [rsp+F8h] [rbp-8h]
  __int64 v68; // [rsp+168h] [rbp+68h]
  __int64 v69; // [rsp+170h] [rbp+70h]

  n0x4500 = 0x4500;
  v62 = 0;
  v1 = a1;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v61 = 1;
  v63 = __rdtsc();
  qword_149C89AA0(
    &n0x4500,
    &word_149F0AA5C,
    "CActionMapManager::UpdateRefiringInputs",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\ActionMapManager.cpp",
    0xB69);
  HIWORD(n0x4500) = word_149F0AA5C;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFD0 + 0x168LL))(qword_149C8DFD0) )
  {
    if ( !(_BYTE)qword_149C8E516
      || (v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8),
          !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x308LL))(v2)) )
    {
      *(_BYTE *)(v1 + 0x1A9) = 1;
      v54[1] = 0;
      v49 = 0;
      v3 = 0;
      v4 = std::allocator<gte::Vector<3,double>>::allocate((std::allocator<gte::Vector<3,double> > *)v54, 1u);
      *(_QWORD *)v4 = v4;
      v5 = 0;
      *((_QWORD *)v4 + 1) = v4;
      v6 = *(_QWORD **)(v1 + 0x118);
      v54[0] = (__int64)v4;
      v69 = 0;
      v50 = 0;
      k = (_QWORD *)*v6;
      if ( (_QWORD *)*v6 != v6 )
      {
        v68 = 0;
        do
        {
          v8 = k[5];
          v53[1] = 0;
          v9 = (__int64 *)std::allocator<gte::Vector<3,double>>::allocate(
                            (std::allocator<gte::Vector<3,double> > *)v53,
                            1u);
          v53[0] = v9;
          v52 = 0;
          *v9 = (__int64)v9;
          v9[1] = (__int64)v9;
          v10 = std::allocator<gte::Vector<3,double>>::allocate((std::allocator<gte::Vector<3,double> > *)&v51, 1u);
          v51 = v10;
          *(_QWORD *)v10 = v10;
          *((_QWORD *)v10 + 1) = v10;
          if ( (unsigned __int8)sub_1424D4DF0(v1, v8, (__int64 *)v53, v54, (__int64 *)&v51) )
            sub_1424DD9D0(v1, v8 + 8, v53);
          v11 = (__int64)v51;
          if ( v52 )
          {
            sub_1424CEFC0((__int64)&v55);
            v58 = 0;
            v59 = 0;
            v12 = std::allocator<gte::Vector<3,double>>::allocate((std::allocator<gte::Vector<3,double> > *)&v58, 1u);
            *(_QWORD *)v12 = v12;
            *((_QWORD *)v12 + 1) = v12;
            v13 = *(_OWORD *)(v8 + 0x28);
            v55 = *(__m256 *)(v8 + 8);
            v57 = *(_QWORD *)(v8 + 0x38);
            v58 = v12;
            v56 = v13;
            LODWORD(v55.m256_f32[1]) = 2;
            v14 = *(_QWORD **)v11;
            if ( *(_QWORD *)v11 != v11 )
            {
              do
              {
                *(_DWORD *)(*(_QWORD *)v14[2] + 0x110LL) = 2;
                v14 = (_QWORD *)*v14;
              }
              while ( v14 != (_QWORD *)v11 );
              v12 = v58;
            }
            v15 = *(_QWORD **)v11;
            v16 = *(gte::Vector<3,double> **)v12;
            if ( *(_QWORD *)v11 == v11 )
            {
LABEL_15:
              if ( v16 != v12 )
              {
                v17 = (gte::Vector<3,double> **)*((_QWORD *)v16 + 1);
                v18 = 0;
                *v17 = v12;
                *((_QWORD *)v12 + 1) = v17;
                do
                {
                  v19 = *(gte::Vector<3,double> **)v16;
                  __asm { vzeroupper }
                  sub_1402A6590((__int64)v16);
                  ++v18;
                  v16 = v19;
                }
                while ( v19 != v12 );
                v59 -= v18;
              }
            }
            else
            {
              while ( v16 != v12 )
              {
                *((_QWORD *)v16 + 2) = v15[2];
                v15 = (_QWORD *)*v15;
                v16 = *(gte::Vector<3,double> **)v16;
                if ( v15 == (_QWORD *)v11 )
                  goto LABEL_15;
              }
              v20 = 0;
              v21 = 0;
              v22 = 0;
              if ( v15 != (_QWORD *)v11 )
              {
                __asm { vzeroupper }
                v21 = (_QWORD *)sub_1402A65A0(0x18u);
                v22 = v21;
                v20 = 1;
                v21[2] = v15[2];
                for ( i = (_QWORD *)*v15; i != (_QWORD *)v11; i = (_QWORD *)*i )
                {
                  v24 = sub_1402A65A0(0x18u);
                  ++v20;
                  *(_QWORD *)(v24 + 0x10) = i[2];
                  *v21 = v24;
                  *(_QWORD *)(v24 + 8) = v21;
                  v21 = (_QWORD *)v24;
                }
              }
              v25 = (__int64)v58;
              if ( v20 )
              {
                v26 = (_QWORD *)*((_QWORD *)v58 + 1);
                v22[1] = v26;
                *v26 = v22;
                *v21 = v25;
                *(_QWORD *)(v25 + 8) = v21;
                v59 += v20;
              }
              v1 = a1;
            }
            if ( v68 == v69 )
            {
              __asm { vzeroupper }
              sub_1424CB7A0((unsigned __int64 *)&v49, v68, (__int64)&v55);
              v3 = (__int64 *)*((_QWORD *)&v49 + 1);
              v69 = v50;
            }
            else
            {
              __asm { vzeroupper }
              sub_1424CF010(v68, (__int64)&v55);
              v3 = (__int64 *)(v68 + 0x48);
              *((_QWORD *)&v49 + 1) = v68 + 0x48;
            }
            v68 = (__int64)v3;
            sub_1403FB1C0((__int64 *)&v58);
          }
          v27 = 0;
          **(_QWORD **)(v11 + 8) = 0;
          v28 = *(_QWORD **)v11;
          if ( *(_QWORD *)v11 )
          {
            do
            {
              v27 = (_QWORD *)*v28;
              sub_1402A6590((__int64)v28);
              v28 = v27;
            }
            while ( v27 );
          }
          sub_1402A6590(v11);
          v29 = v53[0];
          **((_QWORD **)v53[0] + 1) = v27;
          v30 = (_QWORD *)*v29;
          if ( *v29 )
          {
            do
            {
              v31 = (_QWORD *)*v30;
              sub_1402A6590((__int64)v30);
              v30 = v31;
            }
            while ( v31 );
          }
          sub_1402A6590((__int64)v29);
          v32 = (__int64 **)k[2];
          if ( *((_BYTE *)v32 + 0x19) )
          {
            for ( j = k[1]; !*(_BYTE *)(j + 0x19); j = *(_QWORD *)(j + 8) )
            {
              if ( k != *(_QWORD **)(j + 0x10) )
                break;
              k = (_QWORD *)j;
            }
            k = (_QWORD *)j;
          }
          else
          {
            v34 = *v32;
            for ( k = (_QWORD *)k[2]; !*((_BYTE *)v34 + 0x19); v34 = (__int64 *)*v34 )
              k = v34;
          }
        }
        while ( k != v6 );
        v4 = (gte::Vector<3,double> *)v54[0];
        v5 = v69;
      }
      v35 = (__int64 *)v49;
      v36 = (__int64)((__int64)v3 - v49) / 0x48;
      if ( v36 )
      {
        v37 = v49;
        do
        {
          sub_1424DD9D0(v1, v37, (__int64 **)(v37 + 0x38));
          v37 += 0x48;
          --v36;
        }
        while ( v36 );
      }
      if ( v35 != v3 )
      {
        v38 = v35 + 7;
        do
        {
          v39 = (_QWORD **)*v38;
          **(_QWORD **)(*v38 + 8) = 0;
          v40 = *v39;
          if ( v40 )
          {
            do
            {
              v41 = (_QWORD *)*v40;
              sub_1402A6590((__int64)v40);
              v40 = v41;
            }
            while ( v41 );
          }
          sub_1402A6590(*v38);
          v38 += 9;
        }
        while ( v38 + 0xFFFFFFF9 != v3 );
        v3 = v35;
      }
      *(_BYTE *)(v1 + 0x1A9) = 0;
      for ( m = *(gte::Vector<3,double> **)v4; m != v4; m = *(gte::Vector<3,double> **)m )
        sub_1424E7700(
          v1,
          *(_QWORD *)(*((_QWORD *)m + 2) + 0x10LL),
          *(_QWORD *)(*((_QWORD *)m + 2) + 8LL),
          **((_QWORD **)m + 2));
      **((_QWORD **)v4 + 1) = 0;
      v43 = *(gte::Vector<3,double> **)v4;
      if ( *(_QWORD *)v4 )
      {
        do
        {
          v44 = *(gte::Vector<3,double> **)v43;
          sub_1402A6590((__int64)v43);
          v43 = v44;
        }
        while ( v44 );
      }
      *(_QWORD *)v4 = v4;
      *((_QWORD *)v4 + 1) = v4;
      if ( *(_BYTE *)(v1 + 0x1AA) )
      {
        *(_BYTE *)(v1 + 0x1AA) = 0;
        sub_1424E6B60(v1);
      }
      if ( v35 )
      {
        sub_1424CB2C0(v35, v3);
        v45 = v35;
        if ( (unsigned __int64)(0x48 * ((v5 - (__int64)v35) / 0x48)) >= 0x1000 )
        {
          v35 = (__int64 *)v35[0xFFFFFFFF];
          if ( (unsigned __int64)((char *)v45 - (char *)v35 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_1402A6590((__int64)v35);
      }
      **((_QWORD **)v4 + 1) = 0;
      v46 = *(gte::Vector<3,double> **)v4;
      if ( *(_QWORD *)v4 )
      {
        do
        {
          v47 = *(gte::Vector<3,double> **)v46;
          sub_1402A6590((__int64)v46);
          v46 = v47;
        }
        while ( v47 );
      }
      sub_1402A6590((__int64)v4);
    }
  }
  v64 = __rdtsc();
  return qword_149C89AA8(&n0x4500);
}

// --- End Function: sub_1424EC000 (0x1424EC000) ---

// --- Function: sub_1424ED480 (0x1424ED480) ---
__int64 **__fastcall sub_1424ED480(__int64 a1, __int64 **a2, const char **p_p_PlayerUICursor, const char **a4)
{
  const char *v4; // r10
  const char *v5; // r9
  __int64 *v7; // rdx
  __int64 *v8; // rbx
  const char *v9; // rsi
  const char *v10; // r14
  __int64 v11; // r8
  const char *v12; // rbp
  __int64 v13; // rdi
  __int64 v14; // rbx
  __m256i *v15; // rdx
  __m256i v16; // ymm0
  __m256i v17; // ymm1
  __m256i *v18; // rdx
  bool v19; // zf
  __int64 v20; // rdi
  __int64 v21; // rbx
  const char *v22; // rsi
  const char *v23; // r15
  __int64 v24; // rdx
  __m256i *v25; // rdx
  __m256i v26; // ymm0
  __m256i v27; // ymm1
  __int64 v28; // rdx
  __m256i *v29; // rdx
  __int64 *v30; // rax
  __int64 **result; // rax

  v4 = p_p_PlayerUICursor[2];
  v5 = a4[2];
  if ( a1 )
  {
    v7 = *(__int64 **)a1;
    v8 = *(__int64 **)a1;
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  v9 = *(const char **)(a1 + 0x18);
  v10 = (const char *)(v4 - v9);
  v11 = v5 - v4;
  if ( v5 == v4 )
  {
    *a2 = v7;
    a2[2] = (__int64 *)v4;
  }
  else
  {
    v12 = &v9[*(_QWORD *)(a1 + 0x20)];
    if ( (unsigned __int64)v10 >= v12 - v5 )
    {
      if ( v8 )
        v20 = *v8;
      else
        v20 = 0;
      if ( v7 )
        v21 = *v7;
      else
        v21 = 0;
      if ( v5 != v12 )
      {
        v22 = v4;
        v23 = v5;
        do
        {
          v24 = (unsigned __int64)v5 & (*(_QWORD *)(v20 + 0x10) - 1LL);
          v5 = v23 + 1;
          v23 = v5;
          v25 = *(__m256i **)(*(_QWORD *)(v20 + 8) + 8 * v24);
          v26 = *v25;
          v27 = v25[1];
          v28 = (unsigned __int64)v4 & (*(_QWORD *)(v21 + 0x10) - 1LL);
          v4 = ++v22;
          v29 = *(__m256i **)(*(_QWORD *)(v21 + 8) + 8 * v28);
          *v29 = v26;
          v29[1] = v27;
        }
        while ( v5 != v12 );
      }
      do
      {
        v19 = (*(_QWORD *)(a1 + 0x20))-- == 1;
        if ( v19 )
          *(_QWORD *)(a1 + 0x18) = 0;
        --v11;
      }
      while ( v11 );
    }
    else
    {
      if ( v7 )
        v13 = *v7;
      else
        v13 = 0;
      if ( v8 )
        v14 = *v8;
      else
        v14 = 0;
      for ( ; v4 != v9; v18[1] = v17 )
      {
        --v4;
        --v5;
        v15 = *(__m256i **)(*(_QWORD *)(v13 + 8) + 8 * ((unsigned __int64)v4 & (*(_QWORD *)(v13 + 0x10) - 1LL)));
        v16 = *v15;
        v17 = v15[1];
        v18 = *(__m256i **)(*(_QWORD *)(v14 + 8) + 8 * ((unsigned __int64)v5 & (*(_QWORD *)(v14 + 0x10) - 1LL)));
        *v18 = v16;
      }
      do
      {
        v19 = (*(_QWORD *)(a1 + 0x20))-- == 1;
        if ( v19 )
          *(_QWORD *)(a1 + 0x18) = 0;
        else
          ++*(_QWORD *)(a1 + 0x18);
        --v11;
      }
      while ( v11 );
    }
    v30 = *(__int64 **)a1;
    a2[2] = (__int64 *)&v10[*(_QWORD *)(a1 + 0x18)];
    *a2 = v30;
  }
  result = a2;
  a2[1] = 0;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1424ED480 (0x1424ED480) ---

// --- Function: sub_1425065F0 (0x1425065F0) ---
__int64 __fastcall sub_1425065F0(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rcx

  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x40) + 0x18LL))(*(_QWORD *)(a1 + 0x40));
  v3 = *(_QWORD *)(a1 + 0x38);
  if ( v3 )
  {
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x38LL))(v3);
    if ( (_BYTE)result )
      return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x38) + 0x40LL))(*(_QWORD *)(a1 + 0x38));
  }
  return result;
}

// --- End Function: sub_1425065F0 (0x1425065F0) ---

// --- Function: sub_1425530A0 (0x1425530A0) ---
_QWORD *__fastcall sub_1425530A0(_QWORD *a1)
{
  *a1 = off_14870A0F0;
  return a1;
}

// --- End Function: sub_1425530A0 (0x1425530A0) ---

// --- Function: sub_142570300 (0x142570300) ---
__m128 __fastcall sub_142570300(__int64 a1, float a2)
{
  int v2; // r8d
  int v5; // edx
  __int128 n0x3D000000_1; // xmm0
  __int128 n0x3D000000; // kr00_16
  __int128 v9; // kr00_16

  v2 = 0;
  _XMM3 = 0;
  __asm { vroundss xmm3, xmm3, xmm0, 1 }
  v5 = (int)*(float *)&_XMM3;
  n0x3D000000 = 0x3D000000u;
  *(float *)&n0x3D000000 = (float)(0.03125 - (float)(a2 - (float)(*(float *)&_XMM3 * 0.03125))) * 32.0;
  n0x3D000000_1 = n0x3D000000;
  LODWORD(_XMM5) = 0;
  if ( (int)*(float *)&_XMM3 < 0x1F )
    v2 = v5 + 1;
  if ( *(float *)&n0x3D000000 >= 0.0 )
    __asm { vminss  xmm5, xmm0, xmm3 }
  v9 = 0;
  *(float *)&v9 = (float)((float)((float)*(unsigned __int16 *)(a1 + 2LL * v2) * 0.000015259022)
                        * (float)(1.0 - *(float *)&_XMM5))
                + (float)((float)((float)*(unsigned __int16 *)(a1 + 2LL * v5) * 0.000015259022) * *(float *)&_XMM5);
  return (__m128)v9;
}

// --- End Function: sub_142570300 (0x142570300) ---

// --- Function: sub_142573E60 (0x142573E60) ---
__int64 __fastcall sub_142573E60(__int64 a1, float a2)
{
  __int128 v2; // xmm6
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int64 result; // rax
  float *v10; // rbx
  float *v11; // rdi
  float *v12; // rax
  float v13; // xmm0_4
  __int128 v14; // kr00_16
  __int128 v15; // kr00_16
  __int128 v17; // kr00_16
  __int128 v18; // kr00_16
  __int64 v20; // rax
  __int16 v21; // ax
  __int128 v22; // [rsp+20h] [rbp-88h] BYREF
  _WORD v23[2]; // [rsp+30h] [rbp-78h] BYREF
  int v24; // [rsp+34h] [rbp-74h]
  float v25; // [rsp+38h] [rbp-70h]
  float v26; // [rsp+3Ch] [rbp-6Ch]
  __int128 v27; // [rsp+44h] [rbp-64h]
  __int128 v28; // [rsp+60h] [rbp-48h]
  __int128 v29; // [rsp+70h] [rbp-38h]
  __int128 v30; // [rsp+80h] [rbp-28h]
  __int128 v31; // [rsp+90h] [rbp-18h]
  char v32; // [rsp+B0h] [rbp+8h] BYREF

  v30 = _XMM7;
  v29 = v4;
  v31 = v2;
  v28 = v5;
  LODWORD(_XMM7) = 0;
  _XMM6 = 0;
  _XMM8 = 0;
  sub_14036F6D0(&v22);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x4D8LL))(qword_149C8DFE0);
  if ( (_BYTE)result || a2 <= 0.001 )
    goto LABEL_14;
  v10 = *(float **)(a1 + 0xD0);
  if ( v10 != *(float **)(a1 + 0xD8) )
  {
    v11 = v10 + 0x3B;
    do
    {
      v12 = (float *)sub_142574200(v10, &v32);
      v13 = v11[0xFFFFFFC8];
      v14 = _XMM6;
      *(float *)&v14 = *(float *)&_XMM6 + *v12;
      _XMM6 = v14;
      v15 = _XMM8;
      *(float *)&v15 = *(float *)&_XMM8 + v12[1];
      _XMM8 = v15;
      if ( v13 > 0.0 && v13 < v11[0xFFFFFFC9] )
      {
        memmove(v10, v11, *(_QWORD *)(a1 + 0xD8) - (_QWORD)v11);
        *(_QWORD *)(a1 + 0xD8) -= 0xECLL;
      }
      else
      {
        v10 += 0x3B;
        v11 += 0x3B;
      }
    }
    while ( v10 != *(float **)(a1 + 0xD8) );
  }
  v17 = _XMM6;
  *(float *)&v17 = *(float *)&_XMM6 + *(float *)(a1 + 0x100);
  _XMM6 = v17;
  v18 = _XMM8;
  *(float *)&v18 = *(float *)&_XMM8 + *(float *)(a1 + 0x104);
  _XMM8 = v18;
  sub_140387DF0((__int64)&v22, a1 + 0x108);
  *(_QWORD *)(a1 + 0x100) = 0;
  result = sub_1403BE260(a1 + 0x108, 0);
  if ( *(float *)&v18 >= 0.0 )
LABEL_14:
    __asm { vminss  xmm8, xmm8, cs:Y }
  else
    LODWORD(_XMM8) = 0;
  if ( *(float *)&_XMM6 >= 0.0 )
    __asm { vminss  xmm7, xmm6, cs:Y }
  if ( qword_149C8DF50 )
  {
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xD8LL))(qword_149C8DFB8);
    if ( result )
    {
      sub_14036F660((__int64)v23);
      v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xD8LL))(qword_149C8DFB8);
      v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x10LL))(v20);
      v26 = *(float *)&_XMM7;
      v25 = *(float *)&_XMM8;
      v23[0] = v21;
      v24 = 1;
      v27 = v22;
      return (*(__int64 (__fastcall **)(__int64, _WORD *))(*(_QWORD *)qword_149C8DF50 + 0xB8LL))(qword_149C8DF50, v23);
    }
  }
  return result;
}

// --- End Function: sub_142573E60 (0x142573E60) ---

// --- Function: sub_142574200 (0x142574200) ---
__int64 __fastcall sub_142574200(__int64 a1, __int64 a2, float a3)
{
  __int128 n0x3F800000; // xmm7
  __int128 v8; // xmm8
  float v9; // xmm1_4
  __int128 v10; // xmm13
  __int128 v11; // xmm4
  __int128 v12; // kr00_16
  __int128 v17; // kr00_16
  int n0xE; // eax
  __int64 v25; // rcx
  __int128 n0x3D800000_1; // xmm9
  __int128 n0x3D800000; // kr00_16
  __int64 n0xE_1; // rsi
  __int128 v32; // kr00_16
  __int128 n0x3F800000_2; // xmm0
  __int128 n0x3F800000_1; // kr00_16

  _XMM0 = *(unsigned int *)(a1 + 8);
  LODWORD(_XMM6) = 0;
  *(_QWORD *)a2 = 0;
  if ( *(float *)&_XMM0 > 0.0 )
  {
    if ( (float)(*(float *)&_XMM0 - a3) >= 0.0 )
      __asm { vminss  xmm6, xmm0, xmm1 }
    *(float *)(a1 + 8) = *(float *)&_XMM6;
    return a2;
  }
  else
  {
    n0x3F800000 = 0x3F800000u;
    v8 = *(unsigned int *)(a1 + 0xC);
    if ( *(float *)&v8 == 0.0 )
      v9 = 1.0;
    else
      v9 = 1.0 / COERCE_FLOAT(v8 & 0x7FFFFFFF);
    v10 = *(unsigned int *)(a1 + 0x10);
    v12 = v10;
    *(float *)&v12 = *(float *)&v10 * v9;
    v11 = v12;
    *(float *)&v12 = (float)(*(float *)&v10 * v9) * *(float *)(a1 + 0x14);
    _XMM1 = 0;
    __asm { vroundss xmm1, xmm1, xmm2, 1 }
    *(float *)&v12 = *(float *)&v12 - *(float *)&_XMM1;
    _XMM3 = v12;
    if ( *(float *)&v12 >= 0.0 )
      __asm { vminss  xmm5, xmm3, xmm7 }
    else
      LODWORD(_XMM5) = 0;
    v17 = v11;
    _XMM1 = 0;
    __asm { vroundss xmm1, xmm1, xmm2, 1 }
    *(float *)&v17 = (float)(*(float *)&v11 * *(float *)(a1 + 0x18)) - *(float *)&_XMM1;
    _XMM3 = v17;
    if ( *(float *)&v17 >= 0.0 )
      __asm { vminss  xmm11, xmm3, xmm7 }
    else
      LODWORD(_XMM11) = 0;
    _XMM1 = 0;
    __asm { vroundss xmm1, xmm1, xmm0, 1 }
    n0xE = (int)*(float *)&_XMM1;
    v25 = a1 + 0x1C;
    n0x3D800000 = 0x3D800000u;
    *(float *)&n0x3D800000 = (float)(0.0625 - (float)(*(float *)&v11 - (float)(*(float *)&_XMM1 * 0.0625))) * 16.0;
    n0x3D800000_1 = n0x3D800000;
    if ( (int)*(float *)&_XMM1 >= 0xF )
      n0xE = 0xE;
    if ( *(float *)&n0x3D800000 >= 0.0 )
      __asm { vminss  xmm10, xmm9, xmm7 }
    else
      LODWORD(_XMM10) = 0;
    n0xE_1 = n0xE;
    *(float *)a2 = (float)(sub_142570300(v25, *(float *)&_XMM5).m128_f32[0]
                         * (float)((float)((float)((float)*(unsigned __int16 *)(a1 + 2LL * n0xE + 0x62) * 0.000015259022)
                                         * (float)(1.0 - *(float *)&_XMM10))
                                 + (float)((float)((float)*(unsigned __int16 *)(a1 + 2LL * n0xE + 0x60) * 0.000015259022)
                                         * *(float *)&_XMM10)))
                 * *(float *)(a1 + 4);
    if ( *(float *)&n0x3D800000 >= 0.0 )
      __asm { vminss  xmm9, xmm9, xmm7 }
    else
      LODWORD(_XMM9) = 0;
    v32 = v10;
    *(float *)&v32 = *(float *)&v10 + a3;
    _XMM2 = v32;
    *(float *)(a2 + 4) = (float)(sub_142570300(a1 + 0x84, *(float *)&_XMM11).m128_f32[0]
                               * (float)((float)((float)((float)*(unsigned __int16 *)(a1 + 2 * n0xE_1 + 0xCA)
                                                       * 0.000015259022)
                                               * (float)(1.0 - *(float *)&_XMM9))
                                       + (float)((float)((float)*(unsigned __int16 *)(a1 + 2 * n0xE_1 + 0xC8)
                                                       * 0.000015259022)
                                               * *(float *)&_XMM9)))
                       * *(float *)(a1 + 4);
    *(float *)(a1 + 0x10) = *(float *)&v32;
    if ( *(float *)&v8 <= 0.0 )
    {
      if ( *(float *)&v8 != 0.0 )
        n0x3F800000 = v8 ^ xmmword_1482B6750;
      n0x3F800000_1 = n0x3F800000;
      *(float *)&n0x3F800000_1 = *(float *)&n0x3F800000 - *(float *)&_XMM2;
      n0x3F800000_2 = n0x3F800000_1;
      __asm
      {
        vcmpltss xmm1, xmm0, xmm6
        vblendvps xmm0, xmm2, xmm6, xmm1
      }
      *(float *)(a1 + 0x10) = *(float *)&_XMM0;
    }
    return a2;
  }
}

// --- End Function: sub_142574200 (0x142574200) ---

// --- Function: sub_14258AAE0 (0x14258AAE0) ---
char __fastcall sub_14258AAE0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int64 v11; // rax
  const char *p_null; // rdx
  __int64 v14; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v19; // [rsp+A0h] [rbp-70h]
  const char *p_Address; // [rsp+A8h] [rbp-68h]
  __int64 v21; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EF810)(__int64, void *, size_t, __int64, char); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EF370)(__int64, __int64, __int64, __int64); // [rsp+C0h] [rbp-50h]
  __int64 v24; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_sub_1403EBA20)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v26; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E9250)(__int64); // [rsp+E0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E8F70)(_QWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v29; // [rsp+F0h] [rbp-20h]
  char v30; // [rsp+F8h] [rbp-18h]
  char v31; // [rsp+F9h] [rbp-17h]
  __int64 n0x18; // [rsp+100h] [rbp-10h]
  unsigned __int64 v33; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  p_Address = "Address";
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  v19 = a10;
  __Val_0___[9] = sub_1403E8F30;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v31 = 0;
  v21 = *a10;
  p_sub_1403EF810 = sub_1403EF810;
  p_sub_1403EF370 = sub_1403EF370;
  p_sub_1403EBA20 = sub_1403EBA20;
  p_sub_1403E9250 = sub_1403E9250;
  p_sub_1403E8F70 = sub_1403E8F70;
  v24 = 0;
  v26 = 0;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v30 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  do
    ++v11;
  while ( p_null[v11] );
  v33 = v11;
  LODWORD(v14) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 2u, a5, v14, a7, a8);
}

// --- End Function: sub_14258AAE0 (0x14258AAE0) ---

// --- Function: sub_142591FE0 (0x142591FE0) ---
__int64 __fastcall sub_142591FE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rax

  v2 = qword_149F14D30;
  sub_142616380(qword_149F14D30);
  result = sub_142617870(v2);
  v6 = result;
  if ( result )
  {
    (**(void (__fastcall ***)(__int64, __int64))result)(result, a2);
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x10LL))(v6);
    if ( (_BYTE)result )
    {
      if ( !*(_BYTE *)(a1 + 0x10) )
      {
        v7 = qword_149F14D30;
        if ( !BYTE1(qword_149C8E516) )
        {
          v8 = sub_142618260(qword_149F14D30);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x20LL))(v8);
        }
        if ( !(_BYTE)qword_149C8E516 )
          sub_1426165C0(v7);
        result = sub_142618330(v7);
        if ( result )
          return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)result + 8LL))(result, 4);
      }
    }
  }
  return result;
}

// --- End Function: sub_142591FE0 (0x142591FE0) ---

// --- Function: sub_142592130 (0x142592130) ---
void __fastcall sub_142592130(__int64 a1)
{
  __int64 v2; // rax

  if ( !BYTE1(qword_149C8E516) )
  {
    *(_BYTE *)(a1 + 0x11) = 1;
    if ( qword_149F10D68 )
    {
      *(_BYTE *)(a1 + 0x10) = 1;
      sub_1425EFFB0(qword_149F10D68);
      if ( *(_DWORD *)(a1 + 0x34) != 1 )
      {
        v2 = sub_142618260(qword_149F14D30);
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x18LL))(v2);
      }
      *(_BYTE *)(a1 + 0x11) = 0;
    }
    else
    {
      LogTraceConditional("[disconnectlight] Game does not exist!");
      *(_BYTE *)(a1 + 0x11) = 0;
    }
  }
}

// --- End Function: sub_142592130 (0x142592130) ---

// --- Function: sub_1425921A0 (0x1425921A0) ---
void __fastcall sub_1425921A0(__int64 a1, void **a2, void **a3)
{
  __int64 v4; // rdi
  __int64 v7; // r15
  void (__fastcall ***v8)(_QWORD, __int64); // rax
  void (__fastcall ***v9)(_QWORD, _QWORD); // r14
  void (__fastcall *v10)(_QWORD, __int64); // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  const char *v13; // rax
  __int64 v14; // rax
  const char *v15; // rax
  __int64 v16; // r8
  __int64 v17; // r8
  void **v18; // rax
  void **v19; // rax
  __int64 *v20; // rdi
  __int64 v21; // r8
  __int64 v22; // r8
  __int64 v23; // rcx
  __int64 v24; // r8
  int v25; // edi
  int *ThreadLogContextSlot; // rax
  __int64 v27; // rsi
  void (__fastcall *v28)(__int64, void *, _QWORD, _QWORD, _QWORD); // rdi
  void **v29; // rax
  void **v30; // rax
  __int64 v31; // rcx
  __int64 *v32; // [rsp+58h] [rbp-B0h] BYREF
  _BYTE *v33; // [rsp+60h] [rbp-A8h]
  void *v34; // [rsp+68h] [rbp-A0h] BYREF
  void *v35; // [rsp+70h] [rbp-98h] BYREF
  __int64 v36; // [rsp+78h] [rbp-90h] BYREF
  int n0x15; // [rsp+80h] [rbp-88h]
  _QWORD v38[2]; // [rsp+88h] [rbp-80h] BYREF
  __int64 v39; // [rsp+98h] [rbp-70h]
  __int128 v40; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v41; // [rsp+B0h] [rbp-58h] BYREF
  int n0x14; // [rsp+B8h] [rbp-50h]
  _BYTE v43[12]; // [rsp+BCh] [rbp-4Ch] BYREF
  void *v44; // [rsp+C8h] [rbp-40h] BYREF
  __int128 v45; // [rsp+D0h] [rbp-38h]
  const void *v46; // [rsp+E0h] [rbp-28h]
  int v47; // [rsp+E8h] [rbp-20h]
  void *v48; // [rsp+F0h] [rbp-18h] BYREF
  __int64 v49; // [rsp+F8h] [rbp-10h] BYREF
  __m256 v50; // [rsp+100h] [rbp-8h] BYREF
  char v51; // [rsp+120h] [rbp+18h]
  __int64 v52; // [rsp+128h] [rbp+20h] BYREF
  __int128 v53; // [rsp+130h] [rbp+28h]
  const void *v54[4]; // [rsp+148h] [rbp+40h] BYREF
  int v55; // [rsp+168h] [rbp+60h]
  const void *v56; // [rsp+170h] [rbp+68h] BYREF
  __int64 v57; // [rsp+178h] [rbp+70h] BYREF
  __int64 v58; // [rsp+180h] [rbp+78h] BYREF
  const void *v59[5]; // [rsp+188h] [rbp+80h] BYREF
  __int64 v60; // [rsp+1B0h] [rbp+A8h]
  char v61; // [rsp+1D0h] [rbp+C8h]
  __int64 v62; // [rsp+288h] [rbp+180h] BYREF
  _BYTE v63[176]; // [rsp+298h] [rbp+190h] BYREF
  __int64 v64; // [rsp+348h] [rbp+240h] BYREF

  v4 = qword_149F14D30;
  if ( !*(_BYTE *)(a1 + 0x10) && qword_149F14D30 && *(_BYTE *)(qword_149F14D30 + 0x738) )
    sub_142592130(a1);
  v7 = qword_149C8DFD0;
  if ( !byte_149C8E1C0 )
  {
    v8 = (void (__fastcall ***)(_QWORD, __int64))sub_142617870(v4);
    v9 = v8;
    if ( v8 )
    {
      v10 = **v8;
      v11 = sub_140421510((__int64)v63, 0x7540, "DoConnect");
      v10(v9, v11);
      sub_140373CC0(&v64);
    }
  }
  if ( !*(_BYTE *)(a1 + 0x10) )
    sub_1426165C0(v4);
  v12 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v7 + 0xC0LL))(v7, "cl_serveraddroverride");
  v13 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x28LL))(v12);
  CreateStringObjectFromString(&v35, v13);
  v14 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v7 + 0xC0LL))(v7, "cl_serverportoverride");
  v15 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x28LL))(v14);
  CreateStringObjectFromString(&v34, v15);
  if ( !sub_1403C3450(&v35) )
    copyStringStructure(a2, (const void **)&v35, v16);
  if ( !sub_1403C3450(&v34) )
    copyStringStructure(a3, (const void **)&v34, v17);
  *(_QWORD *)(a1 + 0x30) = 1;
  *(_BYTE *)(a1 + 0x12) = 0;
  (*(void (__fastcall **)(__int64, const void **))(*(_QWORD *)qword_149C8E070 + 0x28LL))(qword_149C8E070, v54);
  sub_14035E090(&v32);
  v19 = sub_1403ACC80(v18, "%s:%s", (const char *)*a2, (const char *)*a3);
  v20 = (__int64 *)sub_14035DE10((void **)&v41, (const void **)v19);
  sub_14035E090(&v44);
  v46 = 0;
  v45 = xmmword_14870F830;
  v47 = 0;
  sub_14035E090(&v48);
  sub_14035E090(&v49);
  v51 = 0;
  sub_14035DDF0(&v52, v20);
  v53 = xmmword_14870F830;
  sub_140373CC0(v20);
  sub_140373CC0(&v32);
  copyStringStructure(&v44, v54, v21);
  v47 = v55;
  v46 = v59[2];
  copyStringStructure(&v48, &v56, v22);
  *((_QWORD *)&v53 + 1) = v55;
  *(_QWORD *)&v53 = 0;
  if ( v51 )
  {
    v23 = *(_QWORD *)&v50.m256_f32[2];
    if ( *(_QWORD *)&v50.m256_f32[2] )
    {
      if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)&v50.m256_f32[6] - *(_QWORD *)&v50.m256_f32[2]) >> 1)) >= 0x1000 )
      {
        v23 = *(_QWORD *)(*(_QWORD *)&v50.m256_f32[2] - 8LL);
        if ( (unsigned __int64)(*(_QWORD *)&v50.m256_f32[2] - v23 - 8) > 0x1F )
LABEL_31:
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A6590(v23);
      memset(&v50.m256_f32[2], 0, 0x18);
    }
    sub_140373CC0(&v50);
    v51 = 0;
  }
  v50 = (__m256)0LL;
  __asm { vzeroupper }
  sub_14035E090(&v50);
  v51 = 1;
  memset(&v50.m256_f32[2], 0, 0x18);
  copyStringStructure((void **)&v50, v59, v24);
  *(_DWORD *)(a1 + 0x30) = 2;
  v32 = &v41;
  v36 = 0;
  v33 = v43;
  n0x15 = 0x15;
  v41 = 0x67000000D6LL;
  n0x14 = 0x14;
  v25 = invokeGlobalCallbackAndMaskStatusBits(
          5,
          (__int64)&v32,
          (__int64)"Session Manager [Request Connect]",
          "Connecting $$!");
  if ( (v25 & 0xFFFFF) != 0 )
  {
    v38[1] = v52;
    v38[0] = 0;
    v39 = 0;
    ThreadLogContextSlot = getThreadLogContextSlot();
    v41 = 0x67000000D6LL;
    v32 = &v41;
    v33 = v43;
    n0x14 = 0x14;
    v40 = 0;
    sub_14258AAE0(
      5,
      (__int64)&v32,
      "Session Manager [Request Connect]",
      (__int64)"Connecting $$!",
      1,
      v25,
      &v40,
      0,
      (__int64)ThreadLogContextSlot,
      v38);
    sub_1402A6590(v39);
  }
  if ( *(_BYTE *)(a1 + 0x10) && qword_149F10D68 )
  {
    if ( !(unsigned __int8)sub_1425EF190(qword_149F10D68, &v36, &v44) )
    {
      v27 = qword_149C8DFD0;
      v28 = *(void (__fastcall **)(__int64, void *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149C8DFD0 + 0x130LL);
      sub_14035E090(&v32);
      v30 = sub_1403ACC80(v29, "disconnect [%s] Connect failed in server transition", "CSessionManager::RequestConnect");
      v28(v27, *v30, 0, 0, 0);
      sub_140373CC0(&v32);
    }
  }
  else
  {
    sub_14261E880(qword_149F14D30, &v36, &v44);
  }
  sub_140373CC0(&v52);
  if ( v51 )
  {
    v31 = *(_QWORD *)&v50.m256_f32[2];
    if ( *(_QWORD *)&v50.m256_f32[2] )
    {
      if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)&v50.m256_f32[6] - *(_QWORD *)&v50.m256_f32[2]) >> 1)) >= 0x1000 )
      {
        v31 = *(_QWORD *)(*(_QWORD *)&v50.m256_f32[2] - 8LL);
        if ( (unsigned __int64)(*(_QWORD *)&v50.m256_f32[2] - v31 - 8) > 0x1F )
          goto LABEL_31;
      }
      sub_1402A6590(v31);
      memset(&v50.m256_f32[2], 0, 0x18);
    }
    sub_140373CC0(&v50);
  }
  sub_140373CC0(&v49);
  sub_140373CC0(&v48);
  sub_140373CC0(&v44);
  if ( v61 != 1 )
    sub_140373CC0(&v62);
  if ( v60 )
    sub_1402A6590(v60);
  sub_140373CC0(v59);
  sub_140373CC0(&v58);
  sub_140373CC0(&v57);
  sub_140373CC0(&v56);
  sub_140373CC0(v54);
  sub_140373CC0(&v34);
  sub_140373CC0(&v35);
}

// --- End Function: sub_1425921A0 (0x1425921A0) ---

// --- Function: sub_142597110 (0x142597110) ---
__int64 __fastcall sub_142597110(__int64 a1, __int64 a2, int a3, char a4)
{
  char v4; // di
  int v7; // ebx
  int v8; // eax
  __int64 v10; // [rsp+20h] [rbp-18h] BYREF
  int v11; // [rsp+28h] [rbp-10h]

  v4 = BYTE1(qword_149C8E516);
  v7 = a3 | 2;
  v8 = _stricmp(*(const char **)(a2 + 8), "S42_Default");
  v11 = v7;
  if ( !v8 && !v4 )
  {
    v7 |= 0x20u;
    v11 = v7;
  }
  if ( a4 )
  {
    v7 |= 0x400u;
    v11 = v7;
  }
  v10 = a2;
  if ( v4 )
    return sub_14261EA20(qword_149F14D30, &v10);
  v11 = v7 | 4;
  return sub_14261EAB0(qword_149F14D30, &v10);
}

// --- End Function: sub_142597110 (0x142597110) ---

// --- Function: sub_14259D2A0 (0x14259D2A0) ---
void __fastcall sub_14259D2A0(__int64 a1)
{
  __int64 v2; // rax
  void *v3; // r9
  __int64 v4; // rax
  void *v5; // [rsp+20h] [rbp-E8h] BYREF
  void *v6; // [rsp+28h] [rbp-E0h] BYREF
  _BYTE v7[176]; // [rsp+30h] [rbp-D8h] BYREF
  _QWORD v8[2]; // [rsp+E0h] [rbp-28h] BYREF

  if ( *(_BYTE *)(a1 + 0x12) )
  {
    v2 = sub_140421510((__int64)v7, 0x7540, "OnLobbySessionLeave");
    sub_142591FE0(a1, v2);
    sub_140373CC0(v8);
    *(_BYTE *)(a1 + 0x12) = 0;
  }
  if ( *(_BYTE *)(a1 + 0x13) )
  {
    sub_14035DE10(&v6, (const void **)(a1 + 0x18));
    sub_14035DE10(&v5, (const void **)(a1 + 0x20));
    *(_BYTE *)(a1 + 0x13) = 0;
    assignCStringToStringStructure(a1 + 0x18, (__int64)&p_Src);
    assignCStringToStringStructure(a1 + 0x20, (__int64)&p_Src);
    sub_1425921A0(a1, &v6, &v5);
    sub_140373CC0(&v5);
    sub_140373CC0(&v6);
  }
  else if ( *(_BYTE *)(a1 + 0x15) )
  {
    sub_14035E090(&v5);
    sub_14035DDF0(&v6, (__int64 *)&v5);
    sub_14037AE80(&v5, (void **)(a1 + 0x28));
    sub_14037AE80((void **)(a1 + 0x28), &v6);
    sub_140373CC0(&v6);
    v3 = v5;
    *(_BYTE *)(a1 + 0x15) = 0;
    v4 = sub_140421510((__int64)v7, 0x7540, (const char *)&format_string_, v3);
    sub_142591FE0(a1, v4);
    sub_140373CC0(v8);
    sub_140373CC0(&v5);
  }
}

// --- End Function: sub_14259D2A0 (0x14259D2A0) ---

// --- Function: sub_1425B0580 (0x1425B0580) ---
_OWORD *__fastcall sub_1425B0580(_OWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 v8; // r15
  __int64 v9; // rax
  __int128 v10; // xmm6
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 v16; // rbp
  bool v17; // al
  __int64 v18; // r14
  __int64 v19; // rsi
  __int64 v20; // rax
  __int128 v21; // xmm0
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rcx
  _OWORD *v25; // rcx
  __int128 v27; // [rsp+20h] [rbp-78h] BYREF
  __int128 v28; // [rsp+30h] [rbp-68h]
  __int128 v29; // [rsp+40h] [rbp-58h]
  _OWORD *v30; // [rsp+A0h] [rbp+8h]

  v30 = a1;
  v3 = a2[1];
  v4 = a3;
  v5 = *(_QWORD *)(a3 + 8);
  if ( v3 != v5 )
  {
    v6 = v3 + 1;
    *(_QWORD *)&v29 = *a2;
    *((_QWORD *)&v29 + 1) = v3 + 1;
    if ( v3 + 1 != v5 )
    {
      v7 = v29;
      v8 = *a2;
      do
      {
        v9 = *(_QWORD *)(v7 + 8);
        v10 = v29;
        v11 = v6 & (*(_QWORD *)(v7 + 0x10) - 1LL);
        v28 = v29;
        v27 = *(_OWORD *)*(_QWORD *)(v9 + 8 * v11);
        if ( sub_14059CAD0(&v27, *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (v3 & (*(_QWORD *)(v8 + 0x10) - 1LL)))) )
        {
          v12 = v6 + 1;
          v28 = v10;
          if ( v3 != v6 )
          {
            v13 = *((_QWORD *)&v28 + 1);
            do
              *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8 * (--v12 & (*(_QWORD *)(v10 + 0x10) - 1LL))) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * (--v13 & (*(_QWORD *)(v7 + 0x10) - 1LL)));
            while ( v13 != v3 );
          }
          v14 = *(_QWORD *)(v8 + 8);
          v15 = v3 & (*(_QWORD *)(v8 + 0x10) - 1LL);
        }
        else
        {
          v16 = v6 - 1;
          v17 = sub_14059CAD0(&v27, *(_QWORD **)(*(_QWORD *)(v7 + 8) + 8 * ((v6 - 1) & (*(_QWORD *)(v7 + 0x10) - 1LL))));
          v18 = *((_QWORD *)&v28 + 1);
          v19 = v28;
          if ( v17 )
          {
            do
            {
              v20 = *(_QWORD *)(v19 + 8);
              v21 = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * (v16 & (*(_QWORD *)(v7 + 0x10) - 1LL)));
              v22 = *(_QWORD *)(v19 + 0x10);
              v19 = v7;
              v23 = v18 & (v22 - 1);
              v18 = v16--;
              *(_OWORD *)*(_QWORD *)(v20 + 8 * v23) = v21;
            }
            while ( sub_14059CAD0(&v27, *(_QWORD **)(*(_QWORD *)(v7 + 8) + 8 * (v16 & (*(_QWORD *)(v7 + 0x10) - 1LL)))) );
          }
          v14 = *(_QWORD *)(v19 + 8);
          v24 = *(_QWORD *)(v19 + 0x10) - 1LL;
          v4 = a3;
          v15 = v18 & v24;
        }
        v25 = *(_OWORD **)(v14 + 8 * v15);
        *((_QWORD *)&v29 + 1) = ++v6;
        *v25 = v27;
      }
      while ( v6 != *(_QWORD *)(v4 + 8) );
      a1 = v30;
    }
  }
  *a1 = *(_OWORD *)v4;
  return a1;
}

// --- End Function: sub_1425B0580 (0x1425B0580) ---

// --- Function: sub_1425B07A0 (0x1425B07A0) ---
_UNKNOWN **__fastcall sub_1425B07A0(_QWORD *a1, __int64 a2)
{
  _UNKNOWN **result; // rax
  _QWORD *v3; // rdi
  __int64 v4; // r8
  __int64 v5; // rbp
  __int64 v6; // rdx
  __int64 v7; // r9
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // r13
  __int64 v15; // rbp
  __int64 v16; // r14
  __int64 v17; // r15
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // r14
  __int64 v21; // r15
  __int64 v22; // rbx
  __int64 v23; // rcx
  __int64 v24; // [rsp+30h] [rbp-88h]
  __int64 v25; // [rsp+38h] [rbp-80h]
  __int128 v26; // [rsp+48h] [rbp-70h] BYREF
  __int128 v27; // [rsp+58h] [rbp-60h]
  __int128 v28; // [rsp+68h] [rbp-50h]
  _UNKNOWN *retaddr; // [rsp+B8h] [rbp+0h] BYREF
  __int64 v31; // [rsp+C8h] [rbp+10h]

  result = &retaddr;
  v3 = a1;
  v31 = *(_QWORD *)(a2 + 8) - a1[1];
  v4 = v31;
  v5 = v31 >> 1;
  if ( v31 >> 1 > 0 )
  {
    v6 = *a1;
    v7 = v31 - 1;
    v8 = *a1;
    result = (_UNKNOWN **)a1[1];
    v9 = (v31 - 1) >> 1;
    v25 = *a1;
    do
    {
      v24 = --v5;
      v10 = v5;
      v11 = (*(_QWORD *)(v6 + 0x10) - 1LL) & ((unsigned __int64)result + v5);
      v12 = *(_QWORD *)(v6 + 8);
      v13 = v5;
      v26 = *(_OWORD *)*(_QWORD *)(v12 + 8 * v11);
      if ( v5 < v9 )
      {
        v14 = *v3;
        v15 = v3[1];
        v27 = *(_OWORD *)v3;
        v28 = v27;
        v16 = v27;
        v17 = v27;
        do
        {
          v13 = 2 * v13
              + !sub_14059CAD0(
                   *(_QWORD **)(*(_QWORD *)(v17 + 8)
                              + 8 * ((*(_QWORD *)(v17 + 0x10) - 1LL) & (2 * v13 + *((_QWORD *)&v28 + 1) + 2LL))),
                   *(_QWORD **)(*(_QWORD *)(v16 + 8)
                              + 8 * ((*(_QWORD *)(v16 + 0x10) - 1LL) & (2 * v13 + *((_QWORD *)&v27 + 1) + 1LL))))
              + 1LL;
          v18 = v10 + v15;
          v10 = v13;
          *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v14 + 8) + 8 * ((*(_QWORD *)(v14 + 0x10) - 1LL) & v18)) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v14 + 8) + 8 * ((*(_QWORD *)(v14 + 0x10) - 1LL) & (v13 + v15)));
        }
        while ( v13 < v9 );
        v3 = a1;
        v5 = v24;
        v4 = v31;
        v8 = v25;
        v7 = v31 - 1;
      }
      if ( v10 == v9 && (v4 & 1) == 0 )
      {
        v19 = v10 + v3[1];
        v10 = v7;
        *(_OWORD *)*(_QWORD *)(*(_QWORD *)(*v3 + 8LL) + 8 * ((*(_QWORD *)(*v3 + 0x10LL) - 1LL) & v19)) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(*v3 + 8LL) + 8 * ((*(_QWORD *)(*v3 + 0x10LL) - 1LL) & (v4 + v3[1] - 1LL)));
      }
      if ( v5 < v10 )
      {
        v20 = *v3;
        v21 = v3[1];
        do
        {
          v22 = (v10 - 1) >> 1;
          if ( !sub_14059CAD0(
                  *(_QWORD **)(*(_QWORD *)(v20 + 8) + 8 * ((*(_QWORD *)(v20 + 0x10) - 1LL) & (v21 + v22))),
                  &v26) )
            break;
          v23 = v10 + v21;
          v10 = (v10 - 1) >> 1;
          *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v20 + 8) + 8 * ((*(_QWORD *)(v20 + 0x10) - 1LL) & v23)) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v20 + 8) + 8 * ((*(_QWORD *)(v20 + 0x10) - 1LL) & (v22 + v21)));
        }
        while ( v5 < v22 );
      }
      v4 = v31;
      v6 = *v3;
      v7 = v31 - 1;
      result = (_UNKNOWN **)v3[1];
      *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v8 + 8)
                           + 8 * ((*(_QWORD *)(v8 + 0x10) - 1LL) & ((unsigned __int64)result + v10))) = v26;
    }
    while ( v5 > 0 );
  }
  return result;
}

// --- End Function: sub_1425B07A0 (0x1425B07A0) ---

// --- Function: sub_1425B0BE0 (0x1425B0BE0) ---
_OWORD *__fastcall sub_1425B0BE0(_OWORD *a1, __int128 *a2, __int128 *a3)
{
  __int128 v3; // xmm6
  unsigned __int64 v4; // r12
  __int128 v5; // xmm0
  unsigned __int64 v6; // r13
  __int64 v7; // r15
  __int128 v8; // xmm6
  __int64 v9; // rax
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // r15
  __int64 v12; // r14
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // r12
  __int64 v16; // r9
  __int128 *v17; // r8
  __int128 *v18; // rdx
  __int128 v19; // xmm1
  unsigned __int64 i; // r14
  unsigned __int64 v21; // rax
  __int128 *v22; // r8
  __int128 *v23; // rdx
  __int128 v24; // xmm1
  __int128 *v25; // r8
  __int128 *v26; // rdx
  __int128 v27; // xmm1
  __int128 *v28; // r8
  __int64 v29; // rcx
  __int128 *v30; // rdx
  __int128 v31; // xmm1
  __int128 *v32; // r8
  __int128 *v33; // rdx
  __int128 v34; // xmm1
  __int128 *v35; // r8
  __int128 *v36; // rdx
  __int128 v37; // xmm1
  __int128 *v38; // r8
  __int64 v39; // rcx
  __int128 *v40; // rdx
  __int128 v41; // xmm1
  _OWORD *result; // rax
  unsigned __int64 v43; // [rsp+28h] [rbp-59h]
  __int128 v44; // [rsp+38h] [rbp-49h]
  __int128 v45; // [rsp+48h] [rbp-39h]
  __int128 v46; // [rsp+58h] [rbp-29h]
  __int128 v47; // [rsp+58h] [rbp-29h]
  __int128 v48; // [rsp+68h] [rbp-19h] BYREF
  __int128 v49; // [rsp+78h] [rbp-9h] BYREF
  _OWORD v50[5]; // [rsp+88h] [rbp+7h] BYREF
  unsigned __int64 v53; // [rsp+F8h] [rbp+77h]

  v4 = *((_QWORD *)a2 + 1);
  v45 = *a2;
  v5 = *a3;
  v50[1] = v3;
  v53 = *((_QWORD *)a3 + 1);
  v43 = v4;
  v6 = v4 + ((__int64)(v53 - v4) >> 1);
  *((_QWORD *)&v45 + 1) = v6;
  *(_QWORD *)&v46 = v5;
  *((_QWORD *)&v46 + 1) = v53 - 1;
  if ( (__int64)(v53 - 1 - v4) <= 0x28 )
  {
    v8 = v45;
    v50[0] = v46;
    v48 = *a2;
  }
  else
  {
    *(_QWORD *)&v49 = *(_QWORD *)a2;
    *(_QWORD *)&v48 = v49;
    v7 = (__int64)(v53 - v4) >> 3;
    *((_QWORD *)&v48 + 1) = 2 * v7 + v4;
    *((_QWORD *)&v49 + 1) = v7 + v4;
    v50[0] = *a2;
    sub_1425B0A60(v50, &v49, &v48);
    v8 = v45;
    *((_QWORD *)&v49 + 1) = v7 + v6;
    *(_QWORD *)&v49 = v45;
    *(_QWORD *)&v48 = v45;
    *((_QWORD *)&v48 + 1) = v6 - v7;
    v50[0] = v49;
    v49 = v45;
    sub_1425B0A60(&v48, &v49, v50);
    *(_QWORD *)&v49 = v46;
    *(_QWORD *)&v48 = v46;
    *((_QWORD *)&v48 + 1) = v53 - 1 - 2 * v7;
    *((_QWORD *)&v49 + 1) = v53 - 1 - v7;
    v50[0] = v46;
    sub_1425B0A60(&v48, &v49, v50);
    *(_QWORD *)&v49 = v46;
    *((_QWORD *)&v49 + 1) = v53 - 1 - v7;
    v9 = *((_QWORD *)a2 + 1);
    *(_QWORD *)&v48 = *(_QWORD *)a2;
    *((_QWORD *)&v48 + 1) = v7 + v9;
    v50[0] = v49;
  }
  v49 = v8;
  sub_1425B0A60(&v48, &v49, v50);
  __SET_PAIR__(v10, v49, v8);
  *(_QWORD *)&v47 = v8;
  *((_QWORD *)&v49 + 1) = v6 + 1;
  v44 = v49;
  while ( v4 != v6 )
  {
    if ( v4 >= v6 )
      break;
    v6 = v10 - 1;
    if ( sub_14059CAD0(
           *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * ((*(_QWORD *)(v8 + 0x10) - 1LL) & (v10 - 1))),
           *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * ((*(_QWORD *)(v8 + 0x10) - 1LL) & v10)))
      || sub_14059CAD0(
           *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * ((*(_QWORD *)(v8 + 0x10) - 1LL) & v10)),
           *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * ((*(_QWORD *)(v8 + 0x10) - 1LL) & v6))) )
    {
      break;
    }
    --v10;
  }
  v11 = *((_QWORD *)&v44 + 1);
  v12 = v44;
  *((_QWORD *)&v47 + 1) = v10;
  while ( 1 )
  {
    v13 = v53;
    if ( v11 >= v53 )
      break;
    if ( sub_14059CAD0(
           *(_QWORD **)(*(_QWORD *)(v44 + 8) + 8 * (v11 & (*(_QWORD *)(v44 + 0x10) - 1LL))),
           *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL))))
      || sub_14059CAD0(
           *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL))),
           *(_QWORD **)(*(_QWORD *)(v44 + 8) + 8 * (v11 & (*(_QWORD *)(v44 + 0x10) - 1LL)))) )
    {
      v13 = v53;
      break;
    }
    ++v11;
  }
  v49 = v47;
  v14 = v10;
  *((_QWORD *)&v44 + 1) = v11;
  v15 = v11;
LABEL_17:
  v16 = v44;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v15 < v13 )
      {
        if ( sub_14059CAD0(
               *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL))),
               *(_QWORD **)(*(_QWORD *)(v16 + 8) + 8 * (v15 & (*(_QWORD *)(v16 + 0x10) - 1LL)))) )
        {
          goto LABEL_24;
        }
        if ( !sub_14059CAD0(
                *(_QWORD **)(*(_QWORD *)(v44 + 8) + 8 * (v15 & (*(_QWORD *)(v44 + 0x10) - 1LL))),
                *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL)))) )
        {
          if ( v11 != v15 )
          {
            v17 = *(__int128 **)(*(_QWORD *)(v44 + 8) + 8 * (v15 & (*(_QWORD *)(v44 + 0x10) - 1LL)));
            v18 = *(__int128 **)(*(_QWORD *)(v12 + 8) + 8 * (v11 & (*(_QWORD *)(v12 + 0x10) - 1LL)));
            v19 = *v18;
            *v18 = *v17;
            *v17 = v19;
          }
          *((_QWORD *)&v44 + 1) = ++v11;
LABEL_24:
          v13 = v53;
          ++v15;
          goto LABEL_17;
        }
      }
      for ( i = v14 - 1; ; --i )
      {
        v21 = v43;
        if ( v43 >= v14 )
          break;
        if ( !sub_14059CAD0(
                *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (i & (*(_QWORD *)(v8 + 0x10) - 1LL))),
                *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL)))) )
        {
          if ( sub_14059CAD0(
                 *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL))),
                 *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * (i & (*(_QWORD *)(v8 + 0x10) - 1LL)))) )
          {
            v21 = v43;
            break;
          }
          if ( --v10 != i )
          {
            v22 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * (i & (*(_QWORD *)(v8 + 0x10) - 1LL)));
            v23 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL)));
            v24 = *v23;
            *v23 = *v22;
            *v22 = v24;
          }
        }
        --v14;
      }
      *((_QWORD *)&v47 + 1) = v10;
      if ( v14 == v21 )
        break;
      if ( v15 == v53 )
      {
        if ( --v14 != --v10 )
        {
          v32 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL)));
          v33 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * (v14 & (*(_QWORD *)(v8 + 0x10) - 1LL)));
          v34 = *v33;
          *v33 = *v32;
          *v32 = v34;
        }
        v12 = v44;
        *((_QWORD *)&v44 + 1) = --v11;
        v35 = *(__int128 **)(*(_QWORD *)(v44 + 8) + 8 * (v11 & (*(_QWORD *)(v44 + 0x10) - 1LL)));
        v36 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL)));
        v13 = v53;
        v37 = *v36;
        *v36 = *v35;
        *v35 = v37;
        goto LABEL_17;
      }
      --v14;
      v16 = v44;
      v12 = v44;
      v38 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * (v14 & (*(_QWORD *)(v8 + 0x10) - 1LL)));
      v39 = v15++ & (*(_QWORD *)(v44 + 0x10) - 1LL);
      v40 = *(__int128 **)(*(_QWORD *)(v44 + 8) + 8 * v39);
      v13 = v53;
      v41 = *v40;
      *v40 = *v38;
      *v38 = v41;
    }
    if ( v15 == v53 )
      break;
    v12 = v44;
    if ( v11 != v15 )
    {
      v25 = *(__int128 **)(*(_QWORD *)(v44 + 8) + 8 * (v11 & (*(_QWORD *)(v44 + 0x10) - 1LL)));
      v26 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * (v10 & (*(_QWORD *)(v8 + 0x10) - 1LL)));
      v27 = *v26;
      *v26 = *v25;
      *v25 = v27;
    }
    v16 = v44;
    *((_QWORD *)&v44 + 1) = ++v11;
    v28 = *(__int128 **)(*(_QWORD *)(v44 + 8) + 8 * (v15 & (*(_QWORD *)(v44 + 0x10) - 1LL)));
    v29 = v10++ & (*(_QWORD *)(v8 + 0x10) - 1LL);
    ++v15;
    v30 = *(__int128 **)(*(_QWORD *)(v8 + 8) + 8 * v29);
    v13 = v53;
    v31 = *v30;
    *v30 = *v28;
    *v28 = v31;
  }
  result = a1;
  *a1 = v47;
  a1[1] = v44;
  return result;
}

// --- End Function: sub_1425B0BE0 (0x1425B0BE0) ---

// --- Function: sub_1425B1230 (0x1425B1230) ---
__int64 __fastcall sub_1425B1230(_QWORD *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v4; // r15
  __int64 v5; // r13
  __int64 v6; // r14
  __int64 v7; // rbp
  __int64 v8; // rsi
  _QWORD *v9; // rdi
  __int64 v10; // r12
  bool v11; // zf
  __int64 v12; // r12
  __int64 v13; // rdi
  __int64 v14; // r13
  __int64 v15; // r15
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rbp
  __int64 v19; // r14
  __int64 v20; // rbx
  __int64 v21; // rcx
  __int64 result; // rax
  __int64 v23; // [rsp+28h] [rbp-70h]
  __int128 v24; // [rsp+30h] [rbp-68h]
  __int128 v25; // [rsp+40h] [rbp-58h]

  v4 = a4;
  v5 = a3 - 1;
  v23 = a2;
  v6 = a3;
  v7 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a1;
  v10 = a2;
  v11 = a2 == v7;
  if ( a2 < v7 )
  {
    v12 = *a1;
    v13 = a1[1];
    v24 = *(_OWORD *)a1;
    v25 = *(_OWORD *)a1;
    v14 = *a1;
    v15 = *a1;
    do
    {
      a2 = 2 * a2
         + !sub_14059CAD0(
              *(_QWORD **)(*(_QWORD *)(v15 + 8)
                         + 8 * ((*(_QWORD *)(v15 + 0x10) - 1LL) & (2 * a2 + *((_QWORD *)&v25 + 1) + 2LL))),
              *(_QWORD **)(*(_QWORD *)(v14 + 8)
                         + 8 * ((*(_QWORD *)(v14 + 0x10) - 1LL) & (2 * a2 + *((_QWORD *)&v24 + 1) + 1LL))))
         + 1LL;
      v16 = v8 + v13;
      v8 = a2;
      *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8 * ((*(_QWORD *)(v12 + 0x10) - 1LL) & v16)) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8 * ((*(_QWORD *)(v12 + 0x10) - 1LL) & (a2 + v13)));
      v11 = a2 == v7;
    }
    while ( a2 < v7 );
    v6 = a3;
    v9 = a1;
    v4 = a4;
    v10 = v23;
    v5 = a3 - 1;
  }
  if ( v11 && (v6 & 1) == 0 )
  {
    v17 = v8 + v9[1];
    v8 = v5;
    *(_OWORD *)*(_QWORD *)(*(_QWORD *)(*v9 + 8LL) + 8 * ((*(_QWORD *)(*v9 + 0x10LL) - 1LL) & v17)) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(*v9 + 8LL) + 8 * ((*(_QWORD *)(*v9 + 0x10LL) - 1LL) & (v6 + v9[1] - 1LL)));
  }
  if ( v10 < v8 )
  {
    v18 = *v9;
    v19 = v9[1];
    do
    {
      v20 = (v8 - 1) >> 1;
      if ( !sub_14059CAD0(*(_QWORD **)(*(_QWORD *)(v18 + 8) + 8 * ((*(_QWORD *)(v18 + 0x10) - 1LL) & (v19 + v20))), v4) )
        break;
      v21 = v8 + v19;
      v8 = (v8 - 1) >> 1;
      *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v18 + 8) + 8 * ((*(_QWORD *)(v18 + 0x10) - 1LL) & v21)) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(v18 + 8) + 8 * ((*(_QWORD *)(v18 + 0x10) - 1LL) & (v20 + v19)));
    }
    while ( v10 < v20 );
  }
  result = *(_QWORD *)(*v9 + 8LL);
  *(_OWORD *)*(_QWORD *)(result + 8 * ((*(_QWORD *)(*v9 + 0x10LL) - 1LL) & (v8 + v9[1]))) = *(_OWORD *)v4;
  return result;
}

// --- End Function: sub_1425B1230 (0x1425B1230) ---

// --- Function: sub_1425B15F0 (0x1425B15F0) ---
_OWORD *__fastcall sub_1425B15F0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // r15
  __int64 v6; // r12
  __int128 v10; // xmm1
  __int128 v11; // xmm1
  __int128 v12; // xmm1
  _OWORD *result; // rax
  __m128i v14; // xmm0
  __int64 v15; // r14
  signed __int64 epi64; // rdi
  __int64 v17; // rsi
  __int64 v18; // r15
  __int64 v19; // r13
  __int64 v20; // rax
  __int64 v21; // rcx
  __int128 **v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // rax
  __int128 v25; // [rsp+30h] [rbp-40h] BYREF
  __int128 v26; // [rsp+40h] [rbp-30h] BYREF
  __int128 v27; // [rsp+50h] [rbp-20h] BYREF
  __int128 v28; // [rsp+60h] [rbp-10h]

  v4 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a1 + 8);
  if ( v4 - v6 <= 0x20 )
  {
LABEL_7:
    v12 = *(_OWORD *)a1;
    v27 = *(_OWORD *)a2;
    v26 = v12;
    return sub_1425B0580(&v25, &v26, (__int64)&v27);
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_OWORD *)a1;
      if ( a3 <= 0 )
        break;
      v25 = *(_OWORD *)a2;
      v26 = v10;
      sub_1425B0BE0(&v27, &v26, &v25);
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( *((_QWORD *)&v27 + 1) - v6 >= v4 - *((_QWORD *)&v28 + 1) )
      {
        v26 = *(_OWORD *)a2;
        v25 = v28;
        sub_1425B15F0(&v25, &v26, a3, a4);
        *(_OWORD *)a2 = v27;
      }
      else
      {
        v11 = *(_OWORD *)a1;
        v26 = v27;
        v25 = v11;
        sub_1425B15F0(&v25, &v26, a3, a4);
        *(_OWORD *)a1 = v28;
      }
      v4 = *(_QWORD *)(a2 + 8);
      v6 = *(_QWORD *)(a1 + 8);
      if ( v4 - v6 <= 0x20 )
        goto LABEL_7;
    }
    v26 = *(_OWORD *)a2;
    v25 = v10;
    sub_1425B07A0(&v25, (__int64)&v26);
    v14 = *(__m128i *)a2;
    v15 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)&v27 = *(_QWORD *)a1;
    epi64 = _mm_extract_epi64(v14, 1);
    result = (_OWORD *)(epi64 - v15);
    v26 = (__int128)v14;
    if ( epi64 - v15 >= 2 )
    {
      v25 = *(_OWORD *)a1;
      v17 = *((_QWORD *)&v25 + 1);
      v18 = v25;
      v19 = v26;
      do
      {
        if ( epi64 - v17 >= 2 )
        {
          v20 = *(_QWORD *)(v19 + 8);
          v21 = *(_QWORD *)(v19 + 0x10) - 1LL;
          *(_QWORD *)&v25 = v18;
          *((_QWORD *)&v25 + 1) = v17;
          v22 = (__int128 **)(v20 + 8 * ((epi64 - 1) & v21));
          v23 = v17 & (*(_QWORD *)(v18 + 0x10) - 1LL);
          v24 = *(_QWORD *)(v18 + 8);
          v26 = **v22;
          **v22 = *(_OWORD *)*(_QWORD *)(v24 + 8 * v23);
          v27 = v25;
          sub_1425B1230(&v27, 0, epi64 - 1 - v17, &v26);
        }
        result = (_OWORD *)(--epi64 - v15);
      }
      while ( epi64 - v15 >= 2 );
    }
  }
  return result;
}

// --- End Function: sub_1425B15F0 (0x1425B15F0) ---

// --- Function: sub_1425B23C0 (0x1425B23C0) ---
__int64 __fastcall sub_1425B23C0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 n0xA; // rsi
  __int64 v10; // rdi
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  char v18; // [rsp+30h] [rbp+8h] BYREF

  *(_QWORD *)a1 = off_148305068;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = off_148713DE8;
  *(_QWORD *)(a1 + 0x18) = qword_149C8DFC0;
  v2 = qword_149C8DF30;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x20) = v2;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = 0;
  *(_QWORD *)(a1 + 0xE8) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  v3 = sub_1402A65A0(0x30u);
  *(_QWORD *)v3 = v3;
  *(_QWORD *)(v3 + 8) = v3;
  *(_QWORD *)(v3 + 0x10) = v3;
  *(_WORD *)(v3 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x100) = v3;
  *(_QWORD *)(a1 + 0x110) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  v4 = sub_1402A65A0(0x30u);
  *(_QWORD *)v4 = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)(v4 + 0x10) = v4;
  *(_WORD *)(v4 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x110) = v4;
  *(_QWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0x128) = 0;
  v5 = sub_1402A65A0(0x30u);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 0x10) = v5;
  *(_WORD *)(v5 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x120) = v5;
  *(_QWORD *)(a1 + 0x130) = 0;
  *(_QWORD *)(a1 + 0x138) = 0;
  v6 = sub_1402A65A0(0x30u);
  *(_QWORD *)v6 = v6;
  *(_QWORD *)(v6 + 8) = v6;
  *(_QWORD *)(v6 + 0x10) = v6;
  *(_WORD *)(v6 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x130) = v6;
  *(_QWORD *)(a1 + 0x140) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  v7 = sub_1402A65A0(0x48u);
  *(_QWORD *)v7 = v7;
  *(_QWORD *)(v7 + 8) = v7;
  *(_QWORD *)(v7 + 0x10) = v7;
  *(_WORD *)(v7 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x140) = v7;
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = 0;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_QWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x178) = 0;
  v8 = sub_1402A65A0(0xC30u);
  *(_QWORD *)(a1 + 0x168) = v8;
  n0xA = 0xA;
  *(_QWORD *)(a1 + 0x170) = v8;
  *(_QWORD *)(a1 + 0x178) = v8 + 0xC30;
  v10 = *(_QWORD *)(a1 + 0x168);
  do
  {
    sub_1425B47B0(v10);
    v10 += 0x138;
    --n0xA;
  }
  while ( n0xA );
  *(_QWORD *)(a1 + 0x170) = v10;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0;
  v11 = sub_1402A65A0(0x30u);
  *(_QWORD *)v11 = v11;
  *(_QWORD *)(v11 + 8) = v11;
  *(_QWORD *)(v11 + 0x10) = v11;
  *(_WORD *)(v11 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x198) = v11;
  *(_QWORD *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0;
  v12 = sub_1402A65A0(0x40u);
  *(_QWORD *)v12 = v12;
  *(_QWORD *)(v12 + 8) = v12;
  *(_QWORD *)(v12 + 0x10) = v12;
  *(_WORD *)(v12 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x1A8) = v12;
  *(_QWORD *)(a1 + 0x1B8) = 0;
  *(_QWORD *)(a1 + 0x1C0) = 0;
  v13 = sub_1402A65A0(0x30u);
  *(_QWORD *)v13 = v13;
  *(_QWORD *)(v13 + 8) = v13;
  *(_QWORD *)(v13 + 0x10) = v13;
  *(_WORD *)(v13 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x1B8) = v13;
  *(_QWORD *)(a1 + 0x1C8) = 0;
  *(_QWORD *)(a1 + 0x1D0) = 0;
  v14 = sub_1402A65A0(0x30u);
  *(_QWORD *)v14 = v14;
  *(_QWORD *)(v14 + 8) = v14;
  *(_QWORD *)(v14 + 0x10) = v14;
  *(_WORD *)(v14 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x1C8) = v14;
  *(_DWORD *)(a1 + 0x1D8) = 0;
  *(_QWORD *)(a1 + 0x1E0) = (unsigned __int64)&unk_149C78F0B & 0xFFFFFFFFFFFFFFF8uLL;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F0) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_DWORD *)(a1 + 0x200) = 0;
  sub_14035E090((_QWORD *)(a1 + 0x208));
  sub_14035E090((_QWORD *)(a1 + 0x210));
  *(_DWORD *)(a1 + 0x218) = 0;
  qword_149F10D68 = a1;
  v15 = sub_1402A65A0(0x40u);
  if ( v15 )
    v16 = sub_142380BD0(v15, qword_149F14D30, a1);
  else
    v16 = 0;
  *(_QWORD *)(a1 + 0x48) = v16;
  *(_DWORD *)(a1 + 0x18C) = 0;
  if ( qword_149C8DF38 )
    qword_149AE7720 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DF38
                                                                                          + 0x28LL))(
                                   qword_149C8DF38,
                                   &v18,
                                   "Engine.Components.Bullet");
  return a1;
}

// --- End Function: sub_1425B23C0 (0x1425B23C0) ---

// --- Function: sub_1425BA9C0 (0x1425BA9C0) ---
char __fastcall sub_1425BA9C0(__int64 a1, const char **a2)
{
  if ( *(_QWORD *)(a1 + 0x40) )
    return sub_142382B50(*(_QWORD *)(a1 + 0x48), a2);
  sub_1405C6220(0xAu, 2u, "Can't ChangeGameContext() on client");
  return 0;
}

// --- End Function: sub_1425BA9C0 (0x1425BA9C0) ---

// --- Function: sub_1425DCA00 (0x1425DCA00) ---
__int64 __fastcall sub_1425DCA00(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v4; // rbx
  signed __int64 v6; // rdi

  v2 = a1 + 8;
  *(_QWORD *)a2 = v2;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  v4 = v2 + 0x10;
  *(_QWORD *)(a2 + 8) = v2 + 0x10;
  *(_DWORD *)(a2 + 0x18) = 1;
  if ( *(_DWORD *)(v2 + 0x20) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v4 + 0x14);
    return a2;
  }
  else
  {
    v6 = _InterlockedIncrement64((volatile signed __int64 *)v4);
    if ( (v6 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v4, v6, (const char *)&p_Src, (const char *)&p_Src, 1);
    return a2;
  }
}

// --- End Function: sub_1425DCA00 (0x1425DCA00) ---

// --- Function: sub_1425EF190 (0x1425EF190) ---
char __fastcall sub_1425EF190(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // rax
  char v10; // [rsp+48h] [rbp+20h] BYREF

  if ( !(unsigned __int8)sub_1425F4E30() )
    return 0;
  if ( !*(_QWORD *)(a1 + 0x38) )
  {
    v6 = sub_1402A65A0(0x28u);
    v7 = v6;
    if ( v6 )
    {
      *(_QWORD *)(v6 + 0xC) = 0;
      *(_QWORD *)(v6 + 0x14) = 0;
      *(_DWORD *)(v6 + 0x1C) = 0;
      *(_QWORD *)v6 = off_1486D83C8;
      *(_QWORD *)(v6 + 0x10) = &p_Src;
      *(_DWORD *)(v6 + 8) = 0;
      *(_DWORD *)(v6 + 0x18) = 0xFFFFFFFF;
      *(_DWORD *)(v6 + 0x1C) = 0;
      *(_QWORD *)(v6 + 0x20) = 0;
    }
    else
    {
      v7 = 0;
    }
    *(_QWORD *)(a1 + 0x38) = v7;
  }
  v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 0x20) + 0x10LL))(*(_QWORD *)(a1 + 0x20), 0);
  *(_QWORD *)(a1 + 0x28) = v8;
  if ( !v8 || !(*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 0x10LL))(v8, a3) )
    return 0;
  v10 = 1;
  *(_DWORD *)(a1 + 0x218) = 0;
  sub_1425F4AE0(a1, a2, &v10);
  return v10;
}

// --- End Function: sub_1425EF190 (0x1425EF190) ---

// --- Function: sub_1425EF3A0 (0x1425EF3A0) ---
__int64 __fastcall sub_1425EF3A0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int8 v8; // [rsp+40h] [rbp+18h] BYREF

  result = sub_1425F4E30();
  if ( (_BYTE)result )
  {
    v5 = *(_QWORD *)(a1 + 0x40);
    if ( !v5 )
    {
      v6 = sub_1402A65A0(0x30u);
      if ( v6 )
        v5 = sub_142380DF0(v6);
      else
        v5 = 0;
      *(_QWORD *)(a1 + 0x40) = v5;
    }
    v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(a1 + 0x20) + 0x10LL))(
           *(_QWORD *)(a1 + 0x20),
           v5,
           0);
    *(_DWORD *)(a1 + 0x218) = 0;
    *(_QWORD *)(a1 + 0x30) = v7;
    v8 = 1;
    sub_1425F4AE0(a1, a2, &v8);
    return v8;
  }
  return result;
}

// --- End Function: sub_1425EF3A0 (0x1425EF3A0) ---

// --- Function: sub_1425EF430 (0x1425EF430) ---
__int64 __fastcall sub_1425EF430(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // r14
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // rax
  __int64 v11; // r8
  void **v12; // rax
  void **v13; // rbx
  unsigned __int16 v14; // ax
  void **v15; // rax
  __int64 *v16; // rbx
  __int64 v17; // r8
  __int64 v18; // r8
  __int64 v19; // r8
  __int64 v20; // rcx
  unsigned __int8 v21; // bl
  __int64 v22; // rcx
  __int64 v23; // rcx
  char v24[8]; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v25; // [rsp+28h] [rbp-D8h] BYREF
  void *v26[2]; // [rsp+30h] [rbp-D0h] BYREF
  const void *v27; // [rsp+40h] [rbp-C0h] BYREF
  __int128 v28; // [rsp+48h] [rbp-B8h]
  __int64 v29; // [rsp+58h] [rbp-A8h]
  int v30; // [rsp+60h] [rbp-A0h]
  void *v31; // [rsp+68h] [rbp-98h] BYREF
  const void *v32; // [rsp+70h] [rbp-90h] BYREF
  __int64 v33; // [rsp+78h] [rbp-88h] BYREF
  __int128 v34; // [rsp+80h] [rbp-80h]
  __int64 v35; // [rsp+90h] [rbp-70h]
  char v36; // [rsp+98h] [rbp-68h]
  __int64 v37; // [rsp+A0h] [rbp-60h] BYREF
  void (__fastcall *n2)(__int64, __int64 *); // [rsp+A8h] [rbp-58h]
  __int64 v39; // [rsp+B0h] [rbp-50h]
  void *v40; // [rsp+C0h] [rbp-40h] BYREF
  __int128 v41; // [rsp+C8h] [rbp-38h]
  __int64 v42; // [rsp+D8h] [rbp-28h]
  int v43; // [rsp+E0h] [rbp-20h]
  void *v44; // [rsp+E8h] [rbp-18h] BYREF
  void *v45; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v46; // [rsp+F8h] [rbp-8h] BYREF
  __int128 v47; // [rsp+100h] [rbp+0h]
  __int64 v48; // [rsp+110h] [rbp+10h]
  char v49; // [rsp+118h] [rbp+18h]
  __int64 v50; // [rsp+120h] [rbp+20h] BYREF
  __int128 v51; // [rsp+128h] [rbp+28h]
  __int128 v52; // [rsp+140h] [rbp+40h] BYREF
  __int64 v53[4]; // [rsp+150h] [rbp+50h] BYREF
  int v54; // [rsp+170h] [rbp+70h]
  const void *v55; // [rsp+178h] [rbp+78h] BYREF
  __int64 v56; // [rsp+180h] [rbp+80h] BYREF
  __int64 v57; // [rsp+188h] [rbp+88h] BYREF
  _QWORD v58[5]; // [rsp+190h] [rbp+90h] BYREF
  __int64 v59; // [rsp+1B8h] [rbp+B8h]
  char v60; // [rsp+1D8h] [rbp+D8h]
  __int64 v61; // [rsp+290h] [rbp+190h] BYREF

  result = sub_1425F4E30();
  if ( (_BYTE)result )
  {
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8E070 + 0x28LL))(qword_149C8E070, v53);
    v5 = v54;
    v26[0] = 0;
    v26[1] = (void *)v54;
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)qword_149C8DF30 + 0xF8LL))(qword_149C8DF30, v26);
    (*(void (__fastcall **)(__int64, __int128 *))(*(_QWORD *)qword_149C8DF30 + 0xE8LL))(qword_149C8DF30, &v52);
    if ( !*(_QWORD *)(a1 + 0x40) )
    {
      v6 = sub_1402A65A0(0x30u);
      if ( v6 )
        v7 = sub_142380DF0(v6);
      else
        v7 = 0;
      *(_QWORD *)(a1 + 0x40) = v7;
    }
    if ( !*(_QWORD *)(a1 + 0x38) )
    {
      v8 = sub_1402A65A0(0x28u);
      v9 = v8;
      if ( v8 )
      {
        *(_QWORD *)(v8 + 0xC) = 0;
        *(_QWORD *)(v8 + 0x14) = 0;
        *(_DWORD *)(v8 + 0x1C) = 0;
        *(_QWORD *)v8 = off_1486D83C8;
        *(_QWORD *)(v8 + 0x10) = &p_Src;
        *(_DWORD *)(v8 + 8) = 0;
        *(_DWORD *)(v8 + 0x18) = 0xFFFFFFFF;
        *(_DWORD *)(v8 + 0x1C) = 0;
        *(_QWORD *)(v8 + 0x20) = 0;
      }
      else
      {
        v9 = 0;
      }
      *(_QWORD *)(a1 + 0x38) = v9;
    }
    v10 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 0x20) + 0x10LL))(
            *(_QWORD *)(a1 + 0x20),
            *(_QWORD *)(a1 + 0x40));
    *(_QWORD *)(a1 + 0x30) = v10;
    *(_QWORD *)(a1 + 0x28) = v10;
    sub_14035E090(&v27);
    v29 = 0;
    v28 = xmmword_148711828;
    v30 = 0;
    sub_14035E090(&v31);
    sub_14035E090(&v32);
    v36 = 0;
    v37 = 0;
    n2 = 0;
    v39 = 0;
    assignCStringToStringStructure((__int64)&v27, v53[0]);
    v29 = v58[2];
    v30 = v54;
    *(_QWORD *)&v28 = 0;
    *((_QWORD *)&v28 + 1) = v5;
    copyStringStructure(&v31, &v55, v11);
    (*(void (__fastcall **)(_QWORD, const void **))(**(_QWORD **)(a1 + 0x30) + 0x20LL))(*(_QWORD *)(a1 + 0x30), &v27);
    sub_14035E090(&v25);
    v13 = v12;
    v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF30 + 0xB0LL))(qword_149C8DF30);
    v15 = sub_1403ACC80(
            v13,
            "%s:%u",
            off_149AE7728,                      // "<local>"
            v14);
    v16 = (__int64 *)sub_14035DE10(v26, (const void **)v15);
    sub_14035E090(&v40);
    v42 = 0;
    v41 = xmmword_148711828;
    v43 = 0;
    sub_14035E090(&v44);
    sub_14035E090(&v45);
    v49 = 0;
    sub_14035DDF0(&v50, v16);
    v51 = xmmword_148711828;
    sub_140373CC0(v16);
    sub_140373CC0(&v25);
    copyStringStructure(&v40, &v27, v17);
    v42 = v29;
    v43 = v30;
    v41 = v28;
    copyStringStructure(&v44, (const void **)&v31, v18);
    copyStringStructure(&v45, &v32, v19);
    v20 = *(_QWORD *)(a1 + 0x28);
    *(_QWORD *)&v51 = 0;
    *((_QWORD *)&v51 + 1) = v5;
    v41 = v52;
    if ( (*(unsigned __int8 (__fastcall **)(__int64, void **))(*(_QWORD *)v20 + 0x10LL))(v20, &v40) )
    {
      *(_DWORD *)(a1 + 0x218) = 0;
      v24[0] = 1;
      sub_1425F4AE0(a1, a2, v24);
      v21 = v24[0];
    }
    else
    {
      v21 = 0;
    }
    sub_140373CC0(&v50);
    if ( v49 )
    {
      v22 = v47;
      if ( (_QWORD)v47 )
      {
        if ( (unsigned __int64)(2 * ((v48 - (__int64)v47) >> 1)) >= 0x1000 )
        {
          v22 = *(_QWORD *)(v47 - 8);
          if ( (unsigned __int64)(v47 - v22 - 8) > 0x1F )
LABEL_27:
            invalid_parameter_noinfo_noreturn();
        }
        sub_1402A6590(v22);
        v47 = 0;
        v48 = 0;
      }
      sub_140373CC0(&v46);
    }
    sub_140373CC0(&v45);
    sub_140373CC0(&v44);
    sub_140373CC0(&v40);
    if ( (unsigned __int64)n2 >= 2 )
    {
      n2(2, &v37);
      n2 = 0;
    }
    v37 = 0;
    if ( v36 )
    {
      v23 = v34;
      if ( (_QWORD)v34 )
      {
        if ( (unsigned __int64)(2 * ((v35 - (__int64)v34) >> 1)) >= 0x1000 )
        {
          v23 = *(_QWORD *)(v34 - 8);
          if ( (unsigned __int64)(v34 - v23 - 8) > 0x1F )
            goto LABEL_27;
        }
        sub_1402A6590(v23);
        v34 = 0;
        v35 = 0;
      }
      sub_140373CC0(&v33);
    }
    sub_140373CC0(&v32);
    sub_140373CC0(&v31);
    sub_140373CC0(&v27);
    if ( v60 != 1 )
      sub_140373CC0(&v61);
    if ( v59 )
      sub_1402A6590(v59);
    sub_140373CC0(v58);
    sub_140373CC0(&v57);
    sub_140373CC0(&v56);
    sub_140373CC0(&v55);
    sub_140373CC0(v53);
    return v21;
  }
  return result;
}

// --- End Function: sub_1425EF430 (0x1425EF430) ---

// --- Function: sub_1425EFFB0 (0x1425EFFB0) ---
__int64 __fastcall sub_1425EFFB0(__int64 a1)
{
  sub_1425D7B00();
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x18) + 0x80LL))(*(_QWORD *)(a1 + 0x18));
}

// --- End Function: sub_1425EFFB0 (0x1425EFFB0) ---

// --- Function: sub_1425F4AE0 (0x1425F4AE0) ---
void __fastcall sub_1425F4AE0(__int64 a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // rdi
  bool v6; // si
  __int64 v7; // rdx
  __int64 v8; // r8

  v3 = a3;
  if ( !(_WORD)qword_149C8E516 && (*(_DWORD *)(a2 + 8) & 0x200) != 0 )
  {
    *(_DWORD *)(a1 + 0x1D8) = 2;
    return;
  }
  v6 = 0;
  if ( *a3 && (unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 2) )
  {
    LOWORD(v7) = 4;
    v6 = (unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), v7) != 0;
  }
  if ( !*v3 )
    goto LABEL_15;
  if ( v6 )
  {
    LOBYTE(a3) = 1;
    *v3 &= sub_1425BA420(a1, sub_1425BC110, a3, "have connection");
    if ( !*v3 )
      goto LABEL_15;
  }
  if ( !(unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 2) )
    goto LABEL_15;
  if ( *(_QWORD *)(a1 + 0x40) )
  {
    if ( !sub_142382B50(*(_QWORD *)(a1 + 0x48), *(const char ***)a2) )
    {
      *v3 = 0;
      goto LABEL_23;
    }
LABEL_15:
    if ( *v3 )
    {
      if ( (unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 8)
        && !(unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 0x40)
        && (unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 4) )
      {
        LOBYTE(v8) = 1;
        *v3 &= sub_1425BA420(a1, sub_1425BC140, v8, "have player");
      }
      if ( *v3 )
      {
        if ( (unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 0x80) )
          *v3 &= sub_1425BA420(a1, sub_1425BC160, 0, "in game");
      }
    }
    goto LABEL_23;
  }
  sub_1405C6220(0xAu, 2u, "Can't ChangeGameContext() on client");
  *v3 = 0;
LABEL_23:
  *(_DWORD *)(a1 + 0x1D8) = 5;
}

// --- End Function: sub_1425F4AE0 (0x1425F4AE0) ---

// --- Function: sub_1425F4E30 (0x1425F4E30) ---
char __fastcall sub_1425F4E30(__int64 a1, unsigned int *a2)
{
  __int64 *v4; // rdx
  _BYTE *v5; // rdx
  __int64 v6; // rax
  _BYTE *v7; // rdx
  __int64 v8; // rax
  float v9; // xmm6_4
  __int64 v10; // rax
  __int64 v11; // rbx
  double v12; // xmm0_8
  __int64 n0x20; // rbx
  __int64 v14; // rax
  __int64 v15; // rbp
  __int64 v16; // rax
  unsigned int n2; // edi
  char v18; // al
  const char *p_multiplayer; // rdx
  __int64 v20; // rax
  _QWORD *v21; // rcx
  __int64 n0xC0; // rdx
  __int64 n4; // r9
  __int64 n0xC0_1; // r8
  __int64 v26; // rcx
  __int64 v27; // rax
  __int64 v28; // rax
  _QWORD v29[2]; // [rsp+20h] [rbp-38h] BYREF
  char v30; // [rsp+60h] [rbp+8h] BYREF

  *(_OWORD *)(a1 + 0x1F8) = *(_OWORD *)a2;
  v4 = *(__int64 **)a2;
  if ( v4 )
  {
    assignCStringToStringStructure(a1 + 0x208, *v4);
    assignCStringToStringStructure(a1 + 0x210, *(_QWORD *)(*(_QWORD *)a2 + 8LL));
    *(_QWORD *)(a1 + 0x1E8) = *(_QWORD *)(a1 + 0x208);
    *(_QWORD *)(a1 + 0x1F0) = *(_QWORD *)(a1 + 0x210);
    *(_QWORD *)(a1 + 0x1F8) = a1 + 0x1E8;
  }
  *(_DWORD *)(a1 + 0x1D8) = 1;
  sub_142612140(a1 + 0x1E0, 0);
  *(_DWORD *)(a1 + 0x21C) = 0;
  sub_140E17860(*(_QWORD *)(a1 + 0x48), a2[2]);
  if ( !(unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 1) )
  {
    if ( !*(_QWORD *)a2 )
      return 0;
    v5 = **(_BYTE ***)a2;
    if ( !v5 || !*v5 )
      return 0;
    assignCStringToStringStructure(*(_QWORD *)(a1 + 0x48) + 0x18LL, (__int64)v5);
    v6 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
           qword_149C8DFD0,
           "sv_map");
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x40LL))(v6, **(_QWORD **)a2);
  }
  if ( !(unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 0x10) )
  {
    if ( *(_QWORD *)a2 )
    {
      v7 = *(_BYTE **)(*(_QWORD *)a2 + 8LL);
      if ( v7 )
      {
        if ( *v7 )
        {
          assignCStringToStringStructure(*(_QWORD *)(a1 + 0x48) + 0x20LL, (__int64)v7);
          v8 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
                 qword_149C8DFD0,
                 "sv_gamerules");
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v8 + 0x40LL))(v8, *(_QWORD *)(*(_QWORD *)a2 + 8LL));
          goto LABEL_13;
        }
      }
    }
    return 0;
  }
LABEL_13:
  v9 = -1.0;
  v10 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
          qword_149C8DFD0,
          "net_inactivitytimeout");
  v11 = v10;
  if ( v10 )
  {
    v12 = (*(double (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x20LL))(v10);
    v9 = *(float *)&v12;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x38LL))(v11);
  }
  n0x20 = 0x20;
  if ( *(_QWORD *)(a1 + 0x20) )
  {
    v14 = sub_142618260(qword_149F14D30);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x28LL))(v14);
    sub_1425D7B00(a1);
    v15 = qword_149F14B60;
    if ( !qword_149F14B60 )
    {
      v16 = *(_QWORD *)qword_149C8E0F8;
      v29[0] = &v30;
      v29[1] = sub_14259ECA0;
      v15 = (*(__int64 (__fastcall **)(__int64, __int64 *, const char *, _QWORD *))(v16 + 0x48))(
              qword_149C8E0F8,
              &qword_149F14B60,
              "SEngineConfigServerMesh",
              v29);
      v29[0] = 0xFFFFFFFFFFFFFFFFuLL;
    }
    n2 = 0;
    if ( (unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 2) && !*(_DWORD *)(v15 + 0x48) )
    {
      if ( !(unsigned __int8)sub_1423847B0(*(_QWORD *)(a1 + 0x48), 0x20)
        && (unsigned __int8)sub_14261B5B0(qword_149F14D30) )
      {
        n2 = 2;
      }
      if ( (unsigned __int8)sub_14261BF30(qword_149F14D30) )
        n2 |= 1u;
    }
    (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 0x20) + 0x18LL))(
      *(_QWORD *)(a1 + 0x20),
      *(_QWORD *)(a1 + 0x48),
      n2);
  }
  v18 = sub_1423847B0(*(_QWORD *)(a1 + 0x48), 0x20);
  p_multiplayer = "singleplayer";
  if ( !v18 )
    p_multiplayer = "multiplayer";
  (*(void (__fastcall **)(__int64, const char *, _QWORD))(*(_QWORD *)qword_149C8DFE0 + 0x488LL))(
    qword_149C8DFE0,
    p_multiplayer,
    0);
  *(_QWORD *)(a1 + 0x50) = qword_149C8DF40;
  if ( !*(_QWORD *)(a1 + 0x190) )
  {
    v20 = sub_1402A65A0(0xC00u);
    if ( v20 )
    {
      v21 = (_QWORD *)(v20 + 0x50);
      do
      {
        *v21 = 0;
        v21 += 0xC;
        --n0x20;
      }
      while ( n0x20 );
    }
    else
    {
      v20 = 0;
    }
    *(_QWORD *)(a1 + 0x190) = v20;
  }
  n0xC0 = 0xC0;
  n4 = 4;
  n0xC0_1 = 0xC0;
  do
  {
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0xB8) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) - 0xB0LL;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x98) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) - 0x90LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x8C) = 0;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x88) = 1;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0xC0) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) - 0x60LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x68) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x70) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x58) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) - 0x50LL;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x38) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) - 0x30LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x2C) = 0;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x28) = 1;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x60) = *(_QWORD *)(a1 + 0x190) + n0xC0_1;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 8) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x10) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 8) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x10LL;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x28) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x30LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x34) = 0;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x38) = 1;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190)) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x60LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x58) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x50) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x68) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x70LL;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x88) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x90LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x94) = 0;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x98) = 1;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0x60) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0xC0LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0xB8) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0xB0) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) + 0xC8) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0xD0LL;
    n0xC0 += 0x300;
    *(_QWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x218) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0xF0LL;
    *(_DWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x20C) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x208) = 1;
    *(_QWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x240) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x120LL;
    *(_DWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x1E8) = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x1F0) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x1D8) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x130LL;
    *(_QWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x1B8) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x150LL;
    *(_DWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x1AC) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x1A8) = 1;
    *(_QWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x1E0) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x180LL;
    *(_DWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x188) = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 0x190) + n0xC0 - 0x190) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x178) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x190LL;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x158) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x1B0LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x14C) = 0;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x148) = 1;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x180) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x1E0LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x128) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x130) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0x118) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x1F0LL;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0xF8) = n0xC0_1 + *(_QWORD *)(a1 + 0x190) + 0x210LL;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0xEC) = 0;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0xE8) = 1;
    v26 = *(_QWORD *)(a1 + 0x190);
    v27 = n0xC0_1 + v26 + 0x240;
    n0xC0_1 += 0x300;
    *(_QWORD *)(n0xC0 + v26 - 0x120) = v27;
    --n4;
    *(_DWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0xC8) = 0;
    *(_QWORD *)(n0xC0 + *(_QWORD *)(a1 + 0x190) - 0xD0) = 0;
  }
  while ( n4 );
  LOBYTE(n0xC0) = 1;
  *(_QWORD *)(*(_QWORD *)(a1 + 0x190) + 0xBA0LL) = 0;
  *(_DWORD *)(a1 + 0x188) = 0;
  sub_1425D83C0(a1, n0xC0, n0xC0_1);
  *(_BYTE *)(a1 + 0x180) = 0;
  *(_BYTE *)(a1 + 0x10) = 9;
  if ( v9 > 0.0 )
  {
    v28 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
            qword_149C8DFD0,
            "net_inactivitytimeout");
    if ( v28 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x38LL))(v28);
  }
  return 1;
}

// --- End Function: sub_1425F4E30 (0x1425F4E30) ---

// --- Function: sub_14260F030 (0x14260F030) ---
void __fastcall sub_14260F030(__int64 a1)
{
  __int64 v2; // r8
  __int64 v3; // rax
  __int64 v4; // r9
  __int64 *v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rax
  __int64 *v8; // rax
  bool v9; // zf
  __int64 v10; // rdx
  __m128i v11; // xmm0
  __int64 v12; // rdx
  unsigned int epi32; // edx
  __int64 v14; // rdi
  void (__fastcall *v15)(__int64); // rax
  __int64 v16; // r11
  unsigned __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rsi
  __m128i v21; // [rsp+20h] [rbp-38h] BYREF
  _QWORD v22[2]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v23; // [rsp+60h] [rbp+8h] BYREF
  __int64 v24; // [rsp+68h] [rbp+10h] BYREF

  if ( *(_QWORD *)(a1 + 0x68) )
  {
    if ( *(_BYTE *)(a1 + 0x70) )
    {
      v2 = *(_QWORD *)(a1 + 0x68);
      v3 = a1 + 0x48;
      v4 = *(_QWORD *)(a1 + 0x60);
      v5 = *(__int64 **)(a1 + 0x48);
      if ( v3 && v5 )
      {
        v6 = *v5;
        v7 = *v5;
      }
      else
      {
        v6 = 0;
        if ( v5 )
          v7 = *v5;
        else
          v7 = 0;
      }
      v22[0] = v6;
      v22[1] = v4;
      v21.m128i_i64[0] = v7;
      v21.m128i_i64[1] = v4 + v2;
      sub_1425B15F0((__int64)v22, (__int64)&v21, v2, 0);
      *(_BYTE *)(a1 + 0x70) = 0;
    }
    v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                      qword_149C8DF80,
                      0);
    v9 = *(_QWORD *)(a1 + 0x68) == 0;
    v23 = *v8;
    if ( !v9 )
    {
      do
      {
        if ( !sub_14059CAE0(
                *(_QWORD **)(*(_QWORD *)(a1 + 0x50) + 8 * (*(_QWORD *)(a1 + 0x60) & (*(_QWORD *)(a1 + 0x58) - 1LL))),
                &v23) )
          break;
        v10 = *(_QWORD *)(a1 + 0x60);
        v11 = *(__m128i *)*(_QWORD *)(*(_QWORD *)(a1 + 0x50) + 8 * (v10 & (*(_QWORD *)(a1 + 0x58) - 1LL)));
        v9 = (*(_QWORD *)(a1 + 0x68))-- == 1;
        v21 = v11;
        if ( v9 )
          v12 = 0;
        else
          v12 = v10 + 1;
        *(_QWORD *)(a1 + 0x60) = v12;
        epi32 = _mm_extract_epi32(v11, 2);
        v14 = *(_QWORD *)(a1 + 0x30) + 0x30LL * (unsigned __int16)(epi32 - 1);
        v15 = *(void (__fastcall **)(__int64))(v14 + 8);
        if ( *(_QWORD *)(v14 + 0x10) == 1 )
          v15(epi32);
        else
          v15(v14 + 8);
        v16 = *(_QWORD *)(a1 + 0x30);
        v17 = (unsigned __int16)(v21.m128i_i16[4] - 1);
        if ( v17 < (*(_QWORD *)(a1 + 0x38) - v16) / 0x30
          && v21.m128i_i16[5] >= 0
          && *(_WORD *)(v16 + 0x30 * v17 + 0x28) == v21.m128i_i16[5] )
        {
          if ( *(_BYTE *)(v14 + 0x20) )
          {
            sub_14059CA80(&v21, &v24, (_QWORD *)v14);
            v18 = v24;
            if ( v24 <= v23 )
            {
              v18 = v23 + 1;
              v24 = v23 + 1;
            }
            v21.m128i_i64[0] = v18;
            if ( *(_QWORD *)(a1 + 0x58) <= (unsigned __int64)(*(_QWORD *)(a1 + 0x68) + 1LL) )
              sub_140DEFD80((_QWORD *)(a1 + 0x48), 1u);
            v19 = *(_QWORD *)(a1 + 0x58) - 1LL;
            *(_QWORD *)(a1 + 0x60) &= v19;
            v20 = 8 * (v19 & (*(_QWORD *)(a1 + 0x60) + *(_QWORD *)(a1 + 0x68)));
            if ( !*(_QWORD *)(v20 + *(_QWORD *)(a1 + 0x50)) )
              *(_QWORD *)(v20 + *(_QWORD *)(a1 + 0x50)) = sub_1402A65A0(0x10u);
            *(__m128i *)*(_QWORD *)(v20 + *(_QWORD *)(a1 + 0x50)) = v21;
            ++*(_QWORD *)(a1 + 0x68);
            *(_BYTE *)(a1 + 0x70) = 1;
          }
          else
          {
            sub_142611B00(a1, v21.m128i_u32[2]);
          }
        }
      }
      while ( *(_QWORD *)(a1 + 0x68) );
    }
  }
}

// --- End Function: sub_14260F030 (0x14260F030) ---

// --- Function: sub_142611B00 (0x142611B00) ---
unsigned __int64 __fastcall sub_142611B00(_QWORD *a1, int a2)
{
  __int64 v2; // rdi
  unsigned __int64 v4; // rcx
  __int64 v5; // r8
  unsigned __int64 n0x8000; // rax
  __int64 v7; // rbx
  __int64 v8; // rcx
  unsigned __int64 v9; // rcx
  void (__fastcall *n2)(__int64, __int64, _QWORD); // rax

  v2 = a1[6];
  v4 = (unsigned __int16)(a2 - 1);
  v5 = a1[7] - v2;
  n0x8000 = (unsigned __int64)((unsigned __int128)(v5 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F;
  if ( v4 < v5 / 0x30 )
  {
    v7 = v2 + 0x30 * v4;
    if ( *(_WORD *)(v7 + 0x28) == HIWORD(a2) )
    {
      *(_WORD *)(*a1 + 2LL * a1[4]) = a2 - 1;
      v8 = a1[7] - a1[6];
      ++a1[5];
      v9 = (__int64)((unsigned __int128)(v8 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 3;
      a1[4] = (a1[4] + 1LL) % ((v9 >> 0x3F) + v9);
      n2 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v7 + 0x10);
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v7 + 8, 0);
        *(_QWORD *)(v7 + 0x10) = 0;
      }
      n0x8000 = 0x8000;
      *(_QWORD *)(v7 + 8) = 0;
      *(_WORD *)(v7 + 0x28) |= 0x8000u;
    }
  }
  return n0x8000;
}

// --- End Function: sub_142611B00 (0x142611B00) ---

// --- Function: sub_142612B80 (0x142612B80) ---
const ULONG_PTR *__fastcall sub_142612B80(_QWORD *a1, void (__fastcall *a2)(_QWORD, __int64), __int64 a3)
{
  __int64 v4; // rbx
  int v7; // esi
  unsigned int v8; // eax
  __int64 v9; // rcx
  __int64 v10; // rdi
  char *v11; // rdi
  char v12; // r8
  _QWORD *v13; // rcx
  __int64 *v14; // rax
  int v15; // eax
  const ULONG_PTR *result; // rax
  __int64 v17; // [rsp+30h] [rbp-49h] BYREF
  __int64 v18; // [rsp+38h] [rbp-41h]
  _QWORD *v19; // [rsp+40h] [rbp-39h]
  __int64 v20; // [rsp+48h] [rbp-31h]
  __int64 v21; // [rsp+50h] [rbp-29h]
  _BYTE v22[2]; // [rsp+60h] [rbp-19h] BYREF
  __int16 v23; // [rsp+62h] [rbp-17h]
  __int64 v24; // [rsp+64h] [rbp-15h]
  int v25; // [rsp+6Ch] [rbp-Dh]
  unsigned __int64 v26; // [rsp+70h] [rbp-9h]
  unsigned __int64 v27; // [rsp+78h] [rbp-1h]
  __int64 v28; // [rsp+80h] [rbp+7h]
  __int64 v29; // [rsp+88h] [rbp+Fh]
  __int16 v30; // [rsp+E0h] [rbp+67h] BYREF

  v4 = (__int64)(a1 + 4);
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
    if ( v8 )
      sub_1403C6E80(v4, v8, (__int64)"SCIGListenerSet<struct IGameFrameworkListener>::Notify", 1);
    else
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v4 + 0x10) = v7;
  }
  v9 = a1[1] - *a1;
  v17 = *a1;
  v9 >>= 4;
  v21 = v9;
  v19 = a1;
  v20 = 0;
  v18 = a1[3];
  a1[3] = &v17;
  if ( v9 > 0 )
  {
    v10 = v20;
    do
    {
      v11 = (char *)(v17 + 0x10 * v10);
      v12 = *v11;
      v30 = *((_WORD *)v11 + 1);
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v22[1] = v12;
      v26 = __rdtsc();
      v22[0] = 0;
      qword_149C89AA0(v22, &v30, &p_Src, &p_Src, 0);
      v23 = v30;
      a2(*((_QWORD *)v11 + 1), a3);
      ++v20;
      v27 = __rdtsc();
      qword_149C89AA8(v22);
      v10 = v20;
    }
    while ( v20 < v21 );
  }
  v13 = v19 + 3;
  v14 = (__int64 *)v19[3];
  if ( v14 )
  {
    while ( v14 != &v17 )
    {
      v13 = v14 + 1;
      v14 = (__int64 *)v14[1];
      if ( !v14 )
        goto LABEL_15;
    }
    *v13 = v18;
  }
LABEL_15:
  v15 = *(_DWORD *)(v4 + 0x14);
  if ( v15 )
  {
    result = (const ULONG_PTR *)(unsigned int)(v15 - 1);
    *(_DWORD *)(v4 + 0x14) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
    result = (const ULONG_PTR *)(unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
    if ( (_DWORD)result == 1 )
      *(_QWORD *)(v4 + 8) = &p_Src;
    else
      return sub_1403DF590(v4, (unsigned int)result);
  }
  return result;
}

// --- End Function: sub_142612B80 (0x142612B80) ---

// --- Function: sub_142616380 (0x142616380) ---
__int64 __fastcall sub_142616380(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  _QWORD *v3; // rdi
  _QWORD *j; // rbx
  void (__fastcall ***v5)(_QWORD, __int64); // r14
  void (__fastcall *v6)(_QWORD, __int64); // rsi
  __int64 v7; // rax
  __int64 **v8; // rax
  __int64 i; // rax
  __int64 *v10; // rcx
  _QWORD v12[2]; // [rsp+20h] [rbp-F8h] BYREF
  _DWORD *v13; // [rsp+30h] [rbp-E8h]
  _BYTE v14[176]; // [rsp+40h] [rbp-D8h] BYREF
  __int64 v15; // [rsp+F0h] [rbp-28h] BYREF

  result = *(_QWORD *)(a1 + 0x50);
  if ( result )
  {
    v2 = *(_QWORD *)(result + 0x40);
    if ( v2 )
    {
      sub_1425DCA00(v2, (__int64)v12);
      v3 = *(_QWORD **)v12[0];
      j = **(_QWORD ***)v12[0];
      if ( j != *(_QWORD **)v12[0] )
      {
        do
        {
          v5 = *(void (__fastcall ****)(_QWORD, __int64))(j[6] + 0x10LL);
          v6 = **v5;
          v7 = sub_140421510((__int64)v14, 0x7544, "DGS disconnecting all channels before game shutdown");
          v6(v5, v7);
          sub_140373CC0(&v15);
          v8 = (__int64 **)j[2];
          if ( *((_BYTE *)v8 + 0x19) )
          {
            for ( i = j[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
            {
              if ( j != *(_QWORD **)(i + 0x10) )
                break;
              j = (_QWORD *)i;
            }
            j = (_QWORD *)i;
          }
          else
          {
            v10 = *v8;
            for ( j = (_QWORD *)j[2]; !*((_BYTE *)v10 + 0x19); v10 = (__int64 *)*v10 )
              j = v10;
          }
        }
        while ( j != v3 );
      }
      result = (__int64)v13;
      if ( (*v13)-- == 1 )
        return rw_lock_release_read_lock(v12[1]);
    }
  }
  return result;
}

// --- End Function: sub_142616380 (0x142616380) ---

// --- Function: sub_1426165C0 (0x1426165C0) ---
void __fastcall sub_1426165C0(_QWORD *a1)
{
  __int64 v2; // rbx
  __int64 v3; // rcx
  __int64 v4; // rsi
  int v5; // eax
  int v6; // eax
  Parameter *Parameter; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  _QWORD *v12; // rdi
  _DWORD v13[14]; // [rsp+28h] [rbp-50h] BYREF

  if ( qword_149C8E0F8 )
  {
    sub_14036F220((__int64)v13);
    v13[0] = 0x17;
    if ( qword_149C8E0F8 && qword_149C8DFC0 )
      (*(void (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149C8DFC0 + 0x178LL))(qword_149C8DFC0, v13);
    v2 = a1[0xA];
    if ( v2 )
      _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
    v3 = a1[0xA];
    v4 = 0;
    if ( v3 )
    {
      v5 = _InterlockedDecrement((volatile signed __int32 *)(v3 + 8));
      if ( v5 )
      {
        if ( v5 < 0 )
          LogFatalError("Deleting Reference Counted Object Twice");
      }
      else
      {
        (**(void (__fastcall ***)(__int64, __int64))v3)(v3, 1);
      }
      a1[0xA] = 0;
    }
    if ( v2 )
    {
      v6 = _InterlockedDecrement((volatile signed __int32 *)(v2 + 8));
      if ( v6 )
      {
        if ( v6 < 0 )
          LogFatalError("Deleting Reference Counted Object Twice");
      }
      else
      {
        (**(void (__fastcall ***)(__int64, __int64))v2)(v2, 1);
      }
    }
    Parameter = a1[0xAB];
    if ( Parameter )
      _StarEngineModule__(Parameter);
    if ( qword_149C8E0F8 && (_BYTE)qword_149C8E516 )
    {
      v8 = sub_1402A65A0(0x220u);
      if ( v8 )
        v4 = sub_1425B23C0(v8);
      if ( a1[0xA] != v4 )
      {
        if ( v4 )
          _InterlockedIncrement((volatile signed __int32 *)(v4 + 8));
        v9 = a1[0xA];
        if ( v9 )
        {
          v10 = _InterlockedDecrement((volatile signed __int32 *)(v9 + 8));
          if ( v10 )
          {
            if ( v10 < 0 )
              LogFatalError("Deleting Reference Counted Object Twice");
          }
          else
          {
            (**(void (__fastcall ***)(__int64, __int64))v9)(v9, 1);
          }
        }
        a1[0xA] = v4;
      }
    }
    v11 = a1[0x9C];
    if ( v11 )
      sub_14237CCF0(v11);
    v12 = (_QWORD *)a1[0xE0];
    if ( v12 )
    {
      sub_140373CC0(v12);
      sub_14035E090(v12);
    }
    if ( qword_149C8E0F8 )
    {
      if ( qword_149C8DFE0 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x610LL))(qword_149C8DFE0);
      if ( qword_149C8E0F8 )
      {
        if ( qword_149C8DF58 )
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF58 + 0x308LL))(qword_149C8DF58, 0);
      }
    }
  }
}

// --- End Function: sub_1426165C0 (0x1426165C0) ---

// --- Function: sub_142617870 (0x142617870) ---
__int64 __fastcall sub_142617870(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *(_QWORD *)(a1 + 0x50);
  if ( v1 && (v2 = *(_QWORD *)(v1 + 0x38)) != 0 && (v3 = *(_QWORD *)(v2 + 0x20)) != 0 )
    return *(_QWORD *)(v3 + 0x10);
  else
    return 0;
}

// --- End Function: sub_142617870 (0x142617870) ---

// --- Function: sub_142618260 (0x142618260) ---
_QWORD *__fastcall sub_142618260(__int64 a1)
{
  _QWORD *result; // rax

  result = *(_QWORD **)(a1 + 0x620);
  if ( !result )
  {
    result = (_QWORD *)sub_1402A65A0(8u);
    if ( result )
    {
      result = sub_1425530A0(result);
      *(_QWORD *)(a1 + 0x620) = result;
    }
    else
    {
      *(_QWORD *)(a1 + 0x620) = 0;
    }
  }
  return result;
}

// --- End Function: sub_142618260 (0x142618260) ---

// --- Function: sub_1426182E0 (0x1426182E0) ---
__int64 __fastcall sub_1426182E0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x4D8);
}

// --- End Function: sub_1426182E0 (0x1426182E0) ---

// --- Function: sub_142618330 (0x142618330) ---
__int64 __fastcall sub_142618330(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x6F8);
}

// --- End Function: sub_142618330 (0x142618330) ---

// --- Function: sub_14261B630 (0x14261B630) ---
__int64 __fastcall sub_14261B630(_QWORD *a1, int a2)
{
  __int64 result; // rax
  const char *String2; // rdi
  __int64 String2_1; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rbx
  char v10; // bp
  __int64 v11; // rcx
  _QWORD *v12; // rcx
  _QWORD *v13; // rax
  __int64 v14; // rdi
  __int64 v15; // r8
  __int64 v16; // rbx
  __int64 v17; // rbx
  __int64 v18; // rbx
  bool v19; // al
  const char *v20[2]; // [rsp+20h] [rbp-38h] BYREF
  _QWORD v21[2]; // [rsp+30h] [rbp-28h] BYREF

  if ( (_BYTE)qword_149C8E516 )
    return sub_1405C6220(0xAu, 2u, "Won't load level in editor");
  String2 = (const char *)a1[0xE9];
  String2_1 = sub_142384210(*(_QWORD *)(qword_149F14D30 + 0x5A8), String2);
  if ( String2_1 )
    String2 = (const char *)String2_1;
  else
    sub_1405C6220(0xAu, 0, "!Couldn't find Game Rules \"%s\". Default will be used", String2);
  if ( sub_142384310(*(_QWORD *)(qword_149F14D30 + 0x4D8), "megamap") )
  {
    LogTraceConditional("============================ Loading level %s ============================", "megamap");
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x2A0LL))(qword_149C8DFE0);
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v8 + 0x18LL))(v8, 0x10, 0);
    v9 = qword_149F14D30;
    v10 = 0;
    v20[1] = String2;
    v20[0] = "megamap";
    v11 = *(_QWORD *)(qword_149F14D30 + 0x50);
    if ( v11 && *(_DWORD *)(v11 + 0x1D8) == 5 )
    {
      if ( BYTE1(qword_149C8E516) )
      {
        sub_1425BA9C0(v11, v20);
        v10 = 1;
      }
      else
      {
        sub_1426165C0((_QWORD *)qword_149F14D30);
      }
      v9 = qword_149F14D30;
    }
    v12 = *(_QWORD **)(v9 + 0x620);
    if ( !v12 )
    {
      v13 = (_QWORD *)sub_1402A65A0(8u);
      if ( v13 )
        v12 = sub_1425530A0(v13);
      else
        v12 = 0;
      *(_QWORD *)(v9 + 0x620) = v12;
    }
    result = (*(__int64 (__fastcall **)(_QWORD *, const char *, const char *))(*v12 + 8LL))(v12, "megamap", String2);
    if ( (_BYTE)result )
    {
      if ( v20[0] )
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(qword_149F14D30 + 0x4D8) + 0x58LL))(*(_QWORD *)(qword_149F14D30 + 0x4D8));
      v21[0] = 2;
      *(_BYTE *)(qword_149F14D30 + 0x738) = 1;
      v14 = qword_149F14D30;
      v21[1] = v20[0];
      sub_142612B80(
        (_QWORD *)(qword_149F14D30 + 0x6C0),
        (void (__fastcall *)(_QWORD, __int64))sub_140B1A1CC,
        (__int64)v21);
      result = LODWORD(v21[0]);
      if ( LODWORD(v21[0]) )
      {
        if ( LODWORD(v21[0]) == 4 && !(_BYTE)qword_149C8E516 )
        {
          v16 = *(_QWORD *)(v14 + 0x5D0);
          if ( v16 )
          {
            sub_1423C9640(*(__int64 **)(v14 + 0x5D0));
            result = sub_1402A6590(v16);
            *(_QWORD *)(v14 + 0x5D0) = 0;
          }
        }
      }
      else
      {
        v17 = qword_149C8DF50;
        if ( qword_149C8DF50 )
        {
          LOBYTE(v15) = 1;
          (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)qword_149C8DF50 + 0x170LL))(
            qword_149C8DF50,
            0,
            v15);
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v17 + 0x170LL))(v17, 1, 1);
        }
      }
      if ( !v10 )
      {
        v18 = a1[0xDF];
        v19 = sub_1403C3450(a1 + 0xEB);
        return sub_142597110(v18, (__int64)v20, a2, !v19);
      }
    }
  }
  else
  {
    sub_1405C6220(0xAu, 2u, "!Couldn't find map '%s'. We only support loading megamap records now.", "megamap");
    if ( !_stricmp("megamap", "MegaMap") )
      LogFatalError("MegaMap level data missing! Try syncing Data/Levels/MegaMap.");
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x2A0LL))(qword_149C8DFE0);
    return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v7 + 0x18LL))(v7, 0x15, 0);
  }
  return result;
}

// --- End Function: sub_14261B630 (0x14261B630) ---

// --- Function: sub_14261CF60 (0x14261D176) ---
__int64 __fastcall sub_14261CF60(__int64 a1, __int64 a2, unsigned int a3)
{
  __int128 v3; // xmm6
  unsigned int v6; // ebx
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  bool v11; // di
  char v12; // bp
  __int64 v13; // rcx
  char v16; // r14
  __int64 v17; // rdi
  void (__fastcall *v18)(__int64, __int64); // rbx
  __int64 v19; // rax
  __int64 v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // rcx
  __int64 v25; // rax
  __int64 *v26; // rax
  __int64 v27; // rcx
  __int64 v28; // rcx
  __int64 v29; // rax
  __int64 v30; // rcx
  __int64 v31; // rax
  _BYTE v33[16]; // [rsp+30h] [rbp-88h] BYREF
  int n0x3500; // [rsp+40h] [rbp-78h] BYREF
  __int64 v35; // [rsp+44h] [rbp-74h]
  int v36; // [rsp+4Ch] [rbp-6Ch]
  unsigned __int64 v37; // [rsp+50h] [rbp-68h]
  unsigned __int64 v38; // [rsp+58h] [rbp-60h]
  __int64 v39; // [rsp+60h] [rbp-58h]
  __int64 v40; // [rsp+68h] [rbp-50h]
  __int128 v41; // [rsp+90h] [rbp-28h]
  char v42; // [rsp+C0h] [rbp+8h] BYREF

  *(float *)&dword_149F14D38 = 10.0;
  v41 = v3;
  v6 = 0;
  if ( !sub_1403C3450(*(_QWORD **)(a1 + 0x700)) )
  {
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149C8DFD0 + 0x130LL))(
      qword_149C8DFD0,
      **(_QWORD **)(a1 + 0x700),
      0,
      0,
      0);
    sub_1403EDAA0(*(void ***)(a1 + 0x700), 0, 0x20);
  }
  sub_14259D2A0(*(_QWORD *)(a1 + 0x6F8));
  sub_14244C930(*(_QWORD *)(a1 + 0x618));
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x570LL))(qword_149C8DFE0);
  if ( v7 )
    (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v7 + 0x10LL))(v7, &v42);
  v8 = *(_QWORD *)(a1 + 0x50);
  v11 = 0;
  if ( v8 )
  {
    if ( (v9 = *(_QWORD *)(v8 + 0x48)) != 0 && *(_DWORD *)(v9 + 0x2C) == 3
      || (v10 = *(_QWORD *)(v8 + 0x48)) != 0 && *(_DWORD *)(v10 + 0x2C) == 2 )
    {
      v11 = 1;
    }
  }
  if ( !*(_BYTE *)(a1 + 0x10) )
    goto LABEL_16;
  if ( qword_149C8DFB8 )
  {
    if ( (_BYTE)qword_149C8E516 && !BYTE3(qword_149C8E516) )
      goto LABEL_16;
LABEL_43:
    v12 = 1;
    goto LABEL_17;
  }
  if ( !(_BYTE)qword_149C8E516 )
    goto LABEL_43;
LABEL_16:
  v12 = 0;
LABEL_17:
  if ( v11 && !v12 )
  {
    v13 = *(_QWORD *)(a1 + 0x5D0);
    if ( v13 )
      sub_14260F030(v13);
  }
  n0x3500 = 0x3500;
  v35 = 1;
  v36 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v37 = __rdtsc();
  qword_149C89AA0(
    &n0x3500,
    &word_149F14F9C,
    "CCryAction::PreUpdate",
    "W:/p4-src/CryEngine/Code/CryEngine/CryAction/CryAction.cpp",
    0x4B0);
  HIWORD(n0x3500) = word_149F14F9C;
  (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, &v42, 0);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
  if ( (a3 & 0xA) != 2 )
    sub_1424C66F0(*(_QWORD *)(a1 + 0x558));
  if ( !v11
    || *(_BYTE *)(a1 + 0x10)
    || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0xB8LL))(qword_149C8DF80, 0) )
  {
    v6 = 1;
  }
  v16 = v12;
  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 0x20) + 0x20LL))(*(_QWORD *)(a1 + 0x20), a3, v6);
  v17 = *(_QWORD *)(a1 + 0x20);
  v18 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v17 + 0x70LL);
  v19 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0xA0LL))(qword_149C8E018);
  v18(v17, v19);
  if ( (a3 & 2) == 0 )
  {
    if ( qword_149F04448 )
      sub_142305E10(qword_149F04448);
    v20 = *(_QWORD *)(a1 + 0x50);
    if ( v20
      && ((v21 = *(_QWORD *)(v20 + 0x48)) != 0 && *(_DWORD *)(v21 + 0x2C) == 3
       || (v22 = *(_QWORD *)(v20 + 0x48)) != 0 && *(_DWORD *)(v22 + 0x2C) == 2)
      && *(_DWORD *)(v20 + 0x1D8) == 5 )
    {
      v12 = *(_BYTE *)(a1 + 0x10);
      if ( !v12 )
      {
        if ( !v16 )
        {
          v23 = *(_QWORD *)(a1 + 0x5A0);
          if ( v23 )
            sub_1425065F0(v23);
        }
        if ( qword_149C8DF48 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF48 + 0x28LL))(qword_149C8DF48);
      }
    }
    else
    {
      v12 = *(_BYTE *)(a1 + 0x10);
    }
    if ( qword_149C8E040 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E040 + 0x80LL))(qword_149C8E040);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E000 + 0x108LL))(qword_149C8E000);
  }
  sub_1424EA790(*(_QWORD *)(a1 + 0x588));
  sub_142573E60(*(_QWORD *)(a1 + 0x5E0), *(float *)&_XMM6);
  v24 = *(_QWORD *)(a1 + 0x590);
  if ( v24 )
    sub_14215A470(v24);
  if ( *(_QWORD *)(a1 + 0x520) )
  {
    if ( v12 )
    {
      if ( qword_149C8DFB8 )
      {
        v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0x60LL))(qword_149C8DFB8);
        if ( v25 )
        {
          v26 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v25 + 0x5B8LL))(v25, v33);
          if ( sub_1403EAAF0(v26) )
          {
            (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x550) + 0x28LL))(*(_QWORD *)(a1 + 0x550));
            goto LABEL_62;
          }
        }
      }
    }
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x520) + 0x70LL))(*(_QWORD *)(a1 + 0x520));
  }
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x550) + 0x28LL))(*(_QWORD *)(a1 + 0x550));
  if ( !v12 )
  {
    v27 = *(_QWORD *)(a1 + 0x5C0);
    if ( v27 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v27 + 8LL))(v27);
    v28 = *(_QWORD *)(a1 + 0x558);
    if ( v28 )
      sub_1424C9F20(v28);
  }
LABEL_62:
  if ( *(_DWORD *)(a1 + 0x744) == 1 )
  {
    v29 = *(_QWORD *)(a1 + 0x50);
    if ( !v29 || (unsigned int)(*(_DWORD *)(v29 + 0x1D8) - 1) > 3 )
    {
      *(_DWORD *)(a1 + 0x744) = 2;
      sub_14261B630((_QWORD *)a1, 0);
    }
  }
  sub_142305E70(*(_QWORD *)(a1 + 0x688));
  v30 = *(_QWORD *)(a1 + 0x698);
  if ( v30 )
    sub_142371B60(v30);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x308LL))(qword_149C8DFE0) && !v12 )
  {
    v31 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x308LL))(qword_149C8DFE0);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x40LL))(v31);
  }
  v38 = __rdtsc();
  return qword_149C89AA8(&n0x3500);
}

// --- End Function: sub_14261CF60 (0x14261D176) ---

// --- Function: sub_14261E880 (0x14261E880) ---
char __fastcall sub_14261E880(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax

  v6 = sub_1402A65A0(0x220u);
  if ( v6 )
    v6 = sub_1425B23C0(v6);
  sub_14189C120(a1 + 0xA, v6);
  if ( sub_1425EF190(a1[0xA], a2, a3) )
    return 1;
  sub_1405C6220(0xAu, 2u, "Failed initializing game");
  sub_1426165C0(a1);
  return 0;
}

// --- End Function: sub_14261E880 (0x14261E880) ---

// --- Function: sub_14261EA20 (0x14261EA20) ---
char __fastcall sub_14261EA20(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rax

  v4 = sub_1402A65A0(0x220u);
  if ( v4 )
    v4 = sub_1425B23C0(v4);
  sub_14189C120(a1 + 0xA, v4);
  if ( (unsigned __int8)sub_1425EF3A0(a1[0xA], a2) )
    return 1;
  sub_1405C6220(0xAu, 2u, "Failed initializing game");
  sub_1426165C0(a1);
  return 0;
}

// --- End Function: sub_14261EA20 (0x14261EA20) ---

// --- Function: sub_14261EAB0 (0x14261EAB0) ---
char __fastcall sub_14261EAB0(_QWORD *a1, __int64 a2)
{
  __int64 *v4; // rbx
  __int64 v5; // rax

  if ( (_BYTE)qword_149C8E516 )
  {
    v4 = a1 + 0xA;
    if ( !a1[0xA] )
      LogFatalError("Must have game around always for editor");
  }
  else
  {
    v5 = sub_1402A65A0(0x220u);
    if ( v5 )
      v5 = sub_1425B23C0(v5);
    v4 = a1 + 0xA;
    sub_14189C120(a1 + 0xA, v5);
  }
  if ( (unsigned __int8)sub_1425EF430(*v4, a2) )
    return 1;
  sub_1405C6220(0xAu, 2u, "Failed initializing game");
  sub_1426165C0(a1);
  return 0;
}

// --- End Function: sub_14261EAB0 (0x14261EAB0) ---

// --- Function: sub_14262C950 (0x14262C950) ---
_QWORD *__fastcall sub_14262C950(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_20;
  if ( n0xFFFF_20 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                          qword_149C8DFC8,
                          &v9,
                          "SCItemWeaponComponent");
    n0xFFFF_20 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14262C950 (0x14262C950) ---

// --- Function: sub_142643440 (0x142643440) ---
__int64 sub_142643440()
{
  __int64 result; // rax
  unsigned int v1; // edi
  _QWORD **v2; // rcx
  _QWORD *v3; // rdx
  _QWORD *v4; // rbx
  __int64 v5; // [rsp+20h] [rbp-60h] BYREF
  char v6; // [rsp+28h] [rbp-58h]
  unsigned int v7; // [rsp+30h] [rbp-50h] BYREF
  _BYTE v8[8]; // [rsp+38h] [rbp-48h] BYREF
  unsigned __int64 v9[2]; // [rsp+40h] [rbp-40h] BYREF
  __int128 v10; // [rsp+50h] [rbp-30h] BYREF
  __int64 v11; // [rsp+60h] [rbp-20h]
  unsigned __int8 *v12; // [rsp+90h] [rbp+10h] BYREF
  char v13; // [rsp+98h] [rbp+18h] BYREF

  result = (unsigned int)dword_149F1AE74;
  if ( !dword_149F1AE74 )
  {
    sub_140530130((__int64)&v7);
    v12 = (unsigned __int8 *)&dword_149F1AE74;
    sub_14035ADB0((__int64)v8, (__int64)&v5, (unsigned __int8 *)&v12);
    if ( v6 )
    {
      CreateStringObjectFromString((void **)&v12, "SQDRVSnapshotVariables");
      sub_140531040((int *)&v7, v12);
      sub_140373CC0(&v12);
      sub_14264DB80(&v7, 0);
      sub_1403E9C10(v8, &v13, v5);
    }
    v1 = v7;
    if ( (_QWORD)v10 )
    {
      sub_1403A6820((__int64)&v10, v10, (v11 - v10) & 0xFFFFFFFFFFFFFFF8uLL);
      v10 = 0;
      v11 = 0;
    }
    v2 = (_QWORD **)v9[0];
    **(_QWORD **)(v9[0] + 8) = 0;
    v3 = *v2;
    if ( *v2 )
    {
      do
      {
        v4 = (_QWORD *)*v3;
        sub_1403A6820((__int64)v9, (unsigned __int64)v3, 0x18u);
        v3 = v4;
      }
      while ( v4 );
    }
    sub_1403A6820((__int64)v9, v9[0], 0x18u);
    result = v1;
    dword_149F1AE74 = v1;
  }
  return result;
}

// --- End Function: sub_142643440 (0x142643440) ---

// --- Function: sub_142643570 (0x142643570) ---
__int64 sub_142643570()
{
  __int64 result; // rax
  unsigned int v1; // edi
  _QWORD **v2; // rcx
  _QWORD *v3; // rdx
  _QWORD *v4; // rbx
  _DWORD v5[4]; // [rsp+20h] [rbp-58h] BYREF
  unsigned __int64 v6[2]; // [rsp+30h] [rbp-48h] BYREF
  __int128 v7; // [rsp+40h] [rbp-38h] BYREF
  __int64 v8; // [rsp+50h] [rbp-28h]

  result = (unsigned int)dword_149F1AE54;
  if ( !dword_149F1AE54 )
  {
    sub_140530130((__int64)v5);
    sub_14263CAB0(v5, &p_Src, 0);
    v1 = v5[0];
    if ( (_QWORD)v7 )
    {
      sub_1403A6820((__int64)&v7, v7, (v8 - v7) & 0xFFFFFFFFFFFFFFF8uLL);
      v7 = 0;
      v8 = 0;
    }
    v2 = (_QWORD **)v6[0];
    **(_QWORD **)(v6[0] + 8) = 0;
    v3 = *v2;
    if ( *v2 )
    {
      do
      {
        v4 = (_QWORD *)*v3;
        sub_1403A6820((__int64)v6, (unsigned __int64)v3, 0x18u);
        v3 = v4;
      }
      while ( v4 );
    }
    sub_1403A6820((__int64)v6, v6[0], 0x18u);
    result = v1;
    dword_149F1AE54 = v1;
  }
  return result;
}

// --- End Function: sub_142643570 (0x142643570) ---

// --- Function: sub_142647CF0 (0x142647CF0) ---
__int64 sub_142647CF0()
{
  __int64 result; // rax
  unsigned int v1; // edi
  _QWORD **v2; // rcx
  _QWORD *v3; // rdx
  _QWORD *v4; // rbx
  _DWORD v5[4]; // [rsp+20h] [rbp-58h] BYREF
  unsigned __int64 v6[2]; // [rsp+30h] [rbp-48h] BYREF
  __int128 v7; // [rsp+40h] [rbp-38h] BYREF
  __int64 v8; // [rsp+50h] [rbp-28h]
  void *v9; // [rsp+80h] [rbp+8h] BYREF

  result = (unsigned int)dword_149F1AE70;
  if ( !dword_149F1AE70 )
  {
    sub_140530130((__int64)v5);
    CreateStringObjectFromString(&v9, "EQuantumDriveState");
    sub_140530E30(v5, v9, 0xB, &unk_149AF7DC0);
    sub_140373CC0(&v9);
    v1 = v5[0];
    if ( (_QWORD)v7 )
    {
      sub_1403A6820((__int64)&v7, v7, (v8 - v7) & 0xFFFFFFFFFFFFFFF8uLL);
      v7 = 0;
      v8 = 0;
    }
    v2 = (_QWORD **)v6[0];
    **(_QWORD **)(v6[0] + 8) = 0;
    v3 = *v2;
    if ( *v2 )
    {
      do
      {
        v4 = (_QWORD *)*v3;
        sub_1403A6820((__int64)v6, (unsigned __int64)v3, 0x18u);
        v3 = v4;
      }
      while ( v4 );
    }
    sub_1403A6820((__int64)v6, v6[0], 0x18u);
    result = v1;
    dword_149F1AE70 = v1;
  }
  return result;
}

// --- End Function: sub_142647CF0 (0x142647CF0) ---

// --- Function: sub_142659050 (0x142659050) ---
__int64 __fastcall sub_142659050(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  unsigned __int64 v8; // rax
  __int64 v9; // rbp
  __int64 v10; // rbx
  __int64 i; // rdi
  char v12; // al
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v17; // rax
  const void *v18; // rdx
  char *v19; // rdi
  signed __int64 Size; // rbx
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rbx
  __int64 v23; // rax
  __int64 v24; // rcx
  unsigned __int64 v25; // rax
  __int64 v26; // rbp
  __int64 v27; // rdi
  _QWORD *v28; // r14
  _BYTE *v29; // rbx
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rbx
  __int64 v32; // rax
  __int64 v33; // rcx
  unsigned __int64 v34; // rax
  __int64 v35; // rbp
  __int64 v36; // rdi
  __int64 j; // rbx

  *(_QWORD *)(a1 + 8) = 0x1FF;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  sub_1402A6440(a1, *(const void **)(a2 + 0x10), *(_QWORD *)a2);
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x228) = a1 + 0x230;
  *(_QWORD *)(a1 + 0x220) = 0x1FF;
  sub_1402A6440(a1 + 0x218, *(const void **)(a2 + 0x228), *(_QWORD *)(a2 + 0x218));
  *(_QWORD *)(a1 + 0x430) = 0;
  *(_QWORD *)(a1 + 0x438) = 0;
  *(_QWORD *)(a1 + 0x440) = 0;
  v4 = (*(_QWORD *)(a2 + 0x438) - *(_QWORD *)(a2 + 0x430)) / 0x28LL;
  if ( v4 )
  {
    if ( v4 > 0x666666666666666LL )
      unknown_libname_10();
    v5 = 0x28 * v4;
    if ( 0x28 * v4 < 0x1000 )
    {
      if ( v5 )
        v8 = sub_1402A65A0(0x28 * v4);
      else
        v8 = 0;
    }
    else
    {
      if ( v5 + 0x27 < v5 )
        goto LABEL_50;
      v6 = sub_1402A65A0(v5 + 0x27);
      v7 = v6;
      if ( !v6 )
        goto LABEL_42;
      v8 = (v6 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v8 - 8) = v7;
    }
    *(_QWORD *)(a1 + 0x430) = v8;
    *(_QWORD *)(a1 + 0x438) = v8;
    *(_QWORD *)(a1 + 0x440) = v5 + v8;
    v9 = *(_QWORD *)(a2 + 0x438);
    v10 = *(_QWORD *)(a2 + 0x430);
    for ( i = *(_QWORD *)(a1 + 0x430); v10 != v9; i += 0x28 )
    {
      sub_14035DE10((void **)i, (const void **)v10);
      sub_14035DE10((void **)(i + 8), (const void **)(v10 + 8));
      *(_QWORD *)(i + 0x10) = *(_QWORD *)(v10 + 0x10);
      *(_DWORD *)(i + 0x18) = *(_DWORD *)(v10 + 0x18);
      *(_DWORD *)(i + 0x1C) = *(_DWORD *)(v10 + 0x1C);
      v12 = *(_BYTE *)(v10 + 0x20);
      v10 += 0x28;
      *(_BYTE *)(i + 0x20) = v12;
    }
    *(_QWORD *)(a1 + 0x438) = i;
  }
  *(_QWORD *)(a1 + 0x448) = 0;
  *(_QWORD *)(a1 + 0x450) = 0;
  *(_QWORD *)(a1 + 0x458) = 0;
  v13 = (__int64)(*(_QWORD *)(a2 + 0x450) - *(_QWORD *)(a2 + 0x448)) >> 3;
  if ( v13 )
  {
    if ( v13 > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v14 = 8 * v13;
    if ( 8 * v13 < 0x1000 )
    {
      if ( v14 )
        v17 = sub_1402A65A0(8 * v13);
      else
        v17 = 0;
    }
    else
    {
      if ( v14 + 0x27 < v14 )
        goto LABEL_50;
      v15 = sub_1402A65A0(v14 + 0x27);
      v16 = v15;
      if ( !v15 )
        goto LABEL_42;
      v17 = (v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v17 - 8) = v16;
    }
    *(_QWORD *)(a1 + 0x448) = v17;
    *(_QWORD *)(a1 + 0x450) = v17;
    *(_QWORD *)(a1 + 0x458) = v14 + v17;
    v18 = *(const void **)(a2 + 0x448);
    v19 = *(char **)(a1 + 0x448);
    Size = *(_QWORD *)(a2 + 0x450) - (_QWORD)v18;
    memmove(v19, v18, Size);
    *(_QWORD *)(a1 + 0x450) = &v19[8 * (Size >> 3)];
  }
  *(_QWORD *)(a1 + 0x460) = 0;
  *(_QWORD *)(a1 + 0x468) = 0;
  *(_QWORD *)(a1 + 0x470) = 0;
  v21 = (*(_QWORD *)(a2 + 0x468) - *(_QWORD *)(a2 + 0x460)) / 0x430LL;
  if ( v21 )
  {
    if ( v21 > 0x3D226357E16ECELL )
      unknown_libname_10();
    v22 = 0x430 * v21;
    if ( 0x430 * v21 < 0x1000 )
    {
      if ( v22 )
        v25 = sub_1402A65A0(0x430 * v21);
      else
        v25 = 0;
    }
    else
    {
      if ( v22 + 0x27 < v22 )
        goto LABEL_50;
      v23 = sub_1402A65A0(v22 + 0x27);
      v24 = v23;
      if ( !v23 )
        goto LABEL_42;
      v25 = (v23 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v25 - 8) = v24;
    }
    *(_QWORD *)(a1 + 0x460) = v25;
    *(_QWORD *)(a1 + 0x468) = v25;
    *(_QWORD *)(a1 + 0x470) = v22 + v25;
    v26 = *(_QWORD *)(a2 + 0x468);
    v27 = *(_QWORD *)(a2 + 0x460);
    v28 = *(_QWORD **)(a1 + 0x460);
    if ( v27 != v26 )
    {
      v29 = v28 + 0x46;
      do
      {
        *v28 = 0;
        v29[0xFFFFFDE8] = 0;
        *((_QWORD *)v29 + 0xFFFFFFBC) = v29 + 0xFFFFFDE8;
        *((_QWORD *)v29 + 0xFFFFFFBB) = 0x1FF;
        sub_1402A6440((__int64)v28, *(const void **)(v27 + 0x10), *(_QWORD *)v27);
        *((_QWORD *)v29 + 0xFFFFFFFD) = 0;
        *v29 = 0;
        *((_QWORD *)v29 + 0xFFFFFFFF) = v29;
        *((_QWORD *)v29 + 0xFFFFFFFE) = 0x1FF;
        sub_1402A6440((__int64)(v29 + 0xFFFFFFE8), *(const void **)(v27 + 0x228), *(_QWORD *)(v27 + 0x218));
        v28 += 0x86;
        v29 += 0x430;
        v27 += 0x430;
      }
      while ( v27 != v26 );
    }
    *(_QWORD *)(a1 + 0x468) = v28;
  }
  *(_OWORD *)(a1 + 0x478) = *(_OWORD *)(a2 + 0x478);
  *(_QWORD *)(a1 + 0x488) = *(_QWORD *)(a2 + 0x488);
  *(_QWORD *)(a1 + 0x490) = *(_QWORD *)(a2 + 0x490);
  *(_BYTE *)(a1 + 0x498) = *(_BYTE *)(a2 + 0x498);
  *(_QWORD *)(a1 + 0x4A0) = 0;
  *(_QWORD *)(a1 + 0x4A8) = 0;
  *(_QWORD *)(a1 + 0x4B0) = 0;
  v30 = (*(_QWORD *)(a2 + 0x4A8) - *(_QWORD *)(a2 + 0x4A0)) / 0x218LL;
  if ( !v30 )
    return a1;
  if ( v30 > 0x7A44C6AFC2DD9CLL )
    unknown_libname_10();
  v31 = 0x218 * v30;
  if ( 0x218 * v30 < 0x1000 )
  {
    if ( v31 )
      v34 = sub_1402A65A0(0x218 * v30);
    else
      v34 = 0;
    goto LABEL_46;
  }
  if ( v31 + 0x27 < v31 )
LABEL_50:
    sub_1402E3880();
  v32 = sub_1402A65A0(v31 + 0x27);
  v33 = v32;
  if ( !v32 )
LABEL_42:
    invalid_parameter_noinfo_noreturn();
  v34 = (v32 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v34 - 8) = v33;
LABEL_46:
  *(_QWORD *)(a1 + 0x4A0) = v34;
  *(_QWORD *)(a1 + 0x4A8) = v34;
  *(_QWORD *)(a1 + 0x4B0) = v31 + v34;
  v35 = *(_QWORD *)(a2 + 0x4A8);
  v36 = *(_QWORD *)(a2 + 0x4A0);
  for ( j = *(_QWORD *)(a1 + 0x4A0); v36 != v35; v36 += 0x218 )
  {
    *(_QWORD *)j = 0;
    *(_BYTE *)(j + 0x18) = 0;
    *(_QWORD *)(j + 0x10) = j + 0x18;
    *(_QWORD *)(j + 8) = 0x1FF;
    sub_1402A6440(j, *(const void **)(v36 + 0x10), *(_QWORD *)v36);
    j += 0x218;
  }
  *(_QWORD *)(a1 + 0x4A8) = j;
  return a1;
}

// --- End Function: sub_142659050 (0x142659050) ---

// --- Function: sub_1426595C0 (0x1426595C0) ---
__int64 __fastcall sub_1426595C0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)(a1 + 8) = 0x1FF;
  sub_1402A6440(a1, *(const void **)(a2 + 0x10), *(_QWORD *)a2);
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x228) = a1 + 0x230;
  *(_QWORD *)(a1 + 0x220) = 0x1FF;
  sub_1402A6440(a1 + 0x218, *(const void **)(a2 + 0x228), *(_QWORD *)(a2 + 0x218));
  return a1;
}

// --- End Function: sub_1426595C0 (0x1426595C0) ---

// --- Function: sub_14265C210 (0x14265C210) ---
__int64 __fastcall sub_14265C210(_QWORD *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rcx
  _QWORD *v4; // rcx
  __int64 result; // rax

  sub_140375620(a1 + 0x94);
  sub_1426B72B0(a1 + 0x8C);
  v2 = a1[0x89];
  if ( v2 )
  {
    if ( ((a1[0x8B] - v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = *(_QWORD *)(v2 - 8);
    }
    sub_1402A6590(v2);
    a1[0x89] = 0;
    a1[0x8A] = 0;
    a1[0x8B] = 0;
  }
  sub_140564E90(a1 + 0x86);
  v3 = (_QWORD *)a1[0x45];
  if ( v3 != a1 + 0x46 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - a1[0x44];
    sub_147715880(v3);
  }
  v4 = (_QWORD *)a1[2];
  result = (__int64)(a1 + 3);
  if ( v4 != a1 + 3 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
    return sub_147715880(v4);
  }
  return result;
}

// --- End Function: sub_14265C210 (0x14265C210) ---

// --- Function: sub_1426B72B0 (0x1426B72B0) ---
__int64 __fastcall sub_1426B72B0(__int64 *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rsi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 0x86 )
      sub_140374740(v1);
    v4 = *a1;
    if ( (unsigned __int64)(0x430 * ((a1[2] - *a1) / 0x430)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_1402A6590(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1426B72B0 (0x1426B72B0) ---

// --- Function: sub_1426B8660 (0x1426B8660) ---
_QWORD *__fastcall sub_1426B8660(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v5)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+50h] [rbp+18h] BYREF
  char v9; // [rsp+58h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(qword_149C8DFC0);
  v3 = v2;
  if ( v2 )
  {
    n0xFFFF = n0xFFFF_21;
    v5 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v2 + 0x340LL);
    if ( n0xFFFF_21 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                            qword_149C8DFC8,
                            &v8,
                            "ActionAreaComponent");
      n0xFFFF_21 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v5(v3, &v9, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1426B8660 (0x1426B8660) ---

// --- Function: sub_1426FAA90 (0x1426FAA90) ---
_QWORD *__fastcall sub_1426FAA90(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v5)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+50h] [rbp+18h] BYREF
  char v9; // [rsp+58h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(qword_149C8DFC0);
  v3 = v2;
  if ( v2 )
  {
    n0xFFFF = n0xFFFF_4;
    v5 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v2 + 0x340LL);
    if ( n0xFFFF_4 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                            qword_149C8DFC8,
                            &v8,
                            "Actor");
      n0xFFFF_4 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v5(v3, &v9, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1426FAA90 (0x1426FAA90) ---

// --- Function: ??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ (0x14272C3B0) ---
void _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator()()
{
  ;
}

// --- End Function: ??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ (0x14272C3B0) ---

// --- Function: ??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z (0x14272CDF0) ---
_QWORD *__fastcall std::_Iterator_base12::operator=(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  return a1;
}

// --- End Function: ??4_Iterator_base12@std@@QEAAAEAU01@AEBU01@@Z (0x14272CDF0) ---

// --- Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x14272D330) ---
__int64 __fastcall std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x14272D330) ---

// --- Function: sub_142750740 (0x142750740) ---
ULONG_PTR __fastcall sub_142750740(Parameter *Parameter_1)
{
  _StarEngineModule__(Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_142750740 (0x142750740) ---

// --- Function: sub_1427520B0 (0x1427520B0) ---
_QWORD *__fastcall sub_1427520B0(_QWORD *a1, _QWORD *a2)
{
  *a1 = 0;
  a1[1] = 0;
  if ( a2[1] )
    InterlockedIncrement_w_1(a2[1]);
  *a1 = *a2;
  a1[1] = a2[1];
  return a1;
}

// --- End Function: sub_1427520B0 (0x1427520B0) ---

// --- Function: sub_142752190 (0x142752190) ---
ULONG_PTR __fastcall sub_142752190(Parameter *Parameter)
{
  sub_142750740((Parameter *)Parameter);
  *(_QWORD *)Parameter = 0;
  *(_QWORD *)(Parameter + 8) = 0;
  *(_QWORD *)(Parameter + 0x10) = 0;
  _StarEngineModule__(Parameter);
  return Parameter;
}

// --- End Function: sub_142752190 (0x142752190) ---

// --- Function: sub_142758050 (0x142758050) ---
// attributes: thunk
__int64 sub_142758050()
{
  return sub_142758060();
}

// --- End Function: sub_142758050 (0x142758050) ---

// --- Function: sub_142758060 (0x142758060) ---
_QWORD *__fastcall sub_142758060(_QWORD *a1)
{
  return sub_14276E9D0(a1);
}

// --- End Function: sub_142758060 (0x142758060) ---

// --- Function: sub_142758BD0 (0x142758BD0) ---
__int64 __fastcall sub_142758BD0(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  if ( *(_QWORD *)(a1 + 8) )
    return std::_Ref_count_base::_Decref(*(std::_Ref_count_base **)(a1 + 8));
  return result;
}

// --- End Function: sub_142758BD0 (0x142758BD0) ---

// --- Function: sub_14275A910 (0x14275A910) ---
_QWORD *__fastcall sub_14275A910(_QWORD *a1, __int64 *a2)
{
  __int64 v3; // [rsp+50h] [rbp-28h]
  __int64 v4; // [rsp+58h] [rbp-20h]
  __int64 v5; // [rsp+60h] [rbp-18h]
  std::_Ref_count_base *v6; // [rsp+60h] [rbp-18h]

  v4 = *a2;
  v5 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  *a1 = v4;
  v3 = v5;
  v6 = (std::_Ref_count_base *)a1[1];
  a1[1] = v3;
  if ( v6 )
    std::_Ref_count_base::_Decref(v6);
  return a1;
}

// --- End Function: sub_14275A910 (0x14275A910) ---

// --- Function: sub_14275AC70 (0x14275AC70) ---
_BOOL8 __fastcall sub_14275AC70(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x10) != 0;
}

// --- End Function: sub_14275AC70 (0x14275AC70) ---

// --- Function: Handle::IsValid (0x14275ACB0) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B84E0(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || (unsigned __int8)sub_14276AAE0(a1);
}

// --- End Function: Handle::IsValid (0x14275ACB0) ---

// --- Function: sub_14275AD80 (0x14275AD80) ---
__int64 __fastcall sub_14275AD80(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x10);
}

// --- End Function: sub_14275AD80 (0x14275AD80) ---

// --- Function: sub_14275ADA0 (0x14275ADA0) ---
__int64 __fastcall sub_14275ADA0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14275ADA0 (0x14275ADA0) ---

// --- Function: sub_14276AAE0 (0x14276AAE0) ---
char __fastcall sub_14276AAE0(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  __int64 v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B84E0(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B43C0(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)sub_1402E4BA0() || is_thread_privileged_or_bypass_mode() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B43C0(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = sub_1403B43C0(v7);
      return sub_140395230(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_14276AAE0 (0x14276AAE0) ---

// --- Function: sub_14276E9D0 (0x14276E9D0) ---
_QWORD *__fastcall sub_14276E9D0(_QWORD *a1)
{
  _QWORD *result; // rax
  void (__fastcall *v2)(__int64, _QWORD *, _QWORD); // [rsp+20h] [rbp-18h]

  if ( a1[1] > 1u )
    v2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a1[1];
  else
    v2 = 0;
  if ( v2 )
  {
    v2(2, a1, 0);
    a1[1] = 0;
  }
  result = a1;
  *a1 = 0;
  return result;
}

// --- End Function: sub_14276E9D0 (0x14276E9D0) ---

// --- Function: unknown_libname_485 (0x14278ED00) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
__int64 __fastcall unknown_libname_485(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: unknown_libname_485 (0x14278ED00) ---

// --- Function: ?is_valid@?$__crt_unique_heap_ptr@_WU__crt_internal_free_policy@@@@QEBA_NXZ (0x14279F060) ---
// Microsoft VisualC v14 64bit runtime
_BOOL8 __fastcall __crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid(_QWORD *a1)
{
  return *a1 != 0;
}

// --- End Function: ?is_valid@?$__crt_unique_heap_ptr@_WU__crt_internal_free_policy@@@@QEBA_NXZ (0x14279F060) ---

// --- Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_2 (0x1427D27F0) ---
// Microsoft VisualC v14 64bit runtime
__int64 __fastcall __crt_win32_buffer_debug_info::file_name(__crt_win32_buffer_debug_info *this)
{
  return *((_QWORD *)this + 1);
}

// --- End Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_2 (0x1427D27F0) ---

// --- Function: unknown_libname_65 (0x1427D2800) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_65()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_65 (0x1427D2800) ---

// --- Function: sub_1427D28D0 (0x1427D28D0) ---
_QWORD *__fastcall sub_1427D28D0(_QWORD *a1, Parameter *Parameter_1)
{
  *Parameter_1 = *a1;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_1427D28D0 (0x1427D28D0) ---

// --- Function: sub_1427D2930 (0x1427D2930) ---
_QWORD *__fastcall sub_1427D2930(__int64 a1, Parameter *Parameter_1)
{
  *Parameter_1 = *(_QWORD *)(a1 + 8);
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_1427D2930 (0x1427D2930) ---

// --- Function: sub_1427D2E60 (0x1427D2E60) ---
__int64 __fastcall sub_1427D2E60(__int64 *a1)
{
  if ( is_valid_handle_typeA(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1427D2E60 (0x1427D2E60) ---

// --- Function: sub_1427D2EA0 (0x1427D2EA0) ---
__int64 __fastcall sub_1427D2EA0(_QWORD *a1)
{
  if ( Handle::IsValid(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1427D2EA0 (0x1427D2EA0) ---

// --- Function: sub_14280FC00 (0x14280FC00) ---
__int64 __fastcall sub_14280FC00(__int64 a1, __int64 *a2)
{
  __int64 result; // rax
  _QWORD *v3; // [rsp+20h] [rbp-18h]

  v3 = (_QWORD *)sub_1402A53E0(8, a1);
  result = *a2;
  *v3 = *a2;
  return result;
}

// --- End Function: sub_14280FC00 (0x14280FC00) ---

// --- Function: sub_14280FD70 (0x14280FD70) ---
__int64 __fastcall sub_14280FD70(__int64 a1)
{
  return sub_1402A53E0(1, a1);
}

// --- End Function: sub_14280FD70 (0x14280FD70) ---

// --- Function: unknown_libname_490 (0x14280FE10) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
_QWORD *__fastcall unknown_libname_490(_QWORD *a1, __int64 a2)
{
  *a1 = a2;
  return a1;
}

// --- End Function: unknown_libname_490 (0x14280FE10) ---

// --- Function: unknown_libname_491 (0x142817280) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
__int64 __fastcall unknown_libname_491(__int64 a1)
{
  return a1;
}

// --- End Function: unknown_libname_491 (0x142817280) ---

// --- Function: sub_14288B1F0 (0x14288B1F0) ---
_BOOL8 __fastcall sub_14288B1F0(_QWORD *a1)
{
  return *a1 != 0;
}

// --- End Function: sub_14288B1F0 (0x14288B1F0) ---

// --- Function: sub_14291FD30 (0x14291FD30) ---
__int64 __fastcall sub_14291FD30(Parameter *Parameter, char *src_1, unsigned __int64 a3)
{
  __int64 result; // rax
  char v4; // [rsp+20h] [rbp-88h]
  __int64 *v6; // [rsp+30h] [rbp-78h]
  char *dst_1; // [rsp+40h] [rbp-68h]
  unsigned __int64 v8; // [rsp+48h] [rbp-60h]
  unsigned __int64 v9; // [rsp+50h] [rbp-58h]
  char *dst; // [rsp+58h] [rbp-50h]
  char *src; // [rsp+60h] [rbp-48h]
  _QWORD *v13; // [rsp+70h] [rbp-38h]
  __int64 v14; // [rsp+80h] [rbp-28h]

  v6 = (__int64 *)((char *)Parameter + 8);
  v13 = (_QWORD *)((char *)Parameter + 0x10);
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( a3 <= (*v13 - *(_QWORD *)Parameter) / 0x18LL )
  {
    v8 = (*v6 - *(_QWORD *)Parameter) / 0x18;
    if ( a3 <= v8 )
    {
      v14 = *(_QWORD *)Parameter + 0x18 * a3;
      dst = *(char **)Parameter;
      v9 = a3;
      src = src_1;
      if ( AK::WriteBytesCount::Reserve(Parameter) )
      {
        while ( v9 )
        {
          qmemcpy(dst, src, 0x18u);
          dst += 0x18;
          src += 0x18;
          --v9;
        }
      }
      else
      {
        sub_142920860(src_1, a3, dst);
      }
      result = (__int64)v6;
      *v6 = v14;
    }
    else
    {
      v4 = 0;
      if ( !AK::WriteBytesCount::Reserve((AK::WriteBytesCount *)0x18) )
      {
        sub_142920860(src_1, v8, *(_QWORD *)Parameter);
        src_1 += 0x18 * v8;
        v4 = 1;
      }
      if ( !v4 )
      {
        for ( dst_1 = *(char **)Parameter; dst_1 != (char *)*v6; dst_1 += 0x18 )
        {
          qmemcpy(dst_1, src_1, 0x18u);
          src_1 += 0x18;
        }
      }
      result = sub_1429234C0(src_1, a3 - v8, *v6, Parameter);
      *v6 = result;
    }
  }
  else
  {
    sub_142997FD0(Parameter, a3);
    result = sub_1429234C0(src_1, a3, *(_QWORD *)Parameter, Parameter);
    *v6 = result;
  }
  return result;
}

// --- End Function: sub_14291FD30 (0x14291FD30) ---

// --- Function: sub_142921710 (0x142921710) ---
char *__fastcall sub_142921710(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  char *v6; // [rsp+20h] [rbp-B8h]
  __int64 v7; // [rsp+38h] [rbp-A0h]
  _QWORD *v9; // [rsp+48h] [rbp-90h]
  unsigned __int64 v11; // [rsp+60h] [rbp-78h]
  __int64 v12; // [rsp+70h] [rbp-68h]
  __int64 v13; // [rsp+90h] [rbp-48h] BYREF
  __int64 v14; // [rsp+98h] [rbp-40h] BYREF
  __int64 v15; // [rsp+A0h] [rbp-38h]
  __int64 v16; // [rsp+A8h] [rbp-30h]
  char *v17; // [rsp+B0h] [rbp-28h]
  __int64 v18; // [rsp+B8h] [rbp-20h]
  __int64 v19; // [rsp+C8h] [rbp-10h]

  v9 = a1 + 1;
  v7 = (a2 - *a1) / 0x170;
  v12 = (a1[1] - *a1) / 0x170LL;
  v13 = 0xB21642C8590B21LL;
  v14 = __crt_strtox::maximum_signed_value((__crt_strtox *)0x170);
  v15 = *unknown_libname_2(&v14, &v13);
  if ( v12 == v15 )
    unknown_libname_65(v4, v3);
  v11 = sub_1429971C0(a1, v12 + 1);
  v19 = 0xB21642C8590B21LL;
  if ( v11 > 0xB21642C8590B21LL )
    sub_1402E3880();
  v16 = 0x170 * v11;
  v17 = (char *)std::_Allocate<16,std::_Default_allocate_traits,0>(0x170 * v11);
  v6 = v17;
  v18 = sub_1402A53E0(0x170, (__int64)&v17[0x170 * v7]);
  sub_14292E130(v18, a3);
  if ( a2 == *v9 )
  {
    sub_142922BB0(*a1, *v9, v6, a1);
  }
  else
  {
    sub_142923760(*a1, a2, v6, a1);
    sub_142923760(a2, *v9, &v6[0x170 * v7 + 0x170], a1);
  }
  sub_1429975A0(a1, v6, v12 + 1, v11);
  return &v6[0x170 * v7];
}

// --- End Function: sub_142921710 (0x142921710) ---

// --- Function: sub_142922970 (0x142922970) ---
__int64 __fastcall sub_142922970(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v7; // [rsp+38h] [rbp-30h]
  __int64 v8; // [rsp+40h] [rbp-28h] BYREF
  __int64 v9; // [rsp+48h] [rbp-20h]
  __int64 v10; // [rsp+50h] [rbp-18h]

  v8 = a3;
  v9 = a3;
  v10 = a4;
  while ( a1 != a2 )
  {
    sub_142920910(&v8, a1);
    a1 += 0x10;
  }
  v8 = v9;
  v7 = v9;
  sub_142934B40(&v8);
  return v7;
}

// --- End Function: sub_142922970 (0x142922970) ---

// --- Function: sub_142925110 (0x142925110) ---
__int64 __fastcall sub_142925110(__int64 a1, _OWORD *a2)
{
  sub_14035EC10((_OWORD *)a1, a2);
  *(_QWORD *)(a1 + 0x10) = sub_14279EE40(a1);
  return a1;
}

// --- End Function: sub_142925110 (0x142925110) ---

// --- Function: sub_14292E130 (0x14292E130) ---
__int64 __fastcall sub_14292E130(__int64 a1, __int64 a2)
{
  sub_14035DE10((void **)a1, (const void **)a2);
  qmemcpy((void *)(a1 + 8), (const void *)(a2 + 8), 0x10u);
  sub_14035DE10((void **)(a1 + 0x18), (const void **)(a2 + 0x18));
  sub_14035DE10((void **)(a1 + 0x20), (const void **)(a2 + 0x20));
  qmemcpy((void *)(a1 + 0x28), (const void *)(a2 + 0x28), 0x10u);
  qmemcpy((void *)(a1 + 0x38), (const void *)(a2 + 0x38), 0x10u);
  qmemcpy((void *)(a1 + 0x48), (const void *)(a2 + 0x48), 0x10u);
  qmemcpy((void *)(a1 + 0x58), (const void *)(a2 + 0x58), 0x10u);
  qmemcpy((void *)(a1 + 0x68), (const void *)(a2 + 0x68), 0xCu);
  *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(a2 + 0x78);
  sub_1403629F0(a1 + 0x80, a2 + 0x80);
  *(_DWORD *)(a1 + 0x84) = *(_DWORD *)(a2 + 0x84);
  *(_DWORD *)(a1 + 0x88) = *(_DWORD *)(a2 + 0x88);
  *(_DWORD *)(a1 + 0x8C) = *(_DWORD *)(a2 + 0x8C);
  *(_DWORD *)(a1 + 0x90) = *(_DWORD *)(a2 + 0x90);
  *(_BYTE *)(a1 + 0x94) = *(_BYTE *)(a2 + 0x94);
  *(_BYTE *)(a1 + 0x95) = *(_BYTE *)(a2 + 0x95);
  *(_BYTE *)(a1 + 0x96) = *(_BYTE *)(a2 + 0x96);
  sub_1402B0E40(a1 + 0x98, a2 + 0x98);
  *(_DWORD *)(a1 + 0xD8) = *(_DWORD *)(a2 + 0xD8);
  *(_DWORD *)(a1 + 0xDC) = *(_DWORD *)(a2 + 0xDC);
  *(_BYTE *)(a1 + 0xE0) = *(_BYTE *)(a2 + 0xE0);
  *(_BYTE *)(a1 + 0xE1) = *(_BYTE *)(a2 + 0xE1);
  *(_BYTE *)(a1 + 0xE2) = *(_BYTE *)(a2 + 0xE2);
  *(_BYTE *)(a1 + 0xE3) = *(_BYTE *)(a2 + 0xE3);
  *(_BYTE *)(a1 + 0xE4) = *(_BYTE *)(a2 + 0xE4);
  qmemcpy((void *)(a1 + 0xE8), (const void *)(a2 + 0xE8), 0x28u);
  qmemcpy((void *)(a1 + 0x110), (const void *)(a2 + 0x110), 0x10u);
  qmemcpy((void *)(a1 + 0x120), (const void *)(a2 + 0x120), 0x10u);
  qmemcpy((void *)(a1 + 0x130), (const void *)(a2 + 0x130), 0x10u);
  sub_1403629F0(a1 + 0x140, a2 + 0x140);
  sub_1403629F0(a1 + 0x144, a2 + 0x144);
  *(_DWORD *)(a1 + 0x148) = *(_DWORD *)(a2 + 0x148);
  sub_1402B3D20((_QWORD *)(a1 + 0x150));
  if ( *(_QWORD *)(a2 + 0x158) )
    InterlockedIncrement_w_1(*(_QWORD *)(a2 + 0x158));
  *(_QWORD *)(a1 + 0x150) = *(_QWORD *)(a2 + 0x150);
  *(_QWORD *)(a1 + 0x158) = *(_QWORD *)(a2 + 0x158);
  qmemcpy((void *)(a1 + 0x160), (const void *)(a2 + 0x160), 0x10u);
  return a1;
}

// --- End Function: sub_14292E130 (0x14292E130) ---

// --- Function: sub_142934E60 (0x142934E60) ---
__int64 __fastcall sub_142934E60(__int64 a1)
{
  return sub_142998B70(a1);
}

// --- End Function: sub_142934E60 (0x142934E60) ---

// --- Function: sub_142934E80 (0x142934E80) ---
__int64 __fastcall sub_142934E80(__int64 a1)
{
  return sub_142998CA0(a1);
}

// --- End Function: sub_142934E80 (0x142934E80) ---

// --- Function: sub_142934EA0 (0x142934EA0) ---
__int64 __fastcall sub_142934EA0(__int64 a1)
{
  return sub_142998DD0(a1);
}

// --- End Function: sub_142934EA0 (0x142934EA0) ---

// --- Function: sub_142934EC0 (0x142934EC0) ---
__int64 __fastcall sub_142934EC0(__int64 a1)
{
  return sub_142998F00(a1);
}

// --- End Function: sub_142934EC0 (0x142934EC0) ---

// --- Function: sub_142934F00 (0x142934F00) ---
__int64 __fastcall sub_142934F00(__int64 a1)
{
  return sub_142999100(a1);
}

// --- End Function: sub_142934F00 (0x142934F00) ---

// --- Function: sub_142997430 (0x142997430) ---
__int64 __fastcall sub_142997430(Parameter *Parameter, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 i; // [rsp+20h] [rbp-58h]
  __int64 *v7; // [rsp+38h] [rbp-40h]
  _QWORD *v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]

  v7 = Parameter + 1;
  v8 = Parameter + 2;
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( *Parameter )
  {
    v9 = *v7;
    for ( i = *Parameter; i != v9; i += 0x10 )
      sub_140375A30((_DWORD *)(i + 8));
    std::_Deallocate<16,0>(*Parameter, 0x10 * ((*v8 - *Parameter) >> 4));
  }
  *Parameter = a2;
  *v7 = 0x10 * a3 + a2;
  result = 0x10 * a4 + a2;
  *v8 = result;
  return result;
}

// --- End Function: sub_142997430 (0x142997430) ---

// --- Function: sub_142999100 (0x142999100) ---
Parameter *__fastcall sub_142999100(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  Parameter *Parameter_2; // [rsp+30h] [rbp-38h]
  _QWORD *v4; // [rsp+48h] [rbp-20h]

  v4 = Parameter + 1;
  Parameter_2 = Parameter + 2;
  _StarEngineModule__((ULONG_PTR)Parameter);
  Parameter_1 = Parameter;
  if ( *Parameter )
  {
    std::_Deallocate<16,0>(*Parameter, 0x18 * ((*Parameter_2 - *Parameter) / 0x18));
    *Parameter = 0;
    *v4 = 0;
    Parameter_1 = Parameter_2;
    *Parameter_2 = 0;
  }
  return Parameter_1;
}

// --- End Function: sub_142999100 (0x142999100) ---

// --- Function: unknown_libname_73 (0x142999370) ---
// Microsoft VisualC v14 64bit runtime
__int64 __fastcall unknown_libname_73(__int64 a1, __int64 a2, __int64 a3)
{
  return std::_Deallocate<16,0>(a2, 0x10 * a3);
}

// --- End Function: unknown_libname_73 (0x142999370) ---

// --- Function: sub_142999720 (0x142999720) ---
__int64 __fastcall sub_142999720(_QWORD *a1)
{
  return (__int64)(a1[1] - *a1) >> 3;
}

// --- End Function: sub_142999720 (0x142999720) ---

// --- Function: sub_1429DB7B0 (0x1429DB7B0) ---
_QWORD *__fastcall sub_1429DB7B0(__int64 a1, _QWORD *a2)
{
  _BYTE v3[8]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v4; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int64); // [rsp+30h] [rbp-28h]
  __int64 *v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  _BYTE v8[16]; // [rsp+48h] [rbp-10h] BYREF

  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)a1 + 0x340LL);
  v4 = sub_1429F5930(v3);
  v6 = (__int64 *)v5(a1, v8, v4);
  v7 = *v6;
  *a2 = v7;
  return a2;
}

// --- End Function: sub_1429DB7B0 (0x1429DB7B0) ---

// --- Function: sub_142AD3050 (0x142AD3050) ---
const void *__fastcall sub_142AD3050(__int64 a1, __int64 a2, __int64 a3)
{
  const void **v3; // rbx
  const void *result; // rax

  v3 = *(const void ***)(a1 + 0x10);
  copyStringStructure((void **)*v3 + 8, v3 + 2, a3);
  result = *v3;
  *((_BYTE *)*v3 + 0x10) = 2;
  return result;
}

// --- End Function: sub_142AD3050 (0x142AD3050) ---

// --- Function: sub_142AD4C40 (0x142AD4C40) ---
void **__fastcall sub_142AD4C40(__int64 a1, void **a2, const char **a3, const char **a4)
{
  const char **v4; // rbx
  void **v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // r13
  __int64 v9; // r13
  __int64 v10; // r15
  unsigned __int64 MaxCount_3; // rax
  const char *String2; // r14
  int v13; // edi
  unsigned __int64 v14; // rbx
  int v15; // ebx
  size_t MaxCount; // r12
  const char **v17; // rsi
  void **result; // rax
  __int64 v19; // rax
  _QWORD *v20; // rdi
  bool i; // zf
  __int64 v22; // rax
  __int64 v23; // rbx
  __int64 (__fastcall ***v24)(_QWORD, __int128 *); // rax
  __int64 (__fastcall ***v25)(_QWORD); // rax
  __int64 (__fastcall ***v26)(_QWORD); // rcx
  __int64 (__fastcall **v27)(_QWORD); // rax
  __int64 v28; // rax
  __int64 v29; // rbx
  __int64 v30; // rax
  __int64 v31; // rax
  __int128 *v32; // r13
  unsigned __int64 MaxCount_4; // rax
  const char *String2_1; // r14
  __int64 v35; // r15
  int v36; // edi
  unsigned __int64 v37; // rbx
  int v38; // ebx
  size_t MaxCount_1; // r12
  __int128 *v40; // r13
  const char *String2_2; // r14
  __int64 v42; // r15
  unsigned __int64 MaxCount_5; // rax
  int v44; // edi
  unsigned __int64 v45; // rbx
  int v46; // ebx
  size_t MaxCount_2; // r12
  double v48; // xmm1_8
  const char *v49; // rax
  int v50; // ebx
  void **v51; // rsi
  _QWORD *v52; // rbx
  _QWORD *v53; // rdi
  double v54; // xmm1_8
  const char *v55; // rax
  int v56; // ebx
  _QWORD *v57; // rdi
  _QWORD *v58; // rdi
  __int64 v59; // [rsp+20h] [rbp-99h]
  void *v60[2]; // [rsp+28h] [rbp-91h] BYREF
  __int64 v61; // [rsp+38h] [rbp-81h]
  const char **v62; // [rsp+40h] [rbp-79h]
  void **v63; // [rsp+48h] [rbp-71h]
  const char **v64; // [rsp+50h] [rbp-69h]
  _QWORD *v65; // [rsp+58h] [rbp-61h]
  __int128 *v66; // [rsp+60h] [rbp-59h]
  __int64 v67; // [rsp+68h] [rbp-51h] BYREF
  const char *v68[2]; // [rsp+70h] [rbp-49h] BYREF
  __int128 v69; // [rsp+80h] [rbp-39h] BYREF
  double v70; // [rsp+90h] [rbp-29h]
  _QWORD *v71; // [rsp+A0h] [rbp-19h]
  __int128 v72; // [rsp+B0h] [rbp-9h] BYREF
  __int128 v73; // [rsp+C0h] [rbp+7h] BYREF
  __int64 v74; // [rsp+D0h] [rbp+17h]

  v4 = a3;
  v62 = a4;
  v64 = a3;
  v5 = a2;
  v63 = a2;
  v6 = sub_143165DE0();
  if ( !v6 )
    goto LABEL_72;
  v7 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x88LL))(v6);
  v59 = v7;
  v8 = *(unsigned int *)(v7 - 4);
  LODWORD(v8) = v8 & 0x7FFFFFFF;
  v9 = v7 + 0x20 * v8;
  if ( v7 == v9 )
    goto LABEL_72;
  while ( 1 )
  {
    v10 = *(_QWORD *)(v7 + 8);
    MaxCount_3 = 0xFFFFFFFFFFFFFFFFuLL;
    String2 = *v4;
    do
      ++MaxCount_3;
    while ( String2[MaxCount_3] );
    v13 = 0;
    v14 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v14;
    while ( *(_BYTE *)(v10 + v14) );
    v15 = v14 - MaxCount_3;
    if ( v15 >= 0 )
    {
      MaxCount = (int)MaxCount_3;
      while ( _strnicmp((const char *)(v10 + v13), String2, MaxCount) )
      {
        if ( ++v13 > v15 )
          goto LABEL_13;
      }
      if ( v10 + v13 )
        break;
    }
LABEL_13:
    v7 = v59 + 0x20;
    v59 = v7;
    if ( v7 == v9 )
    {
      v5 = v63;
LABEL_72:
      CreateStringObjectFromString(v5, (const char *)&p_Src);
      result = v5;
      *((_DWORD *)v5 + 2) = 0;
      return result;
    }
    v4 = v64;
  }
  v17 = v62;
  if ( sub_1403C3450(v62) )
  {
    sub_14035DE10(v63, (const void **)(v59 + 0x10));
    result = v63;
    *((_DWORD *)v63 + 2) = 0;
    return result;
  }
  *(_OWORD *)v60 = 0;
  v61 = 0;
  v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0);
  (*(void (__fastcall **)(__int64, const char *, void **))(*(_QWORD *)v19 + 0x110LL))(v19, "Level", v60);
  v20 = v60[0];
  v71 = v60[1];
  for ( i = v60[0] == v60[1]; ; i = v20 == v71 )
  {
    v65 = v20;
    if ( i )
    {
      v51 = v63;
      sub_14035DE10(v63, (const void **)(v59 + 0x10));
      v52 = v60[0];
      *((_DWORD *)v51 + 2) = 0;
      if ( !v52 )
        return v51;
      v58 = v60[1];
      if ( v52 == v60[1] )
        goto LABEL_69;
      do
        sub_140373CC0(v52++);
      while ( v52 != v58 );
      goto LABEL_68;
    }
    v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0);
    v67 = *v20;
    v23 = v22;
    sub_14035DDD0(v68, &v67);
    lookup_entry_in_hashtable((_QWORD *)(v23 + 0x40), &v69, v68);
    v68[0] = (char *)&qword_149C78E84 + 4;
    sub_140373CC0(v68);
    if ( (_QWORD)v69 != *(_QWORD *)(v23 + 0x40) + *(_QWORD *)(v23 + 0x58) )
    {
      v29 = *((_QWORD *)&v69 + 1);
      sub_14035EC10(&v73, (_OWORD *)(*((_QWORD *)&v69 + 1) + 0x10LL));
      v26 = *(__int64 (__fastcall ****)(_QWORD))(v29 + 8);
      v27 = *v26;
      goto LABEL_26;
    }
    v72 = 0u;
    sub_14035EC10(&v73, &v72);
    if ( qword_149C8DFE0 )
    {
      if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0) )
      {
        v24 = (__int64 (__fastcall ***)(_QWORD, __int128 *))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0
                                                                                               + 0x240LL))(qword_149C8DFE0);
        v25 = (__int64 (__fastcall ***)(_QWORD))(**v24)(v24, &v73);
        v26 = v25;
        if ( v25 )
        {
          v27 = *v25;
LABEL_26:
          v28 = (*v27)(v26);
          goto LABEL_27;
        }
      }
    }
    v28 = 0;
LABEL_27:
    v74 = v28;
    if ( *(_QWORD *)(v28 + 0x118) == *(_QWORD *)v59 )
    {
      v30 = sub_140976B00(qword_149FBE618);
      v64 = (const char **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x1D0LL))(v30);
      v31 = v74;
      v32 = *(__int128 **)(v74 + 0x140);
      v66 = (__int128 *)((char *)v32 + 0x18 * *(_QWORD *)(v74 + 0x148));
      if ( v32 != v66 )
      {
        while ( 1 )
        {
          MaxCount_4 = 0xFFFFFFFFFFFFFFFFuLL;
          String2_1 = *v17;
          v35 = *(_QWORD *)(*((_QWORD *)v32 + 2) + 0xD8LL);
          do
            ++MaxCount_4;
          while ( String2_1[MaxCount_4] );
          v36 = 0;
          v37 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++v37;
          while ( *(_BYTE *)(v35 + v37) );
          v38 = v37 - MaxCount_4;
          if ( v38 >= 0 )
            break;
LABEL_40:
          v32 = (__int128 *)((char *)v32 + 0x18);
          if ( v32 == v66 )
          {
            v31 = v74;
            v20 = v65;
            goto LABEL_42;
          }
        }
        MaxCount_1 = (int)MaxCount_4;
        while ( _strnicmp((const char *)(v35 + v36), String2_1, MaxCount_1) )
        {
          if ( ++v36 > v38 )
            goto LABEL_39;
        }
        if ( !(v35 + v36) )
        {
LABEL_39:
          v17 = v62;
          goto LABEL_40;
        }
        v48 = *((double *)v32 + 2);
        v69 = *v32;
        v49 = *v64;
        v70 = v48;
        v50 = (*((__int64 (__fastcall **)(const char **, __int128 *))v49 + 7))(v64, &v69);
        v51 = v63;
        sub_14035DE10(v63, (const void **)(v59 + 0x10));
        *((_DWORD *)v51 + 2) = v50;
        v52 = v60[0];
        if ( !v60[0] )
          return v51;
        v53 = v60[1];
        if ( v60[0] == v60[1] )
          goto LABEL_69;
        do
          sub_140373CC0(v52++);
        while ( v52 != v53 );
LABEL_68:
        v52 = v60[0];
        goto LABEL_69;
      }
LABEL_42:
      v40 = *(__int128 **)(v31 + 0x170);
      v66 = (__int128 *)((char *)v40 + 0x18 * *(_QWORD *)(v31 + 0x178));
      if ( v40 != v66 )
        break;
    }
LABEL_56:
    ++v20;
  }
  while ( 1 )
  {
    String2_2 = *v17;
    v42 = *(_QWORD *)(*((_QWORD *)v40 + 2) + 0xD8LL);
    MaxCount_5 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++MaxCount_5;
    while ( String2_2[MaxCount_5] );
    v44 = 0;
    v45 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v45;
    while ( *(_BYTE *)(v42 + v45) );
    v46 = v45 - MaxCount_5;
    if ( v46 >= 0 )
      break;
LABEL_54:
    v40 = (__int128 *)((char *)v40 + 0x18);
    if ( v40 == v66 )
    {
      v20 = v65;
      goto LABEL_56;
    }
  }
  MaxCount_2 = (int)MaxCount_5;
  while ( _strnicmp((const char *)(v42 + v44), String2_2, MaxCount_2) )
  {
    if ( ++v44 > v46 )
      goto LABEL_53;
  }
  if ( !(v42 + v44) )
  {
LABEL_53:
    v17 = v62;
    goto LABEL_54;
  }
  v54 = *((double *)v40 + 2);
  v69 = *v40;
  v55 = *v64;
  v70 = v54;
  v56 = (*((__int64 (__fastcall **)(const char **, __int128 *))v55 + 7))(v64, &v69);
  v51 = v63;
  sub_14035DE10(v63, (const void **)(v59 + 0x10));
  *((_DWORD *)v51 + 2) = v56;
  v52 = v60[0];
  if ( v60[0] )
  {
    v57 = v60[1];
    if ( v60[0] != v60[1] )
    {
      do
        sub_140373CC0(v52++);
      while ( v52 != v57 );
      goto LABEL_68;
    }
LABEL_69:
    sub_1403A6820((__int64)v60, (unsigned __int64)v52, (v61 - (_QWORD)v52) & 0xFFFFFFFFFFFFFFF8uLL);
  }
  return v51;
}

// --- End Function: sub_142AD4C40 (0x142AD4C40) ---

// --- Function: sub_142AD6970 (0x142AD6970) ---
void __fastcall sub_142AD6970(__int64 a1, int a2, const void **a3)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // r15
  __int64 n0x10; // rax
  _QWORD *v8; // rdi
  __int64 v9; // r12
  __int64 v10; // r14
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // r13
  unsigned __int64 v13; // rdx
  unsigned __int64 allocSize; // r12
  __int64 _First_1; // rax
  __int64 *v16; // r14
  std::shared_ptr<gte::ETManifoldMesh::Triangle> *_First; // rcx
  _QWORD *_Al__6; // r8
  _QWORD *_Al__5; // rdx
  _QWORD *v20; // rdx
  unsigned __int64 _Al__1; // r14
  __int64 _Al__2; // r13
  volatile signed __int32 *v23; // rdi
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // r9
  __int64 v27; // rax
  __int64 *v28; // r14
  __int64 v29; // rax
  __int64 v30; // rdi
  __int64 *v31; // rax
  volatile signed __int32 *v32; // rdi
  volatile signed __int32 *v33; // rdi
  volatile signed __int32 *v34; // rdi
  volatile signed __int32 *v35; // rdi
  unsigned __int64 _Al__3; // r14
  __int64 _Al__4; // r12
  volatile signed __int32 *v38; // rdi
  __int128 _Al_; // [rsp+20h] [rbp-A9h] BYREF
  unsigned __int64 v40; // [rsp+30h] [rbp-99h]
  const void *(__fastcall *p_sub_142AD3050)(__int64, __int64, __int64); // [rsp+38h] [rbp-91h] BYREF
  void (__fastcall *p_sub_141279340)(__int64, const void *(__fastcall **)(__int64, __int64, __int64)); // [rsp+40h] [rbp-89h]
  __int64 v43; // [rsp+48h] [rbp-81h]
  __int64 v44; // [rsp+50h] [rbp-79h]
  int v45; // [rsp+58h] [rbp-71h]
  void *v46; // [rsp+60h] [rbp-69h] BYREF
  __int64 v47; // [rsp+68h] [rbp-61h]
  int v48; // [rsp+70h] [rbp-59h]
  void *v49; // [rsp+78h] [rbp-51h] BYREF
  __int64 v50; // [rsp+80h] [rbp-49h]
  int v51; // [rsp+88h] [rbp-41h]
  void *v52; // [rsp+90h] [rbp-39h] BYREF
  __int64 v53; // [rsp+98h] [rbp-31h]
  __int64 _First_2; // [rsp+A0h] [rbp-29h]
  __int64 v55; // [rsp+A8h] [rbp-21h] BYREF
  __int64 v56; // [rsp+B0h] [rbp-19h] BYREF
  volatile signed __int32 *v57; // [rsp+B8h] [rbp-11h]
  char v58[8]; // [rsp+C0h] [rbp-9h] BYREF
  volatile signed __int32 *v59; // [rsp+C8h] [rbp-1h]
  volatile signed __int32 *v60; // [rsp+D8h] [rbp+Fh]
  __int64 n0x10_1; // [rsp+148h] [rbp+7Fh]

  *(_BYTE *)(a1 + 0x10) = 6;
  v4 = *sub_1465E6470(qword_149FBE618, &v55);
  v5 = sub_1402A65A0(0x48u);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 8) = 1;
    *(_DWORD *)(v5 + 0xC) = 1;
    *(_QWORD *)v5 = off_1483A7828;
    *(_QWORD *)(v5 + 0x18) = v4;
    *(_DWORD *)(v5 + 0x20) = 4;
    *(_QWORD *)(v5 + 0x28) = 0;
    *(_QWORD *)(v5 + 0x30) = 0;
    *(_QWORD *)(v5 + 0x38) = 0;
    *(_QWORD *)(v5 + 0x10) = off_1483A3998;
    n0x10 = v5 + 0x10;
    *(_DWORD *)(v6 + 0x40) = a2;
    _Al_ = 0;
    v40 = 0;
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 8));
  }
  else
  {
    MEMORY[0x40] = a2;
    v6 = 0;
    v40 = 0;
    n0x10 = 0x10;
    _Al_ = 0;
  }
  v8 = (_QWORD *)*((_QWORD *)&_Al_ + 1);
  n0x10_1 = n0x10;
  if ( *((_QWORD *)&_Al_ + 1) )
  {
    **((_QWORD **)&_Al_ + 1) = n0x10;
    v8[1] = v6;
    *((_QWORD *)&_Al_ + 1) += 0x10LL;
  }
  else
  {
    v9 = 0xFFFFFFFFFFFFFFFLL;
    v10 = -(__int64)_Al_ >> 4;
    if ( v10 == 0xFFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v11 = -(__int64)_Al_ >> 4;
    v12 = v10 + 1;
    v53 = v10 + 1;
    v13 = v11 >> 1;
    if ( v11 <= 0xFFFFFFFFFFFFFFFLL - (v11 >> 1) )
    {
      v9 = v13 + v11;
      if ( v13 + v11 < v12 )
        v9 = v10 + 1;
    }
    allocSize = 0x10 * v9;
    _First_1 = sub_140394E70((__int64)&_Al_, allocSize);
    v16 = (__int64 *)(_First_1 + 0x10 * v10);
    _First_2 = _First_1;
    *v16 = n0x10_1;
    _First = (std::shared_ptr<gte::ETManifoldMesh::Triangle> *)_First_1;
    v16[1] = v6;
    _Al__6 = (_QWORD *)*((_QWORD *)&_Al_ + 1);
    _Al__5 = (_QWORD *)_Al_;
    if ( *((_QWORD *)&_Al_ + 1) )
    {
      if ( (_QWORD)_Al_ )
      {
        do
        {
          *(_QWORD *)_First = 0;
          *((_QWORD *)_First + 1) = 0;
          *(_QWORD *)_First = *_Al__5;
          *((_QWORD *)_First + 1) = _Al__5[1];
          _First = (std::shared_ptr<gte::ETManifoldMesh::Triangle> *)((char *)_First + 0x10);
          *_Al__5 = 0;
          _Al__5[1] = 0;
          _Al__5 += 2;
        }
        while ( _Al__5 );
      }
      std::_Destroy_range<std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle>>>(
        _First,
        _First,
        (std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle> > *)&_Al_);
      v20 = (_QWORD *)*((_QWORD *)&_Al_ + 1);
      _First = (std::shared_ptr<gte::ETManifoldMesh::Triangle> *)(v16 + 2);
      if ( *((_QWORD *)&_Al_ + 1) )
      {
        do
        {
          *(_QWORD *)_First = 0;
          *((_QWORD *)_First + 1) = 0;
          *(_QWORD *)_First = *v8;
          *((_QWORD *)_First + 1) = v8[1];
          _First = (std::shared_ptr<gte::ETManifoldMesh::Triangle> *)((char *)_First + 0x10);
          *v8 = 0;
          v8[1] = 0;
          v8 += 2;
        }
        while ( v8 != v20 );
      }
    }
    else if ( (_QWORD)_Al_ )
    {
      do
      {
        *(_QWORD *)_First = 0;
        *((_QWORD *)_First + 1) = 0;
        *(_QWORD *)_First = *_Al__5;
        *((_QWORD *)_First + 1) = _Al__5[1];
        _First = (std::shared_ptr<gte::ETManifoldMesh::Triangle> *)((char *)_First + 0x10);
        *_Al__5 = 0;
        _Al__5[1] = 0;
        _Al__5 += 2;
      }
      while ( _Al__5 != _Al__6 );
    }
    std::_Destroy_range<std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle>>>(
      _First,
      _First,
      (std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle> > *)&_Al_);
    _Al__1 = _Al_;
    if ( (_QWORD)_Al_ )
    {
      _Al__2 = *((_QWORD *)&_Al_ + 1);
      if ( (_QWORD)_Al_ != *((_QWORD *)&_Al_ + 1) )
      {
        do
        {
          v23 = *(volatile signed __int32 **)(_Al__1 + 8);
          if ( v23 )
          {
            if ( _InterlockedExchangeAdd(v23 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v23)(v23);
              if ( _InterlockedExchangeAdd(v23 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v23 + 8LL))(v23);
            }
          }
          _Al__1 += 0x10LL;
        }
        while ( _Al__1 != _Al__2 );
        _Al__1 = _Al_;
      }
      sub_1403A6820((__int64)&_Al_, _Al__1, (v40 - _Al__1) & 0xFFFFFFFFFFFFFFF0uLL);
      v12 = v53;
    }
    *(_QWORD *)&_Al_ = _First_2;
    *((_QWORD *)&_Al_ + 1) = _First_2 + 0x10 * v12;
    v40 = allocSize + _First_2;
  }
  v50 = a1;
  v51 = a2;
  sub_14035DE10(&v52, a3);
  v24 = (**(__int64 (__fastcall ***)(__int64))qword_149C8E0A8)(qword_149C8E0A8);
  v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v24 + 0x70LL))(v24);
  LOBYTE(v26) = 0x36;
  v27 = (*(__int64 (__fastcall **)(__int64, char *, __int128 *, __int64))(*(_QWORD *)v25 + 0x30LL))(
          v25,
          v58,
          &_Al_,
          v26);
  v47 = v50;
  v28 = (__int64 *)v27;
  v48 = v51;
  sub_14035DE10(&v49, (const void **)&v52);
  v44 = v47;
  v45 = v48;
  sub_14035DE10(&v46, (const void **)&v49);
  v29 = sub_1402A65A0(0x18u);
  v30 = v29;
  if ( v29 )
  {
    *(_QWORD *)v29 = v44;
    *(_DWORD *)(v29 + 8) = v45;
    sub_14035DE10((void **)(v29 + 0x10), (const void **)&v46);
    v43 = v30;
  }
  else
  {
    v43 = 0;
  }
  p_sub_142AD3050 = sub_142AD3050;
  p_sub_141279340 = (void (__fastcall *)(__int64, const void *(__fastcall **)(__int64, __int64, __int64)))sub_141279340;
  sub_140373CC0(&v46);
  sub_140373CC0(&v49);
  v31 = sub_1403C8EA0(v28, &v56, (__int64)&p_sub_142AD3050);
  v32 = (volatile signed __int32 *)v31[1];
  *v31 = 0;
  v31[1] = 0;
  if ( v32 )
  {
    if ( _InterlockedExchangeAdd(v32 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v32)(v32);
      if ( _InterlockedExchangeAdd(v32 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v32 + 8LL))(v32);
    }
  }
  v33 = v57;
  if ( v57 )
  {
    if ( _InterlockedExchangeAdd(v57 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v33)(v33);
      if ( _InterlockedExchangeAdd(v33 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v33 + 8LL))(v33);
    }
  }
  if ( (unsigned __int64)p_sub_141279340 >= 2 )
  {
    p_sub_141279340(2, &p_sub_142AD3050);
    p_sub_141279340 = 0;
  }
  v34 = v60;
  p_sub_142AD3050 = 0;
  if ( v60 )
  {
    if ( _InterlockedExchangeAdd(v60 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v34)(v34);
      if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v34 + 8LL))(v34);
    }
  }
  v35 = v59;
  if ( v59 )
  {
    if ( _InterlockedExchangeAdd(v59 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
      if ( _InterlockedExchangeAdd(v35 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
    }
  }
  sub_140373CC0(&v52);
  _Al__3 = _Al_;
  if ( (_QWORD)_Al_ )
  {
    _Al__4 = *((_QWORD *)&_Al_ + 1);
    if ( (_QWORD)_Al_ != *((_QWORD *)&_Al_ + 1) )
    {
      do
      {
        v38 = *(volatile signed __int32 **)(_Al__3 + 8);
        if ( v38 )
        {
          if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
            if ( _InterlockedExchangeAdd(v38 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
          }
        }
        _Al__3 += 0x10LL;
      }
      while ( _Al__3 != _Al__4 );
      _Al__3 = _Al_;
    }
    sub_1403A6820((__int64)&_Al_, _Al__3, (v40 - _Al__3) & 0xFFFFFFFFFFFFFFF0uLL);
    _Al_ = 0;
    v40 = 0;
  }
  if ( v6 && _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 8), 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(__int64))v6)(v6);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 0xC), 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
  }
}

// --- End Function: sub_142AD6970 (0x142AD6970) ---

// --- Function: sub_142AD6F20 (0x142AD6F20) ---
void __fastcall sub_142AD6F20(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  void *v7; // [rsp+20h] [rbp-18h] BYREF
  int v8; // [rsp+28h] [rbp-10h]

  switch ( *(_BYTE *)(a1 + 0x10) )
  {
    case 0:
    case 3:
    case 5:
    case 6:
      return;
    case 1:
      if ( sub_1403EBE30((_QWORD *)(a1 + 0x20)) && !*(_BYTE *)(a1 + 0x18) )
        goto LABEL_4;
      break;
    case 2:
      if ( sub_1403EBE30((_QWORD *)(a1 + 0x20)) )
      {
        if ( *(_BYTE *)(a1 + 0x18) )
        {
          if ( *(_BYTE *)(a1 + 0x48) )
          {
            if ( sub_1403C3450((_QWORD *)(a1 + 0x30)) )
            {
              sub_142AD4C40(a1, &v7, (const char **)(a1 + 0x20), (const char **)(a1 + 0x28));
              copyStringStructure((void **)(a1 + 0x30), (const void **)&v7, v3);
              *(_DWORD *)(a1 + 0x38) = v8;
              sub_140373CC0(&v7);
            }
            if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(a1 + 0x28), (_QWORD *)(a1 + 0x40)) )
            {
              sub_142AD6970(a1, *(_DWORD *)(a1 + 0x38), (const void **)(a1 + 0x28));
            }
            else
            {
              v4 = sub_143165DE0();
              (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 0x70LL))(v4, a1 + 0x30);
              v5 = sub_143165DE0();
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x78LL))(v5);
              *(_BYTE *)(a1 + 0x10) = 3;
            }
          }
        }
        else
        {
LABEL_4:
          v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
          (*(void (__fastcall **)(__int64, _QWORD, const ULONG_PTR *))(*(_QWORD *)v2 + 0x88LL))(
            v2,
            *(_QWORD *)(a1 + 0x20),
            &p_Src);
          *(_BYTE *)(a1 + 0x10) = 3;
        }
      }
      break;
    case 4:
      v6 = *(_QWORD *)(a1 + 0xC8);
      if ( v6 && (unsigned int)dword_149C8E13C > (unsigned __int64)(*(_QWORD *)(a1 + 0xD0) + v6) )
      {
        *(_QWORD *)(a1 + 0xC8) = 0;
        sub_1403DAB30(a1 + 0xA0);
      }
      break;
    default:
      __debugbreak();
      break;
  }
}

// --- End Function: sub_142AD6F20 (0x142AD6F20) ---

// --- Function: ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z (0x142AEB380) ---
_BOOL8 __fastcall std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
        _QWORD *a1,
        _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z (0x142AEB380) ---

// --- Function: sub_142AEB610 (0x142AEB610) ---
_QWORD *__fastcall sub_142AEB610(_QWORD *a1)
{
  *a1 += 8LL;
  return a1;
}

// --- End Function: sub_142AEB610 (0x142AEB610) ---

// --- Function: sub_142B13C60 (0x142B13C60) ---
_QWORD *__fastcall sub_142B13C60(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_22;
  if ( n0xFFFF_22 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                          qword_149C8DFC8,
                          &v9,
                          "EntityComponentMineable");
    n0xFFFF_22 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_142B13C60 (0x142B13C60) ---

// --- Function: sub_142BDC810 (0x142BDC810) ---
__int64 __fastcall sub_142BDC810(__int64 a1)
{
  void (__fastcall ***v2)(_QWORD); // rax
  __int64 v3; // rcx
  int n0x4600; // [rsp+30h] [rbp-58h] BYREF
  __int64 v6; // [rsp+34h] [rbp-54h]
  int v7; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v8; // [rsp+40h] [rbp-48h]
  unsigned __int64 v9; // [rsp+48h] [rbp-40h]
  __int64 v10; // [rsp+50h] [rbp-38h]
  __int64 v11; // [rsp+58h] [rbp-30h]

  n0x4600 = 0x4600;
  v6 = 1;
  v7 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v8 = __rdtsc();
  qword_149C89AA0(
    &n0x4600,
    &word_149F4EFCC,
    "CIGRadarSystem::CRadarSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\CIGRadarSystem/CIGRadarSystem.cpp",
    0x12E);
  HIWORD(n0x4600) = word_149F4EFCC;
  if ( Parameter_0 )
  {
    if ( !*(_QWORD *)(a1 + 0x70) )
    {
      v2 = (void (__fastcall ***)(_QWORD))(*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0
                                                                                          + 0x48LL))(
                                            Parameter_0,
                                            0x13000001);
      *(_QWORD *)(a1 + 0x70) = v2;
      if ( v2 )
        (**v2)(v2);
    }
  }
  v3 = *(_QWORD *)(a1 + 0x70);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8LL))(v3);
  v9 = __rdtsc();
  return qword_149C89AA8(&n0x4600);
}

// --- End Function: sub_142BDC810 (0x142BDC810) ---

// --- Function: sub_142BF7CB0 (0x142BF7CB0) ---
__int64 __fastcall sub_142BF7CB0(__int64 a1, __int64 a2)
{
  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 0x10) )
    return sub_142AE6600(a1, *(_QWORD *)(a1 + 8), a2);
  else
    return sub_142AE6290(a1, a2);
}

// --- End Function: sub_142BF7CB0 (0x142BF7CB0) ---

// --- Function: sub_142C065D0 (0x142C065D0) ---
_QWORD *__fastcall sub_142C065D0(_QWORD *a1)
{
  _BYTE v2[8]; // [rsp+20h] [rbp-28h] BYREF
  _QWORD *v3; // [rsp+28h] [rbp-20h]
  __int64 v4; // [rsp+30h] [rbp-18h]

  *a1 = 0;
  a1[1] = 0;
  v3 = a1 + 2;
  v4 = sub_1402A4D50((__int64)v2);
  sub_1402A4D50((__int64)v3);
  *v3 = 0;
  return a1;
}

// --- End Function: sub_142C065D0 (0x142C065D0) ---

// --- Function: sub_142C06B30 (0x142C06B30) ---
_QWORD *__fastcall sub_142C06B30(_QWORD *a1)
{
  sub_142C065D0(a1);
  return a1;
}

// --- End Function: sub_142C06B30 (0x142C06B30) ---

// --- Function: sub_142C0DB50 (0x142C0DB50) ---
__int64 __fastcall sub_142C0DB50(_QWORD *a1, __int64 a2)
{
  return *a1 + 8 * a2;
}

// --- End Function: sub_142C0DB50 (0x142C0DB50) ---

// --- Function: sub_142C0DBB0 (0x142C0DBB0) ---
__int64 __fastcall sub_142C0DBB0(_QWORD *a1, __int64 a2)
{
  return *a1 + (a2 << 6);
}

// --- End Function: sub_142C0DBB0 (0x142C0DBB0) ---

// --- Function: sub_142C0DC20 (0x142C0DC20) ---
__int64 __fastcall sub_142C0DC20(_QWORD *a1)
{
  return *a1 + 0x20LL;
}

// --- End Function: sub_142C0DC20 (0x142C0DC20) ---

// --- Function: ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@1@XZ (0x142C0DC50) ---
__int64 __fastcall std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(
        _QWORD *a1)
{
  return *a1 + 0x20LL;
}

// --- End Function: ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@1@XZ (0x142C0DC50) ---

// --- Function: sub_142C0DC70 (0x142C0DC70) ---
__int64 __fastcall sub_142C0DC70(__int64 a1)
{
  sub_142C0DC90(a1);
  return a1;
}

// --- End Function: sub_142C0DC70 (0x142C0DC70) ---

// --- Function: sub_142C0DC90 (0x142C0DC90) ---
__int64 __fastcall sub_142C0DC90(__int64 a1)
{
  __int64 v2; // [rsp+0h] [rbp-18h]
  __int64 *i; // [rsp+8h] [rbp-10h]

  if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 0x10LL) + 0x19LL) )
  {
    while ( 1 )
    {
      v2 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
      if ( *(_BYTE *)(v2 + 0x19) || *(_QWORD *)a1 != *(_QWORD *)(v2 + 0x10) )
        break;
      *(_QWORD *)a1 = v2;
    }
    *(_QWORD *)a1 = v2;
  }
  else
  {
    for ( i = *(__int64 **)(*(_QWORD *)a1 + 0x10LL); !*(_BYTE *)(*i + 0x19); i = (__int64 *)*i )
      ;
    *(_QWORD *)a1 = i;
  }
  return a1;
}

// --- End Function: sub_142C0DC90 (0x142C0DC90) ---

// --- Function: sub_142C0DD60 (0x142C0DD60) ---
_QWORD *__fastcall sub_142C0DD60(_QWORD *a1)
{
  *a1 += 0x10LL;
  return a1;
}

// --- End Function: sub_142C0DD60 (0x142C0DD60) ---

// --- Function: sub_142C64A50 (0x142C64A50) ---
Parameter *__fastcall sub_142C64A50(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  Parameter *Parameter_2; // [rsp+28h] [rbp-30h]

  Parameter_2 = Parameter + 1;
  Parameter_1 = Parameter;
  if ( *Parameter != Parameter[1] )
  {
    _StarEngineModule__((ULONG_PTR)Parameter);
    Parameter_1 = Parameter_2;
    *Parameter_2 = *Parameter;
  }
  return Parameter_1;
}

// --- End Function: sub_142C64A50 (0x142C64A50) ---

// --- Function: sub_142C64BB0 (0x142C64BB0) ---
_QWORD *__fastcall sub_142C64BB0(_QWORD *a1)
{
  _QWORD *result; // rax

  result = a1;
  a1[1] = *a1;
  return result;
}

// --- End Function: sub_142C64BB0 (0x142C64BB0) ---

// --- Function: sub_142C64FF0 (0x142C64FF0) ---
_BOOL8 __fastcall sub_142C64FF0(_QWORD *a1)
{
  return *a1 == a1[1];
}

// --- End Function: sub_142C64FF0 (0x142C64FF0) ---

// --- Function: sub_142C672F0 (0x142C672F0) ---
__int64 __fastcall sub_142C672F0(__int64 a1, __int64 a2)
{
  return sub_142BF7CB0(a1, a2);
}

// --- End Function: sub_142C672F0 (0x142C672F0) ---

// --- Function: sub_142C69A80 (0x142C69A80) ---
_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *__fastcall sub_142C69A80(
        _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *a1,
        __int64 *a2,
        _QWORD *a3)
{
  __int64 v4; // [rsp+20h] [rbp-18h] BYREF
  wchar_t *v5; // [rsp+28h] [rbp-10h] BYREF

  v4 = *a2;
  v5 = (wchar_t *)(sub_1402A4EC0((__int64)&v4) / *a3);
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(a1, (const wchar_t **)&v5);
  return a1;
}

// --- End Function: sub_142C69A80 (0x142C69A80) ---

// --- Function: sub_142C69B80 (0x142C69B80) ---
__int64 __fastcall sub_142C69B80(_QWORD *a1, _BYTE *a2, __int64 a3)
{
  __int64 result; // rax

  result = (unsigned __int8)sub_14048D530(a1, a2);
  if ( (_BYTE)result )
  {
    sub_142C69BE0(a1, a3);
    return sub_140387CB0((__int64)a1, (__int64)&unk_1482C0F54);
  }
  return result;
}

// --- End Function: sub_142C69B80 (0x142C69B80) ---

// --- Function: sub_142C69BE0 (0x142C69BE0) ---
__int64 __fastcall sub_142C69BE0(__int64 a1, ULONG_PTR **a2)
{
  ULONG_PTR Parameter; // [rsp+28h] [rbp-60h] BYREF
  __int64 v4; // [rsp+30h] [rbp-58h]
  ULONG_PTR **v5; // [rsp+38h] [rbp-50h]
  ULONG_PTR **v6; // [rsp+40h] [rbp-48h]
  ULONG_PTR Parameter_; // [rsp+48h] [rbp-40h] BYREF
  Parameter *Parameter_1; // [rsp+50h] [rbp-38h]
  ULONG_PTR *Parameter__1; // [rsp+58h] [rbp-30h]
  ULONG_PTR v10; // [rsp+60h] [rbp-28h]
  ULONG_PTR v11; // [rsp+68h] [rbp-20h]
  _QWORD *v12; // [rsp+70h] [rbp-18h]
  int *v13; // [rsp+78h] [rbp-10h]

  sub_140387C80(a1, 0x7B);
  v4 = 0;
  v5 = a2;
  Parameter_1 = **a2;
  Parameter = Parameter_1;
  _StarEngineModule__((ULONG_PTR)&Parameter);
  while ( 1 )
  {
    v6 = a2;
    Parameter__1 = *a2;
    Parameter_ = (ULONG_PTR)Parameter__1;
    _StarEngineModule__((ULONG_PTR)&Parameter_);
    if ( Parameter == Parameter_ )
      break;
    v10 = Parameter + 0x20;
    v12 = (_QWORD *)(Parameter + 0x20);
    v11 = Parameter + 0x20;
    v13 = (int *)(Parameter + 0x28);
    if ( v4 )
      sub_140387C80(a1, 0x2C);
    sub_142C98FF0(a1, v12);
    sub_140387C80(a1, 0x3A);
    sub_140492950(a1, *v13);
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string>>>>>,std::_Iterator_base0>::operator++((std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *)&Parameter);
    ++v4;
  }
  return sub_140387C80(a1, 0x7D);
}

// --- End Function: sub_142C69BE0 (0x142C69BE0) ---

// --- Function: sub_142C74070 (0x142C74070) ---
__int64 __fastcall sub_142C74070(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v6; // [rsp+40h] [rbp-C8h]
  char v8[8]; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v9; // [rsp+60h] [rbp-A8h]
  __int64 v10; // [rsp+68h] [rbp-A0h]
  __int64 *v11; // [rsp+70h] [rbp-98h]
  __int64 v12; // [rsp+78h] [rbp-90h]
  __int64 *v13; // [rsp+80h] [rbp-88h]
  __int64 v14; // [rsp+88h] [rbp-80h]
  __int64 v15; // [rsp+90h] [rbp-78h]
  __int64 v16; // [rsp+98h] [rbp-70h]
  __int64 inserted; // [rsp+A0h] [rbp-68h]
  _QWORD dst_[3]; // [rsp+A8h] [rbp-60h] BYREF
  _BYTE dst__1[16]; // [rsp+C0h] [rbp-48h] BYREF
  char v20[56]; // [rsp+D0h] [rbp-38h] BYREF

  v10 = *a1;
  v11 = a1;
  std::_Tree_temp_node<std::_Crt_allocator<std::_Tree_node<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>,void *>>>::_Tree_temp_node<std::_Crt_allocator<std::_Tree_node<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>,void *>>>(
    (unsigned int)v8,
    (_DWORD)a1,
    v10,
    a3,
    a4);
  v6 = v9 + 0x20;
  qmemcpy(
    dst_,
    (const void *)std::_Tree<std::_Tmap_traits<std::string,unsigned __int64,std::less<std::string>,std::allocator<std::pair<std::string const,unsigned __int64>>,0>>::_Find_lower_bound<std::string>(
                    a1,
                    (__int64)v20,
                    (_QWORD *)(v9 + 0x20)),
    sizeof(dst_));
  if ( !*(_BYTE *)(dst_[2] + 0x19LL)
    && (v13 = a1, v12 = dst_[2] + 0x20LL, !(unsigned __int8)sub_1403869D0(a1, v6, dst_[2] + 0x20LL)) )
  {
    *(_QWORD *)a2 = dst_[2];
    *(_BYTE *)(a2 + 8) = 0;
    sub_1409ADF80(v8);
  }
  else
  {
    sub_1403E3D70(a1);
    v14 = 0;
    v15 = v9;
    v9 = 0;
    v16 = v15;
    sub_1409ADF80(v8);
    qmemcpy(dst__1, dst_, sizeof(dst__1));
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 (__int64 **)a1,
                 (__int64)dst__1,
                 v16);
    *(_QWORD *)a2 = inserted;
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}

// --- End Function: sub_142C74070 (0x142C74070) ---

// --- Function: sub_142C742A0 (0x142C742A0) ---
__int64 __fastcall sub_142C742A0(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v6; // [rsp+40h] [rbp-C8h]
  char v8[8]; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v9; // [rsp+60h] [rbp-A8h]
  __int64 v10; // [rsp+68h] [rbp-A0h]
  __int64 *v11; // [rsp+70h] [rbp-98h]
  __int64 v12; // [rsp+78h] [rbp-90h]
  __int64 *v13; // [rsp+80h] [rbp-88h]
  __int64 v14; // [rsp+88h] [rbp-80h]
  __int64 v15; // [rsp+90h] [rbp-78h]
  __int64 v16; // [rsp+98h] [rbp-70h]
  __int64 inserted; // [rsp+A0h] [rbp-68h]
  _QWORD dst_[3]; // [rsp+A8h] [rbp-60h] BYREF
  _BYTE dst__1[16]; // [rsp+C0h] [rbp-48h] BYREF
  char v20[56]; // [rsp+D0h] [rbp-38h] BYREF

  v10 = *a1;
  v11 = a1;
  std::_Tree_temp_node<std::_Crt_allocator<std::_Tree_node<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>,void *>>>::_Tree_temp_node<std::_Crt_allocator<std::_Tree_node<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>,void *>>>(
    (unsigned int)v8,
    (_DWORD)a1,
    v10,
    a3,
    a4);
  v6 = v9 + 0x20;
  qmemcpy(
    dst_,
    (const void *)std::_Tree<std::_Tmap_traits<std::string,unsigned __int64,std::less<std::string>,std::allocator<std::pair<std::string const,unsigned __int64>>,0>>::_Find_lower_bound<std::string>(
                    a1,
                    (__int64)v20,
                    (_QWORD *)(v9 + 0x20)),
    sizeof(dst_));
  if ( !*(_BYTE *)(dst_[2] + 0x19LL)
    && (v13 = a1, v12 = dst_[2] + 0x20LL, !(unsigned __int8)sub_1403869D0(a1, v6, dst_[2] + 0x20LL)) )
  {
    *(_QWORD *)a2 = dst_[2];
    *(_BYTE *)(a2 + 8) = 0;
    sub_1409ADF80(v8);
  }
  else
  {
    sub_1403E3D70(a1);
    v14 = 0;
    v15 = v9;
    v9 = 0;
    v16 = v15;
    sub_1409ADF80(v8);
    qmemcpy(dst__1, dst_, sizeof(dst__1));
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 (__int64 **)a1,
                 (__int64)dst__1,
                 v16);
    *(_QWORD *)a2 = inserted;
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}

// --- End Function: sub_142C742A0 (0x142C742A0) ---

// --- Function: sub_142C7E640 (0x142C7E640) ---
__int64 __fastcall sub_142C7E640(_DWORD *a1, _DWORD *a2, unsigned int a3)
{
  _BYTE buf_[16]; // [rsp+0h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+10h] [rbp-48h]
  _DWORD *v6; // [rsp+18h] [rbp-40h]
  _DWORD *v7; // [rsp+20h] [rbp-38h]
  _DWORD *v8; // [rsp+28h] [rbp-30h]
  _DWORD *v9; // [rsp+30h] [rbp-28h]
  _DWORD *v10; // [rsp+38h] [rbp-20h]
  _DWORD *v11; // [rsp+40h] [rbp-18h]

  memset(buf_, 0, 1u);
  buf_[8] = buf_[0];
  v5 = a3;
  v9 = a2;
  v7 = a1;
  v8 = a1;
  v6 = a1;
  v10 = a2;
  v11 = a2;
  while ( v6 != v11 )
    v5 += *v6++;
  return v5;
}

// --- End Function: sub_142C7E640 (0x142C7E640) ---

// --- Function: sub_142C7EE10 (0x142C7EE10) ---
_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *__fastcall sub_142C7EE10(
        _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *a1,
        __int64 a2)
{
  wchar_t *v5; // [rsp+28h] [rbp-10h] BYREF

  sub_1402A4EC0(a2);
  __asm { vcvtsi2sd xmm0, xmm0, rax }
  *(double *)&v5 = *(double *)&_XMM0 / 1000000.0;
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(a1, (const wchar_t **)&v5);
  return a1;
}

// --- End Function: sub_142C7EE10 (0x142C7EE10) ---

// --- Function: sub_142C7EE60 (0x142C7EE60) ---
__int64 __fastcall sub_142C7EE60(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  ULONG_PTR Parameter[2]; // [rsp+20h] [rbp-28h] BYREF
  ULONG_PTR v6; // [rsp+30h] [rbp-18h] BYREF
  char v7; // [rsp+38h] [rbp-10h]

  sub_142C74070(a1, (__int64)&v6, a3, a4);
  Parameter[1] = v6;
  Parameter[0] = v6;
  _StarEngineModule__((ULONG_PTR)Parameter);
  *(_QWORD *)a2 = Parameter[0];
  *(_BYTE *)(a2 + 8) = v7;
  return a2;
}

// --- End Function: sub_142C7EE60 (0x142C7EE60) ---

// --- Function: sub_142C7EEE0 (0x142C7EEE0) ---
__int64 __fastcall sub_142C7EEE0(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  ULONG_PTR Parameter[2]; // [rsp+20h] [rbp-28h] BYREF
  ULONG_PTR v6; // [rsp+30h] [rbp-18h] BYREF
  char v7; // [rsp+38h] [rbp-10h]

  sub_142C742A0(a1, (__int64)&v6, a3, a4);
  Parameter[1] = v6;
  Parameter[0] = v6;
  _StarEngineModule__((ULONG_PTR)Parameter);
  *(_QWORD *)a2 = Parameter[0];
  *(_BYTE *)(a2 + 8) = v7;
  return a2;
}

// --- End Function: sub_142C7EEE0 (0x142C7EEE0) ---

// --- Function: sub_142C8CD00 (0x142C8CD00) ---
__int64 __fastcall sub_142C8CD00(__int64 a1)
{
  return sub_142D02EA0(a1);
}

// --- End Function: sub_142C8CD00 (0x142C8CD00) ---

// --- Function: sub_142C8CD20 (0x142C8CD20) ---
__int64 __fastcall sub_142C8CD20(__int64 a1)
{
  return sub_142D02F10(a1);
}

// --- End Function: sub_142C8CD20 (0x142C8CD20) ---

// --- Function: sub_142C90BA0 (0x142C90BA0) ---
__int64 __fastcall sub_142C90BA0(__int64 a1, __int64 a2)
{
  return a1 + 4 * a2;
}

// --- End Function: sub_142C90BA0 (0x142C90BA0) ---

// --- Function: sub_142C90E40 (0x142C90E40) ---
__int64 __fastcall sub_142C90E40(_QWORD *a1)
{
  return *a1 + 0x10LL;
}

// --- End Function: sub_142C90E40 (0x142C90E40) ---

// --- Function: sub_142C90F00 (0x142C90F00) ---
_QWORD **__fastcall sub_142C90F00(_QWORD **a1)
{
  *a1 = sub_1405A1070(*a1);
  return a1;
}

// --- End Function: sub_142C90F00 (0x142C90F00) ---

// --- Function: sub_142CCD520 (0x142CCD520) ---
__int64 __fastcall sub_142CCD520(_DWORD *a1, float a2)
{
  unsigned int n0xA; // esi
  unsigned int n0x11; // edi
  unsigned int n0x18; // ebx
  unsigned int n0x2C; // r10d
  unsigned int n0x40; // r8d
  unsigned int n0x60; // r11d
  unsigned int v9; // ebp
  unsigned int n0x80; // r9d
  unsigned int n0xA0; // ecx

  n0xA = (int)(float)(a2 * 3.0);
  n0x11 = (int)(float)(a2 * 5.0);
  n0x18 = (int)(float)(a2 * 11.0);
  n0x2C = (int)(float)(a2 * 29.0);
  n0x40 = (int)(float)(a2 * 43.0);
  n0x60 = (int)(float)(a2 * 71.0);
  v9 = (int)a2;
  n0x80 = (int)(float)(a2 * 97.0);
  if ( (unsigned int)(int)a2 > 1 )
    v9 = 1;
  if ( !v9 )
    v9 = 1;
  if ( n0xA > 0xA )
    n0xA = 0xA;
  if ( !n0xA )
    n0xA = 1;
  if ( n0x11 > 0x11 )
    n0x11 = 0x11;
  if ( !n0x11 )
    n0x11 = 1;
  if ( n0x18 > 0x18 )
    n0x18 = 0x18;
  if ( !n0x18 )
    n0x18 = 1;
  if ( n0x2C > 0x2C )
    n0x2C = 0x2C;
  if ( !n0x2C )
    n0x2C = 1;
  n0xA0 = (int)(float)(a2 * 109.0);
  if ( n0x40 > 0x40 )
    n0x40 = 0x40;
  if ( n0x40 < 2 )
    n0x40 = 2;
  if ( n0x60 > 0x60 )
    n0x60 = 0x60;
  if ( n0x60 < 3 )
    n0x60 = 3;
  if ( n0x80 > 0x80 )
    n0x80 = 0x80;
  if ( n0x80 < 4 )
    n0x80 = 4;
  if ( n0xA0 > 0xA0 )
    n0xA0 = 0xA0;
  if ( n0xA0 < 4 )
    n0xA0 = 4;
  return (n0x60 + a1[6] - 1) / n0x60
       + (n0x80 + a1[7] - 1) / n0x80
       + (n0xA0 + a1[8] - 1) / n0xA0
       + (n0xA + a1[1] - 1) / n0xA
       + (n0x11 + a1[2] - 1) / n0x11
       + (n0x18 + a1[3] - 1) / n0x18
       + (n0x2C + a1[4] - 1) / n0x2C
       + (n0x40 + a1[5] - 1) / n0x40
       + (v9 + *a1 - 1) / v9;
}

// --- End Function: sub_142CCD520 (0x142CCD520) ---

// --- Function: sub_142CE04B0 (0x142CE04B0) ---
void __fastcall sub_142CE04B0(__int64 a1)
{
  if ( ++**(_DWORD **)(a1 + 0x10) == 1 )
    sub_1402D4DE0(*(_QWORD *)(a1 + 8), (const char *)&p_Src, (const char *)&p_Src, 1);
}

// --- End Function: sub_142CE04B0 (0x142CE04B0) ---

// --- Function: sub_142CE0550 (0x142CE0550) ---
_DWORD *__fastcall sub_142CE0550(__int64 a1)
{
  _DWORD *result; // rax

  ++**(_DWORD **)(a1 + 0x10);
  result = *(_DWORD **)(a1 + 0x10);
  if ( *result == 1 )
    return (_DWORD *)sub_1402E0A70(*(_QWORD *)(a1 + 8), (const char *)&p_Src, (const char *)&p_Src, 1);
  return result;
}

// --- End Function: sub_142CE0550 (0x142CE0550) ---

// --- Function: sub_142CFF140 (0x142CFF140) ---
__int64 __fastcall sub_142CFF140(__int64 a1)
{
  unsigned __int8 v1; // si
  __int64 v2; // rbx
  __int64 v4; // r14
  __int64 n9; // r15
  float v6; // kr00_4
  unsigned __int32 v7; // edi
  unsigned int *v8; // rax
  volatile __int32 *v9; // rax

  v1 = 0;
  v2 = 0;
  v4 = 0;
  n9 = 9;
  do
  {
    v6 = (float)*(unsigned int *)((char *)&unk_1487F85A8 + v4);
    v7 = (int)(float)(v6 * *(float *)(a1 + 0x74));
    if ( *(_DWORD *)((char *)&unk_1487F85F8 + v4) < v7 )
      v7 = *(_DWORD *)((char *)&unk_1487F85F8 + v4);
    if ( v7 < *(_DWORD *)((char *)&unk_1487F85D0 + v4) )
      v7 = *(_DWORD *)((char *)&unk_1487F85D0 + v4);
    if ( v1 || (v8 = (unsigned int *)sub_142C90BA0(a1 + 0x50, v2), (unsigned int)sub_1402A6C80(v8) != v7) )
      v1 = 1;
    v9 = (volatile __int32 *)sub_142C90BA0(a1 + 0x50, v2);
    sub_1408000B0(v9, v7);
    ++v2;
    v4 += 4;
    --n9;
  }
  while ( n9 );
  return v1;
}

// --- End Function: sub_142CFF140 (0x142CFF140) ---

// --- Function: sub_142D02EA0 (0x142D02EA0) ---
_DWORD *__fastcall sub_142D02EA0(__int64 a1)
{
  _DWORD *result; // rax

  --**(_DWORD **)(a1 + 0x10);
  result = *(_DWORD **)(a1 + 0x10);
  if ( !*result )
    return (_DWORD *)rw_lock_release_read_lock(*(_QWORD *)(a1 + 8));
  return result;
}

// --- End Function: sub_142D02EA0 (0x142D02EA0) ---

// --- Function: sub_142D02F10 (0x142D02F10) ---
const ULONG_PTR *__fastcall sub_142D02F10(__int64 a1)
{
  const ULONG_PTR *result; // rax

  --**(_DWORD **)(a1 + 0x10);
  result = *(const ULONG_PTR **)(a1 + 0x10);
  if ( !*(_DWORD *)result )
    return sub_1402E0B70(*(_QWORD *)(a1 + 8));
  return result;
}

// --- End Function: sub_142D02F10 (0x142D02F10) ---

// --- Function: sub_142D04080 (0x142D04080) ---
void __fastcall sub_142D04080(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int128 v4; // xmm9
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *v6; // rax
  _QWORD *v7; // rsi
  __m128 v8; // xmm0
  __int128 v10; // kr00_16
  __int128 v13; // xmm2
  __int128 v21; // kr00_16
  int v22; // esi
  unsigned int v23; // eax
  unsigned int v24; // esi
  unsigned int v25; // eax
  float v26; // xmm1_4
  __int128 n0x41F00000_1; // kr00_16
  __int128 n0x41F00000; // xmm1
  __int128 n0x41F00000_2; // kr00_16
  __int128 n0x41F00000_3; // xmm2
  __int128 n0x3D0D3DCB; // xmm7
  __int128 n0x4059999A; // xmm8
  __int64 n0xF; // r14
  __int128 n0x4059999A_1; // kr00_16
  __int128 n0x4059999A_2; // xmm6
  __int128 n0x4059999A_3; // xmm3
  __int128 n0x3D0D3DCB_1; // xmm0
  int v43; // eax
  int v44; // eax
  unsigned __int32 v45; // eax
  __int64 v46; // [rsp+20h] [rbp-A8h] BYREF
  __int64 v47; // [rsp+28h] [rbp-A0h] BYREF
  double v48; // [rsp+30h] [rbp-98h] BYREF
  _BYTE v49[8]; // [rsp+38h] [rbp-90h] BYREF
  __int64 v50; // [rsp+40h] [rbp-88h] BYREF
  __int128 v51; // [rsp+50h] [rbp-78h]
  __int128 v52; // [rsp+60h] [rbp-68h]
  __int128 v53; // [rsp+70h] [rbp-58h]
  __int128 v54; // [rsp+80h] [rbp-48h]
  __int64 v55; // [rsp+E0h] [rbp+18h] BYREF
  __int64 v56; // [rsp+E8h] [rbp+20h] BYREF

  if ( *(_DWORD *)(a1 + 0x158) <= 1u )
  {
    v7 = (_QWORD *)(a1 + 0x160);
  }
  else
  {
    sub_1402FD820(&v55, (_QWORD *)(a1 + 0x150), (_QWORD *)(a1 + 0x148));
    v47 = (unsigned int)(*(_DWORD *)(a1 + 0x158) - 1);
    v6 = sub_142C69A80((_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *)v49, &v55, &v47);
    sub_1402FE5E0(&v55, v6);
    v7 = (_QWORD *)(a1 + 0x160);
    sub_1402FE5E0((_QWORD *)(a1 + 0x160), &v55);
    *(_DWORD *)(a1 + 0x168) += *(_DWORD *)(a1 + 0x158);
    ++*(_DWORD *)(a1 + 0x16C);
  }
  *(_DWORD *)(a1 + 0x158) = 0;
  v56 = 0;
  sub_1402B3CF0(&v56);
  *(_QWORD *)(a1 + 0x148) = v56;
  v46 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                     qword_149C8DF80,
                     0);
  sub_14059CA60(&v46, &v50, (_QWORD *)(a1 + 0x138));
  v8 = sub_14059CC00();
  *((_QWORD *)&v10 + 1) = v8.m128_u64[1];
  *(double *)&v10 = *(double *)v8.m128_u64 * 1000.0;
  _XMM0 = v10;
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  if ( *(float *)&_XMM1 < 2000.0 )
    goto LABEL_42;
  v54 = v1;
  v53 = v2;
  v52 = v3;
  v51 = v4;
  *(_QWORD *)(a1 + 0x138) = v46;
  if ( *(_DWORD *)(a1 + 0x168) )
  {
    sub_142C7EE10((_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *)&v48, (__int64)v7);
    v13 = *(unsigned __int64 *)&v48;
    _XMM0 = 0;
    __asm { vcvtsi2sd xmm0, xmm0, rax }
    _XMM0 = COERCE_UNSIGNED_INT64(v48 / *(double *)&_XMM0);
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    _XMM0 = 0;
    __asm { vcvtsi2sd xmm0, xmm0, rax }
    *(float *)(a1 + 0x7C) = *(float *)&_XMM1;
    *((_QWORD *)&v21 + 1) = *((_QWORD *)&v13 + 1);
    *(double *)&v21 = *(double *)&v13 / *(double *)&_XMM0;
    _XMM1 = v21;
    __asm { vcvtsd2ss xmm0, xmm1, xmm1 }
    *v7 = 0;
    *(_QWORD *)(a1 + 0x168) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 0x7C) = 0;
    LODWORD(_XMM0) = 0;
  }
  *(float *)(a1 + 0x80) = *(float *)&_XMM0;
  v22 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x20) == v22 )
  {
    ++*(_DWORD *)(a1 + 0x24);
  }
  else
  {
    v23 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x10), 1, 0);
    if ( v23 )
      sub_1403C6E80(a1 + 0x10, v23, (__int64)"CSCActorUpdateManager::Update", 1);
    else
      *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x20) = v22;
  }
  if ( !BYTE1(qword_149C8E516) )
  {
    if ( dword_149B81560 > 0 )
    {
      *(_DWORD *)(a1 + 0x4C) = dword_149B81560;
      v24 = dword_149B81560;
      goto LABEL_24;
    }
LABEL_19:
    v25 = sub_142CCD520((_DWORD *)(a1 + 0x28), *(float *)(a1 + 0x74));
    v26 = *(float *)(a1 + 0x7C);
    if ( v26 == 0.0 || !v25 )
    {
      n0x41F00000 = 0x41F00000u;
    }
    else
    {
      n0x41F00000_1 = 0;
      *(float *)&n0x41F00000_1 = (float)v25;
      *(float *)&n0x41F00000_1 = *(float *)&n0x41F00000_1 / v26;
      n0x41F00000 = n0x41F00000_1;
    }
    n0x41F00000_2 = n0x41F00000;
    *(float *)&n0x41F00000_2 = (float)((float)(*(float *)&n0x41F00000 - *(float *)(a1 + 0x170)) * 0.5)
                             + *(float *)(a1 + 0x170);
    n0x41F00000_3 = n0x41F00000_2;
    __asm
    {
      vminss  xmm0, xmm2, cs:dword_148350DF8
      vmaxss  xmm1, xmm0, cs:flt_1482C3C50
    }
    v24 = (int)*(float *)&_XMM1;
    *(_DWORD *)(a1 + 0x4C) = (int)*(float *)&_XMM1;
    *(float *)(a1 + 0x170) = *(float *)&_XMM1;
    goto LABEL_24;
  }
  if ( dword_149B8155C <= 0 )
    goto LABEL_19;
  *(_DWORD *)(a1 + 0x4C) = dword_149B8155C;
  v24 = dword_149B8155C;
LABEL_24:
  n0x3D0D3DCB = 0x3D0D3DCBu;
  n0x4059999A = 0x4059999Au;
  if ( (unsigned int)sub_142CCD520((_DWORD *)(a1 + 0x28), 0.034482758) > v24 )
  {
    if ( (unsigned int)sub_142CCD520((_DWORD *)(a1 + 0x28), 3.4000001) <= v24 )
    {
      n0xF = 0xF;
      while ( 1 )
      {
        n0x4059999A_1 = n0x4059999A;
        *(float *)&n0x4059999A_1 = (float)(*(float *)&n0x4059999A + *(float *)&n0x3D0D3DCB) * 0.5;
        n0x4059999A_2 = n0x4059999A_1;
        _XMM0 = (unsigned int)sub_142CCD520((_DWORD *)(a1 + 0x28), *(float *)&n0x4059999A_1);
        __asm { vpcmpgtq xmm2, xmm0, xmm1 }
        __asm { vblendvps xmm3, xmm6, xmm8, xmm2 }
        __asm
        {
          vpcmpgtq xmm2, xmm0, xmm1
          vblendvps xmm0, xmm7, xmm6, xmm2
        }
        n0x4059999A = n0x4059999A_3;
        if ( !--n0xF )
          break;
        n0x3D0D3DCB = (unsigned int)n0x3D0D3DCB_1;
      }
      LODWORD(n0x3D0D3DCB) = n0x4059999A_3;
    }
    else
    {
      LODWORD(n0x3D0D3DCB) = 0x4059999A;
    }
  }
  *(float *)(a1 + 0x74) = *(float *)&n0x3D0D3DCB;
  if ( (unsigned __int8)sub_142CFF140(a1) )
    sub_1408000B0((volatile __int32 *)(a1 + 0x78), dword_149C8E13C);
  v43 = *(_DWORD *)(a1 + 0x48);
  *(__m256i *)(a1 + 0x174) = *(__m256i *)(a1 + 0x28);
  *(_DWORD *)(a1 + 0x194) = v43;
  v44 = *(_DWORD *)(a1 + 0x24);
  if ( v44 )
  {
    *(_DWORD *)(a1 + 0x24) = v44 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x20) = 0xFFFFFFFF;
    v45 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x10), 0, 1);
    if ( v45 == 1 )
    {
      *(_QWORD *)(a1 + 0x18) = &p_Src;
    }
    else
    {
      __asm { vzeroupper }
      sub_1403DF590(a1 + 0x10, v45);
    }
  }
  if ( BYTE1(qword_149C8E516) )
  {
    __asm { vzeroupper }
    sub_142D08AB0(a1);
    if ( !*(_DWORD *)(a1 + 0x140) )
      sub_142D07EF0(a1);
    *(_DWORD *)(a1 + 0x140) = (*(_DWORD *)(a1 + 0x140) + 1) % 0xAu;
  }
LABEL_42:
  __asm { vzeroupper }
}

// --- End Function: sub_142D04080 (0x142D04080) ---

// --- Function: sub_142D07EF0 (0x142D07EF0) ---
__int64 __fastcall sub_142D07EF0(int *a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdi
  _DWORD *v12; // rbx
  _DWORD **v13; // rax
  int v14; // eax
  float v15; // xmm1_4
  _BYTE v17[16]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v18[2]; // [rsp+30h] [rbp-20h] BYREF
  __int64 v19[2]; // [rsp+40h] [rbp-10h] BYREF
  int v20; // [rsp+80h] [rbp+30h] BYREF
  int v21; // [rsp+88h] [rbp+38h] BYREF
  void *v22; // [rsp+90h] [rbp+40h] BYREF
  char v23; // [rsp+98h] [rbp+48h] BYREF

  sub_1402B0F80(v19);
  sub_142C7EE60(v19, (__int64)v17, (int)"Closest", (__int64)(a1 + 0x5D));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod0", (__int64)(a1 + 0x5E));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod1", (__int64)(a1 + 0x5F));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod2", (__int64)(a1 + 0x60));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod3", (__int64)(a1 + 0x61));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod4", (__int64)(a1 + 0x62));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod5", (__int64)(a1 + 0x63));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod6", (__int64)(a1 + 0x64));
  sub_142C7EE60(v19, (__int64)v17, (int)"Lod7", (__int64)(a1 + 0x65));
  sub_1402B0F80(v18);
  v2 = sub_142C90BA0((__int64)(a1 + 0x14), 0);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Closest", v2);
  v3 = sub_142C90BA0((__int64)(a1 + 0x14), 1);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod0", v3);
  v4 = sub_142C90BA0((__int64)(a1 + 0x14), 2);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod1", v4);
  v5 = sub_142C90BA0((__int64)(a1 + 0x14), 3);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod2", v5);
  v6 = sub_142C90BA0((__int64)(a1 + 0x14), 4);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod3", v6);
  v7 = sub_142C90BA0((__int64)(a1 + 0x14), 5);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod4", v7);
  v8 = sub_142C90BA0((__int64)(a1 + 0x14), 6);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod5", v8);
  v9 = sub_142C90BA0((__int64)(a1 + 0x14), 7);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod6", v9);
  v10 = sub_142C90BA0((__int64)(a1 + 0x14), 8);
  sub_142C7EEE0(v18, (__int64)v17, (int)"Lod7", v10);
  v11 = qword_149C8E060;
  v12 = *(_DWORD **)sub_142D15A70(a1 + 0x5D, &v23);
  v13 = (_DWORD **)sub_142D12B80(a1 + 0x5D, v17);
  v14 = sub_142C7E640(*v13, v12, 0);
  v15 = *((float *)a1 + 0x1D);
  v21 = v14;
  v20 = sub_142CCD520(a1 + 0x5D, v15);
  sub_14045A0B0(&v22);
  sub_1409A4020(&v22, "EstimatedTimePerActor");
  sub_1409A4020(&v22, "EstimatedTimePerFrame");
  sub_1405CC240(&v22, "ActorPerFrameBudget", a1 + 0x13);
  sub_142C69B80(&v22, "ActorCounts", (__int64)v19);
  sub_142C69B80(&v22, "UpdateFrequencies", (__int64)v18);
  sub_1409A4020(&v22, "UpdateFrequencyScale");
  sub_1405CC240(&v22, "EstimatedActorPerFrameCost", &v20);
  sub_1405CC240(&v22, "TotalActorCount", &v21);
  (*(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v11 + 0x40LL))(
    v11,
    "void __cdecl CSCActorUpdateManager::WriteAnalytics(void) const",
    "ActorUpdateManagerStatus",
    &v22);
  sub_140373CC0(&v22);
  sub_1409ADF50(v18);
  return sub_1409ADF50(v19);
}

// --- End Function: sub_142D07EF0 (0x142D07EF0) ---

// --- Function: sub_142D08AB0 (0x142D08AB0) ---
__int64 __fastcall sub_142D08AB0(__int64 a1)
{
  __int64 v2; // rcx
  void (__fastcall *v3)(_QWORD, void *, const char *); // rbx
  unsigned int *v4; // rax
  unsigned int v5; // eax
  void (__fastcall *v6)(_QWORD, void *, const char *); // rbx
  unsigned int *v7; // rax
  unsigned int v8; // eax
  void (__fastcall *v9)(_QWORD, void *, const char *); // rbx
  unsigned int *v10; // rax
  unsigned int v11; // eax
  void (__fastcall *v12)(_QWORD, void *, const char *); // rbx
  unsigned int *v13; // rax
  unsigned int v14; // eax
  void (__fastcall *v15)(_QWORD, void *, const char *); // rbx
  unsigned int *v16; // rax
  unsigned int v17; // eax
  void (__fastcall *v18)(_QWORD, void *, const char *); // rbx
  unsigned int *v19; // rax
  unsigned int v20; // eax
  void (__fastcall *v21)(_QWORD, void *, const char *); // rbx
  unsigned int *v22; // rax
  unsigned int v23; // eax
  void (__fastcall *v24)(_QWORD, void *, const char *); // rbx
  unsigned int *v25; // rax
  unsigned int v26; // eax
  void (__fastcall *v27)(_QWORD, void *, const char *); // rbx
  unsigned int *v28; // rax
  unsigned int v29; // eax
  __int64 v30; // rcx
  unsigned int v31; // eax
  __int64 (__fastcall *v32)(_QWORD, void *, const char *); // rdi
  _DWORD *v33; // rbx
  _DWORD **v34; // rax
  unsigned int v35; // eax
  char v37; // [rsp+40h] [rbp+8h] BYREF
  char v38; // [rsp+48h] [rbp+10h] BYREF

  qword_149C89B08(a1, &unk_149F50814, "Actor/Update manager/Estimated time per actor");
  qword_149C89B08(v2, &unk_149F50818, "Actor/Update manager/Estimated time per frame");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x4C), &unk_149F5081C, "Actor/Update manager/Actor per frame budget");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x174), &unk_149F50820, "Actor/Update manager/Actor counts/Closest");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x178), &unk_149F50824, "Actor/Update manager/Actor counts/Lod0");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x17C), &unk_149F50828, "Actor/Update manager/Actor counts/Lod1");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x180), &unk_149F5082C, "Actor/Update manager/Actor counts/Lod2");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x184), &unk_149F50830, "Actor/Update manager/Actor counts/Lod3");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x188), &unk_149F50834, "Actor/Update manager/Actor counts/Lod4");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x18C), &unk_149F50838, "Actor/Update manager/Actor counts/Lod5");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x190), &unk_149F5083C, "Actor/Update manager/Actor counts/Lod6");
  qword_149C89AF8(*(unsigned int *)(a1 + 0x194), &unk_149F50840, "Actor/Update manager/Actor counts/Lod7");
  v3 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v4 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 0);
  v5 = sub_1402A6C80(v4);
  v3(v5, &unk_149F50844, "Actor/Update manager/Update frequencies/Closest");
  v6 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v7 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 1);
  v8 = sub_1402A6C80(v7);
  v6(v8, &unk_149F50848, "Actor/Update manager/Update frequencies/Lod0");
  v9 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v10 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 2);
  v11 = sub_1402A6C80(v10);
  v9(v11, &unk_149F5084C, "Actor/Update manager/Update frequencies/Lod1");
  v12 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v13 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 3);
  v14 = sub_1402A6C80(v13);
  v12(v14, &unk_149F50850, "Actor/Update manager/Update frequencies/Lod2");
  v15 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v16 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 4);
  v17 = sub_1402A6C80(v16);
  v15(v17, &unk_149F50854, "Actor/Update manager/Update frequencies/Lod3");
  v18 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v19 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 5);
  v20 = sub_1402A6C80(v19);
  v18(v20, &unk_149F50858, "Actor/Update manager/Update frequencies/Lod4");
  v21 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v22 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 6);
  v23 = sub_1402A6C80(v22);
  v21(v23, &unk_149F5085C, "Actor/Update manager/Update frequencies/Lod5");
  v24 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v25 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 7);
  v26 = sub_1402A6C80(v25);
  v24(v26, &unk_149F50860, "Actor/Update manager/Update frequencies/Lod6");
  v27 = (void (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v28 = (unsigned int *)sub_142C90BA0(a1 + 0x50, 8);
  v29 = sub_1402A6C80(v28);
  v27(v29, &unk_149F50864, "Actor/Update manager/Update frequencies/Lod7");
  qword_149C89B08(v30, &unk_149F50868, "Actor/Update manager/Update frequency scale");
  v31 = sub_142CCD520((_DWORD *)(a1 + 0x174), *(float *)(a1 + 0x74));
  qword_149C89AF8(v31, &unk_149F5086C, "Actor/Update manager/Estimated actor per frame cost");
  v32 = (__int64 (__fastcall *)(_QWORD, void *, const char *))qword_149C89AF8;
  v33 = *(_DWORD **)sub_142D15A70(a1 + 0x174, &v37);
  v34 = (_DWORD **)sub_142D12B80(a1 + 0x174, &v38);
  v35 = sub_142C7E640(*v34, v33, 0);
  return v32(v35, &unk_149F50870, "Actor/Update manager/Total actor count");
}

// --- End Function: sub_142D08AB0 (0x142D08AB0) ---

// --- Function: sub_142D12B10 (0x142D12B10) ---
_QWORD *__fastcall sub_142D12B10(_QWORD **a1, Parameter *Parameter_1)
{
  *Parameter_1 = **a1;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_142D12B10 (0x142D12B10) ---

// --- Function: sub_142D12B80 (0x142D12B80) ---
_QWORD *__fastcall sub_142D12B80(__int64 a1, _QWORD *a2)
{
  *a2 = a1;
  return a2;
}

// --- End Function: sub_142D12B80 (0x142D12B80) ---

// --- Function: sub_142D159A0 (0x142D159A0) ---
_QWORD *__fastcall sub_142D159A0(__int64 a1, Parameter *Parameter_1)
{
  *Parameter_1 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_142D159A0 (0x142D159A0) ---

// --- Function: sub_142D15A10 (0x142D15A10) ---
_QWORD *__fastcall sub_142D15A10(__int64 a1, Parameter *Parameter_1)
{
  *Parameter_1 = *(_QWORD *)(a1 + 8);
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_142D15A10 (0x142D15A10) ---

// --- Function: sub_142D15A70 (0x142D15A70) ---
_QWORD *__fastcall sub_142D15A70(__int64 a1, _QWORD *a2)
{
  *a2 = a1 + 0x24;
  return a2;
}

// --- End Function: sub_142D15A70 (0x142D15A70) ---

// --- Function: sub_142D16460 (0x142D16460) ---
__int64 __fastcall sub_142D16460(__int64 a1, __int64 a2)
{
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = a1 + 0x18;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_DWORD *)(a2 + 0x18) = 0;
  sub_142CE04B0(a2);
  return a2;
}

// --- End Function: sub_142D16460 (0x142D16460) ---

// --- Function: initialize_and_acquire_context_lock (0x142D17210) ---
// Initializes the context structure pointed to by `context_ptr`. Sets field at
// offset 0 to `base_ptr`. Sets field at offset 8 to `base_ptr + 24`. Sets field at
// offset 16 to point to the counter/state at `context_ptr + 24`. Initializes the
// counter/state at offset 24 to 0. Acquires a lock or increments the reference
// count for the context by calling `sub_142AF08F0`.
__int64 __fastcall initialize_and_acquire_context_lock(__int64 a1, __int64 a2)
{
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = a1 + 0x18;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_DWORD *)(a2 + 0x18) = 0;
  sub_142CE0550(a2);
  return a2;
}

// --- End Function: initialize_and_acquire_context_lock (0x142D17210) ---

// --- Function: sub_142D19810 (0x142D19810) ---
__int64 __fastcall sub_142D19810(__int64 a1)
{
  bool v2; // [rsp+20h] [rbp-88h]
  __int64 v3; // [rsp+28h] [rbp-80h]
  __int64 v4; // [rsp+30h] [rbp-78h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  _DWORD *v6; // [rsp+48h] [rbp-60h]
  _DWORD *v7; // [rsp+50h] [rbp-58h]
  __int64 v8; // [rsp+58h] [rbp-50h]
  __int64 v9; // [rsp+60h] [rbp-48h]
  unsigned __int8 (__fastcall *v10)(__int64, __int64, __int64); // [rsp+68h] [rbp-40h]
  _BYTE v11[24]; // [rsp+70h] [rbp-38h] BYREF
  _BYTE v12[32]; // [rsp+88h] [rbp-20h] BYREF

  if ( !a1 )
    return 0;
  v7 = (_DWORD *)sub_142D5CC10(v12);
  v6 = (_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 0x18LL))(a1, v11);
  v2 = unknown_libname_19(v7, v6);
  sub_1402B6C40((__int64)v11);
  sub_1402B6C40((__int64)v12);
  if ( v2 )
    return a1;
  if ( sub_1402C9900()
    && (v3 = sub_1402C9900(), (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x240LL))(v3))
    && (v4 = sub_1402C9900(),
        v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x240LL))(v4),
        v10 = *(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 0x100LL),
        v8 = sub_142D5CBF0(),
        v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1),
        v10(v5, v9, v8)) )
  {
    return a1;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_142D19810 (0x142D19810) ---

// --- Function: sub_142D1A700 (0x142D1A700) ---
__int64 __fastcall sub_142D1A700(__int64 a1)
{
  return sub_142D19810(*(_QWORD *)(a1 + 0xE0));
}

// --- End Function: sub_142D1A700 (0x142D1A700) ---

// --- Function: sub_142D23290 (0x142D23290) ---
__int64 __fastcall sub_142D23290(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 _Bytes; // rax
  void *v4; // [rsp+20h] [rbp-48h]
  _QWORD *v5; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-10h]

  v5 = a1 + 1;
  v8 = (__int64)(a1[1] - *a1) >> 3;
  _Bytes = sub_1402AAE00(*a2);
  v4 = std::_Allocate<16,std::_Default_allocate_traits,0>(_Bytes);
  sub_142AE6E90(*a1, *v5, v4, a1);
  return sub_142B02570(a1, v4, v8, *a2);
}

// --- End Function: sub_142D23290 (0x142D23290) ---

// --- Function: sub_142D24D70 (0x142D24D70) ---
__int64 __fastcall sub_142D24D70(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 i; // [rsp+30h] [rbp-38h]
  __int64 v6; // [rsp+40h] [rbp-28h] BYREF
  __int64 v7; // [rsp+48h] [rbp-20h] BYREF
  __int64 v8; // [rsp+50h] [rbp-18h]

  while ( 1 )
  {
    if ( (a2 - a1) >> 3 <= 0x20 )
      return sub_142D228C0(a1, a2, a4);
    if ( a3 <= 0 )
      break;
    sub_142D22A50(&v7, a1, a2, a4);
    a3 = (a3 >> 2) + (a3 >> 1);
    if ( (v7 - a1) >> 3 >= (a2 - v8) >> 3 )
    {
      sub_142D24D70(v8, a2, a3, a4);
      a2 = v7;
    }
    else
    {
      sub_142D24D70(a1, v7, a3, a4);
      a1 = v8;
    }
  }
  for ( i = (a2 - a1) >> 4; i > 0; sub_142D230D0(a1, i, (a2 - a1) >> 3, (unsigned int)&v6, a4) )
  {
    --i;
    v6 = *(_QWORD *)(a1 + 8 * i);
  }
  return sub_142D24CA0(a1, a2, a4);
}

// --- End Function: sub_142D24D70 (0x142D24D70) ---

// --- Function: sub_142D272A0 (0x142D272A0) ---
__int64 __fastcall sub_142D272A0(__int64 a1, __int64 a2)
{
  unsigned __int8 v3; // [rsp+21h] [rbp-27h]

  return sub_142D24D70(a1, a2, (a2 - a1) >> 3, v3);
}

// --- End Function: sub_142D272A0 (0x142D272A0) ---

// --- Function: sub_142D416A0 (0x142D416A0) ---
__int64 __fastcall sub_142D416A0(__int64 a1)
{
  if ( (unsigned __int8)sub_1403E9930() )
    return 0;
  else
    return *(unsigned int *)sub_1403E6C10(a1);
}

// --- End Function: sub_142D416A0 (0x142D416A0) ---

// --- Function: sub_142D4EDB0 (0x142D4EDB0) ---
__int64 __fastcall sub_142D4EDB0(__int64 a1, int a2)
{
  int v3; // [rsp+38h] [rbp+10h] BYREF

  v3 = a2;
  return sub_1403EC670(a1, &v3);
}

// --- End Function: sub_142D4EDB0 (0x142D4EDB0) ---

// --- Function: sub_142D5D920 (0x142D5D920) ---
__int64 __fastcall sub_142D5D920(__int64 _Cont, double *a2, int a3)
{
  unsigned __int64 v3; // rdi
  unsigned int v6; // ebx
  unsigned int v7; // eax
  __int64 v8; // r14
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  __int64 v11; // rax
  int **v12; // rax
  unsigned int v13; // r15d
  unsigned int v14; // ebx
  double *v15; // rax
  double v16; // xmm3_8
  double v17; // xmm4_8
  __int128 v18; // xmm3
  __int128 v20; // kr00_16
  unsigned int v22; // r15d
  __int64 v23; // rbx
  __int64 *v24; // rax
  unsigned int v25; // ebx
  _QWORD *v26; // rax
  __int64 v27; // rax
  int **v28; // rax
  unsigned int v29; // ebx
  _QWORD *v30; // rax
  __int64 v31; // rax
  int **v32; // rax
  _QWORD Parameter__2[2]; // [rsp+30h] [rbp-D0h] BYREF
  int n0x3500_1; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v36; // [rsp+44h] [rbp-BCh]
  int v37; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v38; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v39; // [rsp+58h] [rbp-A8h]
  __int64 v40; // [rsp+60h] [rbp-A0h]
  __int64 v41; // [rsp+68h] [rbp-98h]
  int n0x3500; // [rsp+90h] [rbp-70h] BYREF
  __int64 v43; // [rsp+94h] [rbp-6Ch]
  int v44; // [rsp+9Ch] [rbp-64h]
  unsigned __int64 v45; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v46; // [rsp+A8h] [rbp-58h]
  __int64 v47; // [rsp+B0h] [rbp-50h]
  __int64 v48; // [rsp+B8h] [rbp-48h]
  _QWORD v49[2]; // [rsp+E0h] [rbp-20h] BYREF
  _QWORD v50[2]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v51; // [rsp+100h] [rbp+0h] BYREF
  __int64 v52; // [rsp+110h] [rbp+10h] BYREF
  __int64 v53; // [rsp+120h] [rbp+20h] BYREF
  __int64 Parameter_; // [rsp+170h] [rbp+70h] BYREF
  double *v55; // [rsp+178h] [rbp+78h]
  char Parameter__1; // [rsp+188h] [rbp+88h] BYREF

  v55 = a2;
  v3 = 0;
  n0x3500 = 0x3500;
  v44 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v43 = 1;
  v45 = __rdtsc();
  qword_149C89AA0(
    &n0x3500,
    &word_149F51670,
    "CPooledResourceManager::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\PooledResourceManager.cpp",
    0x94);
  HIWORD(n0x3500) = word_149F51670;
  if ( *(_DWORD *)(_Cont + 0x88) )
  {
    v6 = std::size<std::vector<GSC::AI::GameGraph::indexed_polygon>>((const std::vector<GSC::AI::GameGraph::indexed_polygon> *)_Cont);
    if ( a3 <= 0 )
    {
      v7 = 0xFFFFFFFF;
      if ( a3 < 0 )
        v7 = 0;
      a3 = v7;
    }
    *(_DWORD *)(_Cont + 0x90) = a3;
    if ( *(_DWORD *)(_Cont + 0x88) > (unsigned int)a3 )
    {
      sub_142C64A50((Parameter *)(_Cont + 0x30));
      sub_142D70450(_Cont + 0x30, v6);
      v13 = sub_1404B90A0(_Cont + 0x48);
      v14 = 0;
      if ( v13 )
      {
        while ( sub_141C986E0((_QWORD *)(_Cont + 0x48), v14) )
        {
          if ( ++v14 >= v13 )
            goto LABEL_24;
        }
        while ( v14 != 0xFFFFFFFF )
        {
          v15 = (double *)sub_1403FC550((_QWORD *)_Cont, v14);
          HIDWORD(Parameter_) = v14;
          v16 = v55[1] - v15[1];
          v17 = v55[2] - v15[2];
          v18 = COERCE_UNSIGNED_INT64((*v55 - *v15) * (*v55 - *v15) + v16 * v16);
          *((_QWORD *)&v20 + 1) = *((_QWORD *)&v18 + 1);
          *(double *)&v20 = *(double *)&v18 + v17 * v17;
          _XMM2 = v20;
          __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
          *(float *)&Parameter_ = *(float *)&_XMM1;
          sub_142C672F0(_Cont + 0x30, (__int64)&Parameter_);
          ++v14;
          v22 = sub_1404B90A0(_Cont + 0x48);
          if ( v14 >= v22 )
            break;
          while ( sub_141C986E0((_QWORD *)(_Cont + 0x48), v14) )
          {
            if ( ++v14 >= v22 )
              goto LABEL_24;
          }
        }
      }
LABEL_24:
      v23 = *sub_1427D2930(_Cont + 0x30, (Parameter *)&Parameter_);
      v24 = sub_1427D28D0((_QWORD *)(_Cont + 0x30), (Parameter *)&Parameter__1);
      sub_142D272A0(*v24, v23);
      n0x3500_1 = 0x3500;
      v36 = 1;
      v37 = 0;
      v39 = 0;
      v40 = 0;
      v41 = 0;
      v38 = __rdtsc();
      qword_149C89AA0(
        &n0x3500_1,
        &word_149F51678,
        "CPooledResourceManager::Update:Invoke Callbacks",
        "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\PooledResourceManager.cpp",
        0xC4);
      HIWORD(n0x3500_1) = word_149F51678;
      sub_1427D28D0((_QWORD *)(_Cont + 0x30), (Parameter *)&Parameter_);
      sub_1427D2930(_Cont + 0x30, (Parameter *)Parameter__2);
      if ( a3 )
      {
        do
        {
          if ( std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                 &Parameter_,
                 Parameter__2) )
          {
            break;
          }
          v25 = *(_DWORD *)(Parameter_ + 4);
          v26 = sub_1406279E0((__int64 *)(_Cont + 0x68), v49, v25);
          if ( !sub_140627B40((__int64)v26) )
          {
            v27 = sub_142C0DBB0((_QWORD *)(_Cont + 0x18), v25);
            sub_140E51DA0(v27, 1);
            v28 = (int **)sub_1406279E0((__int64 *)(_Cont + 0x68), v50, v25);
            std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int>>>::operator=(v28, 1);
            ++*(_DWORD *)(_Cont + 0x8C);
          }
          sub_142AEB610(&Parameter_);
          LODWORD(v3) = v3 + 1;
        }
        while ( (unsigned int)v3 < a3 );
      }
      while ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                 &Parameter_,
                 Parameter__2) )
      {
        v29 = *(_DWORD *)(Parameter_ + 4);
        v30 = sub_1406279E0((__int64 *)(_Cont + 0x68), v50, v29);
        if ( sub_140627B40((__int64)v30) )
        {
          v31 = sub_142C0DBB0((_QWORD *)(_Cont + 0x18), v29);
          sub_140E51DA0(v31, 0);
          v32 = (int **)sub_1406279E0((__int64 *)(_Cont + 0x68), v49, v29);
          std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int>>>::operator=(v32, 0);
          --*(_DWORD *)(_Cont + 0x8C);
        }
        sub_142AEB610(&Parameter_);
      }
    }
    else
    {
      n0x3500_1 = 0x3500;
      v36 = 1;
      v37 = 0;
      v39 = 0;
      v40 = 0;
      v41 = 0;
      v38 = __rdtsc();
      qword_149C89AA0(
        &n0x3500_1,
        &word_149F51674,
        "CPooledResourceManager::Update:EnableAll",
        "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\PooledResourceManager.cpp",
        0xA4);
      HIWORD(n0x3500_1) = word_149F51674;
      if ( v6 )
      {
        v8 = v6;
        do
        {
          v9 = sub_1406279E0((__int64 *)(_Cont + 0x48), &v51, v3);
          if ( !sub_140627B40((__int64)v9) )
          {
            v10 = sub_1406279E0((__int64 *)(_Cont + 0x68), &v52, v3);
            if ( !sub_140627B40((__int64)v10) )
            {
              v11 = sub_142C0DBB0((_QWORD *)(_Cont + 0x18), v3);
              sub_140E51DA0(v11, 1);
              v12 = (int **)sub_1406279E0((__int64 *)(_Cont + 0x68), &v53, v3);
              std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int>>>::operator=(v12, 1);
              ++*(_DWORD *)(_Cont + 0x8C);
            }
          }
          ++v3;
          --v8;
        }
        while ( v8 );
      }
    }
    v39 = __rdtsc();
    qword_149C89AA8(&n0x3500_1);
  }
  v46 = __rdtsc();
  return qword_149C89AA8(&n0x3500);
}

// --- End Function: sub_142D5D920 (0x142D5D920) ---

// --- Function: sub_142D70450 (0x142D70450) ---
unsigned __int64 __fastcall sub_142D70450(__crt_strtox **a1, unsigned __int64 a2)
{
  __crt_strtox *v3; // rcx
  unsigned __int64 result; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // [rsp+28h] [rbp-20h] BYREF
  __int64 v8; // [rsp+30h] [rbp-18h] BYREF
  unsigned __int64 v9; // [rsp+38h] [rbp-10h]
  unsigned __int64 v11; // [rsp+58h] [rbp+10h] BYREF

  v11 = a2;
  v3 = *a1;
  result = (a1[2] - v3) >> 3;
  if ( a2 > result )
  {
    v7 = 0x1FFFFFFFFFFFFFFFLL;
    v8 = __crt_strtox::maximum_signed_value(v3);
    v9 = *unknown_libname_2(&v8, &v7);
    if ( v11 > v9 )
      unknown_libname_65(v6, v5);
    return sub_142D23290(a1, &v11);
  }
  return result;
}

// --- End Function: sub_142D70450 (0x142D70450) ---

// --- Function: sub_142DD9050 (0x142DD9050) ---
const ULONG_PTR *__fastcall sub_142DD9050(__int64 a1)
{
  __int64 v2; // rbx
  int v3; // edi
  unsigned int v4; // eax
  __int64 *v5; // r15
  __int64 v6; // rdx
  int v7; // ebp
  unsigned int v8; // eax
  __int64 v9; // rax
  int v10; // eax
  unsigned __int32 v11; // eax
  __int64 v12; // rdi
  __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // rdi
  __int64 v16; // rsi
  __int64 v17; // rcx
  int v18; // eax
  const ULONG_PTR *result; // rax

  v2 = a1 + 0x38;
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v3 )
  {
    ++*(_DWORD *)(v2 + 0x14);
  }
  else
  {
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 1, 0);
    if ( v4 )
      sub_1403C6E80(v2, v4, (__int64)&p_Src, 1);
    else
      *(_QWORD *)(v2 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v2 + 0x10) = v3;
  }
  v5 = *(__int64 **)(a1 + 0x30);
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x60) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x64);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x50), 1, 0);
    if ( v8 )
      sub_1403C6E80(a1 + 0x50, v8, (__int64)&p_Src, 1);
    else
      *(_QWORD *)(a1 + 0x58) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x60) = v7;
  }
  v9 = a1 + 0x18;
  if ( *(_QWORD *)(a1 + 0x30) != a1 )
    v9 = a1;
  *(_QWORD *)(a1 + 0x30) = v9;
  v10 = *(_DWORD *)(a1 + 0x64);
  if ( v10 )
  {
    *(_DWORD *)(a1 + 0x64) = v10 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x60) = 0xFFFFFFFF;
    v11 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x50), 0, 1);
    if ( v11 == 1 )
      *(_QWORD *)(a1 + 0x58) = &p_Src;
    else
      sub_1403DF590(a1 + 0x50, v11);
  }
  v12 = *v5;
  v13 = v5[1];
  if ( *v5 != v13 )
  {
    do
    {
      v14 = *(_QWORD *)(v12 + 0x38);
      if ( !v14 )
      {
        std::_Xbad_function_call();
        JUMPOUT(0x142DD91F9LL);
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x10LL))(v14);
      v12 += 0x40;
    }
    while ( v12 != v13 );
  }
  v15 = *v5;
  v16 = v5[1];
  if ( *v5 != v16 )
  {
    do
    {
      v17 = *(_QWORD *)(v15 + 0x38);
      if ( v17 )
      {
        LOBYTE(v6) = v17 != v15;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v17 + 0x20LL))(v17, v6);
        *(_QWORD *)(v15 + 0x38) = 0;
      }
      v15 += 0x40;
    }
    while ( v15 != v16 );
    v5[1] = *v5;
  }
  v18 = *(_DWORD *)(v2 + 0x14);
  if ( v18 )
  {
    result = (const ULONG_PTR *)(unsigned int)(v18 - 1);
    *(_DWORD *)(v2 + 0x14) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
    result = (const ULONG_PTR *)(unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v2, 0, 1);
    if ( (_DWORD)result == 1 )
      *(_QWORD *)(v2 + 8) = &p_Src;
    else
      return sub_1403DF590(v2, (unsigned int)result);
  }
  return result;
}

// --- End Function: sub_142DD9050 (0x142DD9050) ---

// --- Function: sub_142E61D20 (0x142E61D20) ---
_QWORD *__fastcall sub_142E61D20(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x450);
  return a2;
}

// --- End Function: sub_142E61D20 (0x142E61D20) ---

// --- Function: sub_142F2BE10 (0x142F2BE10) ---
_QWORD **__fastcall sub_142F2BE10(_QWORD **a1)
{
  *a1 = (_QWORD *)**a1;
  return a1;
}

// --- End Function: sub_142F2BE10 (0x142F2BE10) ---

// --- Function: sub_142F4DB80 (0x142F4DB80) ---
__m128 __fastcall sub_142F4DB80(__int64 a1)
{
  float v1; // xmm1_4
  __int128 v2; // xmm0
  __int128 v4; // kr00_16
  float v5; // xmm2_4
  __int128 n0x3F800000; // xmm1
  __int128 v9; // kr00_16
  __int128 v11; // kr00_16

  v1 = *(float *)(a1 + 0xC);
  if ( v1 <= 0.000099999997 )
  {
    v5 = 1.0;
  }
  else
  {
    v2 = *(unsigned int *)(a1 + 0x10);
    v4 = v2;
    *(float *)&v4 = *(float *)&v2 / v1;
    _XMM3 = v4;
    v5 = 0.0;
    if ( (float)(*(float *)&v2 / v1) >= 0.0 )
    {
      n0x3F800000 = 0x3F800000u;
      __asm
      {
        vcmpltss xmm0, xmm3, xmm1
        vblendvps xmm2, xmm1, xmm3, xmm0
      }
      v9 = *(unsigned int *)(a1 + 8);
      *(float *)&v9 = (float)((float)(*(float *)(a1 + 8) - *(float *)(a1 + 4)) * *(float *)&_XMM2) + *(float *)(a1 + 4);
      return (__m128)v9;
    }
  }
  v11 = *(unsigned int *)(a1 + 8);
  *(float *)&v11 = (float)((float)(*(float *)(a1 + 8) - *(float *)(a1 + 4)) * v5) + *(float *)(a1 + 4);
  return (__m128)v11;
}

// --- End Function: sub_142F4DB80 (0x142F4DB80) ---

// --- Function: sub_142F56150 (0x142F56150) ---
unsigned __int8 *__fastcall sub_142F56150(int a1, char a2, char a3, char a4)
{
  int v7; // esi
  int v8; // ebp
  int v9; // ebx
  int v10; // r15d
  int v11; // ebx
  const char *v12; // rax
  int v13; // r8d
  const char *p__; // r14
  const char *v15; // rdi
  const char *p_p_Src; // rbx
  const char *v17; // rax
  const char *v18; // rdi
  const char *p_p_Src_1; // rbx
  const char *v20; // rax
  int v21; // edi
  const char *v22; // rbx
  const char *p_@ui_mp_sec; // rcx
  const char *v24; // rax
  const char *v25; // rdi
  const char *p_p_Src_2; // rbx
  const char *v27; // rax
  const char *v28; // rdi
  const char *p_p_Src_3; // rbx
  const char *v30; // rax
  const char *v31; // rax
  int v33; // [rsp+70h] [rbp+8h]

  v7 = a1 / 0x15180;
  v8 = a1 % 0x15180 / 0xE10;
  v9 = a1 % 0x15180 % 0xE10;
  v10 = v9 / 0x3C;
  v11 = v9 % 0x3C;
  v33 = v11;
  if ( (dword_149F56F78 & 1) == 0 )
  {
    dword_149F56F78 |= 1u;
    sub_1405CCFD0((__int64)qword_149F56F20);
    atexit(sub_148246A10);
  }
  sub_142F94590(qword_149F56F20);
  if ( a2 )
  {
    if ( a3 )
    {
      if ( v7 <= 0 )
      {
        if ( v8 <= 0 )
          sub_1405D40E0((__int64)qword_149F56F20, "%.2d:%.2d", v10, v11);
        else
          sub_1405D40E0((__int64)qword_149F56F20, "%.2d:%.2d:%.2d", v8, v10, v11);
      }
      else
      {
        sub_1405D40E0((__int64)qword_149F56F20, "%.2d:%.2d:%.2d:%.2d", v7, v8, v10, v11);
      }
    }
    else if ( v7 <= 0 )
    {
      sub_1405D40E0((__int64)qword_149F56F20, "%.2d:%.2d", v8, v10);
    }
    else
    {
      sub_1405D40E0((__int64)qword_149F56F20, "%.2d:%.2d:%.2d", v7, v8, v10);
    }
    return AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
  }
  if ( !a4 )
  {
    if ( v7 == 1 )
    {
      v12 = (const char *)sub_142F5EDC0((unsigned int)"@ui_day", 0, 0, 0, 0);
      v13 = 1;
    }
    else
    {
      if ( v7 <= 1 )
        goto LABEL_19;
      v12 = (const char *)sub_142F5EDC0((unsigned int)"@ui_days", 0, 0, 0, 0);
      v13 = v7;
    }
    sub_1405D40E0((__int64)qword_149F56F20, "%d %s", v13, v12);
LABEL_19:
    p__ = " ";
    if ( v8 == 1 )
    {
      v15 = (const char *)sub_142F5EDC0((unsigned int)"@ui_hr", 0, 0, 0, 0);
      p_p_Src = " ";
      if ( unknown_libname_18(qword_149F56F20) )
        p_p_Src = (const char *)&p_Src;
    }
    else
    {
      if ( v8 <= 1 && v7 <= 0 )
      {
LABEL_27:
        if ( v10 == 1 )
        {
          v18 = (const char *)sub_142F5EDC0((unsigned int)"@ui_min", 0, 0, 0, 0);
          p_p_Src_1 = " ";
          if ( unknown_libname_18(qword_149F56F20) )
            p_p_Src_1 = (const char *)&p_Src;
        }
        else
        {
          if ( v10 <= 1 && v8 <= 0 && v7 <= 0 )
            goto LABEL_36;
          v18 = (const char *)sub_142F5EDC0((unsigned int)"@ui_mins", 0, 0, 0, 0);
          p_p_Src_1 = " ";
          if ( unknown_libname_18(qword_149F56F20) )
            p_p_Src_1 = (const char *)&p_Src;
        }
        v20 = (const char *)AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
        sub_1405D40E0((__int64)qword_149F56F20, "%s%s%d %s", v20, p_p_Src_1, v10, v18);
LABEL_36:
        if ( !a3 )
          return AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
        v21 = v33;
        if ( v33 == 1 )
        {
          v22 = (const char *)sub_142F5EDC0((unsigned int)"@ui_sec", 0, 0, 0, 0);
          if ( unknown_libname_18(qword_149F56F20) )
            p__ = (const char *)&p_Src;
LABEL_62:
          v31 = (const char *)AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
          sub_1405D40E0((__int64)qword_149F56F20, "%s%s%d %s", v31, p__, v21, v22);
          return AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
        }
        p_@ui_mp_sec = "@ui_secs";
LABEL_60:
        v22 = (const char *)sub_142F5EDC0((_DWORD)p_@ui_mp_sec, 0, 0, 0, 0);
        if ( unknown_libname_18(qword_149F56F20) )
          p__ = (const char *)&p_Src;
        goto LABEL_62;
      }
      v15 = (const char *)sub_142F5EDC0((unsigned int)"@ui_hrs", 0, 0, 0, 0);
      p_p_Src = " ";
      if ( unknown_libname_18(qword_149F56F20) )
        p_p_Src = (const char *)&p_Src;
    }
    v17 = (const char *)AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
    sub_1405D40E0((__int64)qword_149F56F20, "%s%s%d %s", v17, p_p_Src, v8, v15);
    goto LABEL_27;
  }
  if ( v7 > 0 )
  {
    v24 = (const char *)sub_142F5EDC0((unsigned int)"@ui_mp_days", 0, 0, 0, 0);
    sub_1405D40E0((__int64)qword_149F56F20, "%d %s", v7, v24);
  }
  p__ = " ";
  if ( v8 > 0 || v7 > 0 )
  {
    v25 = (const char *)sub_142F5EDC0((unsigned int)"@ui_mp_hrs", 0, 0, 0, 0);
    p_p_Src_2 = " ";
    if ( unknown_libname_18(qword_149F56F20) )
      p_p_Src_2 = (const char *)&p_Src;
    v27 = (const char *)AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
    sub_1405D40E0((__int64)qword_149F56F20, "%s%s%d %s", v27, p_p_Src_2, v8, v25);
  }
  if ( v10 > 0 || v8 > 0 || v7 > 0 )
  {
    v28 = (const char *)sub_142F5EDC0((unsigned int)"@ui_mp_mins", 0, 0, 0, 0);
    p_p_Src_3 = " ";
    if ( unknown_libname_18(qword_149F56F20) )
      p_p_Src_3 = (const char *)&p_Src;
    v30 = (const char *)AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
    sub_1405D40E0((__int64)qword_149F56F20, "%s%s%d %s", v30, p_p_Src_3, v10, v28);
  }
  if ( a3 )
  {
    v21 = v33;
    if ( v33 > 0 || !v8 && !v7 && !v10 )
    {
      p_@ui_mp_sec = "@ui_mp_sec";
      goto LABEL_60;
    }
  }
  return AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)qword_149F56F20);
}

// --- End Function: sub_142F56150 (0x142F56150) ---

// --- Function: sub_142F566B0 (0x142F566B0) ---
// local variable allocation has failed, the output may be wrong!
unsigned __int8 *__fastcall sub_142F566B0(double _XMM0_8, char a2, char a3, char a4)
{
  __int128 v5; // kr00_16

  v5 = *(_OWORD *)&_XMM0_8;
  *(float *)&v5 = *(float *)&_XMM0_8 + 0.5;
  _XMM4 = v5;
  __asm
  {
    vcmpltss xmm0, xmm0, xmm2
    vblendvps xmm1, xmm4, xmm3, xmm0
  }
  return sub_142F56150((int)*(float *)&_XMM1, a2, a3, a4);
}

// --- End Function: sub_142F566B0 (0x142F566B0) ---

// --- Function: sub_142F5EDC0 (0x142F5EDC0) ---
__int64 __fastcall sub_142F5EDC0(int a1, int a2, int a3, __int64 a4, __int64 a5)
{
  __int64 v9; // r8
  __int64 v10; // rbx
  __int64 v12[3]; // [rsp+30h] [rbp-18h] BYREF

  sub_14035E2A0(v12);
  sub_142F5EE80((unsigned int)v12, a1, a2, a3, a4, a5);
  if ( (dword_149F58E98 & 1) == 0 )
  {
    dword_149F58E98 |= 1u;
    sub_14035E090(&qword_149F58E90);
    atexit(sub_148246980);
  }
  sub_14052EDB0(v12[0], (__int64)&qword_149F58E90, v9);
  v10 = qword_149F58E90;
  sub_140373CC0(v12);
  return v10;
}

// --- End Function: sub_142F5EDC0 (0x142F5EDC0) ---

// --- Function: sub_142F5EE80 (0x142F5EE80) ---
void __fastcall sub_142F5EE80(
        void **a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int8 *a4,
        unsigned __int8 *a5,
        unsigned __int8 *a6)
{
  _QWORD *v10; // rax
  __int64 v11; // rax
  _QWORD *v12; // rax
  __int64 v13; // rax
  _QWORD *v14; // rax
  __int64 v15; // rax
  _QWORD *v16; // rax
  __int64 v17; // rax
  _QWORD *v18; // rax
  __int64 v19; // rax
  __int64 v20; // [rsp+20h] [rbp-30h] BYREF
  __int64 v21; // [rsp+28h] [rbp-28h] BYREF
  __int64 v22; // [rsp+30h] [rbp-20h] BYREF
  __int64 v23; // [rsp+38h] [rbp-18h] BYREF
  unsigned __int8 *v24; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 *v25; // [rsp+48h] [rbp-8h] BYREF
  __int64 v26; // [rsp+78h] [rbp+28h] BYREF

  if ( a2 )
  {
    sub_14035E2A0(&v23);
    sub_14035E2A0(&v22);
    sub_14035E2A0(&v21);
    sub_14035E2A0(&v20);
    sub_14035E2A0(&v26);
    if ( *a2 == 0x40 )
    {
      v24 = a2;
      v10 = sub_140361D70(&v25, &v24);
      v11 = sub_1402A4EC0((__int64)v10);
      sub_14037B000(&v23, v11);
      sub_140373CC0(&v25);
    }
    else
    {
      sub_142F7B590(a2, &v23);
    }
    if ( a3 )
    {
      if ( *a3 == 0x40 )
      {
        v25 = a3;
        v12 = sub_140361D70(&v24, &v25);
        v13 = sub_1402A4EC0((__int64)v12);
        sub_14037B000(&v22, v13);
        sub_140373CC0(&v24);
      }
      else
      {
        sub_142F7B590(a3, &v22);
      }
    }
    if ( a4 )
    {
      if ( *a4 == 0x40 )
      {
        v25 = a4;
        v14 = sub_140361D70(&v24, &v25);
        v15 = sub_1402A4EC0((__int64)v14);
        sub_14037B000(&v21, v15);
        sub_140373CC0(&v24);
      }
      else
      {
        sub_142F7B590(a4, &v21);
      }
    }
    if ( a5 )
    {
      if ( *a5 == 0x40 )
      {
        v25 = a5;
        v16 = sub_140361D70(&v24, &v25);
        v17 = sub_1402A4EC0((__int64)v16);
        sub_14037B000(&v20, v17);
        sub_140373CC0(&v24);
      }
      else
      {
        sub_142F7B590(a5, &v20);
      }
    }
    if ( a6 )
    {
      if ( *a6 == 0x40 )
      {
        v25 = a6;
        v18 = sub_140361D70(&v24, &v25);
        v19 = sub_1402A4EC0((__int64)v18);
        sub_14037B000(&v26, v19);
        sub_140373CC0(&v24);
      }
      else
      {
        sub_142F7B590(a6, &v26);
      }
    }
    sub_1403EDB70(a1, 0, 0x20u);
    sub_140387CF0(a1, &v22);
    sub_140387CF0(a1, &v21);
    sub_140387CF0(a1, &v20);
    sub_140387CF0(a1, &v26);
    sub_140373CC0(&v26);
    sub_140373CC0(&v20);
    sub_140373CC0(&v21);
    sub_140373CC0(&v22);
    sub_140373CC0(&v23);
  }
  else
  {
    sub_14037B000(a1, &word_1482C9800);
  }
}

// --- End Function: sub_142F5EE80 (0x142F5EE80) ---

// --- Function: sub_142F77640 (0x142F778AE) ---
void __fastcall __noreturn sub_142F77640(__int64 a1, _BYTE *a2)
{
  const char *p_exec_autoexec_server.cfg; // rdx
  __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rsi
  void (__fastcall *v12)(__int64, __int64); // rdi
  __int64 v13; // rax
  __int64 v14; // rsi
  void (__fastcall *v15)(__int64, unsigned __int8 *, _QWORD, _QWORD, _QWORD); // rdi
  unsigned __int8 *v16; // rax
  __int64 v17; // rax
  void *v18[2]; // [rsp+30h] [rbp-158h] BYREF
  _BYTE v19[288]; // [rsp+40h] [rbp-148h] BYREF

  if ( *(_DWORD *)(n29 + 0x1574) )
  {
LABEL_10:
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x210LL))(qword_149C8DFE0);
    v9 = (*(__int64 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v8 + 0x20LL))(v8, 2, "exec_on_demand");
    if ( v9 )
    {
      v11 = qword_149C8DFD0;
      v12 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DFD0 + 0x148LL);
      v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x10LL))(v9);
      v12(v11, v13);
    }
    if ( a2 )
    {
      sub_1405CCF40((__int64)v19, "map ");
      sub_1405CF3F0((__int64)v19, a2);
      v14 = qword_149C8DFD0;
      v15 = *(void (__fastcall **)(__int64, unsigned __int8 *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149C8DFD0
                                                                                      + 0x130LL);
      v16 = AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)v19);
      v15(v14, v16, 0, 0, 0);
      sub_1405CEDF0((__int64)v19);
    }
    if ( !qword_149C8E0F8 || !qword_149C8DFE0 || !(_WORD)qword_149C8E516 )
    {
      ShowCursor(1);
      if ( qword_149C8E0F8 )
      {
        if ( qword_149C8DFE0
          && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x1D8LL))(qword_149C8DFE0) )
        {
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E028 + 0xB8LL))(qword_149C8E028) )
            LogTraceConditional("HM:==> Hardware mouse reference counter decreased in CGameStartup::Run");
          v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x1D8LL))(qword_149C8DFE0);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x40LL))(v17);
        }
      }
    }
    while ( 1 )
    {
      LOBYTE(v10) = 1;
      (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 0x18LL))(a1, v10, 0);
    }
  }
  if ( (_BYTE)qword_149C8E516 )
  {
    if ( !BYTE1(qword_149C8E516) )
      goto LABEL_10;
  }
  else if ( !BYTE1(qword_149C8E516) )
  {
    p_exec_autoexec_server.cfg = "exec autoexec.cfg";
LABEL_9:
    (*(void (__fastcall **)(__int64, const char *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149C8DFD0 + 0x130LL))(
      qword_149C8DFD0,
      p_exec_autoexec_server.cfg,
      0,
      0,
      0);
    goto LABEL_10;
  }
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x210LL))(qword_149C8DFE0);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v5 + 0x20LL))(v5, 2, "map");
  if ( v6 )
  {
    CreateStringObjectFromString(v18, "map ");
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x10LL))(v6);
    sub_140387CB0((__int64)v18, v7);
    LogTraceConditional("[CIG] Commandline: +%s", (const char *)v18[0]);
    (*(void (__fastcall **)(__int64, void *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149C8DFD0 + 0x130LL))(
      qword_149C8DFD0,
      v18[0],
      0,
      0,
      0);
    sub_140373CC0(v18);
    goto LABEL_10;
  }
  p_exec_autoexec_server.cfg = "exec autoexec-server.cfg";
  goto LABEL_9;
}

// --- End Function: sub_142F77640 (0x142F778AE) ---

// --- Function: sub_142F7FF80 (0x142F7FF80) ---
const ULONG_PTR *__fastcall sub_142F7FF80(__int64 a1)
{
  __int128 v1; // xmm6
  int v3; // edi
  unsigned int v4; // eax
  _QWORD *v5; // rcx
  int v6; // eax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int32 v8; // eax
  __int64 v9; // [rsp+30h] [rbp-78h] BYREF
  _QWORD *v10; // [rsp+38h] [rbp-70h]
  int n0x3500; // [rsp+40h] [rbp-68h] BYREF
  __int64 v12; // [rsp+44h] [rbp-64h]
  int v13; // [rsp+4Ch] [rbp-5Ch]
  unsigned __int64 v14; // [rsp+50h] [rbp-58h]
  unsigned __int64 v15; // [rsp+58h] [rbp-50h]
  __int64 v16; // [rsp+60h] [rbp-48h]
  __int64 v17; // [rsp+68h] [rbp-40h]
  __int128 v18; // [rsp+90h] [rbp-18h]

  v18 = v1;
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x18) == v3 )
  {
    ++*(_DWORD *)(a1 + 0x1C);
  }
  else
  {
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 8), 1, 0);
    if ( v4 )
      sub_1403C6E80(a1 + 8, v4, (__int64)"CGameMechanismManager::Update", 1);
    else
      *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x18) = v3;
  }
  n0x3500 = 0x3500;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v12 = 1;
  v14 = __rdtsc();
  qword_149C89AA0(
    &n0x3500,
    &word_149F56F18,
    "CGameMechanismManager::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\GameMechanismManager/GameMechanismManager.cpp",
    0x98);
  v5 = *(_QWORD **)a1;
  HIWORD(n0x3500) = word_149F56F18;
  v9 = qword_149F564A0;
  qword_149F564A0 = (__int64)&v9;
  v10 = v5;
  while ( v5 )
  {
    v10 = (_QWORD *)v5[1];
    (*(void (__fastcall **)(_QWORD *))(*v5 + 8LL))(v5);
    v5 = v10;
  }
  qword_149F564A0 = v9;
  v15 = __rdtsc();
  qword_149C89AA8(&n0x3500);
  v6 = *(_DWORD *)(a1 + 0x1C);
  if ( v6 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v6 - 1);
    *(_DWORD *)(a1 + 0x1C) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFF;
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 8), 0, 1);
    if ( v8 == 1 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(a1 + 0x10) = &p_Src;
    }
    else
    {
      return sub_1403DF590(a1 + 8, v8);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_142F7FF80 (0x142F7FF80) ---

// --- Function: sub_142F82000 (0x142F82000) ---
__int64 __fastcall sub_142F82000(__int64 a1, float a2)
{
  __int64 result; // rax
  bool v4; // zf
  float v5; // kr00_4

  result = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
             qword_149C8DFD0,
             "r_StereoMode");
  if ( result )
  {
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)result + 0x10LL))(result);
    if ( (_DWORD)result )
    {
      if ( *(_BYTE *)(a1 + 0x29) )
      {
        v4 = *(_BYTE *)(a1 + 0x2B) == 0;
        v5 = a2 + *(float *)(a1 + 0x10);
        *(float *)(a1 + 0x10) = v5;
        if ( !v4 && v5 > *(float *)(a1 + 0xC) )
          *(_BYTE *)(a1 + 0x29) = 0;
      }
    }
  }
  return result;
}

// --- End Function: sub_142F82000 (0x142F82000) ---

// --- Function: sub_142F94590 (0x142F94590) ---
__int64 __fastcall sub_142F94590(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( *a1 )
  {
    sub_1405026C0(a1);
    return 0;
  }
  return result;
}

// --- End Function: sub_142F94590 (0x142F94590) ---

// --- Function: sub_142FB5CB0 (0x142FB5CB0) ---
unsigned __int64 __fastcall sub_142FB5CB0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  __int64 v4; // rbp
  __int64 v5; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r12
  unsigned __int64 allocSize_1; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rbx
  __int64 v17; // rdx
  __int64 v18; // rcx

  v3 = a2 - *a1;
  v4 = 0x3FFFFFFFFFFFFFFLL;
  v5 = (a1[1] - *a1) >> 6;
  if ( v5 == 0x3FFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (a1[2] - *a1) >> 6;
  v10 = v9 >> 1;
  v11 = v5 + 1;
  if ( v9 <= 0x3FFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    v13 = v5 + 1;
    if ( v10 + v9 >= v11 )
      v13 = v10 + v9;
    if ( v13 > 0x3FFFFFFFFFFFFFFLL )
      goto LABEL_20;
    v4 = v13;
    allocSize = v13 << 6;
    if ( v13 << 6 < 0x1000 )
    {
      if ( allocSize )
        v16 = sub_1402A65A0(allocSize);
      else
        v16 = 0;
      goto LABEL_15;
    }
    allocSize_1 = allocSize + 0x27;
    if ( allocSize + 0x27 < allocSize )
LABEL_20:
      sub_1402E3880();
  }
  else
  {
    allocSize_1 = 0xFFFFFFFFFFFFFFE7uLL;
  }
  v15 = sub_1402A65A0(allocSize_1);
  if ( !v15 )
    invalid_parameter_noinfo_noreturn();
  v16 = (v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v16 - 8) = v15;
LABEL_15:
  sub_142FC3770(a1, (v3 & 0xFFFFFFFFFFFFFFC0uLL) + v16, a3);
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    sub_142FC0410(v18, v17, v16, a1);
  }
  else
  {
    sub_142FC0B70(v18, a2, v16, a1);
    sub_142FC0B70(a2, a1[1], (v3 & 0xFFFFFFFFFFFFFFC0uLL) + v16 + 0x40, a1);
  }
  sub_1430705E0(a1, v16, v11, v4);
  return (v3 & 0xFFFFFFFFFFFFFFC0uLL) + v16;
}

// --- End Function: sub_142FB5CB0 (0x142FB5CB0) ---

// --- Function: sub_142FC0410 (0x142FC0410) ---
__int64 __fastcall sub_142FC0410(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v5; // rbx
  __int64 v6; // rdi

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = a1 + 0x18;
    v6 = a3 - a1;
    do
    {
      sub_14036DFF0(v3, v5 - 0x18);
      sub_14035DE10((void **)(v5 + v6 - 8), (const void **)(v5 - 8));
      v3 += 0x40;
      *(_DWORD *)(v5 + v6) = *(_DWORD *)v5;
      *(_DWORD *)(v6 + v5 + 4) = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v6 + v5 + 8) = *(_DWORD *)(v5 + 8);
      *(_QWORD *)(v6 + v5 + 0x10) = *(_QWORD *)(v5 + 0x10);
      *(_DWORD *)(v6 + v5 + 0x18) = *(_DWORD *)(v5 + 0x18);
      *(_BYTE *)(v6 + v5 + 0x1C) = *(_BYTE *)(v5 + 0x1C);
      *(_DWORD *)(v6 + v5 + 0x20) = *(_DWORD *)(v5 + 0x20);
      v5 += 0x40;
    }
    while ( v5 - 0x18 != a2 );
  }
  return v3;
}

// --- End Function: sub_142FC0410 (0x142FC0410) ---

// --- Function: sub_142FC0B70 (0x142FC0B70) ---
__int64 __fastcall sub_142FC0B70(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v5; // rbx
  __int64 v6; // rdi

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = a1 + 0x18;
    v6 = a3 - a1;
    do
    {
      sub_14036DFF0(v3, v5 - 0x18);
      sub_14035DDF0((_QWORD *)(v5 + v6 - 8), (__int64 *)(v5 - 8));
      v3 += 0x40;
      *(_DWORD *)(v5 + v6) = *(_DWORD *)v5;
      *(_DWORD *)(v6 + v5 + 4) = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v6 + v5 + 8) = *(_DWORD *)(v5 + 8);
      *(_QWORD *)(v6 + v5 + 0x10) = *(_QWORD *)(v5 + 0x10);
      *(_DWORD *)(v6 + v5 + 0x18) = *(_DWORD *)(v5 + 0x18);
      *(_BYTE *)(v6 + v5 + 0x1C) = *(_BYTE *)(v5 + 0x1C);
      *(_DWORD *)(v6 + v5 + 0x20) = *(_DWORD *)(v5 + 0x20);
      v5 += 0x40;
    }
    while ( v5 - 0x18 != a2 );
  }
  return v3;
}

// --- End Function: sub_142FC0B70 (0x142FC0B70) ---

// --- Function: sub_142FC3770 (0x142FC3770) ---
__int64 __fastcall sub_142FC3770(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  sub_14036DFF0(a2, a3);
  sub_14035DE10((void **)(a2 + 0x10), (const void **)(a3 + 0x10));
  *(_DWORD *)(a2 + 0x18) = *(_DWORD *)(a3 + 0x18);
  *(_DWORD *)(a2 + 0x1C) = *(_DWORD *)(a3 + 0x1C);
  *(_DWORD *)(a2 + 0x20) = *(_DWORD *)(a3 + 0x20);
  *(_QWORD *)(a2 + 0x28) = *(_QWORD *)(a3 + 0x28);
  *(_DWORD *)(a2 + 0x30) = *(_DWORD *)(a3 + 0x30);
  *(_BYTE *)(a2 + 0x34) = *(_BYTE *)(a3 + 0x34);
  result = *(unsigned int *)(a3 + 0x38);
  *(_DWORD *)(a2 + 0x38) = result;
  return result;
}

// --- End Function: sub_142FC3770 (0x142FC3770) ---

// --- Function: sub_142FC53C0 (0x142FC53C0) ---
_QWORD *__fastcall sub_142FC53C0(_QWORD *a1, _QWORD *a2)
{
  *a1 = 0;
  a1[1] = 0;
  *a1 = *a2;
  a1[2] = a2[2];
  return a1;
}

// --- End Function: sub_142FC53C0 (0x142FC53C0) ---

// --- Function: sub_14302F450 (0x14302F450) ---
void __fastcall sub_14302F450(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v3; // r14
  __int64 v4; // r15
  __int64 v5; // r12
  unsigned __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // r15
  const void **v9; // r14
  __int64 v10; // rax
  void (__fastcall ***v11)(_QWORD); // rdx
  const void *v12; // rbx
  int v13; // edi
  float v14; // xmm6_4
  __int64 v15; // rax
  __int64 v16; // rbx
  _QWORD *v17; // rbx
  _QWORD *v18; // rdi
  __int64 v19; // [rsp+20h] [rbp-49h] BYREF
  _QWORD v20[2]; // [rsp+30h] [rbp-39h] BYREF
  void *v21; // [rsp+40h] [rbp-29h] BYREF
  float v22; // [rsp+48h] [rbp-21h]
  float v23; // [rsp+4Ch] [rbp-1Dh]
  float v24; // [rsp+50h] [rbp-19h]
  const void *v25; // [rsp+58h] [rbp-11h]
  int v26; // [rsp+60h] [rbp-9h]
  char v27; // [rsp+64h] [rbp-5h]
  int v28; // [rsp+68h] [rbp-1h]
  void (__fastcall ***v29)(_QWORD); // [rsp+D0h] [rbp+67h] BYREF

  v1 = 0;
  v3 = (__int64)(a1[2] - a1[1]) >> 5;
  v4 = (__int64)(a1[5] - a1[4]) >> 6;
  v5 = (unsigned int)v3;
  v6 = v4 + (unsigned int)v3;
  if ( v6 > (__int64)(a1[6] - a1[4]) >> 6 )
  {
    if ( v6 > 0x3FFFFFFFFFFFFFFLL )
      unknown_libname_10();
    if ( v6 << 6 < 0x1000 )
    {
      if ( v6 << 6 )
        v1 = sub_1402A65A0(v6 << 6);
    }
    else
    {
      if ( (v6 << 6) + 0x27 < v6 << 6 )
        sub_1402E3880();
      v7 = sub_1402A65A0((v6 << 6) + 0x27);
      if ( !v7 )
        invalid_parameter_noinfo_noreturn();
      v1 = (v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v1 - 8) = v7;
    }
    sub_142FC0410(a1[4], a1[5], v1);
    sub_1430705E0(a1 + 4, v1, v4, v4 + (unsigned int)v3);
  }
  if ( (_DWORD)v3 )
  {
    v8 = 0;
    do
    {
      v9 = (const void **)(v8 + a1[1]);
      v10 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x598LL))(qword_149C8E018);
      (*(void (__fastcall **)(__int64, void (__fastcall ****)(_QWORD), const void *))(*(_QWORD *)v10 + 8LL))(
        v10,
        &v29,
        *v9);
      v11 = v29;
      if ( !v29 )
      {
        sub_1405C6220(0x12u, 0, "Failed to load color grading chart: %s", (const char *)*v9);
        v11 = v29;
      }
      v12 = v9[2];
      v13 = *((_DWORD *)v9 + 6);
      v14 = *((float *)v9 + 2);
      v15 = sub_14036E030((__int64)&v19, v11, 1.0);
      sub_14036DFF0((__int64)v20, v15);
      sub_14035DE10(&v21, v9);
      v25 = v12;
      v26 = v13;
      v27 = 0;
      v28 = 0;
      v22 = v14;
      v23 = 0.0;
      v24 = 1.0;
      if ( v19 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 8LL))(v19);
      v19 = 0;
      if ( v29 )
        (*v29)[1](v29);
      v29 = 0;
      if ( v20[0] )
      {
        v16 = a1[5];
        if ( v16 == a1[6] )
        {
          sub_142FB5CB0(a1 + 4, a1[5], (__int64)v20);
        }
        else
        {
          sub_14036DFF0(a1[5], (__int64)v20);
          sub_14035DE10((void **)(v16 + 0x10), (const void **)&v21);
          *(float *)(v16 + 0x18) = v22;
          *(float *)(v16 + 0x1C) = v23;
          *(float *)(v16 + 0x20) = v24;
          *(_QWORD *)(v16 + 0x28) = v25;
          *(_DWORD *)(v16 + 0x30) = v26;
          *(_BYTE *)(v16 + 0x34) = v27;
          *(_DWORD *)(v16 + 0x38) = v28;
          a1[5] += 0x40LL;
        }
      }
      sub_140373CC0(&v21);
      if ( v20[0] )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v20[0] + 8LL))(v20[0]);
      v8 += 0x20;
      --v5;
    }
    while ( v5 );
  }
  v17 = (_QWORD *)a1[1];
  v18 = (_QWORD *)a1[2];
  if ( v17 != v18 )
  {
    do
    {
      sub_140373CC0(v17);
      v17 += 4;
    }
    while ( v17 != v18 );
    a1[2] = a1[1];
  }
}

// --- End Function: sub_14302F450 (0x14302F450) ---

// --- Function: sub_14305EBB0 (0x14305EBB0) ---
__int64 __fastcall sub_14305EBB0(__int64 a1)
{
  unsigned __int64 v1; // rdx
  unsigned __int64 allocSize_1; // r13
  __int64 v3; // rdi
  unsigned __int64 allocSize; // r12
  __int64 v5; // rax
  _QWORD *v6; // r14
  _QWORD *v7; // rbx
  __int64 v8; // rsi
  __int64 v9; // r15
  unsigned int allocSize_2; // eax
  __int64 v11; // rbx
  __int64 v12; // r12
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // r13
  __int64 v17; // r12
  _QWORD *v18; // rsi
  _QWORD *v19; // rbx
  __int64 v20; // rdi
  __int64 v21; // r14
  __int64 v22; // rbx
  __int64 v23; // rdi
  __int64 v24; // rax
  __int64 result; // rax
  _QWORD *v26; // rbx
  _QWORD *v27; // rdi
  __int128 v28; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 v29; // [rsp+30h] [rbp-18h]
  __int64 v30; // [rsp+90h] [rbp+48h]
  unsigned int allocSize_4; // [rsp+98h] [rbp+50h]
  __int64 v32; // [rsp+A0h] [rbp+58h]
  int allocSize_3; // [rsp+A8h] [rbp+60h]

  v30 = a1;
  v1 = 0;
  allocSize_1 = (__int64)(*(_QWORD *)(a1 + 0x28) - *(_QWORD *)(a1 + 0x20)) >> 6;
  v3 = 0;
  v29 = 0;
  allocSize_3 = allocSize_1;
  v28 = 0;
  if ( (_DWORD)allocSize_1 )
  {
    allocSize = 0x10LL * (unsigned int)allocSize_1;
    v5 = sub_140394E70((__int64)&v28, allocSize);
    v6 = (_QWORD *)*((_QWORD *)&v28 + 1);
    v3 = v5;
    v7 = (_QWORD *)v28;
    v8 = v5;
    if ( (_QWORD)v28 != *((_QWORD *)&v28 + 1) )
    {
      do
      {
        sub_14036DFF0(v8, (__int64)v7);
        v8 += 0x10;
        v7 += 2;
      }
      while ( v7 != v6 );
      v6 = (_QWORD *)*((_QWORD *)&v28 + 1);
      v7 = (_QWORD *)v28;
    }
    if ( v7 )
    {
      if ( v7 != v6 )
      {
        do
        {
          if ( *v7 )
            (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v7 + 8LL))(*v7);
          *v7 = 0;
          v7 += 2;
        }
        while ( v7 != v6 );
        v7 = (_QWORD *)v28;
      }
      sub_1403A6820((__int64)&v28, (unsigned __int64)v7, (v29 - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF0uLL);
    }
    a1 = v30;
    v1 = allocSize + v3;
    v29 = allocSize + v3;
    v9 = v3;
    *(_QWORD *)&v28 = v3;
    *((_QWORD *)&v28 + 1) = v3;
  }
  else
  {
    v9 = v28;
  }
  allocSize_2 = 0;
  for ( allocSize_4 = 0; allocSize_2 < (unsigned int)allocSize_1; allocSize_4 = allocSize_2 )
  {
    v11 = *(_QWORD *)(a1 + 0x20) + ((unsigned __int64)allocSize_2 << 6);
    if ( v3 == v1 )
    {
      v12 = (v3 - v9) >> 4;
      if ( v12 == 0xFFFFFFFFFFFFFFFLL )
        unknown_libname_10();
      v13 = v12 + 1;
      v14 = (__int64)(v1 - v9) >> 4;
      v32 = v12 + 1;
      v15 = v14 >> 1;
      if ( v14 <= 0xFFFFFFFFFFFFFFFLL - (v14 >> 1) )
      {
        v16 = v15 + v14;
        if ( v15 + v14 < v13 )
          v16 = v12 + 1;
      }
      else
      {
        v16 = 0xFFFFFFFFFFFFFFFLL;
      }
      allocSize_1 = 0x10 * v16;
      v17 = 0x10 * v12;
      v9 = sub_140394E70((__int64)&v28, allocSize_1);
      sub_14036DFF0(v17 + v9, v11);
      v18 = (_QWORD *)*((_QWORD *)&v28 + 1);
      v19 = (_QWORD *)v28;
      if ( v3 == *((_QWORD *)&v28 + 1) )
      {
        v20 = v9;
        if ( (_QWORD)v28 != *((_QWORD *)&v28 + 1) )
        {
          do
          {
            sub_14036DFF0(v20, (__int64)v19);
            v20 += 0x10;
            v19 += 2;
          }
          while ( v19 != v18 );
          v18 = (_QWORD *)*((_QWORD *)&v28 + 1);
          v19 = (_QWORD *)v28;
        }
      }
      else
      {
        v21 = v9;
        if ( (_QWORD)v28 != v3 )
        {
          do
          {
            sub_14036DFF0(v21, (__int64)v19);
            v21 += 0x10;
            v19 += 2;
          }
          while ( v19 != (_QWORD *)v3 );
          v18 = (_QWORD *)*((_QWORD *)&v28 + 1);
          v19 = (_QWORD *)v28;
        }
        if ( (_QWORD *)v3 != v18 )
        {
          v22 = v17 + v9 - v3 + 0x10;
          do
          {
            sub_14036DFF0(v22 + v3, v3);
            v3 += 0x10;
          }
          while ( (_QWORD *)v3 != v18 );
          v18 = (_QWORD *)*((_QWORD *)&v28 + 1);
          v19 = (_QWORD *)v28;
        }
        v13 = v32;
      }
      if ( v19 )
      {
        if ( v19 != v18 )
        {
          do
          {
            if ( *v19 )
              (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v19 + 8LL))(*v19);
            *v19 = 0;
            v19 += 2;
          }
          while ( v19 != v18 );
          v19 = (_QWORD *)v28;
        }
        sub_1403A6820((__int64)&v28, (unsigned __int64)v19, (v29 - (_QWORD)v19) & 0xFFFFFFFFFFFFFFF0uLL);
      }
      v1 = v9 + allocSize_1;
      *(_QWORD *)&v28 = v9;
      LODWORD(allocSize_1) = allocSize_3;
      v29 = v1;
      v3 = v9 + 0x10 * v13;
    }
    else
    {
      sub_14036DFF0(v3, *(_QWORD *)(a1 + 0x20) + ((unsigned __int64)allocSize_2 << 6));
      v1 = v29;
      v3 = *((_QWORD *)&v28 + 1) + 0x10LL;
      v9 = v28;
    }
    a1 = v30;
    allocSize_2 = allocSize_4 + 1;
    *((_QWORD *)&v28 + 1) = v3;
  }
  v23 = (v3 - v9) >> 4;
  v24 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x598LL))(qword_149C8E018);
  if ( !(_DWORD)v23 )
    v9 = 0;
  result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v24 + 0x20LL))(v24, v9, (unsigned int)v23);
  v26 = (_QWORD *)v28;
  if ( (_QWORD)v28 )
  {
    v27 = (_QWORD *)*((_QWORD *)&v28 + 1);
    if ( (_QWORD)v28 != *((_QWORD *)&v28 + 1) )
    {
      do
      {
        if ( *v26 )
          (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v26 + 8LL))(*v26);
        *v26 = 0;
        v26 += 2;
      }
      while ( v26 != v27 );
      v26 = (_QWORD *)v28;
    }
    return sub_1403A6820((__int64)&v28, (unsigned __int64)v26, (v29 - (_QWORD)v26) & 0xFFFFFFFFFFFFFFF0uLL);
  }
  return result;
}

// --- End Function: sub_14305EBB0 (0x14305EBB0) ---

// --- Function: sub_143066D50 (0x143066D50) ---
void __fastcall sub_143066D50(__int64 a1)
{
  __int128 v1; // xmm6
  unsigned __int32 v3; // xmm0_4
  int v4; // eax
  unsigned __int32 v5; // xmm0_4
  int v6; // eax
  unsigned __int32 v7; // xmm0_4
  int v8; // eax
  __int64 v9; // rax
  double v10; // xmm0_8
  int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rcx
  const char *v15; // rbx
  int v16; // eax
  __int128 n0x3F800000; // xmm0
  __int64 v21; // rax
  __int64 v22; // rax
  unsigned __int64 v23; // rax
  size_t v24; // rsi
  __int64 *v25; // rax
  void **v26; // rax
  unsigned __int64 i; // rbx
  char *v28; // rax
  float v29; // eax
  int v30; // eax
  float v31; // eax
  int v32; // eax
  void *v33; // [rsp+28h] [rbp-29h] BYREF
  void *v34; // [rsp+30h] [rbp-21h] BYREF
  void *v35; // [rsp+38h] [rbp-19h] BYREF
  __int64 v36; // [rsp+40h] [rbp-11h] BYREF
  __int64 v37; // [rsp+48h] [rbp-9h]
  __int64 (__fastcall ***v38)(); // [rsp+50h] [rbp-1h]
  __int64 (__fastcall **v39)(); // [rsp+58h] [rbp+7h] BYREF
  int n3; // [rsp+60h] [rbp+Fh]
  int n8; // [rsp+68h] [rbp+17h]
  int v42; // [rsp+70h] [rbp+1Fh]
  float v43; // [rsp+74h] [rbp+23h]
  char v44; // [rsp+78h] [rbp+27h]
  __int128 v45; // [rsp+88h] [rbp+37h]
  float v46; // [rsp+C8h] [rbp+77h] BYREF
  float v47; // [rsp+D0h] [rbp+7Fh] BYREF

  v45 = v1;
  if ( qword_149C8DFD8 )
  {
    v3 = sub_140572030().m128_u32[0];
    v4 = *(_DWORD *)(a1 + 0xB0);
    if ( v4 )
    {
      v36 = 1;
      v38 = &v39;
      v43 = *(float *)&v3;
      v37 = 0;
      n3 = 3;
      n8 = 8;
      v39 = off_1484FFDA0;
      v44 = 0;
      v42 = v4;
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
    }
    v5 = sub_140572030().m128_u32[0];
    v6 = *(_DWORD *)(a1 + 0xB4);
    if ( v6 )
    {
      v36 = 1;
      v38 = &v39;
      v43 = *(float *)&v5;
      v37 = 0;
      n3 = 3;
      n8 = 8;
      v39 = off_1484FFDA0;
      v44 = 0;
      v42 = v6;
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
    }
    v7 = sub_140572030().m128_u32[0];
    v8 = *(_DWORD *)(a1 + 0xB8);
    if ( v8 )
    {
      v36 = 1;
      v38 = &v39;
      v43 = *(float *)&v7;
      v37 = 0;
      n3 = 3;
      n8 = 8;
      v39 = off_1484FFDA0;
      v44 = 0;
      v42 = v8;
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
    }
    sub_1403CE280(*(_QWORD *)(a1 + 0x48));
    sub_143E381B0(*(_QWORD *)(a1 + 0x10));
    sub_143F54190(*(_QWORD *)(a1 + 0x18));
    sub_14432ADB0(*(_QWORD *)(a1 + 0x20));
    sub_14432AE50(*(_QWORD *)(a1 + 0x28));
    sub_143F544D0(*(_QWORD *)(a1 + 0x30));
    sub_143F68660(*(_QWORD *)(a1 + 0x38));
    if ( Parameter_0 )
    {
      v9 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x5000000);
      if ( v9 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v9 + 8LL))(v9);
    }
    v10 = (*(double (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF80 + 0x88LL))(qword_149C8DF80);
    if ( *(float *)&v10 != *(float *)(a1 + 0x248) )
    {
      v11 = *(_DWORD *)(a1 + 0xC4);
      if ( v11 )
      {
        v36 = 1;
        v38 = &v39;
        v43 = *(float *)&v10;
        v37 = 0;
        n3 = 3;
        n8 = 8;
        v39 = off_1484FFDA0;
        v44 = 0;
        v42 = v11;
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
      }
      *(float *)(a1 + 0x248) = *(float *)&v10;
    }
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E000 + 0x158LL))(qword_149C8E000);
    v13 = v12;
    if ( v12
      && (v14 = *(_QWORD *)(v12 + 0x10)) != 0
      && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0xE8LL))(v14) )
    {
      v15 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v13 + 0x10) + 0x20LL))(*(_QWORD *)(v13 + 0x10));
    }
    else
    {
      v15 = 0;
    }
    v16 = *(_DWORD *)(a1 + 0xC0);
    if ( v16 )
    {
      _XMM0 = (unsigned __int64)v15;
      v36 = 1;
      v38 = &v39;
      __asm { vpcmpeqq xmm3, xmm0, xmm1 }
      n0x3F800000 = 0x3F800000u;
      __asm { vblendvps xmm0, xmm0, xmm2, xmm3 }
      v43 = *(float *)&_XMM0;
      v37 = 0;
      n3 = 3;
      n8 = 8;
      v39 = off_1484FFDA0;
      v44 = 0;
      v42 = v16;
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
    }
    sub_14035E090(&v33);
    if ( v15 )
    {
      v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
      v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v21 + 0x130LL))(v21);
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0xE0LL))(v22) )
      {
        assignCStringToStringStructure((__int64)&v33, (__int64)v15);
        v23 = sub_1403EA670((__int64 *)&v33, 0x2E, 0xFFFFFFFFFFFFFFFFuLL);
        if ( v23 )
        {
          v24 = v23 + 1;
          if ( v23 + 1 < sub_1403EBE30(&v33) )
          {
            v25 = (__int64 *)CreateStringObjectFromString(&v35, v15);
            v26 = sub_1403EF0C0(v25, &v34, v24, 0xFFFFFFFFFFFFFFFFuLL);
            sub_14037AE80(&v33, v26);
            sub_140373CC0(&v34);
            sub_140373CC0(&v35);
          }
        }
      }
    }
    for ( i = 0; i < sub_1403EBE30(&v33); ++i )
    {
      v28 = (char *)std::unique_ptr<char [0]>::operator[](&v33, i);
      if ( !isalnum(*v28) && *(_BYTE *)std::unique_ptr<char [0]>::operator[](&v33, i) != 0x5F )
        *(_BYTE *)std::unique_ptr<char [0]>::operator[](&v33, i) = 0x5F;
    }
    v46 = 0.0;
    if ( sub_1403C3450(&v33)
      || !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD, void *, float *))(*(_QWORD *)qword_149C8DFD8 + 0x78LL))(
            qword_149C8DFD8,
            *(unsigned int *)(a1 + 0xC8),
            v33,
            &v46) )
    {
      v30 = *(_DWORD *)(a1 + 0xC8);
      if ( *(_DWORD *)(a1 + 0xCC) && v30 )
      {
        v43 = *(float *)(a1 + 0xCC);
        v38 = &v39;
        v36 = 1;
        v37 = 0;
        n3 = 3;
        n8 = 0xA;
        v39 = &off_1482CBED0;
        v42 = v30;
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
      }
      v29 = *(float *)(a1 + 0xCC);
    }
    else
    {
      v29 = v46;
      if ( LODWORD(v46) == *(_DWORD *)(a1 + 0xD0) )
      {
LABEL_43:
        v47 = 0.0;
        if ( sub_1403C3450(&v33)
          || !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD, void *, float *))(*(_QWORD *)qword_149C8DFD8 + 0x78LL))(
                qword_149C8DFD8,
                *(unsigned int *)(a1 + 0xD4),
                v33,
                &v47) )
        {
          v32 = *(_DWORD *)(a1 + 0xD4);
          if ( *(_DWORD *)(a1 + 0xD8) && v32 )
          {
            v43 = *(float *)(a1 + 0xD8);
            v38 = &v39;
            v36 = 1;
            v37 = 0;
            n3 = 3;
            n8 = 0xA;
            v39 = &off_1482CBED0;
            v42 = v32;
            (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
          }
          v31 = *(float *)(a1 + 0xD8);
        }
        else
        {
          v31 = v47;
          if ( LODWORD(v47) == *(_DWORD *)(a1 + 0xDC) )
          {
LABEL_54:
            sub_140373CC0(&v33);
            return;
          }
          if ( v47 != 0.0 )
          {
            if ( *(_DWORD *)(a1 + 0xD4) )
            {
              v42 = *(_DWORD *)(a1 + 0xD4);
              v38 = &v39;
              v36 = 1;
              v37 = 0;
              n3 = 3;
              n8 = 0xA;
              v39 = &off_1482CBED0;
              v43 = v47;
              (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
              v31 = v47;
            }
          }
        }
        *(float *)(a1 + 0xDC) = v31;
        goto LABEL_54;
      }
      if ( v46 != 0.0 && *(_DWORD *)(a1 + 0xC8) )
      {
        v42 = *(_DWORD *)(a1 + 0xC8);
        v38 = &v39;
        v36 = 1;
        v37 = 0;
        n3 = 3;
        n8 = 0xA;
        v39 = &off_1482CBED0;
        v43 = v46;
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0x20LL))(qword_149C8DFD8, &v36);
        v29 = v46;
      }
    }
    *(float *)(a1 + 0xD0) = v29;
    goto LABEL_43;
  }
}

// --- End Function: sub_143066D50 (0x143066D50) ---

// --- Function: sub_14306AB20 (0x14306AB20) ---
// local variable allocation has failed, the output may be wrong!
const ULONG_PTR *__fastcall sub_14306AB20(__int64 a1, double a2)
{
  const ULONG_PTR *p_p_Src; // rax
  __int128 v4; // xmm7
  unsigned int v5; // eax
  __int64 v6; // rbx
  float *v7; // rax
  float *v8; // rbx
  float *v9; // r15
  _QWORD *v10; // rsi
  void (__fastcall ***v11)(_QWORD); // r14
  __int64 v12; // rcx
  __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r9
  signed int v16; // r8d
  __int64 v17; // rax
  __int64 v18; // rdx
  int n2; // eax
  float v20; // xmm1_4
  __int128 v21; // kr00_16
  __int64 v24; // rcx
  float v25; // xmm3_4
  int n3; // eax
  bool v27; // zf
  float v28; // kr00_4
  unsigned __int32 v29; // eax
  _UNKNOWN *retaddr; // [rsp+68h] [rbp+0h] BYREF

  p_p_Src = (const ULONG_PTR *)&retaddr;
  v4 = *(_OWORD *)&a2;
  if ( byte_149C8E515 )
  {
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x40), 1, 0);
    if ( v5 )
      sub_1403C6E80(a1 + 0x40, v5, (__int64)"Graphics::CColorGradientManager::UpdateForThisFrame", 1);
    else
      *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v6 = *(_QWORD *)(a1 + 0x20);
    if ( (unsigned __int64)((*(_QWORD *)(a1 + 0x28) - v6) >> 6) > 1 )
    {
      v7 = *(float **)(a1 + 0x28);
      v8 = (float *)(v6 + 0x40);
      while ( v8 != v7 )
      {
        if ( v8[2] == 0.0 && *((_BYTE *)v8 + 0x34) )
        {
          if ( *(_QWORD *)v8 )
            (*(void (__fastcall **)(_QWORD))(**(_QWORD **)v8 + 8LL))(*(_QWORD *)v8);
          *(_QWORD *)v8 = 0;
          v9 = *(float **)(a1 + 0x28);
          if ( v8 + 0x10 != v9 )
          {
            v10 = v8 + 0x14;
            do
            {
              v11 = (void (__fastcall ***)(_QWORD))v10[0xFFFFFFFE];
              if ( (void (__fastcall ***)(_QWORD))v10[0xFFFFFFF6] != v11 )
              {
                if ( v11 )
                  (**v11)(v10[0xFFFFFFFE]);
                v12 = v10[0xFFFFFFF6];
                if ( v12 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 8LL))(v12);
                v10[0xFFFFFFF6] = v11;
              }
              *((_DWORD *)v10 + 0xFFFFFFEE) = *((_DWORD *)v10 + 0xFFFFFFFE);
              sub_14037AE80((void **)v10 + 0xFFFFFFF8, (void **)v10);
              *((_DWORD *)v10 + 0xFFFFFFF2) = *((_DWORD *)v10 + 2);
              *((_DWORD *)v10 + 0xFFFFFFF3) = *((_DWORD *)v10 + 3);
              *((_DWORD *)v10 + 0xFFFFFFF4) = *((_DWORD *)v10 + 4);
              v10[0xFFFFFFFB] = v10[3];
              *((_DWORD *)v10 + 0xFFFFFFF8) = *((_DWORD *)v10 + 8);
              *((_BYTE *)v10 + 0xFFFFFFE4) = *((_BYTE *)v10 + 0x24);
              *((_DWORD *)v10 + 0xFFFFFFFA) = *((_DWORD *)v10 + 0xA);
              v10 += 8;
            }
            while ( v10 + 0xFFFFFFFE != (_QWORD *)v9 );
          }
          v13 = *(_QWORD *)(a1 + 0x28);
          sub_140373CC0((_QWORD *)(v13 - 0x30));
          v14 = *(_QWORD *)(v13 - 0x40);
          if ( v14 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 8LL))(v14);
          *(_QWORD *)(v13 - 0x40) = 0;
          *(_QWORD *)(a1 + 0x28) -= 0x40LL;
          v7 = *(float **)(a1 + 0x28);
        }
        else
        {
          v8 += 0x10;
        }
      }
    }
    sub_14302F450((_QWORD *)a1);
    v15 = *(_QWORD *)(a1 + 0x28);
    v16 = 0x80000001;
    v17 = *(_QWORD *)(a1 + 0x20);
    v18 = 0;
    if ( v17 == v15 )
      goto LABEL_50;
    do
    {
      if ( (*(_DWORD *)(v17 + 0x38) <= 2u || !*(_QWORD *)(v17 + 0x28)) && *(_DWORD *)(v17 + 0x30) >= v16 )
      {
        v16 = *(_DWORD *)(v17 + 0x30);
        v18 = v17;
      }
      v17 += 0x40;
    }
    while ( v17 != v15 );
    if ( !v18 )
    {
LABEL_50:
      sub_14305EBB0(a1);
      v29 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x40), 0, 1);
      if ( v29 != 1 )
        return sub_1403DF590(a1 + 0x40, v29);
      p_p_Src = &p_Src;
      *(_QWORD *)(a1 + 0x48) = &p_Src;
      return p_p_Src;
    }
    n2 = *(_DWORD *)(v18 + 0x38);
    if ( n2 != 1 )
    {
      if ( n2 == 2 )
        goto LABEL_41;
      *(_DWORD *)(v18 + 0x38) = 1;
      *(_DWORD *)(v18 + 0x1C) = 0;
      *(_BYTE *)(v18 + 0x34) = 0;
    }
    if ( !*(_BYTE *)(a1 + 0x38) )
    {
      *(_DWORD *)(v18 + 8) = 0x3F800000;
LABEL_40:
      *(_DWORD *)(v18 + 0x38) = 2;
      goto LABEL_41;
    }
    v20 = *(float *)(v18 + 0x18);
    if ( v20 == 0.0 )
    {
      *(float *)(v18 + 8) = 0x3F800000;
      goto LABEL_40;
    }
    v21 = v4;
    *(float *)&v21 = *(float *)&v4 + *(float *)(v18 + 0x1C);
    *(float *)(v18 + 0x1C) = *(float *)&v21;
    *(float *)&v21 = *(float *)&v21 / v20;
    _XMM0 = v21;
    __asm { vminss  xmm1, xmm0, xmm2 }
    *(float *)(v18 + 8) = *(float *)&_XMM1;
    if ( *(float *)&_XMM1 == 1.0 )
      goto LABEL_40;
LABEL_41:
    v24 = *(_QWORD *)(a1 + 0x20);
    v25 = *(float *)(v18 + 8);
    if ( v24 != *(_QWORD *)(a1 + 0x28) )
    {
      while ( 1 )
      {
        if ( v18 != v24 )
        {
          n3 = *(_DWORD *)(v24 + 0x38);
          if ( n3 == 3 )
            goto LABEL_46;
          if ( n3 != 4 )
            break;
        }
LABEL_48:
        v24 += 0x40;
        if ( v24 == *(_QWORD *)(a1 + 0x28) )
          goto LABEL_49;
      }
      v27 = *(_QWORD *)(v24 + 0x28) == 0;
      *(_DWORD *)(v24 + 0x38) = 3;
      *(_BYTE *)(v24 + 0x34) = v27;
LABEL_46:
      v28 = (float)(1.0 - v25) * *(float *)(v24 + 0x20);
      *(float *)(v24 + 8) = v28;
      if ( v28 == 0.0 )
        *(_DWORD *)(v24 + 0x38) = 4;
      goto LABEL_48;
    }
LABEL_49:
    *(_BYTE *)(a1 + 0x38) = 1;
    goto LABEL_50;
  }
  return p_p_Src;
}

// --- End Function: sub_14306AB20 (0x14306AB20) ---

// --- Function: sub_1430705E0 (0x1430705E0) ---
__int64 __fastcall sub_1430705E0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rdi
  __int64 v10; // rcx
  __int64 result; // rax

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v4 != i; v4 += 8 )
    {
      sub_140373CC0(v4 + 2);
      if ( *v4 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 8LL))(*v4);
      *v4 = 0;
    }
    v10 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v10 - *(_QWORD *)(v10 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = *(_QWORD *)(v10 - 8);
    }
    result = sub_1402A6590(v10);
  }
  *a1 = a2;
  a1[1] = a2 + (a3 << 6);
  a1[2] = a2 + (a4 << 6);
  return result;
}

// --- End Function: sub_1430705E0 (0x1430705E0) ---

// --- Function: sub_143092750 (0x143092750) ---
__int64 __fastcall sub_143092750(__int64 a1, __int64 *a2)
{
  unsigned int event_key_from_source_location; // ebx
  __int64 v5; // rsi
  void (__fastcall *v6)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)); // rbp
  __int64 v7; // rax
  __int64 p_sub_14159F620_1; // rax
  __int64 (__fastcall *p_sub_14154ABF0)(__int64, __int64); // [rsp+20h] [rbp-28h] BYREF
  void (__fastcall *p_sub_14159F620)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+28h] [rbp-20h]
  __int64 v11; // [rsp+30h] [rbp-18h]

  event_key_from_source_location = event_key_from_source_location_4;
  if ( !event_key_from_source_location_4 )
    event_key_from_source_location = get_event_key_from_source_location(
                                       &event_key_from_source_location_4,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\PlayerNotificationSystem\\"
                                                "PlayerNotificationBannerManager.h",
                                       0x13);
  v5 = *a2;
  v6 = *(void (__fastcall **)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)))(*(_QWORD *)a1 + 0x20LL);
  v7 = sub_1402A65A0(0xCu);
  if ( v7 )
  {
    *(_QWORD *)v7 = v5;
    *(_DWORD *)(v7 + 8) = event_key_from_source_location;
    v11 = v7;
  }
  else
  {
    v11 = 0;
  }
  p_sub_14154ABF0 = sub_14154ABF0;
  p_sub_14159F620 = sub_14159F620;
  v6(a1, event_key_from_source_location, &p_sub_14154ABF0);
  p_sub_14159F620_1 = (__int64)p_sub_14159F620;
  if ( (unsigned __int64)p_sub_14159F620 >= 2 )
    return ((__int64 (__fastcall *)(__int64, _QWORD))p_sub_14159F620)(2, &p_sub_14154ABF0);
  return p_sub_14159F620_1;
}

// --- End Function: sub_143092750 (0x143092750) ---

// --- Function: sub_1430937F0 (0x1430937F0) ---
void __fastcall sub_1430937F0(__int64 a1, __int64 *a2)
{
  unsigned int event_key_from_source_location; // eax
  __int64 *j; // rbx
  __int64 *v6; // rdi
  __int64 *v7; // rcx
  __int64 *v8; // rdx
  unsigned int event_key_from_source_location_1; // r8d
  __int64 **v10; // rax
  __int64 *i; // rax
  __int64 *v12; // rcx
  __int64 *v13; // rdi
  __int64 *k; // rbx
  _QWORD *v15; // rdi
  _QWORD *m; // rbx

  if ( *(_DWORD *)(a1 + 0x70) )
  {
    event_key_from_source_location = event_key_from_source_location_4;
    if ( !event_key_from_source_location_4 )
      event_key_from_source_location = get_event_key_from_source_location(
                                         &event_key_from_source_location_4,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\PlayerNotificationSyste"
                                                  "m\\PlayerNotificationBannerManager.h",
                                         0x13);
    j = *(__int64 **)(a1 + 0x60);
    v6 = j;
    v7 = (__int64 *)j[1];
    v8 = v7;
    while ( !*((_BYTE *)v8 + 0x19) )
    {
      event_key_from_source_location_1 = *((_DWORD *)v8 + 7);
      if ( event_key_from_source_location_1 >= event_key_from_source_location )
      {
        if ( *((_BYTE *)v6 + 0x19) && event_key_from_source_location < event_key_from_source_location_1 )
          v6 = v8;
        j = v8;
        v8 = (__int64 *)*v8;
      }
      else
      {
        v8 = (__int64 *)v8[2];
      }
    }
    if ( !*((_BYTE *)v6 + 0x19) )
      v7 = (__int64 *)*v6;
    while ( !*((_BYTE *)v7 + 0x19) )
    {
      if ( event_key_from_source_location >= *((_DWORD *)v7 + 7) )
      {
        v7 = (__int64 *)v7[2];
      }
      else
      {
        v6 = v7;
        v7 = (__int64 *)*v7;
      }
    }
    while ( j != v6 )
    {
      sub_143092750(*(_QWORD *)(*(_QWORD *)a1 + 8LL * *((unsigned int *)j + 8)), a2);
      v10 = (__int64 **)j[2];
      if ( *((_BYTE *)v10 + 0x19) )
      {
        for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
        {
          if ( j != (__int64 *)i[2] )
            break;
          j = i;
        }
        j = i;
      }
      else
      {
        v12 = *v10;
        for ( j = (__int64 *)j[2]; !*((_BYTE *)v12 + 0x19); v12 = (__int64 *)*v12 )
          j = v12;
      }
    }
  }
  else
  {
    v13 = *(__int64 **)(a1 + 8);
    for ( k = *(__int64 **)a1; k != v13; ++k )
      sub_143092750(*k, a2);
  }
  v15 = *(_QWORD **)(a1 + 0x28);
  for ( m = *(_QWORD **)(a1 + 0x20); m != v15; ++m )
    sub_1430937F0(*m, a2);
}

// --- End Function: sub_1430937F0 (0x1430937F0) ---

// --- Function: sub_1430A1B50 (0x1430A1B50) ---
__int64 __fastcall sub_1430A1B50(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r14
  __int64 v12; // rax
  unsigned __int64 v13; // rsi
  __int64 v14; // r15
  __int64 v15; // rdx
  _QWORD *v16; // rcx
  _QWORD *v17; // rbx
  _QWORD *i; // rbp
  __int64 v19; // r8
  __int64 result; // rax

  v6 = (a2 - *a1) / 0x4B8;
  v7 = (a1[1] - *a1) / 0x4B8;
  if ( v7 == 0x36406C80D901B2LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x4B8;
  if ( v9 > 0x36406C80D901B2LL - (v9 >> 1) )
    goto LABEL_25;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x36406C80D901B2LL )
    goto LABEL_25;
  v11 = 0x4B8 * v10;
  if ( 0x4B8 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = sub_1402A65A0(0x4B8 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_25:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_24;
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_13:
  v14 = v13 + 0x4B8 * v6;
  sub_142659050(v14, a3);
  v15 = a1[1];
  v16 = (_QWORD *)*a1;
  if ( a2 == v15 )
  {
    sub_1430B3CB0(v16, v15, v13, a1);
  }
  else
  {
    sub_1430B5280(v16, a2, v13, a1);
    sub_1430B5280(a2, a1[1], v14 + 0x4B8, a1);
  }
  v17 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v17 != i; v17 += 0x97 )
      sub_14265C210(v17);
    v19 = *a1;
    if ( (unsigned __int64)(0x4B8 * ((a1[2] - *a1) / 0x4B8)) < 0x1000 )
      goto LABEL_22;
    if ( (unsigned __int64)(v19 - *(_QWORD *)(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(_QWORD *)(v19 - 8);
LABEL_22:
      sub_1402A6590(v19);
      goto LABEL_23;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *a1 = v13;
  result = v14;
  a1[1] = v13 + 0x4B8 * v8;
  a1[2] = v11 + v13;
  return result;
}

// --- End Function: sub_1430A1B50 (0x1430A1B50) ---

// --- Function: sub_1430A1D80 (0x1430A1D80) ---
unsigned __int64 __fastcall sub_1430A1D80(__int64 *a1, _QWORD *a2, __int64 a3)
{
  __int64 v6; // r15
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r14
  __int64 v12; // rax
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // r15
  unsigned __int64 v15; // r8
  __int64 v16; // rdx
  _QWORD *v17; // rcx
  _QWORD *v18; // rbx
  _QWORD *i; // rbp
  __int64 v20; // r8
  unsigned __int64 result; // rax

  v6 = ((__int64)a2 - *a1) / 0x28;
  v7 = (a1[1] - *a1) / 0x28;
  if ( v7 == 0x666666666666666LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x28;
  if ( v9 > 0x666666666666666LL - (v9 >> 1) )
    goto LABEL_25;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x666666666666666LL )
    goto LABEL_25;
  v11 = 0x28 * v10;
  if ( 0x28 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = sub_1402A65A0(0x28 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_25:
    sub_1402E3880();
  v12 = sub_1402A65A0(v11 + 0x27);
  if ( !v12 )
    goto LABEL_23;
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_13:
  v14 = v13 + 0x28 * v6;
  sub_14035DE10((void **)v14, (const void **)a3);
  sub_14035DE10((void **)(v14 + 8), (const void **)(a3 + 8));
  v15 = v13;
  *(_QWORD *)(v14 + 0x10) = *(_QWORD *)(a3 + 0x10);
  *(_DWORD *)(v14 + 0x18) = *(_DWORD *)(a3 + 0x18);
  *(_DWORD *)(v14 + 0x1C) = *(_DWORD *)(a3 + 0x1C);
  *(_BYTE *)(v14 + 0x20) = *(_BYTE *)(a3 + 0x20);
  v16 = a1[1];
  v17 = (_QWORD *)*a1;
  if ( a2 != (_QWORD *)v16 )
  {
    sub_1430B52E0(v17, a2, v13, a1);
    v16 = a1[1];
    v15 = v14 + 0x28;
    v17 = a2;
  }
  sub_1430B52E0(v17, v16, v15, a1);
  v18 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v18 != i; v18 += 5 )
    {
      sub_140373CC0(v18 + 1);
      sub_140373CC0(v18);
    }
    v20 = *a1;
    if ( (unsigned __int64)(0x28 * ((a1[2] - *a1) / 0x28)) < 0x1000 )
      goto LABEL_21;
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
LABEL_21:
      sub_1402A6590(v20);
      goto LABEL_22;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  *a1 = v13;
  a1[1] = v13 + 0x28 * v8;
  result = v14;
  a1[2] = v11 + v13;
  return result;
}

// --- End Function: sub_1430A1D80 (0x1430A1D80) ---

// --- Function: sub_1430A1FD0 (0x1430A1FD0) ---
unsigned __int64 __fastcall sub_1430A1FD0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  __int64 v7; // r12
  __int64 v8; // rdx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  unsigned __int64 allocSize_1; // rax
  unsigned __int64 v13; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rbx
  __int64 v17; // rdx
  __int64 v18; // rcx

  v6 = 0x3D226357E16ECELL;
  v7 = (a2 - *a1) / 0x430;
  v8 = (a1[1] - *a1) / 0x430;
  if ( v8 == 0x3D226357E16ECELL )
    unknown_libname_10();
  v9 = v8 + 1;
  v10 = (a1[2] - *a1) / 0x430;
  v11 = v10 >> 1;
  if ( v10 <= 0x3D226357E16ECELL - (v10 >> 1) )
  {
    v13 = v9;
    if ( v11 + v10 >= v9 )
      v13 = v11 + v10;
    if ( v13 > 0x3D226357E16ECELL )
      goto LABEL_19;
    allocSize = 0x430 * v13;
    v6 = v13;
    if ( 0x430 * v13 < 0x1000 )
    {
      if ( allocSize )
        v16 = sub_1402A65A0(allocSize);
      else
        v16 = 0;
      goto LABEL_15;
    }
    allocSize_1 = allocSize + 0x27;
    if ( allocSize + 0x27 < allocSize )
LABEL_19:
      sub_1402E3880();
  }
  else
  {
    allocSize_1 = 0xFFFFFFFFFFFFFEC7uLL;
  }
  v15 = sub_1402A65A0(allocSize_1);
  if ( !v15 )
    invalid_parameter_noinfo_noreturn();
  v16 = (v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v16 - 8) = v15;
LABEL_15:
  sub_1426595C0(v16 + 0x430 * v7, a3);
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    sub_142650E10(v18, v17, v16, a1);
  }
  else
  {
    sub_1430B5380(v18, a2, v16, a1);
    sub_1430B5380(a2, a1[1], v16 + 0x430 * v7 + 0x430, a1);
  }
  sub_1431E91F0(a1, v16, v9, v6);
  return v16 + 0x430 * v7;
}

// --- End Function: sub_1430A1FD0 (0x1430A1FD0) ---

// --- Function: sub_1430CE720 (0x1430CE720) ---
__int64 __fastcall sub_1430CE720(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 n2; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF930;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF4D0;
  *(_QWORD *)(a1 + 0x30) = sub_1403EBBC0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x78) = "InventoryId";
  *(_QWORD *)(a1 + 0x88) = &sub_1412AFD70;
  *(_QWORD *)(a1 + 0x90) = sub_1412AFAB0;
  *(_QWORD *)(a1 + 0xA0) = sub_1412AEE70;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9230;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F30;
  n2 = 2;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_WORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  *(_QWORD *)(a1 + 0xD8) = 0xAF;
  return n2;
}

// --- End Function: sub_1430CE720 (0x1430CE720) ---

// --- Function: sub_1430E0500 (0x1430E0500) ---
_QWORD *__fastcall sub_1430E0500(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  _QWORD *v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // rcx
  _BYTE *v7; // rbx
  __int64 v8; // r14
  __int64 v9; // r15
  __int64 v10; // r8
  _QWORD v12[2]; // [rsp+20h] [rbp-28h] BYREF
  char v13; // [rsp+50h] [rbp+8h] BYREF

  v3 = (unsigned __int128)((a2 - a1) * (__int128)0x3759F22983759F23LL) >> 0x40;
  v4 = (_QWORD *)a3;
  v5 = ((unsigned __int64)v3 >> 0x3F) + (v3 >> 8);
  if ( v5 > 0 )
  {
    v6 = a1 - a3;
    v7 = (_BYTE *)(a3 + 0x498);
    v12[0] = &v13;
    v8 = v6 - 0x490;
    v9 = v6 - 0x498;
    do
    {
      *v4 = *(_QWORD *)&v7[v9];
      v10 = (unsigned __int8)*v7;
      v12[1] = &v7[v8];
      sub_1431F2F50(v12, v7 + 0xFFFFFB70, v10);
      --v5;
      *v7 = v7[v8 + 0x490];
      v7 += 0x4A0;
      v4 += 0x94;
    }
    while ( v5 > 0 );
  }
  return v4;
}

// --- End Function: sub_1430E0500 (0x1430E0500) ---

// --- Function: sub_1430E0B00 (0x1430E0B00) ---
_QWORD *__fastcall sub_1430E0B00(__int64 a1, _QWORD *a2, _OWORD *a3, _OWORD *a4)
{
  _OWORD *v4; // rsi
  _OWORD *v8; // rdx
  _OWORD *v9; // rbp
  _OWORD *v10; // rdi
  _QWORD *v11; // r14
  _QWORD *v12; // r14
  _QWORD *v13; // r14
  __int128 v15; // [rsp+28h] [rbp-4E0h] BYREF
  _QWORD v16[154]; // [rsp+38h] [rbp-4D0h] BYREF

  v4 = *(_OWORD **)(a1 + 8);
  if ( v4 == *(_OWORD **)(a1 + 0x10) )
  {
    *a2 = sub_1430A2D50(a1, a3, a4);
  }
  else
  {
    v8 = a4 + 1;
    if ( a3 == v4 )
    {
      *v4 = *a4;
      sub_1430EE270(v4 + 1, v8);
      *(_QWORD *)(a1 + 8) += 0x4C8LL;
      *a2 = a3;
    }
    else
    {
      v15 = *a4;
      sub_1430EE270(v16, v8);
      v9 = (_OWORD *)((char *)v4 + 0xFFFFFB38);
      *v4 = *(_OWORD *)((char *)v4 + 0xFFFFFB38);
      sub_1430EE270(v4 + 1, (char *)v4 + 0xFFFFFB48);
      *(_QWORD *)(a1 + 8) += 0x4C8LL;
      if ( (_OWORD *)((char *)v4 + 0xFFFFFB38) != a3 )
      {
        v10 = v4 + 0x45;
        do
        {
          v10 = (_OWORD *)((char *)v10 + 0xFFFFFB38);
          v9 = (_OWORD *)((char *)v9 + 0xFFFFFB38);
          v10[0xFFFFFFBB] = *v9;
          sub_1402A6440((__int64)(v10 + 0xFFFFFFBC), *((const void **)v10 + 0xFFFFFEE1), *((_QWORD *)v10 + 0xFFFFFEDF));
          sub_1402A6440((__int64)v10 + 0xFFFFFDD8, *((const void **)v10 + 0xFFFFFF24), *((_QWORD *)v10 + 0xFFFFFF22));
          v11 = (_QWORD *)v10 + 0xFFFFFF65;
          if ( v10 + 0xFFFFFFFF != (_OWORD *)((char *)v10 + 0xFFFFFB28) )
          {
            sub_140564E90((__int64 *)v10 + 0xFFFFFFFE);
            *((_QWORD *)v10 + 0xFFFFFFFE) = *v11;
            *((_QWORD *)v10 + 0xFFFFFFFF) = *((_QWORD *)v10 + 0xFFFFFF66);
            *(_QWORD *)v10 = *((_QWORD *)v10 + 0xFFFFFF67);
            *v11 = 0;
            *((_QWORD *)v10 + 0xFFFFFF66) = 0;
            *((_QWORD *)v10 + 0xFFFFFF67) = 0;
          }
          sub_14037BE50((__int64 *)v10 + 1, (__int64 *)v10 + 0xFFFFFF68);
          v12 = (_QWORD *)v10 + 0xFFFFFF6B;
          if ( v10 + 2 != (_OWORD *)((char *)v10 + 0xFFFFFB58) )
          {
            sub_1426B72B0((__int64 *)v10 + 4);
            *((_QWORD *)v10 + 4) = *v12;
            *((_QWORD *)v10 + 5) = *((_QWORD *)v10 + 0xFFFFFF6C);
            *((_QWORD *)v10 + 6) = *((_QWORD *)v10 + 0xFFFFFF6D);
            *v12 = 0;
            *((_QWORD *)v10 + 0xFFFFFF6C) = 0;
            *((_QWORD *)v10 + 0xFFFFFF6D) = 0;
          }
          *(_OWORD *)((char *)v10 + 0x38) = v10[0xFFFFFFB7];
          *((_QWORD *)v10 + 9) = *((_QWORD *)v10 + 0xFFFFFF70);
          v13 = (_QWORD *)v10 + 0xFFFFFF73;
          *((_QWORD *)v10 + 0xA) = *((_QWORD *)v10 + 0xFFFFFF71);
          *((_BYTE *)v10 + 0x58) = *((_BYTE *)v10 + 0xFFFFFB90);
          if ( v10 + 6 != (_OWORD *)((char *)v10 + 0xFFFFFB98) )
          {
            sub_140375620((__int64 *)v10 + 0xC);
            *((_QWORD *)v10 + 0xC) = *v13;
            *((_QWORD *)v10 + 0xD) = *((_QWORD *)v10 + 0xFFFFFF74);
            *((_QWORD *)v10 + 0xE) = *((_QWORD *)v10 + 0xFFFFFF75);
            *v13 = 0;
            *((_QWORD *)v10 + 0xFFFFFF74) = 0;
            *((_QWORD *)v10 + 0xFFFFFF75) = 0;
          }
        }
        while ( v9 != a3 );
      }
      sub_14307B3E0(a3, &v15);
      sub_14265C210(v16);
      *a2 = a3;
    }
  }
  return a2;
}

// --- End Function: sub_1430E0B00 (0x1430E0B00) ---

// --- Function: sub_1430E2470 (0x1430E2470) ---
_QWORD *__fastcall sub_1430E2470(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  _QWORD *v5; // rsi
  __int64 v9; // r15
  _BYTE *v10; // rbx
  _BYTE *v11; // rdx
  __int64 v12; // r8
  char v13; // al
  __int64 v14; // r8
  __int64 v15; // rdx
  __int64 v16; // rcx
  _QWORD v18[2]; // [rsp+20h] [rbp-48h] BYREF
  _QWORD v19[2]; // [rsp+30h] [rbp-38h] BYREF
  char v20; // [rsp+70h] [rbp+8h] BYREF
  char v21; // [rsp+78h] [rbp+10h] BYREF

  v5 = (_QWORD *)a5;
  v9 = a1;
  if ( a1 == a2 )
  {
LABEL_8:
    v15 = a4;
    v16 = a3;
  }
  else
  {
    v10 = (_BYTE *)(a5 + 0x498);
    while ( a3 != a4 )
    {
      v11 = v10 + 0xFFFFFB70;
      if ( *(_BYTE *)(a3 + 0x498) == 4 )
      {
        *v5 = *(_QWORD *)a3;
        v12 = (unsigned __int8)*v10;
        v18[0] = &v20;
        v18[1] = a3 + 8;
        sub_1431F2F50(v18, v11, v12);
        v13 = *(_BYTE *)(a3 + 0x498);
        a3 += 0x4A0;
      }
      else
      {
        *v5 = *(_QWORD *)v9;
        v14 = (unsigned __int8)*v10;
        v19[0] = &v21;
        v19[1] = v9 + 8;
        sub_1431F2F50(v19, v11, v14);
        v13 = *(_BYTE *)(v9 + 0x498);
        v9 += 0x4A0;
      }
      *v10 = v13;
      v5 += 0x94;
      v10 += 0x4A0;
      if ( v9 == a2 )
        goto LABEL_8;
    }
    v15 = a2;
    v16 = v9;
  }
  return sub_1430E0500(v16, v15, (__int64)v5);
}

// --- End Function: sub_1430E2470 (0x1430E2470) ---

// --- Function: sub_1430E2580 (0x1430E2580) ---
void __fastcall sub_1430E2580(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  int v6; // r13d
  __int64 n0x940; // rcx
  unsigned __int64 allocSize; // rdi
  __int64 v9; // r15
  __int64 v10; // r14
  __int64 v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // r8
  __int64 v14; // [rsp+38h] [rbp-D0h] BYREF
  _QWORD v15[2]; // [rsp+40h] [rbp-C8h] BYREF
  _QWORD v16[2]; // [rsp+50h] [rbp-B8h] BYREF
  _QWORD v17[2]; // [rsp+60h] [rbp-A8h] BYREF
  _QWORD v18[2]; // [rsp+70h] [rbp-98h] BYREF
  _QWORD v19[2]; // [rsp+80h] [rbp-88h] BYREF
  _QWORD v20[2]; // [rsp+90h] [rbp-78h] BYREF
  _QWORD v21[3]; // [rsp+A0h] [rbp-68h] BYREF
  unsigned __int64 v22; // [rsp+B8h] [rbp-50h]
  _QWORD v23[146]; // [rsp+C0h] [rbp-48h] BYREF
  unsigned __int8 v24; // [rsp+550h] [rbp+448h]
  int v25; // [rsp+551h] [rbp+449h]
  __int16 v26; // [rsp+555h] [rbp+44Dh]
  char v27; // [rsp+557h] [rbp+44Fh]

  v6 = a2;
  n0x940 = a2 - a1;
  if ( n0x940 >= 0x940 )
  {
    allocSize = 0x4A0 * (n0x940 / 0x4A0);
    v9 = sub_1402A65A0(allocSize);
    v22 = 0xFFFFFFFFFFFFFFFFuLL;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v24 = 0;
    memset(v23, 0, sizeof(v23));
    LOBYTE(v23[3]) = 0;
    v23[2] = &v23[3];
    v10 = allocSize + v9;
    v23[0] = 0;
    LOBYTE(v23[0x46]) = 0;
    LOBYTE(v23[0x86]) = 0;
    BYTE4(v23[0x8D]) = 0;
    LOBYTE(v23[0x8E]) = 0;
    v11 = v9 + 8;
    v23[0x45] = &v23[0x46];
    v23[1] = 0x1FF;
    LODWORD(v23[0x8D]) = 0xFFFFFFFF;
    *(_OWORD *)&v23[0x43] = xmmword_14838B4D0;
    memset(&v23[0x8F], 0, 0x18);
    memset(&v23[0x87], 0, 0x30);
    if ( v9 != allocSize + v9 )
    {
      v12 = v9 + 8;
      do
      {
        v13 = v24;
        *(_QWORD *)(v12 - 8) = v22;
        *(_BYTE *)(v12 + 0x490) = v13;
        if ( (_BYTE)v13 )
        {
          switch ( (_BYTE)v13 )
          {
            case 1:
              v20[1] = v12;
              v20[0] = &v14;
              sub_1431F3DE0(v20, v23, v13);
              break;
            case 2:
              v19[1] = v12;
              v19[0] = &v14;
              sub_1431F3DE0(v19, v23, v13);
              break;
            case 3:
              v18[1] = v12;
              v18[0] = &v14;
              sub_1431F3DE0(v18, v23, v13);
              break;
            case 4:
              v17[1] = v12;
              v17[0] = &v14;
              sub_1431F3DE0(v17, v23, v13);
              break;
            case 5:
              v16[0] = &v14;
              v16[1] = v12;
              sub_1431F3DE0(v16, v23, v13);
              break;
            default:
              v15[0] = &v14;
              v15[1] = v12;
              sub_1431F3DE0(v15, v23, v13);
              break;
          }
        }
        else
        {
          v21[1] = v12;
          v21[0] = &v14;
          sub_1431F3DE0(v21, v23, 0);
        }
        v12 += 0x4A0;
      }
      while ( v12 - 8 != v10 );
    }
    sub_1431F56D0(&v14, v23, v24);
    if ( (unsigned int)sub_1431F2920(a1, v6, v9, 0, a4) == 1 )
      sub_1430E0500(v9, v10, a1);
    if ( v9 != v10 )
    {
      do
      {
        sub_1431F56D0(&v14, v11, *(unsigned __int8 *)(v11 + 0x490));
        v11 += 0x4A0;
      }
      while ( v11 - 8 != v10 );
    }
    sub_1402A6590(v9);
  }
}

// --- End Function: sub_1430E2580 (0x1430E2580) ---

// --- Function: sub_1430E4710 (0x1430E4710) ---
__int64 __fastcall sub_1430E4710(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  _QWORD v5[2]; // [rsp+20h] [rbp-10h] BYREF
  char v6; // [rsp+40h] [rbp+10h] BYREF

  *(_BYTE *)(a1 + 0x490) = *(_BYTE *)(a2 + 0x490);
  v3 = *(unsigned __int8 *)(a2 + 0x490);
  v5[1] = a1;
  v5[0] = &v6;
  sub_1431F3DE0(v5, a2, v3);
  return a1;
}

// --- End Function: sub_1430E4710 (0x1430E4710) ---

// --- Function: sub_1430E4F80 (0x1430E4F80) ---
__int64 __fastcall sub_1430E4F80(__int64 a1, __int64 a2)
{
  void (__fastcall *v4)(_QWORD); // rax

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  v4 = *(void (__fastcall **)(_QWORD))(a2 + 0x20);
  if ( v4 == (void (__fastcall *)(_QWORD))1 )
  {
    *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
    *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a2 + 0x20);
  }
  else if ( v4 )
  {
    v4(0);
  }
  *(_BYTE *)(a1 + 0x30) = *(_BYTE *)(a2 + 0x30);
  return a1;
}

// --- End Function: sub_1430E4F80 (0x1430E4F80) ---

// --- Function: sub_1430E8350 (0x1430E8350) ---
__int64 __fastcall sub_1430E8350(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 0x20) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = &p_Src;
  *(_QWORD *)a1 = &off_14888C9B8;
  *(_QWORD *)(a1 + 8) = &off_14888C9D8;
  result = a1;
  *(_DWORD *)(a1 + 0x24) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  dword_149F5AFCC = 0;
  return result;
}

// --- End Function: sub_1430E8350 (0x1430E8350) ---

// --- Function: sub_1430EAE20 (0x1430EAE20) ---
__int64 __fastcall sub_1430EAE20(__int64 a1, __int64 a2)
{
  void (__fastcall *v4)(_QWORD); // rax

  *(_QWORD *)(a1 + 8) = 0x1FF;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  sub_1402A6440(a1, *(const void **)(a2 + 0x10), *(_QWORD *)a2);
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x228) = a1 + 0x230;
  *(_QWORD *)(a1 + 0x220) = 0x1FF;
  sub_1402A6440(a1 + 0x218, *(const void **)(a2 + 0x228), *(_QWORD *)(a2 + 0x218));
  *(_BYTE *)(a1 + 0x430) = *(_BYTE *)(a2 + 0x430);
  sub_140360340(a1 + 0x438, a2 + 0x438);
  sub_1426560F0(a1 + 0x450, a2 + 0x450);
  *(_QWORD *)(a1 + 0x468) = *(_QWORD *)(a2 + 0x468);
  *(_BYTE *)(a1 + 0x470) = *(_BYTE *)(a2 + 0x470);
  *(_QWORD *)(a1 + 0x478) = 0;
  *(_QWORD *)(a1 + 0x480) = 0;
  *(_QWORD *)(a1 + 0x488) = 0;
  v4 = *(void (__fastcall **)(_QWORD))(a2 + 0x480);
  if ( v4 == (void (__fastcall *)(_QWORD))1 )
  {
    *(_QWORD *)(a1 + 0x478) = *(_QWORD *)(a2 + 0x478);
    *(_QWORD *)(a1 + 0x480) = *(_QWORD *)(a2 + 0x480);
    return a1;
  }
  else
  {
    if ( v4 )
      v4(0);
    return a1;
  }
}

// --- End Function: sub_1430EAE20 (0x1430EAE20) ---

// --- Function: sub_1430EE140 (0x1430EE140) ---
__int64 __fastcall sub_1430EE140(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx

  *(_QWORD *)(a1 + 8) = 0x1FF;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  sub_1402A6440(a1, *(const void **)(a2 + 0x10), *(_QWORD *)a2);
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x228) = a1 + 0x230;
  *(_QWORD *)(a1 + 0x220) = 0x1FF;
  sub_1402A6440(a1 + 0x218, *(const void **)(a2 + 0x228), *(_QWORD *)(a2 + 0x218));
  *(_BYTE *)(a1 + 0x430) = *(_BYTE *)(a2 + 0x430);
  v4 = *(_QWORD *)(a2 + 0x448);
  v5 = *(_QWORD *)(a2 + 0x440);
  v6 = *(_QWORD *)(a2 + 0x438);
  *(_QWORD *)(a2 + 0x448) = 0;
  *(_QWORD *)(a2 + 0x440) = 0;
  *(_QWORD *)(a2 + 0x438) = 0;
  *(_QWORD *)(a1 + 0x438) = v6;
  *(_QWORD *)(a1 + 0x440) = v5;
  *(_QWORD *)(a1 + 0x448) = v4;
  v7 = *(_QWORD *)(a2 + 0x450);
  v8 = *(_QWORD *)(a2 + 0x460);
  v9 = *(_QWORD *)(a2 + 0x458);
  *(_QWORD *)(a2 + 0x460) = 0;
  *(_QWORD *)(a2 + 0x458) = 0;
  *(_QWORD *)(a2 + 0x450) = 0;
  *(_QWORD *)(a1 + 0x450) = v7;
  *(_QWORD *)(a1 + 0x458) = v9;
  *(_QWORD *)(a1 + 0x460) = v8;
  *(_QWORD *)(a1 + 0x468) = *(_QWORD *)(a2 + 0x468);
  *(_BYTE *)(a1 + 0x470) = *(_BYTE *)(a2 + 0x470);
  return a1;
}

// --- End Function: sub_1430EE140 (0x1430EE140) ---

// --- Function: sub_1430EE270 (0x1430EE270) ---
__int64 __fastcall sub_1430EE270(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = 0x1FF;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  sub_1402A6440(a1, *(const void **)(a2 + 0x10), *(_QWORD *)a2);
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x228) = a1 + 0x230;
  *(_QWORD *)(a1 + 0x220) = 0x1FF;
  sub_1402A6440(a1 + 0x218, *(const void **)(a2 + 0x228), *(_QWORD *)(a2 + 0x218));
  v4 = *(_QWORD *)(a2 + 0x440);
  v5 = *(_QWORD *)(a2 + 0x438);
  v6 = *(_QWORD *)(a2 + 0x430);
  *(_QWORD *)(a2 + 0x440) = 0;
  *(_QWORD *)(a2 + 0x438) = 0;
  *(_QWORD *)(a2 + 0x430) = 0;
  *(_QWORD *)(a1 + 0x430) = v6;
  *(_QWORD *)(a1 + 0x438) = v5;
  *(_QWORD *)(a1 + 0x440) = v4;
  v7 = *(_QWORD *)(a2 + 0x458);
  v8 = *(_QWORD *)(a2 + 0x450);
  v9 = *(_QWORD *)(a2 + 0x448);
  *(_QWORD *)(a2 + 0x458) = 0;
  *(_QWORD *)(a2 + 0x450) = 0;
  *(_QWORD *)(a2 + 0x448) = 0;
  *(_QWORD *)(a1 + 0x448) = v9;
  *(_QWORD *)(a1 + 0x450) = v8;
  *(_QWORD *)(a1 + 0x458) = v7;
  v10 = *(_QWORD *)(a2 + 0x470);
  v11 = *(_QWORD *)(a2 + 0x468);
  v12 = *(_QWORD *)(a2 + 0x460);
  *(_QWORD *)(a2 + 0x470) = 0;
  *(_QWORD *)(a2 + 0x468) = 0;
  *(_QWORD *)(a2 + 0x460) = 0;
  *(_QWORD *)(a1 + 0x460) = v12;
  *(_QWORD *)(a1 + 0x468) = v11;
  *(_QWORD *)(a1 + 0x470) = v10;
  *(_OWORD *)(a1 + 0x478) = *(_OWORD *)(a2 + 0x478);
  *(_QWORD *)(a1 + 0x488) = *(_QWORD *)(a2 + 0x488);
  *(_QWORD *)(a1 + 0x490) = *(_QWORD *)(a2 + 0x490);
  *(_BYTE *)(a1 + 0x498) = *(_BYTE *)(a2 + 0x498);
  v13 = *(_QWORD *)(a2 + 0x4A0);
  v14 = *(_QWORD *)(a2 + 0x4B0);
  v15 = *(_QWORD *)(a2 + 0x4A8);
  *(_QWORD *)(a2 + 0x4B0) = 0;
  *(_QWORD *)(a2 + 0x4A8) = 0;
  *(_QWORD *)(a2 + 0x4A0) = 0;
  *(_QWORD *)(a1 + 0x4A0) = v13;
  result = a1;
  *(_QWORD *)(a1 + 0x4A8) = v15;
  *(_QWORD *)(a1 + 0x4B0) = v14;
  return result;
}

// --- End Function: sub_1430EE270 (0x1430EE270) ---

// --- Function: sub_1430EE430 (0x1430EE430) ---
__int64 __fastcall sub_1430EE430(__int64 a1)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x228) = a1 + 0x230;
  result = a1;
  *(_QWORD *)(a1 + 8) = 0x1FF;
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0x1FF;
  *(_QWORD *)(a1 + 0x430) = 0;
  *(_QWORD *)(a1 + 0x438) = 0;
  *(_QWORD *)(a1 + 0x440) = 0;
  *(_QWORD *)(a1 + 0x448) = 0;
  *(_QWORD *)(a1 + 0x450) = 0;
  *(_QWORD *)(a1 + 0x458) = 0;
  *(_QWORD *)(a1 + 0x460) = 0;
  *(_QWORD *)(a1 + 0x468) = 0;
  *(_QWORD *)(a1 + 0x470) = 0;
  *(_OWORD *)(a1 + 0x478) = xmmword_1488844C0;
  *(_DWORD *)(a1 + 0x490) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x494) = 0;
  *(_QWORD *)(a1 + 0x4A0) = 0;
  *(_QWORD *)(a1 + 0x4A8) = 0;
  *(_QWORD *)(a1 + 0x4B0) = 0;
  *(_QWORD *)(a1 + 0x488) = 0;
  *(_BYTE *)(a1 + 0x498) = 3;
  return result;
}

// --- End Function: sub_1430EE430 (0x1430EE430) ---

// --- Function: sub_1430F5D00 (0x1430F5D00) ---
__int64 __fastcall sub_1430F5D00(_QWORD *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rcx
  _QWORD *v4; // rcx
  __int64 result; // rax

  sub_1426B72B0(a1 + 0x8A);
  v2 = a1[0x87];
  if ( v2 )
  {
    if ( ((a1[0x89] - v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = *(_QWORD *)(v2 - 8);
    }
    sub_1402A6590(v2);
    a1[0x87] = 0;
    a1[0x88] = 0;
    a1[0x89] = 0;
  }
  v3 = (_QWORD *)a1[0x45];
  if ( v3 != a1 + 0x46 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - a1[0x44];
    sub_147715880(v3);
  }
  v4 = (_QWORD *)a1[2];
  result = (__int64)(a1 + 3);
  if ( v4 != a1 + 3 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
    return sub_147715880(v4);
  }
  return result;
}

// --- End Function: sub_1430F5D00 (0x1430F5D00) ---

// --- Function: sub_143113A90 (0x143113A90) ---
__int64 __fastcall sub_143113A90(__int64 a1, __int64 a2, _QWORD *a3)
{
  void (__fastcall *v3)(__int64, __int64); // rbp
  __int64 v7; // rax
  __int64 v8; // rax
  _BYTE v10[1240]; // [rsp+20h] [rbp-4D8h] BYREF

  v3 = *(void (__fastcall **)(__int64, __int64))a1;
  if ( *(_QWORD *)(a1 + 8) == 1 )
  {
    v7 = sub_1430EE270((__int64)v10, (__int64)a3);
    v3(a2, v7);
  }
  else
  {
    v8 = sub_1430EE270((__int64)v10, (__int64)a3);
    ((void (__fastcall *)(__int64, __int64, __int64))v3)(a1, a2, v8);
  }
  return sub_14265C210(a3);
}

// --- End Function: sub_143113A90 (0x143113A90) ---

// --- Function: sub_143113B00 (0x143113B00) ---
void __fastcall sub_143113B00(_QWORD *a1, unsigned __int64 *a2)
{
  __int64 v2; // rbx
  _QWORD *v4; // r15
  __int64 v5; // rdi
  int v6; // esi
  __int64 v7; // r8
  unsigned __int64 v8; // rax
  unsigned __int64 *v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r11
  __int64 v12; // rax
  bool v13; // cf
  bool v14; // cf
  __int64 v15; // rsi
  const wchar_t *v16; // rax
  __int64 v17; // rbx
  __int64 v18; // r8
  __int64 n0x1FF; // r12
  _BYTE *v20; // r15
  size_t n0x1FF_3; // rbx
  _BYTE *Src_1; // rdx
  __int64 Src_6; // rax
  __int64 v24; // rbx
  _BYTE *v25; // rax
  size_t Size_2; // r15
  void *Src_2; // rdx
  __int64 n0x1FF_5; // rcx
  __int64 v29; // rax
  __int64 v30; // rax
  size_t n0x1FF_6; // r15
  void *Src_5; // rdx
  __int64 v33; // rax
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  _BYTE *v36; // rcx
  _QWORD *v37; // rax
  int v38; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v40; // [rsp+30h] [rbp-D0h] BYREF
  void *Src_3; // [rsp+38h] [rbp-C8h]
  const void *v42; // [rsp+40h] [rbp-C0h] BYREF
  void *v43; // [rsp+48h] [rbp-B8h] BYREF
  unsigned __int64 v44; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v45; // [rsp+58h] [rbp-A8h]
  char v46; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v47; // [rsp+68h] [rbp-98h] BYREF
  _QWORD *v48; // [rsp+70h] [rbp-90h]
  _BYTE v49[1208]; // [rsp+78h] [rbp-88h] BYREF
  _BYTE v50[1208]; // [rsp+530h] [rbp+430h] BYREF
  _BYTE v51[1208]; // [rsp+9E8h] [rbp+8E8h] BYREF
  size_t Size; // [rsp+EA0h] [rbp+DA0h] BYREF
  __int64 n0x1FF_2; // [rsp+EA8h] [rbp+DA8h]
  void *Src; // [rsp+EB0h] [rbp+DB0h]
  _BYTE v55[512]; // [rsp+EB8h] [rbp+DB8h] BYREF
  size_t n0x1FF_7; // [rsp+10B8h] [rbp+FB8h] BYREF
  __int64 n0x1FF_4; // [rsp+10C0h] [rbp+FC0h]
  _BYTE *Src_4; // [rsp+10C8h] [rbp+FC8h]
  _BYTE v59[512]; // [rsp+10D0h] [rbp+FD0h] BYREF
  size_t Size_1; // [rsp+12D0h] [rbp+11D0h] BYREF
  __int64 n0x1FF_1; // [rsp+12D8h] [rbp+11D8h]
  _BYTE *v62; // [rsp+12E0h] [rbp+11E0h]
  _BYTE v63[520]; // [rsp+12E8h] [rbp+11E8h] BYREF

  v2 = *a1;
  v4 = a1;
  v48 = a1;
  v5 = v2 + 0xB8;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0xC8) == v6 )
  {
    ++*(_DWORD *)(v2 + 0xCC);
  }
  else
  {
    v7 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v8 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
    if ( v8 )
      sub_1403E1120(v2 + 0xB8, v8, v7, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v2 + 0xC0) = v7;
    *(_DWORD *)(v2 + 0xC8) = v6;
  }
  v9 = *(unsigned __int64 **)(v2 + 0xA0);
  v10 = (*(_QWORD *)(v2 + 0xA8) - (_QWORD)v9) / 0x4C8LL;
  if ( v10 )
  {
    v11 = *a2;
    do
    {
      v12 = 0x99 * (v10 >> 1);
      v13 = v9[v12] < v11;
      if ( v9[v12] == v11 )
        v13 = v9[v12 + 1] < a2[1];
      if ( v13 )
      {
        v9 = (unsigned __int64 *)((char *)v9 + v12 * 8 + 0x4C8);
        v10 += 0xFFFFFFFFFFFFFFFFuLL - (v10 >> 1);
      }
      else
      {
        v10 >>= 1;
      }
    }
    while ( v10 );
  }
  if ( v9 == *(unsigned __int64 **)(v2 + 0xA8) )
    goto LABEL_57;
  v14 = *a2 < *v9;
  if ( *a2 == *v9 )
    v14 = a2[1] < v9[1];
  if ( v14 )
  {
LABEL_57:
    memset(v50, 0, sizeof(v50));
    v36 = v50;
    goto LABEL_58;
  }
  v15 = (__int64)(v9 + 2);
  (*(void (__fastcall **)(__int64, unsigned __int64 *, unsigned __int64))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
    qword_149C8DFC0,
    &v47,
    a2[2]);
  if ( !is_entity_descriptor_valid_or_accessible(&v47) )
  {
    memset(v49, 0, sizeof(v49));
    v36 = v49;
LABEL_58:
    v37 = (_QWORD *)sub_1430EE430((__int64)v36);
    sub_143113A90((__int64)(a2 + 3), *(_QWORD *)(*v4 + 0x80LL), v37);
    goto LABEL_59;
  }
  sub_14035E090(&v42);
  sub_14035E090(&v43);
  v44 = a2[2];
  v45 = 0;
  v46 = 0;
  sub_14035E2A0(&v40);
  if ( (*(unsigned __int8 (__fastcall **)(__int64, unsigned __int64, __int64 *))(*(_QWORD *)qword_149C8E070 + 0x58LL))(
         qword_149C8E070,
         a2[2],
         &v40) )
  {
    v16 = (const wchar_t *)sub_1402A4EC0((__int64)&v40);
    sub_1403ACC80(&v43, "%ls", v16);
  }
  v17 = *(_QWORD *)(v15 + 0x438);
  if ( v17 == *(_QWORD *)(v15 + 0x440) )
  {
    sub_1430A1D80((__int64 *)(v15 + 0x430), *(_QWORD **)(v15 + 0x438), (__int64)&v42);
  }
  else
  {
    sub_14035DE10(*(void ***)(v15 + 0x438), &v42);
    sub_14035DE10((void **)(v17 + 8), (const void **)&v43);
    *(_QWORD *)(v17 + 0x10) = v44;
    *(_QWORD *)(v17 + 0x18) = v45;
    *(_BYTE *)(v17 + 0x20) = v46;
    *(_QWORD *)(v15 + 0x438) += 0x28LL;
  }
  if ( *((_BYTE *)a2 + 0x30) )
  {
    v18 = a2[2];
    v63[0] = 0;
    Size_1 = 0;
    n0x1FF = 0x1FF;
    v62 = v63;
    n0x1FF_1 = 0x1FF;
    sub_1402A59F0((__int64)&Size_1, "%llu", v18);
    v20 = (_BYTE *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v47 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v47 & 0xFFFFFFFFFFFFLL);
    v55[0] = 0;
    Size = 0;
    Src = v55;
    n0x1FF_2 = 0x1FF;
    if ( v20 )
    {
      n0x1FF_3 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++n0x1FF_3;
      while ( v20[n0x1FF_3] );
      if ( n0x1FF_3 )
      {
        Src_1 = v55;
        if ( n0x1FF_3 + 1 > 0x200 )
        {
          Src_6 = allocWithProfilerInfo(n0x1FF_3 + 1, 0);
          n0x1FF_2 = n0x1FF_3;
          qword_149C78668 += n0x1FF_3 + 1;
          Src_1 = (_BYTE *)Src_6;
        }
        Src = Src_1;
        Size = n0x1FF_3;
        Src_1[n0x1FF_3] = 0;
        memcpy(Src, v20, n0x1FF_3);
      }
    }
    Src_4 = v59;
    v59[0] = 0;
    n0x1FF_7 = 0;
    n0x1FF_4 = 0x1FF;
    sub_1402A6440((__int64)&n0x1FF_7, v62, Size_1);
    v24 = *(_QWORD *)(v15 + 0x468);
    if ( v24 == *(_QWORD *)(v15 + 0x470) )
    {
      sub_1430A1FD0((__int64 *)(v15 + 0x460), *(_QWORD *)(v15 + 0x468), (__int64)&Size);
    }
    else
    {
      v25 = (_BYTE *)(v24 + 0x18);
      *(_BYTE *)(v24 + 0x18) = 0;
      *(_QWORD *)(v24 + 0x10) = v24 + 0x18;
      *(_QWORD *)v24 = 0;
      *(_QWORD *)(v24 + 8) = 0x1FF;
      Size_2 = Size;
      Src_2 = Src;
      Src_3 = Src;
      if ( Size > 0x1FF )
      {
        *v25 = 0;
        *(_QWORD *)v24 = 0;
        *(_QWORD *)(v24 + 0x10) = v25;
        *(_QWORD *)(v24 + 8) = 0x1FF;
        if ( Size_2 + 1 <= 0x200 )
        {
          n0x1FF_5 = 0x1FF;
        }
        else
        {
          v25 = (_BYTE *)allocWithProfilerInfo(Size_2 + 1, 0);
          Src_2 = Src_3;
          qword_149C78668 += Size_2 + 1;
          n0x1FF_5 = Size_2;
        }
        *(_QWORD *)(v24 + 8) = n0x1FF_5;
        *(_QWORD *)v24 = Size_2;
        *(_QWORD *)(v24 + 0x10) = v25;
        v25[Size_2] = 0;
      }
      memmove(*(void **)(v24 + 0x10), Src_2, Size_2);
      v29 = *(_QWORD *)(v24 + 0x10);
      *(_QWORD *)v24 = Size_2;
      *(_BYTE *)(Size_2 + v29) = 0;
      v30 = v24 + 0x230;
      *(_BYTE *)(v24 + 0x230) = 0;
      *(_QWORD *)(v24 + 0x228) = v24 + 0x230;
      *(_QWORD *)(v24 + 0x218) = 0;
      *(_QWORD *)(v24 + 0x220) = 0x1FF;
      n0x1FF_6 = n0x1FF_7;
      Src_5 = Src_4;
      Src_3 = Src_4;
      if ( n0x1FF_7 > 0x1FF )
      {
        if ( n0x1FF_7 + 1 > 0x200 )
        {
          v30 = allocWithProfilerInfo(n0x1FF_7 + 1, 0);
          Src_5 = Src_3;
          qword_149C78668 += n0x1FF_6 + 1;
          n0x1FF = n0x1FF_6;
        }
        *(_QWORD *)(v24 + 0x220) = n0x1FF;
        *(_QWORD *)(v24 + 0x218) = n0x1FF_6;
        *(_QWORD *)(v24 + 0x228) = v30;
        *(_BYTE *)(n0x1FF_6 + v30) = 0;
      }
      memmove(*(void **)(v24 + 0x228), Src_5, n0x1FF_6);
      v33 = *(_QWORD *)(v24 + 0x228);
      *(_QWORD *)(v24 + 0x218) = n0x1FF_6;
      *(_BYTE *)(n0x1FF_6 + v33) = 0;
      *(_QWORD *)(v15 + 0x468) += 0x430LL;
    }
    if ( Src_4 != v59 )
    {
      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_4;
      sub_147715880(Src_4);
    }
    if ( Src != v55 )
    {
      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_2;
      sub_147715880(Src);
    }
    if ( v62 != v63 )
    {
      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
      sub_147715880(v62);
    }
    v4 = v48;
  }
  else
  {
    v35 = *(_BYTE **)(v15 + 0x450);
    if ( v35 == *(_BYTE **)(v15 + 0x458) )
    {
      sub_1402A93C0(v15 + 0x448, v35, &v44);
    }
    else
    {
      *(_QWORD *)v35 = v44;
      *(_QWORD *)(v15 + 0x450) += 8LL;
    }
  }
  v34 = (_QWORD *)sub_142659050((__int64)v51, v15);
  sub_143113A90((__int64)(a2 + 3), *(_QWORD *)(*v4 + 0x80LL), v34);
  sub_140373CC0(&v40);
  sub_140373CC0(&v43);
  sub_140373CC0(&v42);
LABEL_59:
  if ( v5 )
  {
    v38 = *(_DWORD *)(v5 + 0x14);
    if ( v38 )
    {
      *(_DWORD *)(v5 + 0x14) = v38 - 1;
    }
    else
    {
      *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v5 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v5, n0x200000);
    }
  }
}

// --- End Function: sub_143113B00 (0x143113B00) ---

// --- Function: sub_1431141D0 (0x1431141D0) ---
__int64 __fastcall sub_1431141D0(__int64 *a1, __int64 a2)
{
  __int128 v2; // xmm6
  __int64 *v3; // r13
  __int128 v5; // xmm6
  size_t Size; // r8
  const void *v7; // rdx
  __int64 *v8; // r14
  __int64 *v9; // rdi
  __int64 v10; // rsi
  const wchar_t *v11; // rax
  __int64 v12; // rbx
  size_t *p_Size; // rsi
  size_t *p_Size_1; // r15
  _BYTE *v15; // rdx
  size_t Size_1; // r8
  int *v17; // rax
  const char *EndPtr_1; // rdi
  int *v19; // r14
  unsigned __int64 v20; // rbx
  __int64 v21; // rcx
  const wchar_t *v22; // rax
  __int64 v23; // rbx
  __int64 v24; // rsi
  __int64 v25; // rbx
  int v26; // edi
  __int64 v27; // r8
  unsigned __int64 v28; // rax
  __int64 v29; // r8
  unsigned __int64 v30; // rdx
  __int64 v31; // rax
  bool v32; // cf
  bool v33; // cf
  int v34; // eax
  unsigned __int64 n0x200000; // rax
  _QWORD *v36; // rbx
  void (__fastcall *v37)(__int64, __int64); // r14
  __int64 v38; // rsi
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 *v42; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v43; // [rsp+38h] [rbp-C8h] BYREF
  const void *v44; // [rsp+40h] [rbp-C0h] BYREF
  void *v45; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v46; // [rsp+50h] [rbp-B0h]
  __int64 v47; // [rsp+58h] [rbp-A8h]
  char v48; // [rsp+60h] [rbp-A0h]
  const void *v49; // [rsp+68h] [rbp-98h] BYREF
  void *v50; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int64 v51; // [rsp+78h] [rbp-88h]
  __int64 v52; // [rsp+80h] [rbp-80h]
  char v53; // [rsp+88h] [rbp-78h]
  __int64 v54; // [rsp+90h] [rbp-70h] BYREF
  char *EndPtr; // [rsp+98h] [rbp-68h] BYREF
  __int64 v56; // [rsp+A0h] [rbp-60h] BYREF
  _BYTE v57[1208]; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE v58[1208]; // [rsp+560h] [rbp+460h] BYREF
  char *String[2]; // [rsp+A18h] [rbp+918h] BYREF
  __int64 v60; // [rsp+A28h] [rbp+928h]
  unsigned __int64 n0xF; // [rsp+A30h] [rbp+930h]
  __int128 v62; // [rsp+A40h] [rbp+940h] BYREF
  _QWORD v63[3]; // [rsp+A50h] [rbp+950h] BYREF
  char v64; // [rsp+A68h] [rbp+968h] BYREF
  __int64 v65; // [rsp+C68h] [rbp+B68h]
  __int64 n0x1FF; // [rsp+C70h] [rbp+B70h]
  char *v67; // [rsp+C78h] [rbp+B78h]
  char v68; // [rsp+C80h] [rbp+B80h] BYREF
  __int128 v69; // [rsp+E80h] [rbp+D80h] BYREF
  __int64 v70; // [rsp+E90h] [rbp+D90h]
  __int64 v71; // [rsp+E98h] [rbp+D98h] BYREF
  _BYTE *v72; // [rsp+EA0h] [rbp+DA0h]
  _BYTE *v73; // [rsp+EA8h] [rbp+DA8h]
  __int128 v74; // [rsp+EB0h] [rbp+DB0h] BYREF
  __int64 v75; // [rsp+EC0h] [rbp+DC0h]
  __int128 v76; // [rsp+EC8h] [rbp+DC8h]
  __int64 v77; // [rsp+ED8h] [rbp+DD8h]
  unsigned int v78; // [rsp+EE0h] [rbp+DE0h]
  char v79; // [rsp+EE4h] [rbp+DE4h]
  char n3; // [rsp+EE8h] [rbp+DE8h]
  __int128 v81; // [rsp+EF0h] [rbp+DF0h]
  __int64 v82; // [rsp+F00h] [rbp+E00h]
  __int128 v83; // [rsp+F10h] [rbp+E10h] BYREF
  _QWORD v84[152]; // [rsp+F20h] [rbp+E20h] BYREF
  __int128 v85; // [rsp+13F0h] [rbp+12F0h]

  v85 = v2;
  v3 = a1;
  v42 = a1;
  (*(void (__fastcall **)(__int64, __int128 *))(*(_QWORD *)qword_149C8DFE0 + 0x700LL))(qword_149C8DFE0, &v62);
  v5 = v62;
  Size = *(_QWORD *)a2;
  v7 = *(const void **)(a2 + 0x10);
  v63[2] = &v64;
  v64 = 0;
  v67 = &v68;
  v63[0] = 0;
  v63[1] = 0x1FF;
  v68 = 0;
  v65 = 0;
  n0x1FF = 0x1FF;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v77 = 0;
  v78 = 0xFFFFFFFF;
  v79 = 0;
  n3 = 3;
  v81 = 0;
  v82 = 0;
  v76 = v62;
  sub_1402A6440((__int64)v63, v7, Size);
  v8 = *(__int64 **)(a2 + 0x440);
  v9 = *(__int64 **)(a2 + 0x438);
  n3 = *(_BYTE *)(a2 + 0x430);
  if ( v9 != v8 )
  {
    do
    {
      v54 = *v9;
      v10 = v54;
      sub_14035E090(&v44);
      sub_14035E090(&v45);
      v47 = 0;
      v48 = 0;
      v46 = v10;
      sub_14035E2A0(&v43);
      if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)qword_149C8E070 + 0x58LL))(
             qword_149C8E070,
             v10,
             &v43) )
      {
        v11 = (const wchar_t *)sub_1402A4EC0((__int64)&v43);
        sub_1403ACC80(&v45, "%ls", v11);
      }
      v12 = *((_QWORD *)&v69 + 1);
      if ( *((_QWORD *)&v69 + 1) == v70 )
      {
        sub_1430A1D80((__int64 *)&v69, *((_QWORD **)&v69 + 1), (__int64)&v44);
      }
      else
      {
        sub_14035DE10(*((void ***)&v69 + 1), &v44);
        sub_14035DE10((void **)(v12 + 8), (const void **)&v45);
        *(_QWORD *)(v12 + 0x10) = v46;
        *(_QWORD *)(v12 + 0x18) = v47;
        *(_BYTE *)(v12 + 0x20) = v48;
        *((_QWORD *)&v69 + 1) += 0x28LL;
      }
      if ( v72 == v73 )
      {
        sub_1402A93C0((__int64)&v71, v72, &v54);
      }
      else
      {
        *(_QWORD *)v72 = v10;
        v72 += 8;
      }
      sub_140373CC0(&v43);
      sub_140373CC0(&v45);
      sub_140373CC0(&v44);
      ++v9;
    }
    while ( v9 != v8 );
    v3 = v42;
  }
  p_Size = *(size_t **)(a2 + 0x450);
  for ( p_Size_1 = *(size_t **)(a2 + 0x458); p_Size != p_Size_1; p_Size += 0x86 )
  {
    v15 = (_BYTE *)p_Size[0x45];
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    *(_OWORD *)String = 0;
    v60 = 0;
    n0xF = 0;
    do
      ++Size_1;
    while ( v15[Size_1] );
    sub_1402FD830(String, v15, Size_1);
    v17 = errno();
    EndPtr_1 = (const char *)String;
    if ( n0xF > 0xF )
      EndPtr_1 = String[0];
    v19 = v17;
    *v17 = 0;
    v20 = strtoull(EndPtr_1, &EndPtr, 0xA);
    if ( EndPtr_1 == EndPtr )
    {
      std::_Xinvalid_argument("invalid stoull argument");
      __debugbreak();
    }
    if ( *v19 == 0x22 )
    {
      std::_Xout_of_range("stoull argument out of range");
      JUMPOUT(0x1431148CDLL);
    }
    if ( n0xF > 0xF )
    {
      v21 = (__int64)String[0];
      if ( n0xF + 1 >= 0x1000 )
      {
        v21 = *((_QWORD *)String[0] + 0xFFFFFFFF);
        if ( (unsigned __int64)&String[0][-v21 - 8] > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A6590(v21);
    }
    sub_14035E090(&v49);
    sub_14035E090(&v50);
    v51 = v20;
    v52 = 0;
    v53 = 0;
    sub_14035E2A0(&v42);
    if ( (*(unsigned __int8 (__fastcall **)(__int64, unsigned __int64, __int64 **))(*(_QWORD *)qword_149C8E070 + 0x58LL))(
           qword_149C8E070,
           v20,
           &v42) )
    {
      v22 = (const wchar_t *)sub_1402A4EC0((__int64)&v42);
      sub_1403ACC80(&v50, "%ls", v22);
    }
    v23 = *((_QWORD *)&v69 + 1);
    if ( *((_QWORD *)&v69 + 1) == v70 )
    {
      sub_1430A1D80((__int64 *)&v69, *((_QWORD **)&v69 + 1), (__int64)&v49);
    }
    else
    {
      sub_14035DE10(*((void ***)&v69 + 1), &v49);
      sub_14035DE10((void **)(v23 + 8), (const void **)&v50);
      *(_QWORD *)(v23 + 0x10) = v51;
      *(_QWORD *)(v23 + 0x18) = v52;
      *(_BYTE *)(v23 + 0x20) = v53;
      *((_QWORD *)&v69 + 1) += 0x28LL;
    }
    if ( *((_QWORD *)&v74 + 1) == v75 )
    {
      sub_1430A1FD0((__int64 *)&v74, *((__int64 *)&v74 + 1), p_Size);
    }
    else
    {
      sub_1426595C0(*((__int64 *)&v74 + 1), (__int64)p_Size);
      *((_QWORD *)&v74 + 1) += 0x430LL;
    }
    sub_140373CC0(&v42);
    sub_140373CC0(&v50);
    sub_140373CC0(&v49);
  }
  v24 = *v3;
  v25 = *v3 + 0xB8;
  v26 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v25 + 0x10) == v26 )
  {
    ++*(_DWORD *)(v25 + 0x14);
  }
  else
  {
    v27 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v28 = _InterlockedCompareExchange64((volatile signed __int64 *)v25, 0x200000, 0);
    if ( v28 )
      sub_1403E1120(v25, v28, v27, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v25 + 8) = v27;
    *(_DWORD *)(v25 + 0x10) = v26;
  }
  v83 = v5;
  sub_142659050((__int64)v84, (__int64)v63);
  v29 = *(_QWORD *)(v24 + 0xA0);
  v30 = (*(_QWORD *)(v24 + 0xA8) - v29) / 0x4C8;
  while ( v30 )
  {
    v31 = 0x4C8 * (v30 >> 1);
    v32 = *(_QWORD *)(v31 + v29) < (unsigned __int64)v83;
    if ( *(_QWORD *)(v31 + v29) == (_QWORD)v83 )
      v32 = *(_QWORD *)(v31 + v29 + 8) < *((_QWORD *)&v83 + 1);
    if ( v32 )
    {
      v29 += v31 + 0x4C8;
      v30 += 0xFFFFFFFFFFFFFFFFuLL - (v30 >> 1);
    }
    else
    {
      v30 >>= 1;
    }
  }
  if ( v29 == *(_QWORD *)(v24 + 0xA8) )
    goto LABEL_51;
  v33 = (unsigned __int64)v83 < *(_QWORD *)v29;
  if ( (_QWORD)v83 == *(_QWORD *)v29 )
    v33 = *((_QWORD *)&v83 + 1) < *(_QWORD *)(v29 + 8);
  if ( v33 )
LABEL_51:
    sub_1430E0B00(v24 + 0xA0, &v56, (_OWORD *)v29, &v83);
  sub_14265C210(v84);
  if ( v25 )
  {
    v34 = *(_DWORD *)(v25 + 0x14);
    if ( v34 )
    {
      *(_DWORD *)(v25 + 0x14) = v34 - 1;
    }
    else
    {
      *(_DWORD *)(v25 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v25, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v25 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v25, n0x200000);
    }
  }
  v36 = (_QWORD *)sub_142659050((__int64)v58, (__int64)v63);
  v37 = *(void (__fastcall **)(__int64, __int64))(a2 + 0x478);
  v38 = *(_QWORD *)(*v3 + 0x80);
  if ( *(_QWORD *)(a2 + 0x480) == 1 )
  {
    v39 = sub_1430EE270((__int64)v57, (__int64)v36);
    v37(v38, v39);
  }
  else
  {
    v40 = sub_1430EE270((__int64)v57, (__int64)v36);
    ((void (__fastcall *)(__int64, __int64, __int64))v37)(a2 + 0x478, v38, v40);
  }
  sub_14265C210(v36);
  return sub_14265C210(v63);
}

// --- End Function: sub_1431141D0 (0x1431141D0) ---

// --- Function: sub_1431148D0 (0x1431148D0) ---
__int64 __fastcall sub_1431148D0(__int64 a1, unsigned __int64 *a2)
{
  __int64 v4; // r14
  __int64 p_rw_lock_state; // rdi
  signed __int64 v6; // rdx
  unsigned __int64 *v7; // rcx
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // rsi
  __int64 v10; // rax
  bool v11; // cf
  bool v12; // zf
  bool v13; // cf
  _QWORD *v14; // rax
  _BYTE v16[1216]; // [rsp+30h] [rbp-4C8h] BYREF

  v4 = *(_QWORD *)a1 + 0xA0LL;
  p_rw_lock_state = *(_QWORD *)a1 + 0xB8LL;
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state + 0x14);
  }
  else
  {
    v6 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (v6 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(p_rw_lock_state, v6, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  v7 = *(unsigned __int64 **)v4;
  v8 = (*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) / 0x4C8LL;
  if ( v8 )
  {
    v9 = *a2;
    do
    {
      v10 = 0x99 * (v8 >> 1);
      v11 = v7[v10] < v9;
      if ( v7[v10] == v9 )
        v11 = v7[v10 + 1] < a2[1];
      if ( v11 )
      {
        v7 = (unsigned __int64 *)((char *)v7 + v10 * 8 + 0x4C8);
        v8 += 0xFFFFFFFFFFFFFFFFuLL - (v8 >> 1);
      }
      else
      {
        v8 >>= 1;
      }
    }
    while ( v8 );
  }
  v12 = v7 == *(unsigned __int64 **)(v4 + 8);
  if ( v7 != *(unsigned __int64 **)(v4 + 8) )
  {
    v13 = *a2 < *v7;
    if ( *a2 == *v7 )
      v13 = a2[1] < v7[1];
    if ( v13 )
      v7 = *(unsigned __int64 **)(v4 + 8);
    v12 = v7 == *(unsigned __int64 **)(v4 + 8);
  }
  if ( v12 )
  {
    memset(v16, 0, 0x4B8u);
    v14 = (_QWORD *)sub_1430EE430((__int64)v16);
  }
  else
  {
    v14 = (_QWORD *)sub_142659050((__int64)v16, (__int64)(v7 + 2));
  }
  sub_143113A90((__int64)(a2 + 2), *(_QWORD *)(*(_QWORD *)a1 + 0x80LL), v14);
  return rw_lock_release_read_lock(p_rw_lock_state);
}

// --- End Function: sub_1431148D0 (0x1431148D0) ---

// --- Function: sub_143114A60 (0x143114A60) ---
__int64 __fastcall sub_143114A60(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rbx
  unsigned __int64 v3; // r15
  __int64 v4; // r14
  volatile signed __int64 *p_rw_lock_state; // r12
  signed __int64 v7; // rdx
  __int64 v8; // rdi
  __int64 v9; // rbx
  __int64 v10; // rsi
  __int64 v11; // rbp
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rbx
  unsigned __int64 v15; // rbp
  __int64 i; // rdi
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rdi
  __int64 v19; // rax
  bool v20; // zf
  void (__fastcall *v21)(_QWORD, _QWORD *); // rax
  __int128 v23; // [rsp+30h] [rbp-58h] BYREF
  __int64 v24; // [rsp+40h] [rbp-48h]
  _QWORD v25[3]; // [rsp+48h] [rbp-40h] BYREF

  v2 = *a1;
  v3 = 0;
  v4 = *a2;
  v23 = 0;
  p_rw_lock_state = (volatile signed __int64 *)(v2 + 0xB8);
  v24 = 0;
  if ( *(_DWORD *)(v2 + 0xC8) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v2 + 0xCC);
  }
  else
  {
    v7 = _InterlockedIncrement64(p_rw_lock_state);
    if ( (v7 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v2 + 0xB8, v7, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  v8 = *(_QWORD *)(v2 + 0xA8);
  v9 = *(_QWORD *)(v2 + 0xA0);
  v10 = *((_QWORD *)&v23 + 1);
  if ( v9 != v8 )
  {
    v11 = v9 + 0x10;
    do
    {
      v12 = *(_QWORD *)(v11 + 0x430);
      v13 = *(_QWORD *)(v11 + 0x438);
      if ( v12 != v13 )
      {
        while ( *(_QWORD *)(v12 + 0x10) != v4 )
        {
          v12 += 0x28;
          if ( v12 == v13 )
            goto LABEL_14;
        }
        if ( v10 == v24 )
        {
          sub_1430A1B50((__int64 *)&v23, v10, v11);
          v10 = *((_QWORD *)&v23 + 1);
        }
        else
        {
          sub_142659050(v10, v11);
          v10 += 0x4B8;
          *((_QWORD *)&v23 + 1) = v10;
        }
      }
LABEL_14:
      v9 += 0x4C8;
      v11 += 0x4C8;
    }
    while ( v9 != v8 );
  }
  v14 = v23;
  v15 = 0;
  i = 0;
  v17 = (v10 - (__int64)v23) / 0x4B8;
  if ( v17 )
  {
    if ( v17 > 0x36406C80D901B2LL )
      unknown_libname_10();
    v18 = 0x4B8 * v17;
    if ( 0x4B8 * v17 < 0x1000 )
    {
      if ( v18 )
        v3 = sub_1402A65A0(0x4B8 * v17);
    }
    else
    {
      if ( v18 + 0x27 < v18 )
        sub_1402E3880();
      v19 = sub_1402A65A0(v18 + 0x27);
      if ( !v19 )
        invalid_parameter_noinfo_noreturn();
      v3 = (v19 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v3 - 8) = v19;
    }
    v15 = v18 + v3;
    for ( i = v3; v14 != v10; v14 += 0x4B8 )
    {
      sub_142659050(i, v14);
      i += 0x4B8;
    }
  }
  v20 = a2[2] == 1;
  v25[0] = v3;
  v25[1] = i;
  v25[2] = v15;
  v21 = (void (__fastcall *)(_QWORD, _QWORD *))a2[1];
  if ( v20 )
    v21(*(_QWORD *)(*a1 + 0x80), v25);
  else
    ((void (__fastcall *)(__int64 *, _QWORD, _QWORD *))v21)(a2 + 1, *(_QWORD *)(*a1 + 0x80), v25);
  rw_lock_release_read_lock((__int64)p_rw_lock_state);
  return sub_1431EAF40(&v23);
}

// --- End Function: sub_143114A60 (0x143114A60) ---

// --- Function: sub_143114CC0 (0x143114CC0) ---
unsigned __int64 __fastcall sub_143114CC0(__int64 *a1, unsigned __int64 *a2)
{
  __int64 v2; // rbx
  __int64 v5; // r13
  int v6; // edi
  __int64 v7; // r8
  unsigned __int64 v8; // rax
  unsigned __int64 *v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r11
  __int64 v12; // rax
  bool v13; // cf
  bool v14; // cf
  unsigned __int64 v15; // r14
  _QWORD *v16; // r15
  unsigned __int64 v17; // rax
  void **v18; // rsi
  void **v19; // rbx
  _QWORD *v20; // rax
  unsigned __int64 n0x200000; // rax
  unsigned __int64 v22; // rdi
  __int64 v23; // rbx
  __int64 v24; // r8
  size_t *v25; // r10
  size_t *i; // rbx
  size_t v27; // rax
  char *v28; // r8
  int v29; // ecx
  int v30; // edx
  size_t *v31; // r14
  size_t *v32; // rsi
  __int64 v33; // rdi
  _QWORD *v34; // rcx
  _BYTE *v35; // r8
  _BYTE *v36; // rdx
  _QWORD *v37; // rax
  int v38; // eax
  __int64 v40; // [rsp+38h] [rbp-C8h] BYREF
  __int64 n0x1FF_1; // [rsp+40h] [rbp-C0h]
  char *v42; // [rsp+48h] [rbp-B8h]
  _BYTE v43[512]; // [rsp+50h] [rbp-B0h] BYREF
  _BYTE v44[1208]; // [rsp+250h] [rbp+150h] BYREF
  _BYTE v45[1208]; // [rsp+708h] [rbp+608h] BYREF
  _BYTE v46[1216]; // [rsp+BC0h] [rbp+AC0h] BYREF
  size_t Size; // [rsp+1080h] [rbp+F80h] BYREF
  __int64 n0x1FF; // [rsp+1088h] [rbp+F88h]
  _BYTE *v49; // [rsp+1090h] [rbp+F90h]
  _BYTE v50[520]; // [rsp+1098h] [rbp+F98h] BYREF

  v2 = *a1;
  v5 = *a1 + 0xB8;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0xC8) == v6 )
  {
    ++*(_DWORD *)(v2 + 0xCC);
  }
  else
  {
    v7 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v8 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
    if ( v8 )
      sub_1403E1120(v2 + 0xB8, v8, v7, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v2 + 0xC0) = v7;
    *(_DWORD *)(v2 + 0xC8) = v6;
  }
  v9 = *(unsigned __int64 **)(v2 + 0xA0);
  v10 = (*(_QWORD *)(v2 + 0xA8) - (_QWORD)v9) / 0x4C8LL;
  if ( v10 )
  {
    v11 = *a2;
    do
    {
      v12 = 0x99 * (v10 >> 1);
      v13 = v9[v12] < v11;
      if ( v9[v12] == v11 )
        v13 = v9[v12 + 1] < a2[1];
      if ( v13 )
      {
        v9 = (unsigned __int64 *)((char *)v9 + v12 * 8 + 0x4C8);
        v10 += 0xFFFFFFFFFFFFFFFFuLL - (v10 >> 1);
      }
      else
      {
        v10 >>= 1;
      }
    }
    while ( v10 );
  }
  if ( v9 != *(unsigned __int64 **)(v2 + 0xA8) )
  {
    v14 = *a2 < *v9;
    if ( *a2 == *v9 )
      v14 = a2[1] < v9[1];
    if ( !v14 )
    {
      v15 = a2[2];
      v16 = v9 + 2;
      v17 = v9[0x88];
      v18 = (void **)v9[0x89];
      if ( (void **)v17 != v18 )
      {
        while ( 1 )
        {
          v19 = (void **)(v17 + 0x28);
          if ( *(_QWORD *)(v17 + 0x10) == v15 )
            break;
          v17 += 0x28LL;
          if ( v19 == v18 )
            goto LABEL_22;
        }
        if ( v19 != v18 )
        {
          v22 = v17 + 0x10;
          do
          {
            sub_14037AE80((void **)(v22 - 0x10), v19);
            sub_14037AE80((void **)(v22 - 8), (void **)(v22 + 0x20));
            v19 += 5;
            *(_QWORD *)v22 = *(_QWORD *)(v22 + 0x28);
            *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 0x30);
            *(_DWORD *)(v22 + 0xC) = *(_DWORD *)(v22 + 0x34);
            *(_BYTE *)(v22 + 0x10) = *(_BYTE *)(v22 + 0x38);
            v22 += 0x28LL;
          }
          while ( v19 != v18 );
        }
        v23 = v16[0x87];
        sub_140373CC0((_QWORD *)(v23 - 0x20));
        sub_140373CC0((_QWORD *)(v23 - 0x28));
        v16[0x87] -= 0x28LL;
        if ( *((_BYTE *)a2 + 0x30) )
        {
          v24 = a2[2];
          v49 = v50;
          Size = 0;
          v50[0] = 0;
          n0x1FF = 0x1FF;
          sub_1402A59F0((__int64)&Size, "%llu", v24);
          v42 = v43;
          v43[0] = 0;
          v40 = 0;
          n0x1FF_1 = 0x1FF;
          sub_1402A6440((__int64)&v40, v49, Size);
          v25 = (size_t *)v16[0x8D];
          for ( i = (size_t *)v16[0x8C]; i != v25; i += 0x86 )
          {
            v27 = i[0x45];
            v28 = &v42[-v27];
            do
            {
              v29 = (unsigned __int8)v28[v27];
              v30 = *(unsigned __int8 *)v27 - v29;
              if ( v30 )
                break;
              ++v27;
            }
            while ( v29 );
            if ( !v30 )
              break;
          }
          if ( v42 != v43 )
          {
            qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
            sub_147715880(v42);
          }
          v31 = (size_t *)v16[0x8D];
          if ( i != v31 )
          {
            v32 = i + 0x86;
            if ( i + 0x86 != v31 )
            {
              v33 = (__int64)(i + 0x43);
              do
              {
                sub_1402A6440(v33 - 0x218, *(const void **)(v33 + 0x228), *v32);
                sub_1402A6440(v33, *(const void **)(v33 + 0x440), *(_QWORD *)(v33 + 0x430));
                v32 += 0x86;
                v33 += 0x430;
              }
              while ( v32 != v31 );
            }
            sub_140374740((_QWORD *)(v16[0x8D] - 0x430LL));
            v16[0x8D] -= 0x430LL;
          }
          if ( v49 != v50 )
          {
            qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
            sub_147715880(v49);
            v20 = (_QWORD *)sub_142659050((__int64)v46, (__int64)v16);
            goto LABEL_23;
          }
        }
        else
        {
          v34 = (_QWORD *)v16[0x89];
          v35 = (_BYTE *)v16[0x8A];
          if ( v34 != (_QWORD *)v35 )
          {
            while ( 1 )
            {
              v36 = v34 + 1;
              if ( v15 == *v34 )
                break;
              ++v34;
              if ( v36 == v35 )
              {
                v20 = (_QWORD *)sub_142659050((__int64)v46, (__int64)v16);
                goto LABEL_23;
              }
            }
            memmove(v34, v36, v35 - v36);
            v16[0x8A] -= 8LL;
          }
        }
        v20 = (_QWORD *)sub_142659050((__int64)v46, (__int64)v16);
        goto LABEL_23;
      }
LABEL_22:
      memset(v44, 0, sizeof(v44));
      v20 = (_QWORD *)sub_1430EE430((__int64)v44);
LABEL_23:
      n0x200000 = sub_143113A90((__int64)(a2 + 3), *(_QWORD *)(*a1 + 0x80), v20);
      goto LABEL_50;
    }
  }
  memset(v45, 0, sizeof(v45));
  v37 = (_QWORD *)sub_1430EE430((__int64)v45);
  n0x200000 = sub_143113A90((__int64)(a2 + 3), *(_QWORD *)(*a1 + 0x80), v37);
LABEL_50:
  if ( v5 )
  {
    v38 = *(_DWORD *)(v5 + 0x14);
    if ( v38 )
    {
      n0x200000 = (unsigned int)(v38 - 1);
      *(_DWORD *)(v5 + 0x14) = n0x200000;
    }
    else
    {
      *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v5 + 8) = &p_Src;
      else
        return (unsigned __int64)rw_lock_handle_write_release_contention(v5, n0x200000);
    }
  }
  return n0x200000;
}

// --- End Function: sub_143114CC0 (0x143114CC0) ---

// --- Function: sub_143165DE0 (0x143165DE0) ---
__int64 sub_143165DE0()
{
  return qword_149F5AFA8;
}

// --- End Function: sub_143165DE0 (0x143165DE0) ---

// --- Function: sub_1431D2700 (0x1431D2700) ---
const ULONG_PTR *__fastcall sub_1431D2700(__int64 a1)
{
  _QWORD *v2; // r8
  _QWORD *v3; // rdx
  _QWORD *i; // rax
  _QWORD *v5; // rcx
  __int64 v6; // rbp
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rbx
  __int64 v10; // rax
  size_t Size; // rbx
  const void *v12; // r8
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // rax
  int v16; // esi
  unsigned int v17; // eax
  bool v18; // si
  int v19; // eax
  const ULONG_PTR *result; // rax

  if ( *(_DWORD *)(a1 + 0x9C) )
  {
    v2 = *(_QWORD **)(a1 + 0x70);
    v3 = *(_QWORD **)(a1 + 0x68);
    for ( i = v2; v3 != v2; ++v3 )
    {
      if ( *v3 )
      {
        if ( i != v2 )
          *i++ = *v3;
      }
      else
      {
        v5 = v3;
        if ( i != v2 )
          v5 = i;
        i = v5;
      }
    }
    v6 = *(_QWORD *)(a1 + 0x70);
    v7 = *(_QWORD *)(a1 + 0x68);
    v8 = (v6 - v7) >> 3;
    v9 = v8 - *(unsigned int *)(a1 + 0x9C);
    if ( v9 < v8 )
    {
      v10 = v7 + 8 * v9;
LABEL_16:
      *(_QWORD *)(a1 + 0x70) = v10;
      goto LABEL_17;
    }
    if ( v9 > v8 )
    {
      if ( v9 <= (*(_QWORD *)(a1 + 0x78) - v7) >> 3 )
      {
        Size = 0xFFFFFFFFFFFFFFF8uLL * *(unsigned int *)(a1 + 0x9C);
        memset(*(void **)(a1 + 0x70), 0, Size);
        v10 = Size + v6;
        goto LABEL_16;
      }
      sub_1402AC770(a1 + 0x68, v9);
    }
LABEL_17:
    *(_DWORD *)(a1 + 0x9C) = 0;
  }
  v12 = *(const void **)(a1 + 0x80);
  if ( v12 != *(const void **)(a1 + 0x88) )
  {
    sub_14034C540(a1 + 0x68, *(_BYTE **)(a1 + 0x70), v12, (__int64)(*(_QWORD *)(a1 + 0x88) - (_QWORD)v12) >> 3);
    v13 = *(_QWORD *)(a1 + 0x80);
    if ( v13 != *(_QWORD *)(a1 + 0x88) )
      *(_QWORD *)(a1 + 0x88) = v13;
  }
  *(_BYTE *)(a1 + 0x98) = 1;
  v14 = *(_QWORD **)(a1 + 0x70);
  v15 = *(_QWORD **)(a1 + 0x68);
  for ( *(_QWORD *)(a1 + 0xA0) = v15; v15 != v14; v15 = *(_QWORD **)(a1 + 0xA0) )
  {
    if ( *v15 )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v15 + 0x10LL))(*v15);
    *(_QWORD *)(a1 + 0xA0) += 8LL;
  }
  *(_BYTE *)(a1 + 0x98) = 0;
  while ( 1 )
  {
    v16 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x60) == v16 )
    {
      ++*(_DWORD *)(a1 + 0x64);
    }
    else
    {
      v17 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x50), 1, 0);
      if ( v17 )
        sub_1403C6E80(a1 + 0x50, v17, (__int64)&p_Src, 1);
      else
        *(_QWORD *)(a1 + 0x58) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x60) = v16;
    }
    v18 = *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) && *(_QWORD *)(a1 + 0x18) == *(_QWORD *)(a1 + 0x20);
    v19 = *(_DWORD *)(a1 + 0x64);
    if ( v19 )
    {
      result = (const ULONG_PTR *)(unsigned int)(v19 - 1);
      *(_DWORD *)(a1 + 0x64) = (_DWORD)result;
    }
    else
    {
      *(_DWORD *)(a1 + 0x60) = 0xFFFFFFFF;
      result = (const ULONG_PTR *)(unsigned int)_InterlockedCompareExchange(
                                                  (volatile signed __int32 *)(a1 + 0x50),
                                                  0,
                                                  1);
      if ( (_DWORD)result == 1 )
        *(_QWORD *)(a1 + 0x58) = &p_Src;
      else
        result = sub_1403DF590(a1 + 0x50, (unsigned int)result);
    }
    if ( v18 )
      break;
    sub_142DD9050(a1);
  }
  return result;
}

// --- End Function: sub_1431D2700 (0x1431D2700) ---

// --- Function: sub_1431E2A30 (0x1431E2A30) ---
__int64 __fastcall sub_1431E2A30(__int64 a1)
{
  __int128 v1; // xmm6
  char v3; // si
  __int64 v4; // rax
  __int64 i; // rbx
  int n0x900; // [rsp+30h] [rbp-68h] BYREF
  __int64 v8; // [rsp+34h] [rbp-64h]
  int v9; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v10; // [rsp+40h] [rbp-58h]
  unsigned __int64 v11; // [rsp+48h] [rbp-50h]
  __int64 v12; // [rsp+50h] [rbp-48h]
  __int64 v13; // [rsp+58h] [rbp-40h]
  __int128 v14; // [rsp+80h] [rbp-18h]

  v14 = v1;
  v9 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  n0x900 = 0x900;
  v8 = 1;
  v10 = __rdtsc();
  qword_149C89AA0(
    &n0x900,
    &word_149F5BFAC,
    "CGameEffectsSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Effects/GameEffectsSystem.cpp",
    0x20A);
  v3 = 0;
  HIWORD(n0x900) = word_149F5BFAC;
  if ( qword_149C8DFB8 )
  {
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
    if ( v4 )
      v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x58LL))(v4);
  }
  for ( i = *(_QWORD *)(a1 + 0x40); i; i = *(_QWORD *)(a1 + 0x50) )
  {
    *(_QWORD *)(a1 + 0x50) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 0x50LL))(i);
    if ( !v3 || (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)i + 0x30LL))(i, 0x200) )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)i + 0x18LL))(i);
  }
  *(_QWORD *)(a1 + 0x50) = 0;
  v11 = __rdtsc();
  return qword_149C89AA8(&n0x900);
}

// --- End Function: sub_1431E2A30 (0x1431E2A30) ---

// --- Function: sub_1431E2B90 (0x1431E2B90) ---
__int64 __fastcall sub_1431E2B90(_QWORD *a1)
{
  __int64 v2; // rdi
  char **v3; // r12
  __int64 v4; // rbx
  void *v5; // rax
  __int64 v6; // rsi
  char *v7; // r8
  char *v8; // r15
  char *v9; // r14
  char *v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rdi
  unsigned __int64 v13; // r12
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // rcx
  __int64 v16; // rax
  char *v17; // rcx
  char *v18; // rdx
  char *Size; // r8
  char *v20; // rdx
  char *v21; // rbx
  char *v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // rsi
  unsigned __int8 *v25; // rbx
  __int64 v26; // r8
  __int64 v27; // rdx
  char *i; // rbx
  _QWORD v30[2]; // [rsp+20h] [rbp-30h] BYREF
  void *Src[2]; // [rsp+30h] [rbp-20h] BYREF
  char *v32; // [rsp+40h] [rbp-10h]
  __int64 v33; // [rsp+90h] [rbp+40h] BYREF
  char v34; // [rsp+98h] [rbp+48h] BYREF

  sub_1403CE280((__int64)a1);
  v2 = a1[0x12];
  v3 = (char **)(a1 + 0x11);
  v4 = a1[0x11];
  v5 = sub_1405A0C10();
  sub_1430E2580(v4, v2, (__int64)v5, v33);
  v6 = a1[0x11];
  v7 = 0;
  v8 = 0;
  v32 = 0;
  *(_OWORD *)Src = 0;
  v9 = 0;
  if ( v6 != a1[0x12] )
  {
    v10 = 0;
    while ( *(_BYTE *)(v6 + 0x498) == 4 )
    {
      v11 = *(_QWORD *)(v6 + 8);
      if ( v8 == v7 )
      {
        v12 = (v8 - v9) >> 3;
        if ( v12 == 0x1FFFFFFFFFFFFFFFLL )
          unknown_libname_10();
        v13 = v12 + 1;
        v14 = (v7 - v9) >> 3;
        v15 = v14 >> 1;
        if ( v14 <= 0x1FFFFFFFFFFFFFFFLL - (v14 >> 1) )
        {
          v16 = v15 + v14;
          if ( v15 + v14 < v13 )
            v16 = v12 + 1;
        }
        else
        {
          v16 = 0x1FFFFFFFFFFFFFFFLL;
        }
        v33 = 8 * v16;
        v9 = (char *)sub_140394E70((__int64)Src, 8 * v16);
        v17 = v9;
        *(_QWORD *)&v9[8 * v12] = v11;
        v18 = (char *)Src[0];
        if ( v8 == Src[1] )
        {
          Size = (char *)((char *)Src[1] - (char *)Src[0]);
        }
        else
        {
          memmove(v9, Src[0], v8 - (char *)Src[0]);
          v17 = &v9[8 * v12 + 8];
          Size = (char *)((char *)Src[1] - (char *)v8);
          v18 = v8;
        }
        memmove(v17, v18, (size_t)Size);
        if ( Src[0] )
          sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], (v32 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
        v8 = &v9[8 * v13];
        v7 = &v9[v33];
        Src[0] = v9;
        v32 = &v9[v33];
      }
      else
      {
        *(_QWORD *)v8 = v11;
        v7 = v32;
        v8 = (char *)Src[1] + 8;
        v9 = (char *)Src[0];
      }
      v6 += 0x4A0;
      Src[1] = v8;
      v10 = v8;
      if ( v6 == a1[0x12] )
        goto LABEL_20;
    }
    v8 = v10;
LABEL_20:
    v3 = (char **)(a1 + 0x11);
  }
  if ( v9 != v8 )
  {
    do
    {
      v20 = (char *)a1[0x12];
      v21 = *v3;
      if ( *v3 != v20 )
      {
        while ( 1 )
        {
          v22 = v21 + 0x4A0;
          if ( *(_QWORD *)v21 == *(_QWORD *)v9 )
            break;
          v21 += 0x4A0;
          if ( v22 == v20 )
            goto LABEL_31;
        }
        if ( v22 < v20 )
        {
          v23 = (unsigned __int128)((v20 - v22) * (__int128)0x3759F22983759F23LL) >> 0x40;
          v24 = ((unsigned __int64)v23 >> 0x3F) + (v23 >> 8);
          if ( v24 > 0 )
          {
            v25 = (unsigned __int8 *)(v21 + 0x498);
            v30[0] = &v33;
            do
            {
              *((_QWORD *)v25 + 0xFFFFFF6D) = *((_QWORD *)v25 + 1);
              v26 = *v25;
              v30[1] = v25 + 0x10;
              sub_1431F3480(v30, v25 + 0xFFFFFB70, v26);
              --v24;
              *v25 = v25[0x4A0];
              v25 += 0x4A0;
            }
            while ( v24 > 0 );
          }
        }
        v27 = a1[0x12] - 0x4A0LL;
        a1[0x12] = v27;
        sub_1431F56D0(&v34, v27 + 8, *(unsigned __int8 *)(v27 + 0x498));
      }
LABEL_31:
      v9 += 8;
    }
    while ( v9 != v8 );
    v7 = v32;
    v9 = (char *)Src[0];
  }
  if ( v9 )
    sub_1403A6820((__int64)Src, (unsigned __int64)v9, (v7 - v9) & 0xFFFFFFFFFFFFFFF8uLL);
  for ( i = *v3; i != (char *)a1[0x12]; i += 0x4A0 )
  {
    if ( i[0x498] != 4 )
    {
      a1[0x10] = *(_QWORD *)i;
      sub_1431F5590(a1 + 0xF, i + 8, (unsigned __int8)i[0x498]);
    }
  }
  a1[0x10] = 0xFFFFFFFFFFFFFFFFuLL;
  return sub_1431ECAF0(v3);
}

// --- End Function: sub_1431E2B90 (0x1431E2B90) ---

// --- Function: sub_1431E2EE0 (0x1431E2EE0) ---
unsigned __int64 __fastcall sub_1431E2EE0(__int64 a1)
{
  __int128 v2; // [rsp+20h] [rbp-18h] BYREF

  v2 = 0;
  return sub_1404AD680(a1 + 0x70, (__int64)&v2);
}

// --- End Function: sub_1431E2EE0 (0x1431E2EE0) ---

// --- Function: sub_1431E2F10 (0x1431E2F10) ---
bool __fastcall sub_1431E2F10(_QWORD *a1)
{
  _QWORD *v2; // rax
  bool result; // al
  __int64 i; // rbx
  __int64 p_rw_lock_state; // rbx
  signed __int64 v6; // rdx
  __int64 v7; // rbp
  _OWORD *v8; // rsi
  __int128 v9; // xmm0
  _OWORD *v10; // rbp
  __int64 v11; // rbx
  __int64 v12; // rcx
  __int64 v13; // rbp
  __int64 v14; // r15
  __int64 v15; // rdi
  __int128 v16; // [rsp+30h] [rbp-48h] BYREF
  __int64 v17; // [rsp+80h] [rbp+8h] BYREF
  __int64 v18; // [rsp+88h] [rbp+10h] BYREF
  __int64 v19; // [rsp+90h] [rbp+18h] BYREF

  sub_1403CE280((__int64)(a1 + 7));
  v17 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                     qword_149C8DF80,
                     0);
  v2 = sub_14059CA80(a1 + 0x29, &v19, a1 + 0x2A);
  result = sub_14059CAD0(v2, &v17);
  if ( result )
  {
    for ( i = a1[0x25]; i != a1[0x26]; i = a1[0x25] )
    {
      if ( sub_14059CAD0(&v17, (_QWORD *)(i + 8)) )
        break;
      LODWORD(v18) = *(_DWORD *)i;
      HIDWORD(v18) = 2;
      p_rw_lock_state = j_psub_140338BA0();
      if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(p_rw_lock_state + 0x14);
      }
      else
      {
        v6 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
        if ( (v6 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            p_rw_lock_state,
            v6,
            "SCigEventDispatcher::QueueEvent",
            "SCigEventSystemWithLinks::GetLinkUnlinkLock()",
            1);
      }
      sub_1430937F0((__int64)(a1 + 0x16), &v18);
      rw_lock_release_read_lock(p_rw_lock_state);
      v7 = a1[0x26];
      v8 = (_OWORD *)a1[0x25];
      if ( (__int64)((v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x20 )
      {
        v9 = *(_OWORD *)(v7 - 0x10);
        v10 = (_OWORD *)(v7 - 0x10);
        v11 = 0;
        v16 = v9;
        v12 = 0;
        *v10 = *v8;
        v13 = v10 - v8;
        v14 = (v13 - 1) >> 1;
        if ( v14 > 0 )
        {
          do
          {
            v12 = 2 * v12 + !sub_14059CAF0((_QWORD *)&v8[2 * v12 + 2] + 1, (_QWORD *)&v8[2 * v12 + 1] + 1) + 1LL;
            v8[v11] = v8[v12];
            v11 = v12;
          }
          while ( v12 < v14 );
        }
        if ( v11 == v14 && (v13 & 1) == 0 )
        {
          v8[v11] = v8[v13 - 1];
          v11 = v13 - 1;
        }
        if ( v11 > 0 )
        {
          do
          {
            v15 = (v11 - 1) >> 1;
            if ( !sub_14059CAF0((_QWORD *)&v8[v15] + 1, (_QWORD *)&v16 + 1) )
              break;
            v8[v11] = v8[v15];
            v11 = (v11 - 1) >> 1;
          }
          while ( v15 > 0 );
        }
        v8[v11] = v16;
      }
      a1[0x26] -= 0x10LL;
    }
    result = v17;
    a1[0x29] = v17;
  }
  return result;
}

// --- End Function: sub_1431E2F10 (0x1431E2F10) ---

// --- Function: sub_1431E31B0 (0x1431E31B0) ---
__int64 __fastcall sub_1431E31B0(__int64 a1, float a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int64 v4; // rsi
  __int64 v5; // r13
  int v7; // ebx
  unsigned int v8; // eax
  _QWORD *v9; // rax
  _QWORD *v10; // rdi
  __int64 v11; // r15
  unsigned __int8 v12; // r12
  __int64 v13; // r14
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // r14
  bool v17; // al
  __int64 v18; // rbx
  __int64 (__fastcall *v19)(__int64, char *, __int16 *); // r14
  __int16 n0xFFFF; // ax
  __int64 v21; // rbx
  __int64 v22; // rax
  __int16 n4; // dx
  __int64 **v26; // rax
  __int64 i; // rax
  __int64 *v28; // rcx
  __int64 *v29; // rax
  int v30; // eax
  unsigned __int32 v31; // eax
  __int64 v32; // rax
  __int64 n29; // rax
  __int64 *n29_1; // r13
  __int64 v35; // r15
  __int64 v36; // rdi
  int v37; // ebx
  unsigned int v38; // eax
  __int64 v39; // r12
  __int64 v40; // r15
  __int64 v41; // r14
  __int64 v42; // rbx
  __int64 v43; // rsi
  bool v44; // al
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // r8
  int v49; // eax
  int v50; // [rsp+20h] [rbp-A9h]
  __int64 v51; // [rsp+40h] [rbp-89h]
  __int64 v52; // [rsp+48h] [rbp-81h] BYREF
  __int64 v53; // [rsp+50h] [rbp-79h] BYREF
  _QWORD *v54; // [rsp+58h] [rbp-71h]
  __int64 v55; // [rsp+60h] [rbp-69h] BYREF
  __int64 v56; // [rsp+68h] [rbp-61h] BYREF
  __int128 v57; // [rsp+70h] [rbp-59h] BYREF
  __int64 v58; // [rsp+80h] [rbp-49h]
  char v59[8]; // [rsp+88h] [rbp-41h] BYREF
  __int128 v60; // [rsp+90h] [rbp-39h] BYREF
  __int128 v61; // [rsp+A0h] [rbp-29h] BYREF
  __int64 v62; // [rsp+B0h] [rbp-19h]
  __int128 v63; // [rsp+D0h] [rbp+7h]
  __int128 v64; // [rsp+E0h] [rbp+17h]
  __int64 v65; // [rsp+130h] [rbp+67h] BYREF
  __int16 n0xFFFF_1; // [rsp+140h] [rbp+77h] BYREF
  char v67; // [rsp+148h] [rbp+7Fh] BYREF

  v65 = a1;
  v4 = a1 + 0xE0;
  v63 = v3;
  v52 = a1 + 0xE0;
  v5 = a1;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
    if ( v8 )
      sub_1403C6E80(v4, v8, (__int64)"CSpawnClosetRequestManager::Update", 1);
    else
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v4 + 0x10) = v7;
  }
  v9 = *(_QWORD **)(v5 + 0xD0);
  v64 = v2;
  v10 = (_QWORD *)*v9;
  v54 = v10;
  if ( v10 != v9 )
  {
    while ( 1 )
    {
      v11 = v10[5];
      v12 = 0;
      v13 = v10[6];
      v14 = v11;
      v51 = v13;
      if ( v11 == v13 )
        goto LABEL_42;
      do
      {
        if ( !*(_BYTE *)(v14 + 0x10) )
          ++v12;
        v14 += 0x18;
      }
      while ( v14 != v13 );
      do
      {
        if ( *(_BYTE *)(v11 + 0x10) )
          goto LABEL_40;
        v55 = (unsigned int)(int)(float)(a2 * 10000000.0);
        sub_1402FE5E0((_QWORD *)(v11 + 8), &v55);
        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
          qword_149C8DFC0,
          &v53,
          *(_QWORD *)v11);
        v15 = v53;
        if ( !v53 )
          goto LABEL_37;
        if ( (v53 & 0xF000000000000000uLL) != 0 )
          v16 = v53 & 0xFFFFFF000000LL;
        else
          v16 = (v53 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v16 + 2) == (HIWORD(v53) & 0xFFF) )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v17 = is_thread_privileged_or_bypass_mode(), v15 = v53, v17) )
            v17 = 1;
          if ( *(_WORD *)(v16 + 4) == 2 && v17 )
            goto LABEL_25;
          if ( sub_140395410(&v53) )
          {
            v15 = v53;
LABEL_25:
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v15 & 0xFFFFFFFFFFFFLL) + 0x50LL))(v15 & 0xFFFFFFFFFFFFLL) )
            {
              v18 = v53 & 0xFFFFFFFFFFFFLL;
              v19 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)(v53 & 0xFFFFFFFFFFFFLL) + 0x340LL);
              n0xFFFF = n0xFFFF_23;
              if ( n0xFFFF_23 == (__int16)0xFFFF )
              {
                n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                             + 0x10LL))(
                                      qword_149C8DFC8,
                                      &v67,
                                      "ISubsumptionMissionLinkComponent");
                n0xFFFF_23 = n0xFFFF;
              }
              n0xFFFF_1 = n0xFFFF;
              v21 = *(_QWORD *)v19(v18, v59, &n0xFFFF_1);
              v56 = v21;
              if ( v21 )
              {
                v22 = sub_1403B84E0(v21 & 0xFFFFFFFFFFFFLL);
                n4 = *(_WORD *)(v22 + 4);
                if ( n4 != 4
                  && *(_WORD *)(v22 + 2) == (HIWORD(v21) & 0xFFF)
                  && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140395350(&v56)) )
                {
                  v13 = v51;
                  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v21 & 0xFFFFFFFFFFFFLL) + 0x580LL))(v21 & 0xFFFFFFFFFFFFLL) )
                    goto LABEL_40;
                  goto LABEL_37;
                }
              }
            }
          }
        }
        v13 = v51;
LABEL_37:
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        if ( *(float *)&_XMM1 > *(float *)(::n29 + 0x358) && v12 > *(int *)(::n29 + 0x354) )
        {
          *(_BYTE *)(v11 + 0x10) = 1;
          --v12;
        }
LABEL_40:
        v11 += 0x18;
      }
      while ( v11 != v13 );
      v10 = v54;
      v5 = v65;
LABEL_42:
      v26 = (__int64 **)v10[2];
      if ( *((_BYTE *)v26 + 0x19) )
      {
        for ( i = v10[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
        {
          if ( v10 != *(_QWORD **)(i + 0x10) )
            break;
          v10 = (_QWORD *)i;
        }
        v10 = (_QWORD *)i;
        v54 = (_QWORD *)i;
      }
      else
      {
        v28 = *v26;
        v10 = (_QWORD *)v10[2];
        v54 = v26;
        if ( !*((_BYTE *)v28 + 0x19) )
        {
          do
          {
            v29 = (__int64 *)*v28;
            v10 = v28;
            v54 = v28;
            v28 = v29;
          }
          while ( !*((_BYTE *)v29 + 0x19) );
        }
      }
      if ( v10 == *(_QWORD **)(v5 + 0xD0) )
      {
        v4 = v52;
        break;
      }
    }
  }
  v30 = *(_DWORD *)(v4 + 0x14);
  if ( v30 )
  {
    *(_DWORD *)(v4 + 0x14) = v30 - 1;
  }
  else
  {
    *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
    v31 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
    if ( v31 == 1 )
      *(_QWORD *)(v4 + 8) = &p_Src;
    else
      sub_1403DF590(v4, v31);
  }
  if ( Parameter_0 )
  {
    v32 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000005);
    if ( v32 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v32 + 8LL))(v32);
  }
  n29 = ::n29;
  if ( *(_DWORD *)(::n29 + 0x348) )
  {
    n29 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x590LL))(qword_149C8E018);
    n29_1 = (__int64 *)n29;
    if ( n29 )
    {
      v35 = v65;
      v36 = v65 + 0x110;
      v54 = (_QWORD *)(v65 + 0x110);
      v37 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
      if ( *(_DWORD *)(v36 + 0x10) == v37 )
      {
        ++*(_DWORD *)(v36 + 0x14);
      }
      else
      {
        v38 = _InterlockedCompareExchange((volatile signed __int32 *)v36, 1, 0);
        if ( v38 )
          sub_1403C6E80(v36, v38, (__int64)"CSpawnClosetRequestManager::Update", 1);
        else
          *(_QWORD *)(v36 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
        *(_DWORD *)(v36 + 0x10) = v37;
      }
      v39 = *(_QWORD *)(v35 + 0x100);
      v40 = *(_QWORD *)(v35 + 0xF8);
      if ( v40 != v39 )
      {
        v41 = v40 + 0x18;
        while ( 1 )
        {
          (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
            qword_149C8DFC0,
            &v52,
            *(_QWORD *)(v41 + 8));
          v42 = v52;
          if ( v52 )
          {
            v43 = (v52 & 0xF000000000000000uLL) != 0 ? v52 & 0xFFFFFF000000LL : (v52 & 0xFFFFFFFFFFFFLL) - 6;
            if ( *(_WORD *)(v43 + 2) == (HIWORD(v52) & 0xFFF) )
            {
              if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v44 = is_thread_privileged_or_bypass_mode(), v42 = v52, v44) )
                v44 = 1;
              if ( *(_WORD *)(v43 + 4) == 2 && v44 )
                goto LABEL_81;
              if ( sub_140395410(&v52) )
                break;
            }
          }
LABEL_88:
          v40 += 0x28;
          v41 += 0x28;
          if ( v40 == v39 )
          {
            v36 = (__int64)v54;
            goto LABEL_90;
          }
        }
        v42 = v52;
LABEL_81:
        if ( *(double *)(v41 - 0x10) != 0.0 || *(double *)(v41 - 8) != 0.0 || *(double *)v41 != 0.0 )
        {
          v46 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v42 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v42 & 0xFFFFFFFFFFFFLL);
          (*(void (__fastcall **)(__int64, __int128 *, __int64))(*(_QWORD *)v46 + 0x170LL))(v46, &v57, v41 - 0x10);
          v47 = *n29_1;
          LODWORD(v65) = 0xFFFF0000;
          LOBYTE(v50) = 0;
          (*(void (__fastcall **)(__int64 *, __int128 *, __int64, __int64 *, int, unsigned int))(v47 + 0xE0))(
            n29_1,
            &v57,
            v48,
            &v65,
            v50,
            0xFFFFFFFF);
          v60 = xmmword_14832FCD0;
          v61 = v57;
          v62 = v58;
          sub_1409E0AF0((__int64)qword_149C8E018, (__int64)&v61, 1.2, &v60, 1u, 1u, (__int64)"SpawnClosetNPC Despawn");
        }
        goto LABEL_88;
      }
LABEL_90:
      v49 = *(_DWORD *)(v36 + 0x14);
      if ( v49 )
      {
        n29 = (unsigned int)(v49 - 1);
        *(_DWORD *)(v36 + 0x14) = n29;
      }
      else
      {
        *(_DWORD *)(v36 + 0x10) = 0xFFFFFFFF;
        n29 = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v36, 0, 1);
        if ( (_DWORD)n29 == 1 )
          *(_QWORD *)(v36 + 8) = &p_Src;
        else
          return (__int64)sub_1403DF590(v36, (unsigned int)n29);
      }
    }
  }
  return n29;
}

// --- End Function: sub_1431E31B0 (0x1431E31B0) ---

// --- Function: sub_1431EAF40 (0x1431EAF40) ---
__int64 __fastcall sub_1431EAF40(__int64 *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rsi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 0x97 )
      sub_14265C210(v1);
    v4 = *a1;
    if ( (unsigned __int64)(0x4B8 * ((a1[2] - *a1) / 0x4B8)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_1402A6590(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1431EAF40 (0x1431EAF40) ---

// --- Function: sub_1431ECAF0 (0x1431ECAF0) ---
__int64 __fastcall sub_1431ECAF0(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v3; // rbx
  __int64 result; // rax
  char v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = a1[1];
  v3 = *a1;
  if ( *a1 == v1 )
  {
    a1[1] = v3;
  }
  else
  {
    do
    {
      sub_1431F56D0(&v5, v3 + 8, *(unsigned __int8 *)(v3 + 0x498));
      v3 += 0x4A0;
    }
    while ( v3 != v1 );
    result = *a1;
    a1[1] = *a1;
  }
  return result;
}

// --- End Function: sub_1431ECAF0 (0x1431ECAF0) ---

// --- Function: sub_1431ECE50 (0x1431ECE50) ---
__int64 __fastcall sub_1431ECE50(unsigned __int64 **a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rbp
  unsigned __int64 *v4; // r8
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r11
  __int64 v8; // rax
  bool v9; // cf
  bool v10; // cf
  unsigned __int64 *v11; // rdi
  _QWORD *v12; // rbx
  _QWORD *v13; // r14
  _QWORD *v14; // r14
  _QWORD *v15; // r14

  v2 = a1[1];
  v4 = *a1;
  v6 = ((char *)v2 - (char *)*a1) / 0x4C8;
  if ( v6 )
  {
    v7 = *a2;
    do
    {
      v8 = 0x99 * (v6 >> 1);
      v9 = v4[v8] < v7;
      if ( v4[v8] == v7 )
        v9 = v4[v8 + 1] < a2[1];
      if ( v9 )
      {
        v4 = (unsigned __int64 *)((char *)v4 + v8 * 8 + 0x4C8);
        v6 += 0xFFFFFFFFFFFFFFFFuLL - (v6 >> 1);
      }
      else
      {
        v6 >>= 1;
      }
    }
    while ( v6 );
  }
  if ( v4 == v2 )
    return 0;
  v10 = *a2 < *v4;
  if ( *a2 == *v4 )
    v10 = a2[1] < v4[1];
  if ( v10 )
    return 0;
  v11 = v4 + 0x99;
  if ( v4 + 0x99 != v2 )
  {
    v12 = v4 + 0x8A;
    do
    {
      *((_OWORD *)v12 + 0xFFFFFFBB) = *(_OWORD *)v11;
      sub_1402A6440((__int64)(v12 + 0xFFFFFF78), (const void *)v12[0x13], v12[0x11]);
      sub_1402A6440((__int64)(v12 + 0xFFFFFFBB), (const void *)v12[0x56], v12[0x54]);
      v13 = v12 + 0x97;
      if ( v12 + 0xFFFFFFFE != v12 + 0x97 )
      {
        sub_140564E90(v12 + 0xFFFFFFFE);
        v12[0xFFFFFFFE] = *v13;
        v12[0xFFFFFFFF] = v12[0x98];
        *v12 = v12[0x99];
        *v13 = 0;
        v12[0x98] = 0;
        v12[0x99] = 0;
      }
      sub_14037BE50(v12 + 1, v12 + 0x9A);
      v14 = v12 + 0x9D;
      if ( v12 + 4 != v12 + 0x9D )
      {
        sub_1426B72B0(v12 + 4);
        v12[4] = *v14;
        v12[5] = v12[0x9E];
        v12[6] = v12[0x9F];
        *v14 = 0;
        v12[0x9E] = 0;
        v12[0x9F] = 0;
      }
      *(_OWORD *)(v12 + 7) = *((_OWORD *)v12 + 0x50);
      v12[9] = v12[0xA2];
      v15 = v12 + 0xA5;
      v12[0xA] = v12[0xA3];
      *((_BYTE *)v12 + 0x58) = *((_BYTE *)v12 + 0x520);
      if ( v12 + 0xC != v12 + 0xA5 )
      {
        sub_140375620(v12 + 0xC);
        v12[0xC] = *v15;
        v12[0xD] = v12[0xA6];
        v12[0xE] = v12[0xA7];
        *v15 = 0;
        v12[0xA6] = 0;
        v12[0xA7] = 0;
      }
      v11 += 0x99;
      v12 += 0x99;
    }
    while ( v11 != v2 );
  }
  sub_14265C210(a1[1] + 0xFFFFFF69);
  a1[1] += 0xFFFFFF67;
  return 1;
}

// --- End Function: sub_1431ECE50 (0x1431ECE50) ---

// --- Function: sub_1431F2920 (0x1431F2920) ---
__int64 __fastcall sub_1431F2920(__int64 a1, __int64 a2, __int64 a3, __int64 n0x10_3, char a5)
{
  __int64 n0x10_1; // rdi
  __int64 n0x10; // r13
  __int64 v10; // rcx
  _QWORD *i; // r14
  _QWORD *v12; // rsi
  _BYTE *v13; // rbx
  __int64 v14; // r8
  __int64 v15; // r8
  __int64 n4_1; // r8
  __int64 v18; // rax
  __int64 v19; // r10
  int n0x10_2; // r9d
  __int64 v21; // r14
  __int64 v22; // rdi
  int v23; // eax
  __int64 v24; // r9
  __int64 v25; // r13
  char v26; // [rsp+30h] [rbp-528h] BYREF
  char v27; // [rsp+31h] [rbp-527h] BYREF
  _BYTE v28[2]; // [rsp+32h] [rbp-526h] BYREF
  int v29; // [rsp+34h] [rbp-524h]
  _QWORD v30[2]; // [rsp+38h] [rbp-520h] BYREF
  _QWORD v31[3]; // [rsp+48h] [rbp-510h] BYREF
  __int64 v32; // [rsp+60h] [rbp-4F8h]
  _BYTE v33[1168]; // [rsp+68h] [rbp-4F0h] BYREF
  unsigned __int8 n4; // [rsp+4F8h] [rbp-60h]

  n0x10_1 = n0x10_3;
  n0x10 = (a2 - a1) / 0x4A0;
  if ( n0x10_3 < 1 )
  {
    if ( a1 == a2 || (v10 = a1 + 0x4A0, a1 + 0x4A0 == a2) )
    {
LABEL_6:
      v10 = a2;
    }
    else
    {
      while ( *(_BYTE *)(v10 + 0x498) != 4 )
      {
        v10 += 0x4A0;
        if ( v10 == a2 )
          goto LABEL_6;
      }
    }
    n0x10_1 = (v10 - a1) / 0x4A0;
  }
  if ( n0x10_1 >= n0x10 )
    return 0;
  if ( n0x10 <= 0x10 )
  {
    if ( a1 != a2 )
    {
      for ( i = (_QWORD *)(a1 + 0x4A0 * n0x10_1); i != (_QWORD *)a2; i += 0x94 )
      {
        v32 = *i;
        sub_1430E4710((__int64)v33, (__int64)(i + 1));
        v12 = i;
        if ( i != (_QWORD *)a1 )
        {
          v13 = i + 0x93;
          do
          {
            if ( n4 != 4 )
              break;
            *v12 = *((_QWORD *)v13 + 0xFFFFFED9);
            v14 = (unsigned __int8)*v13;
            v31[0] = &v26;
            v31[1] = v13 + 0xFFFFF6D0;
            sub_1431F2F50(v31, v13 + 0xFFFFFB70, v14);
            v12 += 0xFFFFFF6C;
            *v13 = v13[0xFFFFFB60];
            v13 += 0xFFFFFB60;
          }
          while ( v12 != (_QWORD *)a1 );
        }
        *v12 = v32;
        v15 = *((unsigned __int8 *)v12 + 0x498);
        v30[0] = &v27;
        v30[1] = v33;
        sub_1431F2F50(v30, v12 + 1, v15);
        n4_1 = n4;
        *((_BYTE *)v12 + 0x498) = n4;
        sub_1431F56D0(v28, v33, n4_1);
      }
    }
    return 0;
  }
  v29 = 0;
  v18 = n0x10 / 2;
  v19 = 0x4A0 * (n0x10 / 2);
  v30[0] = n0x10 / 2;
  v31[0] = v19;
  if ( n0x10_1 < n0x10 / 2 )
  {
    LODWORD(v18) = sub_1431F2920(a1, (int)v19 + (int)a1, a3, n0x10_1, a5);
    v19 = v31[0];
    v29 = v18;
    LODWORD(v18) = v30[0];
  }
  n0x10_2 = n0x10_1 - v18;
  v21 = v19 + a3;
  v22 = v19 + a1;
  v23 = sub_1431F2920((int)v19 + (int)a1, a2, (int)v19 + (int)a3, n0x10_2, a5);
  if ( v29 )
  {
    v25 = a3 + 0x4A0 * n0x10;
    if ( !v23 )
      sub_1430E0500(v22, a2, v21);
    v24 = v25;
  }
  else
  {
    if ( !v23 )
    {
      sub_1430E2470(a1, v22, v22, a2, a3);
      return 1;
    }
    sub_1430E0500(a1, v22, a3);
    v24 = a3 + 0x4A0 * n0x10;
  }
  sub_1430E2470(a3, v21, v21, v24, a1);
  return 0;
}

// --- End Function: sub_1431F2920 (0x1431F2920) ---

// --- Function: sub_1431F2F50 (0x1431F2F50) ---
__int64 (__fastcall *__fastcall sub_1431F2F50(__int64 *a1, __int64 a2, __int64 a3))(_QWORD, _QWORD *)
{
  _OWORD *v3; // rbx
  __int64 (__fastcall *result)(_QWORD, _QWORD *); // rax
  __int64 v5; // rsi
  __int64 v6; // r8
  char v7; // r8
  _QWORD *v8; // rcx
  _QWORD *v9; // rdi
  __int64 v10; // rcx
  __int64 v11; // rdi
  __int64 v12; // rdx
  __int64 v13; // [rsp+20h] [rbp-18h] BYREF
  _OWORD *v14; // [rsp+28h] [rbp-10h]

  v3 = (_OWORD *)a2;
  if ( (_BYTE)a3 )
  {
    LOBYTE(a3) = a3 - 1;
    if ( (_BYTE)a3 )
    {
      LOBYTE(a3) = a3 - 1;
      return (__int64 (__fastcall *)(_QWORD, _QWORD *))sub_1431F30B0(a1, a2, a3);
    }
    else
    {
      v5 = a1[1];
      v13 = *a1;
      v14 = (_OWORD *)a2;
      v6 = *(unsigned __int8 *)(v5 + 0x490);
      if ( (_BYTE)v6 )
      {
        v7 = v6 - 1;
        if ( v7 )
        {
          LOBYTE(v6) = v7 - 1;
          if ( (_BYTE)v6 )
          {
            LOBYTE(v6) = v6 - 1;
            return (__int64 (__fastcall *)(_QWORD, _QWORD *))sub_1431F42A0(&v13, v5, v6);
          }
          else
          {
            v8 = *(_QWORD **)(a2 + 0x48);
            v9 = (_QWORD *)(a2 + 0x10);
            if ( v8 )
            {
              LOBYTE(a2) = v8 != v9;
              (*(void (__fastcall **)(_QWORD *, __int64))(*v8 + 0x20LL))(v8, a2);
              v9[7] = 0;
            }
            *v3 = *(_OWORD *)v5;
            *v9 = 0;
            v9[1] = 0;
            v9[2] = 0;
            result = *(__int64 (__fastcall **)(_QWORD, _QWORD *))(v5 + 0x18);
            if ( result == (__int64 (__fastcall *)(_QWORD, _QWORD *))1 )
            {
              *v9 = *(_QWORD *)(v5 + 0x10);
              result = *(__int64 (__fastcall **)(_QWORD, _QWORD *))(v5 + 0x18);
              v9[1] = result;
            }
            else if ( result )
            {
              return (__int64 (__fastcall *)(_QWORD, _QWORD *))result(0, v9);
            }
          }
        }
        else
        {
          *(_OWORD *)a2 = *(_OWORD *)v5;
          return (__int64 (__fastcall *)(_QWORD, _QWORD *))sub_1402B6E50(a2 + 0x10, v5 + 0x10);
        }
      }
      else
      {
        v10 = *(_QWORD *)(a2 + 0x48);
        v11 = a2 + 0x10;
        if ( v10 )
        {
          LOBYTE(a2) = v10 != v11;
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 0x20LL))(v10, a2);
          *(_QWORD *)(v11 + 0x38) = 0;
        }
        return (__int64 (__fastcall *)(_QWORD, _QWORD *))sub_1430EAE20((__int64)v3, v5);
      }
    }
  }
  else
  {
    v12 = a1[1];
    v13 = *a1;
    v14 = v3;
    return (__int64 (__fastcall *)(_QWORD, _QWORD *))sub_1431F3F20(&v13, v12, *(unsigned __int8 *)(v12 + 0x490));
  }
  return result;
}

// --- End Function: sub_1431F2F50 (0x1431F2F50) ---

// --- Function: sub_1431F3330 (0x1431F3330) ---
void __fastcall sub_1431F3330(_QWORD *a1, __int64 a2, char a3)
{
  __int64 v4; // rdx
  bool v5; // zf
  __int64 v6; // r8
  __int64 v7; // rdi
  char v8; // al
  char v9; // al
  char v10; // al
  char v11; // al
  _QWORD v12[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( a3 )
  {
    v4 = a1[1];
    v5 = a3 == 1;
    v12[0] = *a1;
    v12[1] = a2;
    v6 = *(unsigned __int8 *)(v4 + 0x490);
    if ( v5 )
      sub_1431F4AB0(v12, v4, v6);
    else
      sub_1431F5430(v12, v4, v6);
  }
  else
  {
    v7 = a1[1];
    v8 = *(_BYTE *)(v7 + 0x490);
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          v11 = v10 - 1;
          if ( v11 )
          {
            if ( v11 == 1 )
            {
              *(_QWORD *)a2 = *(_QWORD *)v7;
            }
            else
            {
              *(_OWORD *)a2 = *(_OWORD *)v7;
              *(_QWORD *)(a2 + 0x10) = *(_QWORD *)(v7 + 0x10);
              sub_14035DAD0((_QWORD *)(a2 + 0x18), (_QWORD *)(v7 + 0x18));
              *(_BYTE *)(a2 + 0x30) = *(_BYTE *)(v7 + 0x30);
            }
          }
          else
          {
            *(_QWORD *)a2 = *(_QWORD *)v7;
            sub_14035DAD0((_QWORD *)(a2 + 8), (_QWORD *)(v7 + 8));
          }
        }
        else
        {
          *(_OWORD *)a2 = *(_OWORD *)v7;
          sub_14035DAD0((_QWORD *)(a2 + 0x10), (_QWORD *)(v7 + 0x10));
        }
      }
      else
      {
        *(_OWORD *)a2 = *(_OWORD *)v7;
        *(_QWORD *)(a2 + 0x48) = 0;
        std::_Func_class<void,>::_Reset_move(
          (std::_Func_class<void> *)(a2 + 0x10),
          (std::_Func_class<void> *)(v7 + 0x10));
      }
    }
    else
    {
      sub_1430EE140(a2, a1[1]);
      sub_14035DAD0((_QWORD *)(a2 + 0x478), (_QWORD *)(v7 + 0x478));
    }
  }
}

// --- End Function: sub_1431F3330 (0x1431F3330) ---

// --- Function: sub_1431F3480 (0x1431F3480) ---
_QWORD *__fastcall sub_1431F3480(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  _QWORD *result; // rax
  __int64 v5; // rdi
  __int64 v6; // r8
  __int128 v7; // xmm0
  __int64 v8; // rdi
  __int64 v9; // rbx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rbp
  __int64 v16; // rdx
  _QWORD *v17; // [rsp+20h] [rbp-18h] BYREF
  __int64 v18; // [rsp+28h] [rbp-10h]

  v3 = a2;
  if ( (_BYTE)a3 )
  {
    LOBYTE(a3) = a3 - 1;
    if ( (_BYTE)a3 )
    {
      LOBYTE(a3) = a3 - 1;
      return (_QWORD *)sub_1431F3600(a1, a2, a3);
    }
    else
    {
      result = (_QWORD *)*a1;
      v5 = a1[1];
      v17 = (_QWORD *)*a1;
      v18 = a2;
      v6 = *(unsigned __int8 *)(v5 + 0x490);
      if ( (_BYTE)v6 )
      {
        LOBYTE(v6) = v6 - 1;
        if ( (_BYTE)v6 )
        {
          LOBYTE(v6) = v6 - 1;
          return (_QWORD *)sub_1431F4EE0(&v17, v5, v6);
        }
        else
        {
          v7 = *(_OWORD *)v5;
          v8 = v5 + 0x10;
          v9 = a2 + 0x10;
          *(_OWORD *)a2 = v7;
          if ( a2 + 0x10 != v8 )
          {
            v10 = *(_QWORD *)(a2 + 0x48);
            if ( v10 )
            {
              LOBYTE(a2) = v10 != v9;
              result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 0x20LL))(v10, a2);
              *(_QWORD *)(v9 + 0x38) = 0;
            }
            v11 = *(_QWORD *)(v8 + 0x38);
            if ( v11 )
            {
              if ( v11 == v8 )
              {
                result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 8LL))(v11, v9);
                *(_QWORD *)(v9 + 0x38) = result;
                v13 = *(_QWORD *)(v8 + 0x38);
                if ( v13 )
                {
                  LOBYTE(v12) = v13 != v8;
                  result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 0x20LL))(v13, v12);
                  *(_QWORD *)(v8 + 0x38) = 0;
                }
              }
              else
              {
                *(_QWORD *)(v9 + 0x38) = v11;
                *(_QWORD *)(v8 + 0x38) = 0;
              }
            }
          }
        }
      }
      else
      {
        v14 = *(_QWORD *)(a2 + 0x48);
        v15 = a2 + 0x10;
        if ( v14 )
        {
          LOBYTE(a2) = v14 != v15;
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v14 + 0x20LL))(v14, a2);
          *(_QWORD *)(v15 + 0x38) = 0;
        }
        sub_1430EE140(v3, v5);
        return sub_14035DAD0((_QWORD *)(v3 + 0x478), (_QWORD *)(v5 + 0x478));
      }
    }
  }
  else
  {
    v16 = a1[1];
    v17 = (_QWORD *)*a1;
    v18 = v3;
    return (_QWORD *)sub_1431F4C10(&v17, v16, *(unsigned __int8 *)(v16 + 0x490));
  }
  return result;
}

// --- End Function: sub_1431F3480 (0x1431F3480) ---

// --- Function: sub_1431F3600 (0x1431F3600) ---
void __fastcall sub_1431F3600(__int64 *a1, __int64 a2, char a3)
{
  char v4; // r8
  __int64 v5; // rsi
  __int64 v6; // r8
  char v7; // r8
  void (__fastcall *n2_3)(__int64, __int64, _QWORD); // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rdx
  void (__fastcall *n2_4)(__int64, __int64, _QWORD); // rax
  void (__fastcall *n2_2)(__int64, __int64, _QWORD); // rax
  __int64 v13; // r8
  void (__fastcall *n2)(__int64, __int64, _QWORD); // rax
  void (__fastcall *n2_1)(__int64, __int64, _QWORD); // rax
  __int64 v16; // [rsp+20h] [rbp-18h] BYREF
  __int64 v17; // [rsp+28h] [rbp-10h]

  if ( !a3 )
  {
    v5 = a1[1];
    v16 = *a1;
    v17 = a2;
    v13 = *(unsigned __int8 *)(v5 + 0x490);
    if ( (_BYTE)v13 )
    {
      LOBYTE(v13) = v13 - 1;
      if ( (_BYTE)v13 )
      {
        LOBYTE(v13) = v13 - 1;
        sub_1431F5090(&v16, v5, v13);
      }
      else
      {
        n2 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a2 + 0x18);
        if ( (unsigned __int64)n2 >= 2 )
        {
          n2(2, a2 + 0x10, 0);
          *(_QWORD *)(a2 + 0x18) = 0;
        }
        *(_QWORD *)(a2 + 0x10) = 0;
        *(_OWORD *)a2 = *(_OWORD *)v5;
        *(_QWORD *)(a2 + 0x48) = 0;
        std::_Func_class<void,>::_Reset_move(
          (std::_Func_class<void> *)(a2 + 0x10),
          (std::_Func_class<void> *)(v5 + 0x10));
      }
      return;
    }
    n2_1 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a2 + 0x18);
    if ( (unsigned __int64)n2_1 >= 2 )
    {
      n2_1(2, a2 + 0x10, 0);
      *(_QWORD *)(a2 + 0x18) = 0;
    }
    *(_QWORD *)(a2 + 0x10) = 0;
LABEL_26:
    sub_1430EE140(a2, v5);
    v9 = (_QWORD *)(a2 + 0x478);
    v10 = (_QWORD *)(v5 + 0x478);
LABEL_27:
    sub_14035DAD0(v9, v10);
    return;
  }
  v4 = a3 - 1;
  if ( v4 )
  {
    sub_1431F3330(a1, a2, v4 - 1);
    return;
  }
  v5 = a1[1];
  v16 = *a1;
  v17 = a2;
  v6 = *(unsigned __int8 *)(v5 + 0x490);
  if ( !(_BYTE)v6 )
  {
    n2_2 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a2 + 0x10);
    if ( (unsigned __int64)n2_2 >= 2 )
    {
      n2_2(2, a2 + 8, 0);
      *(_QWORD *)(a2 + 0x10) = 0;
    }
    *(_QWORD *)(a2 + 8) = 0;
    goto LABEL_26;
  }
  v7 = v6 - 1;
  if ( v7 )
  {
    LOBYTE(v6) = v7 - 1;
    if ( (_BYTE)v6 )
    {
      LOBYTE(v6) = v6 - 1;
      sub_1431F51B0(&v16, v5, v6);
      return;
    }
    n2_3 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a2 + 0x10);
    if ( (unsigned __int64)n2_3 >= 2 )
    {
      n2_3(2, a2 + 8, 0);
      *(_QWORD *)(a2 + 0x10) = 0;
    }
    *(_QWORD *)(a2 + 8) = 0;
    v9 = (_QWORD *)(a2 + 0x10);
    *(_OWORD *)a2 = *(_OWORD *)v5;
    v10 = (_QWORD *)(v5 + 0x10);
    goto LABEL_27;
  }
  n2_4 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a2 + 0x10);
  if ( (unsigned __int64)n2_4 >= 2 )
  {
    n2_4(2, a2 + 8, 0);
    *(_QWORD *)(a2 + 0x10) = 0;
  }
  *(_QWORD *)(a2 + 8) = 0;
  *(_OWORD *)a2 = *(_OWORD *)v5;
  *(_QWORD *)(a2 + 0x48) = 0;
  std::_Func_class<void,>::_Reset_move((std::_Func_class<void> *)(a2 + 0x10), (std::_Func_class<void> *)(v5 + 0x10));
}

// --- End Function: sub_1431F3600 (0x1431F3600) ---

// --- Function: sub_1431F3DE0 (0x1431F3DE0) ---
__int64 (__fastcall *__fastcall sub_1431F3DE0(__int64 a1, _QWORD *a2, char a3))(_QWORD, _QWORD *)
{
  char v3; // r8
  char v4; // r8
  _QWORD *v5; // rcx
  char v6; // r8
  __int64 (__fastcall *result)(_QWORD, _QWORD *); // rax
  __int64 v8; // rax
  _QWORD *v9; // rcx
  _OWORD *v10; // rax
  _OWORD *v11; // rbx
  __int64 (__fastcall ***v12)(_QWORD, _OWORD *); // rcx

  if ( !a3 )
    return (__int64 (__fastcall *)(_QWORD, _QWORD *))sub_1430EAE20(*(_QWORD *)(a1 + 8), (__int64)a2);
  v3 = a3 - 1;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      v5 = *(_QWORD **)(a1 + 8);
      v6 = v4 - 1;
      if ( v6 )
      {
        if ( v6 == 1 )
        {
          result = (__int64 (__fastcall *)(_QWORD, _QWORD *))*a2;
          *v5 = *a2;
        }
        else
        {
          return (__int64 (__fastcall *)(_QWORD, _QWORD *))sub_1430E4F80((__int64)v5, (__int64)a2);
        }
      }
      else
      {
        *v5 = *a2;
        v5[1] = 0;
        v5[2] = 0;
        v5[3] = 0;
        result = (__int64 (__fastcall *)(_QWORD, _QWORD *))a2[2];
        if ( result == (__int64 (__fastcall *)(_QWORD, _QWORD *))1 )
        {
          v5[1] = a2[1];
          result = (__int64 (__fastcall *)(_QWORD, _QWORD *))a2[2];
          v5[2] = result;
        }
        else if ( result )
        {
          return (__int64 (__fastcall *)(_QWORD, _QWORD *))result(0, v5 + 1);
        }
      }
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 8);
      *(_OWORD *)v8 = *(_OWORD *)a2;
      v9 = (_QWORD *)(v8 + 0x10);
      *(_QWORD *)(v8 + 0x10) = 0;
      *(_QWORD *)(v8 + 0x18) = 0;
      *(_QWORD *)(v8 + 0x20) = 0;
      result = (__int64 (__fastcall *)(_QWORD, _QWORD *))a2[3];
      if ( result == (__int64 (__fastcall *)(_QWORD, _QWORD *))1 )
      {
        *v9 = a2[2];
        result = (__int64 (__fastcall *)(_QWORD, _QWORD *))a2[3];
        v9[1] = result;
      }
      else if ( result )
      {
        return (__int64 (__fastcall *)(_QWORD, _QWORD *))result(0, v9);
      }
    }
  }
  else
  {
    v10 = *(_OWORD **)(a1 + 8);
    *v10 = *(_OWORD *)a2;
    v11 = v10 + 1;
    result = 0;
    *((_QWORD *)v11 + 7) = 0;
    v12 = (__int64 (__fastcall ***)(_QWORD, _OWORD *))a2[9];
    if ( v12 )
    {
      result = (__int64 (__fastcall *)(_QWORD, _QWORD *))(**v12)(v12, v11);
      *((_QWORD *)v11 + 7) = result;
    }
  }
  return result;
}

// --- End Function: sub_1431F3DE0 (0x1431F3DE0) ---

// --- Function: sub_1431F4C10 (0x1431F4C10) ---
void __fastcall sub_1431F4C10(__int64 a1, __int64 a2, __int64 a3)
{
  char v4; // r8
  _QWORD *v5; // rsi
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  __int64 v7; // rbp
  void (__fastcall *n2_1)(__int64, __int64, _QWORD); // rax
  __int64 v9; // rsi
  _QWORD *v10; // r14

  if ( (_BYTE)a3 )
  {
    v4 = a3 - 1;
    if ( v4 )
    {
      LOBYTE(a3) = v4 - 1;
      if ( (_BYTE)a3 )
      {
        LOBYTE(a3) = a3 - 1;
        sub_1431F4DD0(a1, a2, a3);
      }
      else
      {
        v5 = *(_QWORD **)(a1 + 8);
        n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))v5[0x90];
        if ( (unsigned __int64)n2 >= 2 )
        {
          n2(2, v5 + 0x8F, 0);
          v5[0x90] = 0;
        }
        v5[0x8F] = 0;
        sub_1430F5D00(v5);
        *(_OWORD *)v5 = *(_OWORD *)a2;
        sub_14035DAD0(v5 + 2, (_QWORD *)(a2 + 0x10));
      }
    }
    else
    {
      v7 = *(_QWORD *)(a1 + 8);
      n2_1 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v7 + 0x480);
      if ( (unsigned __int64)n2_1 >= 2 )
      {
        n2_1(2, v7 + 0x478, 0);
        *(_QWORD *)(v7 + 0x480) = 0;
      }
      *(_QWORD *)(v7 + 0x478) = 0;
      sub_1430F5D00((_QWORD *)v7);
      *(_OWORD *)v7 = *(_OWORD *)a2;
      *(_QWORD *)(v7 + 0x48) = 0;
      std::_Func_class<void,>::_Reset_move((std::_Func_class<void> *)(v7 + 0x10), (std::_Func_class<void> *)(a2 + 0x10));
    }
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 8);
    sub_1402A6440(v9, *(const void **)(a2 + 0x10), *(_QWORD *)a2);
    sub_1402A6440(v9 + 0x218, *(const void **)(a2 + 0x228), *(_QWORD *)(a2 + 0x218));
    *(_BYTE *)(v9 + 0x430) = *(_BYTE *)(a2 + 0x430);
    sub_14037BE50((__int64 *)(v9 + 0x438), (__int64 *)(a2 + 0x438));
    v10 = (_QWORD *)(a2 + 0x450);
    if ( v9 + 0x450 != a2 + 0x450 )
    {
      sub_1426B72B0((__int64 *)(v9 + 0x450));
      *(_QWORD *)(v9 + 0x450) = *v10;
      *(_QWORD *)(v9 + 0x458) = *(_QWORD *)(a2 + 0x458);
      *(_QWORD *)(v9 + 0x460) = *(_QWORD *)(a2 + 0x460);
      *v10 = 0;
      *(_QWORD *)(a2 + 0x458) = 0;
      *(_QWORD *)(a2 + 0x460) = 0;
    }
    *(_QWORD *)(v9 + 0x468) = *(_QWORD *)(a2 + 0x468);
    *(_BYTE *)(v9 + 0x470) = *(_BYTE *)(a2 + 0x470);
    sub_14037ABF0((_QWORD *)(v9 + 0x478), (_QWORD *)(a2 + 0x478));
  }
}

// --- End Function: sub_1431F4C10 (0x1431F4C10) ---

// --- Function: sub_1431F4DD0 (0x1431F4DD0) ---
_QWORD *__fastcall sub_1431F4DD0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  void (__fastcall *n2)(__int64, __int64, _QWORD); // rax
  _QWORD *result; // rax

  v3 = *(_QWORD *)(a1 + 8);
  n2 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v3 + 0x480);
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v3 + 0x478, 0);
        *(_QWORD *)(v3 + 0x480) = 0;
      }
      *(_QWORD *)(v3 + 0x478) = 0;
      sub_1430F5D00((_QWORD *)v3);
      result = *(_QWORD **)a2;
      *(_QWORD *)v3 = *(_QWORD *)a2;
    }
    else
    {
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v3 + 0x478, 0);
        *(_QWORD *)(v3 + 0x480) = 0;
      }
      *(_QWORD *)(v3 + 0x478) = 0;
      sub_1430F5D00((_QWORD *)v3);
      *(_OWORD *)v3 = *(_OWORD *)a2;
      *(_QWORD *)(v3 + 0x10) = *(_QWORD *)(a2 + 0x10);
      sub_14035DAD0((_QWORD *)(v3 + 0x18), (_QWORD *)(a2 + 0x18));
      result = (_QWORD *)*(unsigned __int8 *)(a2 + 0x30);
      *(_BYTE *)(v3 + 0x30) = (_BYTE)result;
    }
  }
  else
  {
    if ( (unsigned __int64)n2 >= 2 )
    {
      n2(2, v3 + 0x478, 0);
      *(_QWORD *)(v3 + 0x480) = 0;
    }
    *(_QWORD *)(v3 + 0x478) = 0;
    sub_1430F5D00((_QWORD *)v3);
    *(_QWORD *)v3 = *(_QWORD *)a2;
    return sub_14035DAD0((_QWORD *)(v3 + 8), (_QWORD *)(a2 + 8));
  }
  return result;
}

// --- End Function: sub_1431F4DD0 (0x1431F4DD0) ---

// --- Function: sub_1431F4EE0 (0x1431F4EE0) ---
_QWORD *__fastcall sub_1431F4EE0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  char v4; // r8
  char v5; // r8
  __int64 v6; // rdi
  _QWORD *v7; // rcx
  _QWORD *v8; // rsi
  _QWORD *result; // rax
  _QWORD *v10; // rsi
  _QWORD *v11; // rcx
  _QWORD *v12; // rdi
  _QWORD *v13; // rcx
  __int64 v14; // rsi
  __int64 v15; // rcx

  v3 = a2;
  if ( a3 )
  {
    v4 = a3 - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = *(_QWORD *)(a1 + 8);
        v7 = *(_QWORD **)(v6 + 0x48);
        v8 = (_QWORD *)(v6 + 0x10);
        if ( v5 == 1 )
        {
          if ( !v7 )
            goto LABEL_7;
        }
        else if ( !v7 )
        {
LABEL_7:
          *(_OWORD *)v6 = *(_OWORD *)v3;
          *v8 = *(_QWORD *)(v3 + 0x10);
          sub_14035DAD0((_QWORD *)(v6 + 0x18), (_QWORD *)(v3 + 0x18));
          result = (_QWORD *)*(unsigned __int8 *)(v3 + 0x30);
          *(_BYTE *)(v6 + 0x30) = (_BYTE)result;
          return result;
        }
        LOBYTE(a2) = v7 != v8;
        (*(void (__fastcall **)(_QWORD *, __int64))(*v7 + 0x20LL))(v7, a2);
        *(_QWORD *)(v6 + 0x48) = 0;
        goto LABEL_7;
      }
      v10 = *(_QWORD **)(a1 + 8);
      v11 = (_QWORD *)v10[9];
      if ( v11 )
      {
        LOBYTE(a2) = v11 != v10 + 2;
        (*(void (__fastcall **)(_QWORD *, __int64))(*v11 + 0x20LL))(v11, a2);
        v10[9] = 0;
      }
      result = *(_QWORD **)v3;
      *v10 = *(_QWORD *)v3;
    }
    else
    {
      v12 = *(_QWORD **)(a1 + 8);
      v13 = (_QWORD *)v12[9];
      if ( v13 )
      {
        LOBYTE(a2) = v13 != v12 + 2;
        (*(void (__fastcall **)(_QWORD *, __int64))(*v13 + 0x20LL))(v13, a2);
        v12[9] = 0;
      }
      *v12 = *(_QWORD *)v3;
      return sub_14035DAD0(v12 + 1, (_QWORD *)(v3 + 8));
    }
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 8);
    v15 = *(_QWORD *)(v14 + 0x48);
    if ( v15 )
    {
      LOBYTE(a2) = v15 != v14 + 0x10;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v15 + 0x20LL))(v15, a2);
      *(_QWORD *)(v14 + 0x48) = 0;
    }
    *(_OWORD *)v14 = *(_OWORD *)v3;
    return sub_14035DAD0((_QWORD *)(v14 + 0x10), (_QWORD *)(v3 + 0x10));
  }
  return result;
}

// --- End Function: sub_1431F4EE0 (0x1431F4EE0) ---

// --- Function: sub_1431F5090 (0x1431F5090) ---
_QWORD *__fastcall sub_1431F5090(__int64 a1, __int64 a2, char a3)
{
  char v4; // r8
  __int64 v5; // rsi
  void (__fastcall *n2_1)(__int64, __int64, _QWORD); // rax
  _QWORD *result; // rax
  _QWORD *v8; // r14
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  _QWORD *v10; // r14
  void (__fastcall *n2_2)(__int64, _QWORD *, _QWORD); // rax
  __int64 v12; // rcx

  if ( a3 )
  {
    v4 = a3 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        v8 = *(_QWORD **)(a1 + 8);
        n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))v8[3];
        if ( (unsigned __int64)n2 >= 2 )
        {
          n2(2, v8 + 2, 0);
          v8[3] = 0;
        }
        v8[2] = 0;
        result = *(_QWORD **)a2;
        *v8 = *(_QWORD *)a2;
      }
      else
      {
        v5 = *(_QWORD *)(a1 + 8);
        n2_1 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v5 + 0x18);
        if ( (unsigned __int64)n2_1 >= 2 )
        {
          n2_1(2, v5 + 0x10, 0);
          *(_QWORD *)(v5 + 0x18) = 0;
        }
        *(_QWORD *)(v5 + 0x10) = 0;
        *(_OWORD *)v5 = *(_OWORD *)a2;
        *(_QWORD *)(v5 + 0x10) = *(_QWORD *)(a2 + 0x10);
        sub_14035DAD0((_QWORD *)(v5 + 0x18), (_QWORD *)(a2 + 0x18));
        result = (_QWORD *)*(unsigned __int8 *)(a2 + 0x30);
        *(_BYTE *)(v5 + 0x30) = (_BYTE)result;
      }
    }
    else
    {
      v10 = *(_QWORD **)(a1 + 8);
      n2_2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))v10[3];
      if ( (unsigned __int64)n2_2 >= 2 )
      {
        n2_2(2, v10 + 2, 0);
        v10[3] = 0;
      }
      v10[2] = 0;
      *v10 = *(_QWORD *)a2;
      return sub_14035DAD0(v10 + 1, (_QWORD *)(a2 + 8));
    }
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 8);
    *(_OWORD *)v12 = *(_OWORD *)a2;
    return sub_14037ABF0((_QWORD *)(v12 + 0x10), (_QWORD *)(a2 + 0x10));
  }
  return result;
}

// --- End Function: sub_1431F5090 (0x1431F5090) ---

// --- Function: sub_1431F51B0 (0x1431F51B0) ---
unsigned __int64 __fastcall sub_1431F51B0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rdi
  void (__fastcall *n2)(__int64, __int64, _QWORD); // rax
  unsigned __int64 n2_2; // rax
  _QWORD *v7; // rsi
  void (__fastcall *n2_1)(__int64, __int64, _QWORD); // rax

  v3 = *(_QWORD *)(a1 + 8);
  if ( a3 )
  {
    n2 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v3 + 0x10);
    if ( a3 == 1 )
    {
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v3 + 8, 0);
        *(_QWORD *)(v3 + 0x10) = 0;
      }
      *(_QWORD *)(v3 + 8) = 0;
      n2_2 = *(_QWORD *)a2;
      *(_QWORD *)v3 = *(_QWORD *)a2;
    }
    else
    {
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v3 + 8, 0);
        *(_QWORD *)(v3 + 0x10) = 0;
      }
      *(_QWORD *)(v3 + 8) = 0;
      *(_OWORD *)v3 = *(_OWORD *)a2;
      *(_QWORD *)(v3 + 0x10) = *(_QWORD *)(a2 + 0x10);
      sub_14035DAD0((_QWORD *)(v3 + 0x18), (_QWORD *)(a2 + 0x18));
      n2_2 = *(unsigned __int8 *)(a2 + 0x30);
      *(_BYTE *)(v3 + 0x30) = n2_2;
    }
  }
  else
  {
    v7 = (_QWORD *)(a2 + 8);
    *(_QWORD *)v3 = *(_QWORD *)a2;
    n2_1 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v3 + 0x10);
    if ( (unsigned __int64)n2_1 >= 2 )
    {
      n2_1(2, v3 + 8, 0);
      *(_QWORD *)(v3 + 0x10) = 0;
    }
    *(_QWORD *)(v3 + 8) = 0;
    n2_2 = v7[1];
    if ( n2_2 == 1 )
    {
      *(_QWORD *)(v3 + 8) = *v7;
      *(_QWORD *)(v3 + 0x10) = v7[1];
    }
    else
    {
      if ( !n2_2 )
        return n2_2;
      ((void (__fastcall *)(__int64, __int64, _QWORD *))n2_2)(1, v3 + 8, v7);
    }
    n2_2 = v7[1];
    if ( n2_2 >= 2 )
    {
      n2_2 = ((__int64 (__fastcall *)(__int64, _QWORD *))n2_2)(2, v7);
      v7[1] = 0;
    }
    *v7 = 0;
  }
  return n2_2;
}

// --- End Function: sub_1431F51B0 (0x1431F51B0) ---

// --- Function: sub_1431F5590 (0x1431F5590) ---
void __fastcall sub_1431F5590(__int64 *a1, unsigned __int64 *a2, char a3)
{
  char v4; // r8
  char v5; // r8
  char v6; // r8
  char v7; // r8
  __int64 v8; // rsi
  __int64 v9; // rbx
  int v10; // ebp
  __int64 v11; // r8
  unsigned __int64 v12; // rax
  int v13; // eax
  unsigned __int64 n0x200000; // rax

  if ( a3 )
  {
    v4 = a3 - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = v5 - 1;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            if ( v7 == 1 )
              sub_143113B00(a1, a2);
            else
              sub_143114CC0(a1, a2);
          }
        }
        else
        {
          sub_143114A60(a1, (__int64 *)a2);
        }
      }
      else
      {
        sub_1431148D0((__int64)a1, a2);
      }
    }
    else
    {
      v8 = *a1;
      v9 = *a1 + 0xB8;
      v10 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
      if ( *(_DWORD *)(v8 + 0xC8) == v10 )
      {
        ++*(_DWORD *)(v8 + 0xCC);
      }
      else
      {
        v11 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
        v12 = _InterlockedCompareExchange64((volatile signed __int64 *)v9, 0x200000, 0);
        if ( v12 )
          sub_1403E1120(v8 + 0xB8, v12, v11, (const char *)&p_Src, (const char *)&p_Src, 1);
        else
          *(_QWORD *)(v8 + 0xC0) = v11;
        *(_DWORD *)(v8 + 0xC8) = v10;
      }
      sub_1431ECE50((unsigned __int64 **)(v8 + 0xA0), a2);
      if ( v9 )
      {
        v13 = *(_DWORD *)(v9 + 0x14);
        if ( v13 )
        {
          *(_DWORD *)(v9 + 0x14) = v13 - 1;
        }
        else
        {
          *(_DWORD *)(v9 + 0x10) = 0xFFFFFFFF;
          n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v9, 0, 0x200000);
          if ( n0x200000 == 0x200000 )
            *(_QWORD *)(v9 + 8) = &p_Src;
          else
            rw_lock_handle_write_release_contention(v9, n0x200000);
        }
      }
    }
  }
  else
  {
    sub_1431141D0(a1, (__int64)a2);
  }
}

// --- End Function: sub_1431F5590 (0x1431F5590) ---

// --- Function: sub_1431F56D0 (0x1431F56D0) ---
void __fastcall sub_1431F56D0(__int64 a1, _QWORD *a2, char a3)
{
  _QWORD *v3; // rdi
  char v4; // r8
  char v5; // r8
  char v6; // r8
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  void (__fastcall *n2_1)(__int64, _QWORD *, _QWORD); // rax
  void (__fastcall *n2_2)(__int64, _QWORD *, _QWORD); // rax
  _QWORD *v10; // rcx
  _QWORD *v11; // rdi
  void (__fastcall *n2_3)(__int64, _QWORD *, _QWORD); // rax

  v3 = a2;
  if ( a3 )
  {
    v4 = a3 - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = v5 - 1;
        if ( v6 )
        {
          if ( v6 != 1 )
          {
            n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a2[4];
            if ( (unsigned __int64)n2 >= 2 )
            {
              n2(2, a2 + 3, 0);
              v3[4] = 0;
            }
            v3[3] = 0;
          }
        }
        else
        {
          n2_1 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a2[2];
          if ( (unsigned __int64)n2_1 >= 2 )
          {
            n2_1(2, a2 + 1, 0);
            v3[2] = 0;
          }
          v3[1] = 0;
        }
      }
      else
      {
        n2_2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a2[3];
        if ( (unsigned __int64)n2_2 >= 2 )
        {
          n2_2(2, a2 + 2, 0);
          v3[3] = 0;
        }
        v3[2] = 0;
      }
    }
    else
    {
      v10 = (_QWORD *)a2[9];
      v11 = a2 + 2;
      if ( v10 )
      {
        LOBYTE(a2) = v10 != v11;
        (*(void (__fastcall **)(_QWORD *, _QWORD *))(*v10 + 0x20LL))(v10, a2);
        v11[7] = 0;
      }
    }
  }
  else
  {
    n2_3 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a2[0x90];
    if ( (unsigned __int64)n2_3 >= 2 )
    {
      n2_3(2, a2 + 0x8F, 0);
      v3[0x90] = 0;
    }
    v3[0x8F] = 0;
    sub_1430F5D00(v3);
  }
}

// --- End Function: sub_1431F56D0 (0x1431F56D0) ---

// --- Function: sub_14321C310 (0x14321C310) ---
__int64 __fastcall sub_14321C310(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_DWORD *)(a1 + 0x18) = 0;
  sub_142CE04B0(a1);
  return a1;
}

// --- End Function: sub_14321C310 (0x14321C310) ---

// --- Function: sub_14321C370 (0x14321C370) ---
__int64 __fastcall sub_14321C370(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_DWORD *)(a1 + 0x18) = 0;
  sub_142CE0550(a1);
  return a1;
}

// --- End Function: sub_14321C370 (0x14321C370) ---

// --- Function: sub_143282210 (0x143282210) ---
__int64 __fastcall sub_143282210(__int64 a1)
{
  return a1 + 0x1B0;
}

// --- End Function: sub_143282210 (0x143282210) ---

// --- Function: sub_14330D300 (0x14330D300) ---
char **__fastcall sub_14330D300(_QWORD *a1, Parameter *Parameter_1, char *dst_1)
{
  char *Src; // [rsp+20h] [rbp-58h]
  char *dst; // [rsp+28h] [rbp-50h]
  _QWORD *v6; // [rsp+30h] [rbp-48h]
  char *Src_1; // [rsp+40h] [rbp-38h]

  v6 = a1 + 1;
  dst = dst_1;
  Src_1 = (char *)a1[1];
  Src = dst_1 + 0x18;
  if ( AK::WriteBytesCount::Reserve((AK::WriteBytesCount *)a1) )
  {
    while ( Src != Src_1 )
    {
      qmemcpy(dst, Src, 0x18u);
      dst += 0x18;
      Src += 0x18;
    }
  }
  else
  {
    std::_Copy_memmove<int *,int *>(Src, Src_1, (int *)dst);
  }
  *v6 -= 0x18LL;
  *Parameter_1 = dst_1;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_14330D300 (0x14330D300) ---

// --- Function: sub_14330D650 (0x14330D650) ---
_QWORD *__fastcall sub_14330D650(__int64 a1, Parameter *Parameter_1, _QWORD *a3)
{
  __int64 *i; // [rsp+20h] [rbp-48h]
  _QWORD *v5; // [rsp+28h] [rbp-40h]
  _QWORD *v6; // [rsp+30h] [rbp-38h]
  __int64 *v8; // [rsp+50h] [rbp-18h]

  v5 = (_QWORD *)(a1 + 8);
  v6 = a3;
  v8 = *(__int64 **)(a1 + 8);
  for ( i = a3 + 2; i != v8; i += 2 )
  {
    sub_14275A910(v6, i);
    v6 += 2;
  }
  if ( *(_QWORD *)(*v5 - 8LL) )
    std::_Ref_count_base::_Decref(*(std::_Ref_count_base **)(*v5 - 8LL));
  *v5 -= 0x10LL;
  *Parameter_1 = a3;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_14330D650 (0x14330D650) ---

// --- Function: sub_1433142D0 (0x1433142D0) ---
_QWORD *__fastcall sub_1433142D0(_QWORD *a1, __int64 a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_143316930(a1, a2);
  return a1;
}

// --- End Function: sub_1433142D0 (0x1433142D0) ---

// --- Function: sub_143316930 (0x143316930) ---
_QWORD *__fastcall sub_143316930(_QWORD *a1, const void *src)
{
  _QWORD *result; // rax
  void *dst; // [rsp+20h] [rbp-28h]
  void *dst_1; // [rsp+28h] [rbp-20h]

  sub_1402A5330(a1);
  dst = (void *)sub_1402A65A0(0x40u);
  if ( dst )
  {
    qmemcpy(dst, src, 0x40u);
    dst_1 = dst;
  }
  else
  {
    dst_1 = 0;
  }
  a1[2] = dst_1;
  *a1 = sub_14337D7C0;
  result = a1;
  a1[1] = sub_143381660;
  return result;
}

// --- End Function: sub_143316930 (0x143316930) ---

// --- Function: sub_14332BF90 (0x14332BF90) ---
__int64 __fastcall sub_14332BF90(unsigned __int8 *a1)
{
  return *a1;
}

// --- End Function: sub_14332BF90 (0x14332BF90) ---

// --- Function: sub_143348980 (0x143348980) ---
_QWORD *__fastcall sub_143348980(_QWORD *a1, _QWORD *a2)
{
  void (__fastcall *v3)(__int64, _QWORD *, _QWORD *); // [rsp+20h] [rbp-18h]

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if ( a2[1] == 1 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
    sub_1402A5330(a2);
  }
  else
  {
    if ( a2[1] > 1u )
      v3 = (void (__fastcall *)(__int64, _QWORD *, _QWORD *))a2[1];
    else
      v3 = 0;
    if ( v3 )
    {
      v3(1, a1, a2);
      sub_1402A5330(a2);
    }
  }
  return a1;
}

// --- End Function: sub_143348980 (0x143348980) ---

// --- Function: sub_14334AB20 (0x14334AB20) ---
_QWORD *__fastcall sub_14334AB20(_QWORD *a1, __int64 a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-18h]

  *a1 = 0;
  a1[1] = 0;
  v3 = a1 + 2;
  sub_1402A4D50((__int64)(a1 + 2));
  *v3 = 0;
  sub_1433AC230(a1, a2);
  return a1;
}

// --- End Function: sub_14334AB20 (0x14334AB20) ---

// --- Function: sub_143354C30 (0x143354C30) ---
__int64 __fastcall sub_143354C30(__int64 a1)
{
  *(float *)a1 = 0xBF800000;
  *(float *)(a1 + 4) = 0xBF800000;
  *(float *)(a1 + 8) = 0;
  *(float *)(a1 + 0xC) = 0;
  sub_14035E090((_QWORD *)(a1 + 0x10));
  sub_140364420(a1 + 0x18);
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  return a1;
}

// --- End Function: sub_143354C30 (0x143354C30) ---

// --- Function: sub_14335EE30 (0x14335EE30) ---
void __fastcall sub_14335EE30(__int64 a1)
{
  __int64 v1; // [rsp+28h] [rbp-10h]

  v1 = a1 + 0x70;
  sub_140375A50((_DWORD *)(a1 + 0x88));
  sub_140373CC0((_QWORD *)(v1 + 0x10));
  sub_140375A50((_DWORD *)(a1 + 0x38));
  std::vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____::_vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____((__int64 *)(a1 + 0x20));
  _StarEngineModule__(a1 + 8);
}

// --- End Function: sub_14335EE30 (0x14335EE30) ---

// --- Function: sub_1433601D0 (0x1433601D0) ---
__int64 __fastcall sub_1433601D0(__int64 a1, __int64 a2, __int64 a3)
{
  *(float *)a1 = *(float *)a2;
  *(float *)(a1 + 4) = *(float *)(a2 + 4);
  *(float *)(a1 + 8) = *(float *)(a2 + 8);
  *(float *)(a1 + 0xC) = *(float *)(a2 + 0xC);
  copyStringStructure((void **)(a1 + 0x10), (const void **)(a2 + 0x10), a3);
  sub_14037CB50(a1 + 0x18, a2 + 0x18);
  *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(a2 + 0x48);
  *(_QWORD *)(a1 + 0x50) = *(_QWORD *)(a2 + 0x50);
  return a1;
}

// --- End Function: sub_1433601D0 (0x1433601D0) ---

// --- Function: sub_143361210 (0x143361210) ---
__int64 __fastcall sub_143361210(_QWORD *a1)
{
  return *(_QWORD *)(*(_QWORD *)(*a1 + 8LL) + 8 * ((*(_QWORD *)(*a1 + 0x10LL) - 1LL) & a1[1]));
}

// --- End Function: sub_143361210 (0x143361210) ---

// --- Function: sub_14336A8A0 (0x14336A8A0) ---
__int64 __fastcall sub_14336A8A0(__int64 a1, char a2)
{
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = a1 + 0x50;
  sub_140375A50((_DWORD *)(a1 + 0x68));
  sub_140373CC0((_QWORD *)(v3 + 0x10));
  if ( (a2 & 1) != 0 )
    sub_1402A6590(a1);
  return a1;
}

// --- End Function: sub_14336A8A0 (0x14336A8A0) ---

// --- Function: sub_14337D7C0 (0x14337D7C0) ---
__int64 __fastcall sub_14337D7C0(__int64 a1, __int64 a2)
{
  return sub_1433655E0(*(_QWORD *)(a1 + 0x10), a2);
}

// --- End Function: sub_14337D7C0 (0x14337D7C0) ---

// --- Function: sub_143381660 (0x143381660) ---
__int64 (__fastcall **__fastcall sub_143381660(
        int n2,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2)))(__int64 a1, __int64 a2)
{
  __int64 (__fastcall **result)(__int64, __int64); // rax
  __int64 (__fastcall *dst)(__int64, __int64); // [rsp+50h] [rbp-48h]
  __int64 (__fastcall *dst_1)(__int64, __int64); // [rsp+58h] [rbp-40h]
  __int64 (__fastcall *src)(__int64, __int64); // [rsp+60h] [rbp-38h]

  if ( n2 )
  {
    if ( n2 == 1 )
    {
      result = a3;
      if ( *a3 )
      {
        if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
        {
          a2[2] = 0;
          *a2 = *a3;
          a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
        }
        else
        {
          a2[2] = a3[2];
          *a2 = *a3;
          a2[1] = a3[1];
        }
        a3[2] = 0;
        *a3 = 0;
        result = a3;
        a3[1] = 0;
      }
    }
    else if ( n2 == 2 )
    {
      sub_1402A6590((__int64)a2[2]);
      a2[2] = 0;
      *a2 = 0;
      result = a2;
      a2[1] = 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    src = a3[2];
    result = a3;
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        result = a2;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        dst = (__int64 (__fastcall *)(__int64, __int64))sub_1402A65A0(0x40u);
        if ( dst )
        {
          qmemcpy(dst, src, 0x40u);
          dst_1 = dst;
        }
        else
        {
          dst_1 = 0;
        }
        a2[2] = dst_1;
        *a2 = sub_14337D7C0;
        result = a2;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))sub_143381660;
      }
    }
  }
  return result;
}

// --- End Function: sub_143381660 (0x143381660) ---

// --- Function: sub_1433AA1A0 (0x1433AA1A0) ---
__int64 __fastcall sub_1433AA1A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // [rsp+20h] [rbp-28h]
  __int64 v5; // [rsp+30h] [rbp-18h]

  v4 = sub_1402AE320(a1 + 0x28, 0xF0, 8, 0);
  v2 = unknown_libname_491(v4 + 0x20);
  v5 = sub_1402A53E0(0xD0, v2);
  sub_1433132C0(v5, 0, a2);
  return v4;
}

// --- End Function: sub_1433AA1A0 (0x1433AA1A0) ---

// --- Function: sub_1433AA2D0 (0x1433AA2D0) ---
__int64 __fastcall sub_1433AA2D0(__int64 a1, __int64 a2)
{
  sub_14335EE30(a2 + 0x28);
  return sub_1402A6600(a1 + 0x28, a2);
}

// --- End Function: sub_1433AA2D0 (0x1433AA2D0) ---

// --- Function: sub_1433AA470 (0x1433AA470) ---
_QWORD **__fastcall sub_1433AA470(__int64 a1, _BYTE *a2, _DWORD *a3)
{
  bool v4; // [rsp+20h] [rbp-38h]
  _QWORD **v5; // [rsp+30h] [rbp-28h]
  _QWORD *v6; // [rsp+38h] [rbp-20h]
  _QWORD **v7; // [rsp+40h] [rbp-18h]

  v6 = *(_QWORD **)(a1 + 0x10);
  v5 = (_QWORD **)a1;
  v4 = 1;
  while ( v6 )
  {
    v4 = *a3 < *((_DWORD *)v6 + 8);
    v5 = (_QWORD **)v6;
    if ( *a3 >= *((_DWORD *)v6 + 8) )
      v6 = (_QWORD *)*v6;
    else
      v6 = (_QWORD *)v6[1];
  }
  v7 = v5;
  if ( v4 )
  {
    if ( v5 == *(_QWORD ***)(a1 + 8) )
    {
      *a2 = 1;
      return v5;
    }
    v5 = sub_1405A0C20(v5);
  }
  if ( *((_DWORD *)v5 + 8) >= *a3 )
  {
    *a2 = 0;
    return v5;
  }
  else
  {
    *a2 = 1;
    return v7;
  }
}

// --- End Function: sub_1433AA470 (0x1433AA470) ---

// --- Function: sub_1433AAFA0 (0x1433AAFA0) ---
__int64 __fastcall sub_1433AAFA0(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  char v5; // [rsp+30h] [rbp-48h] BYREF
  char v6; // [rsp+31h] [rbp-47h]
  char v7; // [rsp+32h] [rbp-46h]
  _QWORD **v8; // [rsp+38h] [rbp-40h]
  _QWORD v9[2]; // [rsp+40h] [rbp-38h] BYREF
  _QWORD *v10; // [rsp+50h] [rbp-28h]
  __int64 v11; // [rsp+58h] [rbp-20h]
  _QWORD v12[3]; // [rsp+60h] [rbp-18h] BYREF
  int v13; // [rsp+80h] [rbp+8h]

  v13 = a1;
  v8 = sub_1433AA470(a1, &v5, a4);
  if ( v5 )
  {
    sub_1433AB250(v13, (unsigned int)v9, (_DWORD)v8, 0, (__int64)a4);
    v6 = 1;
    v9[1] = a2;
    std::_Iterator_base12::operator=((_QWORD *)a2, v9);
    *(_BYTE *)(a2 + 8) = v6;
  }
  else
  {
    v7 = 0;
    v10 = unknown_libname_490(v12, (__int64)v8);
    v11 = a2;
    std::_Iterator_base12::operator=((_QWORD *)a2, v10);
    *(_BYTE *)(a2 + 8) = v7;
  }
  return a2;
}

// --- End Function: sub_1433AAFA0 (0x1433AAFA0) ---

// --- Function: sub_1433AB250 (0x1433AB250) ---
_QWORD *__fastcall sub_1433AB250(_QWORD *a1, _QWORD *a2, __int64 a3, char a4, _DWORD *a5)
{
  BOOL v6; // [rsp+24h] [rbp-14h]
  __int64 v7; // [rsp+28h] [rbp-10h]

  v6 = !a4 && (_QWORD *)a3 != a1 && *a5 >= *(_DWORD *)(a3 + 0x20);
  v7 = sub_1433AA1A0((__int64)a1, (__int64)a5);
  sub_1405A10C0(v7, (_QWORD *)a3, a1, v6);
  ++a1[4];
  unknown_libname_490(a2, v7);
  return a2;
}

// --- End Function: sub_1433AB250 (0x1433AB250) ---

// --- Function: sub_1433AC230 (0x1433AC230) ---
_QWORD *__fastcall sub_1433AC230(__int64 *a1, __int64 *a2)
{
  _QWORD *result; // rax
  __int64 v3; // [rsp+20h] [rbp-28h]
  __int64 v4; // [rsp+28h] [rbp-20h]
  __int64 v5; // [rsp+30h] [rbp-18h]

  v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  v4 = a1[1];
  a1[1] = a2[1];
  a2[1] = v4;
  v5 = a1[2];
  a1[2] = a2[2];
  result = a2 + 2;
  a2[2] = v5;
  return result;
}

// --- End Function: sub_1433AC230 (0x1433AC230) ---

// --- Function: sub_1434411E0 (0x1434411E0) ---
__int64 __fastcall sub_1434411E0(__int64 *a1)
{
  __int128 v1; // xmm0
  __int128 v3; // kr00_16
  _QWORD *v5; // rax
  _QWORD *v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  unsigned __int64 n4_2; // rax
  unsigned __int64 v11; // rax
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // r8
  __int64 v15; // rax
  __int64 v16; // r8
  __int64 v17; // rax
  unsigned __int64 n4_4; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  _QWORD *v23; // rax
  _QWORD *v25; // [rsp+30h] [rbp-DE8h] BYREF
  char n2_1; // [rsp+39h] [rbp-DDFh]
  char n2_2; // [rsp+3Ah] [rbp-DDEh]
  unsigned __int8 v29[8]; // [rsp+40h] [rbp-DD8h] BYREF
  char v30; // [rsp+48h] [rbp-DD0h]
  int n4_1; // [rsp+4Ch] [rbp-DCCh]
  unsigned int i; // [rsp+50h] [rbp-DC8h]
  unsigned int v33; // [rsp+54h] [rbp-DC4h]
  char v34; // [rsp+58h] [rbp-DC0h]
  char v35; // [rsp+59h] [rbp-DBFh]
  char v36; // [rsp+5Ah] [rbp-DBEh]
  unsigned __int8 v37; // [rsp+5Bh] [rbp-DBDh]
  char v38; // [rsp+5Ch] [rbp-DBCh]
  char v39; // [rsp+5Dh] [rbp-DBBh]
  char v40; // [rsp+5Eh] [rbp-DBAh]
  char v41; // [rsp+5Fh] [rbp-DB9h]
  char v42; // [rsp+60h] [rbp-DB8h]
  char v43; // [rsp+61h] [rbp-DB7h]
  char v44; // [rsp+63h] [rbp-DB5h]
  float v45; // [rsp+64h] [rbp-DB4h]
  float v46; // [rsp+68h] [rbp-DB0h]
  float v47; // [rsp+6Ch] [rbp-DACh] BYREF
  unsigned int v48; // [rsp+70h] [rbp-DA8h]
  unsigned int v49; // [rsp+74h] [rbp-DA4h]
  char n2; // [rsp+7Ch] [rbp-D9Ch]
  BOOL v53; // [rsp+88h] [rbp-D90h]
  unsigned __int64 n4; // [rsp+90h] [rbp-D88h]
  _QWORD *v55; // [rsp+98h] [rbp-D80h]
  _QWORD *v56; // [rsp+A0h] [rbp-D78h]
  float v57; // [rsp+A8h] [rbp-D70h]
  int v58; // [rsp+ACh] [rbp-D6Ch]
  float v59; // [rsp+B0h] [rbp-D68h]
  int *v60; // [rsp+B8h] [rbp-D60h]
  unsigned __int64 v61; // [rsp+C0h] [rbp-D58h] BYREF
  __int64 v62; // [rsp+C8h] [rbp-D50h]
  __int64 *v63; // [rsp+D0h] [rbp-D48h]
  char v64; // [rsp+D8h] [rbp-D40h]
  __int64 *v65; // [rsp+E0h] [rbp-D38h]
  char v66; // [rsp+E8h] [rbp-D30h]
  __int64 v67; // [rsp+F0h] [rbp-D28h]
  __int64 v68; // [rsp+F8h] [rbp-D20h]
  __int64 v69; // [rsp+100h] [rbp-D18h]
  __int64 v70; // [rsp+108h] [rbp-D10h]
  __int64 v71; // [rsp+110h] [rbp-D08h]
  __int64 v72; // [rsp+118h] [rbp-D00h]
  __int64 v73; // [rsp+120h] [rbp-CF8h] BYREF
  float *v74; // [rsp+128h] [rbp-CF0h]
  float *v75; // [rsp+130h] [rbp-CE8h]
  __int64 v76; // [rsp+138h] [rbp-CE0h]
  __int64 v77; // [rsp+140h] [rbp-CD8h]
  __int64 v78; // [rsp+148h] [rbp-CD0h]
  __int64 v79; // [rsp+150h] [rbp-CC8h]
  __int64 v80; // [rsp+158h] [rbp-CC0h]
  __int64 *v81; // [rsp+160h] [rbp-CB8h]
  __int64 *v82; // [rsp+168h] [rbp-CB0h]
  __int64 v83; // [rsp+170h] [rbp-CA8h] BYREF
  __int64 v84; // [rsp+178h] [rbp-CA0h]
  __int64 v85; // [rsp+180h] [rbp-C98h]
  float *v86; // [rsp+188h] [rbp-C90h]
  __int64 v87; // [rsp+190h] [rbp-C88h]
  __int64 v88; // [rsp+198h] [rbp-C80h] BYREF
  _QWORD *v89; // [rsp+1A0h] [rbp-C78h]
  _QWORD *v90; // [rsp+1A8h] [rbp-C70h]
  double (__fastcall *v91)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+1B0h] [rbp-C68h]
  __int64 *v92; // [rsp+1B8h] [rbp-C60h]
  __int64 v93; // [rsp+1C0h] [rbp-C58h]
  __int64 *v94; // [rsp+1C8h] [rbp-C50h]
  __int64 *v95; // [rsp+1D0h] [rbp-C48h]
  _QWORD *v96; // [rsp+1D8h] [rbp-C40h] BYREF
  __int64 v97; // [rsp+1E0h] [rbp-C38h]
  _BYTE *v98; // [rsp+1E8h] [rbp-C30h]
  double (__fastcall *v99)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+1F0h] [rbp-C28h]
  __int64 v100; // [rsp+1F8h] [rbp-C20h]
  void (__fastcall *v101)(__int64, __int64); // [rsp+200h] [rbp-C18h]
  __int64 *v102; // [rsp+208h] [rbp-C10h]
  __int64 *v103; // [rsp+210h] [rbp-C08h]
  __int64 (__fastcall *v104)(_QWORD); // [rsp+218h] [rbp-C00h]
  __int64 v105; // [rsp+228h] [rbp-BF0h]
  char *v106; // [rsp+230h] [rbp-BE8h]
  double (__fastcall *v107)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+238h] [rbp-BE0h]
  __int64 v108; // [rsp+240h] [rbp-BD8h]
  void (__fastcall *v109)(__int64, __int64); // [rsp+248h] [rbp-BD0h]
  __int64 v110; // [rsp+250h] [rbp-BC8h]
  _BYTE *v111; // [rsp+258h] [rbp-BC0h]
  __int64 v112; // [rsp+260h] [rbp-BB8h]
  __int64 v113; // [rsp+268h] [rbp-BB0h]
  unsigned __int64 v114; // [rsp+270h] [rbp-BA8h]
  unsigned __int8 (__fastcall *v115)(__int64, __int64 *, char *); // [rsp+278h] [rbp-BA0h]
  __int64 v116; // [rsp+280h] [rbp-B98h]
  __int64 (__fastcall *v117)(_QWORD); // [rsp+288h] [rbp-B90h]
  __int64 *v118; // [rsp+298h] [rbp-B80h]
  __int64 *v119; // [rsp+2A0h] [rbp-B78h]
  __int64 (__fastcall *v120)(_QWORD); // [rsp+2A8h] [rbp-B70h]
  double (__fastcall *v121)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+2B0h] [rbp-B68h]
  __int64 v122; // [rsp+2B8h] [rbp-B60h]
  __int64 (__fastcall *v123)(_QWORD); // [rsp+2C0h] [rbp-B58h]
  __int64 (__fastcall *v124)(_QWORD); // [rsp+2C8h] [rbp-B50h]
  __int64 *v125; // [rsp+2D0h] [rbp-B48h]
  __int64 *v126; // [rsp+2D8h] [rbp-B40h]
  _QWORD *v127; // [rsp+2E0h] [rbp-B38h]
  __int64 v128; // [rsp+2E8h] [rbp-B30h] BYREF
  void (__fastcall *v129)(__int64, int *); // [rsp+2F0h] [rbp-B28h]
  int v130[2]; // [rsp+2F8h] [rbp-B20h] BYREF
  unsigned __int64 n4_3; // [rsp+300h] [rbp-B18h]
  void (__fastcall *v132)(__int64, unsigned __int64 *, __int64); // [rsp+308h] [rbp-B10h]
  __int64 (__fastcall *v133)(__int64, _BYTE *, _QWORD); // [rsp+310h] [rbp-B08h]
  __int64 v134; // [rsp+318h] [rbp-B00h]
  __int64 *v135; // [rsp+320h] [rbp-AF8h]
  __int64 v136; // [rsp+328h] [rbp-AF0h]
  __int64 v137; // [rsp+330h] [rbp-AE8h]
  __int64 v138; // [rsp+338h] [rbp-AE0h]
  _QWORD *v139; // [rsp+340h] [rbp-AD8h]
  __int64 v140; // [rsp+348h] [rbp-AD0h]
  __int64 *v141; // [rsp+350h] [rbp-AC8h]
  __int64 v142; // [rsp+358h] [rbp-AC0h]
  double (__fastcall *v143)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+360h] [rbp-AB8h]
  __int64 (__fastcall *v144)(__int64, int *, _QWORD *, _QWORD); // [rsp+368h] [rbp-AB0h]
  __int64 (__fastcall *v145)(_QWORD); // [rsp+370h] [rbp-AA8h]
  double v146; // [rsp+378h] [rbp-AA0h]
  double (__fastcall *v147)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+380h] [rbp-A98h]
  __int64 (__fastcall *v148)(__int64, int *, _QWORD *, _QWORD); // [rsp+388h] [rbp-A90h]
  __int64 (__fastcall *v149)(_QWORD); // [rsp+390h] [rbp-A88h]
  __int64 (__fastcall *v150)(_QWORD); // [rsp+398h] [rbp-A80h]
  __int64 (__fastcall *v151)(__int64, _BYTE *); // [rsp+3A0h] [rbp-A78h]
  _QWORD v152[7]; // [rsp+3A8h] [rbp-A70h] BYREF
  __int64 (__fastcall *v153)(__int64, _BYTE *); // [rsp+3E0h] [rbp-A38h]
  _QWORD v154[2]; // [rsp+3E8h] [rbp-A30h] BYREF
  _QWORD v155[5]; // [rsp+3F8h] [rbp-A20h] BYREF
  _QWORD dst__4[10]; // [rsp+420h] [rbp-9F8h] BYREF
  _QWORD v157[4]; // [rsp+470h] [rbp-9A8h] BYREF
  _QWORD dst__2[10]; // [rsp+490h] [rbp-988h] BYREF
  _QWORD dst__3[10]; // [rsp+4E0h] [rbp-938h] BYREF
  _QWORD dst__1[10]; // [rsp+530h] [rbp-8E8h] BYREF
  _QWORD dst__8[10]; // [rsp+580h] [rbp-898h] BYREF
  _QWORD dst__10[10]; // [rsp+5D0h] [rbp-848h] BYREF
  _QWORD dst_[10]; // [rsp+620h] [rbp-7F8h] BYREF
  _BYTE v164[8]; // [rsp+670h] [rbp-7A8h] BYREF
  __int64 v165; // [rsp+678h] [rbp-7A0h] BYREF
  _BYTE v166[8]; // [rsp+680h] [rbp-798h] BYREF
  __int64 n0x32; // [rsp+688h] [rbp-790h]
  __int64 v168; // [rsp+690h] [rbp-788h] BYREF
  __int64 v169; // [rsp+698h] [rbp-780h] BYREF
  _BYTE v170[8]; // [rsp+6A0h] [rbp-778h] BYREF
  _BYTE v171[8]; // [rsp+6A8h] [rbp-770h] BYREF
  __int64 v172; // [rsp+6B0h] [rbp-768h] BYREF
  __int64 v173; // [rsp+6B8h] [rbp-760h] BYREF
  __int64 v174[3]; // [rsp+6C0h] [rbp-758h] BYREF
  _BYTE dst__5[24]; // [rsp+6D8h] [rbp-740h] BYREF
  _QWORD src__1[8]; // [rsp+6F0h] [rbp-728h] BYREF
  __m256i dst__9; // [rsp+730h] [rbp-6E8h] BYREF
  _BYTE src_[48]; // [rsp+750h] [rbp-6C8h] BYREF
  _QWORD buf__6[6]; // [rsp+780h] [rbp-698h] BYREF
  _BYTE v180[32]; // [rsp+7B0h] [rbp-668h] BYREF
  _QWORD buf_[6]; // [rsp+7D0h] [rbp-648h] BYREF
  _QWORD buf__1[6]; // [rsp+800h] [rbp-618h] BYREF
  _QWORD buf__2[6]; // [rsp+830h] [rbp-5E8h] BYREF
  _QWORD buf__3[6]; // [rsp+860h] [rbp-5B8h] BYREF
  _QWORD buf__4[6]; // [rsp+890h] [rbp-588h] BYREF
  _QWORD buf__5[6]; // [rsp+8C0h] [rbp-558h] BYREF
  _BYTE dst__7[64]; // [rsp+8F0h] [rbp-528h] BYREF
  _BYTE dst__6[64]; // [rsp+930h] [rbp-4E8h] BYREF
  _BYTE v189[64]; // [rsp+970h] [rbp-4A8h] BYREF
  int v190; // [rsp+9B0h] [rbp-468h] BYREF
  _QWORD v191[9]; // [rsp+9B8h] [rbp-460h] BYREF
  float v192; // [rsp+A00h] [rbp-418h] BYREF
  float v193; // [rsp+A04h] [rbp-414h]
  _DWORD v194[12]; // [rsp+A18h] [rbp-400h] BYREF
  __int64 v195; // [rsp+A48h] [rbp-3D0h]
  __int64 v196; // [rsp+A50h] [rbp-3C8h]
  _DWORD v197[12]; // [rsp+A60h] [rbp-3B8h] BYREF
  int v198[216]; // [rsp+A90h] [rbp-388h] BYREF

  sub_1402B3C60(dst_);
  memset(buf_, 0, sizeof(buf_));
  qmemcpy(dst_, sub_1402B3C60(buf_), 0x30u);
  dst_[2] = __rdtsc();
  HIDWORD(dst_[0]) = 0;
  BYTE4(dst_[1]) = 0;
  LOWORD(dst_[0]) = 0x5E00;
  v152[6] = qword_149C89AA0;
  qword_149C89AA0(
    dst_,
    &word_149F62E24,
    "CUsableTacticalPointSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UsableTacticalPointSystem.cpp",
    0x2C7);
  WORD1(dst_[0]) = word_149F62E24;
  v67 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x60);
  v153 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v67 + 0x48LL);
  v90 = (_QWORD *)v153(v67, v171);
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&v1 + 1);
  *(double *)&v3 = *(float *)(n29 + 0xE68);
  _XMM0 = v3;
  __asm { vmovupd xmm1, xmm0 }
  v89 = sub_1402B3B40(&v172, *(double *)&_XMM1);
  sub_14059CA80(v90, v152, v89);
  v47 = 0.0;
  v58 = 0;
  v33 = 0;
  v48 = 0;
  v49 = 0;
  sub_1402B3C60(dst__1);
  memset(buf__1, 0, sizeof(buf__1));
  qmemcpy(dst__1, sub_1402B3C60(buf__1), 0x30u);
  dst__1[2] = __rdtsc();
  HIDWORD(dst__1[0]) = 1;
  BYTE4(dst__1[1]) = 0;
  LOWORD(dst__1[0]) = 0x5E00;
  v91 = qword_149C89AA0;
  qword_149C89AA0(
    dst__1,
    &word_149F62E28,
    "CUsableTacticalPointSystem::Update: Processing running queries",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UsableTacticalPointSystem.cpp",
    0x2D2);
  WORD1(dst__1[0]) = word_149F62E28;
  v65 = a1 + 8;
  v66 = 1;
  v92 = a1 + 8;
  sub_1402E0A70((__int64)(a1 + 8), "CUsableTacticalPointSystem::Update", "m_runningQueriesLock", 1);
  v93 = a1[0xF];
  v48 = v93;
  v94 = a1 + 0xB;
  unknown_libname_490(&v25, a1[0xC]);
  while ( 1 )
  {
    v95 = a1 + 0xB;
    unknown_libname_490(&v96, (__int64)(a1 + 0xB));
    v53 = v25 != v96;
    if ( v25 == v96 )
      break;
    v97 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
        + 0x75;
    v98 = (_BYTE *)sub_1402A4D50(v97);
    if ( *v98 )
    {
      sub_1402B3C60(dst__2);
      memset(buf__2, 0, sizeof(buf__2));
      qmemcpy(dst__2, sub_1402B3C60(buf__2), 0x30u);
      dst__2[2] = __rdtsc();
      HIDWORD(dst__2[0]) = 1;
      BYTE4(dst__2[1]) = 0;
      LOWORD(dst__2[0]) = 0x5E00;
      v99 = qword_149C89AA0;
      qword_149C89AA0(
        dst__2,
        &word_149F62E2C,
        "CUsableTacticalPointSystem::Update: Processing running queries - Cancelled",
        "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UsableTacticalPointSystem.cpp",
        0x2DA);
      WORD1(dst__2[0]) = word_149F62E2C;
      v68 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x118);
      v101 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v68 + 0x48LL);
      v100 = *(_QWORD *)(std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
                       + 8);
      v101(v68, v100);
      v103 = a1 + 0xB;
      v102 = &v173;
      v5 = std::_Iterator_base12::operator=(&v173, &v25);
      v6 = (_QWORD *)sub_143457570(v103, v164, *v5);
      std::_Iterator_base12::operator=(&v25, v6);
      v43 = 0;
      dst__2[3] = __rdtsc();
      v104 = qword_149C89AA8;
      qword_149C89AA8(dst__2);
    }
    else
    {
      v105 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
           + 0x74;
      v106 = (char *)unknown_libname_491(v105);
      n2_1 = *v106;
      n2_2 = n2_1;
      n2 = n2_1;
      if ( n2_1 )
      {
        if ( n2 == 2 )
        {
          v119 = a1 + 0xB;
          v118 = &v165;
          v12 = std::_Iterator_base12::operator=(&v165, &v25);
          v13 = (_QWORD *)sub_143457570(v119, v166, *v12);
          std::_Iterator_base12::operator=(&v25, v13);
        }
        else
        {
          sub_142C90F00(&v25);
        }
      }
      else
      {
        sub_1402B3C60(dst__3);
        memset(buf__3, 0, sizeof(buf__3));
        qmemcpy(dst__3, sub_1402B3C60(buf__3), 0x30u);
        dst__3[2] = __rdtsc();
        HIDWORD(dst__3[0]) = 1;
        BYTE4(dst__3[1]) = 0;
        LOWORD(dst__3[0]) = 0x5E00;
        v107 = qword_149C89AA0;
        qword_149C89AA0(
          dst__3,
          &word_149F62E30,
          "CUsableTacticalPointSystem::Update: Processing running queries - Running",
          "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UsableTacticalPointSystem.cpp",
          0x2E5);
        WORD1(dst__3[0]) = word_149F62E30;
        v69 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x118);
        v109 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v69 + 0x48LL);
        v108 = *(_QWORD *)(std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
                         + 8);
        v109(v69, v108);
        *(_QWORD *)(std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
                  + 8) = 0xFFFFFFFFFFFFFFFFuLL;
        v110 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
             + 0x74;
        v29[0] = 1;
        v111 = (_BYTE *)unknown_libname_491(v110);
        v30 = sub_14332BF90(v29);
        *v111 = v30;
        v7 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25);
        v112 = v7 + 0x28;
        v70 = v7 + 0x28;
        if ( *(_QWORD *)(v7 + 0x28) != *(_QWORD *)(v7 + 0x30) )
        {
          v8 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25);
          sub_1403D3830(v8 + 0x40);
          for ( n4 = 0; ; ++n4 )
          {
            v9 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25);
            n4_2 = sub_1403BB1A0(v9 + 0x90);
            if ( n4 >= n4_2 )
              break;
            v113 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
                 + 0x90;
            v71 = sub_1403B92F0(v113, n4);
            for ( i = 0; ; ++i )
            {
              v114 = i;
              v11 = sub_1403BAC10(v71);
              if ( v114 >= v11 )
                break;
              sub_1403BABD0(v71, (__int64)&v73, i);
              v72 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x18);
              v115 = *(unsigned __int8 (__fastcall **)(__int64, __int64 *, char *))(*(_QWORD *)v72 + 0x50LL);
              if ( v115(v72, &v73, (char *)a1 + 0xB4) )
              {
                v116 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v25)
                     + 0x40;
                sub_140393EC0(v116, n4, &v73);
              }
            }
          }
        }
        sub_142C90F00(&v25);
        v44 = 0;
        dst__3[3] = __rdtsc();
        v117 = qword_149C89AA8;
        qword_149C89AA8(dst__3);
      }
    }
  }
  if ( v65 && v66 )
    sub_1402E0B70((__int64)v65);
  v34 = 0;
  dst__1[3] = __rdtsc();
  v120 = qword_149C89AA8;
  qword_149C89AA8(dst__1);
  while ( 1 )
  {
    sub_1402B3C60(dst__4);
    memset(buf__4, 0, sizeof(buf__4));
    qmemcpy(dst__4, sub_1402B3C60(buf__4), 0x30u);
    dst__4[2] = __rdtsc();
    HIDWORD(dst__4[0]) = 1;
    BYTE4(dst__4[1]) = 0;
    LOWORD(dst__4[0]) = 0x5E00;
    v121 = qword_149C89AA0;
    qword_149C89AA0(
      dst__4,
      &word_149F62E34,
      "CUsableTacticalPointSystem::Update: Processing queued query",
      "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UsableTacticalPointSystem.cpp",
      0x30D);
    WORD1(dst__4[0]) = word_149F62E34;
    v190 = 0;
    sub_140455620(v191);
    sub_143354C30((__int64)&v192);
    v81 = a1;
    sub_14321C370((__int64)v155, (__int64)a1, (__int64)(a1 + 5));
    v122 = *(_QWORD *)(v155[0] + 0x20LL);
    v49 = v122;
    if ( *(_QWORD *)(v155[0] + 0x20LL) == 0 )
      break;
    v60 = (int *)sub_143458280(v155[0]);
    v190 = *v60;
    sub_14046C930((__int64)v191, (__int64)(v60 + 2));
    sub_1433601D0((__int64)&v192, (__int64)(v60 + 0x14), v14);
    sub_143458C60(v155[0]);
    sub_142C8CD20((__int64)v155);
    ++v33;
    v47 = *sub_14030BA70(&v47, &v192);
    if ( sub_1419AF770((__int64)v191) )
    {
      v76 = 0;
      v63 = a1 + 8;
      v64 = 1;
      v125 = a1 + 8;
      sub_1402E0A70((__int64)(a1 + 8), "CUsableTacticalPointSystem::Update", "m_runningQueriesLock", 1);
      v126 = a1 + 0xB;
      sub_1433AAFA0((__int64)(a1 + 0xB), (__int64)v154, v37, &v190);
      v38 = 0;
      v15 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(v154);
      sub_1433601D0(v15 + 0x78, (__int64)&v192, v16);
      v17 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(v154);
      *(_DWORD *)(v17 + 0x70) = v190;
      v76 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(v154)
          + 8;
      if ( v63 && v64 )
        sub_1402E0B70((__int64)v63);
      v55 = (_QWORD *)v76;
      n0x32 = 0x32;
      sub_1402B0A70(&v128, (__int64)"CUsableTacticalPointSystem::Update", v76 + 8, 1u);
      v127 = v55 + 4;
      sub_140306C00((__int64)(v55 + 4), 0x32u);
      sub_1402B3ED0(&v128);
      v45 = v193;
      v59 = v193 * v193;
      v46 = v192;
      v57 = v192 * v192;
      qmemcpy(dst__5, (const void *)(sub_1419A7020((__int64)v191, (__int64)v189) + 0x20), sizeof(dst__5));
      sub_140455660((__int64)src_, (__int64)v191);
      src__1[0] = v55;
      qmemcpy(&src__1[1], src_, 0x28u);
      *(float *)&src__1[6] = v45;
      *((float *)&src__1[6] + 1) = v59;
      *(float *)&src__1[7] = v46;
      *((float *)&src__1[7] + 1) = v57;
      qmemcpy(dst__6, src__1, sizeof(dst__6));
      qmemcpy(dst__7, dst__6, sizeof(dst__7));
      sub_1433142D0(v157, (__int64)dst__7);
      v77 = sub_1419AF770((__int64)v191);
      v129 = *(void (__fastcall **)(__int64, int *))(*(_QWORD *)v77 + 0x10LL);
      v129(v77, v130);
      sub_140372710((__int64)v198, 0x7832, *(__int64 *)v130, 0x5E, "Usable Query");
      sub_142347EC0((__int64)v198);
      sub_1419439A0((__int64)v198, 4);
      sub_140363600((__int64)v197, (__int64)v194);
      if ( sub_1403BB1A0((__int64)v197) )
      {
        for ( n4_1 = 0; ; ++n4_1 )
        {
          n4_3 = n4_1;
          n4_4 = sub_1403BB1A0((__int64)v197);
          if ( n4_3 >= n4_4 )
            break;
          sub_140393EC0((__int64)v197, n4_1, (__int64 *)((char *)a1 + 0xBC));
          sub_140393240((__int64)v197, n4_1, (__int64 *)((char *)a1 + 0xC4));
        }
      }
      else
      {
        sub_140393EC0((__int64)v197, 0, (__int64 *)((char *)a1 + 0xBC));
        sub_140393240((__int64)v197, 0, (__int64 *)((char *)a1 + 0xC4));
      }
      sub_1403A9A40((__int64)v198, (__int64)v197);
      if ( sub_140382780(v196, 0) )
      {
        v78 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0xA0);
        v132 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v78 + 0x120LL);
        v132(v78, &v61, v196);
        if ( is_entity_descriptor_valid_or_accessible(&v61) )
        {
          v79 = sub_1403115A0(&v61);
          v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v79 + 0x668LL))(v79);
          sub_1403A9A50((__int64)v198, v19, 0);
          v80 = sub_1403115A0(&v61);
          v133 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v80 + 0x2C8LL);
          qmemcpy(dst__5, (const void *)v133(v80, v180, 0), sizeof(dst__5));
        }
      }
      v134 = v195;
      v135 = sub_1426B8660(&v168);
      v136 = *v135;
      v88 = v136;
      if ( is_valid_handle_typeA(&v88) )
      {
        v137 = v88 & 0xFFFFFFFFFFFFLL;
        v20 = sub_1419AA8C0(v88 & 0xFFFFFFFFFFFFLL);
        sub_141672DD0(v174, v20);
        v82 = v174;
        v56 = (_QWORD *)v174[0];
        v138 = v174[1];
        while ( v56 != (_QWORD *)v138 )
        {
          v139 = v56;
          v140 = *v56;
          v141 = sub_1416150C0(&v169);
          v142 = *v141;
          v83 = v142;
          if ( is_valid_handle_typeA(&v83) )
            v62 = v83 & 0xFFFFFFFFFFFFLL;
          else
            v62 = 0;
          if ( v62 )
          {
            sub_14054B800((__int64)v198, v62);
            sub_1402B3C60(dst__8);
            memset(buf__5, 0, sizeof(buf__5));
            qmemcpy(dst__8, sub_1402B3C60(buf__5), 0x30u);
            dst__8[2] = __rdtsc();
            HIDWORD(dst__8[0]) = 1;
            BYTE4(dst__8[1]) = 0;
            LOWORD(dst__8[0]) = 0x5E00;
            v143 = qword_149C89AA0;
            qword_149C89AA0(
              dst__8,
              &word_149F62E38,
              "CUsableTacticalPointSystem::Update - Zone Query Area Culling",
              "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UsableTacticalPointSystem.cpp",
              0x372);
            WORD1(dst__8[0]) = word_149F62E38;
            v84 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0xA0);
            v144 = *(__int64 (__fastcall **)(__int64, int *, _QWORD *, _QWORD))(*(_QWORD *)v84 + 0x1C0LL);
            v21 = v144(v84, v198, v157, 0);
            *v55 = v21;
            v39 = 0;
            dst__8[3] = __rdtsc();
            v145 = qword_149C89AA8;
            qword_149C89AA8(dst__8);
          }
          ++v56;
        }
        sub_1403749E0(v174);
      }
      else
      {
        v146 = v192;
        qmemcpy(&dst__9, dst__5, 0x18u);
        *(double *)&dst__9.m256i_i64[3] = v192;
        sub_1403A9A30((__int64)v198, &dst__9);
        sub_1402B3C60(dst__10);
        memset(buf__6, 0, sizeof(buf__6));
        qmemcpy(dst__10, sub_1402B3C60(buf__6), 0x30u);
        dst__10[2] = __rdtsc();
        HIDWORD(dst__10[0]) = 1;
        BYTE4(dst__10[1]) = 0;
        LOWORD(dst__10[0]) = 0x5E00;
        v147 = qword_149C89AA0;
        qword_149C89AA0(
          dst__10,
          &word_149F62E3C,
          "CUsableTacticalPointSystem::Update - Zone Query Sphere Culling",
          "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UsableTacticalPointSystem.cpp",
          0x37C);
        WORD1(dst__10[0]) = word_149F62E3C;
        v85 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0xA0);
        v148 = *(__int64 (__fastcall **)(__int64, int *, _QWORD *, _QWORD))(*(_QWORD *)v85 + 0x1C0LL);
        v22 = v148(v85, v198, v157, 0);
        *v55 = v22;
        v40 = 0;
        dst__10[3] = __rdtsc();
        v149 = qword_149C89AA8;
        qword_149C89AA8(dst__10);
      }
      sub_140375A50(v197);
      sub_14037A590((__int64)v198);
      sub_1402A5330(v157);
      v86 = &v192;
      sub_140375A50(v194);
      sub_140373CC0((_QWORD *)v86 + 2);
      v41 = 0;
      dst__4[3] = __rdtsc();
      v150 = qword_149C89AA8;
      qword_149C89AA8(dst__4);
    }
    else
    {
      v75 = &v192;
      sub_140375A50(v194);
      sub_140373CC0((_QWORD *)v75 + 2);
      v36 = 0;
      dst__4[3] = __rdtsc();
      v124 = qword_149C89AA8;
      qword_149C89AA8(dst__4);
    }
    v87 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x60);
    v151 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v87 + 0x48LL);
    v23 = (_QWORD *)v151(v87, v170);
    if ( !sub_14059CAF0(v152, v23) )
      goto LABEL_51;
  }
  sub_142C8CD20((__int64)v155);
  v74 = &v192;
  sub_140375A50(v194);
  sub_140373CC0((_QWORD *)v74 + 2);
  v35 = 0;
  dst__4[3] = __rdtsc();
  v123 = qword_149C89AA8;
  qword_149C89AA8(dst__4);
LABEL_51:
  v152[1] = qword_149C89AF8;
  qword_149C89AF8(v33, &unk_149F62E40, "CUsableTacticalPointSystem Executed Queries");
  v152[2] = qword_149C89AF8;
  qword_149C89AF8(v48, &unk_149F62E44, "CUsableTacticalPointSystem Running Queries");
  v152[3] = qword_149C89AF8;
  qword_149C89AF8(v49, &unk_149F62E48, "CUsableTacticalPointSystem Queued Queries");
  v152[4] = qword_149C89AE0;
  qword_149C89AE0(
    "Executed queries[%i], Queued queries[%i], Running queries[%i], Biggest Search Distance[%.2f], Total resulting usable"
    "s across multiple queries[%i]",
    v33,
    v49,
    v48,
    v47,
    v58);
  v42 = 0;
  dst_[3] = __rdtsc();
  v152[5] = qword_149C89AA8;
  return qword_149C89AA8(dst_);
}

// --- End Function: sub_1434411E0 (0x1434411E0) ---

// --- Function: sub_143456070 (0x143456070) ---
__int64 *__fastcall sub_143456070(__int64 *a1, __int64 *a2)
{
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = a1[3];
  sub_1402B3D20(a2);
  a2[2] = v3;
  sub_1402E0C10(a2, a1);
  return a2;
}

// --- End Function: sub_143456070 (0x143456070) ---

// --- Function: sub_143456BE0 (0x143456BE0) ---
_QWORD *__fastcall sub_143456BE0(_QWORD **a1, Parameter *Parameter_1)
{
  *Parameter_1 = **a1;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_143456BE0 (0x143456BE0) ---

// --- Function: sub_143457570 (0x143457570) ---
_QWORD *__fastcall sub_143457570(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 **n0x10; // [rsp+20h] [rbp-18h] BYREF
  _QWORD *v7; // [rsp+50h] [rbp+18h] BYREF

  v7 = a3;
  unknown_libname_490(&n0x10, (__int64)a3);
  --*(_QWORD *)(a1 + 0x20);
  sub_142C90F00(&v7);
  sub_1405A0C80(n0x10, (__int64 ***)a1);
  sub_1433AA2D0(a1, (__int64)n0x10);
  unknown_libname_490(a2, (__int64)v7);
  return a2;
}

// --- End Function: sub_143457570 (0x143457570) ---

// --- Function: sub_143458280 (0x143458280) ---
__int64 __fastcall sub_143458280(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp-20h]
  _QWORD v3[3]; // [rsp+30h] [rbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 0x18);
  v3[0] = a1;
  v3[1] = v2;
  return sub_143361210(v3);
}

// --- End Function: sub_143458280 (0x143458280) ---

// --- Function: sub_143458C60 (0x143458C60) ---
__int64 __fastcall sub_143458C60(_QWORD *a1)
{
  __int64 result; // rax

  sub_14336A8A0(*(_QWORD *)(a1[1] + 8 * ((a1[2] - 1LL) & a1[3])), 0);
  if ( --a1[4] )
  {
    result = a1[3] + 1LL;
    a1[3] = result;
  }
  else
  {
    result = (__int64)a1;
    a1[3] = 0;
  }
  return result;
}

// --- End Function: sub_143458C60 (0x143458C60) ---

// --- Function: sub_14345B480 (0x14345B480) ---
__int64 __fastcall sub_14345B480(__int64 a1, __int64 a2)
{
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = a1 + 0x10;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_DWORD *)(a2 + 0x18) = 0;
  sub_142CE0550(a2);
  return a2;
}

// --- End Function: sub_14345B480 (0x14345B480) ---

// --- Function: ??0ContextTransitionTasks@CTX@@QEAA@PEAVTaskDomain@1@@Z (0x14345F3A0) ---
void __fastcall CTX::ContextTransitionTasks::ContextTransitionTasks(
        CTX::ContextTransitionTasks *this,
        CTX::TaskDomain *pDomain)
{
  sub_1431477C0(pDomain, this);
  sub_1431477C0(pDomain, (char *)this + 0x10);
  sub_1431477C0(pDomain, (char *)this + 0x20);
}

// --- End Function: ??0ContextTransitionTasks@CTX@@QEAA@PEAVTaskDomain@1@@Z (0x14345F3A0) ---

// --- Function: ??0TaskExecutor@CTX@@QEAA@PEAVTaskDomain@1@@Z (0x14345F660) ---
void __fastcall CTX::TaskExecutor::TaskExecutor(CTX::TaskExecutor *this, CTX::TaskDomain *pDomain)
{
  *((_QWORD *)this + 1) = pDomain;
  *(_QWORD *)this = off_1488D6138;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 0x24) = 0;
}

// --- End Function: ??0TaskExecutor@CTX@@QEAA@PEAVTaskDomain@1@@Z (0x14345F660) ---

// --- Function: sub_14345FEE0 (0x14345FEE0) ---
__int64 __fastcall sub_14345FEE0(_QWORD *a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx
  volatile signed __int32 *v5; // rbx

  v1 = (volatile signed __int32 *)a1[5];
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v4 = (volatile signed __int32 *)a1[3];
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      result = (unsigned int)_InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
  }
  v5 = (volatile signed __int32 *)a1[1];
  if ( v5 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v5)(v5);
      if ( _InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
    }
  }
  return result;
}

// --- End Function: sub_14345FEE0 (0x14345FEE0) ---

// --- Function: sub_143466060 (0x143466060) ---
__int64 __fastcall sub_143466060(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rbx
  int v4; // eax
  int v5; // eax

  result = *(unsigned int *)(a1 + 0x50);
  if ( (_DWORD)result )
  {
    v3 = *(_QWORD *)(a1 + 0x40);
    *(_DWORD *)(a1 + 0x50) = result - 1;
    if ( v3 )
    {
      v4 = *(_DWORD *)(v3 + 0x20);
      if ( v4 )
      {
        v5 = v4 - 1;
        *(_DWORD *)(v3 + 0x20) = v5;
        if ( !v5 )
        {
          if ( qword_149F63B20 )
            (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149F63B20 + 0x20LL))(qword_149F63B20, v3);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x20LL))(v3);
          if ( *(_BYTE *)(v3 + 0x24) )
            sub_143468DD0(v3);
        }
      }
    }
    return sub_14347DC40(a1);
  }
  return result;
}

// --- End Function: sub_143466060 (0x143466060) ---

// --- Function: sub_143472240 (0x143472240) ---
__int64 __fastcall sub_143472240(__int64 a1)
{
  _DWORD *v1; // rbx
  __int64 result; // rax

  ++*(_DWORD *)(a1 + 0x50);
  v1 = *(_DWORD **)(a1 + 0x40);
  if ( v1 )
  {
    if ( ++v1[8] == 1 )
    {
      if ( qword_149F63B20 )
        (*(void (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149F63B20 + 0x18LL))(qword_149F63B20, v1);
      return (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v1 + 0x18LL))(v1);
    }
  }
  return result;
}

// --- End Function: sub_143472240 (0x143472240) ---

// --- Function: sub_1434787E0 (0x1434787E0) ---
_OWORD *__fastcall sub_1434787E0(_QWORD *a1, _OWORD *a2, __int64 *a3)
{
  __int64 v6; // rax
  _QWORD *v7; // rbx
  __int64 v8; // rax
  _QWORD *v9; // r14
  __int64 v10; // rax
  volatile signed __int32 *v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rbx
  __int64 v15; // rax
  volatile signed __int32 *v16; // rbx
  volatile signed __int32 *v17; // rbx
  __int128 v19; // [rsp+20h] [rbp-48h] BYREF
  _QWORD *v20; // [rsp+30h] [rbp-38h] BYREF
  volatile signed __int32 *v21; // [rsp+38h] [rbp-30h]

  v6 = sub_1402A65A0(0x70u);
  v7 = (_QWORD *)v6;
  if ( v6 )
  {
    sub_1430F0050(v6, *a1);
    v7[0xD] = a1;
    *v7 = off_1488D6170;
  }
  else
  {
    v7 = 0;
  }
  v19 = 0;
  v8 = sub_1402A65A0(0x18u);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = 1;
    *(_QWORD *)v8 = &off_1482CC5C0;
    *(_DWORD *)(v8 + 0xC) = 1;
    *(_QWORD *)(v8 + 0x10) = v7;
  }
  else
  {
    v8 = 0;
  }
  sub_140A56F50(&v19, v7, v8);
  v9 = (_QWORD *)sub_1402A65A0(0x20u);
  if ( v9 )
  {
    if ( *((_QWORD *)&v19 + 1) )
      _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v19 + 1) + 8LL));
    v10 = a3[1];
    if ( v10 )
      _InterlockedIncrement((volatile signed __int32 *)(v10 + 8));
    v11 = (volatile signed __int32 *)a3[1];
    v12 = *a3;
    *v9 = 0;
    v9[1] = 0;
    if ( v11 )
      _InterlockedIncrement(v11 + 2);
    v13 = *((_QWORD *)&v19 + 1);
    *v9 = v12;
    v9[1] = v11;
    v9[2] = 0;
    v9[3] = 0;
    if ( v13 )
      _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
    *((_OWORD *)v9 + 1) = v19;
    if ( v11 )
    {
      if ( _InterlockedExchangeAdd(v11 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
        if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
      }
    }
    if ( *((_QWORD *)&v19 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v19 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        v14 = *((_QWORD *)&v19 + 1);
        (***((void (__fastcall ****)(_QWORD))&v19 + 1))(*((_QWORD *)&v19 + 1));
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v14 + 0xC), 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v19 + 1) + 8LL))(*((_QWORD *)&v19 + 1));
      }
    }
  }
  else
  {
    v9 = 0;
  }
  v15 = sub_1402A65A0(0x18u);
  if ( v15 )
  {
    *(_DWORD *)(v15 + 8) = 1;
    *(_QWORD *)v15 = &off_1488D9410;
    *(_DWORD *)(v15 + 0xC) = 1;
    *(_QWORD *)(v15 + 0x10) = v9;
  }
  else
  {
    v15 = 0;
  }
  v20 = v9;
  v21 = (volatile signed __int32 *)v15;
  sub_143480310(a1 + 1, &v20);
  if ( v21 )
  {
    if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
    {
      v16 = v21;
      (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
      if ( _InterlockedExchangeAdd(v16 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v21 + 8LL))(v21);
    }
  }
  sub_14347DC40(a1);
  v17 = (volatile signed __int32 *)a3[1];
  *a2 = v19;
  if ( v17 )
  {
    if ( _InterlockedExchangeAdd(v17 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v17)(v17);
      if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v17 + 8LL))(v17);
    }
  }
  return a2;
}

// --- End Function: sub_1434787E0 (0x1434787E0) ---

// --- Function: sub_14349C1B0 (0x14349C1B0) ---
__int64 __fastcall sub_14349C1B0(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int64 v6; // rcx
  char v9; // si
  float v10; // xmm1_4
  float v11; // xmm0_4
  float v12; // xmm2_4
  __int64 v13; // rax
  unsigned int v14; // ecx
  __int64 v19; // rcx
  float v22; // xmm1_4
  float v23; // xmm0_4
  float v24; // xmm2_4
  __int64 v25; // rax
  unsigned int v26; // ecx
  __int64 v31; // rcx
  float v34; // xmm1_4
  float v35; // xmm0_4
  float v36; // xmm2_4
  __int64 v37; // rax
  unsigned int v38; // ecx
  __int64 v43; // rcx
  float v46; // xmm2_4
  float v47; // xmm2_4
  float v48; // xmm3_4
  __int64 v49; // rax
  unsigned int v50; // ecx
  __int64 v55; // rcx
  char v58; // al
  float v59; // xmm0_4
  char v60; // si
  __int64 v61; // rcx
  float v62; // xmm0_4
  __int64 v63; // rcx
  float v64; // xmm0_4
  float v65; // xmm0_4
  float v66; // xmm0_4
  float v67; // xmm0_4
  __int64 result; // rax
  __int64 v69; // [rsp+20h] [rbp-30h] BYREF
  float v70; // [rsp+28h] [rbp-28h]
  __int128 v71; // [rsp+30h] [rbp-20h]
  __int128 v72; // [rsp+40h] [rbp-10h]
  float v73; // [rsp+70h] [rbp+20h] BYREF
  float v74; // [rsp+78h] [rbp+28h] BYREF

  v72 = v3;
  v6 = *a2;
  v73 = 0.0;
  v71 = v4;
  v9 = 0;
  (*(void (__fastcall **)(__int64, const char *, float *))(*(_QWORD *)v6 + 0x198LL))(v6, "alpha", &v73);
  v10 = *(float *)(a1 + 0x10);
  if ( v10 != *(float *)(a3 + 0x10)
    || *(float *)(a1 + 0x14) != *(float *)(a3 + 0x14)
    || *(float *)(a1 + 0x18) != *(float *)(a3 + 0x18)
    || *(float *)(a1 + 0x1C) != *(float *)(a3 + 0x1C) )
  {
    *(float *)(a3 + 0x10) = v10;
    *(_DWORD *)(a3 + 0x14) = *(_DWORD *)(a1 + 0x14);
    *(_DWORD *)(a3 + 0x18) = *(_DWORD *)(a1 + 0x18);
    *(_DWORD *)(a3 + 0x1C) = *(_DWORD *)(a1 + 0x1C);
    v11 = *(float *)(a1 + 0x10);
    v12 = *(float *)(a1 + 0x18);
    HIDWORD(v69) = *(_DWORD *)(a1 + 0x14);
    *(float *)&v69 = v11;
    v70 = v12;
    v13 = sub_1434C0390(&v69);
    v69 = *(_QWORD *)v13;
    v14 = *(_DWORD *)(v13 + 8);
    _XMM0 = (unsigned int)v69;
    _XMM2 = HIDWORD(v69);
    __asm { vminss  xmm1, xmm0, xmm6 }
    *(float *)&v69 = *(float *)&_XMM1;
    _XMM1 = v14;
    v19 = *a2;
    __asm
    {
      vminss  xmm0, xmm2, xmm6
      vminss  xmm2, xmm1, xmm6
    }
    *((float *)&v69 + 1) = *(float *)&_XMM0;
    v70 = *(float *)&_XMM2;
    v9 = (*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v19 + 0x190LL))(
           v19,
           "diffuse",
           &v69) == 0;
  }
  v22 = *(float *)(a1 + 0x28);
  if ( v22 != *(float *)(a3 + 0x28)
    || *(float *)(a1 + 0x2C) != *(float *)(a3 + 0x2C)
    || *(float *)(a1 + 0x30) != *(float *)(a3 + 0x30)
    || *(float *)(a1 + 0x34) != *(float *)(a3 + 0x34) )
  {
    *(float *)(a3 + 0x28) = v22;
    *(_DWORD *)(a3 + 0x2C) = *(_DWORD *)(a1 + 0x2C);
    *(_DWORD *)(a3 + 0x30) = *(_DWORD *)(a1 + 0x30);
    *(_DWORD *)(a3 + 0x34) = *(_DWORD *)(a1 + 0x34);
    v23 = *(float *)(a1 + 0x28);
    v24 = *(float *)(a1 + 0x30);
    HIDWORD(v69) = *(_DWORD *)(a1 + 0x2C);
    *(float *)&v69 = v23;
    v70 = v24;
    v25 = sub_1434C0390(&v69);
    v69 = *(_QWORD *)v25;
    v26 = *(_DWORD *)(v25 + 8);
    _XMM0 = (unsigned int)v69;
    _XMM2 = HIDWORD(v69);
    __asm { vminss  xmm1, xmm0, xmm6 }
    *(float *)&v69 = *(float *)&_XMM1;
    _XMM1 = v26;
    v31 = *a2;
    __asm
    {
      vminss  xmm0, xmm2, xmm6
      vminss  xmm2, xmm1, xmm6
    }
    *((float *)&v69 + 1) = *(float *)&_XMM0;
    v70 = *(float *)&_XMM2;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v31 + 0x190LL))(
            v31,
            "emissive",
            &v69) )
      v9 = 1;
  }
  v34 = *(float *)(a1 + 0x40);
  if ( v34 != *(float *)(a3 + 0x40)
    || *(float *)(a1 + 0x44) != *(float *)(a3 + 0x44)
    || *(float *)(a1 + 0x48) != *(float *)(a3 + 0x48)
    || *(float *)(a1 + 0x4C) != *(float *)(a3 + 0x4C) )
  {
    *(float *)(a3 + 0x40) = v34;
    *(_DWORD *)(a3 + 0x44) = *(_DWORD *)(a1 + 0x44);
    *(_DWORD *)(a3 + 0x48) = *(_DWORD *)(a1 + 0x48);
    *(_DWORD *)(a3 + 0x4C) = *(_DWORD *)(a1 + 0x4C);
    v35 = *(float *)(a1 + 0x40);
    v36 = *(float *)(a1 + 0x48);
    HIDWORD(v69) = *(_DWORD *)(a1 + 0x44);
    *(float *)&v69 = v35;
    v70 = v36;
    v37 = sub_1434C0390(&v69);
    v69 = *(_QWORD *)v37;
    v38 = *(_DWORD *)(v37 + 8);
    _XMM0 = (unsigned int)v69;
    _XMM2 = HIDWORD(v69);
    __asm { vminss  xmm1, xmm0, xmm6 }
    *(float *)&v69 = *(float *)&_XMM1;
    _XMM1 = v38;
    v43 = *a2;
    __asm
    {
      vminss  xmm0, xmm2, xmm6
      vminss  xmm2, xmm1, xmm6
    }
    *((float *)&v69 + 1) = *(float *)&_XMM0;
    v70 = *(float *)&_XMM2;
    v9 |= (*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v43 + 0x190LL))(
            v43,
            "RimColor",
            &v69) == 0;
  }
  v46 = *(float *)(a1 + 0x58);
  if ( v46 != *(float *)(a3 + 0x58)
    || *(float *)(a1 + 0x5C) != *(float *)(a3 + 0x5C)
    || *(float *)(a1 + 0x60) != *(float *)(a3 + 0x60)
    || *(float *)(a1 + 0x64) != *(float *)(a3 + 0x64) )
  {
    *(float *)(a3 + 0x58) = v46;
    *(_DWORD *)(a3 + 0x5C) = *(_DWORD *)(a1 + 0x5C);
    *(_DWORD *)(a3 + 0x60) = *(_DWORD *)(a1 + 0x60);
    *(_DWORD *)(a3 + 0x64) = *(_DWORD *)(a1 + 0x64);
    v47 = *(float *)(a1 + 0x5C);
    v48 = *(float *)(a1 + 0x60);
    LODWORD(v69) = *(_DWORD *)(a1 + 0x58);
    *((float *)&v69 + 1) = v47;
    v70 = v48;
    v49 = sub_1434C0390(&v69);
    v69 = *(_QWORD *)v49;
    v50 = *(_DWORD *)(v49 + 8);
    _XMM0 = (unsigned int)v69;
    _XMM2 = HIDWORD(v69);
    __asm { vminss  xmm1, xmm0, xmm6 }
    *(float *)&v69 = *(float *)&_XMM1;
    _XMM1 = v50;
    v55 = *a2;
    __asm
    {
      vminss  xmm0, xmm2, xmm6
      vminss  xmm2, xmm1, xmm6
    }
    *((float *)&v69 + 1) = *(float *)&_XMM0;
    v70 = *(float *)&_XMM2;
    v9 |= (*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v55 + 0x190LL))(
            v55,
            "SilhouetteColor",
            &v69) == 0;
  }
  v58 = (*(__int64 (__fastcall **)(_QWORD, const char *, float *))(*(_QWORD *)*a2 + 0x188LL))(*a2, "alpha", &v73);
  v59 = *(float *)(a1 + 0x68);
  v60 = (v58 == 0) | v9;
  if ( v59 != *(float *)(a3 + 0x68) )
  {
    *(float *)(a3 + 0x68) = v59;
    v61 = *a2;
    v74 = 0.0099999998 * *(float *)(a1 + 0x68);
    v60 |= (*(unsigned __int8 (__fastcall **)(__int64, const char *, float *))(*(_QWORD *)v61 + 0x188LL))(
             v61,
             "opacity",
             &v74) == 0;
  }
  v62 = *(float *)(a1 + 0x6C);
  if ( v62 != *(float *)(a3 + 0x6C) )
  {
    *(float *)(a3 + 0x6C) = v62;
    v63 = *a2;
    v74 = 0.0099999998 * *(float *)(a1 + 0x6C);
    v60 |= (*(unsigned __int8 (__fastcall **)(__int64, const char *, float *))(*(_QWORD *)v63 + 0x188LL))(
             v63,
             "glow",
             &v74) == 0;
  }
  v64 = *(float *)(a1 + 0x70);
  if ( v64 != *(float *)(a3 + 0x70) )
  {
    *(float *)(a3 + 0x70) = v64;
    v60 |= (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a2 + 0x188LL))(*a2, "DiffuseAlpha") == 0;
  }
  v65 = *(float *)(a1 + 0x74);
  if ( v65 != *(float *)(a3 + 0x74) )
  {
    *(float *)(a3 + 0x74) = v65;
    v60 |= (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a2 + 0x188LL))(*a2, "RimAlpha") == 0;
  }
  v66 = *(float *)(a1 + 0x78);
  if ( v66 != *(float *)(a3 + 0x78) )
  {
    *(float *)(a3 + 0x78) = v66;
    v60 |= (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a2 + 0x188LL))(*a2, "SilhouetteAlpha") == 0;
  }
  v67 = *(float *)(a1 + 0x7C);
  if ( v67 != *(float *)(a3 + 0x7C) )
  {
    *(float *)(a3 + 0x7C) = v67;
    v60 |= (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a2 + 0x188LL))(
             *a2,
             "SilhouetteThickness") == 0;
  }
  result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1A8LL))(*a2);
  if ( v60 )
    result = sub_1434CE6A0(a3);
  if ( *a2 )
    result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x10LL))(*a2);
  *a2 = 0;
  return result;
}

// --- End Function: sub_14349C1B0 (0x14349C1B0) ---

// --- Function: sub_1434C2A20 (0x1434C2A20) ---
__int64 __fastcall sub_1434C2A20(__int64 a1)
{
  float v1; // xmm13_4
  float v2; // xmm11_4
  float v3; // xmm4_4
  __int64 result; // rax
  float v5; // xmm12_4
  float v6; // xmm10_4
  float v7; // xmm9_4
  float v8; // xmm7_4
  float v9; // xmm8_4
  float v10; // xmm5_4
  float v11; // xmm4_4

  *(_DWORD *)(a1 + 0x84) = *(_DWORD *)(a1 + 0x38);
  v1 = *(float *)(a1 + 0x3C);
  *(float *)(a1 + 0x88) = v1;
  v2 = *(float *)(a1 + 0x40);
  *(float *)(a1 + 0x8C) = v2;
  v3 = *(float *)(a1 + 0x44);
  *(float *)(a1 + 0x90) = v3;
  *(double *)(a1 + 0x94) = *(double *)(a1 + 0x48);
  *(_DWORD *)(a1 + 0x9C) = *(_DWORD *)(a1 + 0x50);
  *(_DWORD *)(a1 + 0xA0) = *(_DWORD *)(a1 + 0x54);
  result = a1 + 0x84;
  v5 = *(float *)(a1 + 0x80);
  v6 = *(float *)(a1 + 0x7C);
  v7 = *(float *)(a1 + 0x78);
  v8 = *(float *)(a1 + 0x84);
  v9 = (float)((float)(v5 * v1) - (float)(v6 * v2)) + (float)(v7 * v3);
  v10 = (float)((float)(v7 * v2) - (float)(v8 * v5)) + (float)(v6 * v3);
  v11 = (float)((float)(v8 * v6) - (float)(v7 * v1)) + (float)(v5 * v3);
  *(float *)(a1 + 0x94) = (float)(v7 + *(float *)(a1 + 0x94))
                        + (float)((float)((float)(v1 * v11) - (float)(v2 * v10))
                                + (float)((float)(v1 * v11) - (float)(v2 * v10)));
  *(float *)(a1 + 0x98) = (float)(v6 + *(float *)(a1 + 0x98))
                        + (float)((float)((float)(v2 * v9) - (float)(v8 * v11))
                                + (float)((float)(v2 * v9) - (float)(v8 * v11)));
  *(float *)(a1 + 0x9C) = (float)(v5 + *(float *)(a1 + 0x9C))
                        + (float)((float)((float)(v8 * v10) - (float)(v1 * v9))
                                + (float)((float)(v8 * v10) - (float)(v1 * v9)));
  return result;
}

// --- End Function: sub_1434C2A20 (0x1434C2A20) ---

// --- Function: sub_1434D1D10 (0x1434D1D10) ---
void __fastcall sub_1434D1D10(float *a1, float *a2, float *a3, float a4)
{
  a1[4] = (float)((float)(a3[4] - a2[4]) * a4) + a2[4];
  a1[5] = (float)((float)(a3[5] - a2[5]) * a4) + a2[5];
  a1[6] = (float)((float)(a3[6] - a2[6]) * a4) + a2[6];
  a1[7] = (float)((float)(a3[7] - a2[7]) * a4) + a2[7];
  a1[0xA] = (float)((float)(a3[0xA] - a2[0xA]) * a4) + a2[0xA];
  a1[0xB] = (float)((float)(a3[0xB] - a2[0xB]) * a4) + a2[0xB];
  a1[0xC] = (float)((float)(a3[0xC] - a2[0xC]) * a4) + a2[0xC];
  a1[0xD] = (float)((float)(a3[0xD] - a2[0xD]) * a4) + a2[0xD];
  a1[0x10] = (float)((float)(a3[0x10] - a2[0x10]) * a4) + a2[0x10];
  a1[0x11] = (float)((float)(a3[0x11] - a2[0x11]) * a4) + a2[0x11];
  a1[0x12] = (float)((float)(a3[0x12] - a2[0x12]) * a4) + a2[0x12];
  a1[0x13] = (float)((float)(a3[0x13] - a2[0x13]) * a4) + a2[0x13];
  a1[0x16] = (float)((float)(a3[0x16] - a2[0x16]) * a4) + a2[0x16];
  a1[0x17] = (float)((float)(a3[0x17] - a2[0x17]) * a4) + a2[0x17];
  a1[0x18] = (float)((float)(a3[0x18] - a2[0x18]) * a4) + a2[0x18];
  a1[0x19] = (float)((float)(a3[0x19] - a2[0x19]) * a4) + a2[0x19];
  a1[0x1A] = (float)((float)(a3[0x1A] - a2[0x1A]) * a4) + a2[0x1A];
  a1[0x1B] = (float)((float)(a3[0x1B] - a2[0x1B]) * a4) + a2[0x1B];
  a1[0x1C] = (float)((float)(a3[0x1C] - a2[0x1C]) * a4) + a2[0x1C];
  a1[0x1D] = (float)((float)(a3[0x1D] - a2[0x1D]) * a4) + a2[0x1D];
  a1[0x1E] = (float)((float)(a3[0x1E] - a2[0x1E]) * a4) + a2[0x1E];
  a1[0x1F] = (float)((float)(a3[0x1F] - a2[0x1F]) * a4) + a2[0x1F];
}

// --- End Function: sub_1434D1D10 (0x1434D1D10) ---

// --- Function: sub_1434E64F0 (0x1434E64F0) ---
__int64 __fastcall sub_1434E64F0(__int64 a1, __int64 a2)
{
  __int64 n29; // rax
  __int64 v3; // r10
  __int64 v4; // r9
  float v5; // xmm14_4
  __int64 v6; // r8
  __int128 v7; // kr00_16
  float v8; // xmm11_4
  float v9; // xmm12_4
  float v10; // xmm9_4
  float v11; // xmm13_4
  float v12; // xmm7_4
  float v13; // xmm5_4

  n29 = ::n29;
  if ( ((*(_DWORD *)(::n29 + 0x1D0) - 1) & 0xFFFFFFFD) == 0 )
  {
    *(_DWORD *)(a1 + 0x18) = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 0x1C) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 0x24) = *(_DWORD *)(a2 + 0xC);
    *(double *)(a1 + 0x28) = *(double *)(a2 + 0x10);
    *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x18);
    *(_DWORD *)(a1 + 0x34) = *(_DWORD *)(a2 + 0x1C);
    if ( *(float *)(a1 + 0x34) == 0.0 )
      *(_DWORD *)(a1 + 0x34) = 0x34000000;
    n29 = *(int *)(a1 + 0x208);
    v3 = *(_QWORD *)(a1 + 0x40);
    v4 = *(_QWORD *)(a1 + 0x38);
    v5 = flt_1488E3388[n29] * *(float *)(a1 + 8);
    if ( v4 != v3 )
    {
      v6 = v4 + 0x40;
      do
      {
        v7 = *(unsigned int *)(v6 - 0x34);
        v8 = *(float *)(a2 + 4);
        v9 = *(float *)(a2 + 8);
        v10 = *(float *)(a2 + 0x1C);
        v11 = *(float *)(a2 + 0xC);
        *(float *)&v7 = (float)(*(float *)&v7 * *(float *)(a1 + 0x20C)) + (float)(*(float *)&v7 + v5);
        v12 = (float)(v8 * (float)-(float)(v8 * *(float *)&v7)) - (float)(v9 * (float)(v9 * *(float *)&v7));
        v13 = (float)(*(float *)a2 * (float)(v9 * *(float *)&v7)) - (float)(v8 * (float)(*(float *)&v7 * v11));
        *(float *)&v7 = (float)((float)((float)(*(float *)&v7 + v12) + v12) * v10) + *(float *)(a2 + 0x10);
        _XMM6 = v7;
        *(float *)&v7 = (float)((float)(v13 + v13) * v10) + *(float *)(a2 + 0x18);
        *(float *)(v6 - 8) = *(float *)a2;
        *(float *)(v6 - 4) = v8;
        *(float *)v6 = v9;
        *(float *)(v6 + 4) = v11;
        __asm { vunpcklps xmm0, xmm6, xmm3 }
        *(double *)(v6 + 8) = *(double *)&_XMM0;
        v4 += 0xA8;
        *(float *)(v6 + 0x10) = *(float *)&v7;
        *(float *)(v6 + 0x14) = v10;
        v6 += 0xA8;
      }
      while ( v4 != v3 );
    }
  }
  return n29;
}

// --- End Function: sub_1434E64F0 (0x1434E64F0) ---

// --- Function: sub_1434ED130 (0x1434ED130) ---
__int64 __fastcall sub_1434ED130(__int64 a1)
{
  __int128 v1; // xmm6
  __int64 **v3; // rbx
  std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> > *v4; // r14
  std::_Tree_val<std::_Tree_simple_types<int> > *v5; // rsi
  __int64 *k; // rbx
  unsigned int v7; // edx
  __int64 *_Wherenode_1; // rax
  __int64 *_Wherenode_3; // rcx
  __int64 **v10; // rcx
  __int64 *_Wherenode; // rdx
  __int64 *_Wherenode_2; // rcx
  __int64 *i; // rcx
  __int64 *v14; // rdi
  void (__fastcall ***v15)(_QWORD, __int64); // rcx
  __int64 **v16; // rax
  __int64 *j; // rax
  __int64 *v18; // rcx
  __int64 *n; // rbx
  __int64 v20; // rdi
  __int64 v21; // rax
  __int64 **v22; // rax
  __int64 *m; // rax
  __int64 *v24; // rcx
  int n0x5F00; // [rsp+30h] [rbp-68h] BYREF
  __int64 v27; // [rsp+34h] [rbp-64h]
  int v28; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v29; // [rsp+40h] [rbp-58h]
  unsigned __int64 v30; // [rsp+48h] [rbp-50h]
  __int64 v31; // [rsp+50h] [rbp-48h]
  __int64 v32; // [rsp+58h] [rbp-40h]
  __int128 v33; // [rsp+80h] [rbp-18h]

  n0x5F00 = 0x5F00;
  v33 = v1;
  v27 = 1;
  v28 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v29 = __rdtsc();
  qword_149C89AA0(
    &n0x5F00,
    &word_149F6569C,
    "CInnerThoughtSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UI/InnerThought/InnerThought.cpp",
    0x57A);
  v3 = *(__int64 ***)(a1 + 0x68);
  v4 = (std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> > *)(a1 + 0x68);
  v5 = (std::_Tree_val<std::_Tree_simple_types<int> > *)(a1 + 0x58);
  HIWORD(n0x5F00) = word_149F6569C;
  k = *v3;
  while ( !*((_BYTE *)k + 0x19) )
  {
    v7 = *((_DWORD *)k + 7);
    _Wherenode_1 = *(__int64 **)v5;
    _Wherenode_3 = *(__int64 **)(*(_QWORD *)v5 + 8LL);
    while ( !*((_BYTE *)_Wherenode_3 + 0x19) )
    {
      if ( *((_DWORD *)_Wherenode_3 + 8) >= v7 )
      {
        _Wherenode_1 = _Wherenode_3;
        _Wherenode_3 = (__int64 *)*_Wherenode_3;
      }
      else
      {
        _Wherenode_3 = (__int64 *)_Wherenode_3[2];
      }
    }
    if ( !*((_BYTE *)_Wherenode_1 + 0x19) && v7 >= *((_DWORD *)_Wherenode_1 + 8) && _Wherenode_1 != *(__int64 **)v5 )
    {
      v10 = (__int64 **)_Wherenode_1[2];
      _Wherenode = _Wherenode_1;
      if ( *((_BYTE *)v10 + 0x19) )
      {
        for ( _Wherenode_2 = (__int64 *)_Wherenode_1[1];
              !*((_BYTE *)_Wherenode_2 + 0x19);
              _Wherenode_2 = (__int64 *)_Wherenode_2[1] )
        {
          if ( _Wherenode_1 != (__int64 *)_Wherenode_2[2] )
            break;
          _Wherenode_1 = _Wherenode_2;
        }
      }
      else
      {
        for ( i = *v10; !*((_BYTE *)i + 0x19); i = (__int64 *)*i )
          ;
      }
      v14 = sub_1402E2560(v5, _Wherenode);
      v15 = (void (__fastcall ***)(_QWORD, __int64))v14[5];
      if ( v15 )
        (**v15)(v15, 1);
      sub_1402A6590((__int64)v14);
    }
    v16 = (__int64 **)k[2];
    if ( *((_BYTE *)v16 + 0x19) )
    {
      for ( j = (__int64 *)k[1]; !*((_BYTE *)j + 0x19); j = (__int64 *)j[1] )
      {
        if ( k != (__int64 *)j[2] )
          break;
        k = j;
      }
      k = j;
    }
    else
    {
      v18 = *v16;
      for ( k = (__int64 *)k[2]; !*((_BYTE *)v18 + 0x19); v18 = (__int64 *)*v18 )
        k = v18;
    }
  }
  std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>>::clear(v4);
  n = **(__int64 ***)v5;
  while ( !*((_BYTE *)n + 0x19) )
  {
    v20 = n[5];
    if ( !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(v20 + 0x10))
      || (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v20 + 0x10) & 0xFFFFFFFFFFFFLL) + 0x58LL))(*(_QWORD *)(v20 + 0x10) & 0xFFFFFFFFFFFFLL) )
    {
      v21 = sub_140885420(qword_149FBE618);
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v21 + 0x30LL))(v21, *(unsigned int *)(v20 + 0x24));
    }
    else
    {
      sub_1434F2FC0(v20);
      sub_1434EEBA0(v20);
    }
    v22 = (__int64 **)n[2];
    if ( *((_BYTE *)v22 + 0x19) )
    {
      for ( m = (__int64 *)n[1]; !*((_BYTE *)m + 0x19); m = (__int64 *)m[1] )
      {
        if ( n != (__int64 *)m[2] )
          break;
        n = m;
      }
      n = m;
    }
    else
    {
      v24 = *v22;
      for ( n = (__int64 *)n[2]; !*((_BYTE *)v24 + 0x19); v24 = (__int64 *)*v24 )
        n = v24;
    }
  }
  v30 = __rdtsc();
  return qword_149C89AA8(&n0x5F00);
}

// --- End Function: sub_1434ED130 (0x1434ED130) ---

// --- Function: sub_1434EE280 (0x1434EE280) ---
__int64 __fastcall sub_1434EE280(__int64 a1, float a2)
{
  __int128 v2; // xmm6
  __int64 n29; // rax
  __int64 v5; // rcx
  __int64 (__fastcall **v6)(); // [rsp+20h] [rbp-98h] BYREF
  _BYTE v7[24]; // [rsp+28h] [rbp-90h] BYREF
  _BYTE v8[24]; // [rsp+40h] [rbp-78h] BYREF
  _BYTE v9[24]; // [rsp+58h] [rbp-60h] BYREF
  _BYTE v10[48]; // [rsp+70h] [rbp-48h] BYREF
  __int128 v11; // [rsp+A0h] [rbp-18h]
  __int64 v12; // [rsp+D0h] [rbp+18h] BYREF

  n29 = ::n29;
  v11 = v2;
  if ( ((*(_DWORD *)(::n29 + 0x1D0) - 1) & 0xFFFFFFFD) == 0 && *(_QWORD *)(a1 + 0x200) )
  {
    v6 = off_1488DAA20;
    sub_140371070((__int64)v7);
    sub_140371070((__int64)v8);
    sub_140371070((__int64)v9);
    sub_140371070((__int64)v10);
    sub_1434D1D10((float *)&v6, (float *)(a1 + 0x50), (float *)(a1 + 0xD0), a2);
    v5 = *(_QWORD *)(a1 + 0x200);
    v12 = v5;
    if ( v5 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
    return sub_14349C1B0((__int64)&v6, &v12, a1 + 0x150);
  }
  return n29;
}

// --- End Function: sub_1434EE280 (0x1434EE280) ---

// --- Function: sub_1434EEBA0 (0x1434EEBA0) ---
void __fastcall sub_1434EEBA0(__int64 a1, float a2)
{
  float v2; // xmm0_4
  __int128 v4; // xmm8
  __int64 *j; // rbx
  __int64 **v6; // rax
  __int64 *i; // rax
  __int64 *v8; // rcx
  __int64 *v9; // r12
  double v10; // xmm9_8
  double v11; // kr00_8
  __int64 v12; // rbx
  float v13; // xmm1_4
  float v14; // xmm10_4
  __int64 v15; // kr00_8
  __int128 v16; // xmm6
  __int64 v17; // r15
  float v18; // xmm0_4
  float v19; // xmm12_4
  float v20; // xmm1_4
  int v21; // ebp
  __int64 v22; // r13
  __int64 v23; // rsi
  float *v24; // rbx
  __int64 v25; // rcx
  __int128 v26; // kr00_16
  double v27; // kr00_8
  __int64 v28; // rcx
  _OWORD *v29; // r14
  float v30; // xmm9_4
  float v31; // xmm7_4
  float v32; // xmm3_4
  float v33; // xmm1_4
  float v34; // xmm5_4
  float v35; // xmm4_4
  float v36; // xmm13_4
  __int128 v37; // xmm12
  __int128 v38; // kr00_16
  __int128 v39; // xmm6
  __int128 v40; // kr00_16
  __int128 n0x3F800000; // kr00_16
  __int128 n0x3F800000_1; // xmm3
  __int128 v46; // kr00_16
  __int128 v51; // kr00_16
  __int128 v56; // kr00_16
  __int64 v57; // rbp
  __int64 m; // r14
  __int64 v59; // rsi
  __int64 n; // rbx
  __int64 v61; // rcx
  _OWORD *v62; // rdi
  __int64 v63; // rax
  float v64; // xmm9_4
  float v65; // xmm3_4
  __int128 v66; // xmm5
  float v67; // xmm8_4
  float v68; // xmm1_4
  float v69; // xmm13_4
  __int128 v70; // xmm6
  __int128 v71; // kr00_16
  __int128 v72; // xmm12
  __int128 v73; // xmm6
  __int128 v74; // kr00_16
  __int128 n0x3F800000_2; // kr00_16
  __int128 n0x3F800000_3; // xmm3
  __int128 v80; // kr00_16
  __int128 v85; // kr00_16
  float v90; // [rsp+20h] [rbp-E8h]
  float v91; // [rsp+24h] [rbp-E4h]
  __int64 *v92; // [rsp+28h] [rbp-E0h]
  float v93; // [rsp+110h] [rbp+8h]
  float k; // [rsp+128h] [rbp+20h]

  v2 = *(float *)(a1 + 0xD8);
  v4 = 0;
  if ( (v2 > 0.0 || v2 == -1.0) && (__int64)(*(_QWORD *)(a1 + 0xB0) - *(_QWORD *)(a1 + 0xA8)) >> 3 )
  {
    if ( a2 > 0.0 )
    {
      *(float *)(a1 + 0xD8) = v2 - a2;
      if ( (float)(v2 - a2) < 0.0 )
      {
        *(_DWORD *)(a1 + 0xD8) = 0;
        j = **(__int64 ***)(a1 + 0x58);
        while ( !*((_BYTE *)j + 0x19) )
        {
          (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)j[4] + 8LL))(
            j[4],
            *(unsigned int *)(a1 + 0x24),
            a1 + 0xD0);
          v6 = (__int64 **)j[2];
          if ( *((_BYTE *)v6 + 0x19) )
          {
            for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
            {
              if ( j != (__int64 *)i[2] )
                break;
              j = i;
            }
            j = i;
          }
          else
          {
            v8 = *v6;
            for ( j = (__int64 *)j[2]; !*((_BYTE *)v8 + 0x19); v8 = (__int64 *)*v8 )
              j = v8;
          }
        }
      }
    }
    v9 = *(__int64 **)(a1 + 0xA8);
    v92 = *(__int64 **)(a1 + 0xB0);
    HIDWORD(v11) = 0;
    *(float *)&v11 = 1.0 - (float)(*(float *)(a1 + 0xD8) / *(float *)(a1 + 0xDC));
    v10 = v11;
    for ( k = *(float *)&v11; v9 != v92; ++v9 )
    {
      v12 = *v9;
      if ( *(_QWORD *)(*v9 + 0x38) != *(_QWORD *)(*v9 + 0x40) )
      {
        v13 = *(float *)(a1 + 0x98);
        HIDWORD(v15) = 0;
        *(float *)&v15 = 1.0 - v13;
        v14 = 1.0 - v13;
        v16 = v4;
        v17 = v15 / 0xA8;
        v18 = (float)(unsigned int)(v15 / 0xA8);
        v19 = v13 / v18;
        v91 = v13 / v18;
        v90 = 1.0 - v13;
        v93 = *(float *)&v4;
        LODWORD(v20) = sub_141D12710(*(_BYTE *)(a1 + 0xA1), *(double *)&v4, COERCE_DOUBLE(0x3F800000), v10).m128_u32[0];
        sub_1434EE280(v12, v20);
        v21 = 0;
        v22 = *(_QWORD *)(*v9 + 0x40);
        v23 = *(_QWORD *)(*v9 + 0x38);
        if ( v23 != v22 )
        {
          v24 = (float *)(v23 + 0x60);
          do
          {
            if ( *(_BYTE *)(a1 + 0xA0) )
            {
              v25 = (v21++ & 0xBu) % (unsigned int)v17;
              v26 = 0;
              *(float *)&v26 = (float)v25;
              *(float *)&v26 = *(float *)&v26 * v19;
              v16 = v26;
              v93 = *(float *)&v26;
            }
            if ( *(float *)&v10 > *(float *)&v16
              && *(float *)&v10 < (float)(*(float *)&v16 + v14)
              && v14 > *(float *)&v4 )
            {
              HIDWORD(v27) = HIDWORD(v10);
              *(float *)&v27 = (float)(*(float *)&v10 - *(float *)&v16) / v14;
              sub_141D12710(*(_BYTE *)(a1 + 0xA1), *(double *)&v4, COERCE_DOUBLE(0x3F800000), v27);
            }
            v28 = *((_QWORD *)v24 + 0xFFFFFFF6);
            if ( v28 )
            {
              v29 = (_OWORD *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v28 + 0xF0LL))(
                                v28,
                                "_base_");
              if ( v29 )
              {
                sub_1434F30D0(v23);
                v30 = v24[5];
                v31 = v24[0xFFFFFFFE];
                v32 = v24[0xFFFFFFFF];
                v33 = v24[1];
                v34 = *v24;
                v35 = v32 + v32;
                v36 = (float)(v32 + v32) * v33;
                v38 = LODWORD(v31);
                *(float *)&v38 = v31 * (float)(v34 + v34);
                v37 = v38;
                v40 = LODWORD(v33);
                *(float *)&v40 = v33 * (float)(v34 + v34);
                v39 = v40;
                n0x3F800000 = 0x3F800000u;
                *(float *)&n0x3F800000 = (float)((float)(1.0 - (float)((float)(v32 + v32) * v32))
                                               - (float)((float)(v34 + v34) * v34))
                                       * v30;
                n0x3F800000_1 = n0x3F800000;
                __asm
                {
                  vinsertps xmm3, xmm3, xmm2, 10h
                  vinsertps xmm3, xmm3, xmm4, 20h ; ' '
                  vinsertps xmm3, xmm3, dword ptr [rbx+8], 30h ; '0'
                }
                *v29 = _XMM3;
                v46 = v39;
                *(float *)&v46 = *(float *)&v39 + (float)(v35 * v31);
                v16 = LODWORD(v93);
                *(float *)&v46 = *(float *)&v46 * v30;
                _XMM3 = v46;
                __asm
                {
                  vinsertps xmm3, xmm3, xmm2, 10h
                  vinsertps xmm3, xmm3, xmm4, 20h ; ' '
                  vinsertps xmm3, xmm3, xmm7, 30h ; '0'
                }
                v29[1] = _XMM3;
                v51 = v37;
                *(float *)&v51 = *(float *)&v37 - v36;
                v19 = v91;
                *(float *)&v51 = *(float *)&v51 * v30;
                _XMM3 = v51;
                *(_QWORD *)&v10 = LODWORD(k);
                __asm
                {
                  vinsertps xmm3, xmm3, xmm2, 10h
                  vinsertps xmm3, xmm3, xmm4, 20h ; ' '
                  vinsertps xmm3, xmm3, xmm10, 30h ; '0'
                }
                v14 = v90;
                v29[2] = _XMM3;
                v4 = 0;
              }
            }
            if ( !*(_BYTE *)(a1 + 0xA0) )
            {
              v56 = v16;
              *(float *)&v56 = *(float *)&v16 + v19;
              v16 = v56;
              v93 = *(float *)&v56;
            }
            v23 += 0xA8;
            v24 += 0x2A;
          }
          while ( v23 != v22 );
        }
      }
    }
  }
  else
  {
    v57 = *(_QWORD *)(a1 + 0xB0);
    for ( m = *(_QWORD *)(a1 + 0xA8); m != v57; m += 8 )
    {
      v59 = *(_QWORD *)(*(_QWORD *)m + 0x40LL);
      for ( n = *(_QWORD *)(*(_QWORD *)m + 0x38LL); n != v59; n += 0xA8 )
      {
        v61 = *(_QWORD *)(n + 0x10);
        if ( v61 )
        {
          v62 = (_OWORD *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v61 + 0xF0LL))(v61, "_base_");
          if ( v62 )
          {
            v63 = sub_1434C2A20(n);
            v64 = *(float *)(v63 + 0x1C);
            v65 = *(float *)(v63 + 4);
            v66 = *(unsigned int *)(v63 + 8);
            v67 = (float)(v65 + v65) * *(float *)v63;
            v68 = *(float *)(v63 + 0xC);
            v69 = (float)(v65 + v65) * v68;
            v71 = v66;
            *(float *)&v71 = *(float *)&v66 + *(float *)&v66;
            v70 = v71;
            *(float *)&v71 = (float)(*(float *)&v66 + *(float *)&v66) * *(float *)v63;
            v72 = v71;
            *(float *)&v66 = *(float *)&v70 * *(float *)&v66;
            v74 = v70;
            *(float *)&v74 = *(float *)&v70 * v68;
            v73 = v74;
            n0x3F800000_2 = 0x3F800000u;
            *(float *)&n0x3F800000_2 = (float)((float)(1.0 - (float)((float)(v65 + v65) * v65)) - *(float *)&v66) * v64;
            n0x3F800000_3 = n0x3F800000_2;
            __asm
            {
              vinsertps xmm3, xmm3, xmm2, 10h
              vinsertps xmm3, xmm3, xmm4, 20h ; ' '
              vinsertps xmm3, xmm3, dword ptr [rax+10h], 30h ; '0'
            }
            *v62 = _XMM3;
            v80 = v73;
            *(float *)&v80 = (float)(*(float *)&v73 + v67) * v64;
            _XMM3 = v80;
            __asm
            {
              vinsertps xmm3, xmm3, xmm2, 10h
              vinsertps xmm3, xmm3, xmm4, 20h ; ' '
              vinsertps xmm3, xmm3, xmm7, 30h ; '0'
            }
            v62[1] = _XMM3;
            v85 = v72;
            *(float *)&v85 = (float)(*(float *)&v72 - v69) * v64;
            _XMM3 = v85;
            __asm
            {
              vinsertps xmm3, xmm3, xmm2, 10h
              vinsertps xmm3, xmm3, xmm4, 20h ; ' '
              vinsertps xmm3, xmm3, xmm10, 30h ; '0'
            }
            v62[2] = _XMM3;
          }
        }
      }
    }
  }
}

// --- End Function: sub_1434EEBA0 (0x1434EEBA0) ---

// --- Function: sub_1434F2FC0 (0x1434F2FC0) ---
void __fastcall sub_1434F2FC0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v3; // rcx
  __int128 v4; // xmm6
  double v5; // xmm0_8
  __int64 *v6; // rdi
  float v7; // kr00_4
  __int64 *v8; // rbx
  __int64 v9; // rcx
  __int128 v10; // kr00_16
  float v11[8]; // [rsp+20h] [rbp-58h] BYREF

  v1 = *(unsigned __int8 *)(a1 + 0xE5);
  if ( (_BYTE)v1 != 0xFF )
  {
    v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x38) + 0x20LL) + 0x28 * v1 + 0x18);
    if ( v3 )
    {
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(v3 + 8) + 8LL))(v3 + 8, a1);
    }
    else
    {
      v4 = 0;
      v5 = (*(double (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 0x30LL))(*(_QWORD *)(a1 + 8));
      v6 = *(__int64 **)(a1 + 0xB0);
      v11[3] = 1.0;
      v7 = *(float *)(a1 + 0x1C) * *(float *)(a1 + 0x18);
      v8 = *(__int64 **)(a1 + 0xA8);
      v11[0] = 0.0;
      v11[1] = 0.0;
      v11[2] = 0.0;
      for ( v11[7] = v7; v8 != v6; v4 = v10 )
      {
        v9 = *v8;
        v11[4] = 0.0;
        v11[5] = 0.0;
        v11[6] = *(float *)&v4;
        sub_1434E64F0(v9, (__int64)v11);
        ++v8;
        v10 = v4;
        *(float *)&v10 = *(float *)&v4 + *(float *)&v5;
      }
    }
  }
}

// --- End Function: sub_1434F2FC0 (0x1434F2FC0) ---

// --- Function: sub_1434F30D0 (0x1434F30D0) ---
float *__fastcall sub_1434F30D0(__int64 a1, float a2)
{
  float v2; // xmm5_4
  float v4; // xmm6_4
  float v5; // xmm7_4
  float v6; // xmm8_4
  float v7; // xmm10_4
  __m128 v8; // xmm12
  float v10; // xmm14_4
  float v11; // xmm15_4
  float X; // xmm1_4
  float v13; // xmm9_4
  float v14; // xmm8_4
  float v15; // xmm6_4
  __m128 v16; // kr00_16
  float v17; // xmm7_4
  float v20; // xmm1_4
  float v21; // xmm6_4
  float v22; // xmm4_4
  float v23; // xmm3_4
  float v24; // xmm0_4
  float v25; // xmm9_4
  float v26; // xmm10_4
  float v27; // xmm12_4
  float v28; // xmm11_4
  float Y; // xmm6_4
  double v30; // xmm0_8
  float v31; // xmm5_4
  float v32; // xmm8_4
  float v33; // xmm4_4
  float *result; // rax
  float v35; // xmm6_4
  float v36; // xmm4_4

  v2 = *(float *)(a1 + 0x44);
  v4 = *(float *)(a1 + 0x38);
  v5 = *(float *)(a1 + 0x3C);
  v6 = *(float *)(a1 + 0x1C);
  v7 = *(float *)(a1 + 0x20);
  v8 = (__m128)*(unsigned int *)(a1 + 0x40);
  v10 = *(float *)(a1 + 0x24);
  v11 = *(float *)(a1 + 0x18);
  X = (float)((float)(v5 * v6) + (float)(v4 * v11)) + (float)((float)(v8.m128_f32[0] * v7) + (float)(v2 * v10));
  if ( X < 0.0 )
  {
    X = -(float)((float)((float)(v5 * v6) + (float)(v4 * v11))
               + (float)((float)(v8.m128_f32[0] * v7) + (float)(v2 * v10)));
    LODWORD(v2) ^= 0x80000000;
    LODWORD(v4) ^= 0x80000000;
    LODWORD(v5) ^= 0x80000000;
    *(_OWORD *)&v8 ^= 0x80000000;
  }
  if ( X <= 0.99989998 )
  {
    v25 = v2 - (float)(v10 * X);
    v26 = v4 - (float)(v11 * X);
    v27 = v8.m128_f32[0] - (float)(X * *(float *)(a1 + 0x20));
    v28 = v5 - (float)(v6 * X);
    Y = fsqrt((float)((float)(v28 * v28) + (float)(v26 * v26)) + (float)((float)(v27 * v27) + (float)(v25 * v25)));
    atan2f(Y, X);
    v30 = _libm_sse2_sincosf_();
    v31 = 1.0 / Y;
    v32 = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v30, (__m128)*(unsigned __int64 *)&v30, 1).m128_f32[0];
    v33 = (float)(*(float *)&v30 * v26) * (float)(1.0 / Y);
    v21 = (float)((float)(*(float *)&v30 * v25) * (float)(1.0 / Y)) + (float)(v10 * v32);
    v23 = (float)((float)(*(float *)&v30 * v28) * v31) + (float)(v32 * *(float *)(a1 + 0x1C));
    v22 = v33 + (float)(v11 * v32);
    v24 = (float)((float)(*(float *)&v30 * v27) * v31) + (float)(v32 * *(float *)(a1 + 0x20));
  }
  else
  {
    if ( (float)((float)((float)(v6 * v5) + (float)(v11 * v4))
               + (float)((float)(v7 * v8.m128_f32[0]) + (float)(v10 * v2))) < 0.0 )
    {
      LODWORD(v2) ^= 0x80000000;
      LODWORD(v4) ^= 0x80000000;
      LODWORD(v5) ^= 0x80000000;
      *(_OWORD *)&v8 ^= 0x80000000;
    }
    v13 = (float)(v4 * a2) + (float)((float)(1.0 - a2) * v11);
    v14 = (float)(v5 * a2) + (float)((float)(1.0 - a2) * v6);
    v15 = (float)(v2 * a2) + (float)((float)(1.0 - a2) * v10);
    v16 = v8;
    v17 = (float)(v8.m128_f32[0] * a2) + (float)((float)(1.0 - a2) * v7);
    v16.m128_f32[0] = (float)((float)(v17 * v17) + (float)(v14 * v14))
                    + (float)((float)(v15 * v15) + (float)(v13 * v13));
    _XMM3 = _mm_shuffle_ps(v16, v16, 0);
    __asm { vrsqrtps xmm4, xmm3 }
    _XMM4.m128_f32[0] = _mm_shuffle_ps(_XMM4, _XMM4, 0xFF).m128_f32[0];
    v20 = (float)(1.5 - (float)((float)((float)(_XMM4.m128_f32[0] * v16.m128_f32[0]) * _XMM4.m128_f32[0]) * 0.5))
        * _XMM4.m128_f32[0];
    v21 = v20 * v15;
    v22 = v20 * v13;
    v23 = v20 * v14;
    v24 = v20 * v17;
  }
  *(float *)(a1 + 0x58) = v22;
  *(float *)(a1 + 0x5C) = v23;
  *(float *)(a1 + 0x60) = v24;
  *(float *)(a1 + 0x64) = v21;
  result = (float *)sub_1434C2A20(a1);
  v35 = result[6];
  v36 = result[5];
  *(float *)(a1 + 0x68) = (float)((float)(result[4] - *(float *)(a1 + 0x28)) * a2) + *(float *)(a1 + 0x28);
  *(float *)(a1 + 0x6C) = (float)((float)(v36 - *(float *)(a1 + 0x2C)) * a2) + *(float *)(a1 + 0x2C);
  *(float *)(a1 + 0x70) = (float)((float)(v35 - *(float *)(a1 + 0x30)) * a2) + *(float *)(a1 + 0x30);
  *(float *)(a1 + 0x74) = (float)((float)(*(float *)(a1 + 0x54) - *(float *)(a1 + 0x34)) * a2) + *(float *)(a1 + 0x34);
  return result;
}

// --- End Function: sub_1434F30D0 (0x1434F30D0) ---

// --- Function: sub_14350B400 (0x14350B400) ---
_QWORD *__fastcall sub_14350B400(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  __int64 *i; // rbx
  __int64 v6; // rax
  __int64 v7; // r9
  volatile signed __int32 *v8; // rcx

  for ( i = a1; i != a2; i += 2 )
  {
    v6 = *i;
    v7 = i[1];
    *i = 0;
    i[1] = 0;
    v8 = (volatile signed __int32 *)a3[1];
    *a3 = v6;
    a3[1] = v7;
    if ( v8 && _InterlockedExchangeAdd(v8 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 8LL))(v8);
    a3 += 2;
  }
  return a3;
}

// --- End Function: sub_14350B400 (0x14350B400) ---

// --- Function: sub_1435246C0 (0x1435246C0) ---
void __fastcall sub_1435246C0(__int64 a1, _QWORD *a2)
{
  _QWORD **v2; // rbx
  _QWORD *v3; // rax
  _QWORD *v4; // r9
  _QWORD *v5; // rdx
  char v6; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD ***)(a1 + 0x10);
  if ( *a2 )
  {
    v3 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)*a2 + 0x18LL))(*a2, &v6);
    v4 = (_QWORD *)(*v2)[1];
    v5 = (_QWORD *)**v2;
    if ( v5 == v4 )
    {
LABEL_5:
      sub_1402A8EB0(*v2, v3);
    }
    else
    {
      while ( *v5 != *v3 )
      {
        if ( ++v5 == v4 )
          goto LABEL_5;
      }
    }
  }
}

// --- End Function: sub_1435246C0 (0x1435246C0) ---

// --- Function: sub_143525000 (0x143525000) ---
void __fastcall sub_143525000(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx
  _QWORD *v5; // rdi
  _QWORD *v6; // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = (_QWORD *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        v6 = (_QWORD *)sub_1402A65A0(8u);
        if ( v6 )
          *v6 = *v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_1435246C0;
        a2[1] = sub_143525000;
      }
    }
  }
}

// --- End Function: sub_143525000 (0x143525000) ---

// --- Function: sub_143534220 (0x143534220) ---
unsigned __int64 *__fastcall sub_143534220(unsigned __int64 *a1, double *a2, float a3, __int64 a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm8
  __int64 *v9; // rax
  __int128 v10; // xmm0
  double v11; // xmm1_8
  double v12; // xmm8_8
  __int64 v13; // rdi
  void (__fastcall *v14)(__int64, _BYTE *, unsigned __int64 **, _QWORD); // rsi
  _QWORD *v15; // rax
  __int128 v16; // rdi
  _QWORD *i; // rcx
  __int64 v18; // rdx
  __int64 v19; // rbx
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // r8
  __int64 v23; // r15
  void *v24; // rcx
  const void *v25; // rdx
  size_t Size; // r8
  __int64 v27; // r14
  __int64 (__fastcall *v28)(__int64, _BYTE *, __int16 *); // rbx
  __int16 n0xFFFF; // ax
  unsigned __int64 Src_1; // rbx
  __int64 v31; // rax
  __int16 n4; // dx
  __int128 v34; // xmm7
  double v35; // xmm6_8
  __int64 *v36; // rax
  double v37; // xmm0_8
  unsigned __int64 Src; // [rsp+38h] [rbp-D0h] BYREF
  void *Src_8[2]; // [rsp+40h] [rbp-C8h] BYREF
  void *v41; // [rsp+50h] [rbp-B8h]
  __int16 n0xFFFF_1; // [rsp+58h] [rbp-B0h] BYREF
  _BYTE v43[6]; // [rsp+5Ah] [rbp-AEh] BYREF
  unsigned __int64 *p_sub_1435246C0; // [rsp+60h] [rbp-A8h] BYREF
  void **p_sub_143525000; // [rsp+68h] [rbp-A0h]
  _QWORD *v46; // [rsp+70h] [rbp-98h]
  _BYTE v47[16]; // [rsp+78h] [rbp-90h] BYREF
  __m256 v48; // [rsp+88h] [rbp-80h] BYREF
  _BYTE v49[2]; // [rsp+B8h] [rbp-50h] BYREF
  char v50; // [rsp+BAh] [rbp-4Eh]
  __m256 v51; // [rsp+128h] [rbp+20h]
  _BYTE v52[144]; // [rsp+388h] [rbp+280h] BYREF
  __int128 v53; // [rsp+428h] [rbp+320h]
  __int128 v54; // [rsp+448h] [rbp+340h]

  v54 = v4;
  v53 = v5;
  v9 = (__int64 *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)(a4 & 0xFFFFFFFFFFFFLL) + 0x650LL))(
                    a4 & 0xFFFFFFFFFFFFLL,
                    &Src);
  sub_140372710((__int64)v49, 0x7832, *v9, 0x37, "HarvestableHelpers::FindClosestProvider");
  v10 = *(_OWORD *)a2;
  v11 = a2[2];
  v49[0] |= 0x10u;
  *(_OWORD *)v48.m256_f32 = v10;
  *(double *)&v48.m256_f32[4] = v11;
  v12 = a3;
  *(double *)&v48.m256_f32[6] = a3;
  v51 = v48;
  __asm { vzeroupper }
  (*(void (__fastcall **)(__int64, unsigned __int64 *, const char *))(*(_QWORD *)qword_149C8DF38 + 0x28LL))(
    qword_149C8DF38,
    &Src,
    "Engine.Components.HarvestableProviderComponent");
  p_sub_1435246C0 = &Src;
  p_sub_143525000 = Src_8;
  sub_140363FD0((__int64)&v48, (__int64 **)&p_sub_1435246C0);
  v50 |= 1u;
  sub_14037CB50((__int64)v52, (__int64)&v48);
  sub_140375A50(&v48);
  v13 = qword_149C8DFC0;
  *(_OWORD *)Src_8 = 0;
  v41 = 0;
  v14 = *(void (__fastcall **)(__int64, _BYTE *, unsigned __int64 **, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x1C0LL);
  v15 = (_QWORD *)sub_1402A65A0(8u);
  if ( v15 )
  {
    *v15 = Src_8;
    v46 = v15;
  }
  else
  {
    v46 = 0;
  }
  p_sub_1435246C0 = (unsigned __int64 *)sub_1435246C0;
  p_sub_143525000 = (void **)sub_143525000;
  v14(v13, v49, &p_sub_1435246C0, 0);
  if ( (unsigned __int64)p_sub_143525000 >= 2 )
    ((void (__fastcall *)(__int64, unsigned __int64 **))p_sub_143525000)(2, &p_sub_1435246C0);
  if ( !qword_149C8E0F8
    || !qword_149C8E0C8
    || ((*(void (__fastcall **)(__int64, unsigned __int64 *, double *, __int64))(*(_QWORD *)qword_149C8E0C8 + 0x100LL))(
          qword_149C8E0C8,
          &Src,
          a2,
          a4),
        !is_entity_descriptor_valid_or_accessible(&Src)) )
  {
    *((void **)&v16 + 1) = Src_8[1];
    goto LABEL_26;
  }
  v16 = *(_OWORD *)Src_8;
  for ( i = Src_8[0]; i != Src_8[1]; ++i )
  {
    if ( *i == Src )
      break;
  }
  if ( i == Src_8[1] )
  {
    if ( Src_8[1] != v41 )
    {
      *(_QWORD *)Src_8[1] = Src;
      *((_QWORD *)&v16 + 1) = (char *)Src_8[1] + 8;
      Src_8[1] = (char *)Src_8[1] + 8;
LABEL_26:
      *(void **)&v16 = Src_8[0];
      goto LABEL_27;
    }
    v18 = 0x1FFFFFFFFFFFFFFFLL;
    v19 = ((char *)Src_8[1] - (char *)Src_8[0]) >> 3;
    if ( v19 == 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v20 = v19 + 1;
    v21 = (signed __int64)((__int64)v41 - (unsigned __int64)Src_8[0]) >> 3;
    v22 = v21 >> 1;
    if ( v21 <= 0x1FFFFFFFFFFFFFFFLL - (v21 >> 1) )
    {
      v18 = v21 + v22;
      if ( v21 + v22 < v20 )
        v18 = v19 + 1;
    }
    v23 = 8 * v18;
    *(_QWORD *)&v16 = sub_140394E70((__int64)Src_8, 8 * v18);
    v24 = (void *)v16;
    *(_QWORD *)(v16 + 8 * v19) = Src;
    v25 = Src_8[0];
    if ( *((void **)&v16 + 1) == Src_8[1] )
    {
      Size = (char *)Src_8[1] - (char *)Src_8[0];
    }
    else
    {
      memmove((void *)v16, Src_8[0], *((_QWORD *)&v16 + 1) - (unsigned __int64)Src_8[0]);
      v24 = (void *)(v16 + 8 * (v19 + 1));
      Size = (size_t)Src_8[1] - *((_QWORD *)&v16 + 1);
      v25 = (const void *)*((_QWORD *)&v16 + 1);
    }
    memmove(v24, v25, Size);
    if ( Src_8[0] )
      sub_1403A6820(
        (__int64)Src_8,
        (unsigned __int64)Src_8[0],
        ((unsigned __int64)v41 - (unsigned __int64)Src_8[0]) & 0xFFFFFFFFFFFFFFF8uLL);
    *((_QWORD *)&v16 + 1) = v16 + 8 * v20;
    *(_OWORD *)Src_8 = v16;
    v41 = (void *)(v16 + v23);
  }
LABEL_27:
  *a1 = 0;
  if ( (_QWORD)v16 != *((_QWORD *)&v16 + 1) )
  {
    do
    {
      v27 = *(_QWORD *)v16 & 0xFFFFFFFFFFFFLL;
      v28 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v27 + 0x340LL);
      n0xFFFF = n0xFFFF_24;
      if ( n0xFFFF_24 == (__int16)0xFFFF )
      {
        n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                      + 0x10LL))(
                              qword_149C8DFC8,
                              v43,
                              "HarvestableProviderComponent");
        n0xFFFF_24 = n0xFFFF;
      }
      n0xFFFF_1 = n0xFFFF;
      Src_1 = *(_QWORD *)v28(v27, v47, &n0xFFFF_1);
      Src = Src_1;
      if ( Src_1 )
      {
        v31 = sub_1403B84E0(Src_1 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(v31 + 4);
        if ( n4 != 4
          && *(_WORD *)(v31 + 2) == (HIWORD(Src_1) & 0xFFF)
          && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&Src))
          && dword_149B29A70 > 0
          && sub_140335FE0(Src_1 & 0xFFFFFFFFFFFFLL)
          && *(_QWORD *)(sub_140335FE0(Src_1 & 0xFFFFFFFFFFFFLL) + 0x28) )
        {
          v34 = *(_OWORD *)a2;
          v35 = a2[2];
          v36 = (__int64 *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 **))(*(_QWORD *)v27 + 0x18LL))(
                             v27,
                             &p_sub_1435246C0);
          *(_OWORD *)v48.m256_f32 = v34;
          *(double *)&v48.m256_f32[4] = v35;
          v37 = sub_1404B5460(*v36, (double *)v48.m256_f32);
          if ( v37 < v12 )
          {
            v12 = v37;
            *a1 = Src_1;
          }
        }
      }
      *(_QWORD *)&v16 = v16 + 8;
    }
    while ( (_QWORD)v16 != *((_QWORD *)&v16 + 1) );
    *(void **)&v16 = Src_8[0];
  }
  if ( (_QWORD)v16 )
  {
    sub_1403A6820((__int64)Src_8, v16, ((unsigned __int64)v41 - v16) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_OWORD *)Src_8 = 0;
    v41 = 0;
  }
  sub_14037A590((__int64)v49);
  return a1;
}

// --- End Function: sub_143534220 (0x143534220) ---

// --- Function: sub_14356A3E0 (0x14356A3E0) ---
__int64 sub_14356A3E0()
{
  unsigned __int64 v0; // rbx
  __int64 *v1; // rax
  __int64 v2; // rdi
  __int64 v3; // r14
  __int64 v4; // r15
  unsigned __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rsi
  void (__fastcall *v8)(__int64, unsigned __int64 *, _QWORD); // rdi
  _QWORD *v9; // rax
  double v10; // xmm1_8
  __int64 v11; // rax
  __int16 n4; // cx
  unsigned __int64 v14[2]; // [rsp+30h] [rbp-69h] BYREF
  int n0x3700; // [rsp+40h] [rbp-59h] BYREF
  __int64 v16; // [rsp+44h] [rbp-55h]
  int v17; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v18; // [rsp+50h] [rbp-49h]
  unsigned __int64 v19; // [rsp+58h] [rbp-41h]
  __int64 v20; // [rsp+60h] [rbp-39h]
  __int64 v21; // [rsp+68h] [rbp-31h]
  double v22[4]; // [rsp+90h] [rbp-9h] BYREF
  __int64 v23; // [rsp+B0h] [rbp+17h] BYREF
  __int64 v24; // [rsp+100h] [rbp+67h] BYREF
  unsigned __int64 v25; // [rsp+108h] [rbp+6Fh] BYREF
  __int64 n0x2FAF080; // [rsp+110h] [rbp+77h] BYREF
  char v27; // [rsp+118h] [rbp+7Fh] BYREF

  v0 = 0;
  n0x3700 = 0x3700;
  v17 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v16 = 1;
  v18 = __rdtsc();
  qword_149C89AA0(
    &n0x3700,
    &word_149F65F24,
    "HarvestableHelpers::UpdateDebugging",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Harvestable/HarvestableHelpers.cpp",
    0x67F);
  HIWORD(n0x3700) = word_149F65F24;
  if ( dword_149B29A80 )
  {
    if ( BYTE1(qword_149C8E516) )
    {
      if ( !byte_149C8E514 )
        goto LABEL_19;
    }
    else if ( BYTE2(qword_149C8E516) )
    {
      goto LABEL_19;
    }
    v24 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                       qword_149C8DF80,
                       0);
    if ( sub_14059CAF0(&v24, &qword_149F65F28) )
    {
      n0x2FAF080 = 0x2FAF080;
      v1 = sub_14059CA80(&v24, &v23, &n0x2FAF080);
      v2 = qword_149F65F30;
      v25 = qword_149F65F30;
      qword_149F65F28 = *v1;
      if ( is_valid_handle_typeA((__int64 *)&v25) )
        *(_BYTE *)((v2 & 0xFFFFFFFFFFFFLL) + 0x208) = 0;
      v25 = 0;
      v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x3D0LL))(qword_149C8DFE0);
      v4 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL))(
             qword_149C8DF28,
             *(unsigned int *)(v3 + 0xA8));
      v5 = 0;
      if ( v4 )
      {
        v6 = sub_140976B00(qword_149FBE618);
        v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x1D0LL))(v6);
        v8 = *(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)v7 + 0x100LL);
        v9 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v4 + 0x30LL))(v4, &v27);
        v8(v7, v14, *v9);
        v5 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v14) )
        {
          v10 = *(double *)(v3 + 0x38);
          v22[0] = *(double *)(v3 + 0x18);
          v22[2] = *(double *)(v3 + 0x58);
          v22[1] = v10;
          v0 = *sub_143534220(&v25, v22, 500000.0, v14[0]);
          v25 = v0;
          v5 = v0;
        }
      }
      if ( v5 )
      {
        v11 = sub_1403B84E0(v5 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(v11 + 4);
        if ( n4 != 4
          && *(_WORD *)(v11 + 2) == (HIWORD(v5) & 0xFFF)
          && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v25)) )
        {
          qword_149F65F30 = v0;
          *(_BYTE *)((v0 & 0xFFFFFFFFFFFFLL) + 0x208) = 1;
        }
      }
    }
  }
LABEL_19:
  v19 = __rdtsc();
  return qword_149C89AA8(&n0x3700);
}

// --- End Function: sub_14356A3E0 (0x14356A3E0) ---

// --- Function: sub_143591AC0 (0x143591AC0) ---
__int64 __fastcall sub_143591AC0(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4)
{
  _QWORD *v4; // r12
  __int64 v8; // r14
  __int64 n0x10; // rax
  volatile signed __int32 *v10; // rsi
  __int64 v11; // rax
  volatile signed __int32 *v12; // rsi
  __int64 v13; // rax
  volatile signed __int32 *v14; // rsi
  __int64 v15; // rax
  volatile signed __int32 *v16; // rsi
  __int64 v17; // rax
  volatile signed __int32 *v18; // rsi
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 n0x10_2; // rcx
  __int64 *v22; // rax
  volatile signed __int32 *v23; // r15
  unsigned int v24; // r15d
  _BYTE *v25; // rdx
  __int64 v26; // rax
  volatile signed __int32 *v27; // r15
  __int64 v28; // rcx
  __int64 v29; // rax
  __int64 v30; // r15
  __int64 v31; // r12
  volatile signed __int32 *v32; // r15
  __int128 v34; // [rsp+20h] [rbp-99h] BYREF
  __int64 v35[2]; // [rsp+30h] [rbp-89h] BYREF
  __int64 v36[2]; // [rsp+40h] [rbp-79h] BYREF
  __int64 v37[2]; // [rsp+50h] [rbp-69h] BYREF
  __int64 v38[2]; // [rsp+60h] [rbp-59h] BYREF
  __int64 v39[2]; // [rsp+70h] [rbp-49h] BYREF
  __int128 v40; // [rsp+80h] [rbp-39h] BYREF
  __int128 v41; // [rsp+90h] [rbp-29h] BYREF
  __int128 v42; // [rsp+A0h] [rbp-19h] BYREF
  __int128 v43; // [rsp+B0h] [rbp-9h] BYREF
  __int128 v44; // [rsp+C0h] [rbp+7h] BYREF
  __int64 n0x10_1; // [rsp+120h] [rbp+67h]
  __int64 v46; // [rsp+128h] [rbp+6Fh]
  unsigned int v47; // [rsp+130h] [rbp+77h] BYREF
  unsigned int v48; // [rsp+138h] [rbp+7Fh]

  v48 = a4;
  v47 = a3;
  v4 = (_QWORD *)(a1 + 0x70);
  v46 = a1 + 0x70;
  sub_143472240(a1 + 0x70);
  CTX::ContextTransitionTasks::ContextTransitionTasks(
    (CTX::ContextTransitionTasks *)a2,
    *(CTX::TaskDomain **)(a1 + 0x180));
  v8 = sub_1402A65A0(0x48u);
  n0x10 = 0x10;
  n0x10_1 = 0x10;
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = 1;
    *(_QWORD *)v8 = off_1483A7828;
    *(_DWORD *)(v8 + 0xC) = 1;
    CTX::TaskExecutor::TaskExecutor((CTX::TaskExecutor *)(v8 + 0x10), *(CTX::TaskDomain **)(a1 + 0x180));
    *(_DWORD *)(v8 + 0x40) = a3;
    *(_QWORD *)(v8 + 0x10) = off_1488F2780;
    n0x10 = v8 + 0x10;
    *(_QWORD *)(v8 + 0x38) = a1;
    _InterlockedIncrement((volatile signed __int32 *)(v8 + 8));
  }
  v35[0] = n0x10;
  v35[1] = v8;
  sub_1434787E0(v4, &v40, v35);
  v10 = (volatile signed __int32 *)*((_QWORD *)&v40 + 1);
  if ( *((_QWORD *)&v40 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v40 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
      if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
    }
  }
  if ( *(_DWORD *)(a1 + 0xC8) )
  {
    v11 = *(_QWORD *)(a1 + 0x118);
    if ( v11 )
      _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
    v36[0] = *(_QWORD *)(a1 + 0x110);
    v36[1] = *(_QWORD *)(a1 + 0x118);
    sub_1434787E0(v4, &v41, v36);
    v12 = (volatile signed __int32 *)*((_QWORD *)&v41 + 1);
    if ( *((_QWORD *)&v41 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v41 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v12)(v12);
        if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v12 + 8LL))(v12);
      }
    }
    v13 = *(_QWORD *)(a1 + 0x128);
    if ( v13 )
      _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
    v37[0] = *(_QWORD *)(a1 + 0x120);
    v37[1] = *(_QWORD *)(a1 + 0x128);
    sub_1434787E0(v4, &v42, v37);
    v14 = (volatile signed __int32 *)*((_QWORD *)&v42 + 1);
    if ( *((_QWORD *)&v42 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v42 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v14)(v14);
        if ( _InterlockedExchangeAdd(v14 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v14 + 8LL))(v14);
      }
    }
  }
  else if ( !*(_DWORD *)(a1 + 0xD0) )
  {
    v15 = *(_QWORD *)(a1 + 0xF8);
    if ( v15 )
      _InterlockedIncrement((volatile signed __int32 *)(v15 + 8));
    v38[0] = *(_QWORD *)(a1 + 0xF0);
    v38[1] = *(_QWORD *)(a1 + 0xF8);
    sub_1434787E0(v4, &v43, v38);
    v16 = (volatile signed __int32 *)*((_QWORD *)&v43 + 1);
    if ( *((_QWORD *)&v43 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v43 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v16)(v16);
        if ( _InterlockedExchangeAdd(v16 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v16 + 8LL))(v16);
      }
    }
    *(_DWORD *)(a1 + 0xD0) = 2;
  }
  v17 = sub_1402A65A0(0x58u);
  v18 = (volatile signed __int32 *)v17;
  if ( v17 )
  {
    v19 = v48;
    v20 = v47;
    *(_DWORD *)(v17 + 8) = 1;
    *(_DWORD *)(v17 + 0xC) = 1;
    *(_QWORD *)v17 = off_1482CCF28;
    sub_143579570(v17 + 0x10, a1, v20, v19);
    n0x10_2 = (__int64)(v18 + 4);
    _InterlockedIncrement(v18 + 2);
    n0x10_1 = (__int64)(v18 + 4);
  }
  else
  {
    v18 = 0;
    n0x10_2 = 0x10;
  }
  v39[0] = n0x10_2;
  v39[1] = (__int64)v18;
  v22 = (__int64 *)sub_1434787E0(v4, &v44, v39);
  std::shared_ptr<vraudio::MixerNode>::operator=((_QWORD *)a2, v22);
  v23 = (volatile signed __int32 *)*((_QWORD *)&v44 + 1);
  if ( *((_QWORD *)&v44 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v44 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v23)(v23);
      if ( _InterlockedExchangeAdd(v23 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v23 + 8LL))(v23);
    }
  }
  v24 = v47;
  *(_DWORD *)(a1 + 0xC8) = v47;
  v25 = *(_BYTE **)(a1 + 0xE0);
  if ( v25 == *(_BYTE **)(a1 + 0xE8) )
  {
    sub_140347870(a1 + 0xD8, v25, (int *)&v47);
  }
  else
  {
    *(_DWORD *)v25 = v24;
    *(_QWORD *)(a1 + 0xE0) += 4LL;
  }
  v26 = *(_QWORD *)(n0x10_1 + 0x30);
  if ( v26 )
    _InterlockedIncrement((volatile signed __int32 *)(v26 + 8));
  v27 = *(volatile signed __int32 **)(a2 + 0x18);
  v28 = *(_QWORD *)(n0x10_1 + 0x30);
  *(_QWORD *)(a2 + 0x10) = *(_QWORD *)(n0x10_1 + 0x28);
  *(_QWORD *)(a2 + 0x18) = v28;
  if ( v27 )
  {
    if ( _InterlockedExchangeAdd(v27 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v27)(v27);
      if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v27 + 8LL))(v27);
    }
  }
  if ( *(_BYTE *)(a1 + 0x50) )
  {
    v29 = sub_1402A65A0(0x80u);
    v30 = v29;
    if ( v29 )
    {
      *(_DWORD *)(v29 + 8) = 1;
      *(_DWORD *)(v29 + 0xC) = 1;
      *(_QWORD *)v29 = off_1486CB848;
      sub_14345F690(v29 + 0x10, *(_QWORD *)(a1 + 0x180));
    }
    else
    {
      v30 = 0;
    }
    v34 = 0;
    sub_140A56F50(&v34, v30 + 0x10, v30);
    v31 = a1 + 0x40;
    v32 = *(volatile signed __int32 **)(a1 + 0x48);
    *(_OWORD *)(a1 + 0x40) = v34;
    if ( v32 )
    {
      if ( _InterlockedExchangeAdd(v32 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v32)(v32);
        if ( _InterlockedExchangeAdd(v32 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v32 + 8LL))(v32);
      }
    }
    *(_BYTE *)(a1 + 0x50) = 0;
  }
  else
  {
    v31 = a1 + 0x40;
  }
  sub_140301A50(a2 + 0x20, v31);
  sub_143466060(v46);
  if ( v18 )
  {
    if ( _InterlockedExchangeAdd(v18 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
      if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8LL))(v18);
    }
  }
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(__int64))v8)(v8);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 8LL))(v8);
    }
  }
  return a2;
}

// --- End Function: sub_143591AC0 (0x143591AC0) ---

// --- Function: sub_143595320 (0x143595320) ---
_QWORD *__fastcall sub_143595320(__int64 a1, _QWORD *a2)
{
  __int64 v4; // rbp
  __int64 v5; // rax
  volatile signed __int32 *v6; // rsi
  __int64 v7; // rax
  __int64 *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rdx
  volatile signed __int32 *v11; // rdi
  volatile signed __int32 *v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 *v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rdx
  volatile signed __int32 *v18; // rdi
  __int64 v20[2]; // [rsp+20h] [rbp-78h] BYREF
  __int64 v21[2]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v22[2]; // [rsp+40h] [rbp-58h] BYREF
  __int128 v23; // [rsp+50h] [rbp-48h] BYREF
  __int128 v24; // [rsp+60h] [rbp-38h] BYREF
  __int128 v25; // [rsp+70h] [rbp-28h] BYREF

  if ( qword_149F66620 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149F66620 + 0x18LL))(qword_149F66620, a1);
  v4 = a1 + 0x70;
  *a2 = 0;
  a2[1] = 0;
  sub_143472240(a1 + 0x70);
  if ( *(_DWORD *)(a1 + 0xC8) )
  {
    *(_DWORD *)(a1 + 0xC8) = 0;
    *(_BYTE *)(a1 + 0xCC) = 0;
    v5 = *(_QWORD *)(a1 + 0x118);
    if ( v5 )
      _InterlockedIncrement((volatile signed __int32 *)(v5 + 8));
    v20[0] = *(_QWORD *)(a1 + 0x110);
    v20[1] = *(_QWORD *)(a1 + 0x118);
    sub_1434787E0((_QWORD *)(a1 + 0x70), &v23, v20);
    v6 = (volatile signed __int32 *)*((_QWORD *)&v23 + 1);
    if ( *((_QWORD *)&v23 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v23 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v6)(v6);
        if ( _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
      }
    }
    v7 = *(_QWORD *)(a1 + 0x128);
    if ( v7 )
      _InterlockedIncrement((volatile signed __int32 *)(v7 + 8));
    v21[0] = *(_QWORD *)(a1 + 0x120);
    v21[1] = *(_QWORD *)(a1 + 0x128);
    v8 = (__int64 *)sub_1434787E0((_QWORD *)(a1 + 0x70), &v24, v21);
    v9 = *v8;
    v10 = v8[1];
    *v8 = 0;
    v8[1] = 0;
    v11 = (volatile signed __int32 *)a2[1];
    *a2 = v9;
    a2[1] = v10;
    if ( v11 )
    {
      if ( _InterlockedExchangeAdd(v11 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
        if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
      }
    }
    v12 = (volatile signed __int32 *)*((_QWORD *)&v24 + 1);
  }
  else
  {
    v13 = sub_1402A65A0(0x38u);
    v14 = v13;
    if ( v13 )
    {
      *(_DWORD *)(v13 + 8) = 1;
      *(_DWORD *)(v13 + 0xC) = 1;
      *(_QWORD *)v13 = off_148392F80;
      CTX::TaskExecutor::TaskExecutor((CTX::TaskExecutor *)(v13 + 0x10), *(CTX::TaskDomain **)(a1 + 0x180));
    }
    else
    {
      v14 = 0;
    }
    v22[1] = v14;
    v22[0] = v14 + 0x10;
    v15 = (__int64 *)sub_1434787E0((_QWORD *)(a1 + 0x70), &v25, v22);
    v16 = *v15;
    v17 = v15[1];
    *v15 = 0;
    v15[1] = 0;
    v18 = (volatile signed __int32 *)a2[1];
    *a2 = v16;
    a2[1] = v17;
    if ( v18 )
    {
      if ( _InterlockedExchangeAdd(v18 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
        if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8LL))(v18);
      }
    }
    v12 = (volatile signed __int32 *)*((_QWORD *)&v25 + 1);
  }
  if ( v12 )
  {
    if ( _InterlockedExchangeAdd(v12 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v12)(v12);
      if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v12 + 8LL))(v12);
    }
  }
  sub_143466060(v4);
  return a2;
}

// --- End Function: sub_143595320 (0x143595320) ---

// --- Function: sub_1435955A0 (0x1435955A0) ---
__int64 __fastcall sub_1435955A0(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, char a5, _BYTE *a6)
{
  __int64 *v10; // rbx
  _QWORD v13[6]; // [rsp+30h] [rbp-48h] BYREF

  CTX::ContextTransitionTasks::ContextTransitionTasks(
    (CTX::ContextTransitionTasks *)a2,
    *(CTX::TaskDomain **)(a1 + 0x180));
  if ( (unsigned int)sub_142D416A0(a1 + 0x58) == a3 || *(_DWORD *)(a1 + 8) == a3 )
  {
    if ( a6 )
      *a6 = 1;
  }
  else
  {
    if ( qword_149F66620 )
      (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, char))(*(_QWORD *)qword_149F66620 + 8LL))(
        qword_149F66620,
        a1,
        a3,
        a4,
        a5);
    if ( a3 )
    {
      if ( a5 )
        sub_142D4EDB0(a1 + 0x58, a3);
      v10 = (__int64 *)sub_143591AC0(a1, (__int64)v13, a3, a4);
      std::shared_ptr<vraudio::MixerNode>::operator=((_QWORD *)a2, v10);
      std::shared_ptr<vraudio::MixerNode>::operator=((_QWORD *)(a2 + 0x10), v10 + 2);
      std::shared_ptr<vraudio::MixerNode>::operator=((_QWORD *)(a2 + 0x20), v10 + 4);
      sub_14345FEE0(v13);
      *(_BYTE *)(a1 + 0xCC) = a5;
    }
    if ( a6 )
      *a6 = 0;
  }
  return a2;
}

// --- End Function: sub_1435955A0 (0x1435955A0) ---

// --- Function: sub_14359D680 (0x14359D680) ---
_QWORD *__fastcall sub_14359D680(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1435A0980(a1, &v4);
  return a1;
}

// --- End Function: sub_14359D680 (0x14359D680) ---

// --- Function: sub_14359DC70 (0x14359DC70) ---
_QWORD *__fastcall sub_14359DC70(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1435A10D0(a1, &v4);
  return a1;
}

// --- End Function: sub_14359DC70 (0x14359DC70) ---

// --- Function: ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z_10 (0x14359DEB0) ---
__int64 __fastcall std::string::operator+=(__int64 a1, unsigned __int8 a2)
{
  sub_14359DEE0(a1, a2);
  return a1;
}

// --- End Function: ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z_10 (0x14359DEB0) ---

// --- Function: sub_14359DEE0 (0x14359DEE0) ---
_QWORD *__fastcall sub_14359DEE0(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_14276ABD0(a1, sub_14359B900);
  return a1;
}

// --- End Function: sub_14359DEE0 (0x14359DEE0) ---

// --- Function: sub_1435A66F0 (0x1435A66F0) ---
__int64 __fastcall sub_1435A66F0(_QWORD *a1, _QWORD *a2, AK::WriteBytesMem *a3, float a4)
{
  unsigned __int64 *v5; // [rsp+30h] [rbp-4F8h]
  unsigned int v6; // [rsp+38h] [rbp-4F0h]
  __int64 v7; // [rsp+40h] [rbp-4E8h]
  unsigned __int64 v8; // [rsp+48h] [rbp-4E0h] BYREF
  __int64 v9; // [rsp+50h] [rbp-4D8h]
  __int64 v10; // [rsp+58h] [rbp-4D0h]
  __int64 v11; // [rsp+60h] [rbp-4C8h]
  _QWORD *v12; // [rsp+68h] [rbp-4C0h]
  __int64 v13; // [rsp+70h] [rbp-4B8h]
  __int64 v14; // [rsp+78h] [rbp-4B0h] BYREF
  _BYTE v15[8]; // [rsp+80h] [rbp-4A8h] BYREF
  char v16; // [rsp+88h] [rbp-4A0h] BYREF
  __int64 (__fastcall *v17)(__int64, _QWORD); // [rsp+90h] [rbp-498h]
  void (__fastcall *v18)(__int64, int *); // [rsp+98h] [rbp-490h]
  int v19[2]; // [rsp+A0h] [rbp-488h] BYREF
  unsigned __int8 *v20; // [rsp+A8h] [rbp-480h]
  void (__fastcall *v21)(__int64, _BYTE *, unsigned __int8 *); // [rsp+B0h] [rbp-478h]
  _QWORD *v22; // [rsp+B8h] [rbp-470h]
  _QWORD *v23; // [rsp+C0h] [rbp-468h]
  void (__fastcall *v24)(__int64, int *, _QWORD *, _QWORD); // [rsp+C8h] [rbp-460h]
  unsigned __int64 *v25; // [rsp+D0h] [rbp-458h]
  __int64 v26; // [rsp+D8h] [rbp-450h]
  __int64 *v27; // [rsp+E0h] [rbp-448h]
  __int64 v28; // [rsp+E8h] [rbp-440h]
  __int64 *v29[2]; // [rsp+F0h] [rbp-438h] BYREF
  _QWORD v30[3]; // [rsp+100h] [rbp-428h] BYREF
  __int64 v31; // [rsp+118h] [rbp-410h] BYREF
  _QWORD v32[3]; // [rsp+120h] [rbp-408h] BYREF
  __m256i dst_; // [rsp+138h] [rbp-3F0h] BYREF
  _QWORD src_[3]; // [rsp+158h] [rbp-3D0h] BYREF
  _DWORD v35[12]; // [rsp+170h] [rbp-3B8h] BYREF
  int v36[216]; // [rsp+1A0h] [rbp-388h] BYREF

  a2[1] = *a2;
  if ( a4 > 0.0 )
  {
    v9 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 8);
    v17 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + 0x68LL);
    v6 = sub_1403B43E0((__int64)a1);
    v7 = v17(v9, v6);
    if ( v7 )
    {
      sub_14032BBD0(a1, src_);
      v18 = *(void (__fastcall **)(__int64, int *))(*(_QWORD *)v7 + 0x10LL);
      v18(v7, v19);
      sub_140372710((__int64)v36, 0x7832, *(__int64 *)v19, 0x32, "DebugDoor::FindNearbyComponents");
      qmemcpy(&dst_, src_, 0x18u);
      *(double *)&dst_.m256i_i64[3] = a4;
      sub_1403A9A30((__int64)v36, &dst_);
      v10 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x18);
      v21 = *(void (__fastcall **)(__int64, _BYTE *, unsigned __int8 *))(*(_QWORD *)v10 + 0x28LL);
      v20 = AK::WriteBytesMem::Bytes(a3);
      v21(v10, v15, v20);
      v29[0] = (__int64 *)v15;
      v29[1] = (__int64 *)&v16;
      sub_140363FD0((__int64)v35, v29);
      sub_1403A9A40((__int64)v36, (__int64)v35);
      sub_140375A50(v35);
      unknown_libname_474(v30);
      v11 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0xA0);
      v24 = *(void (__fastcall **)(__int64, int *, _QWORD *, _QWORD))(*(_QWORD *)v11 + 0x1C0LL);
      v22 = v30;
      v23 = v30;
      sub_14359DC70(v32, (__int64)v30);
      v24(v11, v36, v32, 0);
      sub_1402A5330(v32);
      v12 = v30;
      v5 = (unsigned __int64 *)v30[0];
      v25 = (unsigned __int64 *)v30[1];
      while ( v5 != v25 )
      {
        v8 = *v5;
        if ( is_entity_descriptor_valid_or_accessible(&v8) )
        {
          v13 = sub_1403115A0(&v8);
          if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x58LL))(v13) )
          {
            v26 = sub_1403115A0(&v8);
            v27 = sub_1429DB7B0(v26, &v31);
            v28 = *v27;
            v14 = v28;
            if ( Handle::IsValid(&v14) )
              sub_143730890(a2, &v14);
          }
        }
        ++v5;
      }
      sub_1402B4EC0(v30);
      sub_14037A590((__int64)v36);
    }
  }
  return sub_1402A53A0((__int64)a3);
}

// --- End Function: sub_1435A66F0 (0x1435A66F0) ---

// --- Function: sub_1435AAEC0 (0x1435AAEC0) ---
_QWORD *__fastcall sub_1435AAEC0(_QWORD *a1)
{
  *a1 = "struct SCEvtDebug_DrawDoorDebug";
  return a1;
}

// --- End Function: sub_1435AAEC0 (0x1435AAEC0) ---

// --- Function: sub_1435AAEE0 (0x1435AAEE0) ---
_QWORD *__fastcall sub_1435AAEE0(_QWORD *a1)
{
  *a1 = "struct SCEvtDebug_DrawProximitySensorDebug";
  return a1;
}

// --- End Function: sub_1435AAEE0 (0x1435AAEE0) ---

// --- Function: sub_1435ABF80 (0x1435ABF80) ---
__int64 __fastcall sub_1435ABF80(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r8
  void (__fastcall *v7)(__int64, _QWORD *, __int64, _QWORD, __int64, __int64, _QWORD); // [rsp+30h] [rbp-28h]
  _QWORD v8[4]; // [rsp+38h] [rbp-20h] BYREF

  v7 = *(void (__fastcall **)(__int64, _QWORD *, __int64, _QWORD, __int64, __int64, _QWORD))(*(_QWORD *)a1 + 0x10LL);
  sub_14359D680(v8, a2);
  LOBYTE(v3) = 1;
  v7(a1, v8, v3, a3, a2, a2, v7);
  return sub_1402A5330(v8);
}

// --- End Function: sub_1435ABF80 (0x1435ABF80) ---

// --- Function: sub_1435B2AF0 (0x1435B2AF0) ---
__int64 __fastcall sub_1435B2AF0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_14280FD70)(__int64); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_1436538F0();
  v8 = 1;
  v3 = sub_1435AAEC0(&v5);
  v9 = sub_1402A4EC0((__int64)v3);
  v10 = byte_149F67708;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_14280FD70 = sub_14280FD70;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_1435B2AF0 (0x1435B2AF0) ---

// --- Function: sub_1435B2BA0 (0x1435B2BA0) ---
__int64 __fastcall sub_1435B2BA0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 n8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_14280FC00)(__int64, __int64 *); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_143653920();
  n8 = 8;
  v3 = sub_1435AAEE0(&v5);
  v9 = sub_1402A4EC0((__int64)v3);
  v10 = byte_149F67710;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_14280FC00 = sub_14280FC00;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_1435B2BA0 (0x1435B2BA0) ---

// --- Function: sub_143600F40 (0x143600F40) ---
__int64 __fastcall sub_143600F40(_QWORD *a1, __int64 a2)
{
  return *a1 + 0x90 * a2;
}

// --- End Function: sub_143600F40 (0x143600F40) ---

// --- Function: sub_1436538F0 (0x1436538F0) ---
__int64 sub_1436538F0()
{
  __int64 result; // rax

  result = (unsigned int)dword_149F6770C;
  if ( !dword_149F6770C )
    return get_event_key_from_source_location(
             &dword_149F6770C,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ISC/Doors.h",
             0x23);
  return result;
}

// --- End Function: sub_1436538F0 (0x1436538F0) ---

// --- Function: sub_143653920 (0x143653920) ---
__int64 sub_143653920()
{
  __int64 result; // rax

  result = (unsigned int)dword_149F67714;
  if ( !dword_149F67714 )
    return get_event_key_from_source_location(
             &dword_149F67714,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ISC/Doors.h",
             0x29);
  return result;
}

// --- End Function: sub_143653920 (0x143653920) ---

// --- Function: sub_143706FB0 (0x143706FB0) ---
void __fastcall sub_143706FB0()
{
  __int128 v0; // xmm6
  __int64 v1; // rax
  float v2; // xmm6_4
  _QWORD *v3; // rdi
  size_t n0x1FF; // rbx
  _QWORD *v5; // rsi
  __int64 v6; // r14
  unsigned __int8 v7; // bl
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rdi
  _QWORD *v11; // rdi
  __int64 i; // rsi
  __int64 v13; // rbx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  __int64 j; // rsi
  __int64 v17; // rbx
  __int64 v18; // rax
  _QWORD v19[3]; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v20[2]; // [rsp+38h] [rbp-C8h] BYREF
  void *v21; // [rsp+48h] [rbp-B8h]
  char v22; // [rsp+50h] [rbp-B0h] BYREF
  __int128 v23; // [rsp+250h] [rbp+150h]
  __int64 v24; // [rsp+290h] [rbp+190h] BYREF
  __int64 v25; // [rsp+298h] [rbp+198h] BYREF
  __int64 n0x1C9C380; // [rsp+2A0h] [rbp+1A0h] BYREF

  if ( BYTE1(qword_149C8E516) )
  {
    if ( !byte_149C8E514 )
      return;
  }
  else if ( BYTE2(qword_149C8E516) )
  {
    return;
  }
  if ( dword_149B2CA54 || dword_149B2CA50 )
  {
    v25 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                       qword_149C8DF80,
                       0);
    if ( sub_14059CAF0(&v25, &qword_149F67868) )
    {
      n0x1C9C380 = 0x1C9C380;
      qword_149F67868 = *sub_14059CA80(&v25, &v24, &n0x1C9C380);
      if ( !dword_149B2CA50 && !dword_149B2CA54 )
        return;
      v23 = v0;
      v1 = (*(__int64 (**)(void))(*(_QWORD *)qword_149C8DFE0 + 0x3D0LL))();
      v2 = *(float *)&dword_149B2CA60;
      v3 = (_QWORD *)v1;
      v22 = 0;
      v20[0] = 0;
      v21 = &v22;
      v20[1] = 0x1FF;
      n0x1FF = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++n0x1FF;
      while ( aEngineComponen_32[n0x1FF] );
      if ( n0x1FF )
      {
        sub_1402A63B0(v20, n0x1FF);
        memcpy(v21, "Engine.Components.SCItemDoor", n0x1FF);
      }
      sub_1435A66F0(v3, qword_149F66EF8, (AK::WriteBytesMem *)v20, v2);
      if ( dword_149B2CA54 )
      {
        sub_142C64BB0(qword_149F66EE0);
        v5 = (_QWORD *)unknown_libname_485((__int64)qword_149F66EF8);
        v6 = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)qword_149F66EF8);
        if ( v5 != (_QWORD *)v6 )
        {
          v7 = v24;
          do
          {
            v8 = sub_14275ADA0(v5);
            sub_14033D3F0(*(_QWORD *)(v8 + 8) & 0xFFFFFFFFFFFFLL, &v24);
            if ( AssetMeta::HasActorSubresource(&v24) )
            {
              v9 = sub_1403115A0(&v24);
              v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x600LL))(v9);
              std::string::operator+=((__int64)v19, v7);
              sub_1435ABF80(v10, (__int64)v19, 0x9Du);
              sub_142758060(v19);
            }
            ++v5;
          }
          while ( v5 != (_QWORD *)v6 );
        }
      }
    }
    if ( dword_149B2CA50 )
    {
      v11 = (_QWORD *)unknown_libname_485((__int64)qword_149F66EF8);
      for ( i = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)qword_149F66EF8);
            v11 != (_QWORD *)i;
            ++v11 )
      {
        if ( Handle::IsValid(v11) )
        {
          v13 = qword_149C8DFC0;
          v14 = sub_1427D2EA0(v11);
          sub_1435B2AF0(v13, v14, (__int64)&v24);
        }
      }
    }
    if ( dword_149B2CA54 )
    {
      v15 = (_QWORD *)unknown_libname_485((__int64)qword_149F66EE0);
      for ( j = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)qword_149F66EE0);
            v15 != (_QWORD *)j;
            ++v15 )
      {
        if ( Handle::IsValid(v15) )
        {
          v17 = qword_149C8DFC0;
          BYTE4(v24) = dword_149B2CA58 != 0;
          LODWORD(v24) = dword_149B2CA54;
          v18 = sub_1427D2EA0(v15);
          sub_1435B2BA0(v17, v18, (__int64)&v24);
        }
      }
    }
  }
}

// --- End Function: sub_143706FB0 (0x143706FB0) ---

// --- Function: sub_14372C530 (0x14372C530) ---
_BOOL8 __fastcall sub_14372C530(__int64 a1)
{
  return **(_QWORD **)a1 == *(_QWORD *)(*(_QWORD *)a1 + 8LL);
}

// --- End Function: sub_14372C530 (0x14372C530) ---

// --- Function: sub_143730890 (0x143730890) ---
__int64 __fastcall sub_143730890(__int64 a1, __int64 *a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]
  _QWORD *v4; // [rsp+28h] [rbp-10h]

  if ( *(_QWORD *)(a1 + 8) >= *(_QWORD *)(a1 + 0x10) )
    return sub_1435A61A0(a1, a2);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3 + 8;
  v4 = (_QWORD *)sub_1402A53E0(8, v3);
  result = *a2;
  *v4 = *a2;
  return result;
}

// --- End Function: sub_143730890 (0x143730890) ---

// --- Function: sub_1437321C0 (0x1437321C0) ---
__int64 __fastcall sub_1437321C0(AK::WriteBytesMem *a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall **v4)(unsigned __int8 *, __int64, __int64); // [rsp+20h] [rbp-28h]
  unsigned __int8 *v5; // [rsp+28h] [rbp-20h]

  v5 = AK::WriteBytesMem::Bytes(a1);
  v4 = (__int64 (__fastcall **)(unsigned __int8 *, __int64, __int64))sub_1402A4D50((__int64)a1);
  return (*v4)(v5, a2, a3);
}

// --- End Function: sub_1437321C0 (0x1437321C0) ---

// --- Function: sub_1439C70E0 (0x1439C70E0) ---
__int64 __fastcall sub_1439C70E0(__int64 Src_2)
{
  __int64 Src_1; // rax
  float v2; // xmm0_4
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v7; // xmm0_4
  __int128 v13; // kr00_16
  int n5; // [rsp+50h] [rbp-568h]
  float v15; // [rsp+80h] [rbp-538h]
  float v16; // [rsp+84h] [rbp-534h]
  float v17; // [rsp+88h] [rbp-530h]
  float v18; // [rsp+8Ch] [rbp-52Ch]
  float v19; // [rsp+90h] [rbp-528h]
  float v20; // [rsp+94h] [rbp-524h]
  float v21; // [rsp+98h] [rbp-520h]
  float v22; // [rsp+9Ch] [rbp-51Ch]
  float v23; // [rsp+A0h] [rbp-518h]
  float v24; // [rsp+A4h] [rbp-514h]
  float v25; // [rsp+A8h] [rbp-510h]
  float v26; // [rsp+ACh] [rbp-50Ch]
  float v27; // [rsp+B0h] [rbp-508h]
  float v28; // [rsp+B4h] [rbp-504h]
  float v29; // [rsp+B8h] [rbp-500h]
  float v30; // [rsp+BCh] [rbp-4FCh]
  float v31; // [rsp+C0h] [rbp-4F8h]
  float v32; // [rsp+C4h] [rbp-4F4h]
  float v33; // [rsp+C8h] [rbp-4F0h]
  float v34; // [rsp+D0h] [rbp-4E8h]
  float v35; // [rsp+D4h] [rbp-4E4h]
  float v36; // [rsp+D8h] [rbp-4E0h]
  float v37; // [rsp+DCh] [rbp-4DCh]
  float v38; // [rsp+E0h] [rbp-4D8h]
  float v39; // [rsp+E4h] [rbp-4D4h]
  float v40; // [rsp+E8h] [rbp-4D0h]
  float v41; // [rsp+ECh] [rbp-4CCh]
  float v42; // [rsp+F0h] [rbp-4C8h]
  float v43; // [rsp+F4h] [rbp-4C4h]
  float v44; // [rsp+F8h] [rbp-4C0h]
  unsigned __int64 *v45; // [rsp+100h] [rbp-4B8h]
  float v46; // [rsp+108h] [rbp-4B0h] BYREF
  float v47; // [rsp+10Ch] [rbp-4ACh]
  float v48; // [rsp+110h] [rbp-4A8h]
  __int64 v49; // [rsp+118h] [rbp-4A0h]
  float X_5; // [rsp+120h] [rbp-498h]
  float X_6; // [rsp+128h] [rbp-490h]
  float X_7; // [rsp+130h] [rbp-488h]
  float X_8; // [rsp+138h] [rbp-480h]
  float X_9; // [rsp+140h] [rbp-478h]
  float X_10; // [rsp+148h] [rbp-470h]
  float X_11; // [rsp+150h] [rbp-468h]
  float X; // [rsp+158h] [rbp-460h]
  float v58; // [rsp+160h] [rbp-458h]
  float v59; // [rsp+164h] [rbp-454h]
  float X_1; // [rsp+168h] [rbp-450h]
  float X_2; // [rsp+170h] [rbp-448h]
  float X_3; // [rsp+178h] [rbp-440h]
  float X_4; // [rsp+180h] [rbp-438h]
  float v64; // [rsp+188h] [rbp-430h]
  __int64 v65; // [rsp+190h] [rbp-428h]
  float v66; // [rsp+198h] [rbp-420h]
  float v67; // [rsp+1A0h] [rbp-418h]
  float v68; // [rsp+1A8h] [rbp-410h]
  float v69; // [rsp+1B0h] [rbp-408h]
  float v70; // [rsp+1B8h] [rbp-400h]
  float v71; // [rsp+1C0h] [rbp-3F8h]
  float v72; // [rsp+1C8h] [rbp-3F0h]
  float v73; // [rsp+1D0h] [rbp-3E8h]
  float v74; // [rsp+1D8h] [rbp-3E0h]
  float v75; // [rsp+1DCh] [rbp-3DCh]
  float v76; // [rsp+1E0h] [rbp-3D8h]
  float v77; // [rsp+1E8h] [rbp-3D0h]
  float v78; // [rsp+1F0h] [rbp-3C8h]
  float v79; // [rsp+1F8h] [rbp-3C0h]
  int v80; // [rsp+200h] [rbp-3B8h]
  int v81; // [rsp+204h] [rbp-3B4h] BYREF
  float v82; // [rsp+208h] [rbp-3B0h]
  float v83; // [rsp+20Ch] [rbp-3ACh]
  float v84; // [rsp+210h] [rbp-3A8h]
  float v85; // [rsp+218h] [rbp-3A0h]
  float v86; // [rsp+220h] [rbp-398h]
  float v87; // [rsp+228h] [rbp-390h]
  float v88; // [rsp+230h] [rbp-388h]
  float v89; // [rsp+238h] [rbp-380h]
  __int64 v90; // [rsp+240h] [rbp-378h]
  float v91; // [rsp+248h] [rbp-370h]
  float v92; // [rsp+24Ch] [rbp-36Ch]
  float v93; // [rsp+250h] [rbp-368h]
  float v94; // [rsp+258h] [rbp-360h]
  float v95; // [rsp+260h] [rbp-358h]
  float v96; // [rsp+264h] [rbp-354h]
  float v97; // [rsp+268h] [rbp-350h]
  float v98; // [rsp+26Ch] [rbp-34Ch]
  float v99; // [rsp+270h] [rbp-348h]
  float v100; // [rsp+274h] [rbp-344h]
  float v101; // [rsp+278h] [rbp-340h]
  float v102; // [rsp+27Ch] [rbp-33Ch]
  float v103; // [rsp+280h] [rbp-338h]
  float v104; // [rsp+288h] [rbp-330h]
  __int64 v105; // [rsp+290h] [rbp-328h]
  __int64 v106; // [rsp+298h] [rbp-320h]
  __int64 v107; // [rsp+2A0h] [rbp-318h]
  __int64 v108; // [rsp+2A8h] [rbp-310h]
  __int64 v109; // [rsp+2B0h] [rbp-308h]
  __int64 v110; // [rsp+2B8h] [rbp-300h]
  __int64 v111; // [rsp+2C0h] [rbp-2F8h]
  __int64 v112; // [rsp+2C8h] [rbp-2F0h]
  float src_[4]; // [rsp+2D0h] [rbp-2E8h] BYREF
  float dst_[3]; // [rsp+2E0h] [rbp-2D8h] BYREF
  float v115[3]; // [rsp+2F0h] [rbp-2C8h] BYREF
  float v116; // [rsp+2FCh] [rbp-2BCh]
  float v117; // [rsp+300h] [rbp-2B8h]
  float v118; // [rsp+304h] [rbp-2B4h]
  float v119; // [rsp+308h] [rbp-2B0h]
  float v120; // [rsp+30Ch] [rbp-2ACh]
  float v121; // [rsp+310h] [rbp-2A8h]
  float v122; // [rsp+314h] [rbp-2A4h]
  float v123; // [rsp+318h] [rbp-2A0h]
  float v124; // [rsp+31Ch] [rbp-29Ch]
  float v125; // [rsp+320h] [rbp-298h]
  float v126; // [rsp+324h] [rbp-294h]
  float v127; // [rsp+328h] [rbp-290h]
  float v128; // [rsp+32Ch] [rbp-28Ch]
  float v129; // [rsp+330h] [rbp-288h]
  float v130; // [rsp+334h] [rbp-284h]
  float v131; // [rsp+338h] [rbp-280h]
  __int64 v132; // [rsp+340h] [rbp-278h]
  void *Src; // [rsp+348h] [rbp-270h]
  int v134[2]; // [rsp+350h] [rbp-268h]
  __m256 *v135; // [rsp+358h] [rbp-260h]
  __int64 v136; // [rsp+360h] [rbp-258h]
  __int64 v137; // [rsp+368h] [rbp-250h]
  int v138[2]; // [rsp+370h] [rbp-248h]
  unsigned __int64 *v139; // [rsp+378h] [rbp-240h]
  __int64 v140; // [rsp+380h] [rbp-238h]
  __int64 (__fastcall *p_sub_143A18AD0)(); // [rsp+388h] [rbp-230h] BYREF
  __int64 (__fastcall *v142)(__int64, char *, _QWORD *); // [rsp+390h] [rbp-228h]
  char *v143; // [rsp+398h] [rbp-220h]
  __int64 (__fastcall *v144)(__int64, char *); // [rsp+3A0h] [rbp-218h]
  __int64 v145; // [rsp+3A8h] [rbp-210h]
  __int64 v146; // [rsp+3B0h] [rbp-208h]
  __int64 (__fastcall *v147)(__int64, char *, _QWORD); // [rsp+3B8h] [rbp-200h]
  float *src; // [rsp+3C0h] [rbp-1F8h]
  int v149; // [rsp+3C8h] [rbp-1F0h]
  __int64 v150; // [rsp+3D0h] [rbp-1E8h]
  char v151[8]; // [rsp+3D8h] [rbp-1E0h] BYREF
  int v152; // [rsp+3E0h] [rbp-1D8h] BYREF
  _QWORD v153[4]; // [rsp+3E8h] [rbp-1D0h] BYREF
  _QWORD v154[3]; // [rsp+408h] [rbp-1B0h] BYREF
  _QWORD v155[4]; // [rsp+420h] [rbp-198h] BYREF
  char v156[24]; // [rsp+440h] [rbp-178h] BYREF
  char v157[56]; // [rsp+458h] [rbp-160h] BYREF
  int v158[48]; // [rsp+490h] [rbp-128h] BYREF
  float v159[16]; // [rsp+550h] [rbp-68h] BYREF

  v149 = 0;
  v109 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x98);
  v110 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v109 + 0xA0LL))(v109);
  v111 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v110 + 0x2E0LL))(v110);
  if ( v111 )
    v108 = v111;
  else
    v108 = 0;
  v90 = v108;
  if ( v108 )
  {
    *(float *)Src_2 = *(float *)(Src_2 + 4);
    *(float *)(Src_2 + 4) = 0x461C4000;
    *(_BYTE *)(Src_2 + 0x1D) = 0;
    *(_BYTE *)(Src_2 + 0x1C) = 0;
    v112 = *(_QWORD *)sub_1402A4D50((__int64)&gEnv);
    v45 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v112 + 0x60LL))(v112);
    sub_14032BBD0(v45, v154);
    sub_140718D50(v45, (__int64)&v46);
    v105 = *(_QWORD *)sub_1402A4D50((__int64)&gEnv);
    v139 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v105 + 0x60LL))(v105);
    sub_14032CE50(v139, v159);
    v2 = sub_14040AAF0((__int64)v45).m128_f32[0];
    v83 = v48 - (float)(v2 * 0.25);
    v3 = sub_1403B2CC0((__int64)v45);
    v82 = v47 - (float)(v3 * 0.25);
    v84 = v46;
    v95 = v82;
    v96 = v83;
    v97 = v46;
    X = v82 * 0.5;
    v15 = j_sinf(v82 * 0.5);
    v38 = j_cosf(X);
    X_1 = v96 * 0.5;
    v40 = j_sinf(v96 * 0.5);
    v37 = j_cosf(X_1);
    X_2 = v97 * 0.5;
    v36 = j_sinf(v97 * 0.5);
    v39 = j_cosf(X_2);
    v119 = (float)((float)(v38 * v37) * v39) + (float)((float)(v15 * v40) * v36);
    v116 = (float)((float)(v39 * v37) * v15) - (float)((float)(v36 * v40) * v38);
    v117 = (float)((float)(v39 * v40) * v38) + (float)((float)(v36 * v37) * v15);
    v118 = (float)((float)(v36 * v37) * v38) - (float)((float)(v39 * v40) * v15);
    v87 = 2.0 * (float)((float)(v118 * v117) + (float)(v116 * v119));
    v86 = (float)(2.0 * (float)((float)(v117 * v117) + (float)(v119 * v119))) - 1.0;
    v85 = 2.0 * (float)((float)(v116 * v117) - (float)(v118 * v119));
    v159[3] = v85;
    v159[4] = v86;
    v159[5] = v87;
    v94 = v46;
    v4 = sub_14040AAF0((__int64)v45).m128_f32[0];
    v89 = v48 + (float)(v4 * 0.25);
    v88 = v47;
    v98 = v47;
    v99 = v89;
    v100 = v94;
    X_3 = v47 * 0.5;
    v21 = j_sinf(v47 * 0.5);
    v18 = j_cosf(X_3);
    X_4 = v99 * 0.5;
    v20 = j_sinf(v99 * 0.5);
    v17 = j_cosf(X_4);
    X_5 = v100 * 0.5;
    v16 = j_sinf(v100 * 0.5);
    v19 = j_cosf(X_5);
    v123 = (float)((float)(v18 * v17) * v19) + (float)((float)(v21 * v20) * v16);
    v120 = (float)((float)(v19 * v17) * v21) - (float)((float)(v16 * v20) * v18);
    v121 = (float)((float)(v19 * v20) * v18) + (float)((float)(v16 * v17) * v21);
    v122 = (float)((float)(v16 * v17) * v18) - (float)((float)(v19 * v20) * v21);
    v67 = 2.0 * (float)((float)(v122 * v121) + (float)(v120 * v123));
    v66 = (float)(2.0 * (float)((float)(v121 * v121) + (float)(v123 * v123))) - 1.0;
    v104 = 2.0 * (float)((float)(v120 * v121) - (float)(v122 * v123));
    v159[6] = v104;
    v159[7] = v66;
    v159[8] = v67;
    v70 = v46;
    v5 = sub_14040AAF0((__int64)v45).m128_f32[0];
    v69 = v48 - (float)(v5 * 0.25);
    v68 = v47;
    v101 = v47;
    v102 = v69;
    v103 = v70;
    X_6 = v47 * 0.5;
    v27 = j_sinf(v47 * 0.5);
    v24 = j_cosf(X_6);
    X_7 = v102 * 0.5;
    v26 = j_sinf(v102 * 0.5);
    v23 = j_cosf(X_7);
    X_8 = v103 * 0.5;
    v22 = j_sinf(v103 * 0.5);
    v25 = j_cosf(X_8);
    v127 = (float)((float)(v24 * v23) * v25) + (float)((float)(v27 * v26) * v22);
    v124 = (float)((float)(v25 * v23) * v27) - (float)((float)(v22 * v26) * v24);
    v125 = (float)((float)(v25 * v26) * v24) + (float)((float)(v22 * v23) * v27);
    v126 = (float)((float)(v22 * v23) * v24) - (float)((float)(v25 * v26) * v27);
    v73 = 2.0 * (float)((float)(v126 * v125) + (float)(v124 * v127));
    v72 = (float)(2.0 * (float)((float)(v125 * v125) + (float)(v127 * v127))) - 1.0;
    v71 = 2.0 * (float)((float)(v124 * v125) - (float)(v126 * v127));
    v159[9] = v71;
    v159[0xA] = v72;
    v159[0xB] = v73;
    v6 = sub_14040AAF0((__int64)v45).m128_f32[0];
    v75 = v48 + (float)(v6 * 0.25);
    v7 = sub_1403B2CC0((__int64)v45);
    v74 = v47 - (float)(v7 * 0.25);
    v76 = v46;
    v91 = v74;
    v92 = v75;
    v93 = v46;
    X_9 = v74 * 0.5;
    v33 = j_sinf(v74 * 0.5);
    v30 = j_cosf(X_9);
    X_10 = v92 * 0.5;
    v32 = j_sinf(v92 * 0.5);
    v29 = j_cosf(X_10);
    X_11 = v93 * 0.5;
    v28 = j_sinf(v93 * 0.5);
    v31 = j_cosf(X_11);
    v131 = (float)((float)(v30 * v29) * v31) + (float)((float)(v33 * v32) * v28);
    v128 = (float)((float)(v31 * v29) * v33) - (float)((float)(v28 * v32) * v30);
    v129 = (float)((float)(v31 * v32) * v30) + (float)((float)(v28 * v29) * v33);
    v130 = (float)((float)(v28 * v29) * v30) - (float)((float)(v31 * v32) * v33);
    v79 = 2.0 * (float)((float)(v130 * v129) + (float)(v128 * v131));
    v78 = (float)(2.0 * (float)((float)(v129 * v129) + (float)(v131 * v131))) - 1.0;
    v77 = 2.0 * (float)((float)(v128 * v129) - (float)(v130 * v131));
    v159[0xC] = v77;
    v159[0xD] = v78;
    _XMM0 = LODWORD(v79);
    v159[0xE] = v79;
    v106 = sub_1403EAB20((unsigned __int64 *)(v90 + 8));
    Src_1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v106 + 0x3D0LL))(v106);
    Src = (void *)Src_1;
    for ( n5 = 0; n5 < 5; ++n5 )
    {
      if ( *(_DWORD *)(Src_2 + 4LL * n5 + 8) )
      {
        v140 = sub_1465E7430(qword_149FBE618);
        v80 = *(_DWORD *)(Src_2 + 4LL * n5 + 8);
        sub_14049FB00(v140, v80);
      }
      v107 = sub_1403EAB20((unsigned __int64 *)(v90 + 8));
      v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v107 + 0x648LL))(v107);
      v137 = sub_1465E7430(qword_149FBE618);
      sub_1403651D0(v155);
      p_sub_143A18AD0 = sub_143A18AD0;
      sub_141541D70(v153, Src_2, 0, &p_sub_143A18AD0, 8u);
      v153[3] = sub_1437321C0;
      v135 = (__m256 *)v153;
      v143 = v151;
      v144 = *(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v49 + 0x18LL);
      v150 = v144(v49, v151);
      v145 = *(_QWORD *)sub_14036CF10(&v152, 0, 0);
      v146 = v145;
      v132 = v145;
      v147 = *(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)v49 + 0x78LL);
      v65 = v147(v49, v157, 0);
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+18h] }
      v44 = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax] }
      v41 = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+8] }
      v42 = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+10h] }
      v43 = *(float *)&_XMM0;
      v59 = (float)((float)(v42 * v159[3 * n5 + 2]) - (float)(*(float *)&_XMM0 * v159[3 * n5 + 1]))
          + (float)(v44 * v159[3 * n5]);
      v58 = (float)((float)(*(float *)&_XMM0 * v159[3 * n5]) - (float)(v41 * v159[3 * n5 + 2]))
          + (float)(v44 * v159[3 * n5 + 1]);
      v64 = (float)((float)(v41 * v159[3 * n5 + 1]) - (float)(v42 * v159[3 * n5])) + (float)(v44 * v159[3 * n5 + 2]);
      v34 = (float)((float)(v59 * v43) - (float)(v64 * v41))
          + (float)((float)((float)(v59 * v43) - (float)(v64 * v41)) + v159[3 * n5 + 1]);
      v35 = (float)((float)(v58 * v41) - (float)(v59 * v42))
          + (float)((float)((float)(v58 * v41) - (float)(v59 * v42)) + v159[3 * n5 + 2]);
      src_[0] = (float)((float)(v64 * v42) - (float)(v58 * v43))
              + (float)((float)((float)(v64 * v42) - (float)(v58 * v43)) + v159[3 * n5]);
      src_[1] = v34;
      src_[2] = v35;
      src = src_;
      qmemcpy(dst_, src_, sizeof(dst_));
      v115[0] = dst_[0] * 3.0;
      v115[1] = dst_[1] * 3.0;
      v13 = LODWORD(dst_[2]);
      *(float *)&v13 = dst_[2] * 3.0;
      _XMM0 = v13;
      v115[2] = dst_[2] * 3.0;
      *(_QWORD *)v138 = v115;
      v142 = *(__int64 (__fastcall **)(__int64, char *, _QWORD *))(*(_QWORD *)v49 + 0xF8LL);
      *(_QWORD *)v134 = v142(v49, v156, v154);
      v136 = sub_140459BF0(
               (__int64)v158,
               (__int64)"CWeaponCheck::CastRays",
               *(__int64 *)v134,
               *(__int64 *)v138,
               0x11F,
               0x8F,
               Src,
               1u,
               v132,
               (_QWORD *)v150);
      v81 = 1;
      *(_DWORD *)(Src_2 + 4LL * n5 + 8) = sub_1415E4370(v137, 0x53, &v81, v136, v135, (__int64)v155);
      sub_140468B50((__int64)v158);
      Src_1 = (unsigned int)(n5 + 1);
    }
  }
  else
  {
    Src_1 = Src_2;
    *(float *)Src_2 = 0x461C4000;
  }
  return Src_1;
}

// --- End Function: sub_1439C70E0 (0x1439C70E0) ---

// --- Function: sub_1439E9410 (0x1439E9410) ---
__m128 __fastcall sub_1439E9410(float *a1)
{
  __int128 v1; // kr00_16
  float v3; // [rsp+24h] [rbp-14h]
  float v4; // [rsp+28h] [rbp-10h]
  unsigned int v5; // [rsp+2Ch] [rbp-Ch]

  v4 = *(float *)&dword_149F6C624;
  if ( *a1 > 0.0000099999997 && *a1 < 1.0 )
  {
    if ( *a1 <= 0.5 )
      v3 = 0.0;
    else
      v3 = *a1 * 0.5;
    v4 = (float)(*(float *)&dword_149F6C624 * v3) + (float)((float)(1.0 - v3) * 0.050000001);
  }
  *(float *)&v5 = (*(float (__fastcall **)(__int64))(*(_QWORD *)qword_149F6C618 + 0x20LL))(qword_149F6C618);
  v1 = v5;
  *(float *)&v1 = (float)(*(float *)&v5 * 0.85000002) + (float)(v4 * 0.15000001);
  return (__m128)v1;
}

// --- End Function: sub_1439E9410 (0x1439E9410) ---

// --- Function: sub_143A18AD0 (0x143A18AD0) ---
__int64 __fastcall sub_143A18AD0(__int64 a1, _DWORD *a2, __int64 a3)
{
  __int64 result; // rax
  int n5; // [rsp+20h] [rbp-28h]
  float v5; // [rsp+24h] [rbp-24h]
  float *v6; // [rsp+30h] [rbp-18h]

  ++*(_BYTE *)(a1 + 0x1D);
  for ( n5 = 0; n5 < 5; ++n5 )
  {
    if ( *(_DWORD *)(a1 + 4LL * n5 + 8) == *a2 )
    {
      *(_DWORD *)(a1 + 4LL * n5 + 8) = 0;
      break;
    }
  }
  result = a3;
  if ( *(int *)(a3 + 0x180) > 0 )
  {
    v6 = (float *)(sub_1402A4D50(a3) + 0x10);
    if ( *v6 <= *(float *)(a1 + 4) )
      v5 = *v6;
    else
      v5 = *(float *)(a1 + 4);
    result = a1;
    *(float *)(a1 + 4) = v5;
  }
  return result;
}

// --- End Function: sub_143A18AD0 (0x143A18AD0) ---

// --- Function: sub_143A3D940 (0x143A3D940) ---
char __fastcall sub_143A3D940(__int64 a1)
{
  char result; // al
  int n0x13; // [rsp+20h] [rbp-18h]

  if ( qword_149F6C618 )
  {
    if ( *(unsigned __int8 *)(a1 + 0x1D) > 4u )
      return sub_1439C70E0(a1);
    n0x13 = *(unsigned __int8 *)(a1 + 0x1C);
    result = *(_BYTE *)(a1 + 0x1C) + 1;
    *(_BYTE *)(a1 + 0x1C) = result;
    if ( n0x13 > 0x13 )
      return sub_1439C70E0(a1);
  }
  return result;
}

// --- End Function: sub_143A3D940 (0x143A3D940) ---

// --- Function: sub_143A3D9A0 (0x143A3D9A0) ---
__int64 sub_143A3D9A0()
{
  _QWORD dst_[10]; // [rsp+90h] [rbp-98h] BYREF
  _QWORD buf_[9]; // [rsp+E0h] [rbp-48h] BYREF

  sub_1402B3C60(dst_);
  memset(buf_, 0, 0x30u);
  qmemcpy(dst_, sub_1402B3C60(buf_), 0x30u);
  dst_[2] = __rdtsc();
  HIDWORD(dst_[0]) = 1;
  BYTE4(dst_[1]) = 0;
  LOWORD(dst_[0]) = 0x3500;
  qword_149C89AA0(
    dst_,
    &word_149F6D324,
    "Stereo3D::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Stereo3D/StereoFramework.cpp",
    0x27);
  WORD1(dst_[0]) = word_149F6D324;
  qword_149F6C618 = 0;
  dst_[3] = __rdtsc();
  return qword_149C89AA8(dst_);
}

// --- End Function: sub_143A3D9A0 (0x143A3D9A0) ---

// --- Function: sub_143A4B9D0 (0x143A4B9D0) ---
_QWORD *__fastcall sub_143A4B9D0(_QWORD ***a1, Parameter *Parameter_1)
{
  *Parameter_1 = ***a1;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_143A4B9D0 (0x143A4B9D0) ---

// --- Function: sub_143AFAB60 (0x143AFAB60) ---
__int64 __fastcall sub_143AFAB60(_QWORD *a1)
{
  __int64 v2; // rcx
  __int64 v3; // rsi
  _QWORD *v4; // r14
  _QWORD *v5; // rdi
  unsigned __int64 v6; // rbx
  _QWORD *v7; // rdx
  __int64 i; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rdi
  void (__fastcall ***v11)(_QWORD, __int64); // rcx
  _QWORD *v12; // rax
  int n0x5C00; // [rsp+30h] [rbp-68h] BYREF
  __int64 v15; // [rsp+34h] [rbp-64h]
  int v16; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v17; // [rsp+40h] [rbp-58h]
  unsigned __int64 v18; // [rsp+48h] [rbp-50h]
  __int64 v19; // [rsp+50h] [rbp-48h]
  __int64 v20; // [rsp+58h] [rbp-40h]

  n0x5C00 = 0x5C00;
  v16 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v15 = 1;
  v17 = __rdtsc();
  qword_149C89AA0(
    &n0x5C00,
    &word_149F7148C,
    "CGameAISystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AI/GameAISystem.cpp",
    0xA4);
  v2 = a1[9];
  HIWORD(n0x5C00) = word_149F7148C;
  if ( v2 )
    sub_144ED3030();
  v3 = a1[0xB];
  if ( v3 )
  {
    sub_1403CE280(v3 + 0x18);
    v4 = *(_QWORD **)v3;
    while ( v4 != *(_QWORD **)(v3 + 8) )
    {
      v5 = v4 + 1;
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 8LL))(*v4) )
      {
        v6 = *(_QWORD *)(v3 + 8);
        if ( (unsigned __int64)v5 < v6 )
        {
          v7 = v4;
          for ( i = (__int64)(v6 - (_QWORD)v5) >> 3; i > 0; v7 = v10 )
          {
            v9 = v7[1];
            v10 = v7 + 1;
            v7[1] = 0;
            v11 = (void (__fastcall ***)(_QWORD, __int64))*v7;
            *v7 = v9;
            if ( v11 )
              (**v11)(v11, 1);
            --i;
          }
        }
        v12 = (_QWORD *)(*(_QWORD *)(v3 + 8) - 8LL);
        *(_QWORD *)(v3 + 8) = v12;
        if ( *v12 )
          (**(void (__fastcall ***)(_QWORD, __int64))*v12)(*v12, 1);
      }
      else
      {
        ++v4;
      }
    }
  }
  if ( a1[0xC] )
    sub_14573F990();
  v18 = __rdtsc();
  return qword_149C89AA8(&n0x5C00);
}

// --- End Function: sub_143AFAB60 (0x143AFAB60) ---

// --- Function: sub_143B497B0 (0x143B49822) ---
__int64 __fastcall sub_143B497B0(__int64 a1, __int64 a2, __int64 a3)
{
  return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(a1 + 0x10) + 8LL))(
           *(int *)(*(_QWORD *)(a1 + 0x10) + 0x10LL) + **(_QWORD **)(a1 + 0x10),
           a2,
           a3);
}

// --- End Function: sub_143B497B0 (0x143B49822) ---

// --- Function: sub_143BA38B0 (0x143BA38B0) ---
_QWORD *__fastcall sub_143BA38B0(__int64 a1, Parameter *Parameter_1)
{
  *Parameter_1 = **(_QWORD **)(a1 + 8);
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_143BA38B0 (0x143BA38B0) ---

// --- Function: sub_143BD4820 (0x143BD4820) ---
__int64 __fastcall sub_143BD4820(__int64 a1, __int64 a2)
{
  return sub_143CF9AB0(a1, a2);
}

// --- End Function: sub_143BD4820 (0x143BD4820) ---

// --- Function: sub_143BDBF30 (0x143BDBF30) ---
__int64 __fastcall sub_143BDBF30(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _BYTE v4[80]; // [rsp+28h] [rbp-50h] BYREF

  v2 = sub_143CB5860(v4, a2);
  sub_143BDBED0(a1, v2);
  sub_143CDBDA0(a2);
  return a1;
}

// --- End Function: sub_143BDBF30 (0x143BDBF30) ---

// --- Function: sub_143BDD3A0 (0x143BDD3A0) ---
_QWORD *__fastcall sub_143BDD3A0(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  *a1 = a2;
  a1[1] = sub_143BD4820;
  *a3 = a1;
  return a1;
}

// --- End Function: sub_143BDD3A0 (0x143BDD3A0) ---

// --- Function: sub_143BDEFD0 (0x143BDEFD0) ---
__int64 __fastcall sub_143BDEFD0(__int64 a1, const void *src)
{
  _BYTE dst_[72]; // [rsp+20h] [rbp-48h] BYREF

  qmemcpy(dst_, src, 0x30u);
  sub_143BDF010(a1, dst_);
  return a1;
}

// --- End Function: sub_143BDEFD0 (0x143BDEFD0) ---

// --- Function: sub_143BE00C0 (0x143BE00C0) ---
__int64 __fastcall sub_143BE00C0(__int64 a1, __int64 a2)
{
  sub_143BE00F0(a1, a2);
  return a1;
}

// --- End Function: sub_143BE00C0 (0x143BE00C0) ---

// --- Function: sub_143BE07E0 (0x143BE07E0) ---
_QWORD *__fastcall sub_143BE07E0(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_143BF0120(a1, &v4);
  return a1;
}

// --- End Function: sub_143BE07E0 (0x143BE07E0) ---

// --- Function: sub_143BE0830 (0x143BE0830) ---
_QWORD *__fastcall sub_143BE0830(_QWORD *a1, __int64 a2)
{
  sub_143BE07E0(a1, a2);
  return a1;
}

// --- End Function: sub_143BE0830 (0x143BE0830) ---

// --- Function: sub_143BF95B0 (0x143BF95B0) ---
__int64 __fastcall sub_143BF95B0(__int64 *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 i; // [rsp+38h] [rbp-110h]
  __int64 v4; // [rsp+40h] [rbp-108h]
  __int64 v5; // [rsp+40h] [rbp-108h]
  __int64 v6; // [rsp+48h] [rbp-100h]
  __int64 v7; // [rsp+58h] [rbp-F0h]
  __int64 v8; // [rsp+60h] [rbp-E8h]
  __int64 v9; // [rsp+68h] [rbp-E0h]
  __int64 v10[3]; // [rsp+100h] [rbp-48h] BYREF
  __int64 v11; // [rsp+118h] [rbp-30h]
  __int64 v12; // [rsp+120h] [rbp-28h]
  __int64 v13; // [rsp+128h] [rbp-20h]
  __int64 v14; // [rsp+130h] [rbp-18h]
  _QWORD *v15; // [rsp+138h] [rbp-10h]

  v7 = (a1[1] - *a1) / 0xD0;
  if ( v7 )
    v8 = 2 * v7;
  else
    v8 = 1;
  if ( v8 )
    v6 = sub_1402AE320(a1 + 2, 0xD0 * v8, 8, 0);
  else
    v6 = 0;
  ((void (__fastcall *)(__int64 *, __int64, __int64, __int64))sub_143CB4FC0)(v10, *a1, a1[1], v6);
  v10[1] = v10[0];
  v4 = v10[0];
  v11 = sub_1402A53E0(0xD0, v10[0]);
  v10[2] = a2;
  sub_143CDAF10(v11, a2);
  v5 = v4 + 0xD0;
  v13 = a1[1];
  v12 = *a1;
  for ( i = v12; i != v13; i += 0xD0 )
    sub_142758050(i);
  v14 = (a1[2] - *a1) / 0xD0;
  v9 = *a1;
  if ( *a1 )
  {
    v15 = a1 + 2;
    sub_1402A6600((__int64)(a1 + 2), v9);
  }
  *a1 = v6;
  a1[1] = v5;
  result = 0xD0 * v8 + v6;
  a1[2] = result;
  return result;
}

// --- End Function: sub_143BF95B0 (0x143BF95B0) ---

// --- Function: sub_143C02080 (0x143C02080) ---
__int64 __fastcall sub_143C02080(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r8
  void (__fastcall *v5)(__int64, _QWORD *, __int64, _QWORD); // [rsp+30h] [rbp-28h]
  _QWORD v6[4]; // [rsp+38h] [rbp-20h] BYREF

  v5 = *(void (__fastcall **)(__int64, _QWORD *, __int64, _QWORD))(*(_QWORD *)a1 + 0x10LL);
  sub_143BDB2D0(v6, a2);
  LOBYTE(v3) = 1;
  v5(a1, v6, v3, a3);
  return sub_1402A5330(v6);
}

// --- End Function: sub_143C02080 (0x143C02080) ---

// --- Function: sub_143C87D60 (0x143C87D60) ---
__int64 __fastcall sub_143C87D60(__int64 a1, __int64 a2)
{
  _BYTE buf_[24]; // [rsp+20h] [rbp-28h] BYREF

  memset(buf_, 0, 1u);
  buf_[8] = buf_[0];
  buf_[0x10] = 0;
  buf_[0x11] = 0;
  buf_[0x12] = 0;
  return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)a1, a2);
}

// --- End Function: sub_143C87D60 (0x143C87D60) ---

// --- Function: sub_143C87FA0 (0x143C87FA0) ---
char __fastcall sub_143C87FA0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10)
{
  void *v10; // rsp
  __int64 v12; // [rsp+18h] [rbp-F8h]
  _BYTE v13[144]; // [rsp+30h] [rbp-E0h] BYREF
  _BYTE *v14; // [rsp+110h] [rbp+0h]
  _BYTE *__Val_0__; // [rsp+118h] [rbp+8h]
  __int64 n2; // [rsp+120h] [rbp+10h]

  n2 = 2;
  v10 = alloca(0xE0);
  v14 = v13;
  __Val_0__ = v13;
  sub_1430CE720((__int64)v13, a9, a10);
  LODWORD(v12) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0__, 2u, a5, v12, a7, a8);
}

// --- End Function: sub_143C87FA0 (0x143C87FA0) ---

// --- Function: sub_143C88BA0 (0x143C88BA0) ---
char __fastcall sub_143C88BA0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10)
{
  void *v10; // rsp
  __int64 v12; // [rsp+18h] [rbp-F8h]
  _BYTE v13[144]; // [rsp+30h] [rbp-E0h] BYREF
  _BYTE *v14; // [rsp+110h] [rbp+0h]
  _BYTE *__Val_0__; // [rsp+118h] [rbp+8h]
  __int64 n2; // [rsp+120h] [rbp+10h]

  n2 = 2;
  v10 = alloca(0xE0);
  v14 = v13;
  __Val_0__ = v13;
  sub_140357350((__int64)v13, a9, a10);
  LODWORD(v12) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0__, 2u, a5, v12, a7, a8);
}

// --- End Function: sub_143C88BA0 (0x143C88BA0) ---

// --- Function: sub_143C89640 (0x143C89640) ---
char __fastcall sub_143C89640(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14)
{
  void *v14; // rsp
  __int64 v16; // [rsp+18h] [rbp-2B8h]
  _BYTE v17[592]; // [rsp+30h] [rbp-2A0h] BYREF
  _BYTE *v18; // [rsp+2D0h] [rbp+0h]
  _BYTE *__Val_0__; // [rsp+2D8h] [rbp+8h]
  __int64 n6; // [rsp+2E0h] [rbp+10h]

  n6 = 6;
  v14 = alloca(0x2A0);
  v18 = v17;
  __Val_0__ = v17;
  sub_143C901F0((unsigned int)v17, a9, a10, a11, a12, a13, a14);
  LODWORD(v16) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0__, 6u, a5, v16, a7, a8);
}

// --- End Function: sub_143C89640 (0x143C89640) ---

// --- Function: sub_143C89AF0 (0x143C89AF0) ---
char __fastcall sub_143C89AF0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10,
        __int64 a11)
{
  void *v11; // rsp
  __int64 v13; // [rsp+18h] [rbp-168h]
  _BYTE v14[256]; // [rsp+30h] [rbp-150h] BYREF
  _BYTE *v15; // [rsp+180h] [rbp+0h]
  _BYTE *__Val_0__; // [rsp+188h] [rbp+8h]
  __int64 n3; // [rsp+190h] [rbp+10h]

  n3 = 3;
  v11 = alloca(0x150);
  v15 = v14;
  __Val_0__ = v14;
  sub_143C90770(v14, a9, a10, a11);
  LODWORD(v13) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0__, 3u, a5, v13, a7, a8);
}

// --- End Function: sub_143C89AF0 (0x143C89AF0) ---

// --- Function: sub_143C901F0 (0x143C901F0) ---
__int64 __fastcall sub_143C901F0(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, __int64 a7)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B77C0();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF930;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF4D0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403EBBC0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_143C98A70((int)a1 + 0x70, a3, a4, a5, a6, a7) + 1;
}

// --- End Function: sub_143C901F0 (0x143C901F0) ---

// --- Function: sub_143C90770 (0x143C90770) ---
__int64 __fastcall sub_143C90770(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B77C0();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF930;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF4D0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403EBBC0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9230;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F30;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_143C991F0(a1 + 0x70, a3, a4) + 1;
}

// --- End Function: sub_143C90770 (0x143C90770) ---

// --- Function: sub_143CAEEB0 (0x143CAEEB0) ---
__int64 __fastcall sub_143CAEEB0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax

  if ( a1[1] >= (unsigned __int64)a1[2] )
  {
    sub_143BF95B0(a1, a2);
  }
  else
  {
    v2 = sub_1402A53E0(0xD0, a1[1]);
    sub_143CDAF10(v2, a2);
    a1[1] += 0xD0;
  }
  return a1[1] - 0xD0;
}

// --- End Function: sub_143CAEEB0 (0x143CAEEB0) ---

// --- Function: sub_143CB2410 (0x143CB2410) ---
__int64 __fastcall sub_143CB2410(__int64 a1, __int64 *a2)
{
  __int64 v3; // [rsp+28h] [rbp-20h]

  v3 = *a2;
  if ( *(_QWORD *)(a1 + 8) == 1 )
    return (*(__int64 (__fastcall **)(__int64))a1)(v3);
  else
    return (*(__int64 (__fastcall **)(__int64, __int64))a1)(a1, v3);
}

// --- End Function: sub_143CB2410 (0x143CB2410) ---

// --- Function: sub_143CDAF10 (0x143CDAF10) ---
__int64 __fastcall sub_143CDAF10(__int64 a1, __int64 a2)
{
  sub_142877ED0(a1, a2);
  qmemcpy((void *)(a1 + 0x18), (const void *)(a2 + 0x18), 0xB0u);
  sub_1402A4D50(a1 + 0xC8);
  *(_QWORD *)(a1 + 0xC8) = *(_QWORD *)(a2 + 0xC8);
  return a1;
}

// --- End Function: sub_143CDAF10 (0x143CDAF10) ---

// --- Function: sub_143CDEF00 (0x143CDEF00) ---
__int64 __fastcall sub_143CDEF00(__int64 *a1)
{
  __int64 result; // rax

  result = (__int64)a1;
  if ( *a1 )
    return sub_1402A6600((__int64)(a1 + 2), *a1);
  return result;
}

// --- End Function: sub_143CDEF00 (0x143CDEF00) ---

// --- Function: sub_143CDEF80 (0x143CDEF80) ---
__int64 __fastcall sub_143CDEF80(__int64 *a1)
{
  __int64 result; // rax

  result = (__int64)a1;
  if ( *a1 )
    return sub_1402A6600((__int64)(a1 + 2), *a1);
  return result;
}

// --- End Function: sub_143CDEF80 (0x143CDEF80) ---

// --- Function: sub_143CE2CF0 (0x143CE2CF0) ---
__int64 __fastcall sub_143CE2CF0(__int64 *a1)
{
  __int64 i; // [rsp+20h] [rbp-28h]
  __int64 v3; // [rsp+30h] [rbp-18h]

  v3 = a1[1];
  for ( i = *a1; i != v3; i += 0xD0 )
    sub_142758050(i);
  return sub_143CDEF00(a1);
}

// --- End Function: sub_143CE2CF0 (0x143CE2CF0) ---

// --- Function: sub_143CE2F20 (0x143CE2F20) ---
__int64 __fastcall sub_143CE2F20(__int64 *a1)
{
  __int64 i; // [rsp+20h] [rbp-28h]
  __int64 v3; // [rsp+30h] [rbp-18h]

  v3 = a1[1];
  for ( i = *a1; i != v3; i += 0x88 )
    sub_143CE4510(i);
  return sub_143CDEF80(a1);
}

// --- End Function: sub_143CE2F20 (0x143CE2F20) ---

// --- Function: sub_143CE4510 (0x143CE4510) ---
__int64 __fastcall sub_143CE4510(__int64 a1)
{
  sub_1402A5330((_QWORD *)(a1 + 0x50));
  sub_143CE2AB0(a1 + 0x38);
  return sub_140375170((__int64 *)(a1 + 0x20));
}

// --- End Function: sub_143CE4510 (0x143CE4510) ---

// --- Function: sub_143CEAAD0 (0x143CEAAD0) ---
__int64 *__fastcall sub_143CEAAD0(__int64 *a1, __int64 *a2)
{
  if ( a1 != a2 )
  {
    sub_143D79CB0(a1);
    sub_1433AC230(a1, a2);
  }
  return a1;
}

// --- End Function: sub_143CEAAD0 (0x143CEAAD0) ---

// --- Function: sub_143CEEB20 (0x143CEEB20) ---
__int64 __fastcall sub_143CEEB20(__int64 a1, __int64 a2)
{
  sub_14037AE80((void **)a1, (void **)a2);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  qmemcpy((void *)(a1 + 0x10), (const void *)(a2 + 0x10), 0x18u);
  sub_1402B6E10(a1 + 0x28, a2 + 0x28);
  *(_QWORD *)(a1 + 0x68) = *(_QWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x70) = *(_DWORD *)(a2 + 0x70);
  std::shared_ptr<vraudio::MixerNode>::operator=((_QWORD *)(a1 + 0x78), (__int64 *)(a2 + 0x78));
  sub_1423CAE40(a1 + 0x88, a2 + 0x88);
  return a1;
}

// --- End Function: sub_143CEEB20 (0x143CEEB20) ---

// --- Function: sub_143CF0CD0 (0x143CF0CD0) ---
__int64 __fastcall sub_143CF0CD0(_QWORD **a1, __int64 a2)
{
  return **a1 + 0x88 * a2;
}

// --- End Function: sub_143CF0CD0 (0x143CF0CD0) ---

// --- Function: sub_143CF2360 (0x143CF2360) ---
_QWORD *__fastcall sub_143CF2360(_QWORD *a1)
{
  *a1 += 0x90LL;
  return a1;
}

// --- End Function: sub_143CF2360 (0x143CF2360) ---

// --- Function: sub_143CF23F0 (0x143CF23F0) ---
_QWORD *__fastcall sub_143CF23F0(_QWORD *a1, _QWORD *a2)
{
  *a2 = *a1;
  *a1 += 0x88LL;
  return a2;
}

// --- End Function: sub_143CF23F0 (0x143CF23F0) ---

// --- Function: sub_143CF9AB0 (0x143CF9AB0) ---
__int64 __fastcall sub_143CF9AB0(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v4; // rdx
  __int64 v5; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rax
  __int64 v8; // rax
  unsigned __int8 v10; // al
  int v11; // esi
  _QWORD *v12; // rdi
  int *ThreadLogContextSlot; // rbx
  unsigned __int8 v14; // al
  __int128 v15; // [rsp+50h] [rbp-19h] BYREF
  __int128 v16; // [rsp+60h] [rbp-9h] BYREF
  __int128 v17; // [rsp+70h] [rbp+7h] BYREF
  __int64 v18; // [rsp+80h] [rbp+17h] BYREF
  __int64 p_Src[4]; // [rsp+88h] [rbp+1Fh] BYREF
  __int64 v20; // [rsp+D0h] [rbp+67h] BYREF
  __int64 v21; // [rsp+D8h] [rbp+6Fh] BYREF
  __int64 v22; // [rsp+E0h] [rbp+77h] BYREF
  char v23; // [rsp+E8h] [rbp+7Fh] BYREF

  v2 = *a2;
  v4 = *a1;
  v21 = v2;
  sub_1435EC3C0(&v18, v4 + 0x38);
  v5 = unknown_libname_485((__int64)&v18);
  sub_1402E5B20(v5, &v20, &v21);
  v6 = (_QWORD *)unknown_libname_485((__int64)&v18);
  v7 = std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
         v6,
         &v22);
  if ( std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(&v20, v7) )
  {
    sub_1402B3F20(p_Src);
    v10 = sub_14056F960(0x3A);
    HIDWORD(v20) = 0x4D;
    LODWORD(v20) = v10 + 0xC8;
    unknown_libname_477(&v15, (__int64)&v20, (__int64)&v21);
    v16 = v15;
    v11 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)&v16,
            (__int64)"InventoryCallback",
            "Callback canceled for Request[$$]");
    if ( (v11 & 0xFFFFF) != 0 )
    {
      v12 = sub_14035E580(&v18, *a2, 0);
      ThreadLogContextSlot = getThreadLogContextSlot();
      sub_1402B3D20(&v15);
      v14 = sub_14056F960(0x3A);
      HIDWORD(v20) = 0x4D;
      LODWORD(v20) = v14 + 0xC8;
      unknown_libname_477(&v16, (__int64)&v20, (__int64)&v21);
      v17 = v16;
      sub_143C88D50(
        5,
        (unsigned int)&v17,
        (unsigned int)"InventoryCallback",
        (unsigned int)"Callback canceled for Request[$$]",
        1,
        v11,
        (__int64)&v15,
        0,
        (__int64)ThreadLogContextSlot,
        (__int64)v12);
    }
    return 2;
  }
  else
  {
    v8 = unknown_libname_485((__int64)&v18);
    sub_1402E5790(v8, &v23, v20);
    sub_1402B3F20(p_Src);
    return 0;
  }
}

// --- End Function: sub_143CF9AB0 (0x143CF9AB0) ---

// --- Function: sub_143D17B00 (0x143D17B00) ---
__int64 __fastcall sub_143D17B00(__int64 a1, __int64 a2, unsigned int a3)
{
  if ( *(_QWORD *)(a1 + 8) == 1 )
    return (*(__int64 (__fastcall **)(__int64, _QWORD))a1)(a2, a3);
  else
    return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))a1)(a1, a2, a3);
}

// --- End Function: sub_143D17B00 (0x143D17B00) ---

// --- Function: sub_143D28B80 (0x143D28B80) ---
__int64 __fastcall sub_143D28B80(__int64 a1, __crt_win32_buffer_debug_info *a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rbx
  __int64 i; // rdi
  __int64 v10; // rax
  __int64 *v11; // rbx
  __int64 j; // rdi
  __int64 v13; // r8
  __int64 v14; // rax
  __int64 v16[3]; // [rsp+20h] [rbp-288h] BYREF
  _QWORD v17[3]; // [rsp+38h] [rbp-270h] BYREF
  __int64 v18; // [rsp+50h] [rbp-258h] BYREF
  __int64 n0x1FF; // [rsp+58h] [rbp-250h]
  _BYTE *v20; // [rsp+60h] [rbp-248h]
  _BYTE v21[520]; // [rsp+68h] [rbp-240h] BYREF

  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x200LL))(v6);
  unknown_libname_474(v16);
  v8 = sub_1402A4EC0((__int64)a2);
  for ( i = __crt_win32_buffer_debug_info::file_name(a2); v8 != i; v8 += 8 )
    sub_14035CCE0(v16, v8);
  unknown_libname_474(v17);
  v10 = unknown_libname_476(v16);
  sub_140508340(v17, v10);
  v11 = (__int64 *)sub_1402A4EC0((__int64)v16);
  for ( j = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)v16); v11 != (__int64 *)j; ++v11 )
  {
    v13 = *v11;
    v20 = v21;
    v21[0] = 0;
    v18 = 0;
    n0x1FF = 0x1FF;
    v14 = sub_1402A59F0((__int64)&v18, "inventory/entity/%llu", v13);
    sub_1405077E0(v17, v14);
    if ( v20 != v21 )
    {
      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147715880(v20);
    }
  }
  (*(void (__fastcall **)(__int64, __int64, _QWORD *, __int64))(*(_QWORD *)v7 + 0x10LL))(v7, a1, v17, a3);
  sub_140467E30(v17);
  return std::vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____::_vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____(v16);
}

// --- End Function: sub_143D28B80 (0x143D28B80) ---

// --- Function: sub_143D29870 (0x143D29870) ---
__int64 __fastcall sub_143D29870(__int64 a1, __int64 a2, __crt_win32_buffer_debug_info *a3, __int64 a4)
{
  __int64 v8; // rbp
  __int64 *v9; // rbx
  __int64 i; // rdi
  __int64 *v11; // rax
  _QWORD *v12; // rax
  _QWORD v14[3]; // [rsp+20h] [rbp-98h] BYREF
  _QWORD v15[3]; // [rsp+38h] [rbp-80h] BYREF
  _QWORD v16[2]; // [rsp+50h] [rbp-68h] BYREF
  _QWORD v17[3]; // [rsp+60h] [rbp-58h] BYREF
  _QWORD v18[8]; // [rsp+78h] [rbp-40h] BYREF
  __int64 v19; // [rsp+C0h] [rbp+8h] BYREF
  __int64 v20; // [rsp+D0h] [rbp+18h] BYREF

  v8 = sub_143D82640();
  unknown_libname_474(v14);
  v9 = (__int64 *)sub_1402A4EC0((__int64)a3);
  for ( i = __crt_win32_buffer_debug_info::file_name(a3); v9 != (__int64 *)i; v9 += 3 )
  {
    v20 = *v9;
    sub_1402A8EB0(v14, &v20);
  }
  sub_14035E090(&v19);
  sub_1403ACC80((void **)&v19, "%s ID[%llu]", "CInventoryContainerManager::AsyncOpenInventoryContainer", v8);
  v16[0] = a1;
  v16[1] = v8;
  v11 = (__int64 *)sub_1402A4D50(a2);
  sub_1402FD1B0(v17, v11);
  v12 = (_QWORD *)unknown_libname_491(a4);
  sub_143348980(v18, v12);
  sub_143BDBF30((__int64)v15, (__int64)v16);
  sub_143D28B80(v19, (__crt_win32_buffer_debug_info *)v14, (__int64)v15);
  sub_1402A5330(v15);
  sub_140373CC0(&v19);
  sub_1402B4EC0(v14);
  return v8;
}

// --- End Function: sub_143D29870 (0x143D29870) ---

// --- Function: sub_143D79CB0 (0x143D79CB0) ---
__int64 __fastcall sub_143D79CB0(__int64 *a1)
{
  __int64 v2[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_143E6B950(a1);
  sub_14334AB20(v2, (__int64)a1);
  sub_1433AC230(a1, v2);
  return sub_143CE2CF0(v2);
}

// --- End Function: sub_143D79CB0 (0x143D79CB0) ---

// --- Function: sub_143D7D770 (0x143D7D770) ---
__int64 __fastcall sub_143D7D770(__int64 a1, _QWORD *a2)
{
  char buf_; // [rsp+20h] [rbp-D8h] BYREF
  _BYTE v4[15]; // [rsp+21h] [rbp-D7h] BYREF
  int v6; // [rsp+34h] [rbp-C4h]
  int v7; // [rsp+38h] [rbp-C0h]
  __int64 v8; // [rsp+40h] [rbp-B8h]
  __int64 v9; // [rsp+48h] [rbp-B0h]
  __int64 v10; // [rsp+50h] [rbp-A8h]
  __int64 v11; // [rsp+58h] [rbp-A0h]
  __int64 *v12; // [rsp+60h] [rbp-98h]
  __int64 *v13; // [rsp+68h] [rbp-90h]
  __int64 v14; // [rsp+70h] [rbp-88h] BYREF
  __int64 v15; // [rsp+78h] [rbp-80h]
  __int64 v16; // [rsp+80h] [rbp-78h]
  __int64 v17; // [rsp+88h] [rbp-70h]
  __int64 v18; // [rsp+90h] [rbp-68h]
  __int64 v19; // [rsp+98h] [rbp-60h] BYREF
  __int64 v20[3]; // [rsp+A0h] [rbp-58h] BYREF
  __int64 v21[3]; // [rsp+B8h] [rbp-40h] BYREF
  __int64 v22[5]; // [rsp+D0h] [rbp-28h] BYREF

  sub_142C065D0(v21);
  sub_1402B0A70(&v14, (__int64)"CDeferredCallbackQueue<unsigned __int64>::ExecuteCallbacks", a1, 1u);
  v11 = a1 + 0x18;
  sub_14334AB20(v22, (__int64)v21);
  sub_143CEAAD0(v21, (__int64 *)(a1 + 0x18));
  sub_143CEAAD0((__int64 *)(a1 + 0x18), v22);
  sub_143CE2CF0(v22);
  sub_1402B3ED0(&v14);
  sub_142C065D0(v20);
  v12 = v21;
  v9 = v21[0];
  v15 = v21[1];
  while ( v9 != v15 )
  {
    v8 = v9;
    sub_1403719C0(v4, v9 + 0x18);
    if ( *a2 != 0 )
      v6 = sub_143C87D60((__int64)a2, v8 + 0xC8);
    else
      v6 = 0;
    v7 = v6;
    if ( v6 )
    {
      if ( v7 == 1 )
        sub_143CAEEB0(v20, v8);
    }
    else
    {
      memset(&buf_, 0, sizeof(buf_));
      v4[7] = buf_;
      sub_143CB2410(v8, (__int64 *)(v8 + 0xC8));
    }
    sub_140379B70(v4);
    v9 += 0xD0;
  }
  if ( !sub_142C64FF0(v20) )
  {
    sub_1402B0A70(&v19, (__int64)"CDeferredCallbackQueue<unsigned __int64>::ExecuteCallbacks", a1, 1u);
    v13 = v20;
    v10 = v20[0];
    v16 = v20[1];
    while ( v10 != v16 )
    {
      v17 = v10;
      v18 = a1 + 0x18;
      sub_143CAEEB0((__int64 *)(a1 + 0x18), v10);
      v10 += 0xD0;
    }
    sub_1402B3ED0(&v19);
  }
  sub_143CE2CF0(v20);
  return sub_143CE2CF0(v21);
}

// --- End Function: sub_143D7D770 (0x143D7D770) ---

// --- Function: sub_143D82640 (0x143D82640) ---
__int64 __fastcall sub_143D82640(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rbx
  _BYTE v6[16]; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v7[8]; // [rsp+30h] [rbp-28h] BYREF
  __int64 p_Src[4]; // [rsp+38h] [rbp-20h] BYREF
  __int64 v9; // [rsp+60h] [rbp+8h] BYREF

  sub_1435EC3C0(v7, a1 + 0x38);
  v2 = *(_QWORD *)(a1 + 0x60);
  v9 = v2;
  *(_QWORD *)(a1 + 0x60) = v2 + 1;
  if ( v2 == 0xFFFFFFFFFFFFFFFFuLL )
  {
    v9 = v2 + 1;
    *(_QWORD *)(a1 + 0x60) = v2 + 2;
  }
  v3 = unknown_libname_485((__int64)v7);
  sub_1402AFF00(v3, v6, &v9);
  v4 = v9;
  sub_1402B3F20(p_Src);
  return v4;
}

// --- End Function: sub_143D82640 (0x143D82640) ---

// --- Function: sub_143D83060 (0x143D83060) ---
unsigned __int64 *__fastcall sub_143D83060(unsigned __int64 *a1)
{
  __int64 *v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // rax
  __int64 v9; // rbx
  unsigned __int64 v10; // rax
  __int64 v11; // rbx
  bool v12; // al
  __int64 v13; // rdi
  bool v14; // r14
  __int64 (__fastcall *v15)(__int64, _QWORD); // rbx
  __int64 v16; // rax
  __int64 *v17; // rbx
  double *v18; // rax
  double v19; // xmm2_8
  double v20; // xmm1_8
  double v21; // xmm0_8
  __int64 v22; // rax
  __m256 *v23; // rax
  __int64 v24; // rdi
  __int64 v25; // rax
  __int128 v26; // kr00_16
  void (__fastcall *v27)(__int64, _BYTE *, _QWORD *, _QWORD); // rbx
  __int64 v29; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int64 v30; // [rsp+38h] [rbp-C8h] BYREF
  int v31[2]; // [rsp+40h] [rbp-C0h] BYREF
  double v32; // [rsp+48h] [rbp-B8h] BYREF
  __int128 v33; // [rsp+50h] [rbp-B0h] BYREF
  double v34; // [rsp+60h] [rbp-A0h]
  __m256 src__1; // [rsp+68h] [rbp-98h]
  __int64 v36; // [rsp+90h] [rbp-70h]
  __int64 *v37[2]; // [rsp+98h] [rbp-68h] BYREF
  _QWORD v38[3]; // [rsp+A8h] [rbp-58h] BYREF
  __m256 src_; // [rsp+C0h] [rbp-40h] BYREF
  __int128 v40; // [rsp+E0h] [rbp-20h]
  _BYTE v41[32]; // [rsp+F0h] [rbp-10h] BYREF
  _DWORD v42[12]; // [rsp+110h] [rbp+10h] BYREF
  _BYTE v43[2]; // [rsp+140h] [rbp+40h] BYREF
  char v44; // [rsp+142h] [rbp+42h]
  __m256 v45; // [rsp+1B0h] [rbp+B0h]
  _BYTE v46[144]; // [rsp+410h] [rbp+310h] BYREF

  *a1 = 0;
  sub_1465E63C0(qword_149FBE618, &v32);
  v2 = sub_1426FAA90(v31);
  v3 = sub_140505F80(v2);
  if ( v3 )
  {
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x6F0LL))(v3);
    if ( v4 )
    {
      sub_1403B43F0((unsigned __int64 *)(v4 + 8), &v30);
      v29 = 0;
      v5 = sub_1412B19F0(&v32);
      v6 = sub_1403EAAF0(v5);
      if ( v6 )
      {
        v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x600LL))(v6);
        if ( v7 )
        {
          sub_143BE00C0((__int64)&v33, (__int64)&v29);
          sub_143C02080(v7, (__int64)&v33, 0x77u);
          sub_142758060(&v33);
        }
      }
      if ( v29 )
        *a1 = *(_QWORD *)sub_146202A40(v29, v31);
    }
  }
  v8 = *a1;
  if ( !*a1 )
    goto LABEL_19;
  v9 = v8 & 0xFFFFFFFFFFFFLL;
  v10 = HIWORD(v8);
  v11 = (v10 & 0xF000) != 0 ? v9 & 0xFFFFFF000000LL : v9 - 6;
  if ( *(_WORD *)(v11 + 2) != (v10 & 0xFFF) )
    goto LABEL_19;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v12 = is_thread_privileged_or_bypass_mode()) )
    v12 = 1;
  if ( (*(_WORD *)(v11 + 4) != 2 || !v12) && !sub_140395410(a1) )
  {
LABEL_19:
    v30 = 0;
    v13 = qword_149C8DF28;
    v14 = dword_149B4632C > 1;
    v15 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL);
    v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x3D0LL))(qword_149C8DFE0);
    v17 = (__int64 *)v15(v13, *(unsigned int *)(v16 + 0xA8));
    if ( v17 )
    {
      v18 = (double *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x3D0LL))(qword_149C8DFE0);
      v19 = v18[0xB];
      v20 = v18[7];
      v21 = v18[3];
      v22 = *v17;
      *(double *)&v33 = v21;
      *((double *)&v33 + 1) = v20;
      v34 = v19;
      (*(void (__fastcall **)(__int64 *, int *))(v22 + 0x10))(v17, v31);
      sub_140372710((__int64)v43, 0x7832, *(__int64 *)v31, 0x40, "GetClosestMineableToCamera");
      v23 = (__m256 *)sub_14035EBC0((__int64)v41, (__int64)&v33, 1500.0);
      v43[0] |= 0x10u;
      v45 = *v23;
      __asm { vzeroupper }
      (*(void (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149C8DF38 + 0x28LL))(
        qword_149C8DF38,
        &v29,
        "Engine.Components.EntityComponentMineable");
      unknown_libname_477(v37, (__int64)&v29, (__int64)&v30);
      sub_140363FD0((__int64)v42, v37);
      v44 |= 1u;
      sub_14037CB50((__int64)v46, (__int64)v42);
      sub_140375A50(v42);
      v24 = qword_149C8DFC0;
      v32 = 9.99999999999e11;
      *(_OWORD *)&src__1.m256_f32[4] = v33;
      v25 = *(_QWORD *)qword_149C8DFC0;
      LOBYTE(v36) = v14;
      *((_QWORD *)&v26 + 1) = v36;
      *(double *)&v26 = v34;
      v27 = *(void (__fastcall **)(__int64, _BYTE *, _QWORD *, _QWORD))(v25 + 0x1C0);
      *(_QWORD *)src__1.m256_f32 = &v32;
      *(_QWORD *)&src__1.m256_f32[2] = &v30;
      src_ = src__1;
      v40 = v26;
      __asm { vzeroupper }
      sub_143BDEFD0((__int64)v38, &src_);
      v27(v24, v43, v38, 0);
      sub_1402A5330(v38);
      sub_14037A590((__int64)v43);
    }
    *a1 = v30;
  }
  return a1;
}

// --- End Function: sub_143D83060 (0x143D83060) ---

// --- Function: sub_143DE5AB0 (0x143DE5AB0) ---
_UNKNOWN **__fastcall sub_143DE5AB0(__int64 a1)
{
  _UNKNOWN **result; // rax
  __int64 v2; // r15
  _QWORD *v3; // rbx
  _QWORD *v4; // rax
  char v7; // bl
  unsigned __int64 v8; // rsi
  unsigned __int8 v9; // al
  int v10; // r14d
  __int64 v11; // rax
  _QWORD *v12; // rdi
  int *ThreadLogContextSlot; // rbx
  unsigned __int8 v14; // al
  _QWORD *v15; // rax
  __int64 v16; // rdi
  __int64 (__fastcall *v17)(__int64, _BYTE *, _QWORD); // rbx
  _QWORD *v18; // rax
  _QWORD *v19; // rax
  _QWORD *v20; // rdi
  __int64 v21; // rcx
  __int64 v22; // rbx
  bool v23; // al
  unsigned __int64 v24; // r13
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  unsigned __int8 v29; // al
  __int64 v30; // rax
  _QWORD *v31; // r12
  __int64 v32; // rax
  __int64 v33; // rax
  _QWORD *v34; // r15
  __int64 v35; // rax
  _QWORD *v36; // r14
  __int64 v37; // rax
  _QWORD *v38; // rsi
  __int64 v39; // rax
  _QWORD *v40; // rdi
  int *ThreadLogContextSlot_2; // rbx
  unsigned __int8 v42; // al
  __int64 v43; // rax
  unsigned __int8 v44; // al
  int v45; // r14d
  __int64 v46; // rax
  _QWORD *v47; // rsi
  __int64 v48; // rax
  _QWORD *v49; // rdi
  int *ThreadLogContextSlot_1; // rbx
  unsigned __int8 v51; // al
  __int64 v52; // rax
  __int64 v53; // rbx
  __int64 v54; // rax
  Parameter *Parameter; // rdx
  unsigned __int8 v56; // al
  int v57; // r14d
  __int64 v58; // rdi
  int *ThreadLogContextSlot_3; // rbx
  unsigned __int8 v60; // al
  __int64 v61; // rdi
  __int64 v62; // rbx
  __int64 *v63; // rax
  _QWORD *v64; // rax
  _QWORD *v65; // rax
  __int64 v66; // rbx
  __int64 v67; // rax
  _QWORD *v68; // rax
  __int64 v69; // rax
  __int64 v70; // rbx
  __int64 v71; // rax
  _QWORD *v72; // rax
  _DWORD v73[2]; // [rsp+78h] [rbp-90h] BYREF
  _DWORD v74[2]; // [rsp+80h] [rbp-88h] BYREF
  _DWORD v75[2]; // [rsp+88h] [rbp-80h] BYREF
  _DWORD v76[2]; // [rsp+90h] [rbp-78h] BYREF
  unsigned __int64 v77; // [rsp+98h] [rbp-70h] BYREF
  _DWORD v78[2]; // [rsp+A0h] [rbp-68h] BYREF
  _DWORD v79[2]; // [rsp+A8h] [rbp-60h] BYREF
  char *dst; // [rsp+B0h] [rbp-58h] BYREF
  _QWORD *v81[4]; // [rsp+B8h] [rbp-50h] BYREF
  unsigned __int64 v82[3]; // [rsp+D8h] [rbp-30h] BYREF
  __int64 v83[3]; // [rsp+F0h] [rbp-18h] BYREF
  __int128 Parameter__2; // [rsp+108h] [rbp+0h] BYREF
  __int128 Parameter__3; // [rsp+118h] [rbp+10h] BYREF
  __int64 v86; // [rsp+128h] [rbp+20h] BYREF
  _BYTE Parameter__1[8]; // [rsp+130h] [rbp+28h] BYREF
  __int128 Parameter__4; // [rsp+138h] [rbp+30h] BYREF
  __int128 v89; // [rsp+148h] [rbp+40h] BYREF
  _QWORD v90[3]; // [rsp+158h] [rbp+50h] BYREF
  _QWORD v91[3]; // [rsp+170h] [rbp+68h] BYREF
  _BYTE v92[8]; // [rsp+188h] [rbp+80h] BYREF
  __int64 v93; // [rsp+190h] [rbp+88h] BYREF
  char v94; // [rsp+198h] [rbp+90h] BYREF
  __int64 v95; // [rsp+1A0h] [rbp+98h] BYREF
  __int64 v96; // [rsp+1A8h] [rbp+A0h] BYREF
  __int64 v97; // [rsp+1B0h] [rbp+A8h] BYREF
  __int128 v98; // [rsp+1B8h] [rbp+B0h] BYREF
  __int128 v99; // [rsp+1C8h] [rbp+C0h] BYREF
  __int128 v100; // [rsp+1D8h] [rbp+D0h] BYREF
  __int128 v101; // [rsp+1E8h] [rbp+E0h] BYREF
  _QWORD v102[2]; // [rsp+1F8h] [rbp+F0h] BYREF
  __int128 v103; // [rsp+208h] [rbp+100h] BYREF
  __int128 v104; // [rsp+218h] [rbp+110h] BYREF
  __int128 v105; // [rsp+228h] [rbp+120h] BYREF
  __int128 v106; // [rsp+238h] [rbp+130h] BYREF
  _QWORD v107[2]; // [rsp+248h] [rbp+140h] BYREF
  __int128 v108; // [rsp+258h] [rbp+150h] BYREF
  _QWORD v109[2]; // [rsp+268h] [rbp+160h] BYREF
  __int128 v110; // [rsp+278h] [rbp+170h] BYREF
  __int128 v111; // [rsp+288h] [rbp+180h] BYREF
  __int64 v112[3]; // [rsp+298h] [rbp+190h] BYREF
  __int64 v113; // [rsp+2B0h] [rbp+1A8h] BYREF
  __int64 v114; // [rsp+2C0h] [rbp+1B8h] BYREF
  __int64 v115; // [rsp+2D0h] [rbp+1C8h] BYREF
  _QWORD v116[3]; // [rsp+2E0h] [rbp+1D8h] BYREF
  _UNKNOWN *retaddr; // [rsp+340h] [rbp+238h] BYREF
  int v119; // [rsp+350h] [rbp+248h] BYREF
  int n0x4D; // [rsp+354h] [rbp+24Ch]
  __int64 Parameter_; // [rsp+358h] [rbp+250h] BYREF
  __int64 v122; // [rsp+360h] [rbp+258h] BYREF

  result = &retaddr;
  v2 = a1;
  if ( *(_QWORD *)(a1 + 0xD0) == 0xFFFFFFFFFFFFFFFFuLL )
  {
    sub_142D16460(a1 + 0xA0, (__int64)v81);
    if ( sub_14372C530((__int64)v81) )
      goto LABEL_5;
    v3 = (_QWORD *)(sub_143CF0CD0(v81, 0) + 0x68);
    v4 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
                     qword_149C8DF80,
                     &v119);
    sub_14059CA60(v3, &Parameter_, v4);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    if ( COERCE_FLOAT(_XMM1 & 0x7FFFFFFF) < 2.0 )
LABEL_5:
      v7 = 0;
    else
      v7 = 1;
    result = (_UNKNOWN **)sub_142C8CD00((__int64)v81);
    if ( v7 )
    {
      initialize_and_acquire_context_lock(v2 + 0xA0, (__int64)v81);
      sub_142C06B30(v112);
      v8 = 0;
      v77 = 0;
      v9 = sub_14056F960(0x3A);
      n0x4D = 0x4D;
      v119 = v9 + 0xC8;
      unknown_libname_477(&Parameter__3, (__int64)&v119, (__int64)&Parameter_);
      Parameter__2 = Parameter__3;
      v10 = invokeGlobalCallbackAndMaskStatusBits(
              5,
              (__int64)&Parameter__2,
              (__int64)"Process Pending Opens",
              "Pending opens remaining: $$");
      if ( (v10 & 0xFFFFF) != 0 )
      {
        v11 = sub_143E856B0(v81);
        v12 = sub_14035E580(&v89, v11, 0);
        ThreadLogContextSlot = getThreadLogContextSlot();
        sub_1402B3D20(&Parameter__2);
        v14 = sub_14056F960(0x3A);
        n0x4D = 0x4D;
        v119 = v14 + 0xC8;
        unknown_libname_477(&Parameter__3, (__int64)&v119, (__int64)&Parameter_);
        Parameter__4 = Parameter__3;
        sub_143C88BA0(
          5,
          (__int64)&Parameter__4,
          "Process Pending Opens",
          (__int64)"Pending opens remaining: $$",
          1,
          v10,
          &Parameter__2,
          0,
          (__int64)ThreadLogContextSlot,
          v12);
      }
      unknown_libname_474(v83);
      unknown_libname_474(v82);
      sub_142D12B10(v81, (Parameter *)&Parameter_);
      v15 = sub_142D159A0((__int64)v81, (Parameter *)Parameter__1);
      if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
              &Parameter_,
              v15) )
      {
        while ( 1 )
        {
          v16 = qword_149C8DFC0;
          v17 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL);
          v18 = (_QWORD *)unknown_libname_485((__int64)&Parameter_);
          v19 = (_QWORD *)v17(v16, v92, *v18);
          v20 = v19;
          if ( !*v19 )
            break;
          v21 = HIWORD(*v19);
          v22 = (v21 & 0xF000) != 0 ? *v19 & 0xFFFFFF000000LL : (*v19 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v22 + 2) != (v21 & 0xFFF) )
            break;
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v23 = is_thread_privileged_or_bypass_mode()) )
            v23 = 1;
          if ( (*(_WORD *)(v22 + 4) != 2 || !v23) && !sub_140395410(v20) )
            break;
          if ( *(_DWORD *)(unknown_libname_485((__int64)&Parameter_) + 0x80) >= *(_DWORD *)(n29 + 0xC4C) )
          {
            v44 = sub_14056F960(0x3A);
            v75[1] = 0x4D;
            v75[0] = v44 + 0xC8;
            unknown_libname_477(&v99, (__int64)v75, (__int64)v76);
            v100 = v99;
            v45 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)&v100,
                    (__int64)"Process Pending Opens",
                    "Request [$$] Open Failed for inventory $$ due to passing maximum number of retries");
            if ( (v45 & 0xFFFFF) != 0 )
            {
              v46 = unknown_libname_485((__int64)&Parameter_);
              v47 = sub_14035F320(v90, v46, 0);
              v48 = unknown_libname_485((__int64)&Parameter_);
              v49 = sub_14035E580(v91, *(_QWORD *)(v48 + 0x18), 0);
              ThreadLogContextSlot_1 = getThreadLogContextSlot();
              sub_1402B3D20(v102);
              v51 = sub_14056F960(0x3A);
              v76[1] = 0x4D;
              v76[0] = v51 + 0xC8;
              unknown_libname_477(&v101, (__int64)v76, (__int64)&v77);
              v103 = v101;
              sub_143C89AF0(
                3,
                (__int64)&v103,
                "Process Pending Opens",
                (__int64)"Request [$$] Open Failed for inventory $$ due to passing maximum number of retries",
                1,
                v45,
                v102,
                0,
                (__int64)ThreadLogContextSlot_1,
                (__int64)v49,
                (__int64)v47);
              sub_140373F20((__int64)v90);
              v8 = v77;
            }
            v52 = unknown_libname_485((__int64)&Parameter_);
            if ( __crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid((_QWORD *)(v52 + 0x50)) )
            {
              v53 = unknown_libname_485((__int64)&Parameter_);
              v54 = unknown_libname_485((__int64)&Parameter_);
              sub_143D17B00(v53 + 0x50, *(_QWORD *)(v54 + 0x18), 1u);
            }
            Parameter = (__int128 *)&v94;
LABEL_47:
            Parameter_ = *(_QWORD *)sub_143E6C050(v81, Parameter, Parameter_);
            goto LABEL_48;
          }
          v24 = *(_QWORD *)(unknown_libname_485((__int64)&Parameter_) + 0x78);
          *(_QWORD *)(unknown_libname_485((__int64)&Parameter_) + 0x70) = v24;
          v25 = unknown_libname_485((__int64)&Parameter_);
          if ( v24 < sub_1403EEEB0((_QWORD *)(v25 + 0x20)) )
          {
            do
            {
              if ( v8 >= *(int *)(n29 + 0xC40) )
                break;
              v26 = unknown_libname_485((__int64)&Parameter_);
              v27 = sub_143600F40((_QWORD *)(v26 + 0x20), v24);
              sub_1403EC890(v83, v27);
              ++v8;
              ++v24;
              v28 = unknown_libname_485((__int64)&Parameter_);
            }
            while ( v24 < sub_1403EEEB0((_QWORD *)(v28 + 0x20)) );
            v77 = v8;
          }
          v29 = sub_14056F960(0x3A);
          v73[1] = 0x4D;
          v73[0] = v29 + 0xC8;
          unknown_libname_477(&v111, (__int64)v73, (__int64)v74);
          v110 = v111;
          v119 = invokeGlobalCallbackAndMaskStatusBits(
                   5,
                   (__int64)&v110,
                   (__int64)"Process Pending Opens",
                   "Request [$$] Attempting to unstow indices: $$ to $$ out of $$ from inventory $$");
          if ( (v119 & 0xFFFFF) != 0 )
          {
            v30 = unknown_libname_485((__int64)&Parameter_);
            v31 = sub_14035F320(v90, v30, 0);
            v32 = unknown_libname_485((__int64)&Parameter_);
            v33 = sub_1403EEEB0((_QWORD *)(v32 + 0x20));
            v34 = sub_14035E580(&v113, v33, 0);
            v35 = unknown_libname_485((__int64)&Parameter_);
            v36 = sub_14035E580(&v114, *(_QWORD *)(v35 + 0x78) - 1LL, 0);
            v37 = unknown_libname_485((__int64)&Parameter_);
            v38 = sub_14035E580(&v115, *(_QWORD *)(v37 + 0x70), 0);
            v39 = unknown_libname_485((__int64)&Parameter_);
            v40 = sub_14035E580(v116, *(_QWORD *)(v39 + 0x18), 0);
            ThreadLogContextSlot_2 = getThreadLogContextSlot();
            sub_1402B3D20(v109);
            v42 = sub_14056F960(0x3A);
            v74[1] = 0x4D;
            v74[0] = v42 + 0xC8;
            unknown_libname_477(&v108, (__int64)v74, (__int64)v75);
            v98 = v108;
            sub_143C89640(
              5,
              (__int64)&v98,
              "Process Pending Opens",
              (__int64)"Request [$$] Attempting to unstow indices: $$ to $$ out of $$ from inventory $$",
              1,
              v119,
              v109,
              0,
              (__int64)ThreadLogContextSlot_2,
              (__int64)v40,
              (__int64)v38,
              (__int64)v36,
              (__int64)v34,
              (__int64)v31);
            sub_140373F20((__int64)v90);
            v8 = v77;
          }
          v43 = unknown_libname_485((__int64)&Parameter_);
          sub_140BF8F00(v82, v43);
          *(_QWORD *)(unknown_libname_485((__int64)&Parameter_) + 0x78) = v24;
          if ( v8 >= *(int *)(n29 + 0xC40) )
          {
LABEL_49:
            v2 = a1;
            goto LABEL_50;
          }
          sub_143CF23F0(&Parameter_, &v93);
LABEL_48:
          v72 = sub_142D159A0((__int64)v81, (Parameter *)Parameter__1);
          if ( std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                 &Parameter_,
                 v72) )
          {
            goto LABEL_49;
          }
        }
        v56 = sub_14056F960(0x3A);
        v78[1] = 0x4D;
        v78[0] = v56 + 0xC8;
        unknown_libname_477(&v104, (__int64)v78, (__int64)v79);
        v105 = v104;
        v57 = invokeGlobalCallbackAndMaskStatusBits(
                3,
                (__int64)&v105,
                (__int64)"Process Pending Opens",
                "Pending opens for inventory[$$] failed due to inventory not being spawned");
        if ( (v57 & 0xFFFFF) != 0 )
        {
          v58 = unknown_libname_485((__int64)&Parameter_);
          ThreadLogContextSlot_3 = getThreadLogContextSlot();
          sub_1402B3D20(v107);
          v60 = sub_14056F960(0x3A);
          v79[1] = 0x4D;
          v79[0] = v60 + 0xC8;
          unknown_libname_477(&v106, (__int64)v79, (__int64)&dst);
          v89 = v106;
          sub_143C87FA0(
            3,
            (__int64)&v89,
            "Process Pending Opens",
            (__int64)"Pending opens for inventory[$$] failed due to inventory not being spawned",
            1,
            v57,
            v107,
            0,
            (__int64)ThreadLogContextSlot_3,
            v58);
        }
        v61 = unknown_libname_485((__int64)&Parameter_);
        v62 = *sub_1402E55F0((__int64)v82, &v95);
        v63 = std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
                v82,
                &v96);
        sub_140BA3C90((__int64 *)&dst, *v63, v62, v61);
        v64 = sub_1402E55F0((__int64)v82, &v97);
        if ( !std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(&dst, v64) )
        {
          std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
            v83,
            &v122);
          v65 = sub_1402E55F0((__int64)v83, &v86);
          if ( !std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(&v122, v65) )
          {
            do
            {
              v66 = sub_1402A4EC0((__int64)&v122);
              v67 = unknown_libname_485((__int64)&Parameter_);
              if ( sub_1405B53B0(v66 + 0x10, v67) )
                v122 = *(_QWORD *)sub_143E6C760(v83, &Parameter__4, v122);
              else
                sub_143CF2360(&v122);
              v68 = sub_1402E55F0((__int64)v83, &v86);
            }
            while ( !std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(&v122, v68) );
          }
          sub_14330D300(v82, (Parameter *)&Parameter__2, dst);
        }
        v69 = unknown_libname_485((__int64)&Parameter_);
        if ( __crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid((_QWORD *)(v69 + 0x50)) )
        {
          v70 = unknown_libname_485((__int64)&Parameter_);
          v71 = unknown_libname_485((__int64)&Parameter_);
          sub_143D17B00(v70 + 0x50, *(_QWORD *)(v71 + 0x18), 1u);
        }
        Parameter = &Parameter__3;
        goto LABEL_47;
      }
LABEL_50:
      sub_143BE0830(v91, v2);
      *(_QWORD *)(v2 + 0xD0) = sub_143D29870(v2, (__int64)v83, (__crt_win32_buffer_debug_info *)v82, (__int64)v91);
      sub_1402A5330(v91);
      sub_140466E20(v82);
      sub_140375170(v83);
      sub_143CE2F20(v112);
      return (_UNKNOWN **)sub_142C8CD20((__int64)v81);
    }
  }
  return result;
}

// --- End Function: sub_143DE5AB0 (0x143DE5AB0) ---

// --- Function: sub_143E171D0 (0x143E171D0) ---
__int64 __fastcall sub_143E171D0(__int64 a1, char a2)
{
  __int64 result; // rax

  result = a1;
  *(_BYTE *)(a1 + 0x908) = a2;
  return result;
}

// --- End Function: sub_143E171D0 (0x143E171D0) ---

// --- Function: sub_143E381B0 (0x143E381B0) ---
__int64 __fastcall sub_143E381B0(__int64 a1, float a2)
{
  __int128 v2; // xmm6
  __int64 v5; // r12
  _QWORD *v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rdi
  void (__fastcall *v9)(__int64, __int64 *, _QWORD); // rbx
  _QWORD *v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rdi
  bool v13; // al
  __int64 v14; // rax
  unsigned int v15; // eax
  __int64 v16; // rax
  __int64 v17; // r15
  _QWORD *v18; // rax
  __int64 v19; // rax
  _QWORD *v20; // rsi
  unsigned int v21; // r14d
  __int64 v22; // rdi
  __int64 v23; // rbx
  __int64 v24; // rax
  float v25; // kr00_4
  float v26; // xmm1_4
  _QWORD *v27; // rax
  _QWORD *v28; // rax
  _BYTE Parameter__3[8]; // [rsp+30h] [rbp-D0h] BYREF
  _BYTE Parameter__1[8]; // [rsp+38h] [rbp-C8h] BYREF
  int n0x6200; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v33; // [rsp+44h] [rbp-BCh]
  int v34; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v35; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v36; // [rsp+58h] [rbp-A8h]
  __int64 v37; // [rsp+60h] [rbp-A0h]
  __int64 v38; // [rsp+68h] [rbp-98h]
  __int64 p_Src[2]; // [rsp+90h] [rbp-70h] BYREF
  _BYTE v40[64]; // [rsp+A0h] [rbp-60h] BYREF
  __int128 v41; // [rsp+E0h] [rbp-20h]
  __int64 v42; // [rsp+130h] [rbp+30h] BYREF
  _QWORD *Parameter_; // [rsp+140h] [rbp+40h] BYREF
  _QWORD *Parameter__2; // [rsp+148h] [rbp+48h] BYREF

  v41 = v2;
  v34 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  n0x6200 = 0x6200;
  v33 = 1;
  v35 = __rdtsc();
  qword_149C89AA0(
    &n0x6200,
    &word_149F73FB0,
    "CAudioEnvironmentFeedbackManager::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Audio/AudioEnvironmentFeedbackManager.cpp",
    0x98);
  HIWORD(n0x6200) = word_149F73FB0;
  sub_1402B0B20(
    (__int64)p_Src,
    (__int64)"CAudioEnvironmentFeedbackManager::Update",
    a1 + 8,
    1,
    1u,
    (__int64)"m_zoneLock");
  v5 = a1 + 0x38;
  sub_143BA38B0(a1 + 0x38, (Parameter *)&Parameter_);
  v6 = sub_142D15A10(a1 + 0x38, (Parameter *)Parameter__1);
  if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
          &Parameter_,
          v6) )
  {
    do
    {
      v7 = sub_142C90E40(&Parameter_);
      if ( !*(_BYTE *)(v7 + 0x98) )
      {
        v8 = qword_149C8DFC0;
        v9 = *(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL);
        v10 = (_QWORD *)sub_142C90E40(&Parameter_);
        v9(v8, &v42, *v10);
        v11 = v42;
        if ( v42 )
        {
          v12 = (v42 & 0xF000000000000000uLL) != 0 ? v42 & 0xFFFFFF000000LL : (v42 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v12 + 2) == (HIWORD(v42) & 0xFFF) )
          {
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v13 = is_thread_privileged_or_bypass_mode(), v11 = v42, v13) )
              v13 = 1;
            if ( *(_WORD *)(v12 + 4) == 2 && v13 )
              goto LABEL_15;
            if ( sub_140395410(&v42) )
            {
              v11 = v42;
LABEL_15:
              v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v11 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v11 & 0xFFFFFFFFFFFFLL);
              if ( v14 )
                v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x1F8LL))(v14);
              else
                v15 = 0xFFFFFFFF;
              *(_DWORD *)(v7 + 8) = v15;
              v16 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)(v42 & 0xFFFFFFFFFFFFLL) + 0x1E8LL))(
                      v42 & 0xFFFFFFFFFFFFLL,
                      v40,
                      2);
              v17 = v7 + 0x50;
              *(_QWORD *)(v7 + 0x10) = *(_QWORD *)v16;
              *(_QWORD *)(v7 + 0x18) = *(_QWORD *)(v16 + 8);
              *(_QWORD *)(v7 + 0x20) = *(_QWORD *)(v16 + 0x10);
              *(_QWORD *)(v7 + 0x28) = *(_QWORD *)(v16 + 0x18);
              *(_OWORD *)(v7 + 0x30) = *(_OWORD *)(v16 + 0x20);
              *(double *)(v7 + 0x40) = *(double *)(v16 + 0x30);
              *(_QWORD *)(v7 + 0x48) = *(_QWORD *)(v16 + 0x38);
              sub_143BA38B0(v7 + 0x50, (Parameter *)&Parameter__2);
              v18 = sub_142D15A10(v7 + 0x50, (Parameter *)Parameter__3);
              if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                      &Parameter__2,
                      v18) )
              {
                do
                {
                  v19 = sub_142C90E40(&Parameter__2);
                  v20 = (_QWORD *)(v19 + 8);
                  if ( *(_BYTE *)(v19 + 0x58) )
                  {
                    v21 = 0;
                    if ( sub_142999720((_QWORD *)(v19 + 8)) )
                    {
                      v22 = 0;
                      do
                      {
                        v23 = sub_142C0DB50(v20, v22);
                        if ( !*(_BYTE *)(v23 + 4) )
                        {
                          v24 = sub_14046F550(v20[9] + 8LL, v22);
                          v25 = a2 + *(float *)v23;
                          *(float *)v23 = v25;
                          v26 = *(float *)(v24 + 0x14C);
                          if ( *(_BYTE *)(v23 + 5) )
                          {
                            if ( v25 > v26 )
                              *(float *)v23 = v25 - v26;
                          }
                          else if ( v25 > v26 )
                          {
                            *(_BYTE *)(v23 + 4) = 1;
                          }
                        }
                        v22 = ++v21;
                      }
                      while ( v21 < (unsigned __int64)sub_142999720(v20) );
                    }
                  }
                  sub_142F2BE10(&Parameter__2);
                  v27 = sub_142D15A10(v17, (Parameter *)Parameter__3);
                }
                while ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                           &Parameter__2,
                           v27) );
              }
              goto LABEL_30;
            }
          }
        }
        *(_BYTE *)(v7 + 0x98) = 1;
      }
LABEL_30:
      sub_142F2BE10(&Parameter_);
      v28 = sub_142D15A10(v5, (Parameter *)Parameter__1);
    }
    while ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
               &Parameter_,
               v28) );
  }
  sub_1402B3F20(p_Src);
  v36 = __rdtsc();
  return qword_149C89AA8(&n0x6200);
}

// --- End Function: sub_143E381B0 (0x143E381B0) ---

// --- Function: sub_143E3CCC0 (0x143E3CCC0) ---
__int64 __fastcall sub_143E3CCC0(__int64 a1)
{
  _QWORD *v2; // rax
  __int64 v4; // [rsp+30h] [rbp-68h] BYREF
  int n0x2900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v6; // [rsp+44h] [rbp-54h]
  int v7; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v8; // [rsp+50h] [rbp-48h]
  unsigned __int64 v9; // [rsp+58h] [rbp-40h]
  __int64 v10; // [rsp+60h] [rbp-38h]
  __int64 v11; // [rsp+68h] [rbp-30h]
  __int64 v12; // [rsp+A0h] [rbp+8h] BYREF
  _QWORD *v13; // [rsp+A8h] [rbp+10h] BYREF

  n0x2900 = 0x2900;
  v6 = 1;
  v7 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v8 = __rdtsc();
  qword_149C89AA0(
    &n0x2900,
    &word_149F7516C,
    "CInventoryContainerManager::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\GameInventory/InventoryContainerManager.cpp",
    0xE74);
  HIWORD(n0x2900) = word_149F7516C;
  v12 = a1;
  v2 = sub_143BDD3A0(&v4, (__int64)&v12, &v13);
  sub_143D7D770(a1 + 8, v2);
  *v13 = 0xFFFFFFFFFFFFFFFFuLL;
  sub_143DE5AB0(a1);
  v9 = __rdtsc();
  return qword_149C89AA8(&n0x2900);
}

// --- End Function: sub_143E3CCC0 (0x143E3CCC0) ---

// --- Function: sub_143E41760 (0x143E41760) ---
void sub_143E41760()
{
  __int64 *v2; // rax
  __int64 v3; // rax
  __int64 *v4; // rax
  __int64 v5; // rax
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF
  __int64 v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !BYTE1(qword_149C8E516) && dword_149B4632C > 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, &v6, 0);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm2, xmm0, xmm0 }
    *(float *)&dword_149B4B558 = *(float *)&dword_149B4B558 - *(float *)&_XMM2;
    if ( *(float *)&dword_149B4B558 < 0.0 )
    {
      *(float *)&dword_149B4B558 = 1.0;
      sub_143D83060((unsigned __int64 *)&v6);
      if ( dword_149B4632C > 0
        && (is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v6) && v6 != qword_149F74F20
         || !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v6)) )
      {
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&qword_149F74F20) )
        {
          v2 = sub_142B13C60(qword_149F74F20 & 0xFFFFFFFFFFFFLL, &v7);
          v3 = sub_1427D2E60(v2);
          if ( v3 )
            sub_143E171D0(v3, 0);
          qword_149F74F20 = 0;
        }
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v6) )
        {
          v4 = sub_142B13C60(v6 & 0xFFFFFFFFFFFFLL, &v7);
          v5 = sub_1427D2E60(v4);
          if ( v5 )
            sub_143E171D0(v5, 1);
          qword_149F74F20 = v6;
        }
      }
    }
  }
}

// --- End Function: sub_143E41760 (0x143E41760) ---

// --- Function: sub_143E68B00 (0x143E68B00) ---
__int64 *__fastcall sub_143E68B00(__int64 **a1, __int64 *a2)
{
  sub_143456070(*a1, a2);
  return a2;
}

// --- End Function: sub_143E68B00 (0x143E68B00) ---

// --- Function: sub_143E6BD90 (0x143E6BD90) ---
_BOOL8 __fastcall sub_143E6BD90(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 0x20LL) == 0;
}

// --- End Function: sub_143E6BD90 (0x143E6BD90) ---

// --- Function: sub_143E6C050 (0x143E6C050) ---
__int64 __fastcall sub_143E6C050(_QWORD *a1, __int64 a2, __int64 a3)
{
  sub_143E6D250(*a1, a2, a3);
  return a2;
}

// --- End Function: sub_143E6C050 (0x143E6C050) ---

// --- Function: sub_143E6C760 (0x143E6C760) ---
Parameter *__fastcall sub_143E6C760(__int64 a1, Parameter *Parameter, __int64 a3)
{
  __int64 i; // [rsp+20h] [rbp-48h]
  _QWORD *v5; // [rsp+28h] [rbp-40h]
  __int64 v6; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+50h] [rbp-18h]

  v5 = (_QWORD *)(a1 + 8);
  v6 = a3;
  v8 = *(_QWORD *)(a1 + 8);
  for ( i = a3 + 0x90; i != v8; i += 0x90 )
  {
    sub_143CEEB20(v6, i);
    v6 += 0x90;
  }
  sub_140378880((_QWORD *)(*v5 - 0x90LL));
  *v5 -= 0x90LL;
  *(_QWORD *)Parameter = a3;
  _StarEngineModule__((ULONG_PTR)Parameter);
  return Parameter;
}

// --- End Function: sub_143E6C760 (0x143E6C760) ---

// --- Function: sub_143E6D250 (0x143E6D250) ---
_QWORD *__fastcall sub_143E6D250(__int64 a1, Parameter *Parameter_1, __int64 a3)
{
  __int64 i; // [rsp+20h] [rbp-48h]
  _QWORD *v5; // [rsp+28h] [rbp-40h]
  __int64 v6; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+50h] [rbp-18h]

  v5 = (_QWORD *)(a1 + 8);
  v6 = a3;
  v8 = *(_QWORD *)(a1 + 8);
  for ( i = a3 + 0x88; i != v8; i += 0x88 )
  {
    sub_143CEAD30(v6, i);
    v6 += 0x88;
  }
  sub_143CE4510(*v5 - 0x88LL);
  *v5 -= 0x88LL;
  *Parameter_1 = a3;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_143E6D250 (0x143E6D250) ---

// --- Function: sub_143E856B0 (0x143E856B0) ---
__int64 __fastcall sub_143E856B0(__int64 a1)
{
  return (*(_QWORD *)(*(_QWORD *)a1 + 8LL) - **(_QWORD **)a1) / 0x88LL;
}

// --- End Function: sub_143E856B0 (0x143E856B0) ---

// --- Function: sub_143E85E20 (0x143E85E20) ---
__int64 __fastcall sub_143E85E20(__int64 a1, __int64 a2)
{
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = a1 + 0x28;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_DWORD *)(a2 + 0x18) = 0;
  sub_142CE0550(a2);
  return a2;
}

// --- End Function: sub_143E85E20 (0x143E85E20) ---

// --- Function: sub_143E98D80 (0x143E98D80) ---
__int64 __fastcall sub_143E98D80(__int64 a1, __int64 a2)
{
  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 0x10) )
    return sub_143E99EB0(a1, *(_QWORD *)(a1 + 8), a2);
  else
    return sub_142EFA210(a1, a2);
}

// --- End Function: sub_143E98D80 (0x143E98D80) ---

// --- Function: sub_143E9B620 (0x143E9B620) ---
__int64 __fastcall sub_143E9B620(__int64 a1, __int64 a2)
{
  _BYTE v4[16]; // [rsp+40h] [rbp-28h] BYREF
  __int64 v5; // [rsp+50h] [rbp-18h]

  sub_143E9B920(a1, v4, a2);
  if ( !*(_BYTE *)(v5 + 0x19) && !(unsigned __int8)sub_143EC94B0(a2, v5 + 0x20) )
    return v5;
  else
    return *(_QWORD *)a1;
}

// --- End Function: sub_143E9B620 (0x143E9B620) ---

// --- Function: sub_143E9FA30 (0x143E9FA30) ---
__int64 __fastcall sub_143E9FA30(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n2; // rax
  __int64 i; // [rsp+20h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-20h] BYREF
  __int64 v7; // [rsp+30h] [rbp-18h]

  while ( 1 )
  {
    if ( (a2 - a1) >> 4 <= 0x20 )
      return sub_143E9CCF0(a1, a2, a4);
    if ( a3 <= 0 )
      break;
    sub_143E9D8A0(&v6, a1, a2, a4);
    a3 = (a3 >> 2) + (a3 >> 1);
    if ( (v6 - a1) >> 4 >= (a2 - v7) >> 4 )
    {
      sub_143E9FA30(v7, a2, a3, a4);
      a2 = v6;
    }
    else
    {
      sub_143E9FA30(a1, v6, a3, a4);
      a1 = v7;
    }
  }
  sub_143E9D070(a1, a2, a4);
  for ( i = a2; ; i -= 0x10 )
  {
    n2 = (i - a1) >> 4;
    if ( n2 < 2 )
      break;
    sub_143E9E490(a1, i, a4);
  }
  return n2;
}

// --- End Function: sub_143E9FA30 (0x143E9FA30) ---

// --- Function: sub_143EB80E0 (0x143EB80E0) ---
__int64 *__fastcall sub_143EB80E0(__int64 a1, Parameter *Parameter_1, ULONG_PTR a3)
{
  ULONG_PTR Parameter[4]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v5; // [rsp+40h] [rbp-18h]
  __int64 v6; // [rsp+48h] [rbp-10h]
  ULONG_PTR v9; // [rsp+70h] [rbp+18h] BYREF

  v9 = a3;
  v6 = a1;
  Parameter[2] = AK::MemoryMgr::StopProfileThreadUsage((struct _exception *)&v9);
  Parameter[1] = v9;
  Parameter[0] = v9;
  _StarEngineModule__((ULONG_PTR)Parameter);
  Parameter[3] = Parameter[0];
  v5 = sub_143F6C8F0(a1, Parameter[0]);
  *Parameter_1 = v5;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_143EB80E0 (0x143EB80E0) ---

// --- Function: sub_143EB9BE0 (0x143EB9BE0) ---
__int64 __fastcall sub_143EB9BE0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+28h] [rbp-40h]
  __int64 i; // [rsp+38h] [rbp-30h]

  v4 = a1;
  for ( i = (a2 - a1) / 0x58; i > 0; --i )
  {
    sub_143EC8F80(a3, v4);
    v4 += 0x58;
    a3 += 0x58;
  }
  return a3;
}

// --- End Function: sub_143EB9BE0 (0x143EB9BE0) ---

// --- Function: sub_143EBA670 (0x143EBA670) ---
__int64 __fastcall sub_143EBA670(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v6; // [rsp+20h] [rbp-118h]
  __int64 v8; // [rsp+38h] [rbp-100h]
  _QWORD v11[2]; // [rsp+70h] [rbp-C8h] BYREF
  _BYTE v12[88]; // [rsp+80h] [rbp-B8h] BYREF
  _BYTE v13[96]; // [rsp+D8h] [rbp-60h] BYREF
  __int64 v14; // [rsp+150h] [rbp+18h] BYREF

  v14 = a3;
  v11[0] = a3;
  while ( a1 != a2 )
  {
    v3 = sub_143EC4C50(v12, a1);
    if ( (unsigned __int8)sub_143ECA1A0(v11, v3) )
      break;
    a1 += 0x58;
  }
  v6 = a1;
  v8 = a1;
  if ( a1 != a2 )
  {
    while ( 1 )
    {
      v6 += 0x58;
      if ( v6 == a2 )
        break;
      v11[1] = v13;
      v4 = sub_143EC4C50(v13, v6);
      if ( !(unsigned __int8)sub_143ECA1A0(&v14, v4) )
      {
        sub_143EC8F80(v8, v6);
        v8 += 0x58;
      }
    }
  }
  return v8;
}

// --- End Function: sub_143EBA670 (0x143EBA670) ---

// --- Function: sub_143EBAA00 (0x143EBAA00) ---
__int64 __fastcall sub_143EBAA00(__int64 a1, __int64 a2)
{
  unsigned __int8 v3; // [rsp+21h] [rbp-27h]

  return sub_143E9FA30(a1, a2, (a2 - a1) >> 4, v3);
}

// --- End Function: sub_143EBAA00 (0x143EBAA00) ---

// --- Function: sub_143EC4C50 (0x143EC4C50) ---
__int64 __fastcall sub_143EC4C50(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  if ( *(_QWORD *)(a2 + 8) )
    InterlockedIncrement_w_1(*(_QWORD *)(a2 + 8));
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  qmemcpy((void *)(a1 + 0x10), (const void *)(a2 + 0x10), 0x18u);
  qmemcpy((void *)(a1 + 0x28), (const void *)(a2 + 0x28), 0x1Cu);
  *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(a2 + 0x48);
  *(_BYTE *)(a1 + 0x50) = *(_BYTE *)(a2 + 0x50);
  return a1;
}

// --- End Function: sub_143EC4C50 (0x143EC4C50) ---

// --- Function: sub_143EC6850 (0x143EC6850) ---
__int64 __fastcall sub_143EC6850(__int64 a1)
{
  return sub_143F70540(a1);
}

// --- End Function: sub_143EC6850 (0x143EC6850) ---

// --- Function: sub_143EC8F80 (0x143EC8F80) ---
__int64 __fastcall sub_143EC8F80(__int64 a1, __int64 a2)
{
  sub_14275A910((_QWORD *)a1, (__int64 *)a2);
  qmemcpy((void *)(a1 + 0x10), (const void *)(a2 + 0x10), 0x18u);
  qmemcpy((void *)(a1 + 0x28), (const void *)(a2 + 0x28), 0x1Cu);
  *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(a2 + 0x48);
  *(_BYTE *)(a1 + 0x50) = *(_BYTE *)(a2 + 0x50);
  return a1;
}

// --- End Function: sub_143EC8F80 (0x143EC8F80) ---

// --- Function: sub_143ECA1A0 (0x143ECA1A0) ---
_BOOL8 __fastcall sub_143ECA1A0(int *a1, __int64 a2)
{
  bool v2; // bl

  v2 = *a1 - *(_QWORD *)(a2 + 0x48) > (unsigned __int64)a1[1];
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)a2);
  return v2;
}

// --- End Function: sub_143ECA1A0 (0x143ECA1A0) ---

// --- Function: sub_143ED1BB0 (0x143ED1BB0) ---
__int64 __fastcall sub_143ED1BB0(__int64 a1, __int64 a2, double *a3, __int64 a4, double *a5)
{
  __int64 v8; // rdi
  void (__fastcall *v9)(__int64, double *, double *, __int64, char); // rbx
  __int64 v10; // rax
  __int128 v11; // kr00_16
  __int64 v15; // r8
  double v17; // xmm3_8
  double v18; // xmm4_8
  __int128 v19; // kr00_16
  char v23; // [rsp+20h] [rbp-48h]
  double v24; // [rsp+30h] [rbp-38h] BYREF
  double v25; // [rsp+38h] [rbp-30h]
  double v26; // [rsp+40h] [rbp-28h]
  __int64 v27; // [rsp+78h] [rbp+10h] BYREF

  v27 = a2;
  if ( *a5 == 0.0 && a5[1] == 0.0 && a5[2] == 0.0 )
  {
    v8 = qword_149C8E0C8;
    v9 = *(void (__fastcall **)(__int64, double *, double *, __int64, char))(*(_QWORD *)qword_149C8E0C8 + 0x5B8LL);
    v10 = sub_140335A10(&v27);
    v23 = 0;
    v9(v8, &v24, a3, v10, v23);
    *((_QWORD *)&v11 + 1) = 0;
    *(double *)&v11 = (v24 - *a3) * (v24 - *a3) + (v25 - a3[1]) * (v25 - a3[1]) + (v26 - a3[2]) * (v26 - a3[2]);
    _XMM2 = v11;
    __asm
    {
      vsqrtsd xmm0, xmm2, xmm2
      vcvtsd2ss xmm2, xmm0, xmm0
    }
    return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a4 + 0x30LL))(
             a4,
             *(unsigned int *)(a1 + 0x48),
             v15,
             0);
  }
  else
  {
    v17 = a5[1] - a3[1];
    v18 = a5[2] - a3[2];
    *((_QWORD *)&v19 + 1) = 0;
    *(double *)&v19 = (*a5 - *a3) * (*a5 - *a3) + v17 * v17 + v18 * v18;
    _XMM2 = v19;
    __asm
    {
      vsqrtsd xmm0, xmm2, xmm2
      vcvtsd2ss xmm2, xmm0, xmm0
    }
    return (*(__int64 (__fastcall **)(__int64, _QWORD, double *, _QWORD))(*(_QWORD *)a4 + 0x30LL))(
             a4,
             *(unsigned int *)(a1 + 0x48),
             a3,
             0);
  }
}

// --- End Function: sub_143ED1BB0 (0x143ED1BB0) ---

// --- Function: sub_143F170C0 (0x143F170C0) ---
void __fastcall sub_143F170C0(_DWORD *a1, __int64 a2, __int64 *a3, char a4)
{
  unsigned int v6; // esi
  unsigned int v8; // ebx
  void (__fastcall *v9)(__int64 *, _QWORD, __int64, _QWORD); // rbx
  __int64 v10; // rax
  __int64 v11; // r8
  void (__fastcall *v12)(__int64 *, _QWORD, __int64, _QWORD); // rbx
  __int64 v13; // rax
  __int64 v14; // r8
  void (__fastcall *v15)(__int64 *, _QWORD, __int64, _QWORD); // rbx
  __int64 v16; // rax
  __int64 v17; // r8
  void (__fastcall *v18)(__int64 *, _QWORD, __int64, _QWORD); // rbx
  __int64 v19; // rax
  __int64 v20; // r8
  void (__fastcall *v21)(__int64 *, _QWORD, __int64, _QWORD); // rbx
  __int64 v22; // rax
  __int64 v23; // r8
  void (__fastcall *v24)(__int64 *, _QWORD, __int64, _QWORD); // rbx
  __int64 v25; // r8
  __int128 v27; // xmm1
  __int64 v28; // rax
  __m256 v29; // [rsp+20h] [rbp-48h] BYREF
  __int128 v30; // [rsp+40h] [rbp-28h]
  __int64 v31; // [rsp+50h] [rbp-18h]

  if ( a3 )
  {
    v6 = 0;
    v8 = 0;
    if ( a4 )
    {
      switch ( a4 )
      {
        case 1:
          v6 = a1[6];
          v8 = a1[7];
          break;
        case 2:
          v6 = a1[8];
          v8 = a1[9];
          break;
        case 3:
          v6 = a1[0xA];
          v8 = a1[0xB];
          break;
      }
    }
    else
    {
      v6 = a1[4];
      v8 = a1[5];
    }
    (*(void (__fastcall **)(__int64 *, _QWORD))(*a3 + 0x138))(a3, v6);
    (*(void (__fastcall **)(__int64 *, _QWORD))(*a3 + 0x138))(a3, v8);
    v9 = *(void (__fastcall **)(__int64 *, _QWORD, __int64, _QWORD))(*a3 + 0x30);
    v10 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x28LL))(v10);
    v9(a3, (unsigned int)a1[0xC], v11, 0);
    v12 = *(void (__fastcall **)(__int64 *, _QWORD, __int64, _QWORD))(*a3 + 0x30);
    v13 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 8LL))(v13);
    v12(a3, (unsigned int)a1[0xD], v14, 0);
    v15 = *(void (__fastcall **)(__int64 *, _QWORD, __int64, _QWORD))(*a3 + 0x30);
    v16 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x10LL))(v16);
    v15(a3, (unsigned int)a1[0xE], v17, 0);
    v18 = *(void (__fastcall **)(__int64 *, _QWORD, __int64, _QWORD))(*a3 + 0x30);
    v19 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x20LL))(v19);
    v18(a3, (unsigned int)a1[0xF], v20, 0);
    v21 = *(void (__fastcall **)(__int64 *, _QWORD, __int64, _QWORD))(*a3 + 0x30);
    v22 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x18LL))(v22);
    v21(a3, (unsigned int)a1[0x10], v23, 0);
    v24 = *(void (__fastcall **)(__int64 *, _QWORD, __int64, _QWORD))(*a3 + 0x30);
    std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    v24(a3, (unsigned int)a1[0x11], v25, 0);
    __asm { vmovupd ymm0, cs:ymmword_1482BB440 }
    v27 = *(_OWORD *)(a2 + 0x10);
    __asm { vmovupd [rsp+68h+var_48], ymm0 }
    v30 = v27;
    v28 = *a3;
    v31 = *(_QWORD *)(a2 + 0x20);
    __asm { vzeroupper }
    (*(void (__fastcall **)(__int64 *, __m256 *))(v28 + 0x70))(a3, &v29);
    (*(void (__fastcall **)(__int64 *, _QWORD))(*a3 + 8))(a3, v6);
  }
}

// --- End Function: sub_143F170C0 (0x143F170C0) ---

// --- Function: sub_143F17290 (0x143F17290) ---
__int64 sub_143F17290(_DWORD *a1, __int64 a2, __int64 a3, ...)
{
  unsigned int v6; // r14d
  void (__fastcall *v7)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v8; // rax
  __int64 v9; // r8
  void (__fastcall *v10)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v11; // rax
  __int64 v12; // r8
  void (__fastcall *v13)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v14; // rax
  __int64 v15; // r8
  void (__fastcall *v16)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v17; // rax
  __int64 v18; // r8
  void (__fastcall *v19)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v20; // rax
  __int64 v21; // r8
  void (__fastcall *v22)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v23; // r8
  __int128 v25; // xmm1
  __int64 v26; // rax
  __m256 v28; // [rsp+30h] [rbp-58h] BYREF
  __int128 v29; // [rsp+50h] [rbp-38h]
  __int64 v30; // [rsp+60h] [rbp-28h]
  __int64 v31; // [rsp+A8h] [rbp+20h] BYREF
  va_list va; // [rsp+A8h] [rbp+20h]
  va_list va1; // [rsp+B0h] [rbp+28h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v31 = va_arg(va1, _QWORD);
  if ( *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2) + 0x78) )
    v6 = a1[3];
  else
    v6 = a1[2];
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a3 + 0x138LL))(a3, v6);
  v7 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
  v8 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x28LL))(v8);
  v7(a3, (unsigned int)a1[0xC], v9, 0);
  v10 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
  v11 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
  v10(a3, (unsigned int)a1[0xD], v12, 0);
  v13 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
  v14 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x10LL))(v14);
  v13(a3, (unsigned int)a1[0xE], v15, 0);
  v16 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
  v17 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x20LL))(v17);
  v16(a3, (unsigned int)a1[0xF], v18, 0);
  v19 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
  v20 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x18LL))(v20);
  v19(a3, (unsigned int)a1[0x10], v21, 0);
  v22 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
  std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
  v22(a3, (unsigned int)a1[0x11], v23, 0);
  if ( is_valid_handle_typeA((__int64 *)va) )
    sub_143ED1BB0((__int64)a1, v31, (double *)(a2 + 0x10), a3, (double *)(a2 + 0x28));
  __asm { vmovupd ymm0, cs:ymmword_1482BB440 }
  v25 = *(_OWORD *)(a2 + 0x10);
  v26 = *(_QWORD *)a3;
  __asm { vmovupd [rsp+88h+var_58], ymm0 }
  v30 = *(_QWORD *)(a2 + 0x20);
  v29 = v25;
  __asm { vzeroupper }
  (*(void (__fastcall **)(__int64, __m256 *))(v26 + 0x70))(a3, &v28);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a3 + 8LL))(a3, v6);
}

// --- End Function: sub_143F17290 (0x143F17290) ---

// --- Function: sub_143F447E0 (0x143F447E0) ---
__int64 __fastcall sub_143F447E0(__int64 a1, __int64 a2)
{
  unsigned int *v4; // rax
  __int64 v5; // r8
  unsigned int *v6; // rbx
  __int64 p_Src[3]; // [rsp+30h] [rbp-18h] BYREF
  __int64 v9; // [rsp+50h] [rbp+8h] BYREF

  v9 = *(_QWORD *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2) + 8);
  sub_1402B0B20(
    (__int64)p_Src,
    (__int64)"CAudioOneShotManager::EraseFromTriggerMap",
    (__int64)&unk_149B4C2A8,
    1,
    1u,
    (__int64)"s_triggerMapLock");
  sub_143F74B10(&unk_149F75DD0, &v9);
  sub_1402B3F20(p_Src);
  v4 = (unsigned int *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
  v6 = v4;
  if ( *(_QWORD *)v4 )
  {
    LOBYTE(v5) = 1;
    (*(void (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)v4 + 0x10LL))(*(_QWORD *)v4, v4[4], v5);
    if ( *(_QWORD *)v6 )
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)v6 + 0x50LL))(*(_QWORD *)v6);
      *(_QWORD *)v6 = 0;
    }
  }
  *((_QWORD *)v6 + 1) = 0;
  *((_BYTE *)v6 + 0x24) = 0;
  v6[0xA] = 0;
  sub_143F75A30(a1 + 0x18, a2);
  return sub_142758BD0(a2);
}

// --- End Function: sub_143F447E0 (0x143F447E0) ---

// --- Function: sub_143F54190 (0x143F54190) ---
__int64 __fastcall sub_143F54190(__int64 a1, float a2)
{
  __int128 v2; // xmm6
  __int64 v4; // rcx
  __int64 v5; // r15
  _QWORD *v6; // rax
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rbx
  __int64 *v10; // rax
  char v11; // r14
  float v12; // xmm7_4
  _QWORD *v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // rax
  float *v16; // rax
  float v17; // kr00_4
  bool v18; // cc
  _QWORD *v19; // rax
  _QWORD *v20; // rax
  _BYTE Parameter__1[16]; // [rsp+30h] [rbp-D0h] BYREF
  int n0x6200; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v24; // [rsp+44h] [rbp-BCh]
  int v25; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v26; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v27; // [rsp+58h] [rbp-A8h]
  __int64 v28; // [rsp+60h] [rbp-A0h]
  __int64 v29; // [rsp+68h] [rbp-98h]
  _BYTE Parameter__2[8]; // [rsp+90h] [rbp-70h] BYREF
  _BYTE Parameter__3[8]; // [rsp+98h] [rbp-68h] BYREF
  _BYTE Parameter__6[8]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 p_Src[2]; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE v34[16]; // [rsp+B8h] [rbp-48h] BYREF
  _QWORD v35[3]; // [rsp+C8h] [rbp-38h] BYREF
  __int128 v36; // [rsp+100h] [rbp+0h]
  _QWORD *Parameter__4; // [rsp+150h] [rbp+50h] BYREF
  _QWORD *Parameter_; // [rsp+160h] [rbp+60h] BYREF
  char Parameter__5; // [rsp+168h] [rbp+68h] BYREF

  v36 = v2;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  n0x6200 = 0x6200;
  v24 = 1;
  v26 = __rdtsc();
  qword_149C89AA0(
    &n0x6200,
    &word_149F763F0,
    "CAudioOneShotManager::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Audio/AudioOneShotManager.cpp",
    0xF7);
  v4 = *(_QWORD *)(a1 + 0x10);
  HIWORD(n0x6200) = word_149F763F0;
  sub_1403CE280(v4);
  sub_1402B0AA0((__int64)v34, (__int64)"CAudioOneShotManager::Update", a1 + 0x18, 1, 1u, (__int64)"m_contextLock");
  v5 = a1 + 0x38;
  sub_143BA38B0(a1 + 0x38, (Parameter *)&Parameter_);
  v6 = sub_142D15A10(a1 + 0x38, (Parameter *)Parameter__1);
  if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
          &Parameter_,
          v6) )
  {
    do
    {
      v7 = sub_142C90E40(&Parameter_);
      v8 = v7 + 8;
      sub_1402B0B20(
        (__int64)p_Src,
        (__int64)"CAudioOneShotManager::Update",
        v7 + 0x38,
        1,
        1u,
        (__int64)"pool.m_poolLock");
      if ( !*(_BYTE *)(v8 + 0x50) )
      {
        v9 = *sub_1427D2930(v8, (Parameter *)Parameter__2);
        v10 = sub_1427D28D0((_QWORD *)v8, (Parameter *)Parameter__3);
        sub_143EBAA00(*v10, v9);
        *(_BYTE *)(v8 + 0x50) = 1;
      }
      v11 = 0;
      v12 = 3.4028235e38;
      sub_1427D28D0((_QWORD *)v8, (Parameter *)&Parameter__4);
      v13 = sub_1427D2930(v8, (Parameter *)&Parameter__5);
      if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
              &Parameter__4,
              v13) )
      {
        do
        {
          v14 = (_QWORD *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>((__int64)&Parameter__4);
          if ( *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>((__int64)v14) + 0x24) )
          {
            v15 = sub_1427520B0(v35, v14);
            sub_143F447E0(v8, (__int64)v15);
            Parameter__4 = (_QWORD *)*sub_14330D650(v8, (Parameter *)Parameter__6, Parameter__4);
          }
          else
          {
            v16 = (float *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>((__int64)v14);
            v17 = a2 + v16[6];
            v18 = v17 <= v16[5];
            v16[6] = v17;
            if ( !v18 )
              v16[7] = (float)(a2 * v16[8]) + v16[7];
            if ( v12 < *(float *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>((__int64)v14)
                                + 0x1C) )
              v11 = 1;
            v12 = *(float *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>((__int64)v14) + 0x1C);
            sub_142C0DD60(&Parameter__4);
          }
          v19 = sub_1427D2930(v8, (Parameter *)&Parameter__5);
        }
        while ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                   &Parameter__4,
                   v19) );
      }
      *(_BYTE *)(v8 + 0x50) = v11 == 0;
      sub_1402B3F20(p_Src);
      sub_142F2BE10(&Parameter_);
      v20 = sub_142D15A10(v5, (Parameter *)Parameter__1);
    }
    while ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
               &Parameter_,
               v20) );
  }
  sub_1402B3F10((__int64)v34);
  v27 = __rdtsc();
  return qword_149C89AA8(&n0x6200);
}

// --- End Function: sub_143F54190 (0x143F54190) ---

// --- Function: sub_143F544D0 (0x143F544D0) ---
__int64 __fastcall sub_143F544D0(__int64 a1)
{
  __int64 v2; // rax
  int n0x6200; // [rsp+30h] [rbp-58h] BYREF
  __int64 v5; // [rsp+34h] [rbp-54h]
  int v6; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+40h] [rbp-48h]
  unsigned __int64 v8; // [rsp+48h] [rbp-40h]
  __int64 v9; // [rsp+50h] [rbp-38h]
  __int64 v10; // [rsp+58h] [rbp-30h]

  n0x6200 = 0x6200;
  v5 = 1;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = __rdtsc();
  qword_149C89AA0(
    &n0x6200,
    &word_149F763F8,
    "CAudioValueOutputManager::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Audio/AudioValueOutputManager.cpp",
    0xA2);
  HIWORD(n0x6200) = word_149F763F8;
  if ( sub_14288B1F0((_QWORD *)(a1 + 8)) )
  {
    v2 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a1 + 8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x10LL))(v2);
  }
  v8 = __rdtsc();
  return qword_149C89AA8(&n0x6200);
}

// --- End Function: sub_143F544D0 (0x143F544D0) ---

// --- Function: sub_143F552C0 (0x143F552C0) ---
__int64 __fastcall sub_143F552C0(__int64 a1)
{
  __int64 v2; // rcx
  void (__fastcall *v3)(__int64, _QWORD *); // r8
  __int64 result; // rax
  _BYTE v5[16]; // [rsp+30h] [rbp-68h] BYREF
  _BYTE v6[16]; // [rsp+40h] [rbp-58h] BYREF
  _BYTE v7[16]; // [rsp+50h] [rbp-48h] BYREF
  _BYTE v8[16]; // [rsp+60h] [rbp-38h] BYREF
  _QWORD v9[5]; // [rsp+70h] [rbp-28h] BYREF

  if ( Parameter_0 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      sub_1402B0AA0((__int64)v8, (__int64)"CJumpSystemDebug::Update", a1 + 0x40, 1, 1u, (__int64)"m_jumpDrivesLock");
      sub_1402B0AA0((__int64)v7, (__int64)"CJumpSystemDebug::Update", a1 + 0x10, 1, 1u, (__int64)"m_jumpPointsLock");
      sub_1402B0AA0((__int64)v6, (__int64)"CJumpSystemDebug::Update", a1 + 0x28, 1, 1u, (__int64)"m_jumpPointATCsLock");
      sub_1402B0AA0(
        (__int64)v5,
        (__int64)"CJumpSystemDebug::Update",
        a1 + 0x58,
        1,
        1u,
        (__int64)"m_jumpTunnelHostsLock");
      v2 = *(_QWORD *)(a1 + 8);
      v3 = *(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v2 + 0x10LL);
      v9[0] = a1 + 0xA0;
      v9[1] = a1 + 0x70;
      v9[2] = a1 + 0x88;
      v9[3] = a1 + 0xB8;
      v3(v2, v9);
      sub_1402B3F10((__int64)v5);
      sub_1402B3F10((__int64)v6);
      sub_1402B3F10((__int64)v7);
      return sub_1402B3F10((__int64)v8);
    }
  }
  return result;
}

// --- End Function: sub_143F552C0 (0x143F552C0) ---

// --- Function: sub_143F68660 (0x143F68660) ---
_UNKNOWN **__fastcall sub_143F68660(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  _UNKNOWN **result; // rax
  __int64 Parameter__3; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  int v8; // eax
  __int64 Parameter__4; // r8
  __int64 *v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v14; // r12
  unsigned int v15; // esi
  __int64 v16; // r15
  __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  char v21; // r9
  __int64 v22; // r15
  __int64 *v23; // r8
  __int64 v24; // rax
  unsigned int v25; // esi
  void (__fastcall *v27)(__int64, void *, _QWORD, _BYTE *, _QWORD, int, int, int, __int128 *, int); // r14
  void **v28; // rax
  void **v29; // rdi
  __int64 v30; // rax
  void **v31; // rax
  __int64 v32; // r8
  __int64 v33; // rax
  unsigned int v34; // esi
  void (__fastcall *v36)(__int64, void *, _QWORD, _BYTE *, _QWORD, int, int, int, _OWORD *, int); // r14
  void **v37; // rax
  void **v38; // rdi
  __int64 v39; // rax
  void **v40; // rax
  __int64 v41; // r9
  __int64 v42; // rdx
  __int64 v44; // rdi
  __int64 v45; // r14
  _QWORD *v46; // rax
  int v47; // esi
  __int64 v48; // rbx
  __int64 v49; // r8
  __int64 v50; // rdx
  int v51; // [rsp+30h] [rbp-D8h]
  int v52; // [rsp+38h] [rbp-D0h]
  int v53; // [rsp+40h] [rbp-C8h]
  int v54; // [rsp+50h] [rbp-B8h]
  __int64 v55; // [rsp+58h] [rbp-B0h] BYREF
  _QWORD *v56[3]; // [rsp+60h] [rbp-A8h] BYREF
  _BYTE v57[24]; // [rsp+78h] [rbp-90h] BYREF
  double v58; // [rsp+90h] [rbp-78h]
  double v59; // [rsp+98h] [rbp-70h]
  double v61; // [rsp+B0h] [rbp-58h]
  _BYTE Parameter_[24]; // [rsp+B8h] [rbp-50h] BYREF
  __int128 v63; // [rsp+D0h] [rbp-38h] BYREF
  double v64; // [rsp+E0h] [rbp-28h]
  __int128 v65; // [rsp+E8h] [rbp-20h] BYREF
  _OWORD v66[3]; // [rsp+F8h] [rbp-10h] BYREF
  _UNKNOWN *retaddr; // [rsp+170h] [rbp+68h] BYREF
  unsigned __int64 Parameter__1; // [rsp+178h] [rbp+70h] BYREF
  __int64 Parameter__2; // [rsp+180h] [rbp+78h] BYREF
  __int64 v70; // [rsp+188h] [rbp+80h] BYREF
  __int64 v71; // [rsp+190h] [rbp+88h] BYREF

  result = &retaddr;
  if ( *(_BYTE *)(a1 + 0x50) )
  {
    (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)qword_149C8DFD8 + 0xF8LL))(
      qword_149C8DFD8,
      &Parameter__1);
    if ( is_entity_descriptor_valid_or_accessible(&Parameter__1) )
    {
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8E0C8 + 0x668LL))(
        qword_149C8E0C8,
        &Parameter__2);
      Parameter__3 = Parameter__2;
      if ( *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)(Parameter__1
                                                                                         & 0xFFFFFFFFFFFFLL)
                                                                             + 0x660LL))(
                        Parameter__1 & 0xFFFFFFFFFFFFLL,
                        &v70) == Parameter__3 )
      {
        v6 = (*(__int64 (__fastcall **)(unsigned __int64, __int128 *, _QWORD))(*(_QWORD *)(Parameter__1
                                                                                         & 0xFFFFFFFFFFFFLL)
                                                                             + 0x278LL))(
               Parameter__1 & 0xFFFFFFFFFFFFLL,
               &v63,
               0);
        v7 = Parameter__1 & 0xFFFFFFFFFFFFLL;
        *(_OWORD *)(a1 + 0x88) = *(_OWORD *)v6;
        *(double *)(a1 + 0x98) = *(double *)(v6 + 0x10);
        v8 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v7 + 0x658LL))(v7);
        Parameter__4 = Parameter__2;
        *(_DWORD *)(a1 + 0xA0) = v8;
        v10 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)qword_149C8E0C8 + 0x2D0LL))(
                           qword_149C8E0C8,
                           &v70,
                           Parameter__4);
        v11 = sub_140335A10(v10);
        sub_1403DF920(a1 + 0xA8, a1 + 0x88, *(_DWORD *)(a1 + 0xA0), v11);
      }
    }
    sub_14345B480(a1 + 0x58, (__int64)v56);
    sub_142752190((Parameter *)Parameter_);
    sub_143A4B9D0((_QWORD ***)v56, (Parameter *)&Parameter__1);
    sub_143456BE0(v56, (Parameter *)&Parameter__2);
    if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
            &Parameter__1,
            &Parameter__2) )
    {
      v66[2] = v1;
      v66[1] = v2;
      do
      {
        v12 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&Parameter__1);
        v13 = *(unsigned int *)(a1 + 0x80);
        v14 = v12;
        v15 = *(_DWORD *)(a1 + 0x4C);
        v16 = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)(v12 + 0x18));
        v17 = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)(v14 + 0x18));
        v18 = unknown_libname_485(v14 + 0x18);
        v19 = sub_143EBA670(v18, v17, v13 | ((unsigned __int64)v15 << 0x20));
        sub_143F750B0(v14 + 0x18, v19, v16);
        if ( sub_142C64FF0((_QWORD *)(v14 + 0x18)) )
        {
          sub_143F75A00(Parameter_, v14);
        }
        else
        {
          v20 = sub_143F73830(v14 + 0x18);
          v21 = *(_BYTE *)(v14 + 0x40);
          v22 = v20;
          if ( v21 == 1 || *(_BYTE *)(v20 + 0x50) )
            goto LABEL_17;
          v23 = *(__int64 **)(v14 + 0x30);
          if ( v23 )
          {
            if ( *(_BYTE *)(v14 + 0x50) )
            {
              sub_143F68C80(a1, v20, v23, *(_QWORD *)(v14 + 0x38));
            }
            else
            {
              sub_143F170C0((_DWORD *)a1, v20, v23, v21);
              *(_BYTE *)(v14 + 0x50) = 1;
            }
LABEL_17:
            if ( *(_BYTE *)(v14 + 0x40) == 1 )
            {
              v32 = *(_QWORD *)(v14 + 0x30);
              if ( v32 )
              {
                sub_143F68C80(a1, v22, v32, *(_QWORD *)(v14 + 0x38));
              }
              else
              {
                v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFD8 + 0xC8LL))(qword_149C8DFD8);
                v70 = v33;
                *(_QWORD *)(v14 + 0x30) = v33;
                if ( v33 )
                {
                  v34 = *(_DWORD *)(v22 + 0x40);
                  _XMM1 = 0;
                  v36 = *(void (__fastcall **)(__int64, void *, _QWORD, _BYTE *, _QWORD, int, int, int, _OWORD *, int))(*(_QWORD *)v33 + 0x48LL);
                  v59 = 1.0;
                  v58 = 0.0;
                  v61 = 0.0;
                  v66[0] = 0;
                  __asm
                  {
                    vmovupd xmmword ptr [rsp+160h+var_F0+8], xmm0
                    vmovupd [rbp+60h+var_C8], xmm1
                  }
                  sub_14035E090(&v55);
                  v38 = v37;
                  v39 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v22);
                  v40 = sub_1403ACC80(v38, "Water Force ID: %llu", *(_QWORD *)(v39 + 0x60));
                  LOBYTE(v54) = 0;
                  LOBYTE(v53) = 0;
                  LOBYTE(v52) = 0;
                  LOBYTE(v51) = 1;
                  v36(v70, *v40, v34, &v57[8], 0, v51, v52, v53, v66, v54);
                  sub_140373CC0(&v55);
                  sub_143F170C0((_DWORD *)a1, v22, *(__int64 **)(v14 + 0x30), *(_BYTE *)(v14 + 0x40));
                  if ( is_valid_handle_typeA((__int64 *)(v14 + 0x38)) )
                  {
                    v41 = *(_QWORD *)(v14 + 0x30);
                    v42 = *(_QWORD *)(v14 + 0x38);
                    _XMM0 = 0;
                    __asm { vmovupd [rbp+60h+var_98], xmm0 }
                    v64 = 0.0;
                    sub_143ED1BB0(a1, v42, (double *)(v22 + 0x10), v41, (double *)&v63);
                  }
                }
              }
            }
            goto LABEL_23;
          }
          v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFD8 + 0xC8LL))(qword_149C8DFD8);
          v70 = v24;
          *(_QWORD *)(v14 + 0x30) = v24;
          if ( v24 )
          {
            v25 = *(_DWORD *)(v22 + 0x40);
            _XMM1 = 0;
            v27 = *(void (__fastcall **)(__int64, void *, _QWORD, _BYTE *, _QWORD, int, int, int, __int128 *, int))(*(_QWORD *)v24 + 0x48LL);
            v59 = 1.0;
            v58 = 0.0;
            v61 = 0.0;
            v65 = 0;
            __asm
            {
              vmovupd xmmword ptr [rsp+160h+var_F0+8], xmm0
              vmovupd [rbp+60h+var_C8], xmm1
            }
            sub_14035E090(&v71);
            v29 = v28;
            v30 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v22);
            v31 = sub_1403ACC80(v29, "Water Hit ID: %llu", *(_QWORD *)(v30 + 0x60));
            LOBYTE(v54) = 0;
            LOBYTE(v53) = 0;
            LOBYTE(v52) = 0;
            LOBYTE(v51) = 1;
            v27(v70, *v31, v25, &v57[8], 0, v51, v52, v53, &v65, v54);
            sub_140373CC0(&v71);
            sub_143F17290((_DWORD *)a1, v22, *(_QWORD *)(v14 + 0x30), *(_QWORD *)(v14 + 0x38));
            *(_BYTE *)(v22 + 0x50) = 1;
          }
        }
LABEL_23:
        sub_142C0DC70((__int64)&Parameter__1);
      }
      while ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                 &Parameter__1,
                 &Parameter__2) );
    }
    v44 = unknown_libname_485((__int64)Parameter_);
    v45 = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)Parameter_);
    if ( v44 != v45 )
    {
      while ( 1 )
      {
        sub_143F75410(v56, &Parameter__1, v44);
        v46 = sub_143456BE0(v56, (Parameter *)&Parameter__2);
        if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                &Parameter__1,
                v46) )
          break;
LABEL_38:
        v44 += 0x18;
        if ( v44 == v45 )
          goto LABEL_39;
      }
      v47 = *(unsigned __int8 *)(sub_142C0DC20(&Parameter__1) + 0x40);
      v48 = *(_QWORD *)(sub_142C0DC20(&Parameter__1) + 0x30);
      if ( !v48 )
      {
LABEL_37:
        sub_143F74A30(v56, &v70, Parameter__1);
        goto LABEL_38;
      }
      if ( (_BYTE)v47 )
      {
        switch ( v47 )
        {
          case 1:
            v49 = *(unsigned int *)(a1 + 0x1C);
            v50 = *(unsigned int *)(a1 + 0x18);
            break;
          case 2:
            v49 = *(unsigned int *)(a1 + 0x24);
            v50 = *(unsigned int *)(a1 + 0x20);
            break;
          case 3:
            v49 = *(unsigned int *)(a1 + 0x2C);
            v50 = *(unsigned int *)(a1 + 0x28);
            break;
          default:
LABEL_36:
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x50LL))(v48);
            goto LABEL_37;
        }
      }
      else
      {
        v49 = *(unsigned int *)(a1 + 0x14);
        v50 = *(unsigned int *)(a1 + 0x10);
      }
      (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)v48 + 0x20LL))(v48, v50, v49, 0);
      goto LABEL_36;
    }
LABEL_39:
    if ( (unsigned __int8)sub_143F74970(v56) )
      *(_BYTE *)(a1 + 0x50) = 0;
    sub_143EC6850((__int64)Parameter_);
    result = (_UNKNOWN **)sub_142C8CD20((__int64)v56);
    ++*(_QWORD *)(a1 + 0x80);
  }
  else
  {
    ++*(_QWORD *)(a1 + 0x80);
  }
  return result;
}

// --- End Function: sub_143F68660 (0x143F68660) ---

// --- Function: sub_143F68C80 (0x143F68C80) ---
void sub_143F68C80(unsigned int *a1, __int64 a2, __int64 a3, ...)
{
  void (__fastcall *v6)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v7; // rax
  __int64 v8; // r8
  void (__fastcall *v9)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v10; // rax
  __int64 v11; // r8
  void (__fastcall *v12)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v13; // rax
  __int64 v14; // r8
  void (__fastcall *v15)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v16; // rax
  __int64 v17; // r8
  void (__fastcall *v18)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v19; // rax
  __int64 v20; // r8
  void (__fastcall *v21)(__int64, _QWORD, __int64, _QWORD); // rbx
  __int64 v22; // r8
  __int128 v24; // xmm1
  __int64 v25; // rax
  __m256 v26; // [rsp+30h] [rbp-48h] BYREF
  __int128 v27; // [rsp+50h] [rbp-28h]
  __int64 v28; // [rsp+60h] [rbp-18h]
  __int64 v29; // [rsp+98h] [rbp+20h] BYREF
  va_list va; // [rsp+98h] [rbp+20h]
  va_list va1; // [rsp+A0h] [rbp+28h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v29 = va_arg(va1, _QWORD);
  if ( a3 )
  {
    v6 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
    v7 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x28LL))(v7);
    v6(a3, a1[0xC], v8, 0);
    v9 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
    v10 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
    v9(a3, a1[0xD], v11, 0);
    v12 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
    v13 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x10LL))(v13);
    v12(a3, a1[0xE], v14, 0);
    v15 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
    v16 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x20LL))(v16);
    v15(a3, a1[0xF], v17, 0);
    v18 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
    v19 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x18LL))(v19);
    v18(a3, a1[0x10], v20, 0);
    v21 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)a3 + 0x30LL);
    std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2);
    v21(a3, a1[0x11], v22, 0);
    if ( is_valid_handle_typeA((__int64 *)va) )
      sub_143ED1BB0((__int64)a1, v29, (double *)(a2 + 0x10), a3, (double *)(a2 + 0x28));
    __asm { vmovupd ymm0, cs:ymmword_1482BB440 }
    v24 = *(_OWORD *)(a2 + 0x10);
    v25 = *(_QWORD *)a3;
    __asm { vmovupd [rsp+78h+var_48], ymm0 }
    v28 = *(_QWORD *)(a2 + 0x20);
    v27 = v24;
    __asm { vzeroupper }
    (*(void (__fastcall **)(__int64, __m256 *))(v25 + 0x70))(a3, &v26);
  }
}

// --- End Function: sub_143F68C80 (0x143F68C80) ---

// --- Function: sub_143F70540 (0x143F70540) ---
Parameter *__fastcall sub_143F70540(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  Parameter *Parameter_2; // [rsp+30h] [rbp-28h]
  _QWORD *v5; // [rsp+40h] [rbp-18h]

  v5 = Parameter + 1;
  Parameter_2 = Parameter + 2;
  _StarEngineModule__((ULONG_PTR)Parameter);
  Parameter_1 = Parameter;
  if ( *Parameter )
  {
    sub_143456A00(Parameter, *Parameter, (*Parameter_2 - *Parameter) / 0x18LL);
    *Parameter = 0;
    *v5 = 0;
    Parameter_1 = Parameter_2;
    *Parameter_2 = 0;
  }
  return Parameter_1;
}

// --- End Function: sub_143F70540 (0x143F70540) ---

// --- Function: sub_143F73830 (0x143F73830) ---
__int64 __fastcall sub_143F73830(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) - 0x58LL;
}

// --- End Function: sub_143F73830 (0x143F73830) ---

// --- Function: sub_143F74970 (0x143F74970) ---
_BOOL8 __fastcall sub_143F74970(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 8LL) == 0;
}

// --- End Function: sub_143F74970 (0x143F74970) ---

// --- Function: sub_143F74A30 (0x143F74A30) ---
Parameter *__fastcall sub_143F74A30(__int64 *a1, Parameter *Parameter, ULONG_PTR a3)
{
  sub_143EB80E0(*a1, Parameter, a3);
  return Parameter;
}

// --- End Function: sub_143F74A30 (0x143F74A30) ---

// --- Function: sub_143F74B10 (0x143F74B10) ---
__int64 __fastcall sub_143F74B10(__int64 a1, __int64 a2)
{
  return sub_143E9B030(a1, a2);
}

// --- End Function: sub_143F74B10 (0x143F74B10) ---

// --- Function: sub_143F750B0 (0x143F750B0) ---
__int64 __fastcall sub_143F750B0(__int64 a1, __int64 a2, __int64 a3)
{
  std::shared_ptr<std::vector<char> > *i; // [rsp+20h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-18h]
  std::shared_ptr<std::vector<char> > *v6; // [rsp+48h] [rbp-10h]

  if ( a2 != a3 )
  {
    v5 = sub_143EB9BE0(a3, *(_QWORD *)(a1 + 8), a2);
    v6 = *(std::shared_ptr<std::vector<char> > **)(a1 + 8);
    for ( i = (std::shared_ptr<std::vector<char> > *)v5;
          i != v6;
          i = (std::shared_ptr<std::vector<char> > *)((char *)i + 0x58) )
    {
      std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>(i);
    }
    *(_QWORD *)(a1 + 8) -= 0x58 * ((a3 - a2) / 0x58);
  }
  return a2;
}

// --- End Function: sub_143F750B0 (0x143F750B0) ---

// --- Function: sub_143F75410 (0x143F75410) ---
Parameter *__fastcall sub_143F75410(__int64 *a1, Parameter *Parameter, __int64 a3)
{
  *(_QWORD *)Parameter = sub_143E9B620(*a1, a3);
  _StarEngineModule__((ULONG_PTR)Parameter);
  return Parameter;
}

// --- End Function: sub_143F75410 (0x143F75410) ---

// --- Function: sub_143F75A00 (0x143F75A00) ---
__int64 __fastcall sub_143F75A00(Parameter *Parameter, __int64 a2)
{
  return sub_143E98D80((__int64)Parameter, a2);
}

// --- End Function: sub_143F75A00 (0x143F75A00) ---

// --- Function: sub_143F75A30 (0x143F75A30) ---
__int64 __fastcall sub_143F75A30(__int64 a1, __int64 a2)
{
  return sub_143E99030(a1, a2);
}

// --- End Function: sub_143F75A30 (0x143F75A30) ---

// --- Function: sub_1440870C0 (0x1440870C0) ---
__int64 __fastcall sub_1440870C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall **v5)(__int64, __int64); // [rsp+28h] [rbp-50h]
  __int64 v6; // [rsp+30h] [rbp-48h]
  _BYTE v7[24]; // [rsp+48h] [rbp-30h] BYREF

  sub_14408BEB0(a3, a4);
  v5 = (__int64 (__fastcall **)(__int64, __int64))(a1 + 8);
  v6 = sub_141237460((__int64)v7, a2);
  if ( *(_QWORD *)(a1 + 0x10) == 1 )
    return (*v5)(v6, a4);
  else
    return ((__int64 (__fastcall *)(__int64 (__fastcall **)(__int64, __int64), __int64, __int64))*v5)(v5, v6, a4);
}

// --- End Function: sub_1440870C0 (0x1440870C0) ---

// --- Function: sub_1440870C0 (0x14408717E) ---
__int64 __fastcall sub_1440870C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall **v5)(__int64, __int64); // [rsp+28h] [rbp-50h]
  __int64 v6; // [rsp+30h] [rbp-48h]
  _BYTE v7[24]; // [rsp+48h] [rbp-30h] BYREF

  sub_14408BEB0(a3, a4);
  v5 = (__int64 (__fastcall **)(__int64, __int64))(a1 + 8);
  v6 = sub_141237460((__int64)v7, a2);
  if ( *(_QWORD *)(a1 + 0x10) == 1 )
    return (*v5)(v6, a4);
  else
    return ((__int64 (__fastcall *)(__int64 (__fastcall **)(__int64, __int64), __int64, __int64))*v5)(v5, v6, a4);
}

// --- End Function: sub_1440870C0 (0x14408717E) ---

// --- Function: sub_14408BEB0 (0x14408BEB0) ---
unsigned __int64 __fastcall sub_14408BEB0(__int64 a1, __int64 a2)
{
  _BYTE *v3; // [rsp+20h] [rbp-18h]

  v3 = (_BYTE *)sub_1404B4DD0(*(_QWORD **)(a1 + 8), 8);
  if ( v3 )
    *(_BYTE *)a2 = *v3;
  sub_14052A660(a1, (__int64)"requesterId", (unsigned __int64 *)(a2 + 8));
  sub_14052A720(a1, (__int64)"pos_ls", a2 + 0x10);
  sub_14052A720(a1, (__int64)"dir_ls", a2 + 0x1C);
  sub_14052A620(a1, (__int64)"totalEnergyDamage", (_DWORD *)(a2 + 0x28));
  sub_14052A620(a1, (__int64)"physicalDamage", (_DWORD *)(a2 + 0x2C));
  sub_14052A620(a1, (__int64)"projectileHitTime", (_DWORD *)(a2 + 0x30));
  sub_14052A620(a1, (__int64)"hitRadius", (_DWORD *)(a2 + 0x34));
  sub_14052A620(a1, (__int64)"seed", (_DWORD *)(a2 + 0x38));
  return sub_14052A660(a1, (__int64)"timeStamp", (unsigned __int64 *)(a2 + 0x40));
}

// --- End Function: sub_14408BEB0 (0x14408BEB0) ---

// --- Function: sub_14408CAD0 (0x14408CAD0) ---
__int64 __fastcall sub_14408CAD0(_QWORD *a1, const void *src)
{
  __int64 result; // rax
  __int64 v3; // [rsp+28h] [rbp-90h]

  if ( a1[2] <= (unsigned __int64)(a1[4] + 1LL) )
    sub_1440C7240(a1, 1);
  a1[3] &= a1[2] - 1LL;
  v3 = (a1[2] - 1LL) & (a1[4] + a1[3]);
  if ( !*(_QWORD *)(a1[1] + 8 * v3) )
    *(_QWORD *)(a1[1] + 8 * v3) = std::_Allocate<16,std::_Default_allocate_traits,0>(0xA0u);
  qmemcpy((void *)sub_1402A53E0(0xA0, *(_QWORD *)(a1[1] + 8 * v3)), src, 0xA0u);
  result = a1[4] + 1LL;
  a1[4] = result;
  return result;
}

// --- End Function: sub_14408CAD0 (0x14408CAD0) ---

// --- Function: sub_14408CD70 (0x14408CD70) ---
__int64 __fastcall sub_14408CD70(__int64 *a1, const void *src)
{
  __int64 *v3; // [rsp+20h] [rbp-48h]
  __int64 v4; // [rsp+28h] [rbp-40h]
  __int64 v5; // [rsp+48h] [rbp-20h]

  v3 = a1 + 1;
  v4 = a1[1];
  AK::WriteBytesCount::Reserve((AK::WriteBytesCount *)a1);
  qmemcpy((void *)sub_1402A53E0(0xA0, v4), src, 0xA0u);
  v5 = *v3;
  *v3 += 0xA0;
  return v5;
}

// --- End Function: sub_14408CD70 (0x14408CD70) ---

// --- Function: sub_14408CE90 (0x14408CE90) ---
__int64 __fastcall sub_14408CE90(__int64 *a1, const void *src)
{
  if ( a1[1] == a1[2] )
    return sub_14408D220(a1, a1[1], src);
  else
    return sub_14408CD70(a1, src);
}

// --- End Function: sub_14408CE90 (0x14408CE90) ---

// --- Function: sub_14408D220 (0x14408D220) ---
char *__fastcall sub_14408D220(_QWORD *a1, __int64 a2, const void *src)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  char *v6; // [rsp+20h] [rbp-C8h]
  __int64 v7; // [rsp+30h] [rbp-B8h]
  _QWORD *v9; // [rsp+40h] [rbp-A8h]
  unsigned __int64 v11; // [rsp+50h] [rbp-98h]
  __int64 v12; // [rsp+60h] [rbp-88h]
  __int64 v13; // [rsp+80h] [rbp-68h] BYREF
  __int64 v14; // [rsp+88h] [rbp-60h] BYREF
  __int64 v15; // [rsp+90h] [rbp-58h]
  __int64 v16; // [rsp+98h] [rbp-50h]
  char *v17; // [rsp+A0h] [rbp-48h]
  __int64 v18; // [rsp+A8h] [rbp-40h]
  void *dst; // [rsp+B0h] [rbp-38h]
  __int64 v20; // [rsp+C0h] [rbp-28h]

  v9 = a1 + 1;
  v7 = (a2 - *a1) / 0xA0;
  v12 = (a1[1] - *a1) / 0xA0LL;
  v13 = 0x199999999999999LL;
  v14 = __crt_strtox::maximum_signed_value((__crt_strtox *)0xA0);
  v15 = *unknown_libname_2(&v14, &v13);
  if ( v12 == v15 )
    unknown_libname_65(v4, v3);
  v11 = sub_1440C6EE0(a1, v12 + 1);
  v20 = 0x199999999999999LL;
  if ( v11 > 0x199999999999999LL )
    sub_1402E3880();
  v16 = 0xA0 * v11;
  v17 = (char *)std::_Allocate<16,std::_Default_allocate_traits,0>(0xA0 * v11);
  v6 = v17;
  v18 = (__int64)&v17[0xA0 * v7 + 0xA0];
  dst = (void *)sub_1402A53E0(0xA0, (__int64)&v17[0xA0 * v7]);
  qmemcpy(dst, src, 0xA0u);
  if ( a2 == *v9 )
  {
    sub_144090320(*a1, *v9, v6, a1);
  }
  else
  {
    sub_144090320(*a1, a2, v6, a1);
    sub_144090320(a2, *v9, &v6[0xA0 * v7 + 0xA0], a1);
  }
  sub_1440C6FB0(a1, v6, v12 + 1, v11);
  return &v6[0xA0 * v7];
}

// --- End Function: sub_14408D220 (0x14408D220) ---

// --- Function: sub_144093F20 (0x144093F20) ---
__int64 __fastcall sub_144093F20(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x3C) = 0;
  *(_QWORD *)(a1 + 0x44) = 0;
  *(_QWORD *)(a1 + 0x4C) = 0;
  *(_QWORD *)(a1 + 0x54) = 0;
  *(_QWORD *)(a1 + 0x5C) = 0;
  *(_QWORD *)(a1 + 0x64) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_DWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x6C) = 0x800000;
  *(_DWORD *)(a1 + 0x70) = 0x800000;
  *(_DWORD *)(a1 + 0x74) = 0x800000;
  *(_QWORD *)(a1 + 0x78) = 0x800000;
  v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(qword_149C8DF80, 0);
  result = a1;
  *(_QWORD *)(a1 + 0x98) = v2;
  return result;
}

// --- End Function: sub_144093F20 (0x144093F20) ---

// --- Function: sub_144094C20 (0x144094C20) ---
__int64 __fastcall sub_144094C20(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(qword_149C8DF80, 0);
  result = a1;
  *(_QWORD *)(a1 + 0x40) = v2;
  return result;
}

// --- End Function: sub_144094C20 (0x144094C20) ---

// --- Function: sub_144095C00 (0x144095C00) ---
__int64 __fastcall sub_144095C00(_QWORD *a1)
{
  return *(_QWORD *)(*(_QWORD *)(*a1 + 8LL) + 8 * ((*(_QWORD *)(*a1 + 0x10LL) - 1LL) & a1[1]));
}

// --- End Function: sub_144095C00 (0x144095C00) ---

// --- Function: sub_144097190 (0x144097190) ---
__int64 __fastcall sub_144097190(__int64 a1, __int64 a2)
{
  _BYTE v3[8]; // [rsp+20h] [rbp-78h] BYREF
  void (__fastcall **v4)(_BYTE *, __int64); // [rsp+28h] [rbp-70h]
  unsigned int v5; // [rsp+30h] [rbp-68h]
  void (__fastcall *v6)(_BYTE *, __int64); // [rsp+38h] [rbp-60h]
  void (__fastcall *v7)(_BYTE *, __int64); // [rsp+40h] [rbp-58h]
  __int128 dst_; // [rsp+50h] [rbp-48h] BYREF
  _BYTE v9[24]; // [rsp+60h] [rbp-38h] BYREF

  qmemcpy(&dst_, &src__7, sizeof(dst_));
  sub_141237480((__int64)v9, 0, &dst_);
  v3[0] = 0;
  v5 = sub_1440A0460(a1, v3, v9, a2);
  if ( v3[0] )
  {
    v4 = (void (__fastcall **)(_BYTE *, __int64))(a1 + 8);
    v3[1] = 0;
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
    {
      v6 = *v4;
      v6(v9, a2);
    }
    else
    {
      v7 = *v4;
      ((void (__fastcall *)(void (__fastcall **)(_BYTE *, __int64), _BYTE *, __int64))v7)(v4, v9, a2);
    }
  }
  return v5;
}

// --- End Function: sub_144097190 (0x144097190) ---

// --- Function: sub_1440972A0 (0x1440972A0) ---
__int64 __fastcall sub_1440972A0(__int64 a1, __int64 a2, __int64 a3)
{
  _BYTE v4[8]; // [rsp+30h] [rbp-78h] BYREF
  void (__fastcall **v5)(_BYTE *, __int64, __int64); // [rsp+38h] [rbp-70h]
  unsigned int v6; // [rsp+40h] [rbp-68h]
  void (__fastcall *v7)(_BYTE *, __int64, __int64); // [rsp+48h] [rbp-60h]
  void (__fastcall *v8)(_BYTE *, __int64, __int64); // [rsp+50h] [rbp-58h]
  __int128 dst_; // [rsp+60h] [rbp-48h] BYREF
  _BYTE v10[24]; // [rsp+70h] [rbp-38h] BYREF

  qmemcpy(&dst_, &src__7, sizeof(dst_));
  sub_141237480((__int64)v10, 0, &dst_);
  v4[0] = 0;
  v6 = sub_1440A0660(a1, (unsigned int)v4, (unsigned int)v10, a2, a3);
  if ( v4[0] )
  {
    v5 = (void (__fastcall **)(_BYTE *, __int64, __int64))(a1 + 8);
    v4[1] = 0;
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
    {
      v7 = *v5;
      v7(v10, a2, a3);
    }
    else
    {
      v8 = *v5;
      ((void (__fastcall *)(void (__fastcall **)(_BYTE *, __int64, __int64), _BYTE *, __int64, __int64))v8)(
        v5,
        v10,
        a2,
        a3);
    }
  }
  return v6;
}

// --- End Function: sub_1440972A0 (0x1440972A0) ---

// --- Function: sub_1440980A0 (0x1440980A0) ---
char __fastcall sub_1440980A0(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm0
  __int128 v3; // xmm12
  __int128 v4; // xmm13
  __int128 v5; // xmm14
  __int128 v6; // xmm15
  char result; // al
  __int128 v11; // kr00_16
  float v12; // xmm0_4
  __int128 n0x3E99999A; // xmm1
  float v14; // xmm6_4
  float v16; // xmm11_4
  unsigned __int8 v17; // r13
  __int64 v19; // r8
  __int64 v20; // rsi
  __int64 v21; // rcx
  __int64 v22; // rax
  float v23; // xmm1_4
  __m128 v24; // xmm2
  __m128 v25; // kr00_16
  float v26; // xmm0_4
  float v27; // xmm1_4
  __m128 v28; // kr00_16
  __m128 v29; // xmm0
  __int64 v30; // rax
  __int64 v31; // r15
  __int64 v32; // rbx
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned int v36; // eax
  unsigned int v37; // r15d
  float v38; // xmm0_4
  float v39; // xmm11_4
  float v40; // xmm0_4
  float v41; // kr00_4
  __int64 v42; // rax
  __int64 v43; // rax
  __int64 v44; // rbx
  __int64 v45; // rax
  double *v46; // rax
  double v47; // xmm14_8
  double v48; // xmm13_8
  double v49; // xmm11_8
  double v50; // xmm12_8
  double v51; // xmm6_8
  double v52; // xmm5_8
  double v53; // xmm4_8
  double v54; // xmm10_8
  double v55; // xmm2_8
  double v56; // xmm5_8
  double v57; // xmm0_8
  __int128 v58; // xmm15
  double v59; // xmm1_8
  __int128 v60; // xmm13
  __int128 v61; // xmm12
  double v62; // xmm7_8
  double v63; // xmm6_8
  double v64; // xmm4_8
  double v65; // xmm5_8
  double v66; // xmm4_8
  double v67; // xmm2_8
  __int64 v68; // r8
  __int128 v69; // kr00_16
  __int128 v70; // xmm2
  __int128 v71; // xmm1
  __int128 v72; // xmm0
  __int128 v73; // xmm8
  __int128 v74; // xmm2
  __int128 v75; // xmm1
  __int128 v76; // xmm9
  __int128 v77; // xmm10
  double v78; // xmm7_8
  double v79; // xmm6_8
  double v80; // xmm4_8
  double v87; // xmm7_8
  double v88; // xmm6_8
  double v89; // xmm5_8
  double v90; // xmm4_8
  __int64 *v97; // rax
  __int64 v98; // rcx
  __int64 v99; // rcx
  __int64 v100; // rax
  __int64 v101; // rcx
  float v102; // [rsp+40h] [rbp-478h]
  __int64 v103; // [rsp+48h] [rbp-470h] BYREF
  float v104; // [rsp+50h] [rbp-468h]
  __int64 v105; // [rsp+58h] [rbp-460h] BYREF
  float v106; // [rsp+60h] [rbp-458h]
  float v107; // [rsp+68h] [rbp-450h]
  float v108; // [rsp+6Ch] [rbp-44Ch]
  float v109; // [rsp+70h] [rbp-448h]
  __int64 v110; // [rsp+78h] [rbp-440h] BYREF
  double v111; // [rsp+80h] [rbp-438h]
  double v112; // [rsp+88h] [rbp-430h]
  double v113; // [rsp+90h] [rbp-428h]
  double v114; // [rsp+98h] [rbp-420h]
  double v115; // [rsp+A0h] [rbp-418h]
  double v116; // [rsp+A8h] [rbp-410h]
  double v117; // [rsp+B0h] [rbp-408h]
  double v118; // [rsp+B8h] [rbp-400h]
  __m256 v119; // [rsp+C0h] [rbp-3F8h] BYREF
  _BYTE v120[64]; // [rsp+E0h] [rbp-3D8h] BYREF
  unsigned __int8 v121[8]; // [rsp+120h] [rbp-398h] BYREF
  __int64 v122; // [rsp+128h] [rbp-390h]
  __int64 v123; // [rsp+130h] [rbp-388h]
  float v124; // [rsp+138h] [rbp-380h]
  __int64 v125; // [rsp+13Ch] [rbp-37Ch]
  float v126; // [rsp+144h] [rbp-374h]
  float v127; // [rsp+148h] [rbp-370h]
  float v128; // [rsp+14Ch] [rbp-36Ch]
  float v129; // [rsp+150h] [rbp-368h]
  float v130; // [rsp+154h] [rbp-364h]
  unsigned int v131; // [rsp+158h] [rbp-360h]
  __int64 v132; // [rsp+160h] [rbp-358h]
  double v133; // [rsp+170h] [rbp-348h] BYREF
  double v134; // [rsp+178h] [rbp-340h]
  double v135; // [rsp+180h] [rbp-338h]
  double v136; // [rsp+188h] [rbp-330h]
  double v137; // [rsp+190h] [rbp-328h]
  double v138; // [rsp+198h] [rbp-320h]
  double v139; // [rsp+1A0h] [rbp-318h]
  double v140; // [rsp+1A8h] [rbp-310h]
  _QWORD v141[2]; // [rsp+1B0h] [rbp-308h] BYREF
  float v142; // [rsp+1C0h] [rbp-2F8h]
  __int64 v143; // [rsp+1C4h] [rbp-2F4h]
  float v144; // [rsp+1CCh] [rbp-2ECh]
  float v145; // [rsp+1E0h] [rbp-2D8h]
  __m256 v146; // [rsp+1E8h] [rbp-2D0h]
  __m256 v147; // [rsp+208h] [rbp-2B0h]
  __m256 v148; // [rsp+228h] [rbp-290h]
  __int64 v149; // [rsp+248h] [rbp-270h]
  _BYTE v150[16]; // [rsp+250h] [rbp-268h] BYREF
  __int64 v151; // [rsp+260h] [rbp-258h]
  _BYTE v152[44]; // [rsp+288h] [rbp-230h] BYREF
  float v153; // [rsp+2B4h] [rbp-204h]
  double v154; // [rsp+2E0h] [rbp-1D8h]
  double v155; // [rsp+2E8h] [rbp-1D0h]
  double v156; // [rsp+2F0h] [rbp-1C8h]
  float v157; // [rsp+2F8h] [rbp-1C0h]
  float v158; // [rsp+2FCh] [rbp-1BCh]
  float v159; // [rsp+300h] [rbp-1B8h]
  unsigned int v160; // [rsp+32Ch] [rbp-18Ch]
  char v161; // [rsp+334h] [rbp-184h]
  char v162; // [rsp+335h] [rbp-183h]
  char v163; // [rsp+336h] [rbp-182h]
  __int128 v164; // [rsp+394h] [rbp-124h]
  _OWORD v165[8]; // [rsp+3B0h] [rbp-108h] BYREF

  result = sub_1403BDE70(a2);
  if ( !result )
  {
    result = sub_14409B0F0(a1);
    if ( result )
    {
      sub_1403BA040(a2, (__int64)v150);
      *(float *)&v2 = sub_1403B1500((__int64)v152, 3);
      v11 = v2;
      *(float *)&v11 = *(float *)&v2 + sub_1403B1500((__int64)v152, 1);
      _XMM10 = v11;
      v12 = sub_1403B1500((__int64)v152, 0);
      n0x3E99999A = 0x3E99999Au;
      v14 = v153;
      __asm { vcmpltss xmm2, xmm10, xmm0 }
      v16 = v12;
      v17 = 0;
      __asm { vblendvps xmm1, xmm1, xmm0, xmm2 }
      v102 = *(float *)&_XMM1;
      if ( v162 )
      {
        v102 = 0.5;
        v17 = 1;
      }
      v20 = 0;
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
        v21 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v21 = 0;
      LOBYTE(v19) = 1;
      v22 = (*(__int64 (__fastcall **)(__int64, _OWORD *, __int64))(*(_QWORD *)v21 + 0x220LL))(v21, v165, v19);
      v23 = *(float *)(v22 + 0xC);
      if ( *(float *)v22 <= v23 )
      {
        v25 = (__m128)*(unsigned int *)(v22 + 0x10);
        v25.m128_f32[0] = *(float *)(v22 + 0x10) - *(float *)(v22 + 4);
        v24 = v25;
        v25.m128_f32[0] = *(float *)(v22 + 0x14) - *(float *)(v22 + 8);
        v26 = (float)(v23 - *(float *)v22) * (float)(v23 - *(float *)v22);
        v27 = v25.m128_f32[0] * v25.m128_f32[0];
        v28 = v24;
        v28.m128_f32[0] = (float)((float)(v24.m128_f32[0] * v24.m128_f32[0]) + v26) + v27;
        v29 = _mm_sqrt_ps(_mm_shuffle_ps(v28, v28, 0));
        _mm_shuffle_ps(v29, v29, 0xFF);
      }
      if ( v14 < 0.00000011920929 )
      {
        v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
        v31 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v30 + 0x10LL))(v30, v160);
        if ( !v31
          || (v32 = sub_1418215F0(qword_149FBE618),
              v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x18LL))(v31),
              sub_14580E2F0(v32, v165, v33),
              !sub_14275AC70((__int64)v165))
          || (v34 = sub_14275AD80((__int64)v165), (v35 = sub_142D1A700(v34)) == 0)
          || (v14 = *(float *)(v35 + 0xC8), v14 < 0.00000011920929) )
        {
          v14 = 0.050000001;
        }
      }
      if ( v163 )
        v36 = sub_1440A42C0(a1);
      else
        v36 = sub_1405722D0((__int64)&qword_149A6A5E0);
      v37 = v36;
      v38 = (float)(unsigned int)((0x343FD * (unsigned __int64)v36 + 0x269EC3) >> 0x10);
      v39 = v16 * (float)((float)(v38 * 2.3283064e-10) + 0.5);
      v40 = (float)(unsigned int)((0x343FD * (0x343FD * (unsigned __int64)v36 + 0x269EC3) + 0x269EC3) >> 0x10);
      v41 = (float)(unsigned int)((0x343FD * (0x343FD * (0x343FD * (unsigned __int64)v36 + 0x269EC3) + 0x269EC3)
                                 + 0x269EC3) >> 0x10);
      v109 = v14 * (float)((float)((float)(v41 * 4.6566129e-11) * 2.0) + 0.80000001);
      v108 = v39;
      v107 = *(float *)&_XMM10 * (float)((float)(v40 * 2.3283064e-10) + 0.5);
      v42 = sub_1402A4EC0(a1 + 0xA60);
      result = (*(__int64 (__fastcall **)(__int64, __m256 *, _QWORD))(*(_QWORD *)v42 + 0xB8LL))(v42, &v119, v17);
      if ( (float)((float)((float)(v119.m256_f32[1] * v119.m256_f32[1]) + (float)(v119.m256_f32[2] * v119.m256_f32[2]))
                 + (float)((float)(v119.m256_f32[3] * v119.m256_f32[3]) + (float)(v119.m256_f32[4] * v119.m256_f32[4]))) >= 0.00000011920929 )
      {
        v165[7] = v3;
        v165[6] = v4;
        v165[5] = v5;
        v165[4] = v6;
        *(_QWORD *)&v120[0x28] = v151;
        *(_OWORD *)&v120[0x14] = v164;
        if ( !*(_BYTE *)(a2 + 0xE6) )
          *(_BYTE *)(a1 + 0xB98) = 0;
        v43 = sub_1402A4EC0(a1 + 0xA60);
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v43 + 0x18LL))(v43, &v110);
        v44 = sub_1403B4280((__int64)v150);
        v45 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v110 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v110 & 0xFFFFFFFFFFFFLL);
        v46 = (double *)(*(__int64 (__fastcall **)(__int64, _OWORD *, __int64, __int64))(*(_QWORD *)qword_149C8DF28
                                                                                       + 0x480LL))(
                          qword_149C8DF28,
                          v165,
                          v44,
                          v45);
        v47 = v46[2];
        v48 = v46[1];
        v49 = v46[3];
        v50 = *v46;
        v112 = v46[4];
        v114 = v46[5];
        v116 = v46[6];
        v51 = v48 * v156 - v47 * v155 + v49 * v154;
        v52 = v47 * v154 - v50 * v156 + v49 * v155;
        v53 = v50 * v155 - v48 * v154 + v49 * v156;
        v54 = v48 * v53 - v47 * v52;
        v55 = v50 * v52;
        v56 = v46[1];
        v57 = v55 - v48 * v51;
        v58 = COERCE_UNSIGNED_INT64(v156 + v57);
        v59 = v47 * v51 - v50 * v53;
        v60 = COERCE_UNSIGNED_INT64(v155 + v59);
        v61 = COERCE_UNSIGNED_INT64(v154 + v54);
        v113 = v59;
        v111 = v54;
        v115 = v57;
        v62 = v159 * v56 - v158 * v47 + v157 * v49;
        v63 = v157 * v47 - v159 * *v46 + v158 * v49;
        v64 = v158 * *v46 - v157 * v56 + v159 * v49;
        v65 = v56 * v64 - v47 * v63;
        v66 = v47 * v62 - v64 * *v46;
        v67 = v63 * *v46 - v62 * v46[1];
        *(double *)v165 = v157 + v65 + v65;
        v117 = v158 + v66 + v66;
        LOBYTE(v68) = 1;
        v118 = v159 + v67 + v67;
        (*(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)(v110 & 0xFFFFFFFFFFFFLL) + 0x268LL))(
          v110 & 0xFFFFFFFFFFFFLL,
          &v133,
          v68);
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v61 + 1);
        *(double *)&v69 = *(double *)&v61 + v111 + v112 - v137;
        v70 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v60 + 1);
        *(double *)&v69 = *(double *)&v60 + v113 + v114;
        v71 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v58 + 1);
        *(double *)&v69 = *(double *)&v58 + v115;
        v72 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v70 + 1);
        *(double *)&v69 = *(double *)&v70 * (1.0 / v140);
        v73 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v71 + 1);
        *(double *)&v69 = *(double *)&v71 - v138;
        v74 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v72 + 1);
        *(double *)&v69 = *(double *)&v72 + v116;
        v75 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v74 + 1);
        *(double *)&v69 = *(double *)&v74 * (1.0 / v140);
        v76 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v75 + 1);
        *(double *)&v69 = (*(double *)&v75 - v139) * (1.0 / v140);
        v77 = v69;
        v78 = v135 * *(double *)&v76 - v134 * *(double *)&v69 + v136 * *(double *)&v73;
        v79 = v133 * *(double *)&v69 - v135 * *(double *)&v73 + v136 * *(double *)&v76;
        v80 = v134 * *(double *)&v73 - v133 * *(double *)&v76 + v136 * *(double *)&v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v73 + 1);
        *(double *)&v69 = *(double *)&v73 + v135 * v79 - v134 * v80 + v135 * v79 - v134 * v80;
        _XMM2 = v69;
        __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v76 + 1);
        *(double *)&v69 = *(double *)&v76 + v133 * v80 - v135 * v78 + v133 * v80 - v135 * v78;
        _XMM2 = v69;
        *(float *)&v103 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
        *((float *)&v103 + 1) = *(float *)&_XMM0;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v77 + 1);
        *(double *)&v69 = *(double *)&v77 + v134 * v78 - v133 * v79 + v134 * v78 - v133 * v79;
        _XMM2 = v69;
        __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
        v104 = *(float *)&_XMM0;
        v87 = v135 * v117 - v134 * v118 + v136 * *(double *)v165;
        v88 = v133 * v118 - v135 * *(double *)v165 + v136 * v117;
        v89 = v88 * v135 - (v134 * *(double *)v165 - v133 * v117 + v136 * v118) * v134;
        v90 = (v134 * *(double *)v165 - v133 * v117 + v136 * v118) * v133 - v87 * v135;
        *((_QWORD *)&v69 + 1) = 0;
        *(double *)&v69 = v89 + *(double *)v165 + v89;
        _XMM2 = v69;
        *((_QWORD *)&v69 + 1) = 0;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *(double *)&v69 = v90 + v117 + v90;
        _XMM2 = v69;
        *(float *)&v105 = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *((_QWORD *)&v69 + 1) = 0;
        *(double *)&v69 = v87 * v134 - v88 * v133 + v118 + v87 * v134 - v88 * v133;
        _XMM2 = v69;
        *((float *)&v105 + 1) = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        v106 = *(float *)&_XMM1;
        v97 = (__int64 *)sub_1402A4EC0(a1 + 0xA60);
        v98 = *v97;
        v165[0] = 0;
        (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v98 + 0xA8))(v97, &v103, &v105);
        sub_1440ADD00(a1);
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
          v20 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x720LL))(v20);
        if ( !result && !*(_BYTE *)(a2 + 0xE6) )
        {
          sub_144093F20((__int64)v141);
          v99 = *(_QWORD *)sub_1465E63C0(qword_149FBE618, v165);
          v141[1] = v103;
          v143 = v105;
          v146 = v119;
          v148 = *(__m256 *)&v120[0x20];
          v142 = v104;
          v141[0] = v99;
          v146.m256_f32[4] = 0.0;
          v145 = v102;
          v144 = v106;
          v147 = *(__m256 *)v120;
          __asm { vzeroupper }
          sub_1440BC1C0(v141, v151);
          v100 = sub_143E85E20(a1 + 0xA68, (__int64)v165);
          sub_1440C9550(v100, v141);
          sub_142C8CD20((__int64)v165);
          result = sub_1403A9330(a1, 2u);
          if ( !v161 )
          {
            (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(qword_149C8DF80, 0);
            v121[0] = v17;
            v101 = *(_QWORD *)sub_1465E63C0(qword_149FBE618, v165);
            v123 = v103;
            v125 = v105;
            v127 = v107;
            v128 = v108;
            v124 = v104;
            v129 = 0.1;
            v130 = v109;
            v126 = v106;
            v122 = v101;
            v131 = v37;
            v132 = v149;
            if ( *(float *)&v120[0x20] > 1.1754944e-38
              || *(float *)&v120[0x14] > 1.1754944e-38
              || *(float *)&v120[0x18] > 1.1754944e-38
              || *(float *)&v120[0x1C] > 1.1754944e-38 )
            {
              return sub_1440972A0(a1 + 0x598, (__int64)v121, (__int64)&v120[0x14]);
            }
            else
            {
              return sub_144097190(a1 + 0x538, (__int64)v121);
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1440980A0 (0x1440980A0) ---

// --- Function: sub_1440980A0 (0x14409842D) ---
char __fastcall sub_1440980A0(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm0
  __int128 v3; // xmm12
  __int128 v4; // xmm13
  __int128 v5; // xmm14
  __int128 v6; // xmm15
  char result; // al
  __int128 v11; // kr00_16
  float v12; // xmm0_4
  __int128 n0x3E99999A; // xmm1
  float v14; // xmm6_4
  float v16; // xmm11_4
  unsigned __int8 v17; // r13
  __int64 v19; // r8
  __int64 v20; // rsi
  __int64 v21; // rcx
  __int64 v22; // rax
  float v23; // xmm1_4
  __m128 v24; // xmm2
  __m128 v25; // kr00_16
  float v26; // xmm0_4
  float v27; // xmm1_4
  __m128 v28; // kr00_16
  __m128 v29; // xmm0
  __int64 v30; // rax
  __int64 v31; // r15
  __int64 v32; // rbx
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned int v36; // eax
  unsigned int v37; // r15d
  float v38; // xmm0_4
  float v39; // xmm11_4
  float v40; // xmm0_4
  float v41; // kr00_4
  __int64 v42; // rax
  __int64 v43; // rax
  __int64 v44; // rbx
  __int64 v45; // rax
  double *v46; // rax
  double v47; // xmm14_8
  double v48; // xmm13_8
  double v49; // xmm11_8
  double v50; // xmm12_8
  double v51; // xmm6_8
  double v52; // xmm5_8
  double v53; // xmm4_8
  double v54; // xmm10_8
  double v55; // xmm2_8
  double v56; // xmm5_8
  double v57; // xmm0_8
  __int128 v58; // xmm15
  double v59; // xmm1_8
  __int128 v60; // xmm13
  __int128 v61; // xmm12
  double v62; // xmm7_8
  double v63; // xmm6_8
  double v64; // xmm4_8
  double v65; // xmm5_8
  double v66; // xmm4_8
  double v67; // xmm2_8
  __int64 v68; // r8
  __int128 v69; // kr00_16
  __int128 v70; // xmm2
  __int128 v71; // xmm1
  __int128 v72; // xmm0
  __int128 v73; // xmm8
  __int128 v74; // xmm2
  __int128 v75; // xmm1
  __int128 v76; // xmm9
  __int128 v77; // xmm10
  double v78; // xmm7_8
  double v79; // xmm6_8
  double v80; // xmm4_8
  double v87; // xmm7_8
  double v88; // xmm6_8
  double v89; // xmm5_8
  double v90; // xmm4_8
  __int64 *v97; // rax
  __int64 v98; // rcx
  __int64 v99; // rcx
  __int64 v100; // rax
  __int64 v101; // rcx
  float v102; // [rsp+40h] [rbp-478h]
  __int64 v103; // [rsp+48h] [rbp-470h] BYREF
  float v104; // [rsp+50h] [rbp-468h]
  __int64 v105; // [rsp+58h] [rbp-460h] BYREF
  float v106; // [rsp+60h] [rbp-458h]
  float v107; // [rsp+68h] [rbp-450h]
  float v108; // [rsp+6Ch] [rbp-44Ch]
  float v109; // [rsp+70h] [rbp-448h]
  __int64 v110; // [rsp+78h] [rbp-440h] BYREF
  double v111; // [rsp+80h] [rbp-438h]
  double v112; // [rsp+88h] [rbp-430h]
  double v113; // [rsp+90h] [rbp-428h]
  double v114; // [rsp+98h] [rbp-420h]
  double v115; // [rsp+A0h] [rbp-418h]
  double v116; // [rsp+A8h] [rbp-410h]
  double v117; // [rsp+B0h] [rbp-408h]
  double v118; // [rsp+B8h] [rbp-400h]
  __m256 v119; // [rsp+C0h] [rbp-3F8h] BYREF
  _BYTE v120[64]; // [rsp+E0h] [rbp-3D8h] BYREF
  unsigned __int8 v121[8]; // [rsp+120h] [rbp-398h] BYREF
  __int64 v122; // [rsp+128h] [rbp-390h]
  __int64 v123; // [rsp+130h] [rbp-388h]
  float v124; // [rsp+138h] [rbp-380h]
  __int64 v125; // [rsp+13Ch] [rbp-37Ch]
  float v126; // [rsp+144h] [rbp-374h]
  float v127; // [rsp+148h] [rbp-370h]
  float v128; // [rsp+14Ch] [rbp-36Ch]
  float v129; // [rsp+150h] [rbp-368h]
  float v130; // [rsp+154h] [rbp-364h]
  unsigned int v131; // [rsp+158h] [rbp-360h]
  __int64 v132; // [rsp+160h] [rbp-358h]
  double v133; // [rsp+170h] [rbp-348h] BYREF
  double v134; // [rsp+178h] [rbp-340h]
  double v135; // [rsp+180h] [rbp-338h]
  double v136; // [rsp+188h] [rbp-330h]
  double v137; // [rsp+190h] [rbp-328h]
  double v138; // [rsp+198h] [rbp-320h]
  double v139; // [rsp+1A0h] [rbp-318h]
  double v140; // [rsp+1A8h] [rbp-310h]
  _QWORD v141[2]; // [rsp+1B0h] [rbp-308h] BYREF
  float v142; // [rsp+1C0h] [rbp-2F8h]
  __int64 v143; // [rsp+1C4h] [rbp-2F4h]
  float v144; // [rsp+1CCh] [rbp-2ECh]
  float v145; // [rsp+1E0h] [rbp-2D8h]
  __m256 v146; // [rsp+1E8h] [rbp-2D0h]
  __m256 v147; // [rsp+208h] [rbp-2B0h]
  __m256 v148; // [rsp+228h] [rbp-290h]
  __int64 v149; // [rsp+248h] [rbp-270h]
  _BYTE v150[16]; // [rsp+250h] [rbp-268h] BYREF
  __int64 v151; // [rsp+260h] [rbp-258h]
  _BYTE v152[44]; // [rsp+288h] [rbp-230h] BYREF
  float v153; // [rsp+2B4h] [rbp-204h]
  double v154; // [rsp+2E0h] [rbp-1D8h]
  double v155; // [rsp+2E8h] [rbp-1D0h]
  double v156; // [rsp+2F0h] [rbp-1C8h]
  float v157; // [rsp+2F8h] [rbp-1C0h]
  float v158; // [rsp+2FCh] [rbp-1BCh]
  float v159; // [rsp+300h] [rbp-1B8h]
  unsigned int v160; // [rsp+32Ch] [rbp-18Ch]
  char v161; // [rsp+334h] [rbp-184h]
  char v162; // [rsp+335h] [rbp-183h]
  char v163; // [rsp+336h] [rbp-182h]
  __int128 v164; // [rsp+394h] [rbp-124h]
  _OWORD v165[8]; // [rsp+3B0h] [rbp-108h] BYREF

  result = sub_1403BDE70(a2);
  if ( !result )
  {
    result = sub_14409B0F0(a1);
    if ( result )
    {
      sub_1403BA040(a2, (__int64)v150);
      *(float *)&v2 = sub_1403B1500((__int64)v152, 3);
      v11 = v2;
      *(float *)&v11 = *(float *)&v2 + sub_1403B1500((__int64)v152, 1);
      _XMM10 = v11;
      v12 = sub_1403B1500((__int64)v152, 0);
      n0x3E99999A = 0x3E99999Au;
      v14 = v153;
      __asm { vcmpltss xmm2, xmm10, xmm0 }
      v16 = v12;
      v17 = 0;
      __asm { vblendvps xmm1, xmm1, xmm0, xmm2 }
      v102 = *(float *)&_XMM1;
      if ( v162 )
      {
        v102 = 0.5;
        v17 = 1;
      }
      v20 = 0;
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
        v21 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v21 = 0;
      LOBYTE(v19) = 1;
      v22 = (*(__int64 (__fastcall **)(__int64, _OWORD *, __int64))(*(_QWORD *)v21 + 0x220LL))(v21, v165, v19);
      v23 = *(float *)(v22 + 0xC);
      if ( *(float *)v22 <= v23 )
      {
        v25 = (__m128)*(unsigned int *)(v22 + 0x10);
        v25.m128_f32[0] = *(float *)(v22 + 0x10) - *(float *)(v22 + 4);
        v24 = v25;
        v25.m128_f32[0] = *(float *)(v22 + 0x14) - *(float *)(v22 + 8);
        v26 = (float)(v23 - *(float *)v22) * (float)(v23 - *(float *)v22);
        v27 = v25.m128_f32[0] * v25.m128_f32[0];
        v28 = v24;
        v28.m128_f32[0] = (float)((float)(v24.m128_f32[0] * v24.m128_f32[0]) + v26) + v27;
        v29 = _mm_sqrt_ps(_mm_shuffle_ps(v28, v28, 0));
        _mm_shuffle_ps(v29, v29, 0xFF);
      }
      if ( v14 < 0.00000011920929 )
      {
        v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
        v31 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v30 + 0x10LL))(v30, v160);
        if ( !v31
          || (v32 = sub_1418215F0(qword_149FBE618),
              v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x18LL))(v31),
              sub_14580E2F0(v32, v165, v33),
              !sub_14275AC70((__int64)v165))
          || (v34 = sub_14275AD80((__int64)v165), (v35 = sub_142D1A700(v34)) == 0)
          || (v14 = *(float *)(v35 + 0xC8), v14 < 0.00000011920929) )
        {
          v14 = 0.050000001;
        }
      }
      if ( v163 )
        v36 = sub_1440A42C0(a1);
      else
        v36 = sub_1405722D0((__int64)&qword_149A6A5E0);
      v37 = v36;
      v38 = (float)(unsigned int)((0x343FD * (unsigned __int64)v36 + 0x269EC3) >> 0x10);
      v39 = v16 * (float)((float)(v38 * 2.3283064e-10) + 0.5);
      v40 = (float)(unsigned int)((0x343FD * (0x343FD * (unsigned __int64)v36 + 0x269EC3) + 0x269EC3) >> 0x10);
      v41 = (float)(unsigned int)((0x343FD * (0x343FD * (0x343FD * (unsigned __int64)v36 + 0x269EC3) + 0x269EC3)
                                 + 0x269EC3) >> 0x10);
      v109 = v14 * (float)((float)((float)(v41 * 4.6566129e-11) * 2.0) + 0.80000001);
      v108 = v39;
      v107 = *(float *)&_XMM10 * (float)((float)(v40 * 2.3283064e-10) + 0.5);
      v42 = sub_1402A4EC0(a1 + 0xA60);
      result = (*(__int64 (__fastcall **)(__int64, __m256 *, _QWORD))(*(_QWORD *)v42 + 0xB8LL))(v42, &v119, v17);
      if ( (float)((float)((float)(v119.m256_f32[1] * v119.m256_f32[1]) + (float)(v119.m256_f32[2] * v119.m256_f32[2]))
                 + (float)((float)(v119.m256_f32[3] * v119.m256_f32[3]) + (float)(v119.m256_f32[4] * v119.m256_f32[4]))) >= 0.00000011920929 )
      {
        v165[7] = v3;
        v165[6] = v4;
        v165[5] = v5;
        v165[4] = v6;
        *(_QWORD *)&v120[0x28] = v151;
        *(_OWORD *)&v120[0x14] = v164;
        if ( !*(_BYTE *)(a2 + 0xE6) )
          *(_BYTE *)(a1 + 0xB98) = 0;
        v43 = sub_1402A4EC0(a1 + 0xA60);
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v43 + 0x18LL))(v43, &v110);
        v44 = sub_1403B4280((__int64)v150);
        v45 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v110 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v110 & 0xFFFFFFFFFFFFLL);
        v46 = (double *)(*(__int64 (__fastcall **)(__int64, _OWORD *, __int64, __int64))(*(_QWORD *)qword_149C8DF28
                                                                                       + 0x480LL))(
                          qword_149C8DF28,
                          v165,
                          v44,
                          v45);
        v47 = v46[2];
        v48 = v46[1];
        v49 = v46[3];
        v50 = *v46;
        v112 = v46[4];
        v114 = v46[5];
        v116 = v46[6];
        v51 = v48 * v156 - v47 * v155 + v49 * v154;
        v52 = v47 * v154 - v50 * v156 + v49 * v155;
        v53 = v50 * v155 - v48 * v154 + v49 * v156;
        v54 = v48 * v53 - v47 * v52;
        v55 = v50 * v52;
        v56 = v46[1];
        v57 = v55 - v48 * v51;
        v58 = COERCE_UNSIGNED_INT64(v156 + v57);
        v59 = v47 * v51 - v50 * v53;
        v60 = COERCE_UNSIGNED_INT64(v155 + v59);
        v61 = COERCE_UNSIGNED_INT64(v154 + v54);
        v113 = v59;
        v111 = v54;
        v115 = v57;
        v62 = v159 * v56 - v158 * v47 + v157 * v49;
        v63 = v157 * v47 - v159 * *v46 + v158 * v49;
        v64 = v158 * *v46 - v157 * v56 + v159 * v49;
        v65 = v56 * v64 - v47 * v63;
        v66 = v47 * v62 - v64 * *v46;
        v67 = v63 * *v46 - v62 * v46[1];
        *(double *)v165 = v157 + v65 + v65;
        v117 = v158 + v66 + v66;
        LOBYTE(v68) = 1;
        v118 = v159 + v67 + v67;
        (*(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)(v110 & 0xFFFFFFFFFFFFLL) + 0x268LL))(
          v110 & 0xFFFFFFFFFFFFLL,
          &v133,
          v68);
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v61 + 1);
        *(double *)&v69 = *(double *)&v61 + v111 + v112 - v137;
        v70 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v60 + 1);
        *(double *)&v69 = *(double *)&v60 + v113 + v114;
        v71 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v58 + 1);
        *(double *)&v69 = *(double *)&v58 + v115;
        v72 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v70 + 1);
        *(double *)&v69 = *(double *)&v70 * (1.0 / v140);
        v73 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v71 + 1);
        *(double *)&v69 = *(double *)&v71 - v138;
        v74 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v72 + 1);
        *(double *)&v69 = *(double *)&v72 + v116;
        v75 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v74 + 1);
        *(double *)&v69 = *(double *)&v74 * (1.0 / v140);
        v76 = v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v75 + 1);
        *(double *)&v69 = (*(double *)&v75 - v139) * (1.0 / v140);
        v77 = v69;
        v78 = v135 * *(double *)&v76 - v134 * *(double *)&v69 + v136 * *(double *)&v73;
        v79 = v133 * *(double *)&v69 - v135 * *(double *)&v73 + v136 * *(double *)&v76;
        v80 = v134 * *(double *)&v73 - v133 * *(double *)&v76 + v136 * *(double *)&v69;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v73 + 1);
        *(double *)&v69 = *(double *)&v73 + v135 * v79 - v134 * v80 + v135 * v79 - v134 * v80;
        _XMM2 = v69;
        __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v76 + 1);
        *(double *)&v69 = *(double *)&v76 + v133 * v80 - v135 * v78 + v133 * v80 - v135 * v78;
        _XMM2 = v69;
        *(float *)&v103 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
        *((float *)&v103 + 1) = *(float *)&_XMM0;
        *((_QWORD *)&v69 + 1) = *((_QWORD *)&v77 + 1);
        *(double *)&v69 = *(double *)&v77 + v134 * v78 - v133 * v79 + v134 * v78 - v133 * v79;
        _XMM2 = v69;
        __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
        v104 = *(float *)&_XMM0;
        v87 = v135 * v117 - v134 * v118 + v136 * *(double *)v165;
        v88 = v133 * v118 - v135 * *(double *)v165 + v136 * v117;
        v89 = v88 * v135 - (v134 * *(double *)v165 - v133 * v117 + v136 * v118) * v134;
        v90 = (v134 * *(double *)v165 - v133 * v117 + v136 * v118) * v133 - v87 * v135;
        *((_QWORD *)&v69 + 1) = 0;
        *(double *)&v69 = v89 + *(double *)v165 + v89;
        _XMM2 = v69;
        *((_QWORD *)&v69 + 1) = 0;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *(double *)&v69 = v90 + v117 + v90;
        _XMM2 = v69;
        *(float *)&v105 = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *((_QWORD *)&v69 + 1) = 0;
        *(double *)&v69 = v87 * v134 - v88 * v133 + v118 + v87 * v134 - v88 * v133;
        _XMM2 = v69;
        *((float *)&v105 + 1) = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        v106 = *(float *)&_XMM1;
        v97 = (__int64 *)sub_1402A4EC0(a1 + 0xA60);
        v98 = *v97;
        v165[0] = 0;
        (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v98 + 0xA8))(v97, &v103, &v105);
        sub_1440ADD00(a1);
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
          v20 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x720LL))(v20);
        if ( !result && !*(_BYTE *)(a2 + 0xE6) )
        {
          sub_144093F20((__int64)v141);
          v99 = *(_QWORD *)sub_1465E63C0(qword_149FBE618, v165);
          v141[1] = v103;
          v143 = v105;
          v146 = v119;
          v148 = *(__m256 *)&v120[0x20];
          v142 = v104;
          v141[0] = v99;
          v146.m256_f32[4] = 0.0;
          v145 = v102;
          v144 = v106;
          v147 = *(__m256 *)v120;
          __asm { vzeroupper }
          sub_1440BC1C0(v141, v151);
          v100 = sub_143E85E20(a1 + 0xA68, (__int64)v165);
          sub_1440C9550(v100, v141);
          sub_142C8CD20((__int64)v165);
          result = sub_1403A9330(a1, 2u);
          if ( !v161 )
          {
            (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(qword_149C8DF80, 0);
            v121[0] = v17;
            v101 = *(_QWORD *)sub_1465E63C0(qword_149FBE618, v165);
            v123 = v103;
            v125 = v105;
            v127 = v107;
            v128 = v108;
            v124 = v104;
            v129 = 0.1;
            v130 = v109;
            v126 = v106;
            v122 = v101;
            v131 = v37;
            v132 = v149;
            if ( *(float *)&v120[0x20] > 1.1754944e-38
              || *(float *)&v120[0x14] > 1.1754944e-38
              || *(float *)&v120[0x18] > 1.1754944e-38
              || *(float *)&v120[0x1C] > 1.1754944e-38 )
            {
              return sub_1440972A0(a1 + 0x598, (__int64)v121, (__int64)&v120[0x14]);
            }
            else
            {
              return sub_144097190(a1 + 0x538, (__int64)v121);
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1440980A0 (0x14409842D) ---

// --- Function: sub_14409B0F0 (0x14409B0F0) ---
bool __fastcall sub_14409B0F0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  unsigned __int64 *v3; // rax
  char v5; // [rsp+30h] [rbp+8h] BYREF

  if ( *(char *)(a1 + 0xB40) >= 0 )
    return 0;
  v1 = a1 + 0xA60;
  if ( !sub_1402A4EC0(a1 + 0xA60) )
    return 0;
  v2 = sub_1402A4EC0(v1);
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v2 + 0x18LL))(v2, &v5);
  return is_entity_descriptor_valid_or_accessible(v3);
}

// --- End Function: sub_14409B0F0 (0x14409B0F0) ---

// --- Function: sub_1440A0460 (0x1440A0460) ---
__int64 __fastcall sub_1440A0460(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v5; // [rsp+34h] [rbp-B4h]
  __int64 v6; // [rsp+40h] [rbp-A8h]
  ULONG_PTR Parameter; // [rsp+58h] [rbp-90h] BYREF
  __int64 v8; // [rsp+60h] [rbp-88h]
  __int64 v9; // [rsp+68h] [rbp-80h]
  __int64 (__fastcall *p_sub_1440C6D90)(); // [rsp+70h] [rbp-78h]
  __int64 *v11; // [rsp+78h] [rbp-70h]
  __int64 v12; // [rsp+80h] [rbp-68h]
  __int64 (__fastcall **p_p_sub_1440C6D90)(); // [rsp+88h] [rbp-60h]
  __int64 v14; // [rsp+90h] [rbp-58h]
  __int64 (__fastcall *v15)(__int64, _QWORD, __int64, __int64, _BYTE *, __int64); // [rsp+98h] [rbp-50h]
  char v16[8]; // [rsp+A0h] [rbp-48h] BYREF
  __int64 *v17; // [rsp+A8h] [rbp-40h]
  _BYTE v18[16]; // [rsp+B0h] [rbp-38h] BYREF
  __int64 (__fastcall *p_sub_1440C6D90_1)(); // [rsp+C0h] [rbp-28h] BYREF
  __int64 v20; // [rsp+C8h] [rbp-20h] BYREF
  __int64 v21; // [rsp+D0h] [rbp-18h] BYREF

  v6 = ((__int64)(*(_QWORD *)(a1 + 0x20) << 0x10) >> 0x10) & 0xFFFFFFFFFFFFLL;
  if ( !v6 )
    return 1;
  sub_14035DAC0(&Parameter);
  Parameter = (ULONG_PTR)&off_1482C5768;
  v8 = 0;
  sub_14408B9A0(&Parameter, a4);
  v14 = v8;
  p_sub_1440C6D90 = sub_1440C6D90;
  v15 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _BYTE *, __int64))(*(_QWORD *)v6 + 8LL);
  v12 = sub_1402A4D50((__int64)v16);
  v9 = a4;
  p_sub_1440C6D90_1 = p_sub_1440C6D90;
  sub_1402A4D50((__int64)&v20);
  v11 = &v20;
  v20 = a4;
  v17 = &v21;
  p_p_sub_1440C6D90 = &p_sub_1440C6D90_1;
  sub_142D18130(v18, &p_sub_1440C6D90_1, v12);
  v5 = v15(v6, *(_WORD *)(a1 + 0x28) & 0x3FFF, a3, v14, v18, a2);
  sub_1402A53D0(v16);
  _StarEngineModule__((ULONG_PTR)&Parameter);
  return v5;
}

// --- End Function: sub_1440A0460 (0x1440A0460) ---

// --- Function: sub_1440A0660 (0x1440A0660) ---
__int64 __fastcall sub_1440A0660(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned int v6; // [rsp+40h] [rbp-D8h]
  __int64 v7; // [rsp+48h] [rbp-D0h]
  ULONG_PTR Parameter; // [rsp+50h] [rbp-C8h] BYREF
  __int64 v9; // [rsp+58h] [rbp-C0h]
  __int64 v10; // [rsp+60h] [rbp-B8h] BYREF
  _QWORD v11[4]; // [rsp+68h] [rbp-B0h] BYREF
  __int64 (__fastcall *p_sub_1440C6DD0)(); // [rsp+88h] [rbp-90h]
  __int64 *v13; // [rsp+90h] [rbp-88h]
  __int64 *v14; // [rsp+98h] [rbp-80h]
  __int64 *v15; // [rsp+A0h] [rbp-78h]
  __int64 *v16; // [rsp+A8h] [rbp-70h]
  __int64 v17; // [rsp+B0h] [rbp-68h]
  __int64 (__fastcall **p_p_sub_1440C6DD0)(); // [rsp+B8h] [rbp-60h]
  __int64 v19; // [rsp+C0h] [rbp-58h]
  __int64 (__fastcall *v20)(__int64, _QWORD, __int64, __int64, _BYTE *, __int64); // [rsp+C8h] [rbp-50h]
  char v21[8]; // [rsp+D0h] [rbp-48h] BYREF
  __int64 *v22; // [rsp+D8h] [rbp-40h]
  _BYTE v23[16]; // [rsp+E0h] [rbp-38h] BYREF
  __int64 (__fastcall *p_sub_1440C6DD0_1)(); // [rsp+F0h] [rbp-28h] BYREF
  __int64 v25; // [rsp+F8h] [rbp-20h] BYREF
  __int64 v26; // [rsp+100h] [rbp-18h] BYREF
  __int64 v27; // [rsp+108h] [rbp-10h] BYREF

  v7 = ((__int64)(*(_QWORD *)(a1 + 0x20) << 0x10) >> 0x10) & 0xFFFFFFFFFFFFLL;
  if ( !v7 )
    return 1;
  sub_14035DAC0(&Parameter);
  Parameter = (ULONG_PTR)&off_1482C5768;
  v9 = 0;
  sub_14408B9A0((Parameter **)&Parameter, a4);
  sub_14408B810(&Parameter, a5);
  v19 = v9;
  p_sub_1440C6DD0 = sub_1440C6DD0;
  v20 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _BYTE *, __int64))(*(_QWORD *)v7 + 8LL);
  v17 = sub_1402A4D50((__int64)v21);
  v11[2] = a5;
  v10 = a5;
  v13 = &v10;
  v11[3] = a4;
  v11[0] = a4;
  v15 = v11;
  v11[1] = &p_sub_1440C6DD0_1;
  p_sub_1440C6DD0_1 = p_sub_1440C6DD0;
  sub_1402A4D50((__int64)&v25);
  v14 = &v25;
  v25 = *v13;
  v16 = &v26;
  v26 = *v15;
  v22 = &v27;
  p_p_sub_1440C6DD0 = &p_sub_1440C6DD0_1;
  sub_1431F6BB0(v23, &p_sub_1440C6DD0_1, v17);
  v6 = v20(v7, *(_WORD *)(a1 + 0x28) & 0x3FFF, a3, v19, v23, a2);
  sub_1402A53D0(v21);
  _StarEngineModule__((ULONG_PTR)&Parameter);
  return v6;
}

// --- End Function: sub_1440A0660 (0x1440A0660) ---

// --- Function: sub_1440A3890 (0x1440A3890) ---
char __fastcall sub_1440A3890(__int64 a1, unsigned __int8 *a2, _OWORD *a3, __int64 a4)
{
  _OWORD *v8; // rax
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rax
  float v12; // xmm1_4
  __m128 v13; // xmm2
  __m128 v14; // kr00_16
  float v15; // xmm0_4
  float v16; // xmm1_4
  __m128 v17; // kr00_16
  __m128 v18; // xmm0
  __int64 v19; // rax
  __m256i v20; // ymm1
  __m256i v21; // ymm0
  __m256i v22; // ymm0
  __m256 v24; // [rsp+40h] [rbp-138h] BYREF
  _BYTE v25[64]; // [rsp+60h] [rbp-118h]
  char v26[24]; // [rsp+A0h] [rbp-D8h] BYREF
  char v27[168]; // [rsp+B8h] [rbp-C0h] BYREF

  v8 = (_OWORD *)sub_1402A4EC0(a1 + 0xA60);
  if ( v8 )
  {
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
      v10 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v10 = 0;
    LOBYTE(v9) = 1;
    v11 = (*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v10 + 0x220LL))(v10, v26, v9);
    v12 = *(float *)(v11 + 0xC);
    if ( *(float *)v11 <= v12 )
    {
      v14 = (__m128)*(unsigned int *)(v11 + 0x10);
      v14.m128_f32[0] = *(float *)(v11 + 0x10) - *(float *)(v11 + 4);
      v13 = v14;
      v14.m128_f32[0] = *(float *)(v11 + 0x14) - *(float *)(v11 + 8);
      v15 = (float)(v12 - *(float *)v11) * (float)(v12 - *(float *)v11);
      v16 = v14.m128_f32[0] * v14.m128_f32[0];
      v17 = v13;
      v17.m128_f32[0] = (float)((float)(v13.m128_f32[0] * v13.m128_f32[0]) + v15) + v16;
      v18 = _mm_sqrt_ps(_mm_shuffle_ps(v17, v17, 0));
      _mm_shuffle_ps(v18, v18, 0xFF);
    }
    v19 = sub_1402A4EC0(a1 + 0xA60);
    (*(void (__fastcall **)(__int64, __m256 *, _QWORD))(*(_QWORD *)v19 + 0xB8LL))(v19, &v24, *a2);
    *(_OWORD *)&v25[0x14] = *a3;
    v8 = (_OWORD *)sub_144093F20((__int64)v27);
    *(_OWORD *)a4 = *v8;
    *(_OWORD *)(a4 + 0x10) = v8[1];
    *(_OWORD *)(a4 + 0x20) = v8[2];
    *(_OWORD *)(a4 + 0x30) = v8[3];
    *(_OWORD *)(a4 + 0x40) = v8[4];
    *(_OWORD *)(a4 + 0x50) = v8[5];
    *(_OWORD *)(a4 + 0x60) = v8[6];
    *(_OWORD *)(a4 + 0x70) = v8[7];
    *(_OWORD *)(a4 + 0x80) = v8[8];
    v20 = *(__m256i *)v25;
    *(_OWORD *)(a4 + 0x90) = v8[9];
    *(_QWORD *)a4 = *((_QWORD *)a2 + 1);
    *(double *)(a4 + 8) = *((double *)a2 + 2);
    *(_DWORD *)(a4 + 0x10) = *((_DWORD *)a2 + 6);
    *(double *)(a4 + 0x14) = *(double *)(a2 + 0x1C);
    v21 = (__m256i)v24;
    *(_DWORD *)(a4 + 0x1C) = *((_DWORD *)a2 + 9);
    LODWORD(v8) = *((_DWORD *)a2 + 0xC);
    *(__m256i *)(a4 + 0x38) = v21;
    v22 = *(__m256i *)&v25[0x20];
    *(__m256i *)(a4 + 0x58) = v20;
    *(__m256i *)(a4 + 0x78) = v22;
    *(_DWORD *)(a4 + 0x30) = (_DWORD)v8;
    *(_DWORD *)(a4 + 0x48) = 0;
    *(_QWORD *)(a4 + 0x98) = *((_QWORD *)a2 + 8);
    LOBYTE(v8) = 1;
  }
  __asm { vzeroupper }
  return (char)v8;
}

// --- End Function: sub_1440A3890 (0x1440A3890) ---

// --- Function: sub_1440A3890 (0x1440A39AE) ---
char __fastcall sub_1440A3890(__int64 a1, unsigned __int8 *a2, _OWORD *a3, __int64 a4)
{
  _OWORD *v8; // rax
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rax
  float v12; // xmm1_4
  __m128 v13; // xmm2
  __m128 v14; // kr00_16
  float v15; // xmm0_4
  float v16; // xmm1_4
  __m128 v17; // kr00_16
  __m128 v18; // xmm0
  __int64 v19; // rax
  __m256i v20; // ymm1
  __m256i v21; // ymm0
  __m256i v22; // ymm0
  __m256 v24; // [rsp+40h] [rbp-138h] BYREF
  _BYTE v25[64]; // [rsp+60h] [rbp-118h]
  char v26[24]; // [rsp+A0h] [rbp-D8h] BYREF
  char v27[168]; // [rsp+B8h] [rbp-C0h] BYREF

  v8 = (_OWORD *)sub_1402A4EC0(a1 + 0xA60);
  if ( v8 )
  {
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
      v10 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v10 = 0;
    LOBYTE(v9) = 1;
    v11 = (*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v10 + 0x220LL))(v10, v26, v9);
    v12 = *(float *)(v11 + 0xC);
    if ( *(float *)v11 <= v12 )
    {
      v14 = (__m128)*(unsigned int *)(v11 + 0x10);
      v14.m128_f32[0] = *(float *)(v11 + 0x10) - *(float *)(v11 + 4);
      v13 = v14;
      v14.m128_f32[0] = *(float *)(v11 + 0x14) - *(float *)(v11 + 8);
      v15 = (float)(v12 - *(float *)v11) * (float)(v12 - *(float *)v11);
      v16 = v14.m128_f32[0] * v14.m128_f32[0];
      v17 = v13;
      v17.m128_f32[0] = (float)((float)(v13.m128_f32[0] * v13.m128_f32[0]) + v15) + v16;
      v18 = _mm_sqrt_ps(_mm_shuffle_ps(v17, v17, 0));
      _mm_shuffle_ps(v18, v18, 0xFF);
    }
    v19 = sub_1402A4EC0(a1 + 0xA60);
    (*(void (__fastcall **)(__int64, __m256 *, _QWORD))(*(_QWORD *)v19 + 0xB8LL))(v19, &v24, *a2);
    *(_OWORD *)&v25[0x14] = *a3;
    v8 = (_OWORD *)sub_144093F20((__int64)v27);
    *(_OWORD *)a4 = *v8;
    *(_OWORD *)(a4 + 0x10) = v8[1];
    *(_OWORD *)(a4 + 0x20) = v8[2];
    *(_OWORD *)(a4 + 0x30) = v8[3];
    *(_OWORD *)(a4 + 0x40) = v8[4];
    *(_OWORD *)(a4 + 0x50) = v8[5];
    *(_OWORD *)(a4 + 0x60) = v8[6];
    *(_OWORD *)(a4 + 0x70) = v8[7];
    *(_OWORD *)(a4 + 0x80) = v8[8];
    v20 = *(__m256i *)v25;
    *(_OWORD *)(a4 + 0x90) = v8[9];
    *(_QWORD *)a4 = *((_QWORD *)a2 + 1);
    *(double *)(a4 + 8) = *((double *)a2 + 2);
    *(_DWORD *)(a4 + 0x10) = *((_DWORD *)a2 + 6);
    *(double *)(a4 + 0x14) = *(double *)(a2 + 0x1C);
    v21 = (__m256i)v24;
    *(_DWORD *)(a4 + 0x1C) = *((_DWORD *)a2 + 9);
    LODWORD(v8) = *((_DWORD *)a2 + 0xC);
    *(__m256i *)(a4 + 0x38) = v21;
    v22 = *(__m256i *)&v25[0x20];
    *(__m256i *)(a4 + 0x58) = v20;
    *(__m256i *)(a4 + 0x78) = v22;
    *(_DWORD *)(a4 + 0x30) = (_DWORD)v8;
    *(_DWORD *)(a4 + 0x48) = 0;
    *(_QWORD *)(a4 + 0x98) = *((_QWORD *)a2 + 8);
    LOBYTE(v8) = 1;
  }
  __asm { vzeroupper }
  return (char)v8;
}

// --- End Function: sub_1440A3890 (0x1440A39AE) ---

// --- Function: sub_1440A42C0 (0x1440A42C0) ---
__int64 __fastcall sub_1440A42C0(unsigned __int64 *a1)
{
  __int64 result; // rax
  struct __crt_locale_pointers *LocaleT; // rax
  __int64 v4; // rax
  unsigned int v5; // ebx
  __int128 v6; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v7[24]; // [rsp+30h] [rbp-28h] BYREF

  if ( sub_1415770C0((__int64)(a1 + 0xC7), 0) )
    return LODWORD(_LocaleUpdate::GetLocaleT((_LocaleUpdate *)(a1 + 0xC7))->locinfo);
  LocaleT = _LocaleUpdate::GetLocaleT((_LocaleUpdate *)(a1 + 0xCB));
  if ( !LocaleT->locinfo && !LocaleT->mbcinfo )
  {
    v4 = sub_140335FE0((__int64)a1);
    sub_140365980((__int64)&v6, (_QWORD *)(v4 + 0x30));
    if ( __crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid(&v6)
      && *(_DWORD *)(unknown_libname_485((__int64)&v6) + 8) != 0xFFFFFFFF )
    {
      v5 = *(_DWORD *)(unknown_libname_485((__int64)&v6) + 8);
      sub_140373E10((__int64)&v6);
      return v5;
    }
    sub_140373E10((__int64)&v6);
    goto LABEL_11;
  }
  v6 = (__int128)*_LocaleUpdate::GetLocaleT((_LocaleUpdate *)(a1 + 0xCB));
  sub_142925110((__int64)v7, &v6);
  if ( !sub_14275AC70((__int64)v7)
    || (result = *(unsigned int *)(sub_14275AD80((__int64)v7) + 0x10), (_DWORD)result == 0xFFFFFFFF) )
  {
LABEL_11:
    sub_1403B43F0(a1 + 1, &v6);
    return (unsigned int)v6;
  }
  return result;
}

// --- End Function: sub_1440A42C0 (0x1440A42C0) ---

// --- Function: sub_1440A8090 (0x1440A8090) ---
// attributes: thunk
char __fastcall sub_1440A8090(__int64 a1, __int64 a2)
{
  return sub_1440980A0(a1, a2);
}

// --- End Function: sub_1440A8090 (0x1440A8090) ---

// --- Function: sub_1440ABB50 (0x1440ABB9F) ---
void __fastcall sub_1440ABB50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  ULONG_PTR Parameter[2]; // [rsp+20h] [rbp-68h] BYREF
  _BYTE v5[88]; // [rsp+30h] [rbp-58h] BYREF

  sub_1403624C0(Parameter, a3);
  v3 = sub_144094C20((__int64)v5);
  sub_1440870C0(a1, a2, (__int64)Parameter, v3);
  _StarEngineModule__((ULONG_PTR)Parameter);
}

// --- End Function: sub_1440ABB50 (0x1440ABB9F) ---

// --- Function: sub_1440ABE10 (0x1440ABE2D) ---
char __fastcall sub_1440ABE10(__int64 a1, __int64 a2)
{
  return sub_1440A8090(a1, a2);
}

// --- End Function: sub_1440ABE10 (0x1440ABE2D) ---

// --- Function: sub_1440ADD00 (0x1440ADD00) ---
__int64 __fastcall sub_1440ADD00(__int64 a1, float a2)
{
  float v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) )
  {
    if ( *(float *)(a1 + 0x9E0) == -666.0 )
      *(float *)(a1 + 0x9E0) = v4;
    else
      *(float *)(a1 + 0x9E0) = *sub_14035C9A0(&v4, (float *)(a1 + 0x9E0));
  }
  sub_1403A9330(a1, 3u);
  return sub_1403A9330(a1, 4u);
}

// --- End Function: sub_1440ADD00 (0x1440ADD00) ---

// --- Function: sub_1440BA660 (0x1440BA660) ---
__int64 __fastcall sub_1440BA660(__int64 a1, __int64 a2, __int64 a3)
{
  float *v5; // rax
  float *v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rax
  __int64 *v10[4]; // [rsp+20h] [rbp-88h] BYREF
  _BYTE v11[32]; // [rsp+40h] [rbp-68h] BYREF
  _BYTE v12[32]; // [rsp+60h] [rbp-48h] BYREF
  __int64 v13[4]; // [rsp+80h] [rbp-28h] BYREF

  sub_143E85E20(a1 + 0xA68, (__int64)v10);
  initialize_and_acquire_context_lock(a1 + 0xAA8, (__int64)v12);
  if ( !sub_143E6BD90((__int64)v10)
    && sub_14372C530((__int64)v12)
    && (v5 = (float *)sub_1440C8F80(v10), v6 = v5, *(_QWORD *)v5 == *(_QWORD *)a3)
    && std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>((_QWORD *)v5 + 0x13, (_QWORD *)(a3 + 0x98))
    && fabs(v6[0xF] - *(float *)(a3 + 0x3C)) <= 0.00000011920929 )
  {
    v7 = sub_143E68B00(v10, v13);
    sub_1440C89C0(v10, v11, v7);
  }
  else
  {
    v8 = initialize_and_acquire_context_lock(a1 + 0xAA8, (__int64)v11);
    sub_1440C9590(v8, a3);
    sub_142C8CD20((__int64)v11);
    sub_1403A9330(a1, 2u);
  }
  sub_142C8CD20((__int64)v12);
  return sub_142C8CD20((__int64)v10);
}

// --- End Function: sub_1440BA660 (0x1440BA660) ---

// --- Function: sub_1440BA790 (0x1440BA857) ---
char __fastcall sub_1440BA790(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  char result; // al
  __int128 v7; // [rsp+20h] [rbp-B8h] BYREF
  __int64 v8; // [rsp+30h] [rbp-A8h] BYREF
  float v9; // [rsp+38h] [rbp-A0h]
  float v10; // [rsp+3Ch] [rbp-9Ch]
  __int128 v11; // [rsp+40h] [rbp-98h]
  __int128 v12; // [rsp+50h] [rbp-88h]
  float v13; // [rsp+60h] [rbp-78h]
  float v14; // [rsp+6Ch] [rbp-6Ch]
  __int128 v15; // [rsp+70h] [rbp-68h]
  __int128 v16; // [rsp+80h] [rbp-58h]
  __m256i v17; // [rsp+90h] [rbp-48h]
  __int64 v18; // [rsp+B0h] [rbp-28h]
  float v19; // [rsp+B8h] [rbp-20h]
  float v20; // [rsp+BCh] [rbp-1Ch]
  float v21; // [rsp+C0h] [rbp-18h]
  int v22; // [rsp+C4h] [rbp-14h]
  __int64 v23; // [rsp+C8h] [rbp-10h]

  v9 = 0.0;
  v10 = 0.0;
  v13 = 0.0;
  v14 = 0.0;
  v11 = 0;
  v15 = 0;
  v8 = 0;
  v12 = 0;
  v17 = (__m256i)ymmword_1489FCA60;
  v19 = 0.0;
  v20 = 0.0;
  v21 = 0.0;
  v16 = 0;
  v18 = 0;
  v22 = 0;
  __asm { vzeroupper }
  v23 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                     qword_149C8DF80,
                     0);
  v7 = xmmword_148341EA0;
  result = sub_1440A3890(a1, a3, &v7, (__int64)&v8);
  if ( result )
    return sub_1440BA660(a1, a2, (__int64)&v8);
  return result;
}

// --- End Function: sub_1440BA790 (0x1440BA857) ---

// --- Function: sub_1440BC1C0 (0x1440BC1C0) ---
unsigned __int8 __fastcall sub_1440BC1C0(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v3; // rax
  unsigned __int8 result; // al
  __int64 v5; // rax
  double v6; // xmm0_8
  _QWORD v7[3]; // [rsp+20h] [rbp-18h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  __int64 v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( is_entity_descriptor_valid_or_accessible(&v8) )
    v3 = sub_14262C950(v8 & 0xFFFFFFFFFFFFLL, &v10);
  else
    sub_1402B3CF0(v7);
  std::_Iterator_base12::operator=(&v9, v3);
  result = is_valid_handle_typeA(&v9);
  if ( result )
  {
    v5 = sub_1403115A0(&v9);
    v6 = sub_145D67060(v5);
    v10 = (unsigned int)(int)(float)(*(float *)&v6 * 10000000.0);
    return (unsigned __int8)sub_14059CB30((_QWORD *)(a1 + 0x98), &v10);
  }
  return result;
}

// --- End Function: sub_1440BC1C0 (0x1440BC1C0) ---

// --- Function: sub_1440C89C0 (0x1440C89C0) ---
__int64 __fastcall sub_1440C89C0(__int64 *a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+28h] [rbp-30h]
  __int64 v5; // [rsp+30h] [rbp-28h]
  _QWORD v6[4]; // [rsp+38h] [rbp-20h] BYREF

  v5 = *a1;
  v4 = sub_142FC53C0(v6, a3);
  sub_1440C8DD0(v5, a2, v4);
  return a2;
}

// --- End Function: sub_1440C89C0 (0x1440C89C0) ---

// --- Function: sub_1440C8A20 (0x1440C8A20) ---
_QWORD *__fastcall sub_1440C8A20(__int64 *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v5; // [rsp+20h] [rbp-238h]
  unsigned __int64 v6; // [rsp+28h] [rbp-230h]
  _QWORD v7[2]; // [rsp+30h] [rbp-228h] BYREF
  __int64 v8; // [rsp+40h] [rbp-218h]
  __int64 v9[2]; // [rsp+48h] [rbp-210h] BYREF
  __int64 v10; // [rsp+58h] [rbp-200h]
  __int64 *v11; // [rsp+60h] [rbp-1F8h]
  __int64 v12; // [rsp+68h] [rbp-1F0h]
  _QWORD *v13; // [rsp+70h] [rbp-1E8h]
  _QWORD *v14; // [rsp+78h] [rbp-1E0h]
  __int64 v15; // [rsp+80h] [rbp-1D8h]
  __int64 *v16; // [rsp+88h] [rbp-1D0h]
  __int64 *v17; // [rsp+90h] [rbp-1C8h]
  __int64 v18; // [rsp+98h] [rbp-1C0h]
  _QWORD *v19; // [rsp+A0h] [rbp-1B8h]
  _QWORD *v20; // [rsp+A8h] [rbp-1B0h]
  __int64 *v21; // [rsp+B0h] [rbp-1A8h]
  _QWORD *v22; // [rsp+B8h] [rbp-1A0h]
  _QWORD *v23; // [rsp+C0h] [rbp-198h]
  __int64 *v24; // [rsp+C8h] [rbp-190h]
  _QWORD *v25; // [rsp+D0h] [rbp-188h]
  _BYTE *v26; // [rsp+D8h] [rbp-180h]
  _QWORD *v27; // [rsp+E0h] [rbp-178h]
  _QWORD *v28; // [rsp+E8h] [rbp-170h]
  __int64 v29; // [rsp+F0h] [rbp-168h]
  _QWORD *v30; // [rsp+F8h] [rbp-160h]
  __int64 *v31; // [rsp+100h] [rbp-158h]
  _QWORD *v32; // [rsp+108h] [rbp-150h]
  _QWORD *v33; // [rsp+110h] [rbp-148h]
  _QWORD v34[3]; // [rsp+118h] [rbp-140h] BYREF
  _QWORD v35[3]; // [rsp+130h] [rbp-128h] BYREF
  __int64 v36[3]; // [rsp+148h] [rbp-110h] BYREF
  _BYTE v37[24]; // [rsp+160h] [rbp-F8h] BYREF
  _QWORD v38[3]; // [rsp+178h] [rbp-E0h] BYREF
  _QWORD v39[3]; // [rsp+190h] [rbp-C8h] BYREF
  __int64 v40[3]; // [rsp+1A8h] [rbp-B0h] BYREF
  _BYTE v41[24]; // [rsp+1C0h] [rbp-98h] BYREF
  _QWORD v42[3]; // [rsp+1D8h] [rbp-80h] BYREF
  _BYTE v43[24]; // [rsp+1F0h] [rbp-68h] BYREF
  _QWORD v44[3]; // [rsp+208h] [rbp-50h] BYREF
  _BYTE v45[24]; // [rsp+220h] [rbp-38h] BYREF
  __int64 v46[4]; // [rsp+238h] [rbp-20h] BYREF

  v32 = v34;
  v33 = sub_142FC53C0(v34, a3);
  v11 = a1;
  v12 = v33[2];
  std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base12>(
    v7,
    v12,
    a1);
  v13 = v35;
  v14 = sub_142FC53C0(v35, a4);
  v16 = a1;
  v15 = v14[2];
  sub_1402B3D20(v9);
  v10 = v15;
  sub_1402E0C10(v9, v16);
  v17 = sub_143456070(a1, v36);
  v6 = v8 - v17[2];
  v5 = v10 - v8;
  if ( v10 == v8 )
  {
    sub_1402B3D00(a2, v7);
    a2[2] = v8;
    return a2;
  }
  else
  {
    v18 = sub_143456C40(a1, v37);
    if ( v6 >= *(_QWORD *)(v18 + 0x10) - v10 )
    {
      v25 = v42;
      v28 = sub_142FC53C0(v42, v7);
      v26 = v43;
      v29 = sub_143456C40(a1, v43);
      v27 = v44;
      v30 = sub_142FC53C0(v44, v9);
      sub_1440916C0(v45, v30, v29, v28);
      while ( v5 )
      {
        sub_1440C9370(a1);
        --v5;
      }
    }
    else
    {
      v19 = v38;
      v22 = sub_142FC53C0(v38, v9);
      v20 = v39;
      v23 = sub_142FC53C0(v39, v7);
      v21 = v40;
      v24 = sub_143456070(a1, v40);
      sub_144091A40(v41, v24, v23, v22);
      while ( v5 )
      {
        sub_1440C9420(a1);
        --v5;
      }
    }
    v31 = sub_143456070(a1, v46);
    sub_142FC53C0(a2, v31);
    a2[2] += v6;
    return a2;
  }
}

// --- End Function: sub_1440C8A20 (0x1440C8A20) ---

// --- Function: sub_1440C8DD0 (0x1440C8DD0) ---
_QWORD *__fastcall sub_1440C8DD0(__int64 *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // [rsp+20h] [rbp-88h]
  _QWORD *v5; // [rsp+48h] [rbp-60h]
  _QWORD v6[3]; // [rsp+50h] [rbp-58h] BYREF
  _QWORD v7[3]; // [rsp+68h] [rbp-40h] BYREF
  _QWORD v8[5]; // [rsp+80h] [rbp-28h] BYREF

  v4 = sub_142FC53C0(v7, a3);
  ++v4[2];
  sub_142FC53C0(v6, v4);
  v5 = sub_142FC53C0(v8, a3);
  sub_1440C8A20(a1, a2, v5, v6);
  return a2;
}

// --- End Function: sub_1440C8DD0 (0x1440C8DD0) ---

// --- Function: sub_1440C8F80 (0x1440C8F80) ---
__int64 __fastcall sub_1440C8F80(_QWORD *a1)
{
  return sub_1440C8FA0(*a1);
}

// --- End Function: sub_1440C8F80 (0x1440C8F80) ---

// --- Function: sub_1440C8FA0 (0x1440C8FA0) ---
__int64 __fastcall sub_1440C8FA0(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp-20h]
  _QWORD v3[3]; // [rsp+30h] [rbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 0x18);
  v3[0] = a1;
  v3[1] = v2;
  return sub_144095C00(v3);
}

// --- End Function: sub_1440C8FA0 (0x1440C8FA0) ---

// --- Function: sub_1440C9550 (0x1440C9550) ---
__int64 __fastcall sub_1440C9550(ULONG_PTR *a1, const void *src)
{
  _QWORD *Parameter; // [rsp+20h] [rbp-18h]

  Parameter = (_QWORD *)*a1;
  _StarEngineModule__(*a1);
  return sub_14408CAD0(Parameter, src);
}

// --- End Function: sub_1440C9550 (0x1440C9550) ---

// --- Function: sub_1440C9590 (0x1440C9590) ---
__int64 __fastcall sub_1440C9590(__int64 **a1, const void *src)
{
  return sub_14408CE90(*a1, src);
}

// --- End Function: sub_1440C9590 (0x1440C9590) ---

// --- Function: sub_1440E0C80 (0x1440E0C80) ---
char *__fastcall sub_1440E0C80(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __crt_strtox *v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 _Bytes; // rax
  char *v9; // [rsp+20h] [rbp-98h]
  __int64 v10; // [rsp+28h] [rbp-90h]
  _QWORD *v12; // [rsp+38h] [rbp-80h]
  __int64 v14; // [rsp+58h] [rbp-60h]
  __int64 v15; // [rsp+68h] [rbp-50h]
  __int64 v16; // [rsp+80h] [rbp-38h] BYREF
  __int64 v17; // [rsp+88h] [rbp-30h] BYREF
  __int64 v18; // [rsp+90h] [rbp-28h]
  __int64 v19; // [rsp+98h] [rbp-20h]

  v12 = a1 + 1;
  v10 = (a2 - *a1) >> 3;
  v3 = a1 + 1;
  v4 = (__crt_strtox *)*a1;
  v15 = (__int64)(*v3 - (_QWORD)v4) >> 3;
  v16 = 0x1FFFFFFFFFFFFFFFLL;
  v17 = __crt_strtox::maximum_signed_value(v4);
  v18 = *unknown_libname_2(&v17, &v16);
  if ( v15 == v18 )
    unknown_libname_65(v6, v5);
  v14 = sub_1427D1250(a1, v15 + 1);
  v19 = v14;
  _Bytes = sub_1402AAE00(v14);
  v9 = (char *)std::_Allocate<16,std::_Default_allocate_traits,0>(_Bytes);
  sub_143B2DCC0(&v9[8 * v10], a3);
  if ( a2 == *v12 )
  {
    sub_143B2BD60(*a1, *v12, v9, a1);
  }
  else
  {
    sub_143B2C900(*a1, a2, v9, a1);
    sub_143B2C900(a2, *v12, &v9[8 * v10 + 8], a1);
  }
  sub_143B9E7E0(a1, v9, v15 + 1, v14);
  return &v9[8 * v10];
}

// --- End Function: sub_1440E0C80 (0x1440E0C80) ---

// --- Function: sub_1440F58D0 (0x1440F58D0) ---
__int64 __fastcall sub_1440F58D0(__int64 a1)
{
  return sub_143BA12C0(a1);
}

// --- End Function: sub_1440F58D0 (0x1440F58D0) ---

// --- Function: sub_14432ADB0 (0x14432ADB0) ---
__int64 __fastcall sub_14432ADB0(__int64 *a1)
{
  __int64 v2; // rcx
  int n0x6200; // [rsp+30h] [rbp-58h] BYREF
  __int64 v5; // [rsp+34h] [rbp-54h]
  int v6; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+40h] [rbp-48h]
  unsigned __int64 v8; // [rsp+48h] [rbp-40h]
  __int64 v9; // [rsp+50h] [rbp-38h]
  __int64 v10; // [rsp+58h] [rbp-30h]

  n0x6200 = 0x6200;
  v5 = 1;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = __rdtsc();
  qword_149C89AA0(
    &n0x6200,
    &word_149F7B374,
    "CAudioBudgetHelper::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Audio/AudioBudgetHelper.cpp",
    0x54);
  v2 = *a1;
  HIWORD(n0x6200) = word_149F7B374;
  sub_1403CE280(v2);
  v8 = __rdtsc();
  return qword_149C89AA8(&n0x6200);
}

// --- End Function: sub_14432ADB0 (0x14432ADB0) ---

// --- Function: sub_14432AE50 (0x14432AE50) ---
__int64 sub_14432AE50()
{
  int n0x6200; // [rsp+30h] [rbp-58h] BYREF
  __int64 v2; // [rsp+34h] [rbp-54h]
  int v3; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v4; // [rsp+40h] [rbp-48h]
  unsigned __int64 v5; // [rsp+48h] [rbp-40h]
  __int64 v6; // [rsp+50h] [rbp-38h]
  __int64 v7; // [rsp+58h] [rbp-30h]

  n0x6200 = 0x6200;
  v2 = 1;
  v3 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v4 = __rdtsc();
  qword_149C89AA0(
    &n0x6200,
    &word_149F7B378,
    "CAudioGameContextManager::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Audio/AudioGameContextManager.cpp",
    0x60);
  HIWORD(n0x6200) = word_149F7B378;
  v5 = __rdtsc();
  return qword_149C89AA8(&n0x6200);
}

// --- End Function: sub_14432AE50 (0x14432AE50) ---

// --- Function: sub_1443ADBC0 (0x1443ADBC0) ---
__int64 __fastcall sub_1443ADBC0(__int64 a1)
{
  return *(unsigned int *)(a1 + 0x188);
}

// --- End Function: sub_1443ADBC0 (0x1443ADBC0) ---

// --- Function: sub_1443AE730 (0x1443AE730) ---
__int64 __fastcall sub_1443AE730(__int64 a1)
{
  return sub_1427D2EA0((_QWORD *)(a1 + 0x70));
}

// --- End Function: sub_1443AE730 (0x1443AE730) ---

// --- Function: sub_1443B09E0 (0x1443B09E0) ---
__int64 __fastcall sub_1443B09E0(__int64 a1)
{
  return sub_1427D2EA0((_QWORD *)(a1 + 0xD8));
}

// --- End Function: sub_1443B09E0 (0x1443B09E0) ---

// --- Function: sub_14447B650 (0x14447B650) ---
_QWORD *__fastcall sub_14447B650(__int64 a1)
{
  _QWORD *result; // rax
  _QWORD *v2; // [rsp+20h] [rbp-D8h]
  __int64 v3; // [rsp+28h] [rbp-D0h]
  __int64 (__fastcall *v4)(_QWORD *, _BYTE *, _BYTE *, _BYTE *); // [rsp+80h] [rbp-78h]
  _BYTE v5[32]; // [rsp+88h] [rbp-70h] BYREF
  _BYTE v6[32]; // [rsp+A8h] [rbp-50h] BYREF
  _BYTE v7[48]; // [rsp+C8h] [rbp-30h] BYREF

  result = (_QWORD *)sub_1402A4D50((__int64)&gEnv);
  if ( result[0x2F] )
  {
    v3 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x178);
    result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 0x48LL))(v3, 0x13000004);
    v2 = result;
    if ( result )
    {
      v4 = *(__int64 (__fastcall **)(_QWORD *, _BYTE *, _BYTE *, _BYTE *))(*result + 0x10LL);
      sub_14321C310((__int64)v5, a1 + 0x68, a1 + 0x80);
      sub_14321C310((__int64)v6, a1 + 0x38, a1 + 0x50);
      sub_14321C310((__int64)v7, a1 + 8, a1 + 0x20);
      return (_QWORD *)v4(v2, v7, v6, v5);
    }
  }
  return result;
}

// --- End Function: sub_14447B650 (0x14447B650) ---

// --- Function: sub_144500EE0 (0x144500EE0) ---
char __fastcall sub_144500EE0(double *a1, float *src, __int64 a3)
{
  __int128 v9; // kr00_16
  float v20; // [rsp+48h] [rbp-520h]
  float v21; // [rsp+50h] [rbp-518h]
  float v22; // [rsp+58h] [rbp-510h]
  float v23; // [rsp+60h] [rbp-508h]
  float src__2[5]; // [rsp+68h] [rbp-500h] BYREF
  float v25; // [rsp+7Ch] [rbp-4ECh]
  float v26; // [rsp+80h] [rbp-4E8h]
  float v27; // [rsp+84h] [rbp-4E4h]
  float v28; // [rsp+88h] [rbp-4E0h]
  double v29; // [rsp+90h] [rbp-4D8h]
  double v30; // [rsp+98h] [rbp-4D0h]
  double v31; // [rsp+A0h] [rbp-4C8h]
  double v32; // [rsp+A8h] [rbp-4C0h]
  double src__4[4]; // [rsp+B0h] [rbp-4B8h] BYREF
  double v34; // [rsp+D0h] [rbp-498h]
  double v35; // [rsp+D8h] [rbp-490h]
  float dst__2[3]; // [rsp+E0h] [rbp-488h] BYREF
  double v37; // [rsp+F0h] [rbp-478h]
  double v38; // [rsp+F8h] [rbp-470h]
  double v39; // [rsp+100h] [rbp-468h]
  double v40; // [rsp+108h] [rbp-460h]
  double v41; // [rsp+110h] [rbp-458h]
  __int64 v42; // [rsp+118h] [rbp-450h]
  __int64 v43; // [rsp+120h] [rbp-448h]
  double v44; // [rsp+128h] [rbp-440h]
  double v45; // [rsp+130h] [rbp-438h]
  double v46; // [rsp+138h] [rbp-430h]
  double v47; // [rsp+140h] [rbp-428h]
  double v48; // [rsp+148h] [rbp-420h]
  float src__1[3]; // [rsp+150h] [rbp-418h] BYREF
  float dst__5[3]; // [rsp+160h] [rbp-408h] BYREF
  float src__3[3]; // [rsp+170h] [rbp-3F8h] BYREF
  float dst_[3]; // [rsp+180h] [rbp-3E8h] BYREF
  float v53[4]; // [rsp+190h] [rbp-3D8h] BYREF
  float dst__3[3]; // [rsp+1A0h] [rbp-3C8h] BYREF
  double src_[3]; // [rsp+1B0h] [rbp-3B8h] BYREF
  float v56; // [rsp+1C8h] [rbp-3A0h]
  float v57; // [rsp+1CCh] [rbp-39Ch]
  float v58; // [rsp+1D0h] [rbp-398h]
  float v59; // [rsp+1D4h] [rbp-394h]
  double v60; // [rsp+1D8h] [rbp-390h]
  double v61; // [rsp+1E0h] [rbp-388h]
  double v62; // [rsp+1E8h] [rbp-380h]
  double v63; // [rsp+1F0h] [rbp-378h]
  double v64; // [rsp+1F8h] [rbp-370h]
  double v65; // [rsp+200h] [rbp-368h]
  __int64 v66; // [rsp+208h] [rbp-360h]
  void (__fastcall *v67)(__int64, __int64 *, _QWORD); // [rsp+210h] [rbp-358h]
  double v68; // [rsp+218h] [rbp-350h]
  double v69; // [rsp+220h] [rbp-348h]
  double v70; // [rsp+228h] [rbp-340h]
  double v71; // [rsp+230h] [rbp-338h]
  __int64 v72; // [rsp+238h] [rbp-330h]
  double v73; // [rsp+240h] [rbp-328h]
  double v74; // [rsp+248h] [rbp-320h]
  double v75; // [rsp+250h] [rbp-318h]
  double v76; // [rsp+258h] [rbp-310h]
  double v77; // [rsp+260h] [rbp-308h]
  double v78; // [rsp+268h] [rbp-300h]
  double v79; // [rsp+270h] [rbp-2F8h]
  double v80; // [rsp+278h] [rbp-2F0h]
  double v81; // [rsp+280h] [rbp-2E8h]
  double v82; // [rsp+288h] [rbp-2E0h]
  double v83; // [rsp+290h] [rbp-2D8h]
  double v84; // [rsp+298h] [rbp-2D0h]
  double v85; // [rsp+2A0h] [rbp-2C8h]
  double v86; // [rsp+2A8h] [rbp-2C0h]
  double v87; // [rsp+2B0h] [rbp-2B8h]
  double dst__7[3]; // [rsp+2B8h] [rbp-2B0h] BYREF
  double src__5[3]; // [rsp+2D0h] [rbp-298h] BYREF
  __m128 v93; // [rsp+320h] [rbp-248h]
  __int128 v94; // [rsp+330h] [rbp-238h]
  __m128 v95; // [rsp+340h] [rbp-228h]
  __int128 v96; // [rsp+360h] [rbp-208h]
  __int64 v98; // [rsp+380h] [rbp-1E8h] BYREF
  __int128 v99; // [rsp+3C0h] [rbp-1A8h]
  __int128 v100; // [rsp+3D0h] [rbp-198h]
  _BYTE v101[56]; // [rsp+3E0h] [rbp-188h] BYREF
  _BYTE v102[88]; // [rsp+418h] [rbp-150h] BYREF
  _BYTE dst__1[24]; // [rsp+470h] [rbp-F8h] BYREF
  _BYTE dst__4[12]; // [rsp+488h] [rbp-E0h] BYREF
  _BYTE dst__6[12]; // [rsp+494h] [rbp-D4h] BYREF

  if ( !(unsigned __int8)sub_14452C910() )
    return 0;
  v66 = qword_149F7D6F0;
  v42 = sub_1403EAB20((unsigned __int64 *)(qword_149F7D6F0 + 8));
  v43 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v42 + 0x648LL))(v42);
  v67 = *(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v43 + 0x78LL);
  v67(v43, &v98, 0);
  sub_14033A390(src_, (double *)&v98, a1);
  v70 = src_[2] - unk_149F7DBD8;
  v69 = src_[1] - unk_149F7DBD0;
  v68 = src_[0] - unk_149F7DBC8;
  v46 = src_[0] - unk_149F7DBC8;
  v47 = src_[1] - unk_149F7DBD0;
  v48 = src_[2] - unk_149F7DBD8;
  v71 = (src_[0] - unk_149F7DBC8) * (src_[0] - unk_149F7DBC8)
      + (src_[1] - unk_149F7DBD0) * (src_[1] - unk_149F7DBD0)
      + (src_[2] - unk_149F7DBD8) * (src_[2] - unk_149F7DBD8);
  if ( v71 <= *(double *)&qword_149B63348 )
    return 0;
  v72 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x60);
  v20 = sub_1403B30F0(v72, 0);
  qmemcpy(dst_, src, sizeof(dst_));
  v53[0] = dst_[0] * v20;
  v53[1] = dst_[1] * v20;
  v53[2] = dst_[2] * v20;
  *(_QWORD *)&src__4[3] = v53;
  src__4[0] = (float)(dst_[0] * v20);
  src__4[1] = (float)(dst_[1] * v20);
  src__4[2] = (float)(dst_[2] * v20);
  v75 = src_[2] - src__4[2];
  v74 = src_[1] - src__4[1];
  v73 = src_[0] - src__4[0];
  v30 = src_[0] - src__4[0];
  v31 = src_[1] - src__4[1];
  v32 = src_[2] - src__4[2];
  v78 = src_[2] - src__4[2] - unk_149F7DBD8;
  v77 = src_[1] - src__4[1] - unk_149F7DBD0;
  v76 = src_[0] - src__4[0] - unk_149F7DBC8;
  v79 = v76;
  v80 = v77;
  _XMM0 = *(unsigned __int64 *)&v78;
  v81 = v78;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+568h+var_2F8] }
  src__2[0] = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+568h+var_2F0] }
  src__2[1] = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+568h+var_2E8] }
  src__2[2] = *(float *)&_XMM0;
  v28 = (float)((float)(src__2[0] * src__2[0]) + (float)(src__2[1] * src__2[1]))
      + (float)(*(float *)&_XMM0 * *(float *)&_XMM0);
  if ( v28 >= *(double *)&qword_149B63348 )
    return 0;
  sub_141898950(v101);
  sub_1403809B0(v102, a3);
  qmemcpy(dst__1, src_, sizeof(dst__1));
  v21 = (float)((float)(*src * *src) + (float)(src[1] * src[1])) + (float)(src[2] * src[2]);
  _XMM0 = LODWORD(v21);
  LODWORD(src__2[4]) = v21 > 0.00000011920929;
  if ( v21 <= 0.00000011920929 )
  {
    qmemcpy(dst__2, &::src__4, sizeof(dst__2));
  }
  else
  {
    v93 = _mm_shuffle_ps((__m128)LODWORD(v21), (__m128)LODWORD(v21), 0);
    v95 = v93;
    __asm { vrsqrtps xmm0, [rsp+568h+var_228] }
    v94 = _XMM0;
    v96 = _XMM0;
    v100 = _XMM0;
    v22 = *((float *)&_XMM0 + 3)
        * (float)(1.5 - (float)((float)((float)(v21 * *((float *)&_XMM0 + 3)) * *((float *)&_XMM0 + 3)) * 0.5));
    qmemcpy(dst__3, src, sizeof(dst__3));
    dst__2[0] = dst__3[0] * v22;
    dst__2[1] = dst__3[1] * v22;
    v9 = LODWORD(dst__3[2]);
    *(float *)&v9 = dst__3[2] * v22;
    _XMM0 = v9;
    dst__2[2] = dst__3[2] * v22;
  }
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+568h+var_1D0] }
  v59 = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+568h+var_1E8] }
  v56 = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+568h+var_1E0] }
  v57 = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+568h+var_1D8] }
  v58 = *(float *)&_XMM0;
  v27 = (float)((float)(v57 * dst__2[2]) - (float)(*(float *)&_XMM0 * dst__2[1])) + (float)(v59 * dst__2[0]);
  v26 = (float)((float)(*(float *)&_XMM0 * dst__2[0]) - (float)(v56 * dst__2[2])) + (float)(v59 * dst__2[1]);
  v25 = (float)((float)(v56 * dst__2[1]) - (float)(v57 * dst__2[0])) + (float)(v59 * dst__2[2]);
  src__1[0] = (float)((float)(v25 * v57) - (float)(v26 * *(float *)&_XMM0))
            + (float)((float)((float)(v25 * v57) - (float)(v26 * *(float *)&_XMM0)) + dst__2[0]);
  src__1[1] = (float)((float)(v27 * *(float *)&_XMM0) - (float)(v25 * v56))
            + (float)((float)((float)(v27 * *(float *)&_XMM0) - (float)(v25 * v56)) + dst__2[1]);
  src__1[2] = (float)((float)(v26 * v56) - (float)(v27 * v57))
            + (float)((float)((float)(v26 * v56) - (float)(v27 * v57)) + dst__2[2]);
  qmemcpy(dst__4, src__1, sizeof(dst__4));
  v23 = 1.0 / sub_1403EEFA0();
  qmemcpy(dst__5, src__2, sizeof(dst__5));
  src__3[0] = dst__5[0] * v23;
  src__3[1] = dst__5[1] * v23;
  src__3[2] = dst__5[2] * v23;
  qmemcpy(dst__6, src__3, sizeof(dst__6));
  if ( byte_149F7E4EE )
  {
    v37 = src__4[0] * src__4[0] + src__4[1] * src__4[1] + src__4[2] * src__4[2];
    v62 = 2.0 * src__4[2];
    v61 = 2.0 * src__4[1];
    v60 = 2.0 * src__4[0];
    v82 = 2.0 * src__4[0];
    v83 = 2.0 * src__4[1];
    v84 = 2.0 * src__4[2];
    v29 = 2.0 * src__4[0] * v30 + 2.0 * src__4[1] * v31 + 2.0 * src__4[2] * v32;
    v38 = v30 * v30 + v31 * v31 + v32 * v32 - *(double *)&qword_149B63348;
    v44 = v29 * v29 - 4.0 * v37 * v38;
    if ( v44 >= 0.0 )
    {
      __asm
      {
        vmovddup xmm0, [rsp+568h+var_440]
        vmovupd [rsp+568h+var_1F8], xmm0
        vmovupd xmm0, [rsp+568h+var_1F8]
        vmovupd [rsp+568h+var_278], xmm0
        vsqrtpd xmm0, [rsp+568h+var_278]
        vmovupd [rsp+568h+var_268], xmm0
        vmovupd xmm0, [rsp+568h+var_268]
        vmovupd [rsp+568h+var_258], xmm0
        vmovupd xmm0, [rsp+568h+var_258]
        vmovupd [rsp+568h+var_1A8], xmm0
      }
      v45 = *((double *)&v99 + 1);
      if ( v29 >= 0.0 )
        v34 = (COERCE_DOUBLE(*(_QWORD *)&v29 ^ 0x8000000000000000uLL) + v45) / 2.0;
      else
        v34 = (COERCE_DOUBLE(*(_QWORD *)&v29 ^ 0x8000000000000000uLL) - v45) / 2.0;
      v40 = v34 / v37;
      v39 = v38 / v34;
      if ( v34 / v37 >= v38 / v34 )
        v41 = v40;
      else
        v41 = v39;
      v35 = v41;
      qmemcpy(dst__7, src__4, sizeof(dst__7));
      v85 = dst__7[0] * v41;
      v86 = dst__7[1] * v41;
      v87 = dst__7[2] * v41;
      v65 = v32 + dst__7[2] * v41;
      v64 = v31 + dst__7[1] * v41;
      v63 = v30 + dst__7[0] * v41;
      src__5[0] = v63;
      src__5[1] = v64;
      src__5[2] = v65;
      qmemcpy(dst__1, src__5, sizeof(dst__1));
    }
  }
  sub_144534890(qword_149F7D6F0, v101);
  sub_140375D90(v101);
  return 1;
}

// --- End Function: sub_144500EE0 (0x144500EE0) ---

// --- Function: sub_14452C910 (0x14452C910) ---
__int64 sub_14452C910()
{
  __int64 v0; // rax
  unsigned __int8 v2; // [rsp+20h] [rbp-28h]
  unsigned __int64 v3; // [rsp+30h] [rbp-18h] BYREF
  __int64 v4; // [rsp+38h] [rbp-10h] BYREF

  v2 = 0;
  if ( qword_149F7D6F0 )
  {
    if ( *(_BYTE *)(qword_149F7D6F0 + 0x505) )
    {
      v3 = *(_QWORD *)(qword_149F7D6F0 + 8);
      if ( is_entity_descriptor_valid_or_accessible(&v3) )
      {
        v4 = *(_QWORD *)(qword_149F7D6F0 + 8);
        v0 = sub_1403115A0(&v4);
        if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 0x648LL))(v0) )
          return 1;
      }
    }
  }
  return v2;
}

// --- End Function: sub_14452C910 (0x14452C910) ---

// --- Function: sub_1449F4B50 (0x1449F4B50) ---
__int64 sub_1449F4B50()
{
  __int64 v0; // rax

  v0 = sub_1402A4D50((__int64)&gEnv);
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v0 + 0x98) + 0x258LL))(*(_QWORD *)(v0 + 0x98));
}

// --- End Function: sub_1449F4B50 (0x1449F4B50) ---

// --- Function: sub_144A12990 (0x144A12990) ---
void __fastcall sub_144A12990(__int64 a1, __int64 a2, int a3, int a4, int a5, __int64 a6, float a7, __int64 a8)
{
  __int64 v8; // r8
  __int64 v9; // rax
  void *v12; // [rsp+20h] [rbp-1E8h] BYREF
  void *v13; // [rsp+28h] [rbp-1E0h] BYREF
  int v16; // [rsp+34h] [rbp-1D4h]
  void *v17; // [rsp+38h] [rbp-1D0h] BYREF
  float v18; // [rsp+40h] [rbp-1C8h]
  void *v19; // [rsp+48h] [rbp-1C0h] BYREF
  __int64 v20; // [rsp+50h] [rbp-1B8h]
  __int64 v21; // [rsp+58h] [rbp-1B0h]
  __int64 v22; // [rsp+60h] [rbp-1A8h]
  __int64 v23; // [rsp+68h] [rbp-1A0h]
  __int64 v24; // [rsp+70h] [rbp-198h]
  __int64 v25; // [rsp+78h] [rbp-190h]
  const char *p_p_Src; // [rsp+80h] [rbp-188h]
  __int64 v27; // [rsp+88h] [rbp-180h]
  __int64 *v28; // [rsp+90h] [rbp-178h]
  __int64 v29; // [rsp+98h] [rbp-170h] BYREF
  __int64 v30; // [rsp+A0h] [rbp-168h]
  __int64 v31; // [rsp+A8h] [rbp-160h]
  __int64 v32; // [rsp+B0h] [rbp-158h]
  __int64 v33; // [rsp+B8h] [rbp-150h] BYREF
  __int64 v34; // [rsp+C0h] [rbp-148h]
  __int64 (__fastcall *v35)(__int64, const char *); // [rsp+C8h] [rbp-140h]
  __int64 v36; // [rsp+D0h] [rbp-138h]
  __int64 (__fastcall *v37)(__int64, _BYTE *); // [rsp+D8h] [rbp-130h]
  __int64 *v38; // [rsp+E0h] [rbp-128h]
  _QWORD *v39; // [rsp+E8h] [rbp-120h]
  __int64 (__fastcall *v40)(__int64, __int64 *); // [rsp+F0h] [rbp-118h]
  void **v41; // [rsp+F8h] [rbp-110h]
  void **v42; // [rsp+100h] [rbp-108h]
  void **v43; // [rsp+108h] [rbp-100h]
  void **v44; // [rsp+110h] [rbp-F8h]
  void **v45; // [rsp+118h] [rbp-F0h]
  void **v46; // [rsp+120h] [rbp-E8h]
  void **v47; // [rsp+128h] [rbp-E0h]
  void **v48; // [rsp+130h] [rbp-D8h]
  _QWORD *v49; // [rsp+138h] [rbp-D0h]
  void **v50; // [rsp+140h] [rbp-C8h]
  void **v51; // [rsp+148h] [rbp-C0h]
  void **v52; // [rsp+150h] [rbp-B8h]
  void (__fastcall *v53)(__int64, const char *, const char *, void **); // [rsp+158h] [rbp-B0h]
  __int64 v54; // [rsp+160h] [rbp-A8h] BYREF
  __int64 v55; // [rsp+168h] [rbp-A0h]
  __int64 (__fastcall *v56)(__int64, __int64 *); // [rsp+170h] [rbp-98h]
  void **v57; // [rsp+178h] [rbp-90h]
  void **v58; // [rsp+180h] [rbp-88h]
  void **v59; // [rsp+188h] [rbp-80h]
  void **v60; // [rsp+190h] [rbp-78h]
  void **v61; // [rsp+198h] [rbp-70h]
  void **v62; // [rsp+1A0h] [rbp-68h]
  void **v63; // [rsp+1A8h] [rbp-60h]
  void **v64; // [rsp+1B0h] [rbp-58h]
  _QWORD *v65; // [rsp+1B8h] [rbp-50h]
  void **v66; // [rsp+1C0h] [rbp-48h]
  void **v67; // [rsp+1C8h] [rbp-40h]
  void **v68; // [rsp+1D0h] [rbp-38h]
  void (__fastcall *v69)(__int64, const char *, const char *, void **); // [rsp+1D8h] [rbp-30h]
  __int64 v70; // [rsp+1E0h] [rbp-28h] BYREF
  _BYTE v71[8]; // [rsp+1E8h] [rbp-20h] BYREF
  __int64 v72; // [rsp+1F0h] [rbp-18h] BYREF
  __int64 v73; // [rsp+1F8h] [rbp-10h] BYREF

  sub_1465E6470(qword_149FBE618, &v33);
  CreateStringObjectFromString(&v17, (const char *)&p_Src);
  v20 = sub_144F13530();
  if ( v20 )
    copyStringStructure(&v17, (const void **)(v20 + 0x3D0), v8);
  v21 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0xB0);
  v35 = *(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v21 + 0xC0LL);
  v22 = v35(v21, "preferred_region_id");
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x10LL))(v22);
  v23 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x130);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x90LL))(v23) )
  {
    v24 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x130);
    v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v24 + 0x90LL))(v24);
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x20LL))(v25);
    p_p_Src = (const char *)sub_1402A4EC0(v9);
    CreateStringObjectFromString(&v19, p_p_Src);
  }
  else
  {
    p_p_Src = (const char *)&p_Src;
    CreateStringObjectFromString(&v19, (const char *)&p_Src);
  }
  if ( a7 <= 0.0 )
  {
    v55 = sub_1402A4D50((__int64)&gEnv);
    if ( *(_BYTE *)(v55 + 0x5F5) )
    {
      v34 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x140);
      v32 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x138);
      v56 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v32 + 0x130LL);
      v65 = (_QWORD *)v56(v32, &v70);
      sub_14045A0B0(&v13);
      if ( sub_14048D530(&v13, "tmid_TMId") )
      {
        sub_140492C70((__int64)&v13, v33);
        v57 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "type") )
      {
        sub_140492B70((__int64)&v13, a2);
        v58 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "cause") )
      {
        sub_1404928B0((__int64)&v13, a3);
        v59 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "state_con") )
      {
        sub_1404928B0((__int64)&v13, a4);
        v60 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "state_acc") )
      {
        sub_1404928B0((__int64)&v13, a5);
        v61 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "reason") )
      {
        sub_140492B70((__int64)&v13, a6);
        v62 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "hostname") )
      {
        sub_140492B70((__int64)&v13, a8);
        v63 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "LoadingUuid") )
      {
        sub_140492440((__int64)&v13, &v17);
        v64 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "MatchUUID") )
      {
        sub_140492440((__int64)&v13, v65);
        v66 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "RegionId") )
      {
        sub_1404928B0((__int64)&v13, v16);
        v67 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      if ( sub_14048D530(&v13, "shard_id") )
      {
        sub_140492440((__int64)&v13, &v19);
        v68 = &v13;
        sub_140387CB0((__int64)&v13, (__int64)&unk_1482C0F54);
      }
      v69 = *(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v34 + 0x40LL);
      v69(
        v34,
        "void __cdecl CCIGSessionAnalytics::OnErrorPopup(const char *,int,int,int,const char *,float,const char *)",
        "error_popup",
        &v13);
      sub_140373CC0(&v13);
      sub_140373CC0(&v70);
    }
  }
  else
  {
    v36 = sub_1402A4D50((__int64)&gEnv);
    if ( *(_BYTE *)(v36 + 0x5F5) )
    {
      if ( *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x60) )
      {
        v27 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x60);
        v37 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v27 + 0x48LL);
        v28 = (__int64 *)v37(v27, v71);
      }
      else
      {
        v28 = sub_1402B3B40(&v72, -1.0);
      }
      v38 = v28;
      v29 = *v28;
      v39 = sub_14059CA60(&v29, &v73, &qword_149F85C70);
      _XMM0 = sub_14059CC00();
      __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
      v18 = *(float *)&_XMM0;
      qword_149F85C70 = v29;
      if ( *(float *)&_XMM0 > a7 )
      {
        v31 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x140);
        v30 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x138);
        v40 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v30 + 0x130LL);
        v49 = (_QWORD *)v40(v30, &v54);
        sub_14045A0B0(&v12);
        if ( sub_14048D530(&v12, "tmid_TMId") )
        {
          sub_140492C70((__int64)&v12, v33);
          v41 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "type") )
        {
          sub_140492B70((__int64)&v12, a2);
          v42 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "cause") )
        {
          sub_1404928B0((__int64)&v12, a3);
          v43 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "state_con") )
        {
          sub_1404928B0((__int64)&v12, a4);
          v44 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "state_acc") )
        {
          sub_1404928B0((__int64)&v12, a5);
          v45 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "reason") )
        {
          sub_140492B70((__int64)&v12, a6);
          v46 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "hostname") )
        {
          sub_140492B70((__int64)&v12, a8);
          v47 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "LoadingUuid") )
        {
          sub_140492440((__int64)&v12, &v17);
          v48 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "MatchUUID") )
        {
          sub_140492440((__int64)&v12, v49);
          v50 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "RegionId") )
        {
          sub_1404928B0((__int64)&v12, v16);
          v51 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        if ( sub_14048D530(&v12, "shard_id") )
        {
          sub_140492440((__int64)&v12, &v19);
          v52 = &v12;
          sub_140387CB0((__int64)&v12, (__int64)&unk_1482C0F54);
        }
        v53 = *(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v31 + 0x40LL);
        v53(
          v31,
          "void __cdecl CCIGSessionAnalytics::OnErrorPopup(const char *,int,int,int,const char *,float,const char *)",
          "error_popup",
          &v12);
        sub_140373CC0(&v12);
        sub_140373CC0(&v54);
      }
    }
  }
  sub_140373CC0(&v19);
  sub_140373CC0(&v17);
}

// --- End Function: sub_144A12990 (0x144A12990) ---

// --- Function: sub_144A4FF50 (0x144A4FF50) ---
_QWORD *__fastcall sub_144A4FF50(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_144A55B90(a1, &v4);
  return a1;
}

// --- End Function: sub_144A4FF50 (0x144A4FF50) ---

// --- Function: sub_144A70850 (0x144A70850) ---
_QWORD *__fastcall sub_144A70850(__int64 a1, _QWORD *a2)
{
  _BYTE v3[8]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v4; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int64); // [rsp+30h] [rbp-28h]
  __int64 *v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  _BYTE v8[16]; // [rsp+48h] [rbp-10h] BYREF

  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)a1 + 0x340LL);
  v4 = sub_144BBBBF0(v3);
  v6 = (__int64 *)v5(a1, v8, v4);
  v7 = *v6;
  *a2 = v7;
  return a2;
}

// --- End Function: sub_144A70850 (0x144A70850) ---

// --- Function: sub_144A717F0 (0x144A717F0) ---
_QWORD *__fastcall sub_144A717F0(_QWORD *a1)
{
  *a1 = "struct SCEvtDebug_SalvageControllerDebugDraw";
  return a1;
}

// --- End Function: sub_144A717F0 (0x144A717F0) ---

// --- Function: sub_144A78BD0 (0x144A78BD0) ---
__int64 __fastcall sub_144A78BD0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  int event_key_from_source_location; // [rsp+20h] [rbp-58h]
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  __int64 v7; // [rsp+38h] [rbp-40h] BYREF
  int event_key_from_source_location_1; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  __int64 v10; // [rsp+50h] [rbp-28h]
  char v11; // [rsp+58h] [rbp-20h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+60h] [rbp-18h]
  __int64 (__fastcall *p_sub_14280FD70)(__int64); // [rsp+68h] [rbp-10h]

  v7 = a3;
  if ( event_key_from_source_location_5 )
    event_key_from_source_location = event_key_from_source_location_5;
  else
    event_key_from_source_location = get_event_key_from_source_location(
                                       &event_key_from_source_location_5,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ISC/Salvage.h",
                                       0x6C);
  event_key_from_source_location_1 = event_key_from_source_location;
  v9 = 1;
  v3 = sub_144A717F0(&v6);
  v10 = sub_1402A4EC0((__int64)v3);
  v11 = byte_149F882E4;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_14280FD70 = sub_14280FD70;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v7);
}

// --- End Function: sub_144A78BD0 (0x144A78BD0) ---

// --- Function: sub_144B92640 (0x144B92640) ---
__int64 (__fastcall *__fastcall sub_144B92640(const void *src, _QWORD *a2))(__int64, __int64, _QWORD)
{
  __int64 (__fastcall *result)(__int64, __int64, _QWORD); // rax
  __int64 *v3; // rax
  float v4; // [rsp+30h] [rbp-4C8h]
  unsigned __int64 *v5; // [rsp+38h] [rbp-4C0h]
  unsigned __int64 v6; // [rsp+40h] [rbp-4B8h] BYREF
  __int64 v7; // [rsp+48h] [rbp-4B0h]
  __int64 v8; // [rsp+50h] [rbp-4A8h]
  __int64 v9; // [rsp+58h] [rbp-4A0h]
  _QWORD *v10; // [rsp+60h] [rbp-498h]
  __int64 v11; // [rsp+68h] [rbp-490h]
  __int64 v12; // [rsp+70h] [rbp-488h] BYREF
  _BYTE v13[8]; // [rsp+78h] [rbp-480h] BYREF
  char v14; // [rsp+80h] [rbp-478h] BYREF
  __int64 (__fastcall *v15)(__int64, _BYTE *); // [rsp+88h] [rbp-470h]
  void (__fastcall *v16)(__int64, _BYTE *, const char *); // [rsp+90h] [rbp-468h]
  _QWORD *v17; // [rsp+98h] [rbp-460h]
  _QWORD *v18; // [rsp+A0h] [rbp-458h]
  void (__fastcall *v19)(__int64, int *, _QWORD *, _QWORD); // [rsp+A8h] [rbp-450h]
  unsigned __int64 *v20; // [rsp+B0h] [rbp-448h]
  __int64 v21; // [rsp+B8h] [rbp-440h]
  __int64 *v22; // [rsp+C0h] [rbp-438h]
  __int64 v23; // [rsp+C8h] [rbp-430h]
  __int64 *v24[2]; // [rsp+D0h] [rbp-428h] BYREF
  _QWORD v25[3]; // [rsp+E0h] [rbp-418h] BYREF
  _BYTE v26[8]; // [rsp+F8h] [rbp-400h] BYREF
  __int64 v27; // [rsp+100h] [rbp-3F8h] BYREF
  _QWORD v28[3]; // [rsp+108h] [rbp-3F0h] BYREF
  __m256i dst_; // [rsp+120h] [rbp-3D8h] BYREF
  _DWORD v30[12]; // [rsp+140h] [rbp-3B8h] BYREF
  int v31[216]; // [rsp+170h] [rbp-388h] BYREF

  result = (__int64 (__fastcall *)(__int64, __int64, _QWORD))a2;
  a2[1] = *a2;
  v4 = *(float *)&dword_149BBBA44;
  if ( *(float *)&dword_149BBBA44 > 0.0 )
  {
    v7 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 8);
    v15 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 0x18LL);
    v3 = (__int64 *)v15(v7, v26);
    sub_140372710((__int64)v31, 0x7832, *v3, 0x30, "Salvage::Debug::FindNearbySalvageControllers");
    qmemcpy(&dst_, src, 0x18u);
    *(double *)&dst_.m256i_i64[3] = v4;
    sub_1403A9A30((__int64)v31, &dst_);
    v8 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x18);
    v16 = *(void (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)v8 + 0x28LL);
    v16(v8, v13, "Engine.Components.SCItemSalvageController");
    v24[0] = (__int64 *)v13;
    v24[1] = (__int64 *)&v14;
    sub_140363FD0((__int64)v30, v24);
    sub_1403A9A40((__int64)v31, (__int64)v30);
    sub_140375A50(v30);
    unknown_libname_474(v25);
    v9 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0xA0);
    v19 = *(void (__fastcall **)(__int64, int *, _QWORD *, _QWORD))(*(_QWORD *)v9 + 0x1C0LL);
    v17 = v25;
    v18 = v25;
    sub_144A4FF50(v28, (__int64)v25);
    v19(v9, v31, v28, 0);
    sub_1402A5330(v28);
    v10 = v25;
    v5 = (unsigned __int64 *)v25[0];
    v20 = (unsigned __int64 *)v25[1];
    while ( v5 != v20 )
    {
      v6 = *v5;
      if ( is_entity_descriptor_valid_or_accessible(&v6) )
      {
        v11 = sub_1403115A0(&v6);
        if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x58LL))(v11) )
        {
          v21 = sub_1403115A0(&v6);
          v22 = sub_144A70850(v21, &v27);
          v23 = *v22;
          v12 = v23;
          if ( Handle::IsValid(&v12) )
            sub_143730890((__int64)a2, &v12);
        }
      }
      ++v5;
    }
    sub_1402B4EC0(v25);
    return sub_14037A590((__int64)v31);
  }
  return result;
}

// --- End Function: sub_144B92640 (0x144B92640) ---

// --- Function: sub_144C4B170 (0x144C4B170) ---
_QWORD *sub_144C4B170()
{
  _QWORD *result; // rax
  bool v3; // [rsp+20h] [rbp-E8h]
  char v4; // [rsp+21h] [rbp-E7h] BYREF
  _BYTE *v5; // [rsp+28h] [rbp-E0h]
  _QWORD *v6; // [rsp+30h] [rbp-D8h]
  _QWORD *v7; // [rsp+38h] [rbp-D0h]
  __int64 v8; // [rsp+40h] [rbp-C8h]
  __int64 v9; // [rsp+48h] [rbp-C0h]
  __int64 v10; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v11; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v12; // [rsp+60h] [rbp-A8h]
  _QWORD *v13; // [rsp+68h] [rbp-A0h]
  __int64 (__fastcall *v14)(__int64, _QWORD); // [rsp+70h] [rbp-98h]
  _QWORD *v15; // [rsp+78h] [rbp-90h]
  _QWORD *v16; // [rsp+80h] [rbp-88h]
  char *v17; // [rsp+88h] [rbp-80h]
  __int64 v18; // [rsp+90h] [rbp-78h]
  _QWORD v19[3]; // [rsp+98h] [rbp-70h] BYREF
  _BYTE dst_[32]; // [rsp+B0h] [rbp-58h] BYREF
  _QWORD v21[7]; // [rsp+D0h] [rbp-38h] BYREF

  v5 = (_BYTE *)sub_1402A4D50((__int64)&gEnv);
  v3 = !v5[0x5F7] && !v5[0x5F8] || v5[0x5F7] && v5[0x5F4];
  result = (_QWORD *)v3;
  if ( v3 && dword_149BBBA30 )
  {
    v9 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x60);
    v14 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + 0x38LL);
    v11 = *(_QWORD *)v14(v9, 0);
    if ( sub_14059CAF0(&v11, &qword_149F88410) )
    {
      sub_1402B3CF0(&v10);
      _XMM0 = COERCE_UNSIGNED_INT64(5.0 * 10000000.0);
      __asm { vcvttsd2si rax, xmm0 }
      v10 = _RAX;
      qword_149F88410 = *sub_14059CA80(&v11, v19, &v10);
      v12 = sub_1402C9900();
      v15 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x3D0LL))(v12);
      qmemcpy(dst_, sub_14032BBD0(v15, v21), 0x18u);
      sub_144B92640(dst_, qword_149F86D10);
    }
    v13 = qword_149F86D10;
    v6 = (_QWORD *)qword_149F86D10[0];
    v16 = (_QWORD *)qword_149F86D10[1];
    while ( 1 )
    {
      result = v16;
      if ( v6 == v16 )
        break;
      v7 = v6;
      if ( Handle::IsValid(v6) )
      {
        v18 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0xA0);
        v17 = &v4;
        v8 = v19[1];
        if ( Handle::IsValid(v7) )
          v8 = *v7 & 0xFFFFFFFFFFFFLL;
        else
          v8 = 0;
        sub_144A78BD0(v18, v8, (__int64)v17);
      }
      ++v6;
    }
  }
  return result;
}

// --- End Function: sub_144C4B170 (0x144C4B170) ---

// --- Function: sub_144C4B3F0 (0x144C4B3F0) ---
_QWORD *sub_144C4B3F0()
{
  _QWORD *result; // rax
  __int64 v1; // [rsp+28h] [rbp-20h]

  result = (_QWORD *)sub_1402A4D50((__int64)&gEnv);
  if ( result[0x2F] )
  {
    v1 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x178);
    result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v1 + 0x48LL))(v1, 0x11110000);
    if ( result )
      return (_QWORD *)(*(__int64 (__fastcall **)(_QWORD *))(*result + 8LL))(result);
  }
  return result;
}

// --- End Function: sub_144C4B3F0 (0x144C4B3F0) ---

// --- Function: sub_144C7D760 (0x144C7D760) ---
const ULONG_PTR *__fastcall sub_144C7D760(
        _QWORD *a1,
        void (__fastcall *a2)(_QWORD, __int64, __int64, __int64),
        unsigned int *a3,
        __int64 a4,
        unsigned __int8 *a5)
{
  __int64 v5; // rbx
  int v10; // esi
  unsigned int v11; // eax
  __int64 v12; // rcx
  __int64 v13; // rdi
  char *v14; // rdi
  char v15; // r8
  __int64 v16; // r9
  __int64 v17; // rdx
  _QWORD *v18; // rcx
  __int64 *v19; // rax
  int v20; // eax
  const ULONG_PTR *result; // rax
  __int16 v22; // [rsp+30h] [rbp-51h] BYREF
  __int64 v23; // [rsp+38h] [rbp-49h] BYREF
  __int64 v24; // [rsp+40h] [rbp-41h]
  _QWORD *v25; // [rsp+48h] [rbp-39h]
  __int64 v26; // [rsp+50h] [rbp-31h]
  __int64 v27; // [rsp+58h] [rbp-29h]
  _BYTE v28[2]; // [rsp+60h] [rbp-21h] BYREF
  __int16 v29; // [rsp+62h] [rbp-1Fh]
  __int64 v30; // [rsp+64h] [rbp-1Dh]
  int v31; // [rsp+6Ch] [rbp-15h]
  unsigned __int64 v32; // [rsp+70h] [rbp-11h]
  unsigned __int64 v33; // [rsp+78h] [rbp-9h]
  __int64 v34; // [rsp+80h] [rbp-1h]
  __int64 v35; // [rsp+88h] [rbp+7h]
  _QWORD *v36; // [rsp+E0h] [rbp+5Fh]

  v5 = (__int64)(a1 + 4);
  v36 = a1 + 4;
  v10 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v5 + 0x10) == v10 )
  {
    ++*(_DWORD *)(v5 + 0x14);
  }
  else
  {
    v11 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 1, 0);
    if ( v11 )
      sub_1403C6E80(v5, v11, (__int64)"SCIGListenerSet<struct ISpawnManagerListener>::Notify", 1);
    else
      *(_QWORD *)(v5 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v5 + 0x10) = v10;
  }
  v12 = a1[1] - *a1;
  v23 = *a1;
  v12 >>= 4;
  v27 = v12;
  v25 = a1;
  v26 = 0;
  v24 = a1[3];
  a1[3] = &v23;
  if ( v12 > 0 )
  {
    v13 = v26;
    do
    {
      v14 = (char *)(v23 + 0x10 * v13);
      v15 = *v14;
      v22 = *((_WORD *)v14 + 1);
      v29 = 0;
      v30 = 0;
      v31 = 0;
      v33 = 0;
      v34 = 0;
      v35 = 0;
      v28[1] = v15;
      v32 = __rdtsc();
      v28[0] = 0;
      qword_149C89AA0(v28, &v22, &p_Src, &p_Src, 0);
      v16 = *a5;
      v17 = *a3;
      v29 = v22;
      a2(*((_QWORD *)v14 + 1), v17, a4, v16);
      ++v26;
      v33 = __rdtsc();
      qword_149C89AA8(v28);
      v13 = v26;
    }
    while ( v26 < v27 );
    v5 = (__int64)v36;
  }
  v18 = v25 + 3;
  v19 = (__int64 *)v25[3];
  if ( v19 )
  {
    while ( v19 != &v23 )
    {
      v18 = v19 + 1;
      v19 = (__int64 *)v19[1];
      if ( !v19 )
        goto LABEL_16;
    }
    *v18 = v24;
  }
LABEL_16:
  v20 = *(_DWORD *)(v5 + 0x14);
  if ( v20 )
  {
    result = (const ULONG_PTR *)(unsigned int)(v20 - 1);
    *(_DWORD *)(v5 + 0x14) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
    result = (const ULONG_PTR *)(unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v5, 0, 1);
    if ( (_DWORD)result == 1 )
      *(_QWORD *)(v5 + 8) = &p_Src;
    else
      return sub_1403DF590(v5, (unsigned int)result);
  }
  return result;
}

// --- End Function: sub_144C7D760 (0x144C7D760) ---

// --- Function: sub_144C868C0 (0x144C868C0) ---
void __fastcall sub_144C868C0(__int64 a1, __int64 a2)
{
  unsigned int event_key_from_source_location; // eax
  __int64 *j; // rbx
  __int64 *v6; // rdi
  __int64 *v7; // rcx
  __int64 *v8; // rdx
  unsigned int event_key_from_source_location_1; // r8d
  __int64 **v10; // rax
  __int64 *i; // rax
  __int64 *v12; // rcx
  _QWORD *v13; // rdi
  _QWORD *k; // rbx
  _QWORD *v15; // rdi
  _QWORD *m; // rbx

  if ( *(_DWORD *)(a1 + 0x70) )
  {
    event_key_from_source_location = event_key_from_source_location_6;
    if ( !event_key_from_source_location_6 )
      event_key_from_source_location = get_event_key_from_source_location(
                                         &event_key_from_source_location_6,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AI/Spawning/SpawnHelperQuantum.h",
                                         0x35);
    j = *(__int64 **)(a1 + 0x60);
    v6 = j;
    v7 = (__int64 *)j[1];
    v8 = v7;
    while ( !*((_BYTE *)v8 + 0x19) )
    {
      event_key_from_source_location_1 = *((_DWORD *)v8 + 7);
      if ( event_key_from_source_location_1 >= event_key_from_source_location )
      {
        if ( *((_BYTE *)v6 + 0x19) && event_key_from_source_location < event_key_from_source_location_1 )
          v6 = v8;
        j = v8;
        v8 = (__int64 *)*v8;
      }
      else
      {
        v8 = (__int64 *)v8[2];
      }
    }
    if ( !*((_BYTE *)v6 + 0x19) )
      v7 = (__int64 *)*v6;
    while ( !*((_BYTE *)v7 + 0x19) )
    {
      if ( event_key_from_source_location >= *((_DWORD *)v7 + 7) )
      {
        v7 = (__int64 *)v7[2];
      }
      else
      {
        v6 = v7;
        v7 = (__int64 *)*v7;
      }
    }
    while ( j != v6 )
    {
      sub_144C85820(*(_QWORD *)(*(_QWORD *)a1 + 8LL * *((unsigned int *)j + 8)), a2);
      v10 = (__int64 **)j[2];
      if ( *((_BYTE *)v10 + 0x19) )
      {
        for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
        {
          if ( j != (__int64 *)i[2] )
            break;
          j = i;
        }
        j = i;
      }
      else
      {
        v12 = *v10;
        for ( j = (__int64 *)j[2]; !*((_BYTE *)v12 + 0x19); v12 = (__int64 *)*v12 )
          j = v12;
      }
    }
  }
  else
  {
    v13 = *(_QWORD **)(a1 + 8);
    for ( k = *(_QWORD **)a1; k != v13; ++k )
      sub_144C85820(*k, a2);
  }
  v15 = *(_QWORD **)(a1 + 0x28);
  for ( m = *(_QWORD **)(a1 + 0x20); m != v15; ++m )
    sub_144C868C0(*m, a2);
}

// --- End Function: sub_144C868C0 (0x144C868C0) ---

// --- Function: sub_144C92410 (0x144C92410) ---
unsigned __int64 __fastcall sub_144C92410(__int64 a1, int *a2)
{
  int v3; // eax
  unsigned __int64 v4; // r9
  bool v6; // dl
  bool v7; // r8
  bool v8; // dl
  bool v9; // cl
  int v10; // r8d
  unsigned __int64 v11; // r9
  bool v12; // cl
  char v13; // al
  bool v14; // dl
  bool v15; // al
  bool v16; // al
  int v17; // r8d
  unsigned __int64 v18; // r9
  bool v19; // cl
  char v20; // al
  bool v21; // dl
  bool v22; // al
  bool v23; // al

  v3 = *a2;
  v4 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v4 += 8LL;
    v6 = (v3 & 0x40) != 0;
    v3 >>= 7;
    v7 = v6;
    v8 = 0;
    if ( v3 )
      v8 = !v7;
    v9 = 0;
    if ( v3 != 0xFFFFFFFF )
      v9 = v7;
  }
  while ( v9 || v8 );
  *(_QWORD *)(a1 + 8) = v4;
  sub_14052A3D0(a1);
  sub_14052A3D0(a1);
  sub_1405C6400(a1);
  sub_1405C6400(a1);
  sub_14052A3D0(a1);
  sub_1405C6400(a1);
  sub_14052A3D0(a1);
  sub_14052A3B0(a1);
  sub_14052A3B0(a1);
  sub_14052A3B0(a1);
  sub_14052A590(a1);
  sub_14052A3D0(a1);
  v10 = a2[0x32];
  v11 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v12 = 0;
    v11 += 8LL;
    v13 = v10;
    v10 >>= 7;
    v14 = (v13 & 0x40) != 0;
    v15 = (v13 & 0x40) == 0;
    if ( v10 )
      v12 = v15;
    v16 = 0;
    if ( v10 != 0xFFFFFFFF )
      v16 = v14;
  }
  while ( v16 || v12 );
  *(_QWORD *)(a1 + 8) = v11;
  sub_14052A390(a1, "m_bitStorage", a2 + 0x33);
  v17 = a2[0x35];
  v18 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v19 = 0;
    v18 += 8LL;
    v20 = v17;
    v17 >>= 7;
    v21 = (v20 & 0x40) != 0;
    v22 = (v20 & 0x40) == 0;
    if ( v17 )
      v19 = v22;
    v23 = 0;
    if ( v17 != 0xFFFFFFFF )
      v23 = v21;
  }
  while ( v23 || v19 );
  *(_QWORD *)(a1 + 8) = v18;
  sub_14052A590(a1);
  sub_14052A3D0(a1);
  return sub_14052A3B0(a1);
}

// --- End Function: sub_144C92410 (0x144C92410) ---

// --- Function: sub_144C9B370 (0x144C9B370) ---
unsigned __int64 __fastcall sub_144C9B370(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  int v4; // r9d
  unsigned int v7; // eax
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r10
  unsigned __int64 v11; // rbx
  bool v12; // dl
  char v13; // r8
  bool v14; // al
  bool v15; // cl
  char v16; // r8
  bool v17; // al
  bool v18; // al
  char v19; // dl
  __int64 v20; // rdi
  __int64 v21; // rbx
  int v22; // r8d
  unsigned int v23; // eax
  unsigned __int64 v24; // r10
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // rbx
  bool v28; // dl
  char v29; // r11
  bool v30; // al
  bool v31; // cl
  char v32; // r11
  bool v33; // al
  bool v34; // al
  char v35; // dl
  __int64 v36; // rbx
  __int64 v37; // r11
  int v38; // r8d
  unsigned int v39; // eax
  unsigned __int64 v40; // r10
  unsigned __int64 v41; // rcx
  unsigned __int64 v42; // r9
  unsigned __int64 v43; // r11
  char v44; // di
  bool v45; // al
  bool v46; // dl
  bool v47; // al
  bool v48; // cl
  char v49; // al

  v2 = *(_QWORD *)(a1 + 8);
  v3 = 0;
  v4 = *(_DWORD *)a2;
  v7 = *(unsigned __int8 *)(v2 + 0x18);
  v8 = *(_QWORD *)(v2 + 8);
  v9 = (unsigned __int64)(*(_QWORD *)(v2 + 0x10) + 7LL) >> 3;
  v10 = 8 * v9;
  *(_QWORD *)(v2 + 0x10) = 8 * v9;
  if ( 8 * v9 <= v8 )
    v3 = v7;
  v11 = (v9 + *(_QWORD *)v2) * v3;
  if ( v11 )
  {
    do
    {
      v12 = 0;
      v13 = v4;
      v14 = (v4 & 0x40) != 0;
      v4 >>= 7;
      v15 = v14;
      v16 = v13 & 0x7F;
      v17 = !v14;
      if ( v4 )
        v12 = v17;
      v18 = 0;
      if ( v4 != 0xFFFFFFFF )
        v18 = v15;
      v10 += 8LL;
      v19 = v18 || v12;
      *(_QWORD *)(v2 + 0x10) = v10;
      if ( v10 <= v8 )
      {
        *(_BYTE *)v11++ = v16 | (v19 << 7);
        v8 = *(_QWORD *)(v2 + 8);
        v10 = *(_QWORD *)(v2 + 0x10);
      }
    }
    while ( v19 );
  }
  serialize_int64(a1, (__int64)"m_QTStartTime", (__int64 *)(a2 + 8));
  sub_14052AAD0(a1, "m_QTStartSpeed", a2 + 0x10);
  sub_1405C6540(a1, "m_QTStartPoint", a2 + 0x18);
  sub_1405C6540(a1, "m_QTEndPoint", a2 + 0x40);
  sub_14052AAD0(a1, "timeFromDeparture", a2 + 0x68);
  sub_1405C6540(a1, "zonePosition", a2 + 0x70);
  serialize_int64(a1, (__int64)"planetId", (__int64 *)(a2 + 0xA8));
  sub_14052AA80(a1, (__int64)"fPlanetSize", (unsigned int *)(a2 + 0xB0));
  sub_14052AA80(a1, (__int64)"fArrivalRadius", (unsigned int *)(a2 + 0xB4));
  sub_14052AA80(a1, (__int64)"m_requiredCalibrationForQT", (unsigned int *)(a2 + 0xB8));
  sub_14052ADF0(a1, "m_calibrationInProgress", a2 + 0xBC);
  serialize_int64(a1, (__int64)"m_previousTravelTime", (__int64 *)(a2 + 0xC0));
  v20 = *(_QWORD *)(a1 + 8);
  v21 = 0;
  v22 = *(_DWORD *)(a2 + 0xC8);
  v23 = *(unsigned __int8 *)(v20 + 0x18);
  v24 = *(_QWORD *)(v20 + 8);
  v25 = (unsigned __int64)(*(_QWORD *)(v20 + 0x10) + 7LL) >> 3;
  v26 = 8 * v25;
  *(_QWORD *)(v20 + 0x10) = 8 * v25;
  if ( 8 * v25 <= v24 )
    v21 = v23;
  v27 = (v25 + *(_QWORD *)v20) * v21;
  if ( v27 )
  {
    do
    {
      v28 = 0;
      v29 = v22;
      v30 = (v22 & 0x40) != 0;
      v22 >>= 7;
      v31 = v30;
      v32 = v29 & 0x7F;
      v33 = !v30;
      if ( v22 )
        v28 = v33;
      v34 = 0;
      if ( v22 != 0xFFFFFFFF )
        v34 = v31;
      v26 += 8LL;
      v35 = v34 || v28;
      *(_QWORD *)(v20 + 0x10) = v26;
      if ( v26 <= v24 )
      {
        *(_BYTE *)v27++ = v32 | (v35 << 7);
        v24 = *(_QWORD *)(v20 + 8);
        v26 = *(_QWORD *)(v20 + 0x10);
      }
    }
    while ( v35 );
  }
  sub_14052A9E0(a1, "m_bitStorage", a2 + 0xCC);
  v36 = *(_QWORD *)(a1 + 8);
  v37 = 0;
  v38 = *(_DWORD *)(a2 + 0xD4);
  v39 = *(unsigned __int8 *)(v36 + 0x18);
  v40 = *(_QWORD *)(v36 + 8);
  v41 = (unsigned __int64)(*(_QWORD *)(v36 + 0x10) + 7LL) >> 3;
  v42 = 8 * v41;
  *(_QWORD *)(v36 + 0x10) = 8 * v41;
  if ( 8 * v41 <= v40 )
    v37 = v39;
  v43 = (v41 + *(_QWORD *)v36) * v37;
  if ( v43 )
  {
    do
    {
      v44 = v38 & 0x7F;
      v45 = (v38 & 0x40) != 0;
      v38 >>= 7;
      v46 = v45;
      v47 = 0;
      if ( v38 )
        v47 = !v46;
      v48 = 0;
      if ( v38 != 0xFFFFFFFF )
        v48 = v46;
      v42 += 8LL;
      v49 = v48 || v47;
      *(_QWORD *)(v36 + 0x10) = v42;
      if ( v42 <= v40 )
      {
        *(_BYTE *)v43++ = v44 | (v49 << 7);
        v40 = *(_QWORD *)(v36 + 8);
        v42 = *(_QWORD *)(v36 + 0x10);
      }
    }
    while ( v49 );
  }
  sub_14052ADF0(a1, "m_handleFixupEnvelopeOnSpawn", a2 + 0xD8);
  serialize_int64(a1, (__int64)"m_referenceEntityForArrival", (__int64 *)(a2 + 0xE0));
  return serialize_int32(a1, (__int64)"m_bitStorage", (int *)(a2 + 0xD0));
}

// --- End Function: sub_144C9B370 (0x144C9B370) ---

// --- Function: sub_144C9B6E0 (0x144C9B6E0) ---
__int64 __fastcall sub_144C9B6E0(__int64 a1, __int64 a2)
{
  __int64 v2; // r10
  __int64 v3; // r9
  int v4; // edi
  unsigned int v7; // eax
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r11
  unsigned __int64 v11; // r9
  bool v12; // r8
  char v13; // bl
  bool v14; // al
  bool v15; // cl
  char v16; // bl
  bool v17; // al
  bool v18; // al
  char v19; // r8
  __int64 v20; // r10
  __int64 v21; // r9
  int v22; // edi
  unsigned int v23; // eax
  unsigned __int64 v24; // r8
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r11
  unsigned __int64 v27; // r9
  bool v28; // dl
  char v29; // bl
  bool v30; // al
  bool v31; // cl
  char v32; // bl
  bool v33; // al
  bool v34; // al
  char v35; // dl

  v2 = *(_QWORD *)(a1 + 8);
  v3 = 0;
  v4 = *(_DWORD *)a2;
  v7 = *(unsigned __int8 *)(v2 + 0x18);
  v8 = *(_QWORD *)(v2 + 8);
  v9 = (unsigned __int64)(*(_QWORD *)(v2 + 0x10) + 7LL) >> 3;
  v10 = 8 * v9;
  *(_QWORD *)(v2 + 0x10) = 8 * v9;
  if ( 8 * v9 <= v8 )
    v3 = v7;
  v11 = (v9 + *(_QWORD *)v2) * v3;
  if ( v11 )
  {
    do
    {
      v12 = 0;
      v13 = v4;
      v14 = (v4 & 0x40) != 0;
      v4 >>= 7;
      v15 = v14;
      v16 = v13 & 0x7F;
      v17 = !v14;
      if ( v4 )
        v12 = v17;
      v18 = 0;
      if ( v4 != 0xFFFFFFFF )
        v18 = v15;
      v10 += 8LL;
      v19 = v18 || v12;
      *(_QWORD *)(v2 + 0x10) = v10;
      if ( v10 <= v8 )
      {
        *(_BYTE *)v11++ = v16 | (v19 << 7);
        v8 = *(_QWORD *)(v2 + 8);
        v10 = *(_QWORD *)(v2 + 0x10);
      }
    }
    while ( v19 );
  }
  sub_14052ADF0(a1, "m_isPowered", a2 + 4);
  v20 = *(_QWORD *)(a1 + 8);
  v21 = 0;
  v22 = *(_DWORD *)(a2 + 8);
  v23 = *(unsigned __int8 *)(v20 + 0x18);
  v24 = *(_QWORD *)(v20 + 8);
  v25 = (unsigned __int64)(*(_QWORD *)(v20 + 0x10) + 7LL) >> 3;
  v26 = 8 * v25;
  *(_QWORD *)(v20 + 0x10) = 8 * v25;
  if ( 8 * v25 <= v24 )
    v21 = v23;
  v27 = (v25 + *(_QWORD *)v20) * v21;
  if ( v27 )
  {
    do
    {
      v28 = 0;
      v29 = v22;
      v30 = (v22 & 0x40) != 0;
      v22 >>= 7;
      v31 = v30;
      v32 = v29 & 0x7F;
      v33 = !v30;
      if ( v22 )
        v28 = v33;
      v34 = 0;
      if ( v22 != 0xFFFFFFFF )
        v34 = v31;
      v26 += 8LL;
      v35 = v34 || v28;
      *(_QWORD *)(v20 + 0x10) = v26;
      if ( v26 <= v24 )
      {
        *(_BYTE *)v27++ = v32 | (v35 << 7);
        v24 = *(_QWORD *)(v20 + 8);
        v26 = *(_QWORD *)(v20 + 0x10);
      }
    }
    while ( v35 );
  }
  serialize_int64(a1, (__int64)"m_spawnNavpoint", (__int64 *)(a2 + 0x10));
  return sub_1405C6540(a1, "m_spawnPosition", a2 + 0x18);
}

// --- End Function: sub_144C9B6E0 (0x144C9B6E0) ---

// --- Function: sub_144CAD040 (0x144CAD040) ---
__int64 __fastcall sub_144CAD040(__int64 a1, __int64 a2)
{
  sub_1404684E0(a2 + 0xC8);
  sub_142934E80(a2 + 0x60);
  sub_142934EA0(a2 + 0x48);
  sub_142934EC0(a2 + 0x30);
  return sub_1402A6590(a2);
}

// --- End Function: sub_144CAD040 (0x144CAD040) ---

// --- Function: sub_144CCE6A0 (0x144CCE6A0) ---
char __fastcall sub_144CCE6A0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v14; // rsp
  const char *p_null; // r8
  unsigned __int64 v16; // rax
  const char *p_null_1; // rdx
  unsigned __int64 v18; // rcx
  __int64 v20; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  _QWORD *v25; // [rsp+A0h] [rbp-E0h]
  Error **p_Error; // [rsp+A8h] [rbp-D8h]
  __int64 v27; // [rsp+B0h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1403EF810)(__int64, void *, size_t, __int64, char); // [rsp+B8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403EF370)(__int64, __int64, __int64, __int64); // [rsp+C0h] [rbp-C0h]
  __int64 v30; // [rsp+C8h] [rbp-B8h]
  bool (__fastcall *p_sub_1403EBA20)(__int64, __int64); // [rsp+D0h] [rbp-B0h]
  __int64 v32; // [rsp+D8h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E9250)(__int64); // [rsp+E0h] [rbp-A0h]
  _QWORD *(__fastcall *p_sub_1403E8F70)(_QWORD *); // [rsp+E8h] [rbp-98h]
  unsigned __int64 v35; // [rsp+F0h] [rbp-90h]
  char v36; // [rsp+F8h] [rbp-88h]
  char v37; // [rsp+F9h] [rbp-87h]
  __int64 n0x18; // [rsp+100h] [rbp-80h]
  unsigned __int64 v39; // [rsp+108h] [rbp-78h]
  _QWORD *v40; // [rsp+110h] [rbp-70h]
  const char *p_Name; // [rsp+118h] [rbp-68h]
  __int64 v42; // [rsp+120h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EF810_1)(__int64, void *, size_t, __int64, char); // [rsp+128h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EF370_1)(__int64, __int64, __int64, __int64); // [rsp+130h] [rbp-50h]
  __int64 v45; // [rsp+138h] [rbp-48h]
  bool (__fastcall *p_sub_1403EBA20_1)(__int64, __int64); // [rsp+140h] [rbp-40h]
  __int64 v47; // [rsp+148h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E9250_1)(__int64); // [rsp+150h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E8F70_1)(_QWORD *); // [rsp+158h] [rbp-28h]
  unsigned __int64 v50; // [rsp+160h] [rbp-20h]
  char v51; // [rsp+168h] [rbp-18h]
  char v52; // [rsp+169h] [rbp-17h]
  __int64 n0x18_1; // [rsp+170h] [rbp-10h]
  unsigned __int64 v54; // [rsp+178h] [rbp-8h]

  v14 = alloca(0x150);
  p_null = "null";
  __Val_0___[0] = a9;
  p_Error = "Error";
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  v25 = a10;
  __Val_0___[9] = sub_1403E8F30;
  v16 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v37 = 0;
  v27 = *a10;
  p_sub_1403EF810 = sub_1403EF810;
  p_sub_1403EF370 = sub_1403EF370;
  p_sub_1403EBA20 = sub_1403EBA20;
  p_sub_1403E9250 = sub_1403E9250;
  p_sub_1403E8F70 = sub_1403E8F70;
  v30 = 0;
  v32 = 0;
  v35 = 0xFFFFFFFFFFFFFFFFuLL;
  v36 = 0;
  n0x18 = 0x18;
  p_null_1 = "null";
  if ( a10[1] )
    p_null_1 = (const char *)a10[1];
  v18 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v18;
  while ( p_null_1[v18] );
  v39 = v18;
  p_Name = "Name";
  v40 = a11;
  v52 = 0;
  v42 = *a11;
  p_sub_1403EF810_1 = sub_1403EF810;
  p_sub_1403EF370_1 = sub_1403EF370;
  p_sub_1403EBA20_1 = sub_1403EBA20;
  p_sub_1403E9250_1 = sub_1403E9250;
  p_sub_1403E8F70_1 = sub_1403E8F70;
  v45 = 0;
  v47 = 0;
  v50 = 0xFFFFFFFFFFFFFFFFuLL;
  v51 = 0;
  n0x18_1 = 0x18;
  if ( a11[1] )
    p_null = (const char *)a11[1];
  do
    ++v16;
  while ( p_null[v16] );
  v54 = v16;
  LODWORD(v20) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 3u, a5, v20, a7, a8);
}

// --- End Function: sub_144CCE6A0 (0x144CCE6A0) ---

// --- Function: sub_144D1D2F0 (0x144D1D2F0) ---
__int64 __fastcall sub_144D1D2F0(__int64 a1)
{
  __int64 v2; // rcx

  *(_QWORD *)a1 = &off_148B0AD20;
  sub_140377960(a1 + 0x2E0);
  sub_1440F58D0(a1 + 0x2C0);
  v2 = *(_QWORD *)(a1 + 0x298);
  if ( v2 )
  {
    if ( ((*(_QWORD *)(a1 + 0x2A8) - v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = *(_QWORD *)(v2 - 8);
    }
    sub_1402A6590(v2);
    *(_QWORD *)(a1 + 0x298) = 0;
    *(_QWORD *)(a1 + 0x2A0) = 0;
    *(_QWORD *)(a1 + 0x2A8) = 0;
  }
  sub_142934E60(a1 + 0x278);
  std::vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_256_::search_node___((__int64 *)(a1 + 0x260));
  sub_1404684E0(a1 + 0x58);
  sub_140375A30((_DWORD *)(a1 + 0x40));
  return sub_140375A30((_DWORD *)(a1 + 0x3C));
}

// --- End Function: sub_144D1D2F0 (0x144D1D2F0) ---

// --- Function: sub_144D29930 (0x144D29930) ---
__int64 __fastcall sub_144D29930(__int64 ***a1, unsigned int *a2)
{
  __int64 **v2; // rsi
  __int64 *v4; // rbx
  __int64 inserted; // rcx
  __int64 v6; // rax
  unsigned int v7; // r8d
  __int64 v8; // rax
  __int128 v9; // xmm0
  __int128 v11; // [rsp+20h] [rbp-28h] BYREF

  v2 = *a1;
  DWORD2(v11) = 0;
  v4 = *v2;
  inserted = (__int64)*v2;
  v6 = (*v2)[1];
  *(_QWORD *)&v11 = v6;
  if ( !*(_BYTE *)(v6 + 0x19) )
  {
    v7 = *a2;
    do
    {
      *(_QWORD *)&v11 = v6;
      if ( *(_DWORD *)(v6 + 0x20) >= v7 )
      {
        inserted = v6;
        DWORD2(v11) = 1;
        v6 = *(_QWORD *)v6;
      }
      else
      {
        v6 = *(_QWORD *)(v6 + 0x10);
        DWORD2(v11) = 0;
      }
    }
    while ( !*(_BYTE *)(v6 + 0x19) );
  }
  if ( *(_BYTE *)(inserted + 0x19) || *a2 < *(_DWORD *)(inserted + 0x20) )
  {
    if ( v2[1] == (__int64 *)0x38E38E38E38E38ELL )
      unknown_libname_7();
    v8 = sub_1402A65A0(0x48u);
    *(_DWORD *)(v8 + 0x20) = *a2;
    *(_QWORD *)(v8 + 0x40) = 0;
    v9 = v11;
    *(_QWORD *)(v8 + 0x28) = 0;
    *(_QWORD *)(v8 + 0x30) = 0;
    *(_QWORD *)(v8 + 0x38) = 0;
    *(_BYTE *)(v8 + 0x40) = 1;
    *(_QWORD *)v8 = v4;
    *(_QWORD *)(v8 + 8) = v4;
    *(_QWORD *)(v8 + 0x10) = v4;
    *(_WORD *)(v8 + 0x18) = 0;
    v11 = v9;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 v2,
                 (__int64)&v11,
                 v8);
  }
  return inserted + 0x28;
}

// --- End Function: sub_144D29930 (0x144D29930) ---

// --- Function: sub_144D89CC0 (0x144D89CC0) ---
bool __fastcall sub_144D89CC0(__int64 *a1)
{
  __int64 v2; // r15
  int v3; // eax
  __int64 v4; // r12
  __int64 *v5; // rbp
  __int64 v6; // r14
  unsigned __int64 v7; // rdx
  __int64 v8; // rax
  double v9; // xmm1_8
  unsigned __int64 v10; // rcx
  __int64 v11; // rbx
  unsigned __int64 v12; // rcx
  __int64 v13; // rbx
  bool v14; // al
  double v15; // rcx
  __int64 v16; // rdx
  bool result; // al
  __m256 v18; // [rsp+20h] [rbp-68h] BYREF
  double v19; // [rsp+40h] [rbp-48h]
  char v20; // [rsp+98h] [rbp+10h] BYREF
  char v21; // [rsp+A0h] [rbp+18h] BYREF

  v2 = (a1[0x50] - a1[0x4F]) / 0x170;
  v3 = sub_1404C0350((__int64)(a1 + 0xB));
  v4 = v3;
  if ( v3 > 0 )
  {
    v5 = a1 + 0x6C;
    v6 = 0;
    do
    {
      v7 = (a1[0x4D] - a1[0x4C]) / 0x28;
      if ( v7 >= (int)v2 )
        break;
      __asm { vzeroupper }
      v8 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64))(*(_QWORD *)(v5[3] & 0xFFFFFFFFFFFFLL)
                                                                         + 0x668LL))(
             v5[3] & 0xFFFFFFFFFFFFLL,
             v7,
             0x6666666666666667LL);
      *(_QWORD *)&v18.m256_f32[6] = 0;
      v19 = 0.0;
      v9 = *((double *)v5 + 2);
      *(_OWORD *)v18.m256_f32 = *(_OWORD *)v5;
      *(double *)&v18.m256_f32[4] = v9;
      if ( v8 )
      {
        v10 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v8 + 0x38LL))(v8, &v20);
        *(_QWORD *)&v18.m256_f32[6] = v10;
        if ( !v10 )
          goto LABEL_17;
        v11 = v10 & 0xFFFFFFFFFFFFLL;
        v12 = HIWORD(v10);
        v13 = (v12 & 0xF000) != 0 ? v11 & 0xFFFFFF000000LL : v11 - 6;
        if ( *(_WORD *)(v13 + 2) != (v12 & 0xFFF) )
          goto LABEL_17;
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v14 = is_thread_privileged_or_bypass_mode()) )
          v14 = 1;
        if ( *(_WORD *)(v13 + 4) == 2 && v14 || sub_140395410(&v18.m256_f32[6]) )
          v15 = *(double *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)&v18.m256_f32[6]
                                                                                  & 0xFFFFFFFFFFFFLL)
                                                                      + 8LL))(
                             *(_QWORD *)&v18.m256_f32[6] & 0xFFFFFFFFFFFFLL,
                             &v21);
        else
LABEL_17:
          v15 = 0.0;
        v19 = v15;
      }
      if ( (unsigned __int8)sub_144E32E80(a1, &v18) )
      {
        v16 = a1[0x4D];
        if ( v16 == a1[0x4E] )
        {
          sub_1402A96C0(a1 + 0x4C, (_BYTE *)v16, (__int64)&v18);
        }
        else
        {
          *(__m256 *)v16 = v18;
          *(double *)(v16 + 0x20) = v19;
          a1[0x4D] += 0x28;
        }
      }
      ++v6;
      v5 += 0xA;
    }
    while ( v6 < v4 );
  }
  result = (a1[0x4D] - a1[0x4C]) / 0x28 == (int)v2;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_144D89CC0 (0x144D89CC0) ---

// --- Function: sub_144D90650 (0x144D90650) ---
__int64 __fastcall sub_144D90650(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v4; // rax
  double v5; // xmm1_8
  bool v6; // zf
  __int64 result; // rax

  v2 = *(_QWORD *)(a2 + 0x10);
  sub_14036F4A0();
  v4 = sub_1404C8440(v2);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)v2;
  v5 = *(double *)(v2 + 0x10);
  *(_QWORD *)(a1 + 0x160) = v4;
  v6 = v4 == 0;
  *(double *)(a1 + 0x18) = v5;
  result = a1;
  *(_BYTE *)(a1 + 0x191) = 1;
  if ( !v6 )
    *(_BYTE *)(a1 + 0x190) = 1;
  return result;
}

// --- End Function: sub_144D90650 (0x144D90650) ---

// --- Function: sub_144D937A0 (0x144D937A0) ---
__int64 __fastcall sub_144D937A0(__int64 a1)
{
  return sub_144D5D5A0(*(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_144D937A0 (0x144D937A0) ---

// --- Function: sub_144D94530 (0x144D94530) ---
__int64 __fastcall sub_144D94530(__int64 a1)
{
  return sub_144D6ACF0(*(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_144D94530 (0x144D94530) ---

// --- Function: sub_144D9D360 (0x144D9D360) ---
void __fastcall sub_144D9D360(
        int a1,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64, __int64); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( !a1 )
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
        __asm { vzeroupper }
        return;
      }
      v6 = sub_1402A65A0(0x28u);
      v7 = v6;
      if ( v6 )
      {
        *(__m256i *)v6 = *(__m256i *)v5;
        *(double *)(v6 + 0x20) = *((double *)v5 + 4);
      }
      else
      {
        v7 = 0;
      }
      a2[2] = (__int64 (__fastcall *)(__int64, __int64))v7;
      *a2 = sub_144D90650;
      a2[1] = (__int64 (__fastcall *)(__int64, __int64))sub_144D9D360;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      sub_1402A6590((__int64)a2[2]);
      a2[2] = 0;
      *a2 = 0;
      a2[1] = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
  {
    a2[2] = 0;
    *a2 = *a3;
    a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    a2[2] = a3[2];
    *a2 = *a3;
    a2[1] = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_144D9D360 (0x144D9D360) ---

// --- Function: sub_144DA2950 (0x144DA2950) ---
void __fastcall sub_144DA2950(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( !a1 )
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
        __asm { vzeroupper }
        return;
      }
      v6 = sub_1402A65A0(0x68u);
      v7 = v6;
      if ( v6 )
      {
        *(__m256i *)v6 = *(__m256i *)v5;
        *(__m256i *)(v6 + 0x20) = *((__m256i *)v5 + 1);
        *(__m256i *)(v6 + 0x40) = *((__m256i *)v5 + 2);
        *(double *)(v6 + 0x60) = *((double *)v5 + 0xC);
      }
      else
      {
        v7 = 0;
      }
      a2[2] = (__int64 (__fastcall *)(__int64))v7;
      *a2 = sub_144D937A0;
      a2[1] = (__int64 (__fastcall *)(__int64))sub_144DA2950;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      sub_1402A6590((__int64)a2[2]);
      a2[2] = 0;
      *a2 = 0;
      a2[1] = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
  {
    a2[2] = 0;
    *a2 = *a3;
    a2[1] = (__int64 (__fastcall *)(__int64))1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    a2[2] = a3[2];
    *a2 = *a3;
    a2[1] = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_144DA2950 (0x144DA2950) ---

// --- Function: sub_144DA49B0 (0x144DA49B0) ---
void __fastcall sub_144DA49B0(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __m256i *v5; // rdi
  __m256i *v6; // rax
  __m256i *v7; // rcx

  if ( !a1 )
  {
    v5 = (__m256i *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
        __asm { vzeroupper }
        return;
      }
      v6 = (__m256i *)sub_1402A65A0(0x60u);
      v7 = v6;
      if ( v6 )
      {
        *v6 = *v5;
        v6[1] = v5[1];
        v6[2] = v5[2];
      }
      else
      {
        v7 = 0;
      }
      a2[2] = (__int64 (__fastcall *)(__int64))v7;
      *a2 = sub_144D94530;
      a2[1] = (__int64 (__fastcall *)(__int64))sub_144DA49B0;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      sub_1402A6590((__int64)a2[2]);
      a2[2] = 0;
      *a2 = 0;
      a2[1] = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
  {
    a2[2] = 0;
    *a2 = *a3;
    a2[1] = (__int64 (__fastcall *)(__int64))1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    a2[2] = a3[2];
    *a2 = *a3;
    a2[1] = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_144DA49B0 (0x144DA49B0) ---

// --- Function: sub_144DD2640 (0x144DD2640) ---
const ULONG_PTR *__fastcall sub_144DD2640(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int128 v4; // xmm9
  __int128 v5; // xmm10
  __int128 v6; // xmm11
  __int128 v7; // xmm12
  __int128 v8; // xmm13
  __int128 v9; // xmm14
  __int128 v10; // xmm15
  const ULONG_PTR *n29; // rax
  __int64 v12; // r13
  __int64 v13; // rsi
  int v14; // ebx
  unsigned int v15; // eax
  _QWORD *v16; // r12
  __int64 v17; // rbx
  double *v18; // rax
  __int64 v19; // rdi
  __int128 n0x3F800000; // xmm11
  __int64 v22; // r8
  float v23; // xmm9_4
  float v25; // xmm7_4
  float v26; // xmm10_4
  __int64 v29; // rbx
  __int64 v30; // r14
  bool v31; // al
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rcx
  double v35; // xmm0_8
  __int128 v41; // kr00_16
  const char *v42; // rdx
  size_t Size; // r8
  __int64 v45; // rax
  _QWORD *v46; // rax
  const char *v47; // rax
  __int64 v48; // rax
  __int64 v49; // rbx
  __int64 (__fastcall *v50)(__int64, char *, __int16 *); // r14
  __int16 n0xFFFF; // ax
  __int64 v52; // rbx
  __int64 v53; // rax
  __int16 n4; // dx
  const char *v55; // rax
  __int64 v56; // rax
  __int128 v57; // kr00_16
  __int64 v63; // rax
  const void *v64; // rcx
  unsigned __int64 v65; // rax
  __int64 v66; // rbx
  __int64 v67; // r14
  bool v68; // al
  __int64 v69; // rax
  __int64 *v70; // rbx
  double *v71; // rax
  double v72; // xmm1_8
  const char *v73; // rdx
  size_t Size_1; // r8
  __int64 v75; // rax
  _QWORD *v76; // rax
  const char *v77; // rax
  __int64 v78; // rax
  __int64 v79; // rax
  __int64 v80; // rax
  __int64 v83; // rax
  int v84; // r13d
  __int64 v85; // r8
  __int64 v86; // rax
  double *v87; // rax
  double v88; // xmm1_8
  _LocaleUpdate *v89; // rbx
  __int64 v90; // rax
  const char *v91; // rax
  __int64 v92; // r8
  __int64 v93; // rax
  void **v94; // r14
  void **v95; // r15
  __int64 v96; // rbx
  int v97; // eax
  unsigned __int32 v98; // eax
  int v99; // [rsp+20h] [rbp-E0h]
  int v100; // [rsp+20h] [rbp-E0h]
  int v101; // [rsp+20h] [rbp-E0h]
  const char *v102; // [rsp+38h] [rbp-C8h]
  char v103; // [rsp+50h] [rbp-B0h]
  __int64 v104; // [rsp+58h] [rbp-A8h] BYREF
  _BYTE v105[4]; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v106; // [rsp+64h] [rbp-9Ch] BYREF
  _BYTE v107[4]; // [rsp+68h] [rbp-98h] BYREF
  unsigned int v108; // [rsp+6Ch] [rbp-94h] BYREF
  __int64 v109; // [rsp+70h] [rbp-90h]
  __int16 n0xFFFF_1; // [rsp+78h] [rbp-88h] BYREF
  __int64 v111; // [rsp+80h] [rbp-80h] BYREF
  __int128 v112; // [rsp+88h] [rbp-78h] BYREF
  double v113; // [rsp+98h] [rbp-68h]
  char v114[4]; // [rsp+A0h] [rbp-60h] BYREF
  int n0x6000000; // [rsp+A4h] [rbp-5Ch] BYREF
  char v116[8]; // [rsp+A8h] [rbp-58h] BYREF
  unsigned __int64 v117; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 v118; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v119; // [rsp+C0h] [rbp-40h]
  _QWORD *v120; // [rsp+C8h] [rbp-38h]
  __int128 v121; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v122; // [rsp+E8h] [rbp-18h] BYREF
  double v123; // [rsp+F0h] [rbp-10h]
  double v124; // [rsp+F8h] [rbp-8h]
  double v125; // [rsp+100h] [rbp+0h]
  __int64 v126; // [rsp+108h] [rbp+8h]
  __int128 v127; // [rsp+110h] [rbp+10h] BYREF
  double v128; // [rsp+120h] [rbp+20h]
  double v129; // [rsp+128h] [rbp+28h] BYREF
  double v130; // [rsp+130h] [rbp+30h]
  double v131; // [rsp+138h] [rbp+38h]
  double v132; // [rsp+140h] [rbp+40h]
  double v133; // [rsp+148h] [rbp+48h]
  double v134; // [rsp+150h] [rbp+50h]
  char v135[8]; // [rsp+158h] [rbp+58h] BYREF
  __int64 v136; // [rsp+160h] [rbp+60h] BYREF
  __int128 v137; // [rsp+168h] [rbp+68h] BYREF
  char v138[8]; // [rsp+178h] [rbp+78h] BYREF
  char v139[8]; // [rsp+180h] [rbp+80h] BYREF
  __int128 v140; // [rsp+188h] [rbp+88h] BYREF
  double v141; // [rsp+198h] [rbp+98h]
  __int128 v142; // [rsp+1A0h] [rbp+A0h] BYREF
  double v143; // [rsp+1B0h] [rbp+B0h]
  __int128 v144; // [rsp+1C0h] [rbp+C0h] BYREF
  double v145; // [rsp+1D0h] [rbp+D0h]
  __int128 v146; // [rsp+1E0h] [rbp+E0h] BYREF
  double v147; // [rsp+1F0h] [rbp+F0h]
  char v148[8]; // [rsp+200h] [rbp+100h] BYREF
  char v149[24]; // [rsp+208h] [rbp+108h] BYREF
  char v150[24]; // [rsp+220h] [rbp+120h] BYREF
  char v151[64]; // [rsp+238h] [rbp+138h] BYREF
  char v152[72]; // [rsp+278h] [rbp+178h] BYREF
  unsigned __int64 v153; // [rsp+2C0h] [rbp+1C0h] BYREF
  __int64 n0x1FF; // [rsp+2C8h] [rbp+1C8h]
  _BYTE *v155; // [rsp+2D0h] [rbp+1D0h]
  _BYTE v156[520]; // [rsp+2D8h] [rbp+1D8h] BYREF
  __int64 v157; // [rsp+4E0h] [rbp+3E0h] BYREF
  __int64 n0x1FF_1; // [rsp+4E8h] [rbp+3E8h]
  _BYTE *v159; // [rsp+4F0h] [rbp+3F0h]
  _BYTE v160[520]; // [rsp+4F8h] [rbp+3F8h] BYREF
  __int64 v161; // [rsp+700h] [rbp+600h] BYREF
  __int64 n0x1FF_2; // [rsp+708h] [rbp+608h]
  _BYTE *v163; // [rsp+710h] [rbp+610h]
  _BYTE v164[520]; // [rsp+718h] [rbp+618h] BYREF
  __int64 v165; // [rsp+920h] [rbp+820h] BYREF
  __int64 n0x1FF_3; // [rsp+928h] [rbp+828h]
  _BYTE *v167; // [rsp+930h] [rbp+830h]
  _BYTE v168[520]; // [rsp+938h] [rbp+838h] BYREF
  __int64 v169; // [rsp+B40h] [rbp+A40h] BYREF
  __int64 n0x1FF_4; // [rsp+B48h] [rbp+A48h]
  _BYTE *v171; // [rsp+B50h] [rbp+A50h]
  _BYTE v172[520]; // [rsp+B58h] [rbp+A58h] BYREF
  __int64 v173; // [rsp+D60h] [rbp+C60h] BYREF
  __int64 n0x1FF_6; // [rsp+D68h] [rbp+C68h]
  _BYTE *v175; // [rsp+D70h] [rbp+C70h]
  _BYTE v176[520]; // [rsp+D78h] [rbp+C78h] BYREF
  __int64 v177; // [rsp+F80h] [rbp+E80h] BYREF
  __int64 n0x1FF_5; // [rsp+F88h] [rbp+E88h]
  _BYTE *v179; // [rsp+F90h] [rbp+E90h]
  _BYTE v180[520]; // [rsp+F98h] [rbp+E98h] BYREF
  __int128 v181; // [rsp+11B0h] [rbp+10B0h]
  __int128 v182; // [rsp+11C0h] [rbp+10C0h]
  __int128 v183; // [rsp+11D0h] [rbp+10D0h]
  __int128 v184; // [rsp+11E0h] [rbp+10E0h]
  __int128 v185; // [rsp+11F0h] [rbp+10F0h]
  __int128 v186; // [rsp+1200h] [rbp+1100h]
  __int128 v187; // [rsp+1210h] [rbp+1110h]
  __int128 v188; // [rsp+1220h] [rbp+1120h]
  __int128 v189; // [rsp+1230h] [rbp+1130h]
  __int128 v190; // [rsp+1240h] [rbp+1140h]

  n29 = (const ULONG_PTR *)::n29;
  v12 = a1;
  v119 = a1;
  if ( *(_DWORD *)(::n29 + 0xAD8) )
  {
    v13 = a1 + 0x478;
    v126 = a1 + 0x478;
    v14 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v13 + 0x10) == v14 )
    {
      ++*(_DWORD *)(v13 + 0x14);
    }
    else
    {
      v15 = _InterlockedCompareExchange((volatile signed __int32 *)v13, 1, 0);
      if ( v15 )
        sub_1403C6E80(v13, v15, (__int64)"CSpawningManager::DebugDrawSpawnRequestInfo", 1);
      else
        *(_QWORD *)(v13 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v13 + 0x10) = v14;
    }
    v16 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                      qword_149C8DF80,
                      0);
    v120 = v16;
    v109 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x590LL))(qword_149C8E018);
    v17 = v109;
    (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v109 + 0x10LL))(v109, v116);
    n0x6000000 = 0x6000000;
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v17 + 8LL))(v17, &n0x6000000);
    v18 = (double *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x3D0LL))(qword_149C8DFE0);
    v19 = *(_QWORD *)(v12 + 0x460);
    v124 = v18[3];
    v123 = v18[7];
    v125 = v18[0xB];
    if ( v19 != *(_QWORD *)(v12 + 0x468) )
    {
      v190 = v1;
      v189 = v2;
      v188 = v3;
      v187 = v4;
      v186 = v5;
      v185 = v6;
      n0x3F800000 = 0x3F800000u;
      v184 = v7;
      v183 = v8;
      v182 = v9;
      v181 = v10;
      _XMM13 = 0;
      while ( 1 )
      {
        v22 = *(_QWORD *)(v19 + 0x58);
        v23 = 0.64700001;
        _XMM0 = 0;
        v113 = 0.0;
        v156[0] = 0;
        v155 = v156;
        v153 = 0;
        n0x1FF = 0x1FF;
        __asm { vmovupd [rbp+1170h+var_11E8], xmm0 }
        v25 = 1.0;
        v26 = 0.0;
        v103 = 0;
        (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
          qword_149C8DFC0,
          &v117,
          v22);
        sub_14059CA60(v16, &v136, (_QWORD *)(v19 + 0x68));
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
          qword_149C8DFC0,
          &v104,
          *(_QWORD *)(v19 + 0x50));
        if ( *(_QWORD *)(v19 + 0x68) && *(float *)&_XMM6 > *(float *)(::n29 + 0xADC) )
        {
          v103 = 1;
        }
        else
        {
          if ( !*(_DWORD *)(::n29 + 0xAE4)
            || !*(_QWORD *)(v19 + 0x58)
            || is_entity_descriptor_valid_or_accessible(&v117) )
          {
            v29 = v104;
            if ( !v104 )
              goto LABEL_66;
            v30 = (v104 & 0xF000000000000000uLL) != 0 ? v104 & 0xFFFFFF000000LL : (v104 & 0xFFFFFFFFFFFFLL) - 6;
            if ( *(_WORD *)(v30 + 2) != (HIWORD(v104) & 0xFFF) )
              goto LABEL_66;
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v31 = is_thread_privileged_or_bypass_mode(), v29 = v104, v31) )
              v31 = 1;
            if ( *(_WORD *)(v30 + 4) == 2 && v31 )
            {
LABEL_29:
              if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v29 & 0xFFFFFFFFFFFFLL) + 0x50LL))(v29 & 0xFFFFFFFFFFFFLL) )
                goto LABEL_66;
              LOBYTE(v99) = 0;
              v32 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD, _QWORD, int))(*(_QWORD *)(v104 & 0xFFFFFFFFFFFFLL)
                                                                                    + 0x1E8LL))(
                      v104 & 0xFFFFFFFFFFFFLL,
                      v151,
                      0,
                      0,
                      v99);
              v112 = *(_OWORD *)(v32 + 0x20);
              v113 = *(double *)(v32 + 0x30);
              *(_QWORD *)(v19 + 0x48) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(v104 & 0xFFFFFFFFFFFFLL)
                                                                                              + 0x660LL))(
                                                     v104 & 0xFFFFFFFFFFFFLL,
                                                     v138);
              v33 = (*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)(v104 & 0xFFFFFFFFFFFFLL) + 0x1E8LL))(
                      v104 & 0xFFFFFFFFFFFFLL,
                      v152,
                      2);
              v34 = v104 & 0xFFFFFFFFFFFFLL;
              v35 = *(double *)(v33 + 0x30);
              *(_OWORD *)(v19 + 0x28) = *(_OWORD *)(v33 + 0x20);
              *(double *)(v19 + 0x38) = v35;
              *(_BYTE *)(v19 + 0x60) = 1;
              *(_QWORD *)(v19 + 0x68) = *v16;
              (*(void (__fastcall **)(__int64, double *))(*(_QWORD *)v34 + 0x298LL))(v34, &v129);
              if ( v129 <= v132 )
              {
                _XMM2 = COERCE_UNSIGNED_INT64((v133 - v130) * (v133 - v130) + (v132 - v129) * (v132 - v129) + (v134 - v131) * (v134 - v131));
                __asm
                {
                  vmovddup xmm0, xmm2
                  vsqrtpd xmm4, xmm0
                  vunpckhpd xmm4, xmm4, xmm4
                }
                *((_QWORD *)&v41 + 1) = *((_QWORD *)&_XMM4 + 1);
                *(double *)&v41 = *(double *)&_XMM4 * 0.5;
                _XMM0 = v41;
              }
              else
              {
                _XMM0 = 0;
              }
              v42 = *(const char **)v19;
              __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
              *(float *)(v19 + 0x40) = *(float *)&_XMM0;
              if ( v42 )
              {
                Size = 0xFFFFFFFFFFFFFFFFuLL;
                do
                  ++Size;
                while ( v42[Size] );
              }
              else
              {
                Size = 0;
              }
              sub_1402A6440((__int64)&v153, v42, Size);
              v160[0] = 0;
              v159 = v160;
              v157 = 0;
              n0x1FF_1 = 0x1FF;
              v45 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v104 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v104 & 0xFFFFFFFFFFFFLL);
              v46 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v45 + 0x30LL))(v45, v139);
              v47 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*v46 & 0xFFFFFFFFFFFFLL) + 0x70LL))(*v46 & 0xFFFFFFFFFFFFLL);
              v48 = sub_1402A59F0((__int64)&v157, "\n[Zone]: %s", v47);
              sub_1402E13B0(&v153, *(const void **)(v48 + 0x10), *(_QWORD *)v48);
              if ( v159 != v160 )
              {
                qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
                sub_147715880(v159);
              }
              if ( *(_BYTE *)(v19 + 0x61) )
                goto LABEL_51;
              v49 = v104 & 0xFFFFFFFFFFFFLL;
              v50 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)(v104 & 0xFFFFFFFFFFFFLL) + 0x340LL);
              n0xFFFF = n0xFFFF_25;
              if ( n0xFFFF_25 == (__int16)0xFFFF )
              {
                n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                             + 0x10LL))(
                                      qword_149C8DFC8,
                                      v114,
                                      "IEntityComponentNetwork");
                n0xFFFF_25 = n0xFFFF;
              }
              n0xFFFF_1 = n0xFFFF;
              v52 = *(_QWORD *)v50(v49, v148, &n0xFFFF_1);
              v122 = v52;
              if ( v52 )
              {
                v53 = sub_1403B84E0(v52 & 0xFFFFFFFFFFFFLL);
                n4 = *(_WORD *)(v53 + 4);
                if ( n4 != 4
                  && *(_WORD *)(v53 + 2) == (HIWORD(v52) & 0xFFF)
                  && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v122))
                  && *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v52 & 0xFFFFFFFFFFFFLL) + 0x600LL))(v52 & 0xFFFFFFFFFFFFLL)
                              + 0x20) == 2 )
                {
                  *(_BYTE *)(v19 + 0x61) = 1;
                }
              }
              if ( *(_BYTE *)(v19 + 0x61) )
              {
LABEL_51:
                v23 = 0.54500002;
                v25 = 0.133;
                v26 = 0.133;
              }
              else
              {
                v25 = 0.67799997;
                v26 = 0.184;
                v23 = 1.0;
              }
            }
            else
            {
              if ( sub_140395410(&v104) )
              {
                v29 = v104;
                goto LABEL_29;
              }
LABEL_66:
              (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                qword_149C8DFC0,
                &v111,
                *(_QWORD *)(v19 + 0x48));
              v66 = v111;
              if ( v111 )
              {
                v67 = (v111 & 0xF000000000000000uLL) != 0 ? v111 & 0xFFFFFF000000LL : (v111 & 0xFFFFFFFFFFFFLL) - 6;
                if ( *(_WORD *)(v67 + 2) == (HIWORD(v111) & 0xFFF) )
                {
                  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D)
                    || (v68 = is_thread_privileged_or_bypass_mode(), v66 = v111, v68) )
                  {
                    v68 = 1;
                  }
                  if ( *(_WORD *)(v67 + 4) == 2 && v68 )
                  {
LABEL_78:
                    v69 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v66 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v66 & 0xFFFFFFFFFFFFLL);
                    v70 = (__int64 *)v69;
                    if ( v69 )
                    {
                      v71 = (double *)(*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v69 + 0x170LL))(
                                        v69,
                                        v150,
                                        v19 + 0x28);
                    }
                    else
                    {
                      v72 = *(double *)(v19 + 0x38);
                      v140 = *(_OWORD *)(v19 + 0x28);
                      v141 = v72;
                      v71 = (double *)&v140;
                    }
                    v73 = *(const char **)v19;
                    v112 = *(_OWORD *)v71;
                    v113 = v71[2];
                    if ( v73 )
                    {
                      Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
                      do
                        ++Size_1;
                      while ( v73[Size_1] );
                    }
                    else
                    {
                      Size_1 = 0;
                    }
                    sub_1402A6440((__int64)&v153, v73, Size_1);
                    v164[0] = 0;
                    v163 = v164;
                    v75 = *v70;
                    v161 = 0;
                    n0x1FF_2 = 0x1FF;
                    v76 = (_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *))(v75 + 0x30))(v70, v135);
                    v77 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*v76 & 0xFFFFFFFFFFFFLL)
                                                                           + 0x70LL))(*v76 & 0xFFFFFFFFFFFFLL);
                    v78 = sub_1402A59F0((__int64)&v161, "\n[Zone]: %s", v77);
                    sub_1402E13B0(&v153, *(const void **)(v78 + 0x10), *(_QWORD *)v78);
                    if ( v163 != v164 )
                    {
                      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_2;
                      sub_147715880(v163);
                    }
                    if ( *(_BYTE *)(v19 + 0x60) )
                    {
                      v25 = *(_BYTE *)(v19 + 0x61) ? 0.50199997 : 1.0;
                      v168[0] = 0;
                      v167 = v168;
                      v165 = 0;
                      v23 = 0.0;
                      v26 = 0.0;
                      n0x1FF_3 = 0x1FF;
                      v79 = sub_1402A59F0((__int64)&v165, "\nLast Seen: %.0fs", *(float *)&_XMM6);
                      sub_1402E13B0(&v153, *(const void **)(v79 + 0x10), *(_QWORD *)v79);
                      if ( v167 != v168 )
                      {
                        qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_3;
                        sub_147715880(v167);
                      }
                    }
                  }
                  else if ( sub_140395410(&v111) )
                  {
                    v66 = v111;
                    goto LABEL_78;
                  }
                }
              }
            }
            v17 = v109;
            goto LABEL_54;
          }
          v103 = 1;
        }
LABEL_54:
        if ( v153 && (*(double *)&v112 != 0.0 || *((double *)&v112 + 1) != 0.0 || v113 != 0.0) )
        {
          *(float *)&v121 = v25;
          *((float *)&v121 + 1) = v23;
          *((float *)&v121 + 2) = v26;
          *((float *)&v121 + 3) = 1.0;
          if ( is_entity_descriptor_valid_or_accessible(&v117) )
          {
            v172[0] = 0;
            v171 = v172;
            v169 = 0;
            n0x1FF_4 = 0x1FF;
            v55 = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v117 & 0xFFFFFFFFFFFFLL)
                                                                            + 0x70LL))(v117 & 0xFFFFFFFFFFFFLL);
            v56 = sub_1402A59F0((__int64)&v169, "\nOwner: %s", v55);
            sub_1402E13B0(&v153, *(const void **)(v56 + 0x10), *(_QWORD *)v56);
            if ( v171 != v172 )
            {
              qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_4;
              sub_147715880(v171);
            }
          }
          if ( *(_BYTE *)(v19 + 0x61) )
            sub_1402E13B0(&v153, "\n[AutoBury]", 0xBu);
          *((_QWORD *)&v57 + 1) = 0;
          *(double *)&v57 = (*(double *)&v112 - v124) * (*(double *)&v112 - v124)
                          + (*((double *)&v112 + 1) - v123) * (*((double *)&v112 + 1) - v123)
                          + (v113 - v125) * (v113 - v125);
          _XMM2 = v57;
          __asm
          {
            vmovddup xmm1, xmm2
            vsqrtpd xmm4, xmm1
            vunpckhpd xmm4, xmm4, xmm4
            vcvtsd2ss xmm0, xmm4, xmm4
          }
          if ( *(float *)&_XMM0 < 1000.0 )
          {
            v180[0] = 0;
            v179 = v180;
            v177 = 0;
            n0x1FF_5 = 0x1FF;
            v80 = sub_1402A59F0((__int64)&v177, "\n%.2fm", *(float *)&_XMM0);
            sub_1402E13B0(&v153, *(const void **)(v80 + 0x10), *(_QWORD *)v80);
            v64 = v179;
            if ( v179 != v180 )
            {
              v65 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_5;
LABEL_95:
              qword_149C78668 += v65;
              sub_147715880(v64);
            }
          }
          else
          {
            v176[0] = 0;
            v175 = v176;
            v173 = 0;
            n0x1FF_6 = 0x1FF;
            v63 = sub_1402A59F0((__int64)&v173, "\n%.2fkm", (float)(*(float *)&_XMM0 * 0.001));
            sub_1402E13B0(&v153, *(const void **)(v63 + 0x10), *(_QWORD *)v63);
            v64 = v175;
            if ( v175 != v176 )
            {
              v65 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_6;
              goto LABEL_95;
            }
          }
          v142 = v112;
          v143 = v113;
          sub_1409E0AF0((__int64)qword_149C8E018, (__int64)&v142, 1.2, &v121, 1u, 1u, (__int64)&format_string_, v155);
          __asm
          {
            vcmpltss xmm0, xmm13, xmm1
            vblendvps xmm1, xmm11, xmm1, xmm0
          }
          v83 = *(_QWORD *)v17;
          v84 = (int)(float)(1.0 * 255.0);
          v105[3] = v84;
          v105[0] = (int)(float)(v25 * 255.0);
          v105[1] = (int)(float)(v23 * 255.0);
          v105[2] = (int)(float)(v26 * 255.0);
          LOBYTE(v100) = 0;
          (*(void (__fastcall **)(__int64, __int128 *, __int64, _BYTE *, int, unsigned int))(v83 + 0xE0))(
            v17,
            &v112,
            v85,
            v105,
            v100,
            0xFFFFFFFF);
          if ( *(_DWORD *)(::n29 + 0xAD8) == 2 )
          {
            (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
              qword_149C8DFC0,
              &v118,
              *(_QWORD *)(v19 + 0x20));
            if ( is_entity_descriptor_valid_or_accessible(&v118) )
            {
              v86 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v118 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v118 & 0xFFFFFFFFFFFFLL);
              if ( v86 )
              {
                v87 = (double *)(*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v86 + 0x170LL))(
                                  v86,
                                  v149,
                                  v19 + 8);
              }
              else
              {
                v88 = *(double *)(v19 + 0x18);
                v144 = *(_OWORD *)(v19 + 8);
                v145 = v88;
                v87 = (double *)&v144;
              }
              v89 = qword_149C8E018;
              v127 = *(_OWORD *)v87;
              v128 = v87[2];
              v90 = *(_QWORD *)(v118 & 0xFFFFFFFFFFFFLL);
              v137 = xmmword_14832FCA0;
              v91 = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(v90 + 0x70))(v118 & 0xFFFFFFFFFFFFLL);
              v102 = *(const char **)v19;
              v146 = v127;
              v147 = v128;
              sub_1409E0AF0((__int64)v89, (__int64)&v146, 1.2, &v137, 1u, 1u, (__int64)"%s\nZH:%s", v102, v91);
              v17 = v109;
              v106 = 0xFF00FFFF;
              LOBYTE(v101) = 0;
              (*(void (__fastcall **)(__int64, __int128 *, __int64, unsigned int *, int, unsigned int))(*(_QWORD *)v109 + 0xE0LL))(
                v109,
                &v127,
                v92,
                &v106,
                v101,
                0xFFFFFFFF);
              v93 = *(_QWORD *)v17;
              v108 = 0xFF00FFFF;
              v107[0] = (int)(float)(v25 * 255.0);
              v107[1] = (int)(float)(v23 * 255.0);
              v107[2] = (int)(float)(v26 * 255.0);
              v107[3] = v84;
              (*(void (__fastcall **)(__int64, __int128 *, _BYTE *, __int128 *, unsigned int *, int, unsigned int))(v93 + 0x30))(
                v17,
                &v112,
                v107,
                &v127,
                &v108,
                0x3F800000,
                0xFFFFFFFF);
            }
          }
          v12 = v119;
          v16 = v120;
        }
        v94 = (void **)(v19 + 0x88);
        if ( v103 )
        {
          v95 = *(void ***)(v12 + 0x468);
          if ( v94 != v95 )
          {
            v96 = v19 + 0x20;
            do
            {
              sub_14037AE80((void **)(v96 - 0x20), v94);
              *(_OWORD *)(v96 - 0x18) = *(_OWORD *)(v96 + 0x70);
              *(double *)(v96 - 8) = *(double *)(v96 + 0x80);
              v94 += 0x11;
              *(_QWORD *)v96 = *(_QWORD *)(v96 + 0x88);
              *(_OWORD *)(v96 + 8) = *(_OWORD *)(v96 + 0x90);
              *(double *)(v96 + 0x18) = *(double *)(v96 + 0xA0);
              *(_DWORD *)(v96 + 0x20) = *(_DWORD *)(v96 + 0xA8);
              *(_QWORD *)(v96 + 0x28) = *(_QWORD *)(v96 + 0xB0);
              *(_QWORD *)(v96 + 0x30) = *(_QWORD *)(v96 + 0xB8);
              *(_QWORD *)(v96 + 0x38) = *(_QWORD *)(v96 + 0xC0);
              *(_BYTE *)(v96 + 0x40) = *(_BYTE *)(v96 + 0xC8);
              *(_BYTE *)(v96 + 0x41) = *(_BYTE *)(v96 + 0xC9);
              *(_QWORD *)(v96 + 0x48) = *(_QWORD *)(v96 + 0xD0);
              *(_BYTE *)(v96 + 0x50) = *(_BYTE *)(v96 + 0xD8);
              *(_BYTE *)(v96 + 0x51) = *(_BYTE *)(v96 + 0xD9);
              *(_OWORD *)(v96 + 0x58) = *(_OWORD *)(v96 + 0xE0);
              v96 += 0x88;
            }
            while ( v94 != v95 );
            v17 = v109;
          }
          sub_140373CC0((_QWORD *)(*(_QWORD *)(v12 + 0x468) - 0x88LL));
          *(_QWORD *)(v12 + 0x468) -= 0x88LL;
        }
        else
        {
          v19 += 0x88;
        }
        if ( v155 != v156 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
          sub_147715880(v155);
        }
        if ( v19 == *(_QWORD *)(v12 + 0x468) )
        {
          v13 = v126;
          break;
        }
      }
    }
    (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v17 + 8LL))(v17, v116);
    v97 = *(_DWORD *)(v13 + 0x14);
    if ( v97 )
    {
      n29 = (const ULONG_PTR *)(unsigned int)(v97 - 1);
      *(_DWORD *)(v13 + 0x14) = (_DWORD)n29;
    }
    else
    {
      *(_DWORD *)(v13 + 0x10) = 0xFFFFFFFF;
      v98 = _InterlockedCompareExchange((volatile signed __int32 *)v13, 0, 1);
      if ( v98 == 1 )
      {
        n29 = &p_Src;
        *(_QWORD *)(v13 + 8) = &p_Src;
      }
      else
      {
        return sub_1403DF590(v13, v98);
      }
    }
  }
  return n29;
}

// --- End Function: sub_144DD2640 (0x144DD2640) ---

// --- Function: sub_144DD3BA0 (0x144DD3BA0) ---
void sub_144DD3BA0()
{
  __int64 v0; // rax

  if ( Parameter_0 )
  {
    v0 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000000A);
    if ( v0 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v0 + 8LL))(v0);
  }
}

// --- End Function: sub_144DD3BA0 (0x144DD3BA0) ---

// --- Function: sub_144DF1470 (0x144DF1470) ---
__int64 __fastcall sub_144DF1470(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rax
  __int64 v10; // rdi
  __int64 v11; // rdi
  _BYTE v13[24]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v14; // [rsp+48h] [rbp-40h] BYREF
  __int128 v15; // [rsp+50h] [rbp-38h]
  __int128 v16; // [rsp+60h] [rbp-28h] BYREF
  __int64 v17; // [rsp+70h] [rbp-18h]
  char v18; // [rsp+78h] [rbp-10h]
  char v19; // [rsp+98h] [rbp+10h] BYREF

  if ( n0xFFFF_26 == (__int16)0xFFFF )
    n0xFFFF_26 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                             qword_149C8DFC8,
                             &v19,
                             "EntityComponentDefaultLoadout");
  v2 = sub_1405B92D0(a1);
  if ( !v2 )
    return 0;
  v3 = *(_QWORD *)(v2 + 0x18);
  if ( !v3 )
    return 0;
  v13[0] = 0;
  *(_OWORD *)&v13[4] = xmmword_1482ECF20;
  v14 = 0;
  v17 = 0;
  v15 = 0;
  v16 = 0;
  v18 = 0;
  sub_1405B73F0(
    v3,
    (unsigned int)v13,
    0,
    0,
    0,
    0,
    *(_QWORD *)v13,
    (unsigned __int64)((unsigned __int128)xmmword_1482ECF20 >> 0x20),
    *(_QWORD *)&v13[0x10]);
  v4 = v14;
  v5 = v15;
  if ( v14 == (_QWORD)v15 )
  {
LABEL_14:
    sub_1403E52D0(&v16);
    sub_1403E53A0(&v14);
    return 0;
  }
  while ( 1 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x20LL))(v6, *(_QWORD *)(v4 + 0x48));
    v8 = v7;
    if ( v7 )
    {
      v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DFB8 + 0x280LL))(qword_149C8DFB8, v7);
      if ( v9 )
      {
        if ( *(_DWORD *)(v9 + 8) == 0x88 )
        {
          if ( n0xFFFF_27 == (__int16)0xFFFF )
            n0xFFFF_27 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                            + 0x10LL))(
                                     qword_149C8DFC8,
                                     &v19,
                                     "SCItemQuantumDrive");
          v10 = sub_144C7AE20(v8);
          if ( v10 )
            break;
        }
      }
    }
    v11 = sub_144DF16A0(v4);
    if ( v11 )
    {
      if ( n0xFFFF_27 == (__int16)0xFFFF )
        n0xFFFF_27 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                        + 0x10LL))(
                                 qword_149C8DFC8,
                                 &v19,
                                 "SCItemQuantumDrive");
      v10 = sub_144C7AE20(v11);
      break;
    }
    v4 += 0x88;
    if ( v4 == v5 )
      goto LABEL_14;
  }
  sub_1403E52D0(&v16);
  sub_1403E53A0(&v14);
  return v10;
}

// --- End Function: sub_144DF1470 (0x144DF1470) ---

// --- Function: sub_144E28C60 (0x144E28C60) ---
char __fastcall sub_144E28C60(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  _BYTE v10[24]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v11; // [rsp+48h] [rbp-40h] BYREF
  __int128 v12; // [rsp+50h] [rbp-38h]
  __int128 v13; // [rsp+60h] [rbp-28h] BYREF
  __int64 v14; // [rsp+70h] [rbp-18h]
  char v15; // [rsp+78h] [rbp-10h]
  char v16; // [rsp+98h] [rbp+10h] BYREF

  if ( n0xFFFF_26 == (__int16)0xFFFF )
    n0xFFFF_26 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                             qword_149C8DFC8,
                             &v16,
                             "EntityComponentDefaultLoadout");
  v2 = sub_1405B92D0(a1);
  if ( !v2 )
    return 0;
  v3 = *(_QWORD *)(v2 + 0x18);
  if ( !v3 )
    return 0;
  v10[0] = 0;
  *(_OWORD *)&v10[4] = xmmword_1482ECF20;
  v11 = 0;
  v14 = 0;
  v12 = 0;
  v13 = 0;
  v15 = 0;
  sub_1405B73F0(
    v3,
    (unsigned int)v10,
    0,
    0,
    0,
    0,
    *(_QWORD *)v10,
    (unsigned __int64)((unsigned __int128)xmmword_1482ECF20 >> 0x20),
    *(_QWORD *)&v10[0x10]);
  v4 = v11;
  v5 = v12;
  if ( v11 == (_QWORD)v12 )
  {
LABEL_11:
    sub_1403E52D0(&v13);
    sub_1403E53A0(&v11);
    return 0;
  }
  while ( 1 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x20LL))(v6, *(_QWORD *)(v4 + 0x48));
    if ( v7 )
    {
      v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DFB8 + 0x280LL))(qword_149C8DFB8, v7);
      if ( v8 )
      {
        if ( *(_DWORD *)(v8 + 8) == 0x88 )
          break;
      }
    }
    if ( sub_144DF16A0(v4) )
      break;
    v4 += 0x88;
    if ( v4 == v5 )
      goto LABEL_11;
  }
  sub_1403E52D0(&v13);
  sub_1403E53A0(&v11);
  return 1;
}

// --- End Function: sub_144E28C60 (0x144E28C60) ---

// --- Function: sub_144E32E80 (0x144E32E80) ---
__int64 __fastcall sub_144E32E80(__int64 a1, double *a2)
{
  __int64 result; // rax
  __int64 v5; // rax
  double v6; // xmm1_8
  __int64 v7; // rdi
  __int64 (__fastcall *v8)(__int64, __int128 *); // rbx
  __int64 v9; // rax
  char v10; // al
  bool v11; // di
  __int64 v12; // rbx
  __int128 v13; // [rsp+20h] [rbp-78h] BYREF
  double v14; // [rsp+30h] [rbp-68h]
  char v15[24]; // [rsp+38h] [rbp-60h] BYREF
  __int128 v16; // [rsp+50h] [rbp-48h] BYREF
  __int64 v17; // [rsp+60h] [rbp-38h]
  __int128 v18; // [rsp+68h] [rbp-30h]
  double v19; // [rsp+78h] [rbp-20h]
  __int64 v20; // [rsp+A0h] [rbp+8h] BYREF
  char v21; // [rsp+B0h] [rbp+18h] BYREF

  if ( !*(_DWORD *)sub_1404BF960(a1 + 0x58, &v20) || (result = sub_1404C0350(a1 + 0x58), (_DWORD)result) )
  {
    v5 = sub_1404C8440(a2);
    if ( v5 )
    {
      (*(void (__fastcall **)(__int64, __int128 *, double *))(*(_QWORD *)v5 + 0x170LL))(v5, &v13, a2);
    }
    else
    {
      v6 = a2[2];
      v13 = *(_OWORD *)a2;
      v14 = v6;
    }
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xF8LL))(qword_149C8DFB8);
    v8 = *(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v7 + 0x80LL);
    v9 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
                                                            + 0x2C8LL))(
           *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL,
           v15,
           0);
    v16 = *(_OWORD *)v9;
    v17 = *(_QWORD *)(v9 + 0x10);
    v19 = v14;
    v18 = v13;
    v10 = v8(v7, &v16);
    v11 = v10 == 0;
    if ( !v10 )
    {
      v12 = sub_1404C8440(a2);
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v12 + 0x30LL))(v12, &v20);
      for ( ;
            (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x48LL))(v12) == 2;
            v20 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v12 + 0x30LL))(v12, &v21) )
      {
        v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v20 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v20 & 0xFFFFFFFFFFFFLL);
      }
      if ( sub_1404C8440(a2) != v12 )
        sub_1414C2310(a2, v12);
    }
    return v11;
  }
  return result;
}

// --- End Function: sub_144E32E80 (0x144E32E80) ---

// --- Function: sub_144E58F40 (0x144E58F40) ---
__int64 __fastcall sub_144E58F40(__int64 a1)
{
  __int64 p_rw_lock_state; // rbx
  signed __int64 v3; // rdx
  __int64 result; // rax
  int v5; // [rsp+40h] [rbp+8h] BYREF

  v5 = *(_DWORD *)(a1 + 0x2D8);
  p_rw_lock_state = j_psub_140338BA0();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state + 0x14);
  }
  else
  {
    v3 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (v3 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        p_rw_lock_state,
        v3,
        "SCigEventDispatcher::QueueEvent",
        "SCigEventSystemWithLinks::GetLinkUnlinkLock()",
        1);
  }
  sub_144C868C0(a1 + 0x2E0, (__int64)&v5);
  result = rw_lock_release_read_lock(p_rw_lock_state);
  *(_DWORD *)(a1 + 0x54) = 9;
  return result;
}

// --- End Function: sub_144E58F40 (0x144E58F40) ---

// --- Function: sub_144E78CA0 (0x144E78CA0) ---
__int64 __fastcall sub_144E78CA0(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int128 v4; // xmm9
  __int128 v5; // xmm10
  __int128 v6; // xmm11
  __int128 v7; // xmm12
  __int128 v8; // xmm13
  __int128 v9; // xmm14
  __int128 v10; // xmm15
  __int64 v11; // rax
  int v13; // r13d
  __int64 v14; // r14
  __int64 v15; // r12
  __int64 v16; // rbx
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __m256 v20; // ymm1
  __int64 v21; // rcx
  __int64 v25; // rbx
  __int64 v26; // rax
  unsigned __int64 v27; // rcx
  __int64 v28; // rbx
  unsigned __int64 v29; // rcx
  __int64 v30; // rbx
  bool v31; // al
  __int64 v32; // rcx
  double v33; // rbx
  unsigned __int64 v34; // rax
  __int64 v35; // rax
  unsigned __int64 *v36; // rax
  unsigned __int64 v37; // rdi
  __int64 v38; // rbx
  bool v39; // al
  __int64 v40; // rbx
  unsigned __int64 v41; // rax
  __int64 v42; // rsi
  void (__fastcall *v43)(__int64, double *, __int64, __int64); // rdi
  __int64 v44; // rbx
  __int64 v45; // rax
  double *v46; // rax
  double v47; // xmm1_8
  double v48; // xmm3_8
  double v49; // xmm4_8
  double v50; // xmm5_8
  double v57; // xmm4_8
  double v58; // xmm6_8
  double v59; // xmm7_8
  double v60; // kr00_8
  double v61; // rbx
  unsigned __int64 v62; // rax
  __int64 v63; // rax
  unsigned __int64 v64; // rcx
  __int64 v65; // rbx
  unsigned __int64 v66; // rcx
  unsigned __int64 v67; // rbx
  bool v68; // al
  __int64 v69; // rax
  __int64 v70; // rax
  __int64 v71; // rax
  __int64 v72; // rcx
  __int64 v73; // rcx
  __int64 v75; // rsi
  char *v76; // rbx
  __int64 (__fastcall *v77)(__int64, char *, _QWORD); // rdi
  unsigned int v78; // eax
  unsigned int *v79; // rbx
  _QWORD *v80; // rax
  __int64 v81; // rcx
  __int64 v82; // rdi
  char *v83; // rsi
  __int64 (__fastcall *v84)(__int64, char *, _QWORD); // rbx
  unsigned int v85; // eax
  unsigned int *v86; // rbx
  _QWORD *v87; // rax
  __int64 v88; // rcx
  __int64 v89; // rdi
  char *v90; // rsi
  __int64 (__fastcall *v91)(__int64, char *, _QWORD); // rbx
  unsigned int v92; // eax
  unsigned int *v93; // rbx
  _QWORD *v94; // rax
  __int64 v95; // rcx
  __int64 v96; // rsi
  char *v97; // rbx
  __int64 (__fastcall *v98)(__int64, char *, _QWORD); // rdi
  unsigned int v99; // eax
  __int64 v100; // rdx
  _BOOL8 v101; // rcx
  unsigned int *v102; // rbx
  __int64 v103; // r8
  int v104; // r8d
  __int64 v105; // r9
  bool v106; // cl
  bool v107; // dl
  bool v108; // cl
  bool v109; // al
  _QWORD *v110; // r9
  unsigned __int64 v111; // rdi
  unsigned __int64 v112; // r11
  char v113; // r10
  bool v114; // al
  char v115; // r10
  unsigned int v116; // eax
  bool v117; // al
  __int64 v118; // rdi
  __int64 (__fastcall *v119)(__int64, const char *, _QWORD); // rbx
  unsigned int v120; // eax
  unsigned int *v121; // rbx
  int v122; // r8d
  unsigned __int64 v123; // r9
  bool v124; // cl
  bool v125; // dl
  bool v126; // cl
  bool v127; // al
  int v128; // r8d
  unsigned __int64 v129; // r9
  bool v130; // cl
  char v131; // al
  bool v132; // dl
  bool v133; // al
  bool v134; // al
  _QWORD *v135; // rax
  __int64 v136; // rcx
  __int64 v137; // rdi
  __int64 (__fastcall *v138)(__int64, const char *, _QWORD); // rbx
  unsigned int v139; // eax
  unsigned int *v140; // rbx
  _QWORD *v141; // rax
  __int64 v142; // rcx
  double v143; // xmm3_8
  double v144; // xmm5_8
  double v145; // xmm4_8
  double v150; // xmm9_8
  __int128 v151; // xmm3
  __int128 v152; // kr00_16
  double v153; // xmm6_8
  double v154; // xmm10_8
  double v155; // xmm7_8
  __int128 v156; // kr00_16
  double v157; // xmm5_8
  double v158; // xmm6_8
  double v163; // xmm9_8
  double v164; // xmm3_8
  double v165; // xmm4_8
  double v166; // xmm1_8
  double *v167; // rax
  double v169; // xmm3_8
  double v170; // kr00_8
  __int128 v173; // kr00_16
  double v174; // xmm1_8
  double v180; // rbx
  unsigned __int64 v181; // rax
  __int64 v182; // rax
  unsigned __int64 *v183; // rax
  __int64 v184; // rdi
  __int64 v185; // rbx
  bool v186; // al
  double v187; // rbx
  unsigned __int64 v188; // rax
  __int64 v189; // rsi
  void (__fastcall *v190)(__int64, double *, __int64, __int64); // rdi
  __int64 v191; // rbx
  __int64 v192; // rax
  double *v193; // rax
  double v194; // xmm1_8
  double v195; // xmm1_8
  double v196; // rbx
  unsigned __int64 v197; // rax
  __int64 v198; // rcx
  _QWORD *v199; // rax
  bool v200; // zf
  _QWORD *v201; // rax
  double v202; // xmm6_8
  _QWORD *v203; // rbx
  __int64 v204; // rcx
  void (__fastcall *v205)(_QWORD *, __int64 *, __int64, const char *, __int64 (__fastcall **)(__int64, __int64)); // rdi
  __int64 v206; // rax
  _QWORD *v207; // rdx
  volatile signed __int32 *v208; // rbx
  __int64 v209; // rdx
  __int64 v210; // rbx
  float v211; // xmm0_4
  __int64 v212; // r9
  __m256 v214; // [rsp+40h] [rbp-1088h] BYREF
  double v215; // [rsp+60h] [rbp-1068h]
  unsigned int v216; // [rsp+68h] [rbp-1060h] BYREF
  unsigned int v217; // [rsp+6Ch] [rbp-105Ch] BYREF
  unsigned int v218; // [rsp+70h] [rbp-1058h] BYREF
  __int64 v219; // [rsp+78h] [rbp-1050h] BYREF
  __int128 v220; // [rsp+80h] [rbp-1048h] BYREF
  double v221; // [rsp+90h] [rbp-1038h]
  unsigned __int64 v222; // [rsp+98h] [rbp-1030h] BYREF
  __int64 v223; // [rsp+A0h] [rbp-1028h]
  __m256 v224; // [rsp+A8h] [rbp-1020h] BYREF
  double v225; // [rsp+C8h] [rbp-1000h]
  __int128 v226; // [rsp+D0h] [rbp-FF8h] BYREF
  __int64 v227; // [rsp+E0h] [rbp-FE8h]
  unsigned __int64 v228; // [rsp+E8h] [rbp-FE0h] BYREF
  unsigned __int64 v229; // [rsp+F0h] [rbp-FD8h] BYREF
  unsigned __int64 v230; // [rsp+F8h] [rbp-FD0h] BYREF
  unsigned __int64 v231; // [rsp+100h] [rbp-FC8h] BYREF
  __int64 v232; // [rsp+108h] [rbp-FC0h]
  void *(__fastcall **v233)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+110h] [rbp-FB8h] BYREF
  unsigned __int64 v234; // [rsp+118h] [rbp-FB0h]
  __int64 (__fastcall *p_sub_144D90650)(__int64, __int64); // [rsp+120h] [rbp-FA8h] BYREF
  void (__fastcall *p_sub_144D9D360)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+128h] [rbp-FA0h]
  double v237; // [rsp+130h] [rbp-F98h]
  __m256 v238; // [rsp+138h] [rbp-F90h] BYREF
  double v239; // [rsp+158h] [rbp-F70h]
  unsigned __int64 v240; // [rsp+160h] [rbp-F68h] BYREF
  unsigned __int64 v241; // [rsp+168h] [rbp-F60h] BYREF
  unsigned __int64 v242; // [rsp+170h] [rbp-F58h] BYREF
  unsigned __int64 v243; // [rsp+178h] [rbp-F50h] BYREF
  void *(__fastcall **v244)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+180h] [rbp-F48h] BYREF
  __int64 v245; // [rsp+188h] [rbp-F40h]
  __int64 v246; // [rsp+190h] [rbp-F38h]
  __int64 v247; // [rsp+198h] [rbp-F30h] BYREF
  void *(__fastcall **v248)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+1A0h] [rbp-F28h] BYREF
  __int64 v249; // [rsp+1A8h] [rbp-F20h]
  void *(__fastcall **v250)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+1B0h] [rbp-F18h] BYREF
  __int64 v251; // [rsp+1B8h] [rbp-F10h]
  void *(__fastcall **v252)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+1C0h] [rbp-F08h] BYREF
  __int64 v253; // [rsp+1C8h] [rbp-F00h]
  int v254; // [rsp+1D0h] [rbp-EF8h] BYREF
  __int16 v255; // [rsp+1D4h] [rbp-EF4h]
  int v256; // [rsp+1D8h] [rbp-EF0h]
  __int64 v257; // [rsp+1E0h] [rbp-EE8h]
  double v258; // [rsp+1E8h] [rbp-EE0h]
  __int64 v260; // [rsp+200h] [rbp-EC8h]
  __int64 v261; // [rsp+208h] [rbp-EC0h]
  _QWORD v262[2]; // [rsp+210h] [rbp-EB8h] BYREF
  __int64 v263; // [rsp+220h] [rbp-EA8h] BYREF
  void (__fastcall *n2_1)(__int64, __int64 *); // [rsp+228h] [rbp-EA0h]
  __int64 v265; // [rsp+230h] [rbp-E98h]
  _QWORD v266[2]; // [rsp+240h] [rbp-E88h] BYREF
  _QWORD v267[2]; // [rsp+250h] [rbp-E78h] BYREF
  _QWORD v268[2]; // [rsp+260h] [rbp-E68h] BYREF
  _QWORD v269[2]; // [rsp+270h] [rbp-E58h] BYREF
  _QWORD v270[3]; // [rsp+280h] [rbp-E48h] BYREF
  double v271[3]; // [rsp+298h] [rbp-E30h] BYREF
  _QWORD v272[3]; // [rsp+2B0h] [rbp-E18h] BYREF
  char v273; // [rsp+2C8h] [rbp-E00h]
  _QWORD v274[3]; // [rsp+2D0h] [rbp-DF8h] BYREF
  char v275; // [rsp+2E8h] [rbp-DE0h]
  _QWORD v276[3]; // [rsp+2F0h] [rbp-DD8h] BYREF
  char v277; // [rsp+308h] [rbp-DC0h]
  _QWORD v278[3]; // [rsp+310h] [rbp-DB8h] BYREF
  char v279; // [rsp+328h] [rbp-DA0h]
  _QWORD v280[3]; // [rsp+330h] [rbp-D98h] BYREF
  char v281; // [rsp+348h] [rbp-D80h]
  int v282; // [rsp+350h] [rbp-D78h] BYREF
  __int64 v283; // [rsp+358h] [rbp-D70h]
  __int64 v286; // [rsp+380h] [rbp-D48h]
  __int64 v287; // [rsp+388h] [rbp-D40h]
  double v289; // [rsp+3A0h] [rbp-D28h]
  __int64 v290; // [rsp+3A8h] [rbp-D20h]
  __int64 v291; // [rsp+3B0h] [rbp-D18h]
  double v292; // [rsp+3B8h] [rbp-D10h]
  double v294; // [rsp+3D0h] [rbp-CF8h]
  __int64 v295; // [rsp+3D8h] [rbp-CF0h]
  __int64 v296; // [rsp+3E0h] [rbp-CE8h]
  __int64 v297; // [rsp+3E8h] [rbp-CE0h]
  volatile signed __int32 *v298; // [rsp+3F0h] [rbp-CD8h]
  __int64 v299; // [rsp+3F8h] [rbp-CD0h]
  float v300; // [rsp+400h] [rbp-CC8h]
  float v301; // [rsp+404h] [rbp-CC4h]
  float v302; // [rsp+408h] [rbp-CC0h]
  char v303; // [rsp+40Ch] [rbp-CBCh]
  __int64 v304; // [rsp+410h] [rbp-CB8h]
  int n2; // [rsp+418h] [rbp-CB0h]
  __int16 v306; // [rsp+41Ch] [rbp-CACh]
  __int64 v307; // [rsp+420h] [rbp-CA8h]
  char v308; // [rsp+428h] [rbp-CA0h]
  __int64 v309; // [rsp+430h] [rbp-C98h]
  char v310[8]; // [rsp+440h] [rbp-C88h] BYREF
  char v311[8]; // [rsp+448h] [rbp-C80h] BYREF
  char v312[8]; // [rsp+450h] [rbp-C78h] BYREF
  char v313[8]; // [rsp+458h] [rbp-C70h] BYREF
  char v314[8]; // [rsp+460h] [rbp-C68h] BYREF
  char v315[8]; // [rsp+468h] [rbp-C60h] BYREF
  char v316[8]; // [rsp+470h] [rbp-C58h] BYREF
  char v317[8]; // [rsp+478h] [rbp-C50h] BYREF
  char v318[8]; // [rsp+480h] [rbp-C48h] BYREF
  char v319[8]; // [rsp+488h] [rbp-C40h] BYREF
  char v320[8]; // [rsp+490h] [rbp-C38h] BYREF
  char v321[8]; // [rsp+498h] [rbp-C30h] BYREF
  char v322[8]; // [rsp+4A0h] [rbp-C28h] BYREF
  char v323[8]; // [rsp+4A8h] [rbp-C20h] BYREF
  char v324[8]; // [rsp+4B0h] [rbp-C18h] BYREF
  char v325[8]; // [rsp+4B8h] [rbp-C10h] BYREF
  char v326[8]; // [rsp+4C0h] [rbp-C08h] BYREF
  char v327[8]; // [rsp+4C8h] [rbp-C00h] BYREF
  char v328[8]; // [rsp+4D0h] [rbp-BF8h] BYREF
  char v329[8]; // [rsp+4D8h] [rbp-BF0h] BYREF
  char v330[8]; // [rsp+4E0h] [rbp-BE8h] BYREF
  char v331[8]; // [rsp+4E8h] [rbp-BE0h] BYREF
  __int128 v332; // [rsp+4F0h] [rbp-BD8h]
  double v333; // [rsp+500h] [rbp-BC8h]
  __m256 v334; // [rsp+510h] [rbp-BB8h] BYREF
  double v335; // [rsp+530h] [rbp-B98h]
  __m256 v336; // [rsp+540h] [rbp-B88h]
  char v337[24]; // [rsp+560h] [rbp-B68h] BYREF
  double v338[3]; // [rsp+578h] [rbp-B50h] BYREF
  double v339[3]; // [rsp+590h] [rbp-B38h] BYREF
  double v340[7]; // [rsp+5A8h] [rbp-B20h] BYREF
  double v341[8]; // [rsp+5E0h] [rbp-AE8h] BYREF
  _BYTE v342[2512]; // [rsp+620h] [rbp-AA8h] BYREF
  __int128 v343; // [rsp+1000h] [rbp-C8h]
  __int128 v344; // [rsp+1010h] [rbp-B8h]
  __int128 v345; // [rsp+1020h] [rbp-A8h]
  __int128 v346; // [rsp+1030h] [rbp-98h]
  __int128 v347; // [rsp+1040h] [rbp-88h]
  __int128 v348; // [rsp+1050h] [rbp-78h]
  __int128 v349; // [rsp+1060h] [rbp-68h]
  __int128 v350; // [rsp+1070h] [rbp-58h]
  __int128 v351; // [rsp+1080h] [rbp-48h]
  __int128 v352; // [rsp+1090h] [rbp-38h]

  v11 = *(_QWORD *)(a1 + 0x280);
  v13 = 0;
  v14 = *(_QWORD *)(a1 + 0x278);
  v227 = 0;
  v246 = v11;
  v226 = 0;
  v15 = 0;
  if ( v14 != v11 )
  {
    v16 = 0;
    v347 = v6;
    v346 = v7;
    v345 = v8;
    v344 = v9;
    v343 = v10;
    v352 = v1;
    v351 = v2;
    v350 = v3;
    v349 = v4;
    v348 = v5;
    while ( 1 )
    {
      v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
      v18 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v17 + 0x20LL))(v17, *(_QWORD *)v14);
      if ( sub_144E28C60(v18) )
        break;
      sub_1405C6220(4u, 0, "A vehicle in the wave being spawned does not contain a quantum drive.");
LABEL_189:
      v14 += 0x170;
      if ( v14 == v246 )
        goto LABEL_190;
    }
    if ( *(_BYTE *)(a1 + 0x18) )
    {
      *(double *)(v14 + 0x68) = *(double *)(a1 + 0x28);
      *(_DWORD *)(v14 + 0x70) = *(_DWORD *)(a1 + 0x30);
      *(_QWORD *)(v14 + 0x78) = *(_QWORD *)(a1 + 0x20);
    }
    if ( *(_BYTE *)(a1 + 0x38) )
      sub_14037CAC0((_DWORD *)(v14 + 0x80), (_DWORD *)(a1 + 0x3C));
    v19 = *(_QWORD *)(a1 + 0x260);
    v232 = v16 + 1;
    v20 = *(__m256 *)(v19 + 0x28 * v16);
    v21 = *(_QWORD *)(a1 + 8);
    v215 = *(double *)(v19 + 0x28 * v16 + 0x20);
    _XMM0 = 0;
    __asm
    {
      vmovupd xmmword ptr [rsp+10C8h+var_1020], xmm0
      vmovupd [rsp+10C8h+var_D68], xmm0
      vmovupd [rsp+10C8h+var_D38], xmm0
    }
    v292 = -1.0;
    _XMM0 = 0;
    v214 = v20;
    _XMM1 = 0;
    v300 = 0.0;
    v301 = 0.0;
    v302 = 0.0;
    __asm { vmovupd [rsp+10C8h+var_D08], xmm0 }
    *(double *)&v224.m256_f32[4] = 0.0;
    v289 = 0.0;
    v294 = 0.0;
    __asm { vmovupd [rsp+10C8h+var_D58], xmm1 }
    *(_QWORD *)&v224.m256_f32[6] = 0;
    v225 = 0.0;
    v282 = 0;
    v283 = 0;
    v286 = 0;
    v287 = 0;
    v290 = 0;
    v291 = 0;
    v295 = 0;
    v296 = 0;
    v297 = 0;
    v298 = 0;
    v299 = 0;
    v303 = 0;
    v304 = 0;
    n2 = 2;
    v306 = 0;
    v307 = 0;
    v308 = 1;
    v309 = 0;
    __asm { vzeroupper }
    v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v21 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v21 & 0xFFFFFFFFFFFFLL);
    v26 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
                                                             + 0x278LL))(
            *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL,
            v337,
            0);
    v220 = *(_OWORD *)v26;
    *(_QWORD *)&_XMM1 = *(_QWORD *)(v26 + 0x10);
    v222 = 0;
    v223 = 0;
    v221 = *(double *)&_XMM1;
    if ( v25 )
    {
      v27 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v25 + 0x38LL))(v25, v328);
      v222 = v27;
      if ( !v27 )
        goto LABEL_22;
      v28 = v27 & 0xFFFFFFFFFFFFLL;
      v29 = HIWORD(v27);
      v30 = (v29 & 0xF000) != 0 ? v28 & 0xFFFFFF000000LL : v28 - 6;
      if ( *(_WORD *)(v30 + 2) != (v29 & 0xFFF) )
        goto LABEL_22;
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v31 = is_thread_privileged_or_bypass_mode()) )
        v31 = 1;
      if ( *(_WORD *)(v30 + 4) == 2 && v31 || sub_140395410(&v222) )
        v32 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(v222 & 0xFFFFFFFFFFFFLL) + 8LL))(
                           v222 & 0xFFFFFFFFFFFFLL,
                           v329);
      else
LABEL_22:
        v32 = 0;
      v223 = v32;
    }
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v214.m256_f32[6])
      && (v33 = v215,
          *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)&v214.m256_f32[6]
                                                                            & 0xFFFFFFFFFFFFLL)
                                                                + 8LL))(
                       *(_QWORD *)&v214.m256_f32[6] & 0xFFFFFFFFFFFFLL,
                       v330) == *(_QWORD *)&v33) )
    {
      v34 = *(_QWORD *)&v214.m256_f32[6];
    }
    else
    {
      v34 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, double))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                         qword_149C8DFC0,
                         v331,
                         COERCE_DOUBLE(*(_QWORD *)&v215));
      *(_QWORD *)&v214.m256_f32[6] = v34;
    }
    v240 = v34;
    if ( !is_entity_descriptor_valid_or_accessible(&v240)
      || (v35 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v240 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v240 & 0xFFFFFFFFFFFFLL)) == 0 )
    {
LABEL_49:
      v48 = *(double *)v214.m256_f32 - *(double *)&v220;
      v49 = *(double *)&v214.m256_f32[2] - *((double *)&v220 + 1);
      v50 = *(double *)&v214.m256_f32[4] - v221;
      _XMM0 = COERCE_UNSIGNED_INT64(v49 * v49 + v48 * v48 + v50 * v50);
      if ( v49 * v49 + v48 * v48 + v50 * v50 <= 9.999999682655225e-21 )
      {
        _XMM2 = 0;
        __asm { vmovupd xmm3, xmm2 }
        v57 = 1.0;
      }
      else
      {
        __asm
        {
          vmovddup xmm0, xmm0
          vsqrtpd xmm1, xmm0
          vunpckhpd xmm1, xmm1, xmm1
        }
        *(double *)&_XMM2 = 1.0 / *(double *)&_XMM1 * v48;
        *(double *)&_XMM3 = 1.0 / *(double *)&_XMM1 * v49;
        v57 = 1.0 / *(double *)&_XMM1 * v50;
      }
      v58 = *(double *)&_XMM2 * *(double *)&qword_149B7B058 + *(double *)v214.m256_f32;
      v59 = *(double *)&_XMM3 * *(double *)&qword_149B7B058 + *(double *)&v214.m256_f32[2];
      v60 = v57 * *(double *)&qword_149B7B058 + *(double *)&v214.m256_f32[4];
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v214.m256_f32[6])
        && (v61 = v215,
            *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)&v214.m256_f32[6]
                                                                              & 0xFFFFFFFFFFFFLL)
                                                                  + 8LL))(
                         *(_QWORD *)&v214.m256_f32[6] & 0xFFFFFFFFFFFFLL,
                         v315) == *(_QWORD *)&v61) )
      {
        v62 = *(_QWORD *)&v214.m256_f32[6];
      }
      else
      {
        v62 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, double))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                           qword_149C8DFC0,
                           v316,
                           COERCE_DOUBLE(*(_QWORD *)&v215));
        *(_QWORD *)&v214.m256_f32[6] = v62;
      }
      v241 = v62;
      if ( is_entity_descriptor_valid_or_accessible(&v241) )
      {
        v63 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v241 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v241 & 0xFFFFFFFFFFFFLL);
        *(_QWORD *)&v238.m256_f32[6] = 0;
        v239 = 0.0;
        *(double *)v238.m256_f32 = v58;
        *(double *)&v238.m256_f32[2] = v59;
        *(double *)&v238.m256_f32[4] = v60;
        if ( v63 )
        {
          v64 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v63 + 0x38LL))(v63, v317);
          *(_QWORD *)&v238.m256_f32[6] = v64;
          if ( !v64 )
            goto LABEL_70;
          v65 = v64 & 0xFFFFFFFFFFFFLL;
          v66 = HIWORD(v64);
          v67 = (v66 & 0xF000) != 0 ? v65 & 0xFFFFFFFFFF000000uLL : v65 - 6;
          if ( *(_WORD *)(v67 + 2) != (v66 & 0xFFF) )
            goto LABEL_70;
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v68 = is_thread_privileged_or_bypass_mode()) )
            v68 = 1;
          if ( *(_WORD *)(v67 + 4) == 2 && v68 || sub_140395410(&v238.m256_f32[6]) )
            v239 = *(double *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)&v238.m256_f32[6]
                                                                                     & 0xFFFFFFFFFFFFLL)
                                                                         + 8LL))(
                                *(_QWORD *)&v238.m256_f32[6] & 0xFFFFFFFFFFFFLL,
                                v318);
          else
LABEL_70:
            v239 = 0.0;
        }
      }
      else
      {
        *(double *)v238.m256_f32 = v58;
        *(double *)&v238.m256_f32[2] = v59;
        *(double *)&v238.m256_f32[4] = v60;
        *(_QWORD *)&v238.m256_f32[6] = 0;
        v239 = 0.0;
      }
      v69 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
      v70 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v69 + 0x20LL))(v69, *(_QWORD *)v14);
      if ( v70 && (v71 = sub_144DF1470(v70)) != 0 )
      {
        sub_145421300(
          v71,
          (unsigned int)&v238,
          (unsigned int)&v214,
          (unsigned int)&v282,
          (__int64)&v216,
          (__int64)&v217,
          (__int64)&v218,
          (__int64)&v224);
        v72 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
                                                                    + 8LL))(
                           *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL,
                           v327);
        v308 = *(_BYTE *)(a1 + 0x50);
        v309 = v72;
      }
      else
      {
        v224 = v238;
        v225 = v239;
      }
      v73 = *(_QWORD *)(a1 + 8);
      _XMM0 = 0;
      __asm { vmovupd [rsp+10C8h+var_ED8], xmm0 }
      v334 = v214;
      v258 = 0.0;
      v254 = 0;
      v255 = 0;
      v256 = 0;
      v257 = 0;
      v260 = 0;
      v261 = 0;
      v335 = v215;
      __asm { vzeroupper }
      sub_145421720(v73, &v334, &v254);
      v75 = *(_QWORD *)(v14 + 0x150);
      v76 = off_149B7B368[0];                   // "qdrv.snapshotVars"
      v77 = *(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)v75 + 0x28LL);
      v78 = sub_142643440();
      v79 = (unsigned int *)v77(v75, v76, v78);
      if ( v79 )
      {
        v248 = &off_1482C5768;
        v249 = 0;
        sub_144C92410((__int64)&v248, &v282);
        sub_140422000(v79, (unsigned __int64)(v249 + 7) >> 3);
        v80 = v79 + 2;
        v81 = 8LL * *v79;
        if ( v79[1] > 0x10 )
          v80 = (_QWORD *)*v80;
        v272[0] = v80;
        v272[1] = v81;
        v269[0] = &off_1482C5768;
        v272[2] = 0;
        v269[1] = v272;
        v273 = 1;
        sub_144C9B370((__int64)v269, (__int64)&v282);
      }
      v82 = *(_QWORD *)(v14 + 0x150);
      v83 = off_149B7B370[0];                   // "qdrv.spoolRatio"
      v84 = *(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)v82 + 0x28LL);
      v85 = sub_14052D150();
      v86 = (unsigned int *)v84(v82, v83, v85);
      if ( v86 )
      {
        v250 = &off_1482C5768;
        v251 = 0;
        sub_14052A3B0((__int64)&v250);
        sub_140422000(v86, (unsigned __int64)(v251 + 7) >> 3);
        v87 = v86 + 2;
        v88 = 8LL * *v86;
        if ( v86[1] > 0x10 )
          v87 = (_QWORD *)*v87;
        v274[0] = v87;
        v274[1] = v88;
        v262[0] = &off_1482C5768;
        v274[2] = 0;
        v262[1] = v274;
        v275 = 1;
        sub_14052AA80((__int64)v262, (__int64)v83, &v216);
      }
      v89 = *(_QWORD *)(v14 + 0x150);
      v90 = off_149B7B378[0];                   // "qdrv.currentCalibrationRatio"
      v91 = *(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)v89 + 0x28LL);
      v92 = sub_14052D150();
      v93 = (unsigned int *)v91(v89, v90, v92);
      if ( v93 )
      {
        v252 = &off_1482C5768;
        v253 = 0;
        sub_14052A3B0((__int64)&v252);
        sub_140422000(v93, (unsigned __int64)(v253 + 7) >> 3);
        v94 = v93 + 2;
        v95 = 8LL * *v93;
        if ( v93[1] > 0x10 )
          v94 = (_QWORD *)*v94;
        v276[0] = v94;
        v276[1] = v95;
        v266[0] = &off_1482C5768;
        v276[2] = 0;
        v266[1] = v276;
        v277 = 1;
        sub_14052AA80((__int64)v266, (__int64)v90, &v217);
      }
      v96 = *(_QWORD *)(v14 + 0x150);
      v97 = off_149B7B380[0];                   // "qdrv.currentState"
      v98 = *(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)v96 + 0x28LL);
      v99 = sub_142647CF0();
      v102 = (unsigned int *)v98(v96, v97, v99);
      if ( v102 )
      {
        v104 = v218;
        v105 = 0;
        do
        {
          v105 += 8;
          v106 = (v104 & 0x40) != 0;
          v104 >>= 7;
          v107 = v106;
          v108 = 0;
          if ( v104 )
            v108 = !v107;
          v109 = 0;
          if ( v104 != 0xFFFFFFFF )
            v109 = v107;
        }
        while ( v109 || v108 );
        sub_140422000(v102, (unsigned __int64)(v105 + 7) >> 3);
        v110 = v102 + 2;
        v111 = 8LL * *v102;
        if ( v102[1] > 0x10 )
          v110 = (_QWORD *)*v110;
        v103 = v218;
        v112 = 0;
        if ( v110 )
        {
          do
          {
            v100 = 0;
            v113 = v103;
            v114 = (v103 & 0x40) != 0;
            v103 = (unsigned int)((int)v103 >> 7);
            v101 = v114;
            v115 = v113 & 0x7F;
            v116 = !v114;
            if ( (_DWORD)v103 )
              v100 = v116;
            v117 = 0;
            if ( (_DWORD)v103 != 0xFFFFFFFF )
              v117 = v101;
            v112 += 8LL;
            LOBYTE(v100) = v117 | v100;
            if ( v112 <= v111 )
            {
              *(_BYTE *)v110 = v115 | ((_BYTE)v100 << 7);
              v110 = (_QWORD *)((char *)v110 + 1);
            }
          }
          while ( (_BYTE)v100 );
        }
      }
      v118 = *(_QWORD *)(v14 + 0x150);
      v119 = *(__int64 (__fastcall **)(__int64, const char *, _QWORD))(*(_QWORD *)v118 + 0x28LL);
      v120 = sub_142643570(v101, v100, v103);
      v121 = (unsigned int *)v119(v118, "qdrive_new.snapshotVars", v120);
      if ( v121 )
      {
        v122 = v254;
        v233 = &off_1482C5768;
        v123 = 0;
        do
        {
          v123 += 8LL;
          v124 = (v122 & 0x40) != 0;
          v122 >>= 7;
          v125 = v124;
          v126 = 0;
          if ( v122 )
            v126 = !v125;
          v127 = 0;
          if ( v122 != 0xFFFFFFFF )
            v127 = v125;
        }
        while ( v127 || v126 );
        v234 = v123;
        sub_14052A590((__int64)&v233);
        v128 = v256;
        v129 = (v234 + 7) & 0xFFFFFFFFFFFFFFF8uLL;
        do
        {
          v130 = 0;
          v129 += 8LL;
          v131 = v128;
          v128 >>= 7;
          v132 = (v131 & 0x40) != 0;
          v133 = (v131 & 0x40) == 0;
          if ( v128 )
            v130 = v133;
          v134 = 0;
          if ( v128 != 0xFFFFFFFF )
            v134 = v132;
        }
        while ( v134 || v130 );
        v234 = v129;
        sub_14052A3D0((__int64)&v233);
        sub_1405C6400((__int64)&v233);
        sub_140422000(v121, (v234 + 7) >> 3);
        v135 = v121 + 2;
        v136 = 8LL * *v121;
        if ( v121[1] > 0x10 )
          v135 = (_QWORD *)*v135;
        v278[0] = v135;
        v278[1] = v136;
        v268[0] = &off_1482C5768;
        v278[2] = 0;
        v268[1] = v278;
        v279 = 1;
        sub_144C9B6E0((__int64)v268, (__int64)&v254);
      }
      v137 = *(_QWORD *)(v14 + 0x150);
      v138 = *(__int64 (__fastcall **)(__int64, const char *, _QWORD))(*(_QWORD *)v137 + 0x28LL);
      v139 = sub_14052D0E0();
      v140 = (unsigned int *)v138(v137, "smn.quantumSpawnId", v139);
      if ( v140 )
      {
        v244 = &off_1482C5768;
        v245 = 0;
        sub_14052A3B0((__int64)&v244);
        sub_140422000(v140, (unsigned __int64)(v245 + 7) >> 3);
        v141 = v140 + 2;
        v142 = 8LL * *v140;
        if ( v140[1] > 0x10 )
          v141 = (_QWORD *)*v141;
        v280[0] = v141;
        v280[1] = v142;
        v267[0] = &off_1482C5768;
        v280[2] = 0;
        v267[1] = v280;
        v281 = 1;
        serialize_int32((__int64)v267, (__int64)"smn.quantumSpawnId", (int *)(a1 + 0x2D8));
      }
      v143 = *(double *)v214.m256_f32 - v58;
      v144 = *(double *)&v214.m256_f32[4] - v60;
      v145 = *(double *)&v214.m256_f32[2] - v59;
      _XMM0 = COERCE_UNSIGNED_INT64(v145 * v145 + v143 * v143 + v144 * v144);
      if ( v145 * v145 + v143 * v143 + v144 * v144 <= 0.0 )
      {
        v150 = *(double *)&src__1;
        v151 = *((unsigned __int64 *)&src__1 + 1);
        v153 = *(double *)&qword_149A60058;
      }
      else
      {
        __asm
        {
          vmovddup xmm0, xmm0
          vsqrtpd xmm1, xmm0
          vunpckhpd xmm1, xmm1, xmm1
        }
        v150 = v143 * (1.0 / *(double *)&_XMM1);
        *((_QWORD *)&v152 + 1) = 0;
        *(double *)&v152 = 1.0 / *(double *)&_XMM1 * v145;
        v151 = v152;
        v153 = 1.0 / *(double *)&_XMM1 * v144;
      }
      v154 = *(double *)&v151 * *((double *)&src__0 + 1)
           + v150 * *(double *)&src__0
           + v153 * *(double *)&qword_149AF69A8
           + 1.0;
      if ( v154 <= 0.0001 )
      {
        v163 = 0.0;
        if ( (*((double *)&src__0 + 1) * *((double *)&src__0 + 1)
            + *(double *)&src__0 * *(double *)&src__0
            + *(double *)&qword_149AF69A8 * *(double *)&qword_149AF69A8)
           * 0.8100000000000001
           - *(double *)&src__0 * *(double *)&src__0 >= 0.0 )
        {
          *(_QWORD *)&v271[2] = *((_QWORD *)&src__0 + 1) ^ 0x8000000000000000uLL;
          v271[0] = 0.0;
          v271[1] = *(double *)&qword_149AF69A8;
          v167 = v271;
        }
        else
        {
          v270[0] = qword_149AF69A8 ^ 0x8000000000000000uLL;
          *(double *)&v270[1] = 0.0;
          *(double *)&v270[2] = *(double *)&src__0;
          v167 = (double *)v270;
        }
        _XMM0 = *(_OWORD *)v167;
        v169 = v167[2];
        v170 = *(double *)&_XMM0 * *(double *)&_XMM0;
        v332 = *(_OWORD *)v167;
        *((_QWORD *)&v173 + 1) = *((_QWORD *)&v332 + 1);
        __asm { vunpckhpd xmm0, xmm0, xmm0 }
        *(double *)&v173 = v170 + *(double *)&_XMM0 * *(double *)&_XMM0 + v169 * v169 + 2.225073858507201e-308;
        _XMM2 = v173;
        v174 = v167[2];
        v333 = v169;
        __asm
        {
          vmovddup xmm3, xmm2
          vsqrtpd xmm0, xmm3
          vunpckhpd xmm0, xmm0, xmm0
        }
        *(double *)&_XMM2 = 1.0 / *(double *)&_XMM0;
        _XMM0 = *(_OWORD *)v167;
        v164 = *v167 * *(double *)&_XMM2;
        __asm { vunpckhpd xmm0, xmm0, xmm0 }
        v237 = v174;
        v165 = *(double *)&_XMM0 * *(double *)&_XMM2;
        v166 = v174 * *(double *)&_XMM2;
      }
      else
      {
        v155 = v153 * *((double *)&src__0 + 1) - *(double *)&v151 * *(double *)&qword_149AF69A8;
        *((_QWORD *)&v156 + 1) = *((_QWORD *)&v151 + 1);
        v157 = *(double *)&v151 * *(double *)&src__0 - v150 * *((double *)&src__0 + 1);
        v158 = v150 * *(double *)&qword_149AF69A8 - v153 * *(double *)&src__0;
        *(double *)&v156 = v157 * v157 + v158 * v158 + v155 * v155 + v154 * v154;
        _XMM2 = v156;
        __asm
        {
          vmovddup xmm3, xmm2
          vsqrtpd xmm0, xmm3
          vunpckhpd xmm0, xmm0, xmm0
        }
        *(double *)&_XMM0 = 1.0 / *(double *)&_XMM0;
        v163 = *(double *)&_XMM0 * v154;
        v164 = *(double *)&_XMM0 * v155;
        v165 = *(double *)&_XMM0 * v158;
        v166 = *(double *)&_XMM0 * v157;
      }
      *(double *)(v14 + 0x98) = v164;
      *(double *)(v14 + 0xA0) = v165;
      *(double *)(v14 + 0xA8) = v166;
      *(double *)(v14 + 0xB0) = v163;
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v214.m256_f32[6])
        && (v180 = v215,
            *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)&v214.m256_f32[6]
                                                                              & 0xFFFFFFFFFFFFLL)
                                                                  + 8LL))(
                         *(_QWORD *)&v214.m256_f32[6] & 0xFFFFFFFFFFFFLL,
                         v319) == *(_QWORD *)&v180) )
      {
        v181 = *(_QWORD *)&v214.m256_f32[6];
      }
      else
      {
        v181 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, double))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                            qword_149C8DFC0,
                            v320,
                            COERCE_DOUBLE(*(_QWORD *)&v215));
        *(_QWORD *)&v214.m256_f32[6] = v181;
      }
      v242 = v181;
      if ( !is_entity_descriptor_valid_or_accessible(&v242) )
        goto LABEL_159;
      v182 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v242 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v242 & 0xFFFFFFFFFFFFLL);
      if ( !v182 )
        goto LABEL_159;
      v183 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v182 + 0x38LL))(v182, v321);
      v184 = *(_QWORD *)&v224.m256_f32[6];
      v231 = *v183;
      if ( !*(_QWORD *)&v224.m256_f32[6] )
        goto LABEL_154;
      v185 = (HIWORD(v224.m256_f32[7]) & 0xF000) != 0
           ? *(_QWORD *)&v224.m256_f32[6] & 0xFFFFFF000000LL
           : (*(_QWORD *)&v224.m256_f32[6] & 0xFFFFFFFFFFFFLL) - 6;
      if ( *(_WORD *)(v185 + 2) != (HIWORD(v224.m256_f32[7]) & 0xFFF) )
        goto LABEL_154;
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D)
        || (v186 = is_thread_privileged_or_bypass_mode(), v184 = *(_QWORD *)&v224.m256_f32[6], v186) )
      {
        v186 = 1;
      }
      if ( *(_WORD *)(v185 + 4) != 2 || !v186 )
      {
        if ( !sub_140395410(&v224.m256_f32[6]) )
          goto LABEL_154;
        v184 = *(_QWORD *)&v224.m256_f32[6];
      }
      v187 = v225;
      if ( *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(v184 & 0xFFFFFFFFFFFFLL) + 8LL))(
                        v184 & 0xFFFFFFFFFFFFLL,
                        v322) == *(_QWORD *)&v187 )
      {
        v188 = *(_QWORD *)&v224.m256_f32[6];
LABEL_155:
        v230 = v188;
        if ( is_entity_descriptor_valid_or_accessible(&v230)
          && is_entity_descriptor_valid_or_accessible(&v231)
          && v231 != v230 )
        {
          v189 = qword_149C8DF28;
          v190 = *(void (__fastcall **)(__int64, double *, __int64, __int64))(*(_QWORD *)qword_149C8DF28 + 0x480LL);
          v191 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v231 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v231 & 0xFFFFFFFFFFFFLL);
          v192 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v230 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v230 & 0xFFFFFFFFFFFFLL);
          v190(v189, v341, v192, v191);
          v193 = sub_14033A390(v338, v341, (double *)v224.m256_f32);
          *(_OWORD *)v224.m256_f32 = *(_OWORD *)v193;
          v194 = v193[2];
          *(_QWORD *)&v224.m256_f32[6] = v231;
          *(double *)&v224.m256_f32[4] = v194;
          v225 = *(double *)(*(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(v231 & 0xFFFFFFFFFFFFLL)
                                                                                + 8LL))(
                              v231 & 0xFFFFFFFFFFFFLL,
                              v324);
        }
LABEL_159:
        v195 = *(double *)&v224.m256_f32[4];
        *(_OWORD *)(v14 + 0xB8) = *(_OWORD *)v224.m256_f32;
        *(double *)(v14 + 0xC8) = v195;
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v214.m256_f32[6])
          && (v196 = v215,
              *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)&v214.m256_f32[6]
                                                                                & 0xFFFFFFFFFFFFLL)
                                                                    + 8LL))(
                           *(_QWORD *)&v214.m256_f32[6] & 0xFFFFFFFFFFFFLL,
                           v325) == *(_QWORD *)&v196) )
        {
          v197 = *(_QWORD *)&v214.m256_f32[6];
        }
        else
        {
          v197 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, double))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                              qword_149C8DFC0,
                              v326,
                              COERCE_DOUBLE(*(_QWORD *)&v215));
          *(_QWORD *)&v214.m256_f32[6] = v197;
        }
        v243 = v197;
        if ( is_entity_descriptor_valid_or_accessible(&v243) )
          v198 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v243 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v243 & 0xFFFFFFFFFFFFLL);
        else
          v198 = 0;
        v199 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v198 + 0x40LL))(v198, v314);
        v200 = *(_BYTE *)(v14 + 0xE0) == 0;
        *(_QWORD *)(v14 + 0x100) = *v199;
        if ( v200 )
          *(_BYTE *)(v14 + 0xE1) = 1;
        *(_DWORD *)(v14 + 0xD8) = 0x130BF;
        *(_DWORD *)(v14 + 0xDC) = v13++;
        *(_BYTE *)(v14 + 0xE3) = 0;
        v201 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x2D0LL))(qword_149C8DFC0);
        v202 = v225;
        v203 = v201;
        v204 = *v201;
        v336 = v224;
        p_sub_144D9D360 = 0;
        v237 = 0.0;
        v205 = *(void (__fastcall **)(_QWORD *, __int64 *, __int64, const char *, __int64 (__fastcall **)(__int64, __int64)))(v204 + 0x30);
        p_sub_144D90650 = 0;
        __asm { vzeroupper }
        *(double *)&v206 = COERCE_DOUBLE(sub_1402A65A0(0x28u));
        if ( *(double *)&v206 == 0.0 )
        {
          v237 = 0.0;
        }
        else
        {
          *(__m256 *)v206 = v336;
          *(double *)(v206 + 0x20) = v202;
          v237 = *(double *)&v206;
        }
        p_sub_144D90650 = sub_144D90650;
        p_sub_144D9D360 = sub_144D9D360;
        __asm { vzeroupper }
        v205(v203, &v219, 1, "SpawnHelperQuantumSpawn", &p_sub_144D90650);
        if ( (unsigned __int64)p_sub_144D9D360 >= 2 )
          ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))p_sub_144D9D360)(
            2,
            &p_sub_144D90650);
        v207 = *(_QWORD **)(a1 + 0x2C8);
        if ( v207 == *(_QWORD **)(a1 + 0x2D0) )
        {
          sub_1440E0C80((_QWORD *)(a1 + 0x2C0), (__int64)v207, (__int64)&v219);
        }
        else
        {
          *v207 = v219;
          if ( v219 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v219 + 8LL))(v219);
          *(_QWORD *)(a1 + 0x2C8) += 8LL;
        }
        if ( v15 == v227 )
        {
          sub_142921710(&v226, v15, v14);
          v15 = *((_QWORD *)&v226 + 1);
        }
        else
        {
          sub_14292E130(v15, v14);
          v15 += 0x170;
          *((_QWORD *)&v226 + 1) = v15;
        }
        ++*(_DWORD *)(a1 + 0x2DC);
        if ( v219 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v219 + 0x10LL))(v219);
        v208 = v298;
        v219 = 0;
        if ( v298 )
        {
          if ( _InterlockedExchangeAdd(v298 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v208)(v208);
            if ( _InterlockedExchangeAdd(v208 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v208 + 8LL))(v208);
          }
          v15 = *((_QWORD *)&v226 + 1);
        }
        v16 = v232;
        goto LABEL_189;
      }
LABEL_154:
      v188 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, double))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                          qword_149C8DFC0,
                          v323,
                          COERCE_DOUBLE(*(_QWORD *)&v225));
      *(_QWORD *)&v224.m256_f32[6] = v188;
      goto LABEL_155;
    }
    v36 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v35 + 0x38LL))(v35, v310);
    v37 = v222;
    v229 = *v36;
    if ( !v222 )
      goto LABEL_44;
    v38 = (v222 & 0xF000000000000000uLL) != 0 ? v222 & 0xFFFFFF000000LL : (v222 & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v38 + 2) != (HIWORD(v222) & 0xFFF) )
      goto LABEL_44;
    if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v39 = is_thread_privileged_or_bypass_mode(), v37 = v222, v39) )
      v39 = 1;
    if ( *(_WORD *)(v38 + 4) != 2 || !v39 )
    {
      if ( !sub_140395410(&v222) )
        goto LABEL_44;
      v37 = v222;
    }
    v40 = v223;
    if ( *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(v37 & 0xFFFFFFFFFFFFLL) + 8LL))(
                      v37 & 0xFFFFFFFFFFFFLL,
                      v311) == v40 )
    {
      v41 = v222;
LABEL_45:
      v228 = v41;
      if ( is_entity_descriptor_valid_or_accessible(&v228)
        && is_entity_descriptor_valid_or_accessible(&v229)
        && v229 != v228 )
      {
        v42 = qword_149C8DF28;
        v43 = *(void (__fastcall **)(__int64, double *, __int64, __int64))(*(_QWORD *)qword_149C8DF28 + 0x480LL);
        v44 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v229 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v229 & 0xFFFFFFFFFFFFLL);
        v45 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v228 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v228 & 0xFFFFFFFFFFFFLL);
        v43(v42, v340, v45, v44);
        v46 = sub_14033A390(v339, v340, (double *)&v220);
        v220 = *(_OWORD *)v46;
        v47 = v46[2];
        v222 = v229;
        v221 = v47;
        v223 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(v229 & 0xFFFFFFFFFFFFLL)
                                                                              + 8LL))(
                            v229 & 0xFFFFFFFFFFFFLL,
                            v313);
      }
      goto LABEL_49;
    }
LABEL_44:
    v41 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
                       qword_149C8DFC0,
                       v312,
                       v223);
    v222 = v41;
    goto LABEL_45;
  }
LABEL_190:
  v209 = (v15 - (__int64)v226) / 0x170;
  if ( v209 )
  {
    v210 = *(_QWORD *)(sub_1465E67B0(qword_149FBE618, v209) + 0x48);
    v211 = sub_140572030().m128_f32[0];
    v342[0] = 1;
    sub_140572410((__int64)v342, (int)v211);
    v212 = *(_QWORD *)(a1 + 0x10);
    v263 = 0;
    n2_1 = 0;
    v265 = 0;
    *(_DWORD *)(a1 + 0x2B0) = sub_144ECC050(v210, (unsigned int)&v226, (unsigned int)v342, v212, (__int64)&v263);
    if ( (unsigned __int64)n2_1 >= 2 )
      n2_1(2, &v263);
    if ( *(_DWORD *)(a1 + 0x2B0) )
    {
      *(_QWORD *)(a1 + 0x2B8) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80
                                                                                      + 0x38LL))(
                                             qword_149C8DF80,
                                             0);
      v247 = 0xB2D05E00LL;
      sub_1402FE5E0((_QWORD *)(a1 + 0x2B8), &v247);
      *(_DWORD *)(a1 + 0x54) = 4;
      return sub_142934E60((__int64)&v226);
    }
  }
  else
  {
    sub_1405C6220(
      4u,
      0,
      "All vehicles in the wave being spawned did not contain quantum drives. Failing the SpawnRequest");
  }
  *(_DWORD *)(a1 + 0x54) = 9;
  return sub_142934E60((__int64)&v226);
}

// --- End Function: sub_144E78CA0 (0x144E78CA0) ---

// --- Function: sub_144E7A6C0 (0x144E7A6C0) ---
char __fastcall sub_144E7A6C0(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned __int64 v4; // rax
  __int64 v5; // rax
  unsigned __int64 v6; // rdi
  __int64 v7; // rdi
  __int64 v8; // rdi
  bool v9; // al
  __int64 v10; // rsi
  double *v11; // rax
  double v12; // xmm6_8
  double v13; // xmm7_8
  double v14; // xmm8_8
  double v15; // xmm9_8
  __int64 v16; // rbx
  __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  int v22; // [rsp+20h] [rbp-B8h]
  __int128 v23; // [rsp+30h] [rbp-A8h] BYREF
  double v24; // [rsp+40h] [rbp-98h]
  double v25[4]; // [rsp+48h] [rbp-90h] BYREF
  __int128 v26; // [rsp+68h] [rbp-70h]
  double v27; // [rsp+78h] [rbp-60h]
  double v28; // [rsp+80h] [rbp-58h]
  unsigned __int64 v29; // [rsp+E8h] [rbp+10h] BYREF

  if ( *(_DWORD *)(a2 + 0x80) || *(_DWORD *)(a2 + 0x84) )
  {
    v3 = a2 + 0xA0;
    LODWORD(v4) = sub_1404C0350(a2 + 0xA0);
    if ( (int)v4 <= 0 )
      return v4;
  }
  else
  {
    v3 = a2 + 0xA0;
  }
  if ( *(_DWORD *)(a2 + 0x80) || *(_DWORD *)(a2 + 0x84) )
  {
    v4 = *(_QWORD *)(a2 + 0x2C8);
    v29 = v4;
  }
  else
  {
    v5 = sub_1403B0790(v3);
    v4 = sub_1419AF770(v5 + 0x40);
    if ( !v4 )
      return v4;
    (*(void (__fastcall **)(unsigned __int64, unsigned __int64 *))(*(_QWORD *)v4 + 0x30LL))(v4, &v29);
    v4 = v29;
  }
  if ( v4 )
  {
    v6 = v4;
    v4 >>= 0x30;
    v7 = v6 & 0xFFFFFFFFFFFFLL;
    v8 = (v4 & 0xF000) != 0 ? v7 & 0xFFFFFF000000LL : v7 - 6;
    LOWORD(v4) = v4 & 0xFFF;
    if ( *(_WORD *)(v8 + 2) == (_WORD)v4 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v9 = is_thread_privileged_or_bypass_mode()) )
        v9 = 1;
      if ( *(_WORD *)(v8 + 4) == 2 && v9 || (LOBYTE(v4) = sub_140395410(&v29), (_BYTE)v4) )
      {
        v10 = *(_QWORD *)(a2 + 0x50) & 0xFFFFFFFFFFFFLL;
        v11 = (double *)(*(__int64 (__fastcall **)(__int64, double *, _QWORD, _QWORD, char))(*(_QWORD *)v10 + 0x1E8LL))(
                          v10,
                          v25,
                          0,
                          0,
                          1);
        v12 = *v11;
        v13 = v11[1];
        v14 = v11[2];
        v15 = v11[3];
        if ( *(_DWORD *)(a2 + 0x80) || *(_DWORD *)(a2 + 0x84) )
        {
          v17 = a2 + 0x2B0;
          v16 = a2 + 0xA0;
        }
        else
        {
          v16 = a2 + 0xA0;
          v17 = sub_1403B0790(v16) + 0x60;
        }
        v18 = sub_1403B0790(v16);
        v19 = sub_1419AF770(v18 + 0x40);
        if ( v19 )
        {
          (*(void (__fastcall **)(__int64, __int128 *, __int64))(*(_QWORD *)v19 + 0x170LL))(v19, &v23, v17);
        }
        else
        {
          v23 = *(_OWORD *)v17;
          v24 = *(double *)(v17 + 0x10);
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xF0LL))(qword_149C8DF28);
        v20 = *(_QWORD *)v10;
        v26 = v23;
        LOBYTE(v22) = 1;
        v27 = v24;
        v25[0] = v12;
        v25[1] = v13;
        v25[2] = v14;
        v25[3] = v15;
        v28 = 1.0;
        (*(void (__fastcall **)(__int64, double *, _QWORD, __int64, int, _QWORD))(v20 + 0x1D8))(v10, v25, 0, 6, v22, 0);
        LOBYTE(v4) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xF8LL))(qword_149C8DF28);
      }
    }
  }
  return v4;
}

// --- End Function: sub_144E7A6C0 (0x144E7A6C0) ---

// --- Function: sub_144E7A980 (0x144E7A980) ---
char __fastcall sub_144E7A980(__int64 a1, unsigned int a2, __int64 a3, Parameter *Parameter)
{
  bool v4; // zf
  __int64 v8; // rbx
  __int64 v9; // r9
  void *v10; // r9
  __int64 v11; // rax
  _QWORD *v12; // rax
  int v13; // edi
  int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r12
  unsigned __int64 v18; // rax
  unsigned __int64 allocSize; // rcx
  __int64 v20; // rdi
  __int64 v21; // rax
  __int64 v22; // rbx
  __int64 v23; // r9
  unsigned __int64 allocSize_1; // rdi
  char *v26; // rbx
  int v27; // ebx
  unsigned __int64 i; // rdi
  float *v29; // rax
  _QWORD *v30; // rax
  _QWORD *v31; // rax
  void (__fastcall *v32)(__int64, _QWORD); // r8
  volatile signed __int64 *v33; // rbx
  int v34; // edi
  __int64 v35; // r8
  unsigned __int64 v36; // rax
  Parameter *Parameter_1; // rbx
  __int64 v38; // rcx
  int v39; // eax
  unsigned __int64 n0x200000; // rax
  char v41; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v42; // [rsp+38h] [rbp-C8h] BYREF
  int v43; // [rsp+40h] [rbp-C0h] BYREF
  void (__fastcall ***v44)(_QWORD, __int64); // [rsp+48h] [rbp-B8h] BYREF
  void *Src[2]; // [rsp+50h] [rbp-B0h] BYREF
  char *v46; // [rsp+60h] [rbp-A0h]
  int v47; // [rsp+68h] [rbp-98h] BYREF
  __int128 src; // [rsp+70h] [rbp-90h] BYREF
  __int64 v49; // [rsp+80h] [rbp-80h]
  char v50; // [rsp+88h] [rbp-78h]
  __int64 v51; // [rsp+90h] [rbp-70h] BYREF
  void (__fastcall ***v52)(_QWORD, __int64); // [rsp+98h] [rbp-68h] BYREF
  __int64 **v53; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v54; // [rsp+A8h] [rbp-58h]
  int *v55; // [rsp+B0h] [rbp-50h]
  int v56; // [rsp+B8h] [rbp-48h] BYREF
  _QWORD v57[4]; // [rsp+C0h] [rbp-40h] BYREF
  _QWORD v58[3]; // [rsp+E0h] [rbp-20h] BYREF
  _QWORD v59[3]; // [rsp+F8h] [rbp-8h] BYREF
  __int128 v60; // [rsp+110h] [rbp+10h] BYREF
  __int64 v61; // [rsp+120h] [rbp+20h]
  float v62[6]; // [rsp+128h] [rbp+28h] BYREF
  _BYTE v63[2512]; // [rsp+140h] [rbp+40h] BYREF

  v4 = *(_DWORD *)(a3 + 0x80) == 0;
  v42 = a2;
  if ( !v4 || *(_DWORD *)(a3 + 0x84) )
  {
    v8 = a3 + 0xA0;
    if ( (int)sub_1404C0350(a3 + 0xA0) < 1 )
    {
      sub_144E93A80(a1, v42, 0, (unsigned int)"TPS query failed to find enough valid spawn locations");
      LOBYTE(v23) = 1;
      sub_144E93E40(a1, v42, 1, v23);
      return 0;
    }
  }
  else
  {
    v8 = a3 + 0xA0;
  }
  v63[0] = 1;
  sub_140572410((__int64)v63, 0x1571);
  v50 = 1;
  src = 0;
  v49 = 0;
  LOBYTE(v9) = 0xB;
  (*(void (__fastcall **)(__int64, void (__fastcall ****)(_QWORD, __int64), const char *, __int64, _DWORD))(*(_QWORD *)qword_149C8DFC0 + 0xC8LL))(
    qword_149C8DFC0,
    &v44,
    "CSpawningManager::ProcessSpawnRequest",
    v9,
    0);
  if ( v44 )
  {
    v11 = sub_1403B0790(v8);
    v60 = *(_OWORD *)(v11 + 0x60);
    v61 = *(_QWORD *)(v11 + 0x70);
    v12 = (_QWORD *)sub_1403B0790(v8);
    v57[3] = v12[0xB];
    v57[0] = v12[8];
    v57[1] = v12[9];
    v57[2] = v12[0xA];
    v47 = 0;
    v13 = sub_1412AF9F0((_QWORD *)(a3 + 8));
    v14 = sub_1451F83B0(a3 + 8);
    v15 = *Parameter;
    v16 = (unsigned int)(v14 + v13);
    v17 = (int)v16;
    v18 = (Parameter[2] - *Parameter) >> 4;
    v43 = v16;
    if ( (int)v16 > v18 )
    {
      if ( (unsigned __int64)(int)v16 > 0xFFFFFFFFFFFFFFFLL )
        unknown_libname_65(v16, v15);
      allocSize = 0x10LL * (int)v16;
      v20 = (Parameter[1] - v15) >> 4;
      if ( (unsigned __int64)(0x10 * v17) < 0x1000 )
      {
        if ( allocSize )
          v22 = sub_1402A65A0(allocSize);
        else
          v22 = 0;
      }
      else
      {
        if ( allocSize + 0x27 < allocSize )
          sub_1402E3880();
        v21 = sub_1402A65A0(allocSize + 0x27);
        if ( !v21 )
          invalid_parameter_noinfo_noreturn();
        v22 = (v21 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
        *(_QWORD *)(v22 - 8) = v21;
      }
      sub_142922970(*Parameter, Parameter[1], v22, (__int64)Parameter);
      sub_142997430((Parameter *)Parameter, v22, v20, v17);
      LODWORD(v16) = v43;
    }
    v4 = *(_DWORD *)(a3 + 0x84) == 3;
    v41 = 1;
    if ( v4 && (unsigned int)(*(_DWORD *)(a3 + 0x80) - 4) <= 1 )
    {
      v41 = 0;
      v46 = 0;
      *(_OWORD *)Src = 0;
      if ( (_DWORD)v16 )
      {
        if ( (unsigned __int64)(int)v16 > 0x1555555555555555LL )
          unknown_libname_10();
        allocSize_1 = 0xCLL * (int)v16;
        v26 = (char *)sub_140394E70((__int64)Src, allocSize_1);
        memmove(v26, Src[0], (char *)Src[1] - (char *)Src[0]);
        if ( Src[0] )
          sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], 0xC * ((v46 - (char *)Src[0]) / 0xC));
        Src[0] = v26;
        v46 = &v26[allocSize_1];
        Src[1] = v26;
      }
      v27 = 0;
      for ( i = (0x14 * (unsigned __int64)(unsigned int)sub_1405722D0((__int64)v63)) >> 0x20; v27 < v43; ++v27 )
      {
        v29 = sub_1403AE750(v62, v27 + (int)i);
        sub_141DA59D0((__int64)Src, (__int64)v29);
      }
    }
    else
    {
      *(_OWORD *)Src = 0;
      v46 = 0;
    }
    v51 = a1;
    v30 = (_QWORD *)sub_1402A65A0(0x68u);
    if ( v30 )
    {
      *v30 = a1;
      v30[1] = &v51;
      v30[2] = &v47;
      v30[3] = &v43;
      v30[4] = &v42;
      v30[5] = a3;
      v30[6] = &v41;
      v30[7] = v57;
      v30[8] = Src;
      v30[9] = &v60;
      v30[0xA] = &v44;
      v30[0xB] = Parameter;
      v30[0xC] = &src;
    }
    else
    {
      v30 = 0;
    }
    v58[2] = v30;
    v58[0] = sub_144D937A0;
    v58[1] = sub_144DA2950;
    sub_1451F6500(a3 + 8, v58);
    v31 = (_QWORD *)sub_1402A65A0(0x60u);
    if ( v31 )
    {
      *v31 = a1;
      v31[1] = a3;
      v31[2] = v57;
      v31[3] = &v51;
      v31[4] = &v47;
      v31[5] = &v43;
      v31[6] = &v42;
      v31[7] = &v41;
      v31[8] = Src;
      v31[9] = &v44;
      v31[0xA] = Parameter;
      v31[0xB] = &src;
    }
    else
    {
      v31 = 0;
    }
    v59[2] = v31;
    v59[0] = sub_144D94530;
    v59[1] = sub_144DA49B0;
    sub_1451F63D0(a3 + 8, v59);
    if ( v50 )
    {
      sub_144EB8930(a1, v44, v42);
      v32 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0xD0LL);
      v52 = v44;
      v44 = 0;
      v32(qword_149C8DFC0, &v52);
    }
    v10 = Src[0];
    if ( Src[0] )
      sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], 0xC * ((v46 - (char *)Src[0]) / 0xC));
  }
  else
  {
    v50 = 0;
  }
  LOBYTE(v10) = v50 == 0;
  sub_144E93E40(a1, v42, 1, v10);
  v56 = 1;
  v33 = (volatile signed __int64 *)(a1 + 0x2B8);
  v53 = (__int64 **)(a1 + 0x2A8);
  v54 = a1 + 0x2B8;
  v55 = &v56;
  v34 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x2C8) == v34 )
  {
    ++*(_DWORD *)(a1 + 0x2CC);
  }
  else
  {
    v35 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v36 = _InterlockedCompareExchange64(v33, 0x200000, 0);
    if ( v36 )
      sub_1403E1120((__int64)v33, v36, v35, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(a1 + 0x2C0) = v35;
    *(_DWORD *)(a1 + 0x2C8) = v34;
  }
  Parameter_1 = sub_144D29930(&v53, &v42);
  if ( (__int128 *)Parameter_1 != &src )
    sub_14291FD30((Parameter *)Parameter_1, (char *)src, (*((_QWORD *)&src + 1) - (_QWORD)src) / 0x18LL);
  *(_BYTE *)(Parameter_1 + 0x18) = v50;
  v4 = (*v55)-- == 1;
  if ( v4 )
  {
    v38 = v54;
    v39 = *(_DWORD *)(v54 + 0x14);
    if ( v39 )
    {
      *(_DWORD *)(v54 + 0x14) = v39 - 1;
    }
    else
    {
      *(_DWORD *)(v54 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v38, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v38 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v38, n0x200000);
    }
  }
  if ( v44 )
    (**v44)(v44, 1);
  sub_142934F00((__int64)&src);
  return 1;
}

// --- End Function: sub_144E7A980 (0x144E7A980) ---

// --- Function: sub_144E93A80 (0x144E93A80) ---
__int64 sub_144E93A80(_DWORD a1, _DWORD a2, unsigned int a3, const char *Format_1, ...)
{
  unsigned __int64 *v6; // rax
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1090h] [rbp+28h] BYREF

  va_start(va, Format_1);
  v6 = (unsigned __int64 *)sub_1402A6BE0();
  _stdio_common_vsnprintf_s(*v6, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  return sub_1405C6220(4u, a3, "[Spawning Manager] %s", Buffer);
}

// --- End Function: sub_144E93A80 (0x144E93A80) ---

// --- Function: sub_144E93E40 (0x144E93E40) ---
const ULONG_PTR *__fastcall sub_144E93E40(__int64 a1, unsigned int a2, int n2, unsigned __int8 a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int64 v6; // rdi
  int v11; // ebx
  unsigned int v12; // eax
  __int64 *_Wherenode_3; // rcx
  __int64 *_Wherenode_1; // rbx
  __int64 *_Wherenode_4; // rax
  const char *p_p_Src; // rsi
  __int64 v21; // rax
  __int64 v22; // r14
  __int64 (__fastcall *v23)(__int64, _BYTE *, __int16 *); // r15
  __int16 n0xFFFF; // cx
  __int64 v25; // r14
  __int64 v26; // r15
  __int64 v27; // rax
  __int16 n4; // cx
  __int64 (__fastcall ***v29)(_QWORD, __int128 *); // rax
  __int64 (__fastcall ***v30)(_QWORD); // rax
  __int64 v31; // rax
  __int64 (__fastcall ***v32)(_QWORD, __int128 *); // rax
  __int64 (__fastcall ***v33)(_QWORD); // rax
  __int64 v34; // rax
  __int64 *v35; // rsi
  __int64 *v36; // rsi
  const char *p_none; // r14
  __int64 v38; // r15
  __int64 **v39; // r8
  __int64 *_Wherenode; // rdx
  __int64 *_Wherenode_2; // rax
  __int64 *i; // r8
  __int64 *v43; // rax
  int v44; // eax
  const ULONG_PTR *result; // rax
  void *v46; // [rsp+28h] [rbp-99h] BYREF
  __int16 n0xFFFF_1; // [rsp+30h] [rbp-91h] BYREF
  _BYTE v48[6]; // [rsp+32h] [rbp-8Fh] BYREF
  __int64 v49; // [rsp+38h] [rbp-89h] BYREF
  std::_Tree_val<std::_Tree_simple_types<int> > *v50; // [rsp+40h] [rbp-81h]
  __int64 v51; // [rsp+48h] [rbp-79h] BYREF
  __int64 v52; // [rsp+50h] [rbp-71h] BYREF
  _BYTE v53[16]; // [rsp+58h] [rbp-69h] BYREF
  __int128 v54; // [rsp+68h] [rbp-59h] BYREF
  __int128 v55; // [rsp+78h] [rbp-49h] BYREF
  __int128 v56; // [rsp+88h] [rbp-39h] BYREF
  __int64 v57; // [rsp+98h] [rbp-29h]
  __int128 v58; // [rsp+A0h] [rbp-21h] BYREF
  __int64 v59; // [rsp+B0h] [rbp-11h]
  __int128 v60; // [rsp+C8h] [rbp+7h]
  __int128 v61; // [rsp+D8h] [rbp+17h]

  v6 = a1 + 0x338;
  v11 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v6 + 0x10) == v11 )
  {
    ++*(_DWORD *)(v6 + 0x14);
  }
  else
  {
    v12 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 1, 0);
    if ( v12 )
      sub_1403C6E80(v6, v12, (__int64)"CSpawningManager::ReportSpawnRequestTimings", 1);
    else
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v6 + 0x10) = v11;
  }
  _Wherenode_3 = *(__int64 **)(a1 + 0x328);
  v50 = (std::_Tree_val<std::_Tree_simple_types<int> > *)(a1 + 0x328);
  _Wherenode_1 = _Wherenode_3;
  _Wherenode_4 = (__int64 *)_Wherenode_3[1];
  while ( !*((_BYTE *)_Wherenode_4 + 0x19) )
  {
    if ( *((_DWORD *)_Wherenode_4 + 8) >= a2 )
    {
      _Wherenode_1 = _Wherenode_4;
      _Wherenode_4 = (__int64 *)*_Wherenode_4;
    }
    else
    {
      _Wherenode_4 = (__int64 *)_Wherenode_4[2];
    }
  }
  if ( !*((_BYTE *)_Wherenode_1 + 0x19) && a2 >= *((_DWORD *)_Wherenode_1 + 8) && _Wherenode_1 != _Wherenode_3 )
  {
    if ( n2 == 1 )
    {
      _Wherenode_1[6] = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                                     qword_149C8DF80,
                                     0);
    }
    else if ( n2 == 2 )
    {
      _Wherenode_1[7] = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                                     qword_149C8DF80,
                                     0);
    }
    if ( a4 || n2 == 2 )
    {
      v61 = v4;
      v60 = v5;
      sub_14059CA60(_Wherenode_1 + 6, &v51, _Wherenode_1 + 5);
      _XMM0 = sub_14059CC00();
      __asm { vcvtsd2ss xmm7, xmm0, xmm0 }
      if ( n2 >= 2 )
      {
        sub_14059CA60(_Wherenode_1 + 7, &v52, _Wherenode_1 + 6);
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
      }
      p_p_Src = "Unknown";
      v21 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(
              qword_149C8DFC0,
              _Wherenode_1[0xA]);
      v22 = v21;
      if ( !v21 )
        goto LABEL_51;
      v23 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v21 + 0x340LL);
      n0xFFFF = n0xFFFF_28;
      if ( n0xFFFF_28 == (__int16)0xFFFF )
      {
        n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                      + 0x10LL))(
                              qword_149C8DFC8,
                              v48,
                              "IMissionEntity");
        n0xFFFF_28 = n0xFFFF;
      }
      n0xFFFF_1 = n0xFFFF;
      v25 = *(_QWORD *)v23(v22, v53, &n0xFFFF_1);
      v49 = v25;
      if ( !v25 )
        goto LABEL_51;
      v26 = v25 & 0xFFFFFFFFFFFFLL;
      v27 = sub_1403B84E0(v25 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v27 + 4);
      if ( n4 == 4 || *(_WORD *)(v27 + 2) != (HIWORD(v25) & 0xFFF) )
        goto LABEL_51;
      if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_140322850(&v49) )
        goto LABEL_51;
      if ( !v26 )
        goto LABEL_51;
      v54 = *(_OWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x5D0LL))(v26) + 0x58);
      sub_14035EC10(&v56, &v54);
      if ( qword_149C8DFE0
        && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0)
        && (v29 = (__int64 (__fastcall ***)(_QWORD, __int128 *))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0),
            (v30 = (__int64 (__fastcall ***)(_QWORD))(**v29)(v29, &v56)) != 0) )
      {
        v31 = (**v30)(v30);
      }
      else
      {
        v31 = 0;
      }
      v57 = v31;
      v55 = *(_OWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x5D0LL))(v26) + 0x48);
      sub_14035EC10(&v58, &v55);
      if ( qword_149C8DFE0
        && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0)
        && (v32 = (__int64 (__fastcall ***)(_QWORD, __int128 *))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0),
            (v33 = (__int64 (__fastcall ***)(_QWORD))(**v32)(v32, &v58)) != 0) )
      {
        v34 = (**v33)(v33);
      }
      else
      {
        v34 = 0;
      }
      v59 = v34;
      if ( v57 )
      {
        v35 = sub_1403B7660((__int64)&v56);
        if ( (unsigned __int64)sub_1403EBE30(v35) > 0x10 )
        {
          p_p_Src = (const char *)(*v35 + 0x11);
LABEL_51:
          p_none = "none";
          v38 = qword_149C8E060;
          if ( _Wherenode_1[8] )
            p_none = (const char *)_Wherenode_1[8];
          sub_14045A0B0(&v46);
          if ( sub_14048D530(&v46, "TPSQuery Name") )
          {
            sub_140492B70((__int64)&v46, (__int64)p_none);
            sub_140387CB0((__int64)&v46, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v46, "TPSQuery Time") )
          {
            sub_1404929F0((__int64)&v46);
            sub_140387CB0((__int64)&v46, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v46, "CreationBatch Time") )
          {
            sub_1404929F0((__int64)&v46);
            sub_140387CB0((__int64)&v46, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v46, "Request Count") )
          {
            sub_1404928B0((__int64)&v46, *((_DWORD *)_Wherenode_1 + 0x12));
            sub_140387CB0((__int64)&v46, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v46, "Mission Name") )
          {
            sub_140492B70((__int64)&v46, (__int64)p_p_Src);
            sub_140387CB0((__int64)&v46, (__int64)&unk_1482C0F54);
          }
          if ( sub_14048D530(&v46, "Finished Early") )
          {
            sub_140492D10(&v46, a4);
            sub_140387CB0((__int64)&v46, (__int64)&unk_1482C0F54);
          }
          (*(void (__fastcall **)(__int64, const char *, const char *, void **))(*(_QWORD *)v38 + 0x40LL))(
            v38,
            "void __cdecl CSpawningManager::ReportSpawnRequestTimings(unsigned int,int,bool)",
            "SpawnRequest",
            &v46);
          sub_140373CC0(&v46);
          v39 = (__int64 **)_Wherenode_1[2];
          _Wherenode = _Wherenode_1;
          if ( *((_BYTE *)v39 + 0x19) )
          {
            for ( _Wherenode_2 = (__int64 *)_Wherenode_1[1];
                  !*((_BYTE *)_Wherenode_2 + 0x19);
                  _Wherenode_2 = (__int64 *)_Wherenode_2[1] )
            {
              if ( _Wherenode_1 != (__int64 *)_Wherenode_2[2] )
                break;
              _Wherenode_1 = _Wherenode_2;
            }
          }
          else
          {
            for ( i = *v39; !*((_BYTE *)i + 0x19); i = (__int64 *)*i )
              ;
          }
          v43 = sub_1402E2560(v50, _Wherenode);
          sub_1402A6590((__int64)v43);
          goto LABEL_73;
        }
      }
      else
      {
        if ( !v34 )
        {
          p_p_Src = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)((v25 & 0xFFFFFFFFFFFFLL)
                                                                                             + 8)
                                                                                 & 0xFFFFFFFFFFFFLL)
                                                                     + 0x70LL))(*(_QWORD *)((v25 & 0xFFFFFFFFFFFFLL) + 8) & 0xFFFFFFFFFFFFLL);
          goto LABEL_51;
        }
        v36 = sub_1403B7660((__int64)&v58);
        if ( (unsigned __int64)sub_1403EBE30(v36) > 0x12 )
        {
          p_p_Src = (const char *)(*v36 + 0x13);
          goto LABEL_51;
        }
      }
      p_p_Src = (const char *)&p_Src;
      goto LABEL_51;
    }
  }
LABEL_73:
  v44 = *(_DWORD *)(v6 + 0x14);
  if ( v44 )
  {
    result = (const ULONG_PTR *)(unsigned int)(v44 - 1);
    *(_DWORD *)(v6 + 0x14) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(v6 + 0x10) = 0xFFFFFFFF;
    result = (const ULONG_PTR *)(unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v6, 0, 1);
    if ( (_DWORD)result == 1 )
      *(_QWORD *)(v6 + 8) = &p_Src;
    else
      return sub_1403DF590(v6, (unsigned int)result);
  }
  return result;
}

// --- End Function: sub_144E93E40 (0x144E93E40) ---

// --- Function: sub_144EB8930 (0x144EB8930) ---
__int64 __fastcall sub_144EB8930(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // rbx
  int v6; // esi
  unsigned int v7; // eax
  _BYTE *v8; // rdx
  int v9; // eax
  unsigned __int32 v10; // eax
  void (__fastcall *v11)(__int64, __int64 (__fastcall **)()); // rbx
  _OWORD *v12; // rax
  __int64 p_sub_140C22170_1; // rax
  __int128 v14; // [rsp+20h] [rbp-48h]
  __int64 (__fastcall *p_sub_144D8FDA0)(); // [rsp+30h] [rbp-38h] BYREF
  __int64 (__fastcall *p_sub_140C22170)(); // [rsp+38h] [rbp-30h]
  _OWORD *v17; // [rsp+40h] [rbp-28h]
  int v18; // [rsp+80h] [rbp+18h] BYREF

  v18 = a3;
  v4 = a1 + 0x2E8;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v6 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
    if ( v7 )
      sub_1403C6E80(v4, v7, (__int64)"CSpawningManager::SetCreationBatchCallback", 1);
    else
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v4 + 0x10) = v6;
  }
  v8 = *(_BYTE **)(a1 + 0x2D8);
  if ( v8 == *(_BYTE **)(a1 + 0x2E0) )
  {
    sub_140347870(a1 + 0x2D0, v8, &v18);
  }
  else
  {
    *(_DWORD *)v8 = v18;
    *(_QWORD *)(a1 + 0x2D8) += 4LL;
  }
  v9 = *(_DWORD *)(v4 + 0x14);
  if ( v9 )
  {
    *(_DWORD *)(v4 + 0x14) = v9 - 1;
  }
  else
  {
    *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
    v10 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
    if ( v10 == 1 )
      *(_QWORD *)(v4 + 8) = &p_Src;
    else
      sub_1403DF590(v4, v10);
  }
  *(_QWORD *)&v14 = a1;
  v11 = *(void (__fastcall **)(__int64, __int64 (__fastcall **)()))(*(_QWORD *)a2 + 0x30LL);
  DWORD2(v14) = v18;
  v12 = (_OWORD *)sub_1402A65A0(0x10u);
  if ( v12 )
  {
    *v12 = v14;
    v17 = v12;
  }
  else
  {
    v17 = 0;
  }
  p_sub_144D8FDA0 = sub_144D8FDA0;
  p_sub_140C22170 = sub_140C22170;
  v11(a2, &p_sub_144D8FDA0);
  p_sub_140C22170_1 = (__int64)p_sub_140C22170;
  if ( (unsigned __int64)p_sub_140C22170 >= 2 )
    return ((__int64 (__fastcall *)(__int64, __int64 (__fastcall **)()))p_sub_140C22170)(2, &p_sub_144D8FDA0);
  return p_sub_140C22170_1;
}

// --- End Function: sub_144EB8930 (0x144EB8930) ---

// --- Function: sub_144ECC050 (0x144ECC050) ---
__int64 sub_144ECC050(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int128 v5; // xmm8
  __int128 v6; // xmm9
  __int128 v7; // xmm10
  __int128 v8; // xmm11
  __int128 v9; // xmm12
  __int64 v10; // r9
  unsigned int v12; // edi
  signed __int32 v13; // eax
  _QWORD *v14; // r12
  int v15; // r8d
  int v16; // esi
  _QWORD *v17; // rax
  double v18; // xmm1_8
  __int64 v19; // rdx
  __int64 v20; // rax
  __int64 v21; // rbx
  __int64 v22; // r14
  double v23; // xmm1_8
  __int64 v24; // rax
  __int64 v25; // rbx
  __int64 v26; // rdi
  unsigned __int8 *v27; // rax
  bool v28; // zf
  const char *_NONE; // rax
  __int64 v30; // rax
  __int64 v31; // rax
  int v32; // edi
  __int64 *v33; // rcx
  __int64 v34; // rax
  volatile signed __int32 *v35; // rbx
  volatile signed __int32 *v36; // rbx
  __int64 v37; // r8
  __int64 v38; // rax
  __int64 v39; // rax
  __int16 n0xFFFF_2; // dx
  __int64 v41; // rax
  __int64 v42; // rbx
  __int64 (__fastcall *v43)(__int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF; // cx
  __int64 v45; // rbx
  __int64 v46; // rax
  __int16 n4; // cx
  __int64 v48; // rax
  float v49; // xmm7_4
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 v52; // rbx
  __int64 v53; // rdi
  const char *v54; // rsi
  const char *_NO_CLASS_SPECIFIED_4; // rax
  __int64 v56; // rcx
  __int64 v57; // rcx
  __int64 v58; // rdi
  __int64 v59; // rbx
  __int64 v60; // rax
  const char *_NO_CLASS_SPECIFIED_3; // rax
  __int64 v62; // rcx
  __int64 v63; // rdi
  __int64 v64; // rbx
  __int64 v65; // rax
  __int64 v66; // rbx
  __int64 v67; // rax
  __int64 v68; // rax
  double v69; // xmm6_8
  int v70; // ebx
  int v71; // edx
  __int64 *v72; // rax
  __int64 v73; // rax
  void **v74; // rax
  void **v75; // rbx
  const char *v76; // rax
  void **v77; // rax
  __int64 v78; // r8
  const char *_NO_CLASS_SPECIFIED_2; // rax
  __int64 v80; // rcx
  __int64 v81; // rdi
  __int64 v82; // rbx
  __int64 v83; // rax
  __int16 n0xFFFF_3; // dx
  __int16 n0xFFFF_4; // dx
  __int64 v86; // rdx
  __int64 v87; // rcx
  __int64 v88; // rdx
  __int64 v89; // rcx
  _QWORD *v90; // r8
  _QWORD *v91; // r8
  __int64 v92; // rdi
  __int64 (__fastcall *v93)(__int64, const char *, _QWORD); // rbx
  unsigned int v94; // eax
  unsigned int *v95; // rbx
  _QWORD *v96; // rax
  __int64 v97; // rcx
  __int64 v98; // rdi
  __int64 (__fastcall *v99)(__int64, const char *, _QWORD); // rbx
  unsigned int v100; // eax
  unsigned int *v101; // rax
  unsigned int *v102; // rbx
  _QWORD *v103; // rcx
  _BYTE *v104; // rax
  char v105; // cl
  int v106; // r14d
  __int64 v107; // rbx
  __int64 v108; // rax
  __int64 v109; // rdi
  __int64 (__fastcall *v110)(__int64, _BYTE *, __int16 *); // rsi
  __int16 n0xFFFF_5; // cx
  __int64 v112; // rdi
  __int64 v113; // rsi
  __int64 v114; // rax
  __int16 n4_1; // cx
  void (__fastcall *v116)(__int64); // rax
  __int64 v117; // rax
  double v118; // xmm1_8
  void (__fastcall *v119)(__int64, _QWORD); // r8
  __int64 v120; // rcx
  __int64 v121; // rcx
  __int64 v122; // rdi
  __int64 v123; // rbx
  const char *_NO_CLASS_SPECIFIED_1; // rax
  __int64 v125; // rcx
  __int64 v126; // rdi
  __int64 v127; // rbx
  const char *_NO_CLASS_SPECIFIED; // rax
  __int64 v129; // rcx
  __int64 v130; // rdi
  __int64 v131; // rbx
  __int64 v132; // rax
  volatile signed __int32 *v133; // rbx
  __int64 v134; // rcx
  char v135; // di
  int v136; // esi
  __int64 v137; // r8
  unsigned __int64 v138; // rax
  Parameter *Parameter; // rbx
  __int64 v140; // rcx
  int v141; // eax
  unsigned __int64 n0x200000; // rax
  unsigned int v143; // ebx
  char v145; // [rsp+50h] [rbp-B8h]
  __int64 v146; // [rsp+50h] [rbp-B8h]
  int v147; // [rsp+78h] [rbp-90h] BYREF
  char v148; // [rsp+7Ch] [rbp-8Ch] BYREF
  __int128 v149; // [rsp+80h] [rbp-88h] BYREF
  unsigned int v150; // [rsp+90h] [rbp-78h]
  void (__fastcall ***v151)(_QWORD, __int64); // [rsp+98h] [rbp-70h] BYREF
  _BYTE v152[2]; // [rsp+A0h] [rbp-68h] BYREF
  __int16 n0xFFFF_1; // [rsp+A2h] [rbp-66h] BYREF
  __int16 n0xFFFF_6; // [rsp+A4h] [rbp-64h] BYREF
  int v155; // [rsp+A8h] [rbp-60h]
  int v156; // [rsp+ACh] [rbp-5Ch] BYREF
  float v157; // [rsp+B0h] [rbp-58h] BYREF
  void *v158; // [rsp+B8h] [rbp-50h] BYREF
  _BYTE v159[2]; // [rsp+C0h] [rbp-48h] BYREF
  _BYTE v160[2]; // [rsp+C2h] [rbp-46h] BYREF
  _BYTE v161[2]; // [rsp+C4h] [rbp-44h] BYREF
  _BYTE v162[2]; // [rsp+C6h] [rbp-42h] BYREF
  _BYTE v163[2]; // [rsp+C8h] [rbp-40h] BYREF
  _BYTE v164[2]; // [rsp+CAh] [rbp-3Eh] BYREF
  _BYTE v165[4]; // [rsp+CCh] [rbp-3Ch] BYREF
  int v166; // [rsp+D0h] [rbp-38h]
  __int64 v167; // [rsp+D8h] [rbp-30h] BYREF
  __int128 src; // [rsp+E0h] [rbp-28h] BYREF
  __int64 v169; // [rsp+F0h] [rbp-18h]
  char v170; // [rsp+F8h] [rbp-10h]
  __int128 v171; // [rsp+100h] [rbp-8h] BYREF
  double v172; // [rsp+110h] [rbp+8h]
  __int128 v173; // [rsp+118h] [rbp+10h] BYREF
  __int128 v174; // [rsp+128h] [rbp+20h]
  __int128 v175; // [rsp+138h] [rbp+30h]
  __int128 v176; // [rsp+148h] [rbp+40h]
  __int64 v177; // [rsp+158h] [rbp+50h]
  __m256 v178; // [rsp+160h] [rbp+58h]
  __m256i v179; // [rsp+180h] [rbp+78h]
  __int64 v180; // [rsp+1A0h] [rbp+98h]
  int v181; // [rsp+1A8h] [rbp+A0h]
  __int64 v182; // [rsp+1B0h] [rbp+A8h]
  int v183; // [rsp+1B8h] [rbp+B0h] BYREF
  __int64 v184; // [rsp+1C0h] [rbp+B8h]
  __int64 v185; // [rsp+1C8h] [rbp+C0h]
  const char *v186; // [rsp+1D0h] [rbp+C8h] BYREF
  int v187; // [rsp+1D8h] [rbp+D0h]
  __int64 v188; // [rsp+1E0h] [rbp+D8h]
  int v189; // [rsp+1E8h] [rbp+E0h]
  __int64 v190; // [rsp+1F0h] [rbp+E8h]
  __int64 n8; // [rsp+1F8h] [rbp+F0h]
  __int64 v192; // [rsp+200h] [rbp+F8h]
  __int64 v193; // [rsp+208h] [rbp+100h]
  char v194; // [rsp+210h] [rbp+108h]
  __int64 v195; // [rsp+218h] [rbp+110h]
  unsigned __int64 v196; // [rsp+220h] [rbp+118h]
  __int64 v197; // [rsp+228h] [rbp+120h]
  _QWORD v198[2]; // [rsp+230h] [rbp+128h] BYREF
  char v199; // [rsp+240h] [rbp+138h]
  __int64 v200; // [rsp+248h] [rbp+140h] BYREF
  int v201; // [rsp+250h] [rbp+148h]
  char v202; // [rsp+254h] [rbp+14Ch]
  char v203; // [rsp+258h] [rbp+150h]
  __int64 v204; // [rsp+268h] [rbp+160h] BYREF
  __int64 v205; // [rsp+270h] [rbp+168h] BYREF
  __int64 v206; // [rsp+278h] [rbp+170h] BYREF
  __int64 v207; // [rsp+280h] [rbp+178h] BYREF
  volatile signed __int32 *v208; // [rsp+288h] [rbp+180h]
  __int128 v209; // [rsp+290h] [rbp+188h] BYREF
  double v210; // [rsp+2A0h] [rbp+198h]
  __int128 v211; // [rsp+2A8h] [rbp+1A0h] BYREF
  double v212; // [rsp+2B8h] [rbp+1B0h]
  __int64 v213; // [rsp+2C0h] [rbp+1B8h]
  double v214; // [rsp+2D8h] [rbp+1D0h] BYREF
  int v215; // [rsp+2E0h] [rbp+1D8h]
  _QWORD *v216; // [rsp+2E8h] [rbp+1E0h]
  __int64 v217; // [rsp+2F0h] [rbp+1E8h]
  void *(__fastcall **v218)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+2F8h] [rbp+1F0h] BYREF
  __int64 v219; // [rsp+300h] [rbp+1F8h]
  void (__fastcall ***v220)(_QWORD, _QWORD); // [rsp+308h] [rbp+200h] BYREF
  __int64 v221; // [rsp+310h] [rbp+208h]
  __int128 v222; // [rsp+318h] [rbp+210h] BYREF
  double v223; // [rsp+328h] [rbp+220h]
  __int64 v224; // [rsp+330h] [rbp+228h] BYREF
  __int64 **v225; // [rsp+338h] [rbp+230h] BYREF
  __int64 v226; // [rsp+340h] [rbp+238h]
  int *v227; // [rsp+348h] [rbp+240h]
  int v228; // [rsp+350h] [rbp+248h] BYREF
  _QWORD v229[2]; // [rsp+358h] [rbp+250h] BYREF
  double v230[3]; // [rsp+368h] [rbp+260h] BYREF
  _QWORD v231[3]; // [rsp+380h] [rbp+278h] BYREF
  char v232; // [rsp+398h] [rbp+290h]
  __m256 v233; // [rsp+3A8h] [rbp+2A0h] BYREF
  __m256i v234; // [rsp+3C8h] [rbp+2C0h] BYREF
  _BYTE v235[8]; // [rsp+3E8h] [rbp+2E0h] BYREF
  _BYTE v236[8]; // [rsp+3F0h] [rbp+2E8h] BYREF
  _BYTE v237[8]; // [rsp+3F8h] [rbp+2F0h] BYREF
  _BYTE v238[8]; // [rsp+400h] [rbp+2F8h] BYREF
  volatile signed __int32 *v239; // [rsp+408h] [rbp+300h]
  __m256 v240; // [rsp+410h] [rbp+308h] BYREF
  __int128 v241; // [rsp+430h] [rbp+328h]
  double v242; // [rsp+440h] [rbp+338h]
  double v243; // [rsp+448h] [rbp+340h]
  _BYTE v244[24]; // [rsp+450h] [rbp+348h] BYREF
  _BYTE v245[24]; // [rsp+468h] [rbp+360h] BYREF
  __int128 v246; // [rsp+480h] [rbp+378h] BYREF
  __int128 v247; // [rsp+490h] [rbp+388h] BYREF
  __int128 v248; // [rsp+4A0h] [rbp+398h] BYREF
  _OWORD v249[9]; // [rsp+4B0h] [rbp+3A8h] BYREF
  __int64 v250; // [rsp+5A0h] [rbp+498h] BYREF
  va_list va; // [rsp+5A0h] [rbp+498h]
  __int64 v252; // [rsp+5A8h] [rbp+4A0h]
  va_list va1; // [rsp+5B0h] [rbp+4A8h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v250 = va_arg(va1, _QWORD);
  v10 = v250;
  v252 = va_arg(va1, _QWORD);
  *(_OWORD *)((char *)&v249[7] + 8) = v3;
  *(_OWORD *)((char *)&v249[6] + 8) = v4;
  *(_OWORD *)((char *)&v249[5] + 8) = v5;
  *(_OWORD *)((char *)&v249[4] + 8) = v6;
  *(_OWORD *)((char *)&v249[3] + 8) = v7;
  *(_OWORD *)((char *)&v249[2] + 8) = v8;
  *(_OWORD *)((char *)&v249[1] + 8) = v9;
  v221 = v252;
  v213 = a3;
  v217 = a2;
  v12 = 0;
  v150 = 0;
  src = 0;
  v169 = 0;
  v170 = 1;
  v13 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0x218), 1u);
  v14 = *(_QWORD **)a2;
  v147 = v13 + 1;
  v15 = 0;
  v155 = 0;
  v16 = *(_DWORD *)(n29 + 0x1274);
  v17 = *(_QWORD **)(a2 + 8);
  v166 = v16;
  v216 = v17;
  if ( v14 != v17 )
  {
    while ( 1 )
    {
      LOBYTE(v10) = 0xB;
      (*(void (__fastcall **)(__int64, void (__fastcall ****)(_QWORD, __int64), const char *, __int64, _DWORD))(*(_QWORD *)qword_149C8DFC0 + 0xC8LL))(
        qword_149C8DFC0,
        &v151,
        "CSpawningManager::TrySpawn",
        v10,
        0);
      if ( !v151 )
        goto LABEL_264;
      v18 = *((double *)v14 + 0x19);
      v19 = v14[0x20];
      v171 = *(_OWORD *)(v14 + 0x17);
      v172 = v18;
      v20 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(qword_149C8DFC0, v19);
      v21 = v20;
      if ( v20 )
        v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x668LL))(v20);
      else
        v22 = 0;
      if ( !*((_BYTE *)v14 + 0x94) )
        goto LABEL_17;
      v23 = *((double *)v14 + 0x19);
      v222 = *(_OWORD *)(v14 + 0x17);
      v223 = v23;
      if ( v22 )
      {
        v24 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int128 *))(*(_QWORD *)v22 + 0x170LL))(v22, v244, &v222);
        v222 = *(_OWORD *)v24;
        v223 = *(double *)(v24 + 0x10);
      }
      if ( !v21 )
        goto LABEL_15;
      v25 = v14[4];
      v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB0 + 0x60LL))(qword_149C8DFB0);
      v27 = (unsigned __int8 *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v26 + 0x10LL))(
                                 v26,
                                 v152,
                                 v25);
      if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, __int64, __int128 *, int, int, __int128 *))(*(_QWORD *)v26 + 0x150LL))(
             v26,
             *v27,
             v22,
             &v222,
             0x3F800000,
             0x3F800000,
             &v171) )
      {
        break;
      }
      v28 = !sub_1403C3450(v14);
      _NONE = "<NONE>";
      if ( v28 )
        _NONE = (const char *)*v14;
      sub_144E93A80(a1, v147, 0, "Unable to snap spawn position to nav mesh. Class: %s", _NONE);
LABEL_262:
      if ( v151 )
        (**v151)(v151, 1);
LABEL_264:
      v14 += 0x2E;
      if ( v14 == v216 )
      {
        v15 = v155;
        a2 = v217;
        goto LABEL_270;
      }
      v12 = v150;
      v16 = v166;
    }
    v12 = v150;
LABEL_15:
    if ( v22 )
    {
      v30 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int128 *))(*(_QWORD *)v22 + 0xF8LL))(v22, v245, &v171);
      v171 = *(_OWORD *)v30;
      v172 = *(double *)(v30 + 0x10);
    }
LABEL_17:
    if ( v14[0x2A] )
    {
      v31 = v14[0x2B];
      v32 = v12 | 1;
      v150 = v32;
      if ( v31 )
        _InterlockedIncrement((volatile signed __int32 *)(v31 + 8));
      v33 = &v207;
      v207 = v14[0x2A];
      v208 = (volatile signed __int32 *)v14[0x2B];
    }
    else
    {
      v32 = v12 | 2;
      v150 = v32;
      v33 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149C8DFC0 + 0x110LL))(
                         qword_149C8DFC0,
                         v238);
    }
    v149 = 0;
    v34 = v33[1];
    if ( v34 )
      _InterlockedIncrement((volatile signed __int32 *)(v34 + 8));
    v149 = *(_OWORD *)v33;
    if ( (v32 & 2) != 0 )
    {
      v35 = v239;
      v32 &= ~2u;
      v150 = v32;
      if ( v239 )
      {
        if ( _InterlockedExchangeAdd(v239 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
          if ( _InterlockedExchangeAdd(v35 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
        }
      }
    }
    if ( (v32 & 1) != 0 )
    {
      v150 = v32 & 0xFFFFFFFE;
      if ( v208 )
      {
        if ( _InterlockedExchangeAdd(v208 + 2, 0xFFFFFFFF) == 1 )
        {
          v36 = v208;
          (**(void (__fastcall ***)(volatile signed __int32 *))v208)(v208);
          if ( _InterlockedExchangeAdd(v36 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v208 + 8LL))(v208);
        }
      }
    }
    v177 = 0;
    v173 = 0;
    v174 = 0;
    v175 = 0;
    v176 = 0;
    __asm
    {
      vmovupd xmmword ptr [rbp+470h+var_418+8], xmm0
      vmovupd [rbp+470h+var_3F8+8], xmm0
    }
    *(double *)&v178.m256_f32[6] = 1.0;
    *(double *)v178.m256_f32 = 0.0;
    *(double *)v179.m256i_i64 = 0.0;
    *(double *)&v179.m256i_i64[3] = 1.0;
    v180 = 0;
    v181 = 0;
    v182 = 0;
    sub_140362E10(&v183);
    v184 = 0;
    v185 = 0;
    sub_14035E090(&v186);
    v190 = 0;
    n8 = 8;
    v187 = 0;
    v188 = 0;
    v189 = 0;
    v192 = 0;
    v193 = 0;
    v194 = 0;
    v195 = 0;
    v196 = 0xFFFFFFFFFFFFFFFFuLL;
    v197 = 1;
    sub_14035E090(v198);
    v198[1] = 0;
    v199 = 0;
    sub_14035E090(&v200);
    v37 = v14[0x20];
    v240 = *(__m256 *)(v14 + 0x13);
    v241 = v171;
    v243 = 1.0;
    v201 = 0;
    v202 = 0;
    v203 = 0;
    v242 = v172;
    __asm { vzeroupper }
    SEntityTransform::ApplyWorldPose((__int64)&v173, (__int64)&v240, v37);
    v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
    v39 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v38 + 0x20LL))(v38, *v14);
    if ( !v39 )
    {
      v28 = !sub_1403C3450(v14);
      _NO_CLASS_SPECIFIED = "<NO CLASS SPECIFIED>";
      if ( v28 )
        _NO_CLASS_SPECIFIED = (const char *)*v14;
      sub_144E93A80(a1, v147, 0, "!DESIGN BUG: Failed to spawn %s - entity class does not exist!", _NO_CLASS_SPECIFIED);
      sub_140373CC0(&v200);
      sub_140373CC0(v198);
      sub_140373CC0(&v186);
      sub_140375A30(&v183);
      if ( *((_QWORD *)&v176 + 1) )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v176 + 1) + 0x28LL))(*((_QWORD *)&v176 + 1));
      if ( (_QWORD)v176 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v176 + 0x28LL))(v176);
      v129 = *((_QWORD *)&v175 + 1);
      if ( *((_QWORD *)&v175 + 1)
        && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v175 + 1) + 0xCLL), 0xFFFFFFFF) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v129 + 8LL))(v129);
      }
      v121 = *((_QWORD *)&v173 + 1);
      if ( !*((_QWORD *)&v173 + 1) )
        goto LABEL_258;
      v130 = v174;
      if ( *((_QWORD *)&v173 + 1) == (_QWORD)v174 )
        goto LABEL_255;
      v131 = *((_QWORD *)&v173 + 1) + 8LL;
      do
      {
        if ( *(_QWORD *)v131 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)v131 + 8LL) + 0x10LL))(*(_QWORD *)v131 + 8LL);
        *(_QWORD *)v131 = 0;
        v131 += 0x20;
      }
      while ( v131 - 8 != v130 );
      goto LABEL_254;
    }
    sub_1403D7FA0(&v173, v39);
    sub_140394720(&v173, v14 + 0x28);
    sub_1403629B0(&v156, a1 + 0x378);
    sub_140394720(&v173, &v156);
    sub_140375A30(&v156);
    sub_1403D2B20(&v173, (char *)v14 + 0x144);
    if ( v14[0x21] )
    {
      JsonNode::SetInt(v149, (__int64)"user.entityIdToSpawnIn", v14 + 0x21);
      if ( *((_DWORD *)v14 + 0x52) != 0xFFFFFFFF )
        sub_14042F8B0(v149, "user.usableEntryIdToSpawnIn");
    }
    SEntityTransform::SetEntityFlags((__int64)&v173, 0x81000);
    if ( v16
      || (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)v149 + 0x10LL))(
           v149,
           "smn.quantumSpawnId") )
    {
      if ( n0xFFFF_29 == (__int16)0xFFFF )
        n0xFFFF_29 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                         + 0x10LL))(
                                 qword_149C8DFC8,
                                 v159,
                                 "SpawningManagerNotifierComponent");
      sub_140390DD0(&v173);
      sub_14042F8B0(v149, "smn.spawnId");
    }
    n0xFFFF_2 = n0xFFFF_30;
    if ( n0xFFFF_30 == (__int16)0xFFFF )
    {
      n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                      + 0x10LL))(
                              qword_149C8DFC8,
                              v160,
                              "AttachableComponent");
      n0xFFFF_30 = n0xFFFF_2;
    }
    if ( *((_WORD *)v14 + 0xB4) < 0x3FFu && find_component_by_id((__int64)&v173, n0xFFFF_2) )
    {
      v41 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(
              qword_149C8DFC0,
              v14[0x2C]);
      v42 = v41;
      if ( v41 )
      {
        v43 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v41 + 0x340LL);
        n0xFFFF = n0xFFFF_14;
        if ( n0xFFFF_14 == (__int16)0xFFFF )
        {
          n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                        + 0x10LL))(
                                qword_149C8DFC8,
                                v161,
                                "IItemPortContainer");
          n0xFFFF_14 = n0xFFFF;
        }
        n0xFFFF_1 = n0xFFFF;
        v45 = *(_QWORD *)v43(v42, v235, &n0xFFFF_1);
        v204 = v45;
        if ( v45 )
        {
          v46 = sub_1403B84E0(v45 & 0xFFFFFFFFFFFFLL);
          n4 = *(_WORD *)(v46 + 4);
          if ( n4 != 4
            && *(_WORD *)(v46 + 2) == (HIWORD(v45) & 0xFFF)
            && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140395350(&v204)) )
          {
            v48 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)(v45 & 0xFFFFFFFFFFFFLL) + 0x590LL))(
                    v45 & 0xFFFFFFFFFFFFLL,
                    v14 + 0x2C);
            if ( v48 )
              sub_140397230(&v173, v48);
          }
        }
      }
      else
      {
        v204 = 0;
      }
    }
    v49 = 0.0;
    v157 = 0.0;
    v50 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
    v51 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v50 + 0x140LL))(v50);
    v52 = v173;
    v53 = v51;
    if ( !(_QWORD)v173 )
    {
      v28 = !sub_1403C3450(v14);
      _NO_CLASS_SPECIFIED_1 = "<NO CLASS SPECIFIED>";
      if ( v28 )
        _NO_CLASS_SPECIFIED_1 = (const char *)*v14;
      sub_144E93A80(a1, v147, 0, "!DESIGN BUG: Failed to spawn %s - class does not exist!", _NO_CLASS_SPECIFIED_1);
      sub_140373CC0(&v200);
      sub_140373CC0(v198);
      sub_140373CC0(&v186);
      sub_140375A30(&v183);
      if ( *((_QWORD *)&v176 + 1) )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v176 + 1) + 0x28LL))(*((_QWORD *)&v176 + 1));
      if ( (_QWORD)v176 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v176 + 0x28LL))(v176);
      v125 = *((_QWORD *)&v175 + 1);
      if ( *((_QWORD *)&v175 + 1)
        && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v175 + 1) + 0xCLL), 0xFFFFFFFF) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v125 + 8LL))(v125);
      }
      v121 = *((_QWORD *)&v173 + 1);
      if ( !*((_QWORD *)&v173 + 1) )
        goto LABEL_258;
      v126 = v174;
      if ( *((_QWORD *)&v173 + 1) == (_QWORD)v174 )
        goto LABEL_255;
      v127 = *((_QWORD *)&v173 + 1) + 8LL;
      do
      {
        if ( *(_QWORD *)v127 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)v127 + 8LL) + 0x10LL))(*(_QWORD *)v127 + 8LL);
        *(_QWORD *)v127 = 0;
        v127 += 0x20;
      }
      while ( v127 - 8 != v126 );
LABEL_254:
      v121 = *((_QWORD *)&v173 + 1);
      goto LABEL_255;
    }
    v54 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v173 + 0x18LL))(v173);
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *))(*(_QWORD *)v53 + 0x40LL))(v53, v54) )
      goto LABEL_131;
    if ( (unsigned __int8)sub_144D8C6F0(a1, v52, &v157) )
    {
      v49 = v157;
      if ( v157 >= 0.1 )
      {
        if ( *((_BYTE *)v14 + 0xE2) )
          goto LABEL_108;
        v66 = v173;
        v67 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
        v68 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v67 + 0x140LL))(v67);
        (*(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v68 + 0xE0LL))(v68, &v167, v66);
        if ( v167 )
        {
          v69 = *(double *)(v167 + 0x58);
          v70 = *(_DWORD *)(v167 + 0x60);
          sub_1405BD1A0(&v167);
          v215 = v70;
          v145 = *((_BYTE *)v14 + 0xE3);
          v233 = v178;
          v234 = v179;
          v214 = v69;
          __asm { vzeroupper }
          if ( (unsigned __int8)sub_144E76030(
                                  a1,
                                  v71,
                                  (unsigned int)&v171,
                                  (int)v14 + 0x98,
                                  v22,
                                  (__int64)&v234,
                                  (__int64)&v233,
                                  v147,
                                  v213,
                                  v145,
                                  (__int64)&v214,
                                  0,
                                  0)
            && !(unsigned int)sub_1403B8550(&v173) )
          {
            v72 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v22 + 0x40LL))(v22, v236);
            SEntityTransform::ApplyWorldPose((__int64)&v173, (__int64)&v233, *v72);
          }
LABEL_108:
          v73 = *(_QWORD *)v22;
          v209 = *(_OWORD *)v179.m256i_i8;
          v210 = *(double *)&v179.m256i_i64[2];
          (*(void (__fastcall **)(__int64, double *, __int128 *))(v73 + 0x170))(v22, v230, &v209);
          sub_14035E090(&v158);
          sub_14035E090(&v224);
          v75 = v74;
          v76 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x1F0LL))(v22);
          v77 = sub_1403ACC80(
                  v75,
                  "SpawningManager - Spawn Vehicle - Class:%s - Name:%s - Original: Zone:(%f,%f,%f) - Resolved: Zone:(%s)"
                  "(%f,%f,%f) - World:(%f,%f,%f)",
                  v54,
                  v186,
                  *(double *)&v171,
                  *((double *)&v171 + 1),
                  v172,
                  v76,
                  *(double *)&v209,
                  *((double *)&v209 + 1),
                  v210,
                  v230[0],
                  v230[1],
                  v230[2]);
          copyStringStructure(&v158, (const void **)v77, v78);
          sub_140373CC0(&v224);
          if ( BYTE1(qword_149C8E516) )
            LogTraceConditional((const char *)&format_string_, v158);
          else
            sub_1403A63E0(&format_string_);
          sub_140373CC0(&v158);
LABEL_131:
          n0xFFFF_3 = n0xFFFF_31;
          if ( n0xFFFF_31 == (__int16)0xFFFF )
          {
            n0xFFFF_3 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                            + 0x10LL))(
                                    qword_149C8DFC8,
                                    v165,
                                    "SCItemControllableManager");
            n0xFFFF_31 = n0xFFFF_3;
          }
          if ( find_component_by_id((__int64)&v173, n0xFFFF_3) )
            sub_1411F9AC0(v149, "cm.spawnFlags", v14 + 0x1B);
          n0xFFFF_4 = n0xFFFF_32;
          if ( n0xFFFF_32 == (__int16)0xFFFF )
          {
            n0xFFFF_4 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                            + 0x10LL))(
                                    qword_149C8DFC8,
                                    v162,
                                    "EntityComponentCrewManifest");
            n0xFFFF_32 = n0xFFFF_4;
          }
          if ( find_component_by_id((__int64)&v173, n0xFFFF_4) )
          {
            if ( v14[5] || v14[6] )
              sub_14042FD90(v149, "cm.override", v14 + 5);
            if ( !(unsigned __int8)sub_1403C3460(v14 + 0x10) )
              sub_14197BC10(v149, "cm.tags", v14 + 0x10);
            v90 = v14 + 9;
            if ( v14[9] || v14[0xA] )
              sub_14042FD90(v149, "cm.skills", v90);
            if ( *((_DWORD *)v14 + 0x1A) != *(_DWORD *)sub_1403BBE70(v89, v88, v90) )
              sub_140430010(v149, "cm.charname");
            if ( v14[0xF] )
              JsonNode::SetInt(v149, (__int64)"cm.firstcrewid", v14 + 0xF);
            if ( v250 )
              JsonNode::SetInt(v149, (__int64)"cm.mission", (__int64 *)va);
          }
          if ( v14[0xB] || v14[0xC] )
            sub_14042FD90(v149, "vc.aiDamageModifierOverrideId", v14 + 0xB);
          v91 = v14 + 7;
          if ( v14[7] || v14[8] )
            sub_14042FD90(v149, "cargo.controller.manifest.guid", v91);
          if ( v14[0x22] || v14[0x23] )
          {
            v92 = v149;
            v93 = *(__int64 (__fastcall **)(__int64, const char *, _QWORD))(*(_QWORD *)v149 + 0x28LL);
            v94 = sub_14180C000(v87, v86, v91);
            v95 = (unsigned int *)v93(v92, "sc.initialactivity", v94);
            if ( v95 )
            {
              v219 = 0;
              v218 = &off_1482C5768;
              sub_14033A870(&v218, &word_1482B78A4, v14 + 0x22);
              sub_140422000(v95, (unsigned __int64)(v219 + 7) >> 3);
              v96 = v95 + 2;
              v97 = 8LL * *v95;
              if ( v95[1] > 0x10 )
                v96 = (_QWORD *)*v96;
              v231[0] = v96;
              v231[1] = v97;
              v229[0] = &off_1482C5768;
              v231[2] = 0;
              v229[1] = v231;
              v232 = 1;
              sub_14033AA50(v229, &word_1482B78A4, v14 + 0x22);
            }
          }
          if ( v14[0x1F] )
            JsonNode::SetInt(v149, (__int64)"sc.platformEntId", v14 + 0x1F);
          if ( (v14[0x24] || v14[0x25]) && (v14[0x26] || v14[0x27]) && (v14[0x1D] || v14[0x1E]) )
          {
            v246 = *((_OWORD *)v14 + 0x12);
            sub_14042FD90(v149, "sc.platformId", &v246);
            v247 = *((_OWORD *)v14 + 0x13);
            sub_14042FD90(v149, "sc.layerId", &v247);
            v249[0] = *(_OWORD *)(v14 + 0x1D);
            sub_14042FD90(v149, "sc.npcId", v249);
          }
          if ( *((_BYTE *)v14 + 0x95) )
          {
            v148 = 1;
            sub_140430970(v149, "GeomResourceHolographic", &v148);
          }
          if ( *((_BYTE *)v14 + 0x96) )
          {
            if ( n0xFFFF_33 == (__int16)0xFFFF )
              n0xFFFF_33 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                               + 0x10LL))(
                                       qword_149C8DFC8,
                                       v163,
                                       "EASpawnRezComponent");
            sub_140390DD0(&v173);
            v98 = v149;
            v99 = *(__int64 (__fastcall **)(__int64, const char *, _QWORD))(*(_QWORD *)v149 + 0x28LL);
            v100 = sub_14042F6D0();
            v101 = (unsigned int *)v99(v98, "EASpawnRez.SpawnFlags", v100);
            v102 = v101;
            if ( v101 )
            {
              sub_140422000(v101, 1u);
              v103 = v102 + 2;
              if ( v102[1] > 0x10 )
                v103 = (_QWORD *)*v103;
              v104 = 0;
              if ( 8 * (unsigned __int64)*v102 >= 8 )
                v104 = v103;
              if ( v104 )
                *v104 = 4;
            }
          }
          v105 = *((_BYTE *)v14 + 0xE4);
          v146 = v14[3];
          v205 = 0;
          v106 = sub_144D792A0(
                   a1,
                   (_DWORD)v151,
                   (unsigned int)&v173,
                   (unsigned int)&v149,
                   LODWORD(v49),
                   v250,
                   0,
                   v105,
                   (__int64)&v205,
                   v146);
          v107 = v205;
          if ( v14[0x1F] && (v14[0x1D] || v14[0x1E]) )
          {
            v108 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x118LL))(qword_149C8DFC0);
            v109 = v108;
            if ( v108 )
            {
              v110 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v108 + 0x340LL);
              n0xFFFF_5 = n0xFFFF_34;
              if ( n0xFFFF_34 == (__int16)0xFFFF )
              {
                n0xFFFF_5 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                                + 0x10LL))(
                                        qword_149C8DFC8,
                                        v164,
                                        "SubsumptionPlatformComponent");
                n0xFFFF_34 = n0xFFFF_5;
              }
              n0xFFFF_6 = n0xFFFF_5;
              v112 = *(_QWORD *)v110(v109, v237, &n0xFFFF_6);
              v206 = v112;
              if ( v112 )
              {
                v113 = v112 & 0xFFFFFFFFFFFFLL;
                v114 = sub_1403B84E0(v112 & 0xFFFFFFFFFFFFLL);
                n4_1 = *(_WORD *)(v114 + 4);
                if ( n4_1 != 4
                  && *(_WORD *)(v114 + 2) == (HIWORD(v112) & 0xFFF)
                  && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14276AAE0(&v206)) )
                {
                  if ( v113 )
                  {
                    v248 = *(_OWORD *)(v14 + 0x1D);
                    if ( !(unsigned __int8)sub_143AB93A0(v113, &v248, v107) )
                    {
LABEL_209:
                      sub_140373CC0(&v200);
                      sub_140373CC0(v198);
                      sub_140373CC0(&v186);
                      sub_140375A30(&v183);
                      if ( *((_QWORD *)&v176 + 1) )
                        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v176 + 1) + 0x28LL))(*((_QWORD *)&v176 + 1));
                      if ( (_QWORD)v176 )
                        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v176 + 0x28LL))(v176);
                      v120 = *((_QWORD *)&v175 + 1);
                      if ( *((_QWORD *)&v175 + 1)
                        && _InterlockedExchangeAdd(
                             (volatile signed __int32 *)(*((_QWORD *)&v175 + 1) + 0xCLL),
                             0xFFFFFFFF) == 1 )
                      {
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v120 + 8LL))(v120);
                      }
                      v121 = *((_QWORD *)&v173 + 1);
                      if ( *((_QWORD *)&v173 + 1) )
                      {
                        v122 = v174;
                        if ( *((_QWORD *)&v173 + 1) != (_QWORD)v174 )
                        {
                          v123 = *((_QWORD *)&v173 + 1) + 8LL;
                          do
                          {
                            if ( *(_QWORD *)v123 )
                              (*(void (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)v123 + 8LL) + 0x10LL))(*(_QWORD *)v123 + 8LL);
                            *(_QWORD *)v123 = 0;
                            v123 += 0x20;
                          }
                          while ( v123 - 8 != v122 );
                          goto LABEL_254;
                        }
LABEL_255:
                        v132 = v121;
                        if ( ((*((_QWORD *)&v174 + 1) - v121) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
                        {
                          v121 = *(_QWORD *)(v121 - 8);
                          if ( (unsigned __int64)(v132 - v121 - 8) > 0x1F )
                            goto LABEL_268;
                        }
                        sub_1402A6590(v121);
                        v174 = 0;
                        *((_QWORD *)&v173 + 1) = 0;
                      }
LABEL_258:
                      v133 = (volatile signed __int32 *)*((_QWORD *)&v149 + 1);
                      if ( *((_QWORD *)&v149 + 1) )
                      {
                        if ( _InterlockedExchangeAdd(
                               (volatile signed __int32 *)(*((_QWORD *)&v149 + 1) + 8LL),
                               0xFFFFFFFF) == 1 )
                        {
                          (**(void (__fastcall ***)(volatile signed __int32 *))v133)(v133);
                          if ( _InterlockedExchangeAdd(v133 + 3, 0xFFFFFFFF) == 1 )
                            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v133 + 8LL))(v133);
                        }
                      }
                      goto LABEL_262;
                    }
                  }
                }
              }
            }
            else
            {
              v206 = 0;
            }
          }
          ++v155;
          v116 = *(void (__fastcall **)(__int64))v221;
          if ( *(_QWORD *)v221 )
          {
            if ( *(_QWORD *)(v221 + 8) == 1 )
              v116(v107);
            else
              ((void (__fastcall *)(__int64, __int64))v116)(v221, v107);
          }
          DWORD2(v211) = *((_DWORD *)v14 + 0x37);
          v117 = *((_QWORD *)&src + 1);
          *(_QWORD *)&v211 = v107;
          HIDWORD(v211) = v106;
          LOBYTE(v212) = 1;
          if ( *((_QWORD *)&src + 1) == v169 )
          {
            sub_144CAB4B0(&src, *((_QWORD *)&src + 1), &v211);
          }
          else
          {
            v118 = v212;
            *((_QWORD *)&src + 1) += 0x18LL;
            *(_OWORD *)v117 = v211;
            *(double *)(v117 + 0x10) = v118;
          }
          sub_144EB8930(a1, (__int64)v151, v147);
          v119 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0xD0LL);
          v220 = v151;
          v151 = 0;
          v119(qword_149C8DFC0, &v220);
          goto LABEL_209;
        }
        sub_1405BD1A0(&v167);
        v28 = !sub_1403C3450(v14);
        _NO_CLASS_SPECIFIED_2 = "<NO CLASS SPECIFIED>";
        if ( v28 )
          _NO_CLASS_SPECIFIED_2 = (const char *)*v14;
        sub_144E93A80(
          a1,
          v147,
          0,
          "!DESIGN BUG: Failed to spawn %s - couldn't find vehicle params, could be missing Vehicle Definition in Vehicle component",
          _NO_CLASS_SPECIFIED_2);
        sub_140373CC0(&v200);
        sub_140373CC0(v198);
        sub_140373CC0(&v186);
        sub_140375A30(&v183);
        if ( *((_QWORD *)&v176 + 1) )
          (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v176 + 1) + 0x28LL))(*((_QWORD *)&v176 + 1));
        if ( (_QWORD)v176 )
          (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v176 + 0x28LL))(v176);
        v80 = *((_QWORD *)&v175 + 1);
        if ( *((_QWORD *)&v175 + 1)
          && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v175 + 1) + 0xCLL), 0xFFFFFFFF) == 1 )
        {
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v80 + 8LL))(v80);
        }
        v57 = *((_QWORD *)&v173 + 1);
        if ( !*((_QWORD *)&v173 + 1) )
          goto LABEL_81;
        v81 = v174;
        if ( *((_QWORD *)&v173 + 1) != (_QWORD)v174 )
        {
          v82 = *((_QWORD *)&v173 + 1) + 8LL;
          do
          {
            if ( *(_QWORD *)v82 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)v82 + 8LL) + 0x10LL))(*(_QWORD *)v82 + 8LL);
            *(_QWORD *)v82 = 0;
            v82 += 0x20;
          }
          while ( v82 - 8 != v81 );
          v57 = *((_QWORD *)&v173 + 1);
        }
        v83 = v57;
        if ( ((*((_QWORD *)&v174 + 1) - v57) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
        {
          v57 = *(_QWORD *)(v57 - 8);
          if ( (unsigned __int64)(v83 - v57 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
      }
      else
      {
        v28 = !sub_1403C3450(v14);
        _NO_CLASS_SPECIFIED_3 = "<NO CLASS SPECIFIED>";
        if ( v28 )
          _NO_CLASS_SPECIFIED_3 = (const char *)*v14;
        sub_144E93A80(
          a1,
          v147,
          0,
          "!DESIGN BUG: Failed to spawn %s - ship has a size smaller then 10 centimeter (we really doubt we're going to h"
          "ave ships smaller)!",
          _NO_CLASS_SPECIFIED_3);
        sub_140373CC0(&v200);
        sub_140373CC0(v198);
        sub_140373CC0(&v186);
        sub_140375A30(&v183);
        if ( *((_QWORD *)&v176 + 1) )
          (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v176 + 1) + 0x28LL))(*((_QWORD *)&v176 + 1));
        if ( (_QWORD)v176 )
          (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v176 + 0x28LL))(v176);
        v62 = *((_QWORD *)&v175 + 1);
        if ( *((_QWORD *)&v175 + 1)
          && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v175 + 1) + 0xCLL), 0xFFFFFFFF) == 1 )
        {
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v62 + 8LL))(v62);
        }
        v57 = *((_QWORD *)&v173 + 1);
        if ( !*((_QWORD *)&v173 + 1) )
          goto LABEL_81;
        v63 = v174;
        if ( *((_QWORD *)&v173 + 1) != (_QWORD)v174 )
        {
          v64 = *((_QWORD *)&v173 + 1) + 8LL;
          do
          {
            if ( *(_QWORD *)v64 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)v64 + 8LL) + 0x10LL))(*(_QWORD *)v64 + 8LL);
            *(_QWORD *)v64 = 0;
            v64 += 0x20;
          }
          while ( v64 - 8 != v63 );
          v57 = *((_QWORD *)&v173 + 1);
        }
        v65 = v57;
        if ( ((*((_QWORD *)&v174 + 1) - v57) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
        {
          v57 = *(_QWORD *)(v57 - 8);
          if ( (unsigned __int64)(v65 - v57 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
      }
    }
    else
    {
      v28 = !sub_1403C3450(v14);
      _NO_CLASS_SPECIFIED_4 = "<NO CLASS SPECIFIED>";
      if ( v28 )
        _NO_CLASS_SPECIFIED_4 = (const char *)*v14;
      sub_144E93A80(
        a1,
        v147,
        0,
        "!DESIGN BUG: Failed to spawn %s - vehicle class has an invalid landing platform size!",
        _NO_CLASS_SPECIFIED_4);
      sub_140373CC0(&v200);
      sub_140373CC0(v198);
      sub_140373CC0(&v186);
      sub_140375A30(&v183);
      if ( *((_QWORD *)&v176 + 1) )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v176 + 1) + 0x28LL))(*((_QWORD *)&v176 + 1));
      if ( (_QWORD)v176 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v176 + 0x28LL))(v176);
      v56 = *((_QWORD *)&v175 + 1);
      if ( *((_QWORD *)&v175 + 1)
        && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v175 + 1) + 0xCLL), 0xFFFFFFFF) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v56 + 8LL))(v56);
      }
      v57 = *((_QWORD *)&v173 + 1);
      if ( !*((_QWORD *)&v173 + 1) )
        goto LABEL_81;
      v58 = v174;
      if ( *((_QWORD *)&v173 + 1) != (_QWORD)v174 )
      {
        v59 = *((_QWORD *)&v173 + 1) + 8LL;
        do
        {
          if ( *(_QWORD *)v59 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)v59 + 8LL) + 0x10LL))(*(_QWORD *)v59 + 8LL);
          *(_QWORD *)v59 = 0;
          v59 += 0x20;
        }
        while ( v59 - 8 != v58 );
        v57 = *((_QWORD *)&v173 + 1);
      }
      v60 = v57;
      if ( ((*((_QWORD *)&v174 + 1) - v57) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
      {
        v57 = *(_QWORD *)(v57 - 8);
        if ( (unsigned __int64)(v60 - v57 - 8) > 0x1F )
LABEL_268:
          invalid_parameter_noinfo_noreturn();
      }
    }
    sub_1402A6590(v57);
    v174 = 0;
    *((_QWORD *)&v173 + 1) = 0;
LABEL_81:
    if ( *((_QWORD *)&v149 + 1) )
      std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v149 + 1));
    goto LABEL_262;
  }
LABEL_270:
  v134 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v135 = v170;
  v228 = 1;
  v225 = (__int64 **)(a1 + 0x2A8);
  v226 = a1 + 0x2B8;
  if ( v15 != v134 / 0x170 )
    v135 = 0;
  v227 = &v228;
  v170 = v135;
  v136 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x2C8) == v136 )
  {
    ++*(_DWORD *)(a1 + 0x2CC);
  }
  else
  {
    v137 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v138 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0x2B8), 0x200000, 0);
    if ( v138 )
      sub_1403E1120(a1 + 0x2B8, v138, v137, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(a1 + 0x2C0) = v137;
    v135 = v170;
    *(_DWORD *)(a1 + 0x2C8) = v136;
  }
  Parameter = sub_144D29930(&v225, (unsigned int *)&v147);
  if ( (__int128 *)Parameter != &src )
    sub_14291FD30((Parameter *)Parameter, (char *)src, (*((_QWORD *)&src + 1) - (_QWORD)src) / 0x18LL);
  *(_BYTE *)(Parameter + 0x18) = v135;
  v28 = (*v227)-- == 1;
  if ( v28 )
  {
    v140 = v226;
    v141 = *(_DWORD *)(v226 + 0x14);
    if ( v141 )
    {
      *(_DWORD *)(v226 + 0x14) = v141 - 1;
    }
    else
    {
      *(_DWORD *)(v226 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v140, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v140 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v140, n0x200000);
    }
  }
  v143 = v147;
  sub_142934F00((__int64)&src);
  return v143;
}

// --- End Function: sub_144ECC050 (0x144ECC050) ---

// --- Function: sub_144ED3030 (0x144ED3030) ---
unsigned __int64 __fastcall sub_144ED3030(__int64 a1)
{
  __int128 v1; // xmm6
  __int64 v2; // r13
  int v3; // r15d
  __int64 *_Wherenode_3; // rdx
  __int64 _Wherenode; // rbx
  int n4; // eax
  int v9; // ecx
  int v10; // ecx
  __int64 *v11; // rcx
  unsigned __int64 v12; // rdi
  int v13; // eax
  bool v14; // al
  __int64 *v15; // rbx
  __int64 *_Wherenode_7; // rax
  __int64 _Wherenode_4; // rbx
  int n5; // eax
  __int64 v19; // rcx
  __int64 *v20; // rbx
  __int64 v21; // rcx
  int v22; // eax
  unsigned __int32 v23; // eax
  __int64 v24; // rsi
  _QWORD *v25; // rax
  _QWORD *_Wherenode_8; // rbx
  int v27; // ecx
  unsigned int v28; // edi
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rax
  __int64 v31; // rdi
  bool v32; // al
  AK::WriteBytesMem *v33; // rdi
  int v34; // r14d
  int n2; // eax
  Error **p_Fail; // rcx
  int *ThreadLogContextSlot; // rax
  int v38; // eax
  int n2_1; // eax
  Error **p_Fail_1; // rcx
  __int64 Parameter__4; // r14
  __int64 Parameter__5; // r15
  int v43; // eax
  unsigned __int32 v44; // eax
  int v45; // eax
  unsigned __int32 v46; // eax
  __int64 Parameter__1; // rdi
  __int64 Parameter__2; // r14
  __int64 *_Wherenode_9; // rdi
  _QWORD *_Wherenode_15; // rax
  __int64 *_Wherenode_16; // rcx
  __int64 *v52; // rax
  __int64 **v53; // rax
  __int64 _Wherenode_13; // rax
  __int64 *_Wherenode_14; // rcx
  int v56; // eax
  unsigned __int32 v57; // eax
  int v58; // edi
  __int64 v59; // r8
  unsigned __int64 v60; // rax
  __int64 *_Wherenode_10; // rdi
  __int64 v62; // rsi
  int v63; // ebx
  unsigned int v64; // eax
  __int64 v65; // rax
  int v66; // ecx
  __int64 v67; // rbx
  __int64 v68; // r14
  unsigned __int32 v69; // eax
  __int64 v70; // rax
  __int64 v71; // rcx
  volatile signed __int32 *v72; // rbx
  int v73; // r14d
  unsigned int v74; // eax
  int v75; // eax
  unsigned __int32 v76; // eax
  __int64 v77; // r15
  __int64 i; // r12
  int v79; // ebx
  __int64 v80; // r13
  __int64 v81; // r14
  __int64 *v82; // rcx
  __int64 *_Wherenode_11; // rbx
  __int64 *_Wherenode_19; // rax
  __int64 *_Wherenode_20; // rcx
  __int64 *v86; // rdi
  __int64 **v87; // rax
  __int64 *_Wherenode_17; // rax
  __int64 *_Wherenode_18; // rcx
  volatile signed __int32 *v90; // rbx
  int v91; // edi
  unsigned int v92; // eax
  __int64 v93; // r8
  __int64 *_Wherenode_21; // rax
  __int64 *_Wherenode_23; // rdx
  __int64 *_Wherenode_24; // rcx
  __int64 **v97; // r8
  __int64 *_Wherenode_12; // rdx
  __int64 *_Wherenode_22; // rcx
  __int64 *j; // r8
  __int64 *v101; // rax
  __int64 v102; // rcx
  __int64 v103; // r8
  int v104; // eax
  bool v105; // zf
  __int64 v106; // rcx
  int v107; // eax
  unsigned __int32 v108; // eax
  unsigned __int64 n0x200000; // rax
  unsigned __int64 n0x200000_1; // rax
  __int64 v111; // rcx
  int v112; // eax
  unsigned int v113; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v114; // [rsp+68h] [rbp-98h] BYREF
  __int64 _Wherenode_2; // [rsp+70h] [rbp-90h] BYREF
  __int64 _Wherenode_6; // [rsp+78h] [rbp-88h] BYREF
  _DWORD v117[2]; // [rsp+80h] [rbp-80h] BYREF
  _DWORD v118[2]; // [rsp+88h] [rbp-78h] BYREF
  __int64 _Wherenode_1; // [rsp+90h] [rbp-70h] BYREF
  __int64 _Wherenode_5; // [rsp+98h] [rbp-68h] BYREF
  __int128 Parameter_; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v122; // [rsp+B0h] [rbp-50h]
  _DWORD v123[4]; // [rsp+C0h] [rbp-40h] BYREF
  unsigned __int64 v124; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v125; // [rsp+D8h] [rbp-28h]
  __int64 v126; // [rsp+E0h] [rbp-20h]
  __int64 v127; // [rsp+E8h] [rbp-18h]
  __int128 Parameter__3; // [rsp+110h] [rbp+10h] BYREF
  __int64 v129; // [rsp+120h] [rbp+20h]
  wchar_t *v130; // [rsp+128h] [rbp+28h] BYREF
  int v131; // [rsp+130h] [rbp+30h]
  __int64 ***v132; // [rsp+138h] [rbp+38h]
  __int64 v133; // [rsp+140h] [rbp+40h]
  int *v134; // [rsp+148h] [rbp+48h]
  int v135; // [rsp+150h] [rbp+50h] BYREF
  __int64 v136; // [rsp+158h] [rbp+58h] BYREF
  _QWORD v137[2]; // [rsp+160h] [rbp+60h] BYREF
  __int64 v138; // [rsp+170h] [rbp+70h]
  _QWORD v139[2]; // [rsp+178h] [rbp+78h] BYREF
  __int64 v140; // [rsp+188h] [rbp+88h]
  _QWORD v141[2]; // [rsp+190h] [rbp+90h] BYREF
  _QWORD v142[2]; // [rsp+1A0h] [rbp+A0h] BYREF
  __int64 **v143; // [rsp+1B0h] [rbp+B0h] BYREF
  __int64 v144; // [rsp+1B8h] [rbp+B8h]
  _DWORD *n0x200000_2; // [rsp+1C0h] [rbp+C0h]
  _OWORD v146[6]; // [rsp+1D0h] [rbp+D0h] BYREF
  unsigned __int8 v148; // [rsp+248h] [rbp+148h] BYREF
  char v149; // [rsp+250h] [rbp+150h] BYREF
  int v150; // [rsp+258h] [rbp+158h]

  v2 = a1;
  v146[1] = v1;
  v3 = *(_DWORD *)(n29 + 0x1274);
  v150 = v3;
  sub_1402E6690(a1 + 0x438, (__int64)&v143);
  _Wherenode_3 = *v143;
  _Wherenode = **v143;
  _Wherenode_2 = _Wherenode;
  if ( (__int64 *)_Wherenode != _Wherenode_3 )
  {
    do
    {
      v123[0] = 0x5C00;
      *(_QWORD *)&v123[1] = 1;
      v123[3] = 0;
      v125 = 0;
      v126 = 0;
      v127 = 0;
      v124 = __rdtsc();
      qword_149C89AA0(
        v123,
        &word_149F88DC4,
        "CSpawnHelperQuantum::Update",
        "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AI/Spawning/SpawnHelperQuantum.cpp",
        0x142);
      HIWORD(v123[0]) = word_149F88DC4;
      n4 = *(_DWORD *)(_Wherenode + 0x7C);
      if ( n4 != 2 )
      {
        if ( n4 == 4 )
        {
          _XMM0 = 0;
          __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rbx+2E0h] }
          v136 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                              qword_149C8DF80,
                              0);
          if ( *(double *)&_XMM0 != 0.0 && sub_14059CAE0((_QWORD *)(_Wherenode + 0x2E0), &v136) )
          {
            sub_144E58F40(_Wherenode + 0x28);
            *(_QWORD *)(_Wherenode + 0x2E0) = 0;
          }
        }
        goto LABEL_12;
      }
      v9 = AK::WriteBytesMem::Size((AK::WriteBytesMem *)(_Wherenode + 0x80));
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          if ( (unsigned int)(v10 - 1) > 1 )
            goto LABEL_12;
          v11 = (__int64 *)(_Wherenode + 0x28);
LABEL_11:
          *(_DWORD *)(_Wherenode + 0x7C) = 7;
          sub_144E58F40((__int64)v11);
          goto LABEL_12;
        }
        v12 = (*(_QWORD *)(_Wherenode + 0x2A8) - *(_QWORD *)(_Wherenode + 0x2A0)) / 0x170LL;
        v13 = sub_1404C0350(_Wherenode + 0x80);
        v11 = (__int64 *)(_Wherenode + 0x28);
        if ( v13 < v12 )
          goto LABEL_11;
        v14 = sub_144D89CC0(v11);
        v11 = (__int64 *)(_Wherenode + 0x28);
        if ( !v14 )
          goto LABEL_11;
        sub_144E78CA0((__int64)v11);
      }
LABEL_12:
      v125 = __rdtsc();
      qword_149C89AA8(v123);
      if ( *(_DWORD *)(_Wherenode + 0x7C) == 6
        || *(_DWORD *)(_Wherenode + 0x7C) == 7
        || (unsigned int)(*(_DWORD *)(_Wherenode + 0x7C) - 8) < 2 )
      {
        _Wherenode_1 = _Wherenode;
        std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string>>>>>,std::_Iterator_base0>::operator++((std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *)&_Wherenode_1);
        v15 = sub_1402E2560((std::_Tree_val<std::_Tree_simple_types<int> > *)v143, (__int64 *)_Wherenode);
        sub_144D1D2F0((__int64)(v15 + 5));
        sub_1402A6590((__int64)v15);
        _Wherenode = _Wherenode_1;
        _Wherenode_2 = _Wherenode_1;
      }
      else
      {
        std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string>>>>>,std::_Iterator_base0>::operator++((std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *)&_Wherenode_2);
        _Wherenode = _Wherenode_2;
      }
    }
    while ( (__int64 *)_Wherenode != *v143 );
  }
  sub_1402CF910(v2 + 0x360, (__int64)"CSpawningManager::Update", 1);
  _Wherenode_7 = *(__int64 **)(v2 + 0x350);
  _Wherenode_4 = *_Wherenode_7;
  _Wherenode_6 = _Wherenode_4;
  if ( (__int64 *)_Wherenode_4 != _Wherenode_7 )
  {
    do
    {
      n5 = *(_DWORD *)(_Wherenode_4 + 0x30);
      if ( n5 < 5 )
      {
        if ( n5 > 0 )
          *(_DWORD *)(_Wherenode_4 + 0x30) = n5 + 1;
        std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string>>>>>,std::_Iterator_base0>::operator++((std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *)&_Wherenode_6);
        _Wherenode_4 = _Wherenode_6;
      }
      else
      {
        v19 = *(_QWORD *)(_Wherenode_4 + 0x28);
        if ( v19 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x10LL))(v19);
        *(_QWORD *)(_Wherenode_4 + 0x28) = 0;
        _Wherenode_5 = _Wherenode_4;
        std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string>>>>>,std::_Iterator_base0>::operator++((std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *)&_Wherenode_5);
        v20 = sub_1402E2560((std::_Tree_val<std::_Tree_simple_types<int> > *)(v2 + 0x350), (__int64 *)_Wherenode_4);
        v21 = v20[5];
        if ( v21 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v21 + 0x10LL))(v21);
        v20[5] = 0;
        sub_1402A6590((__int64)v20);
        _Wherenode_4 = _Wherenode_5;
        _Wherenode_6 = _Wherenode_5;
      }
    }
    while ( _Wherenode_4 != *(_QWORD *)(v2 + 0x350) );
  }
  v22 = *(_DWORD *)(v2 + 0x374);
  if ( v22 )
  {
    *(_DWORD *)(v2 + 0x374) = v22 - 1;
  }
  else
  {
    *(_DWORD *)(v2 + 0x370) = 0xFFFFFFFF;
    v23 = _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 0x360), 0, 1);
    if ( v23 == 1 )
      *(_QWORD *)(v2 + 0x368) = &p_Src;
    else
      sub_1403DF590(v2 + 0x360, v23);
  }
  v24 = v2 + 0x310;
  sub_1402CF910(v2 + 0x310, (__int64)"CSpawningManager::Update", 1);
  v25 = *(_QWORD **)(v2 + 0x300);
  _Wherenode_8 = (_QWORD *)*v25;
  if ( (_QWORD *)*v25 != v25 )
  {
    do
    {
      v27 = *((_DWORD *)_Wherenode_8 + 0xA);
      v28 = *((_DWORD *)_Wherenode_8 + 8);
      v113 = v28;
      if ( v27 )
      {
        if ( v27 == 1 )
        {
          v29 = _Wherenode_8[0xF];
          if ( v29 )
          {
            v30 = HIWORD(v29);
            v31 = (v30 & 0xF000) != 0
                ? _Wherenode_8[0xF] & 0xFFFFFF000000LL
                : (_Wherenode_8[0xF] & 0xFFFFFFFFFFFFLL) - 6;
            if ( *(_WORD *)(v31 + 2) == (v30 & 0xFFF) )
            {
              if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v32 = is_thread_privileged_or_bypass_mode()) )
                v32 = 1;
              if ( *(_WORD *)(v31 + 4) == 2 && v32 || sub_140395410(_Wherenode_8 + 0xF) )
              {
                if ( (*((_DWORD *)_Wherenode_8 + 0x2A) || *((_DWORD *)_Wherenode_8 + 0x2B))
                  && ((v33 = (AK::WriteBytesMem *)(_Wherenode_8 + 0x19),
                       (unsigned int)AK::WriteBytesMem::Size((AK::WriteBytesMem *)(_Wherenode_8 + 0x19)) != 1)
                   || (*((_DWORD *)_Wherenode_8 + 0x2A) || *((_DWORD *)_Wherenode_8 + 0x2B))
                   && (v33 = (AK::WriteBytesMem *)(_Wherenode_8 + 0x19),
                       (int)sub_1404C0350((__int64)(_Wherenode_8 + 0x19)) <= 0)) )
                {
                  v117[0] = 0xE3;
                  v141[0] = v117;
                  v117[1] = 0x64;
                  v141[1] = v118;
                  v34 = invokeGlobalCallbackAndMaskStatusBits(
                          7,
                          (__int64)v141,
                          (__int64)"FixupSpawnLocation",
                          "TPS Query $$ - couldn't find valid fixup position for entity $$");
                  if ( (v34 & 0xFFFFF) != 0 )
                  {
                    v139[1] = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(_Wherenode_8[0xF] & 0xFFFFFFFFFFFFLL)
                                                                 + 0x70LL))(_Wherenode_8[0xF] & 0xFFFFFFFFFFFFLL);
                    v139[0] = 0;
                    v140 = 0;
                    if ( *((_DWORD *)_Wherenode_8 + 0x2A) || *((_DWORD *)_Wherenode_8 + 0x2B) )
                      n2 = AK::WriteBytesMem::Size(v33);
                    else
                      n2 = 1;
                    v137[0] = 0;
                    v138 = 0;
                    p_Fail = "Error";
                    if ( n2 == 2 )
                      p_Fail = "Fail";
                    v137[1] = p_Fail;
                    ThreadLogContextSlot = getThreadLogContextSlot();
                    v118[0] = 0xE3;
                    v142[0] = v118;
                    v118[1] = 0x64;
                    v142[1] = &_Wherenode_1;
                    v146[0] = 0;
                    sub_144CCE6A0(
                      7,
                      (__int64)v142,
                      "FixupSpawnLocation",
                      (__int64)"TPS Query $$ - couldn't find valid fixup position for entity $$",
                      1,
                      v34,
                      v146,
                      0,
                      (__int64)ThreadLogContextSlot,
                      v137,
                      v139);
                    sub_1402A6590(v138);
                    sub_1402A6590(v140);
                  }
                }
                else
                {
                  sub_144E7A6C0(v2, (__int64)(_Wherenode_8 + 5));
                }
              }
            }
          }
        }
      }
      else if ( (*((_DWORD *)_Wherenode_8 + 0x2A) || *((_DWORD *)_Wherenode_8 + 0x2B))
             && (v38 = AK::WriteBytesMem::Size((AK::WriteBytesMem *)(_Wherenode_8 + 0x19)), v38 != 1) )
      {
        if ( (unsigned int)(v38 - 2) <= 1 )
        {
          if ( *((_DWORD *)_Wherenode_8 + 0x2A) || *((_DWORD *)_Wherenode_8 + 0x2B) )
            n2_1 = AK::WriteBytesMem::Size((AK::WriteBytesMem *)(_Wherenode_8 + 0x19));
          else
            n2_1 = 1;
          p_Fail_1 = "Error";
          if ( n2_1 == 2 )
            p_Fail_1 = "Fail";
          sub_144E93A80(v2, v28, 0, "TPS Query %s - couldn't find valid spawn position(s)", p_Fail_1);
          sub_1402CF910(v2 + 0x290, (__int64)"CSpawningManager::Update", 1);
          v148 = 0;
          v129 = 0;
          Parameter__3 = 0;
          sub_144C7D760(
            (_QWORD *)(v2 + 0x258),
            (void (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_140B1A1CC,
            &v113,
            (__int64)&Parameter__3,
            &v148);
          Parameter__4 = Parameter__3;
          if ( (_QWORD)Parameter__3 )
          {
            Parameter__5 = *((_QWORD *)&Parameter__3 + 1);
            if ( (_QWORD)Parameter__3 != *((_QWORD *)&Parameter__3 + 1) )
            {
              do
              {
                sub_140375A30((_DWORD *)(Parameter__4 + 8));
                Parameter__4 += 0x10;
              }
              while ( Parameter__4 != Parameter__5 );
              Parameter__4 = Parameter__3;
            }
            unknown_libname_73((__int64)&Parameter__3, Parameter__4, (v129 - Parameter__4) >> 4);
          }
          v43 = *(_DWORD *)(v2 + 0x2A4);
          if ( v43 )
          {
            *(_DWORD *)(v2 + 0x2A4) = v43 - 1;
          }
          else
          {
            *(_DWORD *)(v2 + 0x2A0) = 0xFFFFFFFF;
            v44 = _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 0x290), 0, 1);
            if ( v44 == 1 )
              *(_QWORD *)(v2 + 0x298) = &p_Src;
            else
              sub_1403DF590(v2 + 0x290, v44);
          }
        }
      }
      else
      {
        v122 = 0;
        Parameter_ = 0;
        v149 = sub_144E7A980(v2, v28, (__int64)(_Wherenode_8 + 5), (Parameter *)&Parameter_);
        sub_1402CF910(v2 + 0x290, (__int64)"CSpawningManager::Update", 1);
        sub_144C7D760(
          (_QWORD *)(v2 + 0x258),
          (void (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_140B1A1CC,
          &v113,
          (__int64)&Parameter_,
          (unsigned __int8 *)&v149);
        v45 = *(_DWORD *)(v2 + 0x2A4);
        if ( v45 )
        {
          *(_DWORD *)(v2 + 0x2A4) = v45 - 1;
        }
        else
        {
          *(_DWORD *)(v2 + 0x2A0) = 0xFFFFFFFF;
          v46 = _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 0x290), 0, 1);
          if ( v46 == 1 )
            *(_QWORD *)(v2 + 0x298) = &p_Src;
          else
            sub_1403DF590(v2 + 0x290, v46);
        }
        Parameter__1 = Parameter_;
        if ( (_QWORD)Parameter_ )
        {
          Parameter__2 = *((_QWORD *)&Parameter_ + 1);
          if ( (_QWORD)Parameter_ != *((_QWORD *)&Parameter_ + 1) )
          {
            do
            {
              sub_140375A30((_DWORD *)(Parameter__1 + 8));
              Parameter__1 += 0x10;
            }
            while ( Parameter__1 != Parameter__2 );
            Parameter__1 = Parameter_;
          }
          unknown_libname_73((__int64)&Parameter_, Parameter__1, (v122 - Parameter__1) >> 4);
        }
      }
      if ( (*((_DWORD *)_Wherenode_8 + 0x2A) || *((_DWORD *)_Wherenode_8 + 0x2B))
        && !(unsigned int)AK::WriteBytesMem::Size((AK::WriteBytesMem *)(_Wherenode_8 + 0x19)) )
      {
        v53 = (__int64 **)_Wherenode_8[2];
        if ( *((_BYTE *)v53 + 0x19) )
        {
          for ( _Wherenode_13 = _Wherenode_8[1];
                !*(_BYTE *)(_Wherenode_13 + 0x19);
                _Wherenode_13 = *(_QWORD *)(_Wherenode_13 + 8) )
          {
            if ( _Wherenode_8 != *(_QWORD **)(_Wherenode_13 + 0x10) )
              break;
            _Wherenode_8 = (_QWORD *)_Wherenode_13;
          }
          _Wherenode_8 = (_QWORD *)_Wherenode_13;
        }
        else
        {
          _Wherenode_14 = *v53;
          for ( _Wherenode_8 = (_QWORD *)_Wherenode_8[2];
                !*((_BYTE *)_Wherenode_14 + 0x19);
                _Wherenode_14 = (__int64 *)*_Wherenode_14 )
          {
            _Wherenode_8 = _Wherenode_14;
          }
        }
      }
      else
      {
        _Wherenode_9 = (__int64 *)_Wherenode_8[2];
        _Wherenode_15 = _Wherenode_8;
        if ( *((_BYTE *)_Wherenode_9 + 0x19) )
        {
          for ( _Wherenode_9 = (__int64 *)_Wherenode_8[1];
                !*((_BYTE *)_Wherenode_9 + 0x19);
                _Wherenode_9 = (__int64 *)_Wherenode_9[1] )
          {
            if ( _Wherenode_15 != (_QWORD *)_Wherenode_9[2] )
              break;
            _Wherenode_15 = _Wherenode_9;
          }
        }
        else
        {
          _Wherenode_16 = (__int64 *)*_Wherenode_9;
          if ( !*(_BYTE *)(*_Wherenode_9 + 0x19) )
          {
            do
            {
              _Wherenode_9 = _Wherenode_16;
              _Wherenode_16 = (__int64 *)*_Wherenode_16;
            }
            while ( !*((_BYTE *)_Wherenode_16 + 0x19) );
          }
        }
        v52 = sub_1402E2560((std::_Tree_val<std::_Tree_simple_types<int> > *)(v2 + 0x300), _Wherenode_8);
        sub_144CAD040(v2 + 0x300, (__int64)v52);
        _Wherenode_8 = _Wherenode_9;
      }
    }
    while ( _Wherenode_8 != *(_QWORD **)(v2 + 0x300) );
    v3 = v150;
    v24 = v2 + 0x310;
  }
  v56 = *(_DWORD *)(v24 + 0x14);
  if ( v56 )
  {
    *(_DWORD *)(v24 + 0x14) = v56 - 1;
  }
  else
  {
    *(_DWORD *)(v24 + 0x10) = 0xFFFFFFFF;
    v57 = _InterlockedCompareExchange((volatile signed __int32 *)v24, 0, 1);
    if ( v57 == 1 )
      *(_QWORD *)(v24 + 8) = &p_Src;
    else
      sub_1403DF590(v24, v57);
  }
  v132 = (__int64 ***)(v2 + 0x2A8);
  v133 = v2 + 0x2B8;
  v134 = &v135;
  v135 = 1;
  v58 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x2C8) == v58 )
  {
    ++*(_DWORD *)(v2 + 0x2CC);
  }
  else
  {
    v59 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v60 = _InterlockedCompareExchange64((volatile signed __int64 *)(v2 + 0x2B8), 0x200000, 0);
    if ( v60 )
      sub_1403E1120(v2 + 0x2B8, v60, v59, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(v2 + 0x2C0) = v59;
    *(_DWORD *)(v2 + 0x2C8) = v58;
  }
  _Wherenode_10 = **v132;
  if ( _Wherenode_10 != (__int64 *)*v132 )
  {
    v62 = v2 + 0x2E8;
    do
    {
      v63 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
      if ( *(_DWORD *)(v62 + 0x10) == v63 )
      {
        ++*(_DWORD *)(v62 + 0x14);
      }
      else
      {
        v64 = _InterlockedCompareExchange((volatile signed __int32 *)v62, 1, 0);
        if ( v64 )
          sub_1403C6E80(v62, v64, (__int64)"CSpawningManager::Update", 1);
        else
          *(_QWORD *)(v62 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
        *(_DWORD *)(v62 + 0x10) = v63;
      }
      v65 = unknown_libname_249(*(_QWORD *)(v2 + 0x2D0), *(_QWORD *)(v2 + 0x2D8), *((unsigned int *)_Wherenode_10 + 8));
      v66 = *(_DWORD *)(v62 + 0x14);
      v67 = v65;
      v68 = *(_QWORD *)(v2 + 0x2D8);
      if ( v66 )
      {
        *(_DWORD *)(v62 + 0x14) = v66 - 1;
      }
      else
      {
        *(_DWORD *)(v62 + 0x10) = 0xFFFFFFFF;
        v69 = _InterlockedCompareExchange((volatile signed __int32 *)v62, 0, 1);
        if ( v69 == 1 )
          *(_QWORD *)(v62 + 8) = &p_Src;
        else
          sub_1403DF590(v62, v69);
      }
      if ( v3 )
      {
        if ( v67 != v68 )
          goto LABEL_169;
        v70 = _Wherenode_10[5];
        v71 = _Wherenode_10[6];
        if ( v70 != v71 )
        {
          while ( !*(_BYTE *)(v70 + 0x10) )
          {
            v70 += 0x18;
            if ( v70 == v71 )
              goto LABEL_147;
          }
LABEL_169:
          v87 = (__int64 **)_Wherenode_10[2];
          if ( *((_BYTE *)v87 + 0x19) )
          {
            for ( _Wherenode_17 = (__int64 *)_Wherenode_10[1];
                  !*((_BYTE *)_Wherenode_17 + 0x19);
                  _Wherenode_17 = (__int64 *)_Wherenode_17[1] )
            {
              if ( _Wherenode_10 != (__int64 *)_Wherenode_17[2] )
                break;
              _Wherenode_10 = _Wherenode_17;
            }
            _Wherenode_10 = _Wherenode_17;
          }
          else
          {
            _Wherenode_18 = *v87;
            for ( _Wherenode_10 = (__int64 *)_Wherenode_10[2];
                  !*((_BYTE *)_Wherenode_18 + 0x19);
                  _Wherenode_18 = (__int64 *)*_Wherenode_18 )
            {
              _Wherenode_10 = _Wherenode_18;
            }
          }
          continue;
        }
      }
      else if ( v67 != v68 )
      {
        goto LABEL_169;
      }
LABEL_147:
      v72 = (volatile signed __int32 *)(v2 + 0x290);
      v114 = *((_DWORD *)_Wherenode_10 + 8);
      v73 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
      if ( *(_DWORD *)(v2 + 0x2A0) == v73 )
      {
        ++*(_DWORD *)(v2 + 0x2A4);
      }
      else
      {
        v74 = _InterlockedCompareExchange(v72, 1, 0);
        if ( v74 )
          sub_1403C6E80(v2 + 0x290, v74, (__int64)"CSpawningManager::NotifyListeners", 1);
        else
          *(_QWORD *)(v2 + 0x298) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
        *(_DWORD *)(v2 + 0x2A0) = v73;
      }
      sub_144C7D760(
        (_QWORD *)(v2 + 0x258),
        (void (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_140387F04,
        &v114,
        (__int64)(_Wherenode_10 + 5),
        (unsigned __int8 *)_Wherenode_10 + 0x40);
      v75 = *(_DWORD *)(v2 + 0x2A4);
      if ( v75 )
      {
        *(_DWORD *)(v2 + 0x2A4) = v75 - 1;
      }
      else
      {
        *(_DWORD *)(v2 + 0x2A0) = 0xFFFFFFFF;
        v76 = _InterlockedCompareExchange(v72, 0, 1);
        if ( v76 == 1 )
          *(_QWORD *)(v2 + 0x298) = &p_Src;
        else
          sub_1403DF590(v2 + 0x290, v76);
      }
      v77 = _Wherenode_10[5];
      for ( i = _Wherenode_10[6]; v77 != i; *v82 = v81 )
      {
        v79 = *(_DWORD *)(v77 + 0xC);
        sub_14059BE10(&v130);
        v131 = v79;
        sub_14059C4A0(&v130, 60.0, 0.0);
        v80 = *(_QWORD *)(v2 + 0x220);
        if ( *(_QWORD *)(a1 + 0x228) == 0x7FFFFFFFFFFFFFFLL )
          std::_Xlength_error("list too long");
        v81 = sub_1402A65A0(0x20u);
        _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
          (_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *)(v81 + 0x10),
          (const wchar_t **)&v130);
        v77 += 0x18;
        *(_DWORD *)(v81 + 0x18) = v131;
        ++*(_QWORD *)(a1 + 0x228);
        v82 = *(__int64 **)(v80 + 8);
        *(_QWORD *)v81 = v80;
        *(_QWORD *)(v81 + 8) = v82;
        *(_QWORD *)(v80 + 8) = v81;
        v2 = a1;
      }
      _Wherenode_11 = (__int64 *)_Wherenode_10[2];
      _Wherenode_19 = _Wherenode_10;
      if ( *((_BYTE *)_Wherenode_11 + 0x19) )
      {
        for ( _Wherenode_11 = (__int64 *)_Wherenode_10[1];
              !*((_BYTE *)_Wherenode_11 + 0x19);
              _Wherenode_11 = (__int64 *)_Wherenode_11[1] )
        {
          if ( _Wherenode_19 != (__int64 *)_Wherenode_11[2] )
            break;
          _Wherenode_19 = _Wherenode_11;
        }
      }
      else
      {
        _Wherenode_20 = (__int64 *)*_Wherenode_11;
        if ( !*(_BYTE *)(*_Wherenode_11 + 0x19) )
        {
          do
          {
            _Wherenode_11 = _Wherenode_20;
            _Wherenode_20 = (__int64 *)*_Wherenode_20;
          }
          while ( !*((_BYTE *)_Wherenode_20 + 0x19) );
        }
      }
      v86 = sub_1402E2560((std::_Tree_val<std::_Tree_simple_types<int> > *)v132, _Wherenode_10);
      sub_142934F00((__int64)(v86 + 5));
      sub_1402A6590((__int64)v86);
      v3 = v150;
      _Wherenode_10 = _Wherenode_11;
    }
    while ( _Wherenode_10 != (__int64 *)*v132 );
  }
  if ( *(_QWORD *)(v2 + 0x228) && sub_14059BF00(**(_QWORD **)(v2 + 0x220) + 0x10LL) )
  {
    v90 = (volatile signed __int32 *)(v2 + 0x240);
    v91 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v2 + 0x250) == v91 )
    {
      ++*(_DWORD *)(v2 + 0x254);
    }
    else
    {
      v92 = _InterlockedCompareExchange(v90, 1, 0);
      if ( v92 )
        sub_1403C6E80(v2 + 0x240, v92, (__int64)"CSpawningManager::Update", 1);
      else
        *(_QWORD *)(v2 + 0x248) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v2 + 0x250) = v91;
    }
    v93 = **(_QWORD **)(v2 + 0x220);
    _Wherenode_21 = *(__int64 **)(v2 + 0x230);
    _Wherenode_23 = _Wherenode_21;
    _Wherenode_24 = (__int64 *)_Wherenode_21[1];
    if ( !*((_BYTE *)_Wherenode_24 + 0x19) )
    {
      do
      {
        if ( *((_DWORD *)_Wherenode_24 + 8) >= *(_DWORD *)(v93 + 0x18) )
        {
          _Wherenode_21 = _Wherenode_24;
          _Wherenode_24 = (__int64 *)*_Wherenode_24;
        }
        else
        {
          _Wherenode_24 = (__int64 *)_Wherenode_24[2];
        }
      }
      while ( !*((_BYTE *)_Wherenode_24 + 0x19) );
      _Wherenode_23 = *(__int64 **)(v2 + 0x230);
    }
    if ( !*((_BYTE *)_Wherenode_21 + 0x19)
      && *(_DWORD *)(v93 + 0x18) >= *((_DWORD *)_Wherenode_21 + 8)
      && _Wherenode_21 != _Wherenode_23 )
    {
      v97 = (__int64 **)_Wherenode_21[2];
      _Wherenode_12 = _Wherenode_21;
      if ( *((_BYTE *)v97 + 0x19) )
      {
        for ( _Wherenode_22 = (__int64 *)_Wherenode_21[1];
              !*((_BYTE *)_Wherenode_22 + 0x19);
              _Wherenode_22 = (__int64 *)_Wherenode_22[1] )
        {
          if ( _Wherenode_21 != (__int64 *)_Wherenode_22[2] )
            break;
          _Wherenode_21 = _Wherenode_22;
        }
      }
      else
      {
        for ( j = *v97; !*((_BYTE *)j + 0x19); j = (__int64 *)*j )
          ;
      }
      v101 = sub_1402E2560((std::_Tree_val<std::_Tree_simple_types<int> > *)(v2 + 0x230), _Wherenode_12);
      sub_1402A6590((__int64)v101);
    }
    v102 = **(_QWORD **)(v2 + 0x220);
    v103 = *(_QWORD *)v102;
    --*(_QWORD *)(v2 + 0x228);
    **(_QWORD **)(v102 + 8) = v103;
    *(_QWORD *)(v103 + 8) = *(_QWORD *)(v102 + 8);
    sub_1402A6590(v102);
    v104 = *(_DWORD *)(v2 + 0x254);
    if ( v104 )
    {
      *(_DWORD *)(v2 + 0x254) = v104 - 1;
    }
    else
    {
      *(_DWORD *)(v2 + 0x250) = 0xFFFFFFFF;
      v108 = _InterlockedCompareExchange(v90, 0, 1);
      if ( v108 == 1 )
        *(_QWORD *)(v2 + 0x248) = &p_Src;
      else
        sub_1403DF590(v2 + 0x240, v108);
    }
  }
  sub_144DD2640(v2);
  v105 = (*v134)-- == 1;
  if ( v105 )
  {
    v106 = v133;
    v107 = *(_DWORD *)(v133 + 0x14);
    if ( v107 )
    {
      *(_DWORD *)(v133 + 0x14) = v107 - 1;
    }
    else
    {
      *(_DWORD *)(v133 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v106, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v106 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v106, n0x200000);
    }
  }
  n0x200000_1 = (unsigned __int64)n0x200000_2;
  v105 = (*n0x200000_2)-- == 1;
  if ( v105 )
  {
    v111 = v144;
    v112 = *(_DWORD *)(v144 + 0x14);
    if ( v112 )
    {
      n0x200000_1 = (unsigned int)(v112 - 1);
      *(_DWORD *)(v144 + 0x14) = n0x200000_1;
    }
    else
    {
      *(_DWORD *)(v144 + 0x10) = 0xFFFFFFFF;
      n0x200000_1 = _InterlockedCompareExchange64((volatile signed __int64 *)v111, 0, 0x200000);
      if ( n0x200000_1 == 0x200000 )
        *(_QWORD *)(v111 + 8) = &p_Src;
      else
        return (unsigned __int64)rw_lock_handle_write_release_contention(v111, n0x200000_1);
    }
  }
  return n0x200000_1;
}

// --- End Function: sub_144ED3030 (0x144ED3030) ---

// --- Function: sub_144F08A90 (0x144F08A90) ---
__int64 __fastcall sub_144F08A90(__int64 a1)
{
  unsigned int event_key_from_source_location; // ebx
  void (__fastcall *v3)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)); // rsi
  _QWORD *v4; // rax
  __int64 p_sub_14049D9C0_1; // rax
  __int64 (__fastcall *p_sub_14049CE70)(__int64, __int64); // [rsp+20h] [rbp-28h] BYREF
  void (__fastcall *p_sub_14049D9C0)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+28h] [rbp-20h]
  _QWORD *v8; // [rsp+30h] [rbp-18h]
  __int64 v9; // [rsp+50h] [rbp+8h]

  event_key_from_source_location = event_key_from_source_location_7;
  if ( !event_key_from_source_location_7 )
    event_key_from_source_location = get_event_key_from_source_location(
                                       &event_key_from_source_location_7,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/UI/Events.h",
                                       0x62A);
  HIDWORD(v9) = event_key_from_source_location;
  v3 = *(void (__fastcall **)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)))(*(_QWORD *)a1 + 0x20LL);
  v4 = (_QWORD *)sub_1402A65A0(8u);
  if ( v4 )
  {
    *v4 = v9;
    v8 = v4;
  }
  else
  {
    v8 = 0;
  }
  p_sub_14049CE70 = sub_14049CE70;
  p_sub_14049D9C0 = sub_14049D9C0;
  v3(a1, event_key_from_source_location, &p_sub_14049CE70);
  p_sub_14049D9C0_1 = (__int64)p_sub_14049D9C0;
  if ( (unsigned __int64)p_sub_14049D9C0 >= 2 )
    return ((__int64 (__fastcall *)(__int64, _QWORD))p_sub_14049D9C0)(2, &p_sub_14049CE70);
  return p_sub_14049D9C0_1;
}

// --- End Function: sub_144F08A90 (0x144F08A90) ---

// --- Function: sub_144F09380 (0x144F09380) ---
unsigned __int64 __fastcall sub_144F09380(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  __int64 v7; // rdx
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v13; // rax
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rbp
  __int64 v16; // rdx
  unsigned __int64 v17; // r8
  __int64 v18; // rcx

  v6 = (a2 - *a1) / 0xF8;
  v7 = (a1[1] - *a1) / 0xF8;
  if ( v7 == 0x108421084210842LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0xF8;
  v10 = v9 >> 1;
  if ( v9 > 0x108421084210842LL - (v9 >> 1) )
    goto LABEL_17;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0x108421084210842LL )
    goto LABEL_17;
  allocSize = 0xF8 * v11;
  if ( 0xF8 * v11 < 0x1000 )
  {
    if ( allocSize )
      v14 = sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_14;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_17:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    invalid_parameter_noinfo_noreturn();
  v14 = (v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_14:
  v15 = v14 + 0xF8 * v6;
  sub_144F0B650(v15, a3);
  v16 = a1[1];
  v17 = v14;
  v18 = *a1;
  if ( a2 != v16 )
  {
    sub_144F09630(v18, a2, v14, a1);
    v16 = a1[1];
    v17 = v15 + 0xF8;
    v18 = a2;
  }
  sub_144F09630(v18, v16, v17, a1);
  sub_144F1D490(a1, v14, v8, v11);
  return v15;
}

// --- End Function: sub_144F09380 (0x144F09380) ---

// --- Function: sub_144F09630 (0x144F09630) ---
__int64 __fastcall sub_144F09630(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 i; // rbx

  for ( i = a1; i != a2; i += 0xF8 )
  {
    sub_144F0B650(a3, i);
    a3 += 0xF8;
  }
  sub_144F08D30(a3, a3, a4);
  return a3;
}

// --- End Function: sub_144F09630 (0x144F09630) ---

// --- Function: sub_144F09A10 (0x144F09A10) ---
char __fastcall sub_144F09A10(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10,
        __int64 a11,
        __int64 a12)
{
  void *v16; // rsp
  __int64 v18; // [rsp+18h] [rbp-1D8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-1C0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-168h]
  __int64 n0xB0; // [rsp+90h] [rbp-160h]
  __int64 n0xA8; // [rsp+98h] [rbp-158h]
  _QWORD *v23; // [rsp+A0h] [rbp-150h]
  const char *p_ErrorCode; // [rsp+A8h] [rbp-148h]
  __int64 v25; // [rsp+B0h] [rbp-140h]
  __int64 (__fastcall *p_sub_1403EF3A0)(__int64, __int64, __int64); // [rsp+B8h] [rbp-138h]
  __int64 (__fastcall *p_sub_1403EF3A0_1)(__int64, __int64, __int64); // [rsp+C0h] [rbp-130h]
  __int64 v28; // [rsp+C8h] [rbp-128h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+D0h] [rbp-120h]
  __int64 v30; // [rsp+D8h] [rbp-118h]
  __int64 (__fastcall *p_sub_1403E9240)(__int64); // [rsp+E0h] [rbp-110h]
  _OWORD *(__fastcall *p_sub_1403E8F40)(_OWORD *); // [rsp+E8h] [rbp-108h]
  unsigned __int64 v33; // [rsp+F0h] [rbp-100h]
  char v34; // [rsp+F8h] [rbp-F8h]
  char v35; // [rsp+F9h] [rbp-F7h]
  __int64 n0x10; // [rsp+100h] [rbp-F0h]
  __int64 n0x15; // [rsp+108h] [rbp-E8h]
  __int64 v38; // [rsp+110h] [rbp-E0h] BYREF

  v16 = alloca(0x1C0);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  v23 = a10;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  p_ErrorCode = "ErrorCode";
  v35 = 0;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v25 = *a10;
  p_sub_1403EF3A0 = sub_1403EF3A0;
  p_sub_1403EF3A0_1 = sub_1403EF3A0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E9240 = sub_1403E9240;
  v28 = 0;
  v30 = 0;
  v34 = 0;
  p_sub_1403E8F40 = sub_1403E8F40;
  v33 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x10 = 0x10;
  n0x15 = 0x15;
  sub_144F0A3B0(&v38, a11, a12);
  LODWORD(v18) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 4u, a5, v18, a7, a8);
}

// --- End Function: sub_144F09A10 (0x144F09A10) ---

// --- Function: sub_144F0A3B0 (0x144F0A3B0) ---
__int64 __fastcall sub_144F0A3B0(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 n2; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "ErrorCode";
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF3A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF3A0;
  *(_QWORD *)(a1 + 0x30) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9240;
  *(_QWORD *)(a1 + 0x48) = sub_1403E8F40;
  *(_QWORD *)(a1 + 0x78) = "TraceContext";
  *(_QWORD *)(a1 + 0x88) = sub_1403EF930;
  *(_QWORD *)(a1 + 0x90) = sub_1403EF4D0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403EBBC0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9230;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F30;
  n2 = 2;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x10;
  *(_QWORD *)(a1 + 0x68) = 0x15;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_WORD *)(a1 + 0xC8) = 0x100;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 0xB0;
  *(_QWORD *)(a1 + 0xD8) = 0xA8;
  return n2;
}

// --- End Function: sub_144F0A3B0 (0x144F0A3B0) ---

// --- Function: sub_144F0B650 (0x144F0B650) ---
__int64 __fastcall sub_144F0B650(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  sub_14035DDF0((_QWORD *)(a1 + 8), (__int64 *)(a2 + 8));
  sub_14035E0A0((_QWORD *)(a1 + 0x10), (__int64 *)(a2 + 0x10));
  sub_14035E0A0((_QWORD *)(a1 + 0x18), (__int64 *)(a2 + 0x18));
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x20);
  sub_14035DAD0((_QWORD *)(a1 + 0x28), (_QWORD *)(a2 + 0x28));
  *(_BYTE *)(a1 + 0x40) = *(_BYTE *)(a2 + 0x40);
  result = a1;
  *(_OWORD *)(a1 + 0x41) = *(_OWORD *)(a2 + 0x41);
  *(_OWORD *)(a1 + 0x51) = *(_OWORD *)(a2 + 0x51);
  *(_OWORD *)(a1 + 0x61) = *(_OWORD *)(a2 + 0x61);
  *(_OWORD *)(a1 + 0x71) = *(_OWORD *)(a2 + 0x71);
  *(_OWORD *)(a1 + 0x81) = *(_OWORD *)(a2 + 0x81);
  *(_OWORD *)(a1 + 0x91) = *(_OWORD *)(a2 + 0x91);
  *(_OWORD *)(a1 + 0xA1) = *(_OWORD *)(a2 + 0xA1);
  *(_OWORD *)(a1 + 0xB1) = *(_OWORD *)(a2 + 0xB1);
  *(_OWORD *)(a1 + 0xC1) = *(_OWORD *)(a2 + 0xC1);
  *(_OWORD *)(a1 + 0xD1) = *(_OWORD *)(a2 + 0xD1);
  *(_OWORD *)(a1 + 0xE1) = *(_OWORD *)(a2 + 0xE1);
  return result;
}

// --- End Function: sub_144F0B650 (0x144F0B650) ---

// --- Function: sub_144F0B760 (0x144F0B760) ---
__int64 __fastcall sub_144F0B760(__int64 a1, int a2, const void **a3, int a4, __int64 *a5, _QWORD *a6)
{
  int *ThreadLogContextSlot; // rax

  *(_DWORD *)(a1 + 4) = a2;
  sub_14035E090((_QWORD *)(a1 + 8));
  assignCStringToStringStructure(a1 + 8, *a5);
  sub_14035E2A0((_QWORD *)(a1 + 0x10));
  sub_14035E0C0((void **)(a1 + 0x18), a3);
  *(_DWORD *)(a1 + 0x20) = a4;
  sub_14035DAD0((_QWORD *)(a1 + 0x28), a6);
  *(_BYTE *)(a1 + 0x40) = 0;
  ThreadLogContextSlot = getThreadLogContextSlot();
  *(_OWORD *)(a1 + 0x41) = *(_OWORD *)ThreadLogContextSlot;
  *(_OWORD *)(a1 + 0x51) = *((_OWORD *)ThreadLogContextSlot + 1);
  *(_OWORD *)(a1 + 0x61) = *((_OWORD *)ThreadLogContextSlot + 2);
  *(_OWORD *)(a1 + 0x71) = *((_OWORD *)ThreadLogContextSlot + 3);
  *(_OWORD *)(a1 + 0x81) = *((_OWORD *)ThreadLogContextSlot + 4);
  *(_OWORD *)(a1 + 0x91) = *((_OWORD *)ThreadLogContextSlot + 5);
  *(_OWORD *)(a1 + 0xA1) = *((_OWORD *)ThreadLogContextSlot + 6);
  *(_OWORD *)(a1 + 0xB1) = *((_OWORD *)ThreadLogContextSlot + 7);
  *(_OWORD *)(a1 + 0xC1) = *((_OWORD *)ThreadLogContextSlot + 8);
  *(_OWORD *)(a1 + 0xD1) = *((_OWORD *)ThreadLogContextSlot + 9);
  *(_OWORD *)(a1 + 0xE1) = *((_OWORD *)ThreadLogContextSlot + 0xA);
  return a1;
}

// --- End Function: sub_144F0B760 (0x144F0B760) ---

// --- Function: sub_144F0BD20 (0x144F0BD20) ---
__int64 __fastcall sub_144F0BD20(__int64 a1, __int64 a2)
{
  void (__fastcall *n2)(__int64, __int64, _QWORD); // rax
  void (__fastcall *v5)(__int64, __int64, __int64); // rax
  void (__fastcall *n2_1)(__int64, __int64); // rax
  __int64 result; // rax

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  sub_14037AE80((void **)(a1 + 8), (void **)(a2 + 8));
  sub_14037AF60((__int64 *)(a1 + 0x10), (__int64 *)(a2 + 0x10));
  sub_14037AF60((__int64 *)(a1 + 0x18), (__int64 *)(a2 + 0x18));
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x20);
  n2 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a1 + 0x30);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1 + 0x28, 0);
    *(_QWORD *)(a1 + 0x30) = 0;
  }
  *(_QWORD *)(a1 + 0x28) = 0;
  v5 = *(void (__fastcall **)(__int64, __int64, __int64))(a2 + 0x30);
  if ( v5 == (void (__fastcall *)(__int64, __int64, __int64))1 )
  {
    *(_QWORD *)(a1 + 0x28) = *(_QWORD *)(a2 + 0x28);
    *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  }
  else
  {
    if ( !v5 )
      goto LABEL_10;
    v5(1, a1 + 0x28, a2 + 0x28);
  }
  n2_1 = *(void (__fastcall **)(__int64, __int64))(a2 + 0x30);
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, a2 + 0x28);
    *(_QWORD *)(a2 + 0x30) = 0;
  }
  *(_QWORD *)(a2 + 0x28) = 0;
LABEL_10:
  *(_BYTE *)(a1 + 0x40) = *(_BYTE *)(a2 + 0x40);
  result = a1;
  *(_OWORD *)(a1 + 0x41) = *(_OWORD *)(a2 + 0x41);
  *(_OWORD *)(a1 + 0x51) = *(_OWORD *)(a2 + 0x51);
  *(_OWORD *)(a1 + 0x61) = *(_OWORD *)(a2 + 0x61);
  *(_OWORD *)(a1 + 0x71) = *(_OWORD *)(a2 + 0x71);
  *(_OWORD *)(a1 + 0x81) = *(_OWORD *)(a2 + 0x81);
  *(_OWORD *)(a1 + 0x91) = *(_OWORD *)(a2 + 0x91);
  *(_OWORD *)(a1 + 0xA1) = *(_OWORD *)(a2 + 0xA1);
  *(_OWORD *)(a1 + 0xB1) = *(_OWORD *)(a2 + 0xB1);
  *(_OWORD *)(a1 + 0xC1) = *(_OWORD *)(a2 + 0xC1);
  *(_OWORD *)(a1 + 0xD1) = *(_OWORD *)(a2 + 0xD1);
  *(_OWORD *)(a1 + 0xE1) = *(_OWORD *)(a2 + 0xE1);
  return result;
}

// --- End Function: sub_144F0BD20 (0x144F0BD20) ---

// --- Function: sub_144F0D5E0 (0x144F0D5E0) ---
const ULONG_PTR *__fastcall sub_144F0D5E0(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  int v3; // esi
  unsigned int v4; // eax
  __int64 v5; // rax
  __int64 v6; // rcx
  volatile signed __int32 *v7; // rsi
  int v8; // eax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int32 v10; // eax
  __int64 v11; // [rsp+20h] [rbp-18h] BYREF
  volatile signed __int32 *v12; // [rsp+28h] [rbp-10h]

  v1 = (volatile signed __int32 *)(a1 + 0x380);
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x390) == v3 )
  {
    ++*(_DWORD *)(a1 + 0x394);
  }
  else
  {
    v4 = _InterlockedCompareExchange(v1, 1, 0);
    if ( v4 )
      sub_1403C6E80((__int64)v1, v4, (__int64)"CGlobalGameUI::CloseLoginQueuePopUp", 1);
    else
      *(_QWORD *)(a1 + 0x388) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x390) = v3;
  }
  v5 = *(_QWORD *)(a1 + 0x398);
  if ( v5 != *(_QWORD *)(a1 + 0x3A0) && *(_DWORD *)(v5 + 4) == 1 )
  {
    v6 = *(_QWORD *)(a1 + 0x358);
    if ( v6 )
    {
      sub_143595320(v6, &v11);
      v7 = v12;
      if ( v12 )
      {
        if ( _InterlockedExchangeAdd(v12 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
          if ( _InterlockedExchangeAdd(v7 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8LL))(v7);
        }
      }
    }
  }
  v8 = *(_DWORD *)(a1 + 0x394);
  if ( v8 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v8 - 1);
    *(_DWORD *)(a1 + 0x394) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(a1 + 0x390) = 0xFFFFFFFF;
    v10 = _InterlockedCompareExchange(v1, 0, 1);
    if ( v10 == 1 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(a1 + 0x388) = &p_Src;
    }
    else
    {
      return sub_1403DF590((__int64)v1, v10);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_144F0D5E0 (0x144F0D5E0) ---

// --- Function: sub_144F13530 (0x144F13530) ---
__int64 sub_144F13530()
{
  return qword_149F8A290;
}

// --- End Function: sub_144F13530 (0x144F13530) ---

// --- Function: sub_144F1AE70 (0x144F1AE70) ---
__int64 __fastcall sub_144F1AE70(__int64 a1, unsigned int a2, const void **a3, const void **a4, _QWORD *a5)
{
  __int64 v8; // rdi
  volatile signed __int32 *v9; // rbx
  int v10; // r14d
  unsigned int v11; // eax
  int *ThreadLogContextSlot; // rax
  __int64 *v13; // r14
  __int128 v14; // xmm1
  __int64 v15; // rax
  _DWORD *v16; // rcx
  int v17; // r14d
  int *ThreadLogContextSlot_2; // rax
  int v19; // r14d
  int *ThreadLogContextSlot_1; // rax
  int v21; // r15d
  __int64 v22; // r12
  __int64 v23; // rdi
  int *ThreadLogContextSlot_3; // rax
  int v25; // edi
  int *ThreadLogContextSlot_4; // rax
  __int64 v27; // rax
  int v28; // eax
  unsigned __int32 v29; // eax
  int v30; // ebx
  int *ThreadLogContextSlot_5; // rax
  int n0xED; // [rsp+68h] [rbp-98h] BYREF
  int n0x23; // [rsp+6Ch] [rbp-94h]
  _DWORD v35[2]; // [rsp+70h] [rbp-90h] BYREF
  _DWORD v36[2]; // [rsp+78h] [rbp-88h] BYREF
  _DWORD v37[2]; // [rsp+80h] [rbp-80h] BYREF
  _DWORD v38[2]; // [rsp+88h] [rbp-78h] BYREF
  _DWORD v39[2]; // [rsp+90h] [rbp-70h] BYREF
  _DWORD v40[2]; // [rsp+98h] [rbp-68h] BYREF
  _DWORD v41[2]; // [rsp+A0h] [rbp-60h] BYREF
  _DWORD v42[2]; // [rsp+A8h] [rbp-58h] BYREF
  int n0x3600; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v44; // [rsp+B4h] [rbp-4Ch]
  int v45; // [rsp+BCh] [rbp-44h]
  unsigned __int64 v46; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v47; // [rsp+C8h] [rbp-38h]
  __int64 v48; // [rsp+D0h] [rbp-30h]
  __int64 v49; // [rsp+D8h] [rbp-28h]
  _QWORD v50[2]; // [rsp+100h] [rbp+0h] BYREF
  _QWORD v51[2]; // [rsp+110h] [rbp+10h] BYREF
  _QWORD v52[2]; // [rsp+120h] [rbp+20h] BYREF
  _QWORD v53[2]; // [rsp+130h] [rbp+30h] BYREF
  _QWORD v54[2]; // [rsp+140h] [rbp+40h] BYREF
  _QWORD v55[2]; // [rsp+150h] [rbp+50h] BYREF
  _QWORD v56[2]; // [rsp+160h] [rbp+60h] BYREF
  _QWORD v57[2]; // [rsp+170h] [rbp+70h] BYREF
  _QWORD v58[2]; // [rsp+180h] [rbp+80h] BYREF
  _QWORD v59[2]; // [rsp+190h] [rbp+90h] BYREF
  _QWORD v60[2]; // [rsp+1A0h] [rbp+A0h] BYREF
  _QWORD v61[2]; // [rsp+1B0h] [rbp+B0h] BYREF
  _QWORD v62[2]; // [rsp+1C0h] [rbp+C0h] BYREF
  _QWORD v63[2]; // [rsp+1D0h] [rbp+D0h] BYREF
  _QWORD v64[2]; // [rsp+1E0h] [rbp+E0h] BYREF
  _QWORD v65[2]; // [rsp+1F0h] [rbp+F0h] BYREF
  __int128 v66; // [rsp+200h] [rbp+100h] BYREF
  __int128 v67; // [rsp+210h] [rbp+110h] BYREF
  __int128 v68; // [rsp+220h] [rbp+120h] BYREF
  __int128 v69; // [rsp+230h] [rbp+130h] BYREF
  __int128 v70; // [rsp+240h] [rbp+140h] BYREF
  _QWORD v71[6]; // [rsp+250h] [rbp+150h] BYREF
  _DWORD v72[2]; // [rsp+280h] [rbp+180h] BYREF
  __int64 v73; // [rsp+288h] [rbp+188h] BYREF
  void *v74; // [rsp+290h] [rbp+190h] BYREF
  void *v75; // [rsp+298h] [rbp+198h] BYREF
  int v76; // [rsp+2A0h] [rbp+1A0h]
  __int64 v77; // [rsp+2A8h] [rbp+1A8h] BYREF
  void (__fastcall *n2)(__int64, __int64 *); // [rsp+2B0h] [rbp+1B0h]
  char v79; // [rsp+2C0h] [rbp+1C0h]
  __int128 v80; // [rsp+2C1h] [rbp+1C1h]
  __int128 v81; // [rsp+2D1h] [rbp+1D1h]
  __int128 v82; // [rsp+2E1h] [rbp+1E1h]
  __int128 v83; // [rsp+2F1h] [rbp+1F1h]
  __int128 v84; // [rsp+301h] [rbp+201h]
  __int128 v85; // [rsp+311h] [rbp+211h]
  __int128 v86; // [rsp+321h] [rbp+221h]
  __int128 v87; // [rsp+331h] [rbp+231h]
  __int128 v88; // [rsp+341h] [rbp+241h]
  __int128 v89; // [rsp+351h] [rbp+251h]
  __int128 v90; // [rsp+361h] [rbp+261h]

  v45 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v8 = a2;
  n0x3600 = 0x3600;
  v44 = 1;
  v46 = __rdtsc();
  qword_149C89AA0(
    &n0x3600,
    &word_149F8A548,
    "CGlobalGameUI::RequestBlockingError",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\UI/GlobalGameUI/GlobalGameUI.cpp",
    0xC6);
  HIWORD(n0x3600) = word_149F8A548;
  if ( *(_BYTE *)(a1 + 0x378) )
  {
    v9 = (volatile signed __int32 *)(a1 + 0x380);
    v10 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x390) == v10 )
    {
      ++*(_DWORD *)(a1 + 0x394);
    }
    else
    {
      v11 = _InterlockedCompareExchange(v9, 1, 0);
      if ( v11 )
        sub_1403C6E80(a1 + 0x380, v11, (__int64)"CGlobalGameUI::RequestBlockingError", 1);
      else
        *(_QWORD *)(a1 + 0x388) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x390) = v10;
    }
    v72[0] = v8;
    v72[1] = 0;
    sub_14035E090(&v73);
    assignCStringToStringStructure((__int64)&v73, (__int64)"@ui_BlockingMessagePopUpButtonConfirm");
    sub_14035E0C0(&v74, a3);
    sub_14035E0C0(&v75, a4);
    v76 = 1;
    sub_14035DAD0(&v77, a5);
    v79 = 0;
    ThreadLogContextSlot = getThreadLogContextSlot();
    v13 = (__int64 *)(a1 + 0x398);
    v80 = *(_OWORD *)ThreadLogContextSlot;
    v81 = *((_OWORD *)ThreadLogContextSlot + 1);
    v82 = *((_OWORD *)ThreadLogContextSlot + 2);
    v83 = *((_OWORD *)ThreadLogContextSlot + 3);
    v84 = *((_OWORD *)ThreadLogContextSlot + 4);
    v85 = *((_OWORD *)ThreadLogContextSlot + 5);
    v86 = *((_OWORD *)ThreadLogContextSlot + 6);
    v87 = *((_OWORD *)ThreadLogContextSlot + 7);
    v88 = *((_OWORD *)ThreadLogContextSlot + 8);
    v89 = *((_OWORD *)ThreadLogContextSlot + 9);
    v14 = *((_OWORD *)ThreadLogContextSlot + 0xA);
    v15 = *(_QWORD *)(a1 + 0x3A0);
    v90 = v14;
    v16 = *(_DWORD **)(a1 + 0x398);
    if ( v16 == (_DWORD *)v15 )
    {
      if ( v15 == *(_QWORD *)(a1 + 0x3A8) )
      {
        sub_144F09380((__int64 *)(a1 + 0x398), v15, (__int64)v72);
      }
      else
      {
        sub_144F0B650(v15, (__int64)v72);
        *(_QWORD *)(a1 + 0x3A0) += 0xF8LL;
      }
      if ( (unsigned int)AK::WriteBytesMem::Size(*(AK::WriteBytesMem **)(a1 + 0x358)) )
      {
        v37[0] = 0xED;
        v52[0] = v37;
        v37[1] = 0x23;
        v52[1] = v38;
        v19 = invokeGlobalCallbackAndMaskStatusBits(5, (__int64)v52, (__int64)"Error Popup Queued", "errorCode=$$");
        if ( (v19 & 0xFFFFF) != 0 )
        {
          v53[0] = 0;
          v53[1] = v8;
          ThreadLogContextSlot_1 = getThreadLogContextSlot();
          v38[0] = 0xED;
          v54[0] = v38;
          v38[1] = 0x23;
          v54[1] = v39;
          v66 = 0;
          sub_140445600(
            5,
            (__int64)v54,
            "Error Popup Queued",
            (__int64)"errorCode=$$",
            1,
            v19,
            &v66,
            0,
            (__int64)ThreadLogContextSlot_1,
            v53);
        }
      }
      else
      {
        v35[0] = 0xED;
        v65[0] = v35;
        v35[1] = 0x23;
        v65[1] = v36;
        v17 = invokeGlobalCallbackAndMaskStatusBits(5, (__int64)v65, (__int64)"Error Popup Opened", "errorCode=$$");
        if ( (v17 & 0xFFFFF) != 0 )
        {
          v50[0] = 0;
          v50[1] = v8;
          ThreadLogContextSlot_2 = getThreadLogContextSlot();
          v36[0] = 0xED;
          v51[0] = v36;
          v36[1] = 0x23;
          v51[1] = v37;
          v70 = 0;
          sub_140445600(
            5,
            (__int64)v51,
            "Error Popup Opened",
            (__int64)"errorCode=$$",
            1,
            v17,
            &v70,
            0,
            (__int64)ThreadLogContextSlot_2,
            v50);
        }
        sub_1435955A0(*(_QWORD *)(a1 + 0x358), (__int64)v71, 1u, 0, 1, 0);
        sub_14345FEE0(v71);
      }
    }
    else
    {
      if ( !v16[1] && (_DWORD)v8 != *v16 )
      {
        v39[0] = 0xED;
        v55[0] = v39;
        v39[1] = 0x23;
        v55[1] = v40;
        v21 = invokeGlobalCallbackAndMaskStatusBits(
                4,
                (__int64)v55,
                (__int64)"Error Popup Overwritten",
                "Blocking errorCode=$$ queued, overwriting previous popup errorCode=$$. This may result in the error mess"
                "age getting stuck with bad timings.");
        v22 = v8;
        if ( (v21 & 0xFFFFF) != 0 )
        {
          v23 = *v13;
          v56[1] = *(unsigned int *)*v13;
          v56[0] = 0;
          v57[0] = 0;
          v57[1] = v22;
          ThreadLogContextSlot_3 = getThreadLogContextSlot();
          v40[0] = 0xED;
          v58[0] = v40;
          v58[1] = v41;
          v40[1] = 0x23;
          v67 = 0;
          sub_144F09A10(
            4,
            (__int64)v58,
            "Error Popup Overwritten",
            (__int64)"Blocking errorCode=$$ queued, overwriting previous popup errorCode=$$. This may result in the error"
                     " message getting stuck with bad timings.",
            1,
            v21,
            &v67,
            0,
            (__int64)ThreadLogContextSlot_3,
            v57,
            (__int64)v56,
            v23 + 0x41);
        }
        v41[0] = 0xED;
        v59[0] = v41;
        v41[1] = 0x23;
        v59[1] = v42;
        v25 = invokeGlobalCallbackAndMaskStatusBits(
                5,
                (__int64)v59,
                (__int64)"Error Popup Opened (Overwrite)",
                "errorCode=$$");
        if ( (v25 & 0xFFFFF) != 0 )
        {
          v60[0] = 0;
          v60[1] = v22;
          ThreadLogContextSlot_4 = getThreadLogContextSlot();
          v42[0] = 0xED;
          v61[0] = v42;
          v42[1] = 0x23;
          v61[1] = &n0x3600;
          v68 = 0;
          sub_140445600(
            5,
            (__int64)v61,
            "Error Popup Opened (Overwrite)",
            (__int64)"errorCode=$$",
            1,
            v25,
            &v68,
            0,
            (__int64)ThreadLogContextSlot_4,
            v60);
        }
      }
      sub_144F0BD20(*v13, (__int64)v72);
      v27 = sub_143282210(a1 + 0x48);
      sub_144F08A90(v27);
    }
    if ( (unsigned __int64)n2 >= 2 )
    {
      n2(2, &v77);
      n2 = 0;
    }
    v77 = 0;
    sub_140373CC0(&v75);
    sub_140373CC0(&v74);
    sub_140373CC0(&v73);
    v28 = *(_DWORD *)(a1 + 0x394);
    if ( v28 )
    {
      *(_DWORD *)(a1 + 0x394) = v28 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x390) = 0xFFFFFFFF;
      v29 = _InterlockedCompareExchange(v9, 0, 1);
      if ( v29 == 1 )
        *(_QWORD *)(a1 + 0x388) = &p_Src;
      else
        sub_1403DF590(a1 + 0x380, v29);
    }
  }
  else
  {
    n0xED = 0xED;
    v62[0] = &n0xED;
    n0x23 = 0x23;
    v62[1] = v35;
    v30 = invokeGlobalCallbackAndMaskStatusBits(
            4,
            (__int64)v62,
            (__int64)"Error Popup Request Failed",
            "Blocking errorCode=$$ could not be queued because the global game UI is not open.");
    if ( (v30 & 0xFFFFF) != 0 )
    {
      v63[0] = 0;
      v63[1] = v8;
      ThreadLogContextSlot_5 = getThreadLogContextSlot();
      n0xED = 0xED;
      v64[0] = &n0xED;
      n0x23 = 0x23;
      v64[1] = v35;
      v69 = 0;
      sub_140445600(
        4,
        (__int64)v64,
        "Error Popup Request Failed",
        (__int64)"Blocking errorCode=$$ could not be queued because the global game UI is not open.",
        1,
        v30,
        &v69,
        0,
        (__int64)ThreadLogContextSlot_5,
        v63);
    }
  }
  v47 = __rdtsc();
  return qword_149C89AA8(&n0x3600);
}

// --- End Function: sub_144F1AE70 (0x144F1AE70) ---

// --- Function: sub_144F1B8B0 (0x144F1B8B0) ---
void __fastcall sub_144F1B8B0(__int64 a1, const void **a2)
{
  __int64 v4; // rbx
  int v5; // edi
  unsigned int v6; // eax
  char v7; // r14
  __int64 v8; // rdi
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  int v13; // eax
  unsigned __int32 v14; // eax
  const char *p_@LOC_EMPTY; // [rsp+38h] [rbp-190h] BYREF
  __int64 v16; // [rsp+40h] [rbp-188h] BYREF
  void (__fastcall *n2)(__int64, __int64 *, _QWORD); // [rsp+48h] [rbp-180h]
  __int64 v18; // [rsp+50h] [rbp-178h]
  _QWORD v19[7]; // [rsp+58h] [rbp-170h] BYREF
  _BYTE v20[8]; // [rsp+90h] [rbp-138h] BYREF
  __int64 v21; // [rsp+98h] [rbp-130h] BYREF
  __int64 v22; // [rsp+A0h] [rbp-128h] BYREF
  __int64 v23; // [rsp+A8h] [rbp-120h] BYREF
  __int64 v24; // [rsp+B8h] [rbp-110h] BYREF
  void (__fastcall *n2_1)(__int64, __int64 *); // [rsp+C0h] [rbp-108h]

  if ( *(_BYTE *)(a1 + 0x378) )
  {
    v4 = a1 + 0x380;
    v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v4 + 0x10) == v5 )
    {
      ++*(_DWORD *)(v4 + 0x14);
    }
    else
    {
      v6 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
      if ( v6 )
        sub_1403C6E80(v4, v6, (__int64)"CGlobalGameUI::RequestLoginQueueUpdatePopup", 1);
      else
        *(_QWORD *)(v4 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v4 + 0x10) = v5;
    }
    p_@LOC_EMPTY = "@LOC_EMPTY";
    v16 = 0;
    n2 = 0;
    v18 = 0;
    v7 = 0;
    sub_144F0B760((__int64)v20, 1, a2, 1, (__int64 *)&p_@LOC_EMPTY, &v16);
    if ( (unsigned __int64)n2 >= 2 )
      n2(2, &v16, 0);
    v8 = a1 + 0x398;
    v9 = *(_QWORD *)(a1 + 0x398);
    v10 = *(_QWORD *)(a1 + 0x3A0);
    if ( v9 != v10 )
    {
      while ( *(_DWORD *)(v9 + 4) != 1 )
      {
        v9 += 0xF8;
        if ( v9 == v10 )
          goto LABEL_15;
      }
      v7 = 1;
      sub_144F0BD20(v9, (__int64)v20);
    }
LABEL_15:
    v11 = *(_QWORD *)(a1 + 0x3A0);
    if ( *(_QWORD *)v8 == v11 || *(_DWORD *)(*(_QWORD *)v8 + 4LL) != 1 )
    {
      if ( !v7 )
      {
        if ( v11 == *(_QWORD *)(a1 + 0x3A8) )
        {
          sub_144F09380((__int64 *)(a1 + 0x398), *(_QWORD *)(a1 + 0x3A0), (__int64)v20);
        }
        else
        {
          sub_144F0B650(*(_QWORD *)(a1 + 0x3A0), (__int64)v20);
          *(_QWORD *)(a1 + 0x3A0) += 0xF8LL;
        }
        if ( !(unsigned int)AK::WriteBytesMem::Size(*(AK::WriteBytesMem **)(a1 + 0x358)) )
        {
          sub_1435955A0(*(_QWORD *)(a1 + 0x358), (__int64)v19, 1u, 0, 1, 0);
          sub_14345FEE0(v19);
        }
      }
    }
    else
    {
      v12 = sub_143282210(a1 + 0x48);
      sub_144F08A90(v12);
    }
    if ( (unsigned __int64)n2_1 >= 2 )
    {
      n2_1(2, &v24);
      n2_1 = 0;
    }
    v24 = 0;
    sub_140373CC0(&v23);
    sub_140373CC0(&v22);
    sub_140373CC0(&v21);
    v13 = *(_DWORD *)(v4 + 0x14);
    if ( v13 )
    {
      *(_DWORD *)(v4 + 0x14) = v13 - 1;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      v14 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
      if ( v14 == 1 )
        *(_QWORD *)(v4 + 8) = &p_Src;
      else
        sub_1403DF590(v4, v14);
    }
  }
}

// --- End Function: sub_144F1B8B0 (0x144F1B8B0) ---

// --- Function: sub_144F1D030 (0x144F1D030) ---
__int64 __fastcall sub_144F1D030(__int64 a1)
{
  __int64 v2; // rax
  __int64 result; // rax
  const char *p_Unknown; // rbx
  const char *p_Unknown_1; // rdi
  __int64 v6; // rcx
  const char *p_Unknown_2; // rax
  __int64 v8; // rcx
  const char *p_Unknown_3; // rax

  v2 = sub_140976B00(qword_149FBE618);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x240LL))(v2);
  if ( (_BYTE)result )
  {
    p_Unknown = "Unknown";
    p_Unknown_1 = "Unknown";
    if ( qword_149C8E0F8 && qword_149C8DFD0 )
    {
      v6 = qword_149F8A4F8;
      if ( qword_149F8A4F8
        || (qword_149F8A4F8 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
                                qword_149C8DFD0,
                                "sv_megamapinstance"),
            (v6 = qword_149F8A4F8) != 0) )
      {
        p_Unknown_2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x28LL))(v6);
        if ( p_Unknown_2 )
        {
          if ( *p_Unknown_2 )
            p_Unknown = p_Unknown_2;
        }
      }
      v8 = qword_149F8A500;
      if ( qword_149F8A500
        || (qword_149F8A500 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
                                qword_149C8DFD0,
                                "sv_gamerules"),
            (v8 = qword_149F8A500) != 0) )
      {
        p_Unknown_3 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x28LL))(v8);
        if ( p_Unknown_3 )
        {
          if ( *p_Unknown_3 )
            p_Unknown_1 = p_Unknown_3;
        }
      }
    }
    sub_1465E3F20(qword_149FBE618, "game-map", p_Unknown);
    return sub_1465E3F20(qword_149FBE618, "game-mode", p_Unknown_1);
  }
  else if ( *(_DWORD *)(a1 + 0x80) == 4 )
  {
    return sub_1465E3F20(qword_149FBE618, "game-state", "Lobby");
  }
  return result;
}

// --- End Function: sub_144F1D030 (0x144F1D030) ---

// --- Function: sub_144F1D490 (0x144F1D490) ---
__int64 __fastcall sub_144F1D490(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rcx
  __int64 v9; // rcx
  __int64 result; // rax

  v6 = *a1;
  if ( v6 )
  {
    sub_144F08D30(v6, a1[1], a1);
    v9 = *a1;
    if ( (unsigned __int64)(0xF8 * ((a1[2] - *a1) / 0xF8)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v9 - *(_QWORD *)(v9 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v9 = *(_QWORD *)(v9 - 8);
    }
    sub_1402A6590(v9);
  }
  *a1 = a2;
  a1[1] = a2 + 0xF8 * a3;
  result = a2 + 0xF8 * a4;
  a1[2] = result;
  return result;
}

// --- End Function: sub_144F1D490 (0x144F1D490) ---

// --- Function: sub_1451F63D0 (0x1451F63D0) ---
__int64 (__fastcall *__fastcall sub_1451F63D0(__int64 a1, __int64 a2))(__int64, __int64)
{
  __int64 v3; // rbx
  __int64 i; // rbp
  int j; // edi
  void (__fastcall *v6)(__int64); // rax
  __int64 (__fastcall *n2)(__int64, __int64); // rax

  v3 = *(_QWORD *)(a1 + 0x30);
  for ( i = *(_QWORD *)(a1 + 0x38); v3 != i; v3 += 0x20 )
  {
    for ( j = 0; j < *(_DWORD *)(v3 + 0x10); ++j )
    {
      v6 = *(void (__fastcall **)(__int64))a2;
      if ( *(_QWORD *)(a2 + 8) == 1 )
        v6(v3);
      else
        ((void (__fastcall *)(__int64, __int64))v6)(a2, v3);
    }
  }
  n2 = *(__int64 (__fastcall **)(__int64, __int64))(a2 + 8);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2 = (__int64 (__fastcall *)(__int64, __int64))n2(2, a2);
    *(_QWORD *)(a2 + 8) = 0;
  }
  *(_QWORD *)a2 = 0;
  return n2;
}

// --- End Function: sub_1451F63D0 (0x1451F63D0) ---

// --- Function: sub_1451F6500 (0x1451F6500) ---
__int64 __fastcall sub_1451F6500(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 i; // rbx
  void (__fastcall *v5)(__int64); // rax
  void (__fastcall *n2)(__int64, __int64); // rax
  __int64 result; // rax

  v2 = a1[1];
  for ( i = *a1; i != v2; i += 0x98 )
  {
    v5 = *(void (__fastcall **)(__int64))a2;
    if ( *(_QWORD *)(a2 + 8) == 1 )
      v5(i);
    else
      ((void (__fastcall *)(__int64, __int64))v5)(a2, i);
  }
  n2 = *(void (__fastcall **)(__int64, __int64))(a2 + 8);
  if ( (unsigned __int64)n2 < 2 )
  {
    result = 0;
  }
  else
  {
    n2(2, a2);
    result = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  *(_QWORD *)a2 = 0;
  return result;
}

// --- End Function: sub_1451F6500 (0x1451F6500) ---

// --- Function: sub_1451F83B0 (0x1451F83B0) ---
__int64 __fastcall sub_1451F83B0(__int64 a1)
{
  __int64 v1; // rdx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_QWORD *)(a1 + 0x38);
  result = 0;
  for ( i = *(_QWORD *)(a1 + 0x30); i != v1; i += 0x20 )
    result = (unsigned int)(*(_DWORD *)(i + 0x10) + result);
  return result;
}

// --- End Function: sub_1451F83B0 (0x1451F83B0) ---

// --- Function: sub_145421300 (0x145421300) ---
int *__fastcall sub_145421300(
        __int64 a1,
        const void *src,
        const void *src_1,
        __int64 a4,
        float *a5,
        float *a6,
        _DWORD *a7,
        __int64 a8)
{
  __int64 *v8; // rax
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  int *result; // rax
  int v14; // [rsp+60h] [rbp-428h]
  _QWORD v15[2]; // [rsp+68h] [rbp-420h] BYREF
  __int64 v16; // [rsp+78h] [rbp-410h]
  __int64 v17; // [rsp+80h] [rbp-408h]
  __int64 v18; // [rsp+88h] [rbp-400h]
  int *v19; // [rsp+90h] [rbp-3F8h]
  __int64 v20; // [rsp+98h] [rbp-3F0h]
  __int64 v21; // [rsp+A0h] [rbp-3E8h]
  void *v22; // [rsp+A8h] [rbp-3E0h]
  __int64 v23; // [rsp+B0h] [rbp-3D8h]
  __int64 v24; // [rsp+B8h] [rbp-3D0h]
  __int64 v25; // [rsp+C0h] [rbp-3C8h]
  _Mtx_t v26; // [rsp+C8h] [rbp-3C0h]
  int v27[2]; // [rsp+D0h] [rbp-3B8h]
  __int64 (__fastcall *v28)(__int64, _QWORD); // [rsp+D8h] [rbp-3B0h]
  double v29; // [rsp+E0h] [rbp-3A8h]
  __int64 v30; // [rsp+E8h] [rbp-3A0h] BYREF
  __int64 v31; // [rsp+F0h] [rbp-398h] BYREF
  __int64 v32; // [rsp+F8h] [rbp-390h] BYREF
  __int64 v33; // [rsp+100h] [rbp-388h] BYREF
  _BYTE v34[8]; // [rsp+108h] [rbp-380h] BYREF
  _BYTE buf_[48]; // [rsp+110h] [rbp-378h] BYREF
  _BYTE v36[56]; // [rsp+140h] [rbp-348h] BYREF
  _BYTE v37[72]; // [rsp+178h] [rbp-310h] BYREF
  int v38; // [rsp+1C0h] [rbp-2C8h] BYREF
  __int64 v39; // [rsp+1C8h] [rbp-2C0h]
  _BYTE v40[144]; // [rsp+3F8h] [rbp-90h] BYREF

  if ( !*(_BYTE *)(sub_1402A4D50((__int64)&gEnv) + 0x2A0) )
    LogFatalError("Attempting to begin quantum entrance for subsumption on a pure client. NEVER do this.");
  v15[1] = &v31;
  v31 = 0;
  v20 = 0;
  v21 = 0;
  v25 = 0;
  memset(buf_, 0, sizeof(buf_));
  v26 = (_Mtx_t)sub_1449625C0(buf_);
  v16 = sub_1404C8440(src);
  v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x1F8LL))(v16);
  v22 = &v32;
  sub_1402B3CF0(&v32);
  v23 = *v8;
  v24 = v23;
  *(_QWORD *)v27 = v23;
  sub_145382060((int)&v38, v23, 0, v14, 0, (__int64)src, (__int64)src_1, a1 + 0x18, v26, 0, 0, 0);
  _XMM0 = COERCE_UNSIGNED_INT64(*(double *)&qword_149B8DB68 * 0.699999988079071);
  __asm { vmovupd xmm1, xmm0 }
  v29 = sub_14497EFF0(&v38);
  v17 = *(_QWORD *)(sub_1402A4D50((__int64)&gEnv) + 0x60);
  v28 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v17 + 0x38LL);
  v15[0] = *(_QWORD *)v28(v17, 0);
  sub_1402B3B40(&v30, v29);
  v11 = sub_14059CA60(v15, &v33, &v30);
  sub_144975B00(&v38, *v11);
  sub_1449652E0(v36);
  std::shared_ptr<__ExceptionPtr>::_Resetp0<__ExceptionPtr>(&v38, v15[0], v36);
  v12 = (_QWORD *)sub_1449A4E50(&v38, v34);
  sub_142BD2A60(a8, v37, *v12);
  *(_QWORD *)(a4 + 8) = v15[0];
  *(_DWORD *)a4 = 2;
  *(double *)(a4 + 0x10) = 0;
  *(_DWORD *)(a4 + 0xC8) = 0;
  *(_BYTE *)(a4 + 0xBC) = 0;
  *(float *)(a4 + 0xB8) = 0x3F800000;
  v18 = a4 + 0xCC;
  *(_WORD *)(a4 + 0xCC) |= 0x17Cu;
  qmemcpy((void *)(a4 + 0x18), src, 0x28u);
  qmemcpy((void *)(a4 + 0x40), src_1, 0x28u);
  *(_DWORD *)(a4 + 0xD4) = 2;
  *a5 = 0x3F800000;
  *a7 = 6;
  *a6 = 0x3F800000;
  sub_144966210(v40);
  v19 = &v38;
  result = &v38;
  if ( v39 )
    return (int *)std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)v19 + 1));
  return result;
}

// --- End Function: sub_145421300 (0x145421300) ---

// --- Function: sub_145421720 (0x145421720) ---
__int64 __fastcall sub_145421720(unsigned __int64 a1, const void *src_1, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-48h]
  _QWORD *v5; // [rsp+28h] [rbp-40h]
  _QWORD v6[2]; // [rsp+38h] [rbp-30h] BYREF
  _BYTE v7[32]; // [rsp+48h] [rbp-20h] BYREF
  unsigned __int64 v8; // [rsp+70h] [rbp+8h] BYREF
  const void *src; // [rsp+78h] [rbp+10h]
  __int64 v10; // [rsp+80h] [rbp+18h]

  v10 = a3;
  src = src_1;
  v8 = a1;
  if ( is_entity_descriptor_valid_or_accessible(&v8) )
  {
    v4 = sub_1403115A0(&v8);
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v4 + 8LL))(v4, v7);
  }
  else
  {
    v6[0] = 0;
    v5 = v6;
  }
  v6[1] = v5;
  *(_QWORD *)(v10 + 0x10) = *v5;
  qmemcpy((void *)(v10 + 0x18), src, 0x28u);
  *(_DWORD *)v10 = 3;
  *(_BYTE *)(v10 + 4) = 1;
  result = v10;
  *(_DWORD *)(v10 + 8) = 2;
  return result;
}

// --- End Function: sub_145421720 (0x145421720) ---

// --- Function: sub_14551CC20 (0x14551CC20) ---
unsigned __int8 *__fastcall sub_14551CC20(unsigned __int8 *a1)
{
  unsigned __int8 *result; // rax
  __int64 v2; // [rsp+20h] [rbp-28h]
  __int64 v3; // [rsp+28h] [rbp-20h]
  __int64 v4; // [rsp+30h] [rbp-18h]

  result = (unsigned __int8 *)a1[0x433];
  if ( a1[0x433] )
  {
    result = (unsigned __int8 *)a1[0x431];
    if ( a1[0x431] )
    {
      if ( !*(_DWORD *)(n29 + 0x1574) )
      {
        v2 = sub_140976B00(qword_149FBE618);
        if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x1E0LL))(v2) )
        {
          v3 = sub_140976B00(qword_149FBE618);
          v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x1E0LL))(v3);
          (*(void (__fastcall **)(__int64, const char *))(*(_QWORD *)v4 + 0x20LL))(v4, "ProcessBootRequest");
          a1[0x432] = 1;
        }
      }
      result = a1;
      a1[0x431] = 0;
    }
  }
  return result;
}

// --- End Function: sub_14551CC20 (0x14551CC20) ---

// --- Function: sub_145526A10 (0x145526A10) ---
__int64 __fastcall sub_145526A10(__int64 a1, int n2)
{
  __int64 result; // rax

  result = a1;
  if ( *(_DWORD *)(a1 + 0x440) != 2 )
  {
    if ( n2 == 3 )
    {
      if ( *(_DWORD *)(a1 + 0x440) <= 1u )
        *(_BYTE *)(a1 + 0x433) = 1;
    }
    else if ( n2 == 2 )
    {
      *(_BYTE *)(a1 + 0x433) = 0;
    }
    result = a1;
    *(_DWORD *)(a1 + 0x440) = n2;
  }
  return result;
}

// --- End Function: sub_145526A10 (0x145526A10) ---

// --- Function: sub_14554D170 (0x14554D170) ---
__int64 sub_14554D170()
{
  return qword_149F9A578;
}

// --- End Function: sub_14554D170 (0x14554D170) ---

// --- Function: sub_14573F990 (0x14573F990) ---
void sub_14573F990()
{
  __int64 v0; // rax

  if ( Parameter_0 )
  {
    v0 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x4000003);
    if ( v0 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v0 + 8LL))(v0);
  }
}

// --- End Function: sub_14573F990 (0x14573F990) ---

// --- Function: sub_14580E2F0 (0x14580E2F0) ---
__int64 __fastcall sub_14580E2F0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_145E13690(a2, a3);
  return a2;
}

// --- End Function: sub_14580E2F0 (0x14580E2F0) ---

// --- Function: sub_14586B8A0 (0x14586B8A0) ---
__int64 __fastcall sub_14586B8A0(__int64 a1)
{
  double *v2; // rax
  double v3; // xmm2_8
  double v4; // xmm1_8
  double v6[4]; // [rsp+30h] [rbp-78h] BYREF
  int n0x5300; // [rsp+50h] [rbp-58h] BYREF
  __int64 v8; // [rsp+54h] [rbp-54h]
  int v9; // [rsp+5Ch] [rbp-4Ch]
  unsigned __int64 v10; // [rsp+60h] [rbp-48h]
  unsigned __int64 v11; // [rsp+68h] [rbp-40h]
  __int64 v12; // [rsp+70h] [rbp-38h]
  __int64 v13; // [rsp+78h] [rbp-30h]

  n0x5300 = 0x5300;
  v9 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v8 = 1;
  v10 = __rdtsc();
  qword_149C89AA0(
    &n0x5300,
    &word_149F9E7C4,
    "CWeaponSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\WeaponSystem.cpp",
    0x9C);
  HIWORD(n0x5300) = word_149F9E7C4;
  v2 = (double *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x3D0LL))(qword_149C8DFE0);
  v3 = v2[0xB];
  v4 = v2[7];
  v6[0] = v2[3];
  v6[1] = v4;
  v6[2] = v3;
  sub_142D5D920(a1 + 0x58, v6, *(_DWORD *)(n29 + 0x157C));
  v11 = __rdtsc();
  return qword_149C89AA8(&n0x5300);
}

// --- End Function: sub_14586B8A0 (0x14586B8A0) ---

// --- Function: sub_145D67060 (0x145D67060) ---
__m128 __fastcall sub_145D67060(__int64 a1)
{
  __int128 v1; // xmm0
  unsigned int v2; // eax
  __int128 v3; // kr00_16

  *(double *)&v1 = sub_143012720(a1 + 0x2D50);
  v3 = v1;
  *(float *)&v3 = (float)v2;
  *(float *)&v3 = *(float *)&v3 * 0.033333335;
  return (__m128)v3;
}

// --- End Function: sub_145D67060 (0x145D67060) ---

// --- Function: sub_145DF96D0 (0x145DF96D0) ---
__int64 __fastcall sub_145DF96D0(__int64 a1)
{
  __int64 v1; // rsi
  int *v2; // rbx
  int *v3; // rax
  int v4; // ebx
  int v5; // edi
  __int64 v7; // rdi
  unsigned __int8 (__fastcall *v8)(__int64, __int64, const char *); // rbx
  __int64 v9; // rax
  _BYTE v10[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v11; // [rsp+28h] [rbp-30h]
  _BYTE v12[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v13; // [rsp+40h] [rbp-18h]

  v1 = *(_QWORD *)(a1 + 0xE0);
  if ( !v1 )
    return 0;
  v2 = (int *)sub_142D5D0D0(v12);
  v3 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v1 + 0x18LL))(v1, v10);
  v4 = *v2;
  v5 = *v3;
  if ( v11 )
    sub_147715880(v11);
  if ( v13 )
    sub_147715880(v13);
  if ( v4 == v5 )
    return v1;
  if ( qword_149C8DFE0
    && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0)
    && (v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x240LL))(qword_149C8DFE0),
        v8 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v7 + 0x100LL),
        v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 8LL))(v1),
        v8(v7, v9, "ProjectileParams")) )
  {
    return v1;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_145DF96D0 (0x145DF96D0) ---

// --- Function: sub_145DF9AE0 (0x145DF9AE0) ---
__int64 __fastcall sub_145DF9AE0(__int64 a1, __int64 *a2)
{
  unsigned int event_key_from_source_location; // ebx
  __int64 v5; // rsi
  void (__fastcall *v6)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)); // rbp
  __int64 v7; // rax
  __int64 p_sub_14159F620_1; // rax
  __int64 (__fastcall *p_sub_14154ABF0)(__int64, __int64); // [rsp+20h] [rbp-28h] BYREF
  void (__fastcall *p_sub_14159F620)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+28h] [rbp-20h]
  __int64 v11; // [rsp+30h] [rbp-18h]

  event_key_from_source_location = event_key_from_source_location_8;
  if ( !event_key_from_source_location_8 )
    event_key_from_source_location = get_event_key_from_source_location(
                                       &event_key_from_source_location_8,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Recording\\CombatLoggingEvents.h",
                                       0x6D);
  v5 = *a2;
  v6 = *(void (__fastcall **)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)))(*(_QWORD *)a1 + 0x20LL);
  v7 = sub_1402A65A0(0xCu);
  if ( v7 )
  {
    *(_QWORD *)v7 = v5;
    *(_DWORD *)(v7 + 8) = event_key_from_source_location;
    v11 = v7;
  }
  else
  {
    v11 = 0;
  }
  p_sub_14154ABF0 = sub_14154ABF0;
  p_sub_14159F620 = sub_14159F620;
  v6(a1, event_key_from_source_location, &p_sub_14154ABF0);
  p_sub_14159F620_1 = (__int64)p_sub_14159F620;
  if ( (unsigned __int64)p_sub_14159F620 >= 2 )
    return ((__int64 (__fastcall *)(__int64, _QWORD))p_sub_14159F620)(2, &p_sub_14154ABF0);
  return p_sub_14159F620_1;
}

// --- End Function: sub_145DF9AE0 (0x145DF9AE0) ---

// --- Function: sub_145DFC180 (0x145DFC180) ---
_QWORD *__fastcall sub_145DFC180(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, int *a4, int *a5)
{
  int *v5; // rsi
  int *v6; // r15
  __int64 v10; // rax
  __int64 v11; // rcx
  _QWORD *result; // rax
  unsigned __int64 v13; // r13
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rdi
  unsigned __int64 v17; // rdi
  __int64 v18; // r14
  __int64 *v19; // r9
  __int64 v20; // rcx
  __int64 *v21; // rdx
  __int64 v22; // rdx
  __int64 v23; // rdx
  unsigned __int64 v24; // rdi
  __int64 v25; // r14
  int v26; // eax
  __int64 v27; // rcx
  __int64 v28; // [rsp+20h] [rbp-68h] BYREF
  _QWORD *v29; // [rsp+30h] [rbp-58h] BYREF
  __int64 v30; // [rsp+38h] [rbp-50h]
  _QWORD *v31; // [rsp+40h] [rbp-48h] BYREF
  unsigned __int64 v32; // [rsp+48h] [rbp-40h]
  char v33[56]; // [rsp+50h] [rbp-38h] BYREF

  v5 = a5;
  v6 = a4;
  if ( a4 == a5 )
  {
    v10 = *a1;
    v11 = a1[3];
    *a2 = v10;
    a2[2] = a3 + v11;
    result = a2;
    a2[1] = 0;
  }
  else
  {
    v13 = a1[4];
    if ( a3 > v13 >> 1 )
    {
      v22 = a1[4];
      do
      {
        if ( ((*((_BYTE *)a1 + 0x18) + (_BYTE)v22) & 3) == 0 && a1[2] <= (unsigned __int64)(v22 + 4) >> 2 )
          sub_1405027A0(a1, 1u);
        v23 = a1[2];
        a1[3] &= 4 * v23 - 1;
        v24 = a1[4] + a1[3];
        v25 = 8 * ((v23 - 1) & (v24 >> 2));
        if ( !*(_QWORD *)(v25 + a1[1]) )
          *(_QWORD *)(v25 + a1[1]) = sub_1402A65A0(0x10u);
        v26 = *v6++;
        *(_DWORD *)(*(_QWORD *)(v25 + a1[1]) + 4 * (v24 & 3)) = v26;
        v22 = a1[4] + 1LL;
        a1[4] = v22;
      }
      while ( v6 != a5 );
      v20 = a1[3];
      v19 = (__int64 *)&v31;
      v32 = v22 + v20;
      v21 = &v28;
      v30 = v20 + v13;
    }
    else
    {
      v14 = a1[4];
      do
      {
        v5 += 0xFFFFFFFF;
        if ( (a1[3] & 3) == 0 && a1[2] <= (unsigned __int64)(v14 + 4) >> 2 )
          sub_1405027A0(a1, 1u);
        v15 = a1[2];
        v16 = a1[3] & (4 * v15 - 1);
        a1[3] = v16;
        if ( !v16 )
          v16 = 4 * v15;
        v17 = v16 - 1;
        v18 = 8 * ((v15 - 1) & (v17 >> 2));
        if ( !*(_QWORD *)(v18 + a1[1]) )
          *(_QWORD *)(v18 + a1[1]) = sub_1402A65A0(0x10u);
        *(_DWORD *)(*(_QWORD *)(v18 + a1[1]) + 4 * (v17 & 3)) = *v5;
        a1[3] = v17;
        v14 = a1[4] + 1LL;
        a1[4] = v14;
      }
      while ( v5 != v6 );
      v32 = v17;
      v19 = &v28;
      v20 = v17 - v13 + v14;
      v21 = (__int64 *)&v31;
      v30 = v20;
    }
    v31 = a1;
    v29 = a1;
    ((void (__fastcall *)(char *, __int64 *, _QWORD **, __int64 *, _QWORD *, unsigned __int64))sub_145DFEBA0)(
      v33,
      v21,
      &v29,
      v19,
      a1,
      v20 + a3);
    v27 = a1[3];
    *a2 = *a1;
    result = a2;
    a2[2] = a3 + v27;
    a2[1] = 0;
  }
  return result;
}

// --- End Function: sub_145DFC180 (0x145DFC180) ---

// --- Function: sub_145DFEBA0 (0x145DFEBA0) ---
__m128i *__fastcall sub_145DFEBA0(__m128i *a1, __m128i *a2, __int128 *a3, __m128i *a4)
{
  __int64 v4; // rax
  unsigned __int64 v6; // r12
  __m128i v9; // xmm2
  signed __int64 epi64; // rsi
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r10
  __int128 v14; // xmm1
  _DWORD *v15; // r8
  __int64 v16; // rcx
  unsigned __int64 v17; // rax
  _DWORD *v18; // rdx
  unsigned __int64 v19; // r9
  unsigned __int64 i; // r10
  _DWORD *v21; // r8
  __int64 v22; // rcx
  unsigned __int64 v23; // rax
  _DWORD *v24; // rdx
  unsigned __int64 v25; // r9
  unsigned __int64 v26; // r10
  __m128i v27; // xmm0
  _DWORD *v28; // r8
  __int64 v29; // rcx
  unsigned __int64 v30; // rax
  _DWORD *v31; // rdx
  __int128 v32; // [rsp+0h] [rbp-38h]
  __m128i j; // [rsp+0h] [rbp-38h]
  __m128i v34; // [rsp+0h] [rbp-38h]
  __m128i v35; // [rsp+10h] [rbp-28h]

  v4 = a2->m128i_i64[1];
  v6 = *((_QWORD *)a3 + 1);
  v9 = *a4;
  if ( v4 == v6 )
  {
    *a1 = v9;
    return a1;
  }
  else
  {
    epi64 = _mm_extract_epi64(v9, 1);
    if ( v6 == epi64 )
    {
      *a1 = *a2;
    }
    else
    {
      v12 = *((_QWORD *)a3 + 1);
      v13 = a2->m128i_u64[1];
      v14 = *a3;
      v32 = *a3;
      v35 = *a2;
      if ( v4 != v6 )
      {
        do
        {
          if ( v13 == --v12 )
            break;
          v15 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v32 + 8) + 8 * ((*(_QWORD *)(v32 + 0x10) - 1LL) & (v12 >> 2)))
                         + 4 * (v12 & 3));
          v16 = v13 & 3;
          v17 = v13++ >> 2;
          v18 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v35.m128i_i64[0] + 8)
                                     + 8 * (v17 & (*(_QWORD *)(v35.m128i_i64[0] + 0x10) - 1LL)))
                         + 4 * v16);
          LODWORD(v16) = *v18;
          *v18 = *v15;
          *v15 = v16;
        }
        while ( v13 != v12 );
      }
      v19 = a4->m128i_u64[1];
      for ( i = v6; i != v19; *v21 = v22 )
      {
        if ( i == --v19 )
          break;
        v21 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v9.m128i_i64[0] + 8)
                                   + 8 * ((*(_QWORD *)(v9.m128i_i64[0] + 0x10) - 1LL) & (v19 >> 2)))
                       + 4 * (v19 & 3));
        v22 = i & 3;
        v23 = i++ >> 2;
        v24 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v14 + 8) + 8 * (v23 & (*(_QWORD *)(v14 + 0x10) - 1LL))) + 4 * v22);
        LODWORD(v22) = *v24;
        *v24 = *v21;
      }
      v25 = a4->m128i_u64[1];
      v26 = a2->m128i_u64[1];
      v27 = *a2;
      for ( j = *a2; v26 != v25; *v28 = v29 )
      {
        if ( v26 == --v25 )
          break;
        v28 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v9.m128i_i64[0] + 8)
                                   + 8 * ((*(_QWORD *)(v9.m128i_i64[0] + 0x10) - 1LL) & (v25 >> 2)))
                       + 4 * (v25 & 3));
        v29 = v26 & 3;
        v30 = v26++ >> 2;
        v31 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(j.m128i_i64[0] + 8)
                                   + 8 * (v30 & (*(_QWORD *)(j.m128i_i64[0] + 0x10) - 1LL)))
                       + 4 * v29);
        LODWORD(v29) = *v31;
        *v31 = *v28;
      }
      v34.m128i_i64[0] = v27.m128i_i64[0];
      v34.m128i_i64[1] = epi64 - v6 + a2->m128i_i64[1];
      *a1 = v34;
    }
    return a1;
  }
}

// --- End Function: sub_145DFEBA0 (0x145DFEBA0) ---

// --- Function: sub_145E09110 (0x145E09110) ---
unsigned __int64 __fastcall sub_145E09110(__int64 a1, __int64 a2, int a3)
{
  __int64 *v3; // rbx
  __int64 v5; // rcx
  int v6; // r9d
  int v7; // edi
  unsigned __int64 n0x200000; // rax
  volatile signed __int64 *v9; // rbx
  int v10; // esi
  __int64 v11; // r8
  unsigned __int64 v12; // rax
  __int64 v13; // rdx
  int v14; // eax
  __int64 v15; // [rsp+30h] [rbp-48h]
  int v16; // [rsp+48h] [rbp-30h] BYREF
  int v17; // [rsp+80h] [rbp+8h] BYREF
  __int64 v18; // [rsp+88h] [rbp+10h] BYREF

  v3 = *(__int64 **)(a1 + 0x10);
  v18 = a2;
  v5 = *v3;
  v6 = *((unsigned __int8 *)v3 + 0xC);
  v7 = *(_DWORD *)(*(_QWORD *)(*v3 + 0x80) + 4 * a2);
  v17 = v7;
  n0x200000 = sub_145E3B8B0(v5, v7, a3, v6, (__int64)(v3 + 2));
  if ( !(_BYTE)n0x200000 )
  {
    v15 = v3[5];
    v9 = (volatile signed __int64 *)(v15 + 0x18);
    v16 = 1;
    v10 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v15 + 0x28) == v10 )
    {
      ++*(_DWORD *)(v15 + 0x2C);
    }
    else
    {
      v11 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v12 = _InterlockedCompareExchange64(v9, 0x200000, 0);
      if ( v12 )
        sub_1403E1120((__int64)v9, v12, v11, (const char *)&p_Src, (const char *)&p_Src, 1);
      else
        *(_QWORD *)(v15 + 0x20) = v11;
      v7 = v17;
      *(_DWORD *)(v15 + 0x28) = v10;
    }
    v13 = *(_QWORD *)(v15 + 8);
    if ( v13 == *(_QWORD *)(v15 + 0x10) )
    {
      sub_1413B5210((__int64 *)v15, (_BYTE *)v13, &v18, &v17);
    }
    else
    {
      *(_QWORD *)v13 = a2;
      *(_DWORD *)(v13 + 8) = v7;
      *(_QWORD *)(v15 + 8) += 0x10LL;
    }
    n0x200000 = (unsigned __int64)&v16;
    if ( !--v16 )
    {
      v14 = *(_DWORD *)(v15 + 0x2C);
      if ( v14 )
      {
        n0x200000 = (unsigned int)(v14 - 1);
        *(_DWORD *)(v15 + 0x2C) = n0x200000;
      }
      else
      {
        *(_DWORD *)(v15 + 0x28) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64(v9, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
          *(_QWORD *)(v15 + 0x20) = &p_Src;
        else
          return (unsigned __int64)rw_lock_handle_write_release_contention((__int64)v9, n0x200000);
      }
    }
  }
  return n0x200000;
}

// --- End Function: sub_145E09110 (0x145E09110) ---

// --- Function: sub_145E0A310 (0x145E0A310) ---
void __fastcall sub_145E0A310(
        int a1,
        unsigned __int64 (__fastcall **a2)(__int64 a1, __int64 a2, int a3),
        unsigned __int64 (__fastcall **a3)(__int64 a1, __int64 a2, int a3))
{
  int v4; // ecx
  unsigned __int64 (__fastcall *v5)(__int64, __int64, int); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( !a1 )
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64, int))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64, int))1;
        __asm { vzeroupper }
        return;
      }
      v6 = sub_1402A65A0(0x30u);
      v7 = v6;
      if ( v6 )
      {
        *(__m256i *)v6 = *(__m256i *)v5;
        *(_OWORD *)(v6 + 0x20) = *((_OWORD *)v5 + 2);
      }
      else
      {
        v7 = 0;
      }
      a2[2] = (unsigned __int64 (__fastcall *)(__int64, __int64, int))v7;
      *a2 = sub_145E09110;
      a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64, int))sub_145E0A310;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      sub_1402A6590((__int64)a2[2]);
      a2[2] = 0;
      *a2 = 0;
      a2[1] = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64, int))1 )
  {
    a2[2] = 0;
    *a2 = *a3;
    a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64, int))1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    a2[2] = a3[2];
    *a2 = *a3;
    a2[1] = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_145E0A310 (0x145E0A310) ---

// --- Function: sub_145E0FED0 (0x145E0FED0) ---
void __fastcall sub_145E0FED0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int128 *a5, float *a6, __int64 *a7)
{
  __int128 v7; // xmm6
  bool v11; // zf
  __int64 *v12; // r14
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rsi
  float v16; // xmm6_4
  __int128 v17; // xmm1
  float v18; // xmm2_4
  __m128 v19; // kr00_16
  float v20; // xmm1_4
  float v23; // kr00_4
  __m128 v24; // xmm2
  float v25; // xmm5_4
  float v26; // xmm4_4
  float v27; // xmm0_4
  double v28; // xmm0_8
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rcx
  _QWORD *v32; // rdi
  _QWORD *v33; // rbx
  __int64 v34; // rcx
  __int64 v35; // rax
  unsigned __int64 v36; // [rsp+20h] [rbp-71h] BYREF
  _QWORD v37[4]; // [rsp+30h] [rbp-61h] BYREF
  __int128 v38; // [rsp+50h] [rbp-41h]
  __int64 v39; // [rsp+60h] [rbp-31h]
  float v40; // [rsp+68h] [rbp-29h]
  float v41; // [rsp+6Ch] [rbp-25h]
  float v42; // [rsp+70h] [rbp-21h]
  double v43; // [rsp+74h] [rbp-1Dh]
  int v44; // [rsp+7Ch] [rbp-15h]
  int v45; // [rsp+80h] [rbp-11h]
  char v46; // [rsp+84h] [rbp-Dh]
  __int64 v47; // [rsp+88h] [rbp-9h]
  __int128 v48; // [rsp+90h] [rbp-1h]
  __int128 v49; // [rsp+B0h] [rbp+1Fh]
  unsigned __int64 v50; // [rsp+E0h] [rbp+4Fh] BYREF

  (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)qword_149C8DFC0 + 0x120LL))(
    qword_149C8DFC0,
    &v36,
    a4);
  v11 = *(_DWORD *)(a1 + 8) == 0;
  v50 = v36;
  if ( v11
    || is_entity_descriptor_valid_or_accessible(&v50)
    && (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v50 & 0xFFFFFFFFFFFFLL) + 0x720LL))(v50 & 0xFFFFFFFFFFFFLL)
    && *(_DWORD *)(a1 + 8) == 1 )
  {
    if ( sub_1465E68E0(qword_149FBE618) )
    {
      v12 = a7;
      if ( a7 )
      {
        v13 = sub_145DF96D0(a1);
        if ( v13 )
        {
          if ( *(_QWORD *)(v13 + 8) )
          {
            v14 = sub_142D408D0(a1);
            if ( !v14
              || (v15 = v14 + 0x198,
                  v49 = v7,
                  v16 = sub_1403B1500(v14 + 0x198, 2),
                  fabs(v16 - sub_1403BB1D0(v15)) >= 0.00000011920929) )
            {
              v48 = 0;
              v37[2] = 0;
              v17 = *a5;
              v39 = *((_QWORD *)a5 + 2);
              v38 = v17;
              v37[3] = 0;
              v19 = (__m128)*(unsigned int *)a6;
              v19.m128_f32[0] = (float)(*a6 * *a6) + (float)(a6[1] * a6[1]);
              v18 = v19.m128_f32[0];
              v20 = a6[2] * a6[2];
              v47 = 0;
              if ( (float)(v19.m128_f32[0] + v20) <= 0.00000011920929 )
              {
                v26 = *((float *)&src__4 + 1);
                v25 = *(float *)&dword_149A5E108;
                v27 = *(float *)&src__4;
              }
              else
              {
                v19.m128_f32[0] = v19.m128_f32[0] + v20;
                _XMM0 = _mm_shuffle_ps(v19, v19, 0);
                __asm { vrsqrtps xmm3, xmm0 }
                _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
                v23 = 1.5 - (float)((float)((float)(_XMM3.m128_f32[0] * (float)(v18 + v20)) * _XMM3.m128_f32[0]) * 0.5);
                v24 = (__m128)*(unsigned __int64 *)a6;
                _XMM3.m128_f32[0] = v23 * _XMM3.m128_f32[0];
                v25 = _XMM3.m128_f32[0] * a6[2];
                v26 = _mm_shuffle_ps(v24, v24, 0x55).m128_f32[0] * _XMM3.m128_f32[0];
                v27 = v24.m128_f32[0] * _XMM3.m128_f32[0];
              }
              v40 = v27;
              v28 = *(double *)a6;
              v44 = *((_DWORD *)a6 + 2);
              v29 = *v12;
              v41 = v26;
              v42 = v25;
              v43 = v28;
              v37[0] = a2;
              v37[1] = a4;
              v46 = 0;
              v45 = (*(__int64 (__fastcall **)(__int64 *))(v29 + 0x28))(v12);
              v30 = sub_1465E68E0(qword_149FBE618);
              sub_1465690E0(v30, v37);
              v31 = v47;
              if ( v47 )
              {
                v32 = (_QWORD *)v48;
                if ( v47 != (_QWORD)v48 )
                {
                  v33 = (_QWORD *)(v47 + 0x38);
                  do
                  {
                    v34 = v33[0xFFFFFFFE];
                    if ( v34 )
                    {
                      if ( ((*v33 - v34) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
                      {
                        if ( (unsigned __int64)(v34 - *(_QWORD *)(v34 - 8) - 8) > 0x1F )
                          goto LABEL_26;
                        v34 = *(_QWORD *)(v34 - 8);
                      }
                      sub_1402A6590(v34);
                      v33[0xFFFFFFFE] = 0;
                      v33[0xFFFFFFFF] = 0;
                      *v33 = 0;
                    }
                    v33 += 8;
                  }
                  while ( v33 + 0xFFFFFFF9 != v32 );
                  v31 = v47;
                }
                v35 = v31;
                if ( ((*((_QWORD *)&v48 + 1) - v31) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
                {
                  v31 = *(_QWORD *)(v31 - 8);
                  if ( (unsigned __int64)(v35 - v31 - 8) > 0x1F )
LABEL_26:
                    invalid_parameter_noinfo_noreturn();
                }
                sub_1402A6590(v31);
              }
            }
          }
        }
      }
    }
  }
}

// --- End Function: sub_145E0FED0 (0x145E0FED0) ---

// --- Function: sub_145E13690 (0x145E13690) ---
__int64 __fastcall sub_145E13690(__int64 a1, const char *a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rsi
  __int64 v7; // rdi
  char *String2; // [rsp+50h] [rbp+18h] BYREF

  CreateStringObjectFromString((void **)&String2, a2);
  v4 = qword_149FB17A0;
  v5 = qword_149FB1798;
  v6 = (qword_149FB17A0 - qword_149FB1798) >> 5;
  if ( v6 )
  {
    do
    {
      v7 = 0x20 * (v6 >> 1);
      if ( _stricmp(*(const char **)(v7 + v5), String2) >= 0 )
      {
        v6 >>= 1;
      }
      else
      {
        v5 += v7 + 0x20;
        v6 += 0xFFFFFFFFFFFFFFFFuLL - (v6 >> 1);
      }
    }
    while ( v6 );
    v4 = qword_149FB17A0;
  }
  if ( v5 != v4 && _stricmp(String2, *(const char **)v5) < 0 )
    v5 = qword_149FB17A0;
  sub_140373CC0(&String2);
  if ( v5 == qword_149FB17A0 )
  {
    sub_142C26720("Failed to spawn ammo '%s'! Unknown class or entity class not registered...", a2);
    sub_140364B00((_QWORD *)a1);
  }
  else
  {
    *(_OWORD *)a1 = *(_OWORD *)(v5 + 8);
    *(double *)(a1 + 0x10) = *(double *)(v5 + 0x18);
  }
  return a1;
}

// --- End Function: sub_145E13690 (0x145E13690) ---

// --- Function: sub_145E16690 (0x145E16690) ---
__int64 __fastcall sub_145E16690(__int64 a1, __int64 a2, double *a3)
{
  __int128 v3; // xmm6
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rcx
  _QWORD *v10; // r15
  double v11; // xmm1_8
  __int128 v13; // xmm0
  __int64 v16; // rdi
  __int64 v19; // rbx
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rbx
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  float v27; // xmm1_4
  double v29; // [rsp+20h] [rbp-E0h] BYREF
  double v30; // [rsp+28h] [rbp-D8h]
  double v31; // [rsp+30h] [rbp-D0h]
  _BYTE v32[16]; // [rsp+38h] [rbp-C8h] BYREF
  _BYTE v33[16]; // [rsp+48h] [rbp-B8h] BYREF
  _BYTE v34[16]; // [rsp+58h] [rbp-A8h] BYREF
  void *(__fastcall **v35)(AK::ReadBytesMem *__hidden, unsigned int); // [rsp+68h] [rbp-98h] BYREF
  __int128 v36; // [rsp+70h] [rbp-90h]
  double v37; // [rsp+80h] [rbp-80h]
  void *(__fastcall **v38)(AK::ReadBytesMem *__hidden, unsigned int); // [rsp+88h] [rbp-78h] BYREF
  __int128 v39; // [rsp+90h] [rbp-70h]
  double v40; // [rsp+A0h] [rbp-60h]
  void *(__fastcall **v41)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+A8h] [rbp-58h] BYREF
  void *(__fastcall **v42)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+C8h] [rbp-38h] BYREF
  void *(__fastcall **v43)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+E8h] [rbp-18h] BYREF
  void *(__fastcall **v44)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+108h] [rbp+8h] BYREF
  void *(__fastcall **v45)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+128h] [rbp+28h] BYREF
  void *(__fastcall **v46)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+148h] [rbp+48h] BYREF
  __int128 v47; // [rsp+170h] [rbp+70h]

  v7 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 0x18) + 0xE0LL) + 0x30LL))(*(_QWORD *)(*(_QWORD *)(a1 + 0x18) + 0xE0LL));
  sub_1403832E0(a2, v7, a1 + 0x60);
  v8 = sub_142D1A700(*(_QWORD *)(a1 + 0x18));
  if ( v8 )
  {
    v9 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL))(
           qword_149C8DF28,
           *(unsigned int *)(a1 + 0x28));
    if ( !v9 )
      v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x10LL))(qword_149C8DF28);
    (*(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)v9 + 0x170LL))(v9, &v29, a1 + 0xF8);
    v10 = *(_QWORD **)(v8 + 0x58);
    v35 = &off_1482C6B58;
    v11 = *(double *)(a2 + 0x18);
    v36 = *(_OWORD *)(a2 + 8);
    v37 = v11;
    if ( v10 )
    {
      _XMM2 = COERCE_UNSIGNED_INT64((v29 - *a3) * (v29 - *a3) + (v30 - a3[1]) * (v30 - a3[1]) + (v31 - a3[2])
                                                                                              * (v31 - a3[2]));
      v13 = *(_OWORD *)(a2 + 8);
      __asm { vmovddup xmm1, xmm2 }
      v47 = v3;
      __asm { vsqrtpd xmm6, xmm1 }
      *(_QWORD *)&_XMM1 = *(_QWORD *)(a2 + 0x18);
      v38 = &off_1482C6B58;
      v40 = *(double *)&_XMM1;
      v39 = v13;
      v16 = sub_14036EC80(&v45, 0);
      sub_140365980((__int64)v32, v10 + 1);
      __asm
      {
        vunpckhpd xmm6, xmm6, xmm6
        vcvtsd2ss xmm2, xmm6, xmm6
      }
      v19 = sub_1403B1510(v32);
      v20 = sub_14036EBA0(&v44, 0);
      v21 = sub_140383560(&v43, v20, v19);
      v22 = sub_1403C7810(&v42, v21, v16);
      sub_140365980((__int64)v33, v10 + 3);
      v23 = sub_1403B1510(v33);
      v24 = sub_1403832E0(&v41, v23, v22);
      sub_140387E70(&v35, v24);
      v41 = &off_1482B7538;
      v42 = &off_1482B7538;
      v43 = &off_1482B7538;
      v44 = &off_1482B7538;
      v45 = &off_1482B7538;
      sub_140365980((__int64)v34, v10 + 5);
      v25 = sub_1403B1510(v34);
      v26 = sub_1403C7810(&v46, &v35, v25);
      v36 = *(_OWORD *)(v26 + 8);
      LODWORD(v37) = *(_DWORD *)(v26 + 0x18);
      LODWORD(_XMM1) = *(_DWORD *)(v26 + 0x1C);
      v46 = &off_1482B7538;
      *((float *)&v37 + 1) = *(float *)&_XMM1;
      sub_14039E9D0(&v35, &v38);
    }
    v27 = *((float *)&v37 + 1);
    *(_OWORD *)(a2 + 8) = v36;
    *(float *)(a2 + 0x18) = *(float *)&v37;
    *(float *)(a2 + 0x1C) = v27;
  }
  sub_140387E70(a2, a1 + 0x88);
  sub_14039E990(a2);
  return a2;
}

// --- End Function: sub_145E16690 (0x145E16690) ---

// --- Function: sub_145E18010 (0x145E18010) ---
__int64 __fastcall sub_145E18010(_QWORD *a1, int a2)
{
  __int64 v2; // rbx
  int v5; // edx
  _DWORD *v6; // rcx
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // rax
  int n0x5300; // [rsp+30h] [rbp-58h] BYREF
  __int64 v12; // [rsp+34h] [rbp-54h]
  int v13; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v14; // [rsp+40h] [rbp-48h]
  unsigned __int64 v15; // [rsp+48h] [rbp-40h]
  __int64 v16; // [rsp+50h] [rbp-38h]
  __int64 v17; // [rsp+58h] [rbp-30h]

  v2 = 0;
  n0x5300 = 0x5300;
  v12 = 1;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = __rdtsc();
  qword_149C89AA0(
    &n0x5300,
    &word_149FB19C8,
    "CProjectileManager::GetPhysProjState",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileManager.cpp",
    0x2F6);
  v5 = 0;
  v6 = (_DWORD *)a1[0x1F];
  HIWORD(n0x5300) = word_149FB19C8;
  v7 = (__int64)(a1[0x20] - (_QWORD)v6) >> 2;
  if ( (int)v7 > 0 )
  {
    v8 = (int)v7;
    v9 = 0;
    while ( *v6 != a2 )
    {
      ++v5;
      ++v9;
      ++v6;
      if ( v9 >= v8 )
        goto LABEL_7;
    }
    v2 = a1[0x1C] + 0x30LL * v5;
  }
LABEL_7:
  v15 = __rdtsc();
  qword_149C89AA8(&n0x5300);
  return v2;
}

// --- End Function: sub_145E18010 (0x145E18010) ---

// --- Function: sub_145E2C090 (0x145E2C090) ---
void __fastcall sub_145E2C090(int a1, __int64 a2, const char *a3, const char *a4)
{
  __int64 v8; // rdi
  __int64 v9; // rax
  __m256 v10; // ymm1
  __int128 v11; // xmm0
  unsigned int event_key_from_source_location; // esi
  void (__fastcall *v13)(__int64, _QWORD, __int64 (__fastcall **)()); // r14
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 (__fastcall *p_sub_1416DD870)(); // [rsp+20h] [rbp-E0h] BYREF
  __int64 (__fastcall *p_sub_145E09920)(); // [rsp+28h] [rbp-D8h]
  __int64 v18; // [rsp+30h] [rbp-D0h]
  void *v19; // [rsp+40h] [rbp-C0h] BYREF
  void *v20; // [rsp+48h] [rbp-B8h] BYREF
  int v21; // [rsp+50h] [rbp-B0h]
  __m256 v22; // [rsp+58h] [rbp-A8h]
  __int128 v23; // [rsp+78h] [rbp-88h]
  double v24; // [rsp+88h] [rbp-78h]
  void *v25; // [rsp+90h] [rbp-70h] BYREF
  void *v26; // [rsp+98h] [rbp-68h] BYREF
  int v27; // [rsp+A0h] [rbp-60h]
  __m256 v28; // [rsp+A8h] [rbp-58h]
  __int128 v29; // [rsp+C8h] [rbp-38h]
  double v30; // [rsp+D8h] [rbp-28h]
  unsigned int event_key_from_source_location_1; // [rsp+E0h] [rbp-20h]
  __int64 v32; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v33[9]; // [rsp+F0h] [rbp-10h] BYREF
  unsigned int event_key_from_source_location_2; // [rsp+138h] [rbp+38h]

  v8 = 0;
  v9 = sub_1465E6760(qword_149FBE618);
  if ( v9 )
    v8 = *(_QWORD *)(v9 + 0x10);
  if ( v8 )
  {
    CreateStringObjectFromString(&v19, a3);
    CreateStringObjectFromString(&v20, a4);
    v10 = *(__m256 *)a2;
    v11 = *(_OWORD *)(a2 + 0x20);
    event_key_from_source_location = event_key_from_source_location_9;
    v21 = a1;
    v22 = v10;
    v24 = *(double *)(a2 + 0x30);
    v23 = v11;
    if ( !event_key_from_source_location_9 )
    {
      __asm { vzeroupper }
      event_key_from_source_location = get_event_key_from_source_location(
                                         &event_key_from_source_location_9,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Recording\\CombatLoggingEvents.h",
                                         0x5A);
    }
    v13 = *(void (__fastcall **)(__int64, _QWORD, __int64 (__fastcall **)()))(*(_QWORD *)v8 + 0x20LL);
    __asm { vzeroupper }
    sub_14035DE10(&v25, (const void **)&v19);
    sub_14035DE10(&v26, (const void **)&v20);
    v28 = v22;
    v27 = v21;
    v30 = v24;
    v29 = v23;
    event_key_from_source_location_1 = event_key_from_source_location;
    __asm { vzeroupper }
    sub_145E025D0(&v32, &v25);
    event_key_from_source_location_2 = event_key_from_source_location_1;
    v14 = sub_1402A65A0(0x58u);
    v15 = v14;
    if ( v14 )
    {
      sub_145E025D0(v14, &v32);
      *(_DWORD *)(v15 + 0x50) = event_key_from_source_location_2;
      v18 = v15;
    }
    else
    {
      v18 = 0;
    }
    p_sub_1416DD870 = sub_1416DD870;
    p_sub_145E09920 = sub_145E09920;
    sub_140373CC0(v33);
    sub_140373CC0(&v32);
    sub_140373CC0(&v26);
    sub_140373CC0(&v25);
    v13(v8, event_key_from_source_location, &p_sub_1416DD870);
    if ( (unsigned __int64)p_sub_145E09920 >= 2 )
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))p_sub_145E09920)(2, &p_sub_1416DD870);
    sub_140373CC0(&v20);
    sub_140373CC0(&v19);
  }
}

// --- End Function: sub_145E2C090 (0x145E2C090) ---

// --- Function: sub_145E2DBD0 (0x145E2DBD0) ---
void __fastcall sub_145E2DBD0(unsigned int a1)
{
  __int64 v1; // rbp
  __int64 v2; // rax
  __int64 v3; // rdi
  unsigned int event_key_from_source_location; // ebx
  void (__fastcall *v5)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)); // r14
  _QWORD *v6; // rax
  __int64 (__fastcall *p_sub_14049CE70)(__int64, __int64); // [rsp+20h] [rbp-28h] BYREF
  void (__fastcall *p_sub_14049D9C0)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+28h] [rbp-20h]
  _QWORD *v9; // [rsp+30h] [rbp-18h]

  v1 = a1;
  if ( byte_149FB1604 )
  {
    v2 = sub_1465E6760(qword_149FBE618);
    if ( v2 )
    {
      v3 = *(_QWORD *)(v2 + 0x10);
      if ( v3 )
      {
        event_key_from_source_location = event_key_from_source_location_10;
        if ( !event_key_from_source_location_10 )
          event_key_from_source_location = get_event_key_from_source_location(
                                             &event_key_from_source_location_10,
                                             (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Recording\\CombatLoggingEvents.h",
                                             0x1C);
        v5 = *(void (__fastcall **)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)))(*(_QWORD *)v3 + 0x20LL);
        v6 = (_QWORD *)sub_1402A65A0(8u);
        if ( v6 )
        {
          *v6 = v1 | ((unsigned __int64)event_key_from_source_location << 0x20);
          v9 = v6;
        }
        else
        {
          v9 = 0;
        }
        p_sub_14049CE70 = sub_14049CE70;
        p_sub_14049D9C0 = sub_14049D9C0;
        v5(v3, event_key_from_source_location, &p_sub_14049CE70);
        if ( (unsigned __int64)p_sub_14049D9C0 >= 2 )
          ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))p_sub_14049D9C0)(
            2,
            &p_sub_14049CE70);
      }
    }
  }
}

// --- End Function: sub_145E2DBD0 (0x145E2DBD0) ---

// --- Function: sub_145E2ED90 (0x145E2ED90) ---
const ULONG_PTR *__fastcall sub_145E2ED90(__int64 a1)
{
  int v2; // edi
  unsigned int v3; // eax
  __int64 v4; // rcx
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 v8; // rcx
  int v9; // eax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int32 v11; // eax

  v2 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v2 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v3 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v3 )
      sub_1403C6E80(a1, v3, (__int64)"CProjectileManager::SProjectile::Reset", 1);
    else
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x10) = v2;
  }
  v4 = *(_QWORD *)(a1 + 0x30);
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x10LL))(v4);
  *(_QWORD *)(a1 + 0x30) = 0;
  v5 = *(_QWORD *)(a1 + 0xA8);
  v6 = *(_QWORD *)(a1 + 0xB0);
  if ( v5 != v6 )
  {
    do
    {
      sub_144095910(v5);
      v5 += 0x40;
    }
    while ( v5 != v6 );
    *(_QWORD *)(a1 + 0xB0) = *(_QWORD *)(a1 + 0xA8);
  }
  v7 = *(_QWORD *)(a1 + 0x190);
  if ( v7 != *(_QWORD *)(a1 + 0x198) )
    *(_QWORD *)(a1 + 0x198) = v7;
  v8 = *(_QWORD *)(a1 + 0x1A8);
  if ( v8 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)(v8 + 0x30) + 0x10LL))(v8 + 0x30);
  *(_QWORD *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1D0) = 0;
  v9 = *(_DWORD *)(a1 + 0x14);
  if ( v9 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v9 - 1);
    *(_DWORD *)(a1 + 0x14) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    v11 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
    if ( v11 == 1 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(a1 + 8) = &p_Src;
    }
    else
    {
      return sub_1403DF590(a1, v11);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_145E2ED90 (0x145E2ED90) ---

// --- Function: sub_145E34640 (0x145E34640) ---
__int64 __fastcall sub_145E34640(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        double *a4,
        __int64 a5,
        __int64 a6,
        char a7,
        unsigned __int8 a8)
{
  __int128 v8; // xmm6
  __int128 v9; // xmm7
  __int128 v10; // xmm8
  __int128 v11; // xmm9
  __int128 v12; // xmm10
  __int128 v13; // xmm11
  __int128 v14; // xmm12
  __int128 v15; // xmm13
  __int128 v16; // xmm14
  __int128 v17; // xmm15
  int v18; // edi
  int v19; // r13d
  __int64 v20; // r14
  __int64 v23; // rax
  __int64 v24; // rsi
  _QWORD *v25; // rcx
  __int64 *v26; // rbx
  const ULONG_PTR *v27; // rbx
  __int64 v28; // rax
  __int64 v29; // r12
  __int64 v30; // rcx
  int v31; // r8d
  unsigned __int64 v32; // rbx
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // rcx
  float *v39; // rax
  double v43; // xmm4_8
  double v44; // xmm5_8
  double v49; // xmm6_8
  double v51; // xmm7_8
  double v52; // kr00_8
  double v53; // xmm5_8
  __int128 v54; // xmm8
  __int128 v55; // xmm9
  __int128 v56; // kr00_16
  double v64; // xmm4_8
  double v66; // xmm0_8
  __int128 v67; // xmm1
  double v68; // xmm7_8
  double v69; // xmm6_8
  double v70; // xmm4_8
  __int128 v71; // kr00_16
  double v72; // xmm5_8
  __int128 v77; // kr00_16
  double v78; // xmm1_8
  __int64 v79; // rax
  __int64 v84; // rax
  __int64 v85; // rcx
  __int64 *v86; // rax
  __int64 v87; // rcx
  __int64 v88; // rdx
  volatile signed __int32 *v89; // rdi
  volatile signed __int32 *v90; // rdi
  double v91; // xmm1_8
  __int64 v92; // rdi
  __int64 *v93; // rax
  __int64 v94; // rax
  __int64 v96; // [rsp+30h] [rbp-D0h]
  __int64 v97; // [rsp+38h] [rbp-C8h]
  int v98; // [rsp+40h] [rbp-C0h]
  int n0x5300; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v100; // [rsp+54h] [rbp-ACh]
  int v101; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v102; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v103; // [rsp+68h] [rbp-98h]
  __int64 v104; // [rsp+70h] [rbp-90h]
  __int64 v105; // [rsp+78h] [rbp-88h]
  _QWORD v106[2]; // [rsp+A0h] [rbp-60h] BYREF
  _QWORD v107[2]; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v108; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v109; // [rsp+C8h] [rbp-38h] BYREF
  _BYTE v110[8]; // [rsp+D0h] [rbp-30h] BYREF
  _BYTE v111[8]; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v112; // [rsp+E0h] [rbp-20h] BYREF
  _BYTE v113[8]; // [rsp+E8h] [rbp-18h] BYREF
  volatile signed __int32 *v114; // [rsp+F0h] [rbp-10h]
  char v115; // [rsp+F8h] [rbp-8h] BYREF
  __int128 v116; // [rsp+110h] [rbp+10h] BYREF
  __int64 v117; // [rsp+120h] [rbp+20h]
  unsigned __int64 v118; // [rsp+128h] [rbp+28h]
  _BYTE v119[56]; // [rsp+130h] [rbp+30h] BYREF
  __int64 v120; // [rsp+168h] [rbp+68h]
  _BYTE v121[56]; // [rsp+170h] [rbp+70h] BYREF
  __int64 v122; // [rsp+1A8h] [rbp+A8h]
  __int64 v123; // [rsp+1B0h] [rbp+B0h]
  __int128 v124; // [rsp+1B8h] [rbp+B8h]
  double v125; // [rsp+1C8h] [rbp+C8h]
  float v126; // [rsp+1D0h] [rbp+D0h]
  float v127; // [rsp+1D4h] [rbp+D4h]
  float v128; // [rsp+1D8h] [rbp+D8h]
  float v129; // [rsp+1DCh] [rbp+DCh]
  __int64 v130; // [rsp+1E0h] [rbp+E0h]
  __int64 v131; // [rsp+1F0h] [rbp+F0h] BYREF
  __int64 v132; // [rsp+1F8h] [rbp+F8h]
  void *(__fastcall **v133)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+200h] [rbp+100h]
  __int128 v134; // [rsp+208h] [rbp+108h]
  __int64 v135; // [rsp+218h] [rbp+118h]
  int v136; // [rsp+220h] [rbp+120h]
  const void *v137; // [rsp+228h] [rbp+128h] BYREF
  const void *v138; // [rsp+230h] [rbp+130h] BYREF
  int v139; // [rsp+238h] [rbp+138h]
  int v140; // [rsp+23Ch] [rbp+13Ch]
  __int128 v141; // [rsp+240h] [rbp+140h]
  int v142; // [rsp+250h] [rbp+150h]
  char v143; // [rsp+254h] [rbp+154h]
  char v144; // [rsp+255h] [rbp+155h]
  char v145; // [rsp+256h] [rbp+156h]
  char v146; // [rsp+257h] [rbp+157h]
  char v147; // [rsp+258h] [rbp+158h]
  char v148; // [rsp+259h] [rbp+159h]
  unsigned __int8 v149; // [rsp+25Ah] [rbp+15Ah]
  __int128 v150; // [rsp+260h] [rbp+160h]
  __int64 v151; // [rsp+270h] [rbp+170h]
  _QWORD v152[3]; // [rsp+280h] [rbp+180h] BYREF
  __int128 v153; // [rsp+298h] [rbp+198h]
  __int64 v154; // [rsp+2A8h] [rbp+1A8h]
  int v155; // [rsp+2B0h] [rbp+1B0h]
  void *v156; // [rsp+2B8h] [rbp+1B8h] BYREF
  void *v157; // [rsp+2C0h] [rbp+1C0h] BYREF
  int v158; // [rsp+2C8h] [rbp+1C8h]
  int v159; // [rsp+2CCh] [rbp+1CCh]
  __int128 v160; // [rsp+2D0h] [rbp+1D0h]
  int v161; // [rsp+2E0h] [rbp+1E0h]
  char v162; // [rsp+2E4h] [rbp+1E4h]
  char v163; // [rsp+2E5h] [rbp+1E5h]
  char v164; // [rsp+2E6h] [rbp+1E6h]
  char v165; // [rsp+2E7h] [rbp+1E7h]
  char v166; // [rsp+2E8h] [rbp+1E8h]
  char v167; // [rsp+2E9h] [rbp+1E9h]
  unsigned __int8 v168; // [rsp+2EAh] [rbp+1EAh]
  __int128 v169; // [rsp+2F0h] [rbp+1F0h]
  __int64 v170; // [rsp+300h] [rbp+200h]
  _BYTE v171[56]; // [rsp+310h] [rbp+210h] BYREF
  __int64 v172; // [rsp+348h] [rbp+248h] BYREF
  _QWORD v173[8]; // [rsp+350h] [rbp+250h] BYREF
  __int64 v174; // [rsp+390h] [rbp+290h]
  __int64 v175; // [rsp+398h] [rbp+298h]
  _BYTE v176[216]; // [rsp+3A0h] [rbp+2A0h] BYREF
  double v177; // [rsp+478h] [rbp+378h]
  double v178; // [rsp+480h] [rbp+380h]
  double v179; // [rsp+488h] [rbp+388h]
  double v180; // [rsp+490h] [rbp+390h]
  __int128 v181; // [rsp+498h] [rbp+398h]
  double v182; // [rsp+4A8h] [rbp+3A8h]
  __int128 v183; // [rsp+4C0h] [rbp+3C0h]
  __int128 v184; // [rsp+4D0h] [rbp+3D0h]
  __int128 v185; // [rsp+4E0h] [rbp+3E0h]
  __int128 v186; // [rsp+4F0h] [rbp+3F0h]
  __int128 v187; // [rsp+500h] [rbp+400h]
  __int128 v188; // [rsp+510h] [rbp+410h]
  __int128 v189; // [rsp+520h] [rbp+420h]
  __int128 v190; // [rsp+530h] [rbp+430h]
  __int128 v191; // [rsp+540h] [rbp+440h]
  __int128 v192; // [rsp+550h] [rbp+450h]
  unsigned __int64 v193; // [rsp+5A8h] [rbp+4A8h] BYREF
  unsigned __int64 v194; // [rsp+5B0h] [rbp+4B0h] BYREF

  v194 = a3;
  v193 = a2;
  v18 = a5;
  v19 = 0;
  v20 = a6;
  v98 = a5;
  v101 = 0;
  v103 = 0;
  v104 = 0;
  v105 = 0;
  n0x5300 = 0x5300;
  v100 = 1;
  v102 = __rdtsc();
  qword_149C89AA0(
    &n0x5300,
    &word_149FB19E0,
    "ProjectileUtils::SpawnAdditionalProjectiles",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileUtils.cpp",
    0x3F0);
  HIWORD(n0x5300) = word_149FB19E0;
  v23 = sub_142D1A700(a1);
  if ( v23 )
  {
    sub_140365980((__int64)v106, (_QWORD *)(v23 + 0x110));
    v24 = v106[0];
    v25 = v106;
  }
  else
  {
    sub_140365990((__int64)v107);
    v25 = v107;
    v107[0] = 0;
    v24 = 0;
  }
  sub_140373E10((__int64)v25);
  if ( v20 && v24 && *(_QWORD *)(v24 + 0x18) )
  {
    v26 = sub_1403B7660(v24 + 8);
    v27 = (unsigned __int64)sub_1403EBE30(v26) <= 0xA ? &p_Src : (const ULONG_PTR *)(*v26 + 0xB);
    v28 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
    v96 = (*(__int64 (__fastcall **)(__int64, const ULONG_PTR *))(*(_QWORD *)v28 + 0x20LL))(v28, v27);
    if ( v96 )
    {
      v29 = *(_QWORD *)(v24 + 0x28);
      v97 = *(_QWORD *)(v24 + 0x18);
      sub_145E02C00(&v131);
      v131 = *sub_1403B43F0(&v193, &v108);
      v30 = *sub_1403B43F0(&v194, &v109);
      v145 = a7;
      v149 = a8;
      v32 = 0x343FDLL * a8 + 0x269EC3;
      v132 = v30;
      v140 = v32 >> 0x10;
      if ( *(int *)(v24 + 0x20) > 0 )
      {
        v192 = v8;
        v191 = v9;
        v190 = v10;
        v189 = v11;
        v188 = v12;
        v187 = v13;
        v186 = v14;
        v185 = v15;
        v184 = v16;
        v183 = v17;
        do
        {
          v33 = 0x343FD * v32 + 0x269EC3;
          v32 = 0x343FD * v33 + 0x269EC3;
          v139 = v33 >> 0x10;
          v34 = v32 >> 0x10;
          if ( v29 )
          {
            v32 = 0x343FD * v32 + 0x269EC3;
            _XMM0 = 0;
            __asm { vcmpltss xmm1, xmm0, xmm3 }
            _XMM0 = HIDWORD(v141);
            __asm { vblendvps xmm1, xmm0, xmm3, xmm1 }
            *((float *)&v141 + 3) = *(float *)&_XMM1;
          }
          v39 = (float *)sub_145AC9370((unsigned int)&v115, v18, v31, 0xFFFFFFFF, v34);
          _XMM8 = 0x3FE6A09E60000000uLL;
          _XMM7 = 0;
          _XMM10 = 0;
          v43 = *v39;
          v44 = v39[1];
          _XMM1 = COERCE_UNSIGNED_INT64(v44 * v44 + v43 * v43);
          __asm
          {
            vmovddup xmm2, xmm1
            vsqrtpd xmm3, xmm2
            vunpckhpd xmm3, xmm3, xmm3
          }
          v49 = v39[2];
          _XMM9 = COERCE_UNSIGNED_INT64(v49 * 0.7071067690849304);
          if ( *(double *)&_XMM3 > 0.00001 )
          {
            v51 = 1.0 / *(double *)&_XMM3 * v43;
            v52 = 1.0 / *(double *)&_XMM3 * v44;
            v53 = -1.0;
            v54 = COERCE_UNSIGNED_INT64(v52 + 1.0);
            *((_QWORD *)&v56 + 1) = *((_QWORD *)&_XMM3 + 1);
            *(double *)&v56 = *(double *)&_XMM3 + 1.0;
            v55 = v56;
            *((_QWORD *)&v56 + 1) = *((_QWORD *)&v54 + 1);
            *(double *)&v56 = *(double *)&v54 * *(double *)&v54 + v51 * v51;
            _XMM1 = v56;
            __asm { vmovddup xmm2, xmm1 }
            *((_QWORD *)&v56 + 1) = *((_QWORD *)&v55 + 1);
            __asm { vsqrtpd xmm3, xmm2 }
            *(double *)&v56 = *(double *)&v55 * *(double *)&v55 + v49 * v49;
            _XMM1 = v56;
            __asm { vunpckhpd xmm3, xmm3, xmm3 }
            __asm
            {
              vmovddup xmm2, xmm1
              vsqrtpd xmm1, xmm2
            }
            v64 = 0.0;
            if ( *(double *)&_XMM3 != 0.0 )
            {
              v64 = 1.0 / *(double *)&_XMM3 * *(double *)&v54;
              v53 = -(1.0 / *(double *)&_XMM3 * v51);
            }
            __asm { vunpckhpd xmm1, xmm1, xmm1 }
            v66 = 1.0 / *(double *)&_XMM1;
            v67 = COERCE_UNSIGNED_INT64(1.0 / *(double *)&_XMM1 * v49);
            v68 = *(double *)&v67 * v53;
            v69 = v66 * *(double *)&v55 * v64;
            *((_QWORD *)&v71 + 1) = *((_QWORD *)&v67 + 1);
            v70 = *(double *)&v67 * v64;
            v72 = v66 * *(double *)&v55 * v53;
            *(double *)&v71 = v70 * v70 + v69 * v69 + v72 * v72 + v68 * v68;
            _XMM1 = v71;
            if ( *(double *)&v71 <= 0.00000000999999993922529 )
            {
              _XMM8 = 0x3FF0000000000000uLL;
              _XMM9 = 0;
              _XMM7 = 0;
              _XMM10 = 0;
            }
            else
            {
              __asm
              {
                vmovddup xmm0, xmm1
                vsqrtpd xmm1, xmm0
                vunpckhpd xmm1, xmm1, xmm1
              }
              _XMM8 = COERCE_UNSIGNED_INT64(1.0 / *(double *)&_XMM1 * v69);
              *((_QWORD *)&v77 + 1) = 0;
              *(double *)&v77 = 1.0 / *(double *)&_XMM1 * v70;
              _XMM9 = v77;
              *((_QWORD *)&v77 + 1) = 0;
              *(double *)&v77 = 1.0 / *(double *)&_XMM1 * v68;
              _XMM7 = v77;
              *((_QWORD *)&v77 + 1) = 0;
              *(double *)&v77 = 1.0 / *(double *)&_XMM1 * v72;
              _XMM10 = v77;
            }
          }
          v78 = a4[2];
          v79 = *(_QWORD *)v20;
          v116 = 0;
          v124 = *(_OWORD *)a4;
          v125 = v78;
          __asm
          {
            vcvtsd2ss xmm0, xmm9, xmm9
            vcvtsd2ss xmm3, xmm8, xmm8
            vcvtsd2ss xmm1, xmm7, xmm7
            vcvtsd2ss xmm2, xmm10, xmm10
          }
          v118 = 0;
          v126 = *(float *)&_XMM0;
          v127 = *(float *)&_XMM1;
          v128 = *(float *)&_XMM2;
          v129 = *(float *)&_XMM3;
          v120 = 0;
          v122 = 0;
          v123 = 0;
          v130 = 0;
          if ( (*(__int64 (__fastcall **)(__int64))(v79 + 0x28))(v20) )
          {
            v84 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x28LL))(v20);
            v85 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v84 + 8LL))(v84, v110);
          }
          else
          {
            v85 = 0;
          }
          v123 = v85;
          v118 = v194;
          v86 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149C8DFC0 + 0x110LL))(
                             qword_149C8DFC0,
                             v113);
          v87 = *v86;
          v88 = v86[1];
          *v86 = 0;
          v86[1] = 0;
          v89 = (volatile signed __int32 *)*((_QWORD *)&v116 + 1);
          *(_QWORD *)&v116 = v87;
          *((_QWORD *)&v116 + 1) = v88;
          if ( v89 )
          {
            if ( _InterlockedExchangeAdd(v89 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v89)(v89);
              if ( _InterlockedExchangeAdd(v89 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v89 + 8LL))(v89);
            }
          }
          v90 = v114;
          if ( v114 )
          {
            if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v90)(v90);
              if ( _InterlockedExchangeAdd(v90 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v90 + 8LL))(v90);
            }
          }
          v117 = v96;
          v152[0] = v131;
          v152[1] = v132;
          v153 = v134;
          v152[2] = &off_1482C6B58;
          v155 = v136;
          v154 = v135;
          sub_14035DE10(&v156, &v137);
          sub_14035DE10(&v157, &v138);
          v158 = v139;
          v159 = v140;
          v161 = v142;
          v162 = v143;
          v163 = v144;
          v164 = v145;
          v165 = v146;
          v166 = v147;
          v167 = v148;
          v168 = v149;
          v170 = v151;
          v160 = v141;
          v169 = v150;
          if ( v151 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v151 + 8LL))(v151);
          sub_145DF8C70(v119, v152);
          if ( v170 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v170 + 0x10LL))(v170);
          v170 = 0;
          sub_140373CC0(&v157);
          sub_140373CC0(&v156);
          sub_145E02B10(v171, &v131);
          v175 = v97;
          sub_1457C64D0(v176, &v116);
          v91 = a4[2];
          v181 = *(_OWORD *)a4;
          v182 = v91;
          v180 = *(double *)&_XMM8;
          v177 = *(double *)&_XMM9;
          v178 = *(double *)&_XMM7;
          v179 = *(double *)&_XMM10;
          sub_145DF8E00(v121, v171);
          sub_142D2CB70(v176);
          if ( v174 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v174 + 0x10LL))(v174);
          v174 = 0;
          sub_140373CC0(v173);
          sub_140373CC0(&v172);
          v92 = v116;
          if ( is_entity_descriptor_valid_or_accessible(&v193) )
            v93 = (__int64 *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)(v193 & 0xFFFFFFFFFFFFLL)
                                                                                  + 8LL))(
                               v193 & 0xFFFFFFFFFFFFLL,
                               v111);
          else
            v93 = sub_1403B43F0(&v194, &v112);
          JsonNode::SetInt(v92, (__int64)"proj_ownerId", v93);
          sub_145DFA460(v116, "proj_launchParams", &v131);
          v94 = sub_1418215F0(qword_149FBE618);
          sub_145862000(v94, &v116);
          sub_142D2CB70(&v116);
          v18 = v98;
          ++v19;
        }
        while ( v19 < *(_DWORD *)(v24 + 0x20) );
      }
      if ( v151 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v151 + 0x10LL))(v151);
      v151 = 0;
      sub_140373CC0(&v138);
      sub_140373CC0(&v137);
      v133 = &off_1482B7538;
    }
  }
  v103 = __rdtsc();
  return qword_149C89AA8(&n0x5300);
}

// --- End Function: sub_145E34640 (0x145E34640) ---

// --- Function: sub_145E37120 (0x145E37120) ---
__int64 __fastcall sub_145E37120(
        __int64 a1,
        double *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        char a7,
        double *a8)
{
  __int128 v8; // xmm6
  __int128 v9; // xmm7
  __int128 v10; // xmm8
  __int128 v11; // xmm9
  __int128 v12; // xmm10
  __int128 v13; // xmm11
  __int128 v14; // xmm12
  __int128 v15; // xmm13
  __int128 v16; // xmm14
  __int128 v17; // xmm15
  __int64 v22; // r12
  double v23; // xmm7_8
  double v24; // xmm8_8
  double v25; // xmm9_8
  double v26; // xmm10_8
  double v27; // xmm11_8
  double v28; // xmm12_8
  double v29; // xmm13_8
  double v30; // xmm14_8
  double v31; // xmm15_8
  double v32; // xmm2_8
  double v33; // xmm1_8
  double v34; // xmm2_8
  __int128 v35; // xmm6
  double v36; // xmm10_8
  double v38; // xmm12_8
  __int128 v41; // kr00_16
  double v44; // xmm7_8
  __int128 v60; // kr00_16
  __int128 v65; // xmm7
  double v66; // xmm3_8
  __int128 v67; // kr00_16
  __int128 v69; // xmm9
  __int64 v71; // rax
  __int64 v72; // rax
  __int64 v73; // r15
  __int64 v74; // rax
  __int128 v76; // kr00_16
  float v82; // kr00_4
  __int64 v83; // rax
  __int64 v84; // rax
  unsigned int event_key_from_source_location; // ebx
  __int64 v86; // rdi
  void (__fastcall *v87)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)); // rsi
  _QWORD *v88; // rax
  unsigned __int8 v89; // bl
  double v91; // [rsp+38h] [rbp-D0h]
  __int64 v92; // [rsp+38h] [rbp-D0h]
  double v93; // [rsp+40h] [rbp-C8h]
  double v94; // [rsp+40h] [rbp-C8h]
  double v95; // [rsp+48h] [rbp-C0h]
  double v96; // [rsp+50h] [rbp-B8h]
  double v97; // [rsp+68h] [rbp-A0h]
  __int64 (__fastcall *p_sub_14049CE70)(__int64, __int64); // [rsp+70h] [rbp-98h] BYREF
  void (__fastcall *p_sub_14049D9C0)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+78h] [rbp-90h]
  _QWORD *v100; // [rsp+80h] [rbp-88h]
  double v101; // [rsp+88h] [rbp-80h]
  __int64 v102; // [rsp+90h] [rbp-78h] BYREF
  __int64 v103; // [rsp+98h] [rbp-70h] BYREF
  int n0x5300; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v105; // [rsp+ACh] [rbp-5Ch]
  int v106; // [rsp+B4h] [rbp-54h]
  unsigned __int64 v107; // [rsp+B8h] [rbp-50h]
  unsigned __int64 v108; // [rsp+C0h] [rbp-48h]
  __int64 v109; // [rsp+C8h] [rbp-40h]
  __int64 v110; // [rsp+D0h] [rbp-38h]
  __m256 v111; // [rsp+F8h] [rbp-10h] BYREF
  __int128 v112; // [rsp+118h] [rbp+10h]
  double v113; // [rsp+128h] [rbp+20h]
  __int128 v114; // [rsp+138h] [rbp+30h]
  __int128 v115; // [rsp+148h] [rbp+40h]
  __int128 v116; // [rsp+158h] [rbp+50h]
  __int128 v117; // [rsp+168h] [rbp+60h]
  __int128 v118; // [rsp+178h] [rbp+70h]
  __int128 v119; // [rsp+188h] [rbp+80h]
  __int128 v120; // [rsp+198h] [rbp+90h]
  __int128 v121; // [rsp+1A8h] [rbp+A0h]
  __int128 v122; // [rsp+1B8h] [rbp+B0h]
  __int128 v123; // [rsp+1C8h] [rbp+C0h]

  v123 = v8;
  v122 = v9;
  v121 = v10;
  v120 = v11;
  v119 = v12;
  v118 = v13;
  v117 = v14;
  v116 = v15;
  v115 = v16;
  v114 = v17;
  n0x5300 = 0x5300;
  v105 = 1;
  v106 = 0;
  v108 = 0;
  v109 = 0;
  v110 = 0;
  v107 = __rdtsc();
  qword_149C89AA0(
    &n0x5300,
    &word_149FB19DC,
    "ProjectileUtils::TryWhizSound",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileUtils.cpp",
    0x340);
  HIWORD(n0x5300) = word_149FB19DC;
  if ( BYTE1(qword_149C8E516) )
    goto LABEL_30;
  if ( a7 )
    goto LABEL_30;
  v22 = a3 + 0x48;
  if ( !sub_1403C4E50(a3 + 0x48) )
    goto LABEL_30;
  if ( (*(_QWORD *)a8 & 0x7FF0000000000000LL) == 0x7FF0000000000000LL )
    goto LABEL_30;
  if ( ((_QWORD)a8[1] & 0x7FF0000000000000LL) == 0x7FF0000000000000LL )
    goto LABEL_30;
  if ( ((_QWORD)a8[2] & 0x7FF0000000000000LL) == 0x7FF0000000000000LL )
    goto LABEL_30;
  v23 = a2[1];
  v24 = *(double *)(a1 + 0x28);
  v25 = *a2;
  v26 = *(double *)(a1 + 0x20);
  v27 = a2[2];
  v28 = *(double *)(a1 + 0x30);
  v29 = v23 - v24;
  v30 = *a2 - v26;
  v31 = v27 - v28;
  if ( v30 * v30 + v29 * v29 + v31 * v31 < 0.0000001192092895507812 )
    goto LABEL_30;
  v93 = v24 - v23;
  v91 = v28 - v27;
  v96 = v26 - v25;
  v32 = (v23 - a8[1]) * (v24 - v23) + (v25 - *a8) * (v26 - v25) + (v27 - a8[2]) * (v28 - v27);
  if ( v32 * v32
     - ((v24 - a8[1]) * (v24 - a8[1])
      + (v26 - *a8) * (v26 - *a8)
      + (v28 - a8[2]) * (v28 - a8[2])
      - (float)(*(float *)(a3 + 0x68) * *(float *)(a3 + 0x68)))
     * ((v24 - v23) * (v24 - v23) + (v26 - v25) * (v26 - v25) + (v28 - v27) * (v28 - v27)) < 0.0 )
    goto LABEL_30;
  v33 = a8[1];
  v34 = a8[2];
  v35 = COERCE_UNSIGNED_INT64(v33 - v24);
  v36 = *a8 - v26;
  _XMM8 = COERCE_UNSIGNED_INT64(v33 - v23);
  v38 = v34 - v28;
  _XMM5 = COERCE_UNSIGNED_INT64(v34 - v27);
  _XMM4 = COERCE_UNSIGNED_INT64(*a8 - v25);
  if ( v36 * v30 + *(double *)&v35 * v29 + v38 * v31 <= 0.0
    || *(double *)&_XMM8 * v93 + *(double *)&_XMM4 * v96 + *(double *)&_XMM5 * v91 <= 0.0 )
  {
LABEL_30:
    v89 = 0;
  }
  else
  {
    *((_QWORD *)&v41 + 1) = *((_QWORD *)&v35 + 1);
    *(double *)&v41 = *(double *)&v35 * *(double *)&v35 + v36 * v36 + v38 * v38;
    _XMM3 = v41;
    if ( *(double *)&_XMM8 * *(double *)&_XMM8
       + *(double *)&_XMM4 * *(double *)&_XMM4
       + *(double *)&_XMM5 * *(double *)&_XMM5 <= *(double *)&v41 )
    {
      _XMM6 = *(_OWORD *)a2;
      v44 = a2[2];
    }
    else
    {
      _XMM6 = *(_OWORD *)(a1 + 0x20);
      v44 = *(double *)(a1 + 0x30);
    }
    _XMM1 = *(unsigned __int64 *)&v93;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm13, xmm1, xmm13, xmm0
    }
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm0, xmm4, xmm10, xmm0
    }
    v94 = *(double *)&_XMM0;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm0, xmm5, xmm12, xmm0
    }
    v101 = *(double *)&_XMM0;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm0, xmm8, xmm1, xmm0
    }
    _XMM1 = *(unsigned __int64 *)&v96;
    v95 = *(double *)&_XMM0;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm4, xmm1, xmm14, xmm0
    }
    _XMM1 = *(unsigned __int64 *)&v91;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm3, xmm1, xmm15, xmm0
    }
    *((_QWORD *)&v60 + 1) = *((_QWORD *)&_XMM4 + 1);
    *(double *)&v60 = *(double *)&_XMM4 * *(double *)&_XMM4
                    + *(double *)&_XMM13 * *(double *)&_XMM13
                    + *(double *)&_XMM3 * *(double *)&_XMM3;
    _XMM1 = v60;
    v97 = v44;
    if ( *(double *)&v60 <= 0.0 )
    {
      v69 = *(unsigned __int64 *)&v44;
      __asm
      {
        vunpckhpd xmm8, xmm6, xmm6
        vmovupd xmm10, xmm6
      }
    }
    else
    {
      __asm { vmovddup xmm0, xmm1 }
      __asm
      {
        vsqrtpd xmm2, xmm0
        vunpckhpd xmm2, xmm2, xmm2
      }
      v65 = COERCE_UNSIGNED_INT64(1.0 / *(double *)&_XMM2 * *(double *)&_XMM3);
      v66 = 1.0 / *(double *)&_XMM2 * *(double *)&_XMM13 * v95
          + 1.0 / *(double *)&_XMM2 * *(double *)&_XMM4 * v94
          + 1.0 / *(double *)&_XMM2 * *(double *)&_XMM3 * v101;
      *((_QWORD *)&v67 + 1) = 0;
      *(double *)&v67 = 1.0 / *(double *)&_XMM2 * *(double *)&_XMM13 * v66 + *((double *)&_XMM6 + 1);
      _XMM8 = v67;
      *((_QWORD *)&v67 + 1) = *((_QWORD *)&v65 + 1);
      *(double *)&v67 = *(double *)&v65 * v66 + v97;
      v69 = v67;
      *((_QWORD *)&v67 + 1) = 0;
      *(double *)&v67 = 1.0 / *(double *)&_XMM2 * *(double *)&_XMM4 * v66 + *(double *)&_XMM6;
      _XMM10 = v67;
      v44 = *(double *)&v69;
      __asm { vunpcklpd xmm6, xmm10, xmm8 }
    }
    v71 = sub_140976B00(qword_149FBE618);
    v72 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v71 + 0x2E0LL))(v71);
    v73 = v72;
    if ( !v72
      || (sub_1403B43F0((unsigned __int64 *)(v72 + 8), &v102), a4 != v102)
      && (a4 == a5
       || (v74 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v73 + 0x6F0LL))(v73)) == 0
       || (sub_1403B43F0((unsigned __int64 *)(v74 + 8), &v103), a5 != v103)) )
    {
      v111 = *(__m256 *)a1;
      v112 = _XMM6;
      v113 = v44;
      __asm { vzeroupper }
      sub_145E28E10("Whiz", v22, &v111, a6);
      *((_QWORD *)&v76 + 1) = *((_QWORD *)&_XMM10 + 1);
      *(double *)&v76 = *(double *)&_XMM10 - *a8;
      _XMM0 = v76;
      *((_QWORD *)&v76 + 1) = *((_QWORD *)&_XMM8 + 1);
      *(double *)&v76 = *(double *)&_XMM8 - a8[1];
      _XMM1 = v76;
      __asm { vcvtsd2ss xmm3, xmm0, xmm0 }
      *((_QWORD *)&v76 + 1) = *((_QWORD *)&v69 + 1);
      *(double *)&v76 = *(double *)&v69 - a8[2];
      _XMM0 = v76;
      __asm
      {
        vcvtsd2ss xmm2, xmm1, xmm1
        vcvtsd2ss xmm4, xmm0, xmm0
      }
      v82 = (float)((float)(*(float *)&_XMM2 * *(float *)&_XMM2) + (float)(*(float *)&_XMM3 * *(float *)&_XMM3))
          + (float)(*(float *)&_XMM4 * *(float *)&_XMM4);
      v83 = sub_1465E67C0(qword_149FBE618);
      v84 = sub_1403229B0(v83);
      event_key_from_source_location = event_key_from_source_location_11;
      v86 = v84;
      if ( !event_key_from_source_location_11 )
        event_key_from_source_location = get_event_key_from_source_location(
                                           &event_key_from_source_location_11,
                                           (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/Audio/Game.h",
                                           0x1C);
      *(float *)&v92 = v82;
      HIDWORD(v92) = event_key_from_source_location;
      v87 = *(void (__fastcall **)(__int64, _QWORD, __int64 (__fastcall **)(__int64, __int64)))(*(_QWORD *)v86 + 0x20LL);
      v88 = (_QWORD *)sub_1402A65A0(8u);
      if ( v88 )
      {
        *v88 = v92;
        v100 = v88;
      }
      else
      {
        v100 = 0;
      }
      p_sub_14049CE70 = sub_14049CE70;
      p_sub_14049D9C0 = sub_14049D9C0;
      v87(v86, event_key_from_source_location, &p_sub_14049CE70);
      if ( (unsigned __int64)p_sub_14049D9C0 >= 2 )
        ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))p_sub_14049D9C0)(2, &p_sub_14049CE70);
    }
    v89 = 1;
  }
  v108 = __rdtsc();
  qword_149C89AA8(&n0x5300);
  return v89;
}

// --- End Function: sub_145E37120 (0x145E37120) ---

// --- Function: sub_145E37C30 (0x145E37C30) ---
__int64 __fastcall sub_145E37C30(__int64 a1)
{
  __int128 v1; // xmm6
  _QWORD *v3; // rax
  int v6; // r14d
  unsigned int v7; // eax
  int v8; // eax
  unsigned __int32 v9; // eax
  int v10; // edi
  unsigned int v11; // eax
  __int64 v12; // r14
  __int64 v13; // rdi
  __int64 v14; // rax
  __int64 v15; // r8
  int v16; // r10d
  __int64 v17; // r9
  __int64 v18; // r12
  __int64 v19; // r14
  _QWORD *v20; // r15
  __int64 v21; // rdi
  __int64 v22; // rax
  int v23; // eax
  unsigned __int32 v24; // eax
  __int64 v25; // rcx
  __int64 v27; // [rsp+38h] [rbp-49h] BYREF
  __int64 v28; // [rsp+40h] [rbp-41h] BYREF
  int n0x5100; // [rsp+48h] [rbp-39h] BYREF
  __int64 v30; // [rsp+4Ch] [rbp-35h]
  int v31; // [rsp+54h] [rbp-2Dh]
  unsigned __int64 v32; // [rsp+58h] [rbp-29h]
  unsigned __int64 v33; // [rsp+60h] [rbp-21h]
  __int64 v34; // [rsp+68h] [rbp-19h]
  __int64 v35; // [rsp+70h] [rbp-11h]
  __int128 v36; // [rsp+98h] [rbp+17h]
  int v37; // [rsp+F8h] [rbp+77h]
  void *v38; // [rsp+100h] [rbp+7Fh] BYREF

  v36 = v1;
  v31 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  n0x5100 = 0x5100;
  v30 = 1;
  v32 = __rdtsc();
  qword_149C89AA0(
    &n0x5100,
    &word_149FB1ADC,
    "CCombatLogging::Update",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Recording/CombatLogging.cpp",
    0x5A);
  HIWORD(n0x5100) = word_149FB1ADC;
  if ( *(_QWORD *)(a1 + 0x60) )
  {
    v3 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                     qword_149C8DF80,
                     0);
    sub_14059CA60(v3, &v28, (_QWORD *)a1);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  }
  else
  {
    LODWORD(_XMM1) = 0;
  }
  *(float *)(a1 + 8) = *(float *)&_XMM1;
  if ( *(_QWORD *)(a1 + 0x60) )
  {
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x28) == v6 )
    {
      ++*(_DWORD *)(a1 + 0x2C);
    }
    else
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x18), 1, 0);
      if ( v7 )
        sub_1403C6E80(a1 + 0x18, v7, (__int64)"CCombatLogging::Update", 1);
      else
        *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x28) = v6;
    }
    sub_14034FA50((__int64 *)(*(_QWORD *)(a1 + 0x30) + 0x18LL * *(unsigned int *)(a1 + 0x48)), 0);
    v8 = *(_DWORD *)(a1 + 0x2C);
    if ( v8 )
    {
      *(_DWORD *)(a1 + 0x2C) = v8 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x28) = 0xFFFFFFFF;
      v9 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x18), 0, 1);
      if ( v9 == 1 )
        *(_QWORD *)(a1 + 0x20) = &p_Src;
      else
        sub_1403DF590(a1 + 0x18, v9);
    }
  }
  sub_1403CE280(*(_QWORD *)(a1 + 0x10));
  if ( *(_QWORD *)(a1 + 0x60) )
  {
    v10 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x28) == v10 )
    {
      ++*(_DWORD *)(a1 + 0x2C);
    }
    else
    {
      v11 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x18), 1, 0);
      if ( v11 )
        sub_1403C6E80(a1 + 0x18, v11, (__int64)"CCombatLogging::Update", 1);
      else
        *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x28) = v10;
    }
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 0x30) + 0x18LL * *(unsigned int *)(a1 + 0x48)) != *(_QWORD *)(*(_QWORD *)(a1 + 0x30)
                                                                                                  + 0x18LL * *(unsigned int *)(a1 + 0x48)
                                                                                                  + 8) )
    {
      sub_14035E090(&v38);
      sub_1403ACC80(&v38, "#%.2f\n", *(float *)(a1 + 8));
      v12 = *(_QWORD *)(a1 + 0x60);
      if ( v12 )
      {
        v13 = qword_149C8DF58;
        v14 = sub_1403EBE30(&v38);
        (*(void (__fastcall **)(__int64, void *, __int64, __int64, __int64))(*(_QWORD *)v13 + 0x160LL))(
          v13,
          v38,
          1,
          v14,
          v12);
      }
      v15 = *(_QWORD *)(a1 + 0x30);
      v16 = 0;
      v17 = *(unsigned int *)(a1 + 0x48);
      v37 = 0;
      if ( (__int64)(*(_QWORD *)(v15 + 0x18 * v17 + 8) - *(_QWORD *)(v15 + 0x18 * v17)) >> 3 )
      {
        v18 = 0;
        do
        {
          v19 = *(_QWORD *)(a1 + 0x60);
          v20 = (_QWORD *)(v18 + *(_QWORD *)(v15 + 0x18LL * (unsigned int)v17));
          if ( v19 )
          {
            v21 = qword_149C8DF58;
            v22 = sub_1403EBE30((_QWORD *)(v18 + *(_QWORD *)(v15 + 0x18LL * (unsigned int)v17)));
            (*(void (__fastcall **)(__int64, _QWORD, __int64, __int64, __int64))(*(_QWORD *)v21 + 0x160LL))(
              v21,
              *v20,
              1,
              v22,
              v19);
            v16 = v37;
          }
          ++v16;
          v15 = *(_QWORD *)(a1 + 0x30);
          LODWORD(v17) = *(_DWORD *)(a1 + 0x48);
          v18 += 8;
          v37 = v16;
        }
        while ( v16 < (unsigned __int64)((__int64)(*(_QWORD *)(v15 + 0x18LL * (unsigned int)v17 + 8)
                                                 - *(_QWORD *)(v15 + 0x18LL * (unsigned int)v17)) >> 3) );
      }
      sub_140373CC0(&v38);
    }
    v23 = *(_DWORD *)(a1 + 0x2C);
    if ( v23 )
    {
      *(_DWORD *)(a1 + 0x2C) = v23 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x28) = 0xFFFFFFFF;
      v24 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x18), 0, 1);
      if ( v24 == 1 )
        *(_QWORD *)(a1 + 0x20) = &p_Src;
      else
        sub_1403DF590(a1 + 0x18, v24);
    }
  }
  if ( byte_149FB1604 && *(float *)(a1 + 8) > *(float *)(a1 + 0xC) )
  {
    v25 = *(_QWORD *)(a1 + 0x10);
    *(float *)&v27 = 0.0;
    BYTE4(v27) = 0;
    sub_145DF9AE0(v25, &v27);
  }
  v33 = __rdtsc();
  return qword_149C89AA8(&n0x5100);
}

// --- End Function: sub_145E37C30 (0x145E37C30) ---

// --- Function: sub_145E3B110 (0x145E3B110) ---
void __fastcall sub_145E3B110(int a1, __int64 a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int128 v6; // xmm10
  __int128 v7; // xmm11
  __int128 v8; // xmm12
  __int64 v11; // rax
  __int64 v12; // rdi
  double v13; // xmm6_8
  double v14; // xmm7_8
  double v15; // xmm8_8
  double v16; // xmm9_8
  __int128 v17; // xmm10
  double v18; // xmm11_8
  double v19; // xmm12_8
  unsigned int event_key_from_source_location; // ebx
  void (__fastcall *v21)(__int64, _QWORD, __int64 (__fastcall **)()); // rsi
  __int64 v22; // rax
  __int64 (__fastcall *p_sub_1416DD850)(); // [rsp+20h] [rbp-98h] BYREF
  __int64 (__fastcall *p_sub_145E097C0)(); // [rsp+28h] [rbp-90h]
  __int64 v25; // [rsp+30h] [rbp-88h]
  __int128 v26; // [rsp+40h] [rbp-78h]
  __int128 v27; // [rsp+50h] [rbp-68h]
  __int128 v28; // [rsp+60h] [rbp-58h]
  __int128 v29; // [rsp+70h] [rbp-48h]
  __int128 v30; // [rsp+80h] [rbp-38h]
  __int128 v31; // [rsp+90h] [rbp-28h]
  __int128 v32; // [rsp+A0h] [rbp-18h]

  if ( byte_149FB1604 )
  {
    v11 = sub_1465E6760(qword_149FBE618);
    if ( v11 )
    {
      v12 = *(_QWORD *)(v11 + 0x10);
      if ( v12 )
      {
        v32 = v2;
        v13 = *(double *)(a2 + 0x18);
        v31 = v3;
        v14 = *(double *)a2;
        v30 = v4;
        v15 = *(double *)(a2 + 8);
        v29 = v5;
        v16 = *(double *)(a2 + 0x10);
        v28 = v6;
        v17 = *(_OWORD *)(a2 + 0x20);
        v27 = v7;
        v18 = *(double *)(a2 + 0x30);
        v26 = v8;
        v19 = *(double *)(a2 + 0x38);
        event_key_from_source_location = event_key_from_source_location_12;
        if ( !event_key_from_source_location_12 )
          event_key_from_source_location = get_event_key_from_source_location(
                                             &event_key_from_source_location_12,
                                             (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Recording\\CombatLoggingEvents.h",
                                             0x12);
        v21 = *(void (__fastcall **)(__int64, _QWORD, __int64 (__fastcall **)()))(*(_QWORD *)v12 + 0x20LL);
        v22 = sub_1402A65A0(0x50u);
        if ( v22 )
        {
          *(double *)(v22 + 0x20) = v13;
          *(double *)(v22 + 8) = v14;
          *(double *)(v22 + 0x10) = v15;
          *(double *)(v22 + 0x18) = v16;
          *(_DWORD *)v22 = a1;
          *(_OWORD *)(v22 + 0x28) = v17;
          *(double *)(v22 + 0x38) = v18;
          *(double *)(v22 + 0x40) = v19;
          *(_DWORD *)(v22 + 0x48) = event_key_from_source_location;
          v25 = v22;
        }
        else
        {
          v25 = 0;
        }
        p_sub_1416DD850 = sub_1416DD850;
        p_sub_145E097C0 = sub_145E097C0;
        v21(v12, event_key_from_source_location, &p_sub_1416DD850);
        if ( (unsigned __int64)p_sub_145E097C0 >= 2 )
          ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))p_sub_145E097C0)(2, &p_sub_1416DD850);
      }
    }
  }
}

// --- End Function: sub_145E3B110 (0x145E3B110) ---

// --- Function: sub_145E3B8B0 (0x145E3B8B0) ---
__int64 __fastcall sub_145E3B8B0(__int64 a1, unsigned int a2, float a3, char a4, double *a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  __int128 v8; // xmm9
  __int128 v9; // xmm10
  __int128 v10; // xmm11
  __int128 v11; // xmm12
  __int128 v12; // xmm13
  __int128 v13; // xmm14
  __int128 v14; // xmm15
  __int64 v16; // rbx
  char v17; // di
  signed __int64 v18; // rdx
  __int64 v19; // r14
  int v20; // ebx
  unsigned int v21; // eax
  __int64 v22; // rcx
  __int64 v23; // rbx
  bool v24; // r12
  bool v25; // bl
  __int64 v26; // rsi
  double v27; // xmm7_8
  double v28; // xmm4_8
  double v29; // xmm15_8
  double v30; // xmm13_8
  double v31; // xmm14_8
  double v32; // xmm6_8
  double v33; // xmm5_8
  double v34; // xmm4_8
  __int64 v35; // rax
  __int64 v36; // r12
  __int64 v37; // rdi
  __int64 (__fastcall *v38)(__int64, _QWORD); // rbx
  unsigned int v39; // eax
  __int64 v40; // rax
  __int64 v41; // rbx
  double v42; // xmm14_8
  double *v43; // rax
  double v44; // xmm6_8
  double v47; // xmm12_8
  __int128 v48; // xmm13
  __int128 v49; // xmm11
  __int128 v50; // xmm0
  double v51; // xmm1_8
  double v52; // xmm10_8
  double v53; // xmm9_8
  double v54; // xmm8_8
  double v55; // xmm7_8
  __int128 v56; // kr00_16
  __int128 v57; // xmm6
  double v58; // xmm4_8
  __int128 v59; // xmm5
  __int128 v60; // xmm3
  __int128 v61; // xmm4
  __int128 v63; // xmm3
  __int64 v69; // rax
  __int64 v70; // rcx
  __int64 v71; // rbx
  float v72; // xmm7_4
  __int64 v73; // rax
  __int64 v74; // rax
  float v75; // xmm5_4
  float v76; // xmm0_4
  __int64 *v78; // rsi
  __int64 v79; // rdi
  __int64 v80; // rbx
  __int64 *v81; // rax
  __m128 v82; // kr00_16
  __m128 v85; // xmm2
  float v86; // xmm4_4
  float v87; // xmm5_4
  float v88; // xmm0_4
  double v89; // xmm1_8
  unsigned __int64 v90; // r8
  unsigned __int64 v91; // rdx
  __int64 v92; // rcx
  __int128 v93; // xmm0
  double v94; // xmm3_8
  double v95; // xmm4_8
  double v96; // xmm6_8
  double v101; // xmm7_8
  double v102; // xmm4_8
  __int128 src__1; // xmm5
  double v104; // xmm6_8
  __int128 v105; // kr00_16
  double v110; // xmm8_8
  double v111; // xmm9_8
  double v112; // xmm8_8
  double v113; // xmm9_8
  __int128 v114; // xmm7
  __int128 v115; // xmm10
  __int128 v116; // kr00_16
  double v124; // xmm6_8
  double v126; // xmm2_8
  double v127; // xmm1_8
  double v128; // xmm7_8
  double v129; // xmm4_8
  double v130; // xmm10_8
  __int128 v131; // kr00_16
  double v132; // xmm5_8
  char v137; // di
  __int64 v138; // rbx
  __int64 v139; // r9
  __int64 v140; // r8
  __int64 v141; // rsi
  void (__fastcall *v142)(__int64, _QWORD, _QWORD, __int64); // rdi
  unsigned int v143; // ebx
  unsigned int v144; // eax
  __int64 v145; // r9
  const vraudio::AudioBuffer **_Whereptr; // rdx
  unsigned __int8 v147; // bl
  _BYTE *v148; // rax
  __int64 v149; // rax
  __int64 v150; // rax
  int v151; // ecx
  __int64 v152; // rax
  __int64 v153; // rax
  int v154; // ecx
  __int64 *v155; // rax
  __int64 v156; // r10
  int v157; // eax
  unsigned __int32 v158; // eax
  char v160; // [rsp+38h] [rbp-D0h]
  unsigned __int8 v161; // [rsp+40h] [rbp-C8h]
  bool v163; // [rsp+49h] [rbp-BFh]
  bool v164; // [rsp+4Ah] [rbp-BEh]
  char v165; // [rsp+4Bh] [rbp-BDh]
  double v166; // [rsp+50h] [rbp-B8h]
  __int64 v167; // [rsp+50h] [rbp-B8h]
  double *v168; // [rsp+58h] [rbp-B0h] BYREF
  double v169; // [rsp+60h] [rbp-A8h]
  float src_[4]; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v171; // [rsp+78h] [rbp-90h]
  __int128 v172; // [rsp+80h] [rbp-88h] BYREF
  double v173; // [rsp+90h] [rbp-78h]
  float v174[4]; // [rsp+98h] [rbp-70h] BYREF
  double v175; // [rsp+A8h] [rbp-60h]
  double v176; // [rsp+B0h] [rbp-58h]
  int n0x5300; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v178; // [rsp+CCh] [rbp-3Ch]
  int v179; // [rsp+D4h] [rbp-34h]
  unsigned __int64 v180; // [rsp+D8h] [rbp-30h]
  unsigned __int64 v181; // [rsp+E0h] [rbp-28h]
  __int64 v182; // [rsp+E8h] [rbp-20h]
  __int64 v183; // [rsp+F0h] [rbp-18h]
  double v184[3]; // [rsp+118h] [rbp+10h] BYREF
  double v185; // [rsp+130h] [rbp+28h] BYREF
  double v186; // [rsp+138h] [rbp+30h]
  double v187; // [rsp+140h] [rbp+38h]
  double v188; // [rsp+148h] [rbp+40h]
  double v189; // [rsp+150h] [rbp+48h]
  double v190; // [rsp+158h] [rbp+50h]
  double v191; // [rsp+160h] [rbp+58h]
  double v192; // [rsp+168h] [rbp+60h] BYREF
  double v193; // [rsp+170h] [rbp+68h]
  double v194; // [rsp+178h] [rbp+70h]
  double v195; // [rsp+180h] [rbp+78h] BYREF
  double v196; // [rsp+188h] [rbp+80h]
  double v197; // [rsp+190h] [rbp+88h]
  double v198; // [rsp+198h] [rbp+90h]
  double v199; // [rsp+1A0h] [rbp+98h]
  double v200; // [rsp+1A8h] [rbp+A0h]
  double v201; // [rsp+1B0h] [rbp+A8h]
  __m256 v202; // [rsp+1B8h] [rbp+B0h] BYREF
  __int128 v203; // [rsp+1D8h] [rbp+D0h]
  __int64 v204; // [rsp+1E8h] [rbp+E0h]
  double v205; // [rsp+1F0h] [rbp+E8h]
  __m256 v206; // [rsp+1F8h] [rbp+F0h] BYREF
  __int128 v207; // [rsp+218h] [rbp+110h]
  __int64 v208; // [rsp+228h] [rbp+120h]
  double v209; // [rsp+230h] [rbp+128h]
  __int64 v210; // [rsp+238h] [rbp+130h] BYREF
  __int64 v211; // [rsp+240h] [rbp+138h] BYREF
  __int64 v212; // [rsp+248h] [rbp+140h] BYREF
  __int64 v213; // [rsp+250h] [rbp+148h] BYREF
  __int64 v214; // [rsp+258h] [rbp+150h] BYREF
  __int128 v215; // [rsp+268h] [rbp+160h] BYREF
  double v216; // [rsp+278h] [rbp+170h]
  double v217[3]; // [rsp+288h] [rbp+180h] BYREF
  double v218; // [rsp+2A0h] [rbp+198h]
  __int128 v219; // [rsp+2A8h] [rbp+1A0h]
  double v220; // [rsp+2B8h] [rbp+1B0h]
  double v221[4]; // [rsp+2C0h] [rbp+1B8h] BYREF
  __int128 v222; // [rsp+2E0h] [rbp+1D8h]
  double v223; // [rsp+2F0h] [rbp+1E8h]
  __int128 v224; // [rsp+2F8h] [rbp+1F0h] BYREF
  double v225; // [rsp+308h] [rbp+200h]
  double v226; // [rsp+310h] [rbp+208h]
  double v228; // [rsp+328h] [rbp+220h]
  _BYTE v229[56]; // [rsp+330h] [rbp+228h] BYREF
  _BYTE v230[56]; // [rsp+368h] [rbp+260h] BYREF
  _BYTE v231[56]; // [rsp+3A0h] [rbp+298h] BYREF
  _BYTE v232[32]; // [rsp+3D8h] [rbp+2D0h] BYREF
  __int128 v233; // [rsp+408h] [rbp+300h]
  __int128 v234; // [rsp+418h] [rbp+310h]
  __int128 v235; // [rsp+428h] [rbp+320h]
  __int128 v236; // [rsp+438h] [rbp+330h]
  __int128 v237; // [rsp+448h] [rbp+340h]
  __int128 v238; // [rsp+458h] [rbp+350h]
  __int128 v239; // [rsp+468h] [rbp+360h]
  __int128 v240; // [rsp+478h] [rbp+370h]
  __int128 v241; // [rsp+488h] [rbp+380h]
  __int128 v242; // [rsp+498h] [rbp+390h]

  v242 = v5;
  v241 = v6;
  v240 = v7;
  v239 = v8;
  v238 = v9;
  v237 = v10;
  v236 = v11;
  v235 = v12;
  v234 = v13;
  v233 = v14;
  v168 = a5;
  v179 = 0;
  v181 = 0;
  v182 = 0;
  v183 = 0;
  v16 = a2;
  n0x5300 = 0x5300;
  v178 = 1;
  v180 = __rdtsc();
  v17 = 1;
  qword_149C89AA0(
    &n0x5300,
    &word_149FB19CC,
    "CProjectileManager::UpdateProjectile",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileManager.cpp",
    0x364);
  HIWORD(n0x5300) = word_149FB19CC;
  if ( *(_DWORD *)(a1 + 0xD8) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0xDC);
  }
  else
  {
    v18 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0xC8));
    if ( (v18 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0xC8, v18, "CProjectileManager::UpdateProjectile", "m_projectilesLock", 1);
  }
  v19 = *(_QWORD *)(a1 + 0x40) + 0x1E0 * v16;
  v20 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v19 + 0x10) == v20 )
  {
    ++*(_DWORD *)(v19 + 0x14);
  }
  else
  {
    v21 = _InterlockedCompareExchange((volatile signed __int32 *)v19, 1, 0);
    if ( v21 )
      sub_1403C6E80(v19, v21, (__int64)"CProjectileManager::UpdateProjectile", 1);
    else
      *(_QWORD *)(v19 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v19 + 0x10) = v20;
  }
  v22 = *(_QWORD *)(v19 + 0x18);
  *(float *)(v19 + 0x1B0) = a3 + *(float *)(v19 + 0x1B0);
  v23 = sub_142D1A700(v22);
  v24 = *(float *)(v19 + 0x1B4) <= *(float *)(v19 + 0x1B0) && *(_BYTE *)(v19 + 0x1CB);
  v163 = v24;
  if ( !byte_149C8E515 || *(_BYTE *)(v19 + 0x1CD) || !sub_1403C4E50(*(_QWORD *)(v19 + 0x18) + 0x48LL) )
    v17 = 0;
  v165 = v17;
  v25 = *(float *)(v19 + 0x1B4) <= *(float *)(v19 + 0x1B0) && v23 && *(_QWORD *)(v23 + 0x110);
  v164 = v25;
  v171 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL))(
           qword_149C8DF28,
           *(unsigned int *)(v19 + 0x28));
  v26 = v171;
  if ( !v171 )
  {
    v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x10LL))(qword_149C8DF28);
    v171 = v26;
  }
  (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v26 + 0x68LL))(v26, &v195, 0);
  sub_14033A390(&v185, &v195, (double *)(v19 + 0xF8));
  v27 = *(double *)(v19 + 0x188);
  v28 = *(double *)(v19 + 0x180);
  v29 = *(double *)(v19 + 0x160);
  v30 = *(double *)(v19 + 0x170);
  v31 = *(double *)(v19 + 0x178);
  v169 = *(double *)(v19 + 0x158);
  v166 = *(double *)(v19 + 0x168);
  v175 = v28;
  v32 = v196 * v27 - v197 * v28 + v198 * v31;
  v33 = v197 * v31 - v195 * v27 + v198 * v28;
  v34 = v195 * v28 - v196 * v31 + v198 * v27;
  v176 = v27;
  v188 = v196 * v166 - v197 * v29 + v198 * v169 + v195 * v30;
  v189 = v197 * v169 - v195 * v166 + v198 * v29 + v196 * v30;
  v190 = v195 * v29 - v196 * v169 + v198 * v166 + v197 * v30;
  v191 = v198 * v30 - v195 * v169 - v196 * v29 - v197 * v166;
  v192 = v196 * v34 - v197 * v33 + v31 + v199 + v196 * v34 - v197 * v33;
  v193 = v197 * v32 - v195 * v34 + v175 + v200 + v197 * v32 - v195 * v34;
  v194 = v195 * v33 - v196 * v32 + v27 + v201 + v195 * v33 - v196 * v32;
  if ( v24 || a4 || v17 || v25 )
  {
    v35 = sub_145E18010((_QWORD *)a1, *(_DWORD *)(v19 + 0xC0));
    v36 = v35;
    if ( v35 )
    {
      v37 = qword_149C8DF28;
      v38 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL);
      v39 = sub_1405A9140(v35);
      v40 = v38(v37, v39);
      v167 = v40;
      v41 = v40;
      v42 = 0.0;
      if ( v40 )
      {
        v43 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v40 + 0x68LL))(v40, v229, 0);
        v44 = *v43;
      }
      else
      {
        _XMM0 = 0;
        _XMM1 = 0;
        __asm
        {
          vmovupd [rbp+3D0h+var_1E0], xmm0
          vmovupd [rbp+3D0h+var_1C0], xmm1
        }
        v226 = 1.0;
        v225 = 0.0;
        v228 = 0.0;
        v43 = (double *)&v224;
        v44 = 0.0;
      }
      v48 = *((unsigned __int64 *)v43 + 1);
      v49 = *((unsigned __int64 *)v43 + 2);
      v50 = *((_OWORD *)v43 + 2);
      v51 = v43[6];
      v218 = v43[3];
      v47 = v218;
      v217[1] = *(double *)&v48;
      v217[2] = *(double *)&v49;
      v219 = v50;
      v220 = v51;
      v169 = v44;
      v217[0] = v44;
      sub_14033A390((double *)&v172, v217, (double *)v36);
      v52 = *(float *)(v36 + 0x20);
      v53 = *(float *)(v36 + 0x1C);
      v54 = *(float *)(v36 + 0x18);
      v55 = *(double *)&v48 * v52 - *(double *)&v49 * v53 + v47 * v54;
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v49 + 1);
      *(double *)&v56 = *(double *)&v49 * v54 - v44 * v52 + v47 * v53;
      v57 = v56;
      v58 = v53 * v169 - *(double *)&v48 * v54 + v47 * v52;
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v48 + 1);
      *(double *)&v56 = *(double *)&v48 * v58 - *(double *)&v49 * *(double *)&v57;
      v59 = v56;
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v57 + 1);
      *(double *)&v56 = *(double *)&v57 * v169;
      v60 = v56;
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v49 + 1);
      *(double *)&v56 = *(double *)&v49 * v55 - v58 * v169;
      v61 = v56;
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v59 + 1);
      *(double *)&v56 = *(double *)&v59 + v54 + *(double *)&v59;
      _XMM2 = v56;
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v60 + 1);
      *(double *)&v56 = *(double *)&v60 - *(double *)&v48 * v55;
      v63 = v56;
      __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v61 + 1);
      *(double *)&v56 = *(double *)&v61 + v53 + *(double *)&v61;
      _XMM2 = v56;
      src_[0] = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
      *((_QWORD *)&v56 + 1) = *((_QWORD *)&v63 + 1);
      *(double *)&v56 = *(double *)&v63 + v52 + *(double *)&v63;
      _XMM2 = v56;
      src_[1] = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
      src_[2] = *(float *)&_XMM0;
      if ( a4 )
      {
        v69 = sub_145E16690(v19, (__int64)v232, (double *)&v172);
        if ( sub_144500EE0((double *)&v172, src_, v69) )
        {
          v70 = *(_QWORD *)(v19 + 0x1A8);
          *(_DWORD *)(v19 + 0x1B0) = *(_DWORD *)(v19 + 0x1B4);
          if ( v70 )
            (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v70 + 0x218LL))(v70, 0);
          if ( dword_149FB1608 && *(_BYTE *)(v19 + 0x1DC) )
          {
            sub_145E2DBD0(*(_DWORD *)(v19 + 0x1D8));
            *(_BYTE *)(v19 + 0x1DC) = 0;
          }
        }
      }
      if ( v163 )
      {
        v71 = *(_QWORD *)(v19 + 0x18);
        v72 = *(float *)(v19 + 0x1B0);
        if ( !*(_BYTE *)(v71 + 0x45) )
        {
          v73 = sub_145DF96D0(*(_QWORD *)(v19 + 0x18));
          if ( v73 )
          {
            v74 = *(_QWORD *)(v73 + 8);
            if ( v74 )
            {
              v75 = *(float *)(v74 + 0x10);
              if ( v75 <= 0.00000011920929
                || (v185 - *(double *)&v172) * (v185 - *(double *)&v172)
                 + (v186 - *((double *)&v172 + 1)) * (v186 - *((double *)&v172 + 1))
                 + (v187 - v173) * (v187 - v173) > (float)(v75 * v75) )
              {
                v76 = *(float *)(v74 + 8);
                if ( (v76 <= 0.00000011920929 || v72 > v76)
                  && !(v72 < *(float *)(v71 + 0x2C) ? *(_BYTE *)(v74 + 0x14) == 0 : *(_BYTE *)(v74 + 0x16) == 0) )
                {
                  v78 = *(__int64 **)(v19 + 0x38);
                  v79 = *sub_1403B43F0((unsigned __int64 *)(v19 + 0x50), &v210);
                  v80 = *sub_1403B43F0((unsigned __int64 *)(v19 + 0x48), &v211);
                  v81 = sub_1403B43F0((unsigned __int64 *)(v19 + 0x40), &v212);
                  sub_145E0FED0(*(_QWORD *)(v19 + 0x18), *v81, v80, v79, &v172, src_, v78);
                  v26 = v171;
                }
              }
            }
          }
        }
        v41 = v167;
      }
      if ( v164 )
      {
        v82 = (__m128)*(unsigned int *)(v36 + 0x18);
        v82.m128_f32[0] = (float)((float)(*(float *)(v36 + 0x18) * *(float *)(v36 + 0x18))
                                + (float)(*(float *)(v36 + 0x1C) * *(float *)(v36 + 0x1C)))
                        + (float)(*(float *)(v36 + 0x20) * *(float *)(v36 + 0x20));
        if ( v82.m128_f32[0] <= 0.00000011920929 )
        {
          v86 = *(float *)&dword_149A5E108;
          v87 = *((float *)&src__4 + 1);
          v88 = *(float *)&src__4;
        }
        else
        {
          _XMM0 = _mm_shuffle_ps(v82, v82, 0);
          __asm { vrsqrtps xmm3, xmm0 }
          _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
          v85 = (__m128)*(unsigned __int64 *)(v36 + 0x18);
          _XMM3.m128_f32[0] = (float)(1.5
                                    - (float)((float)((float)(_XMM3.m128_f32[0] * v82.m128_f32[0]) * _XMM3.m128_f32[0])
                                            * 0.5))
                            * _XMM3.m128_f32[0];
          v86 = _XMM3.m128_f32[0] * *(float *)(v36 + 0x20);
          v87 = _mm_shuffle_ps(v85, v85, 0x55).m128_f32[0] * _XMM3.m128_f32[0];
          v88 = v85.m128_f32[0] * _XMM3.m128_f32[0];
        }
        v89 = *(double *)(v36 + 0x10);
        v90 = *(_QWORD *)(v19 + 0x50);
        v91 = *(_QWORD *)(v19 + 0x40);
        v92 = *(_QWORD *)(v19 + 0x18);
        v161 = *(_BYTE *)(v19 + 0x1C9);
        v160 = *(_BYTE *)(v19 + 0x1CA);
        v174[0] = v88;
        v93 = *(_OWORD *)v36;
        v174[1] = v87;
        v174[2] = v86;
        v215 = v93;
        v216 = v89;
        sub_145E34640(v92, v91, v90, (double *)&v215, (__int64)v174, v41, v160, v161);
      }
      if ( v165 )
      {
        (*(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)v26 + 0x170LL))(v26, v184, v19 + 0x110);
        v94 = v192 - v184[0];
        v95 = v193 - v184[1];
        v96 = v194 - v184[2];
        _XMM5 = COERCE_UNSIGNED_INT64(v95 * v95 + v94 * v94 + v96 * v96);
        if ( v95 * v95 + v94 * v94 + v96 * v96 <= 0.0 )
        {
          src__1 = (unsigned __int64)::src__1;
          v101 = *((double *)&::src__1 + 1);
          v102 = *(double *)&qword_149A60058;
        }
        else
        {
          __asm
          {
            vmovddup xmm0, xmm5
            vsqrtpd xmm1, xmm0
            vunpckhpd xmm1, xmm1, xmm1
          }
          v101 = v95 * (1.0 / *(double *)&_XMM1);
          v102 = v96 * (1.0 / *(double *)&_XMM1);
          src__1 = COERCE_UNSIGNED_INT64(v94 * (1.0 / *(double *)&_XMM1));
        }
        v104 = 0.7071067690849304;
        *((_QWORD *)&v105 + 1) = *((_QWORD *)&src__1 + 1);
        *(double *)&v105 = *(double *)&src__1 * *(double *)&src__1 + v101 * v101;
        _XMM1 = v105;
        __asm
        {
          vmovddup xmm2, xmm1
          vsqrtpd xmm3, xmm2
          vunpckhpd xmm3, xmm3, xmm3
        }
        v110 = v102 * 0.7071067690849304;
        v111 = 0.0;
        if ( *(double *)&_XMM3 > 0.00001 )
        {
          v112 = -1.0;
          v113 = 1.0 / *(double *)&_XMM3 * *(double *)&src__1;
          v114 = COERCE_UNSIGNED_INT64(1.0 / *(double *)&_XMM3 * v101 + 1.0);
          *((_QWORD *)&v116 + 1) = *((_QWORD *)&_XMM3 + 1);
          *(double *)&v116 = *(double *)&_XMM3 + 1.0;
          v115 = v116;
          *((_QWORD *)&v116 + 1) = *((_QWORD *)&v114 + 1);
          *(double *)&v116 = *(double *)&v114 * *(double *)&v114 + v113 * v113;
          _XMM1 = v116;
          __asm
          {
            vmovddup xmm2, xmm1
            vsqrtpd xmm3, xmm2
          }
          *((_QWORD *)&v116 + 1) = *((_QWORD *)&v115 + 1);
          *(double *)&v116 = *(double *)&v115 * *(double *)&v115 + v102 * v102;
          _XMM1 = v116;
          __asm { vunpckhpd xmm3, xmm3, xmm3 }
          __asm
          {
            vmovddup xmm2, xmm1
            vsqrtpd xmm5, xmm2
          }
          v124 = 0.0;
          if ( *(double *)&_XMM3 != 0.0 )
          {
            v112 = -(1.0 / *(double *)&_XMM3 * v113);
            v124 = 1.0 / *(double *)&_XMM3 * *(double *)&v114;
          }
          __asm { vunpckhpd xmm5, xmm5, xmm5 }
          v126 = 1.0 / *(double *)&_XMM5 * *(double *)&v115;
          v127 = 1.0 / *(double *)&_XMM5 * v102;
          v128 = v127 * v112;
          v129 = v127 * v124;
          *((_QWORD *)&v131 + 1) = 0;
          v130 = v126 * v112;
          v132 = v126 * v124;
          *(double *)&v131 = v130 * v130 + v128 * v128 + v129 * v129 + v132 * v132;
          _XMM1 = v131;
          if ( *(double *)&v131 <= 0.00000000999999993922529 )
          {
            v104 = 1.0;
            v110 = 0.0;
            v111 = 0.0;
          }
          else
          {
            __asm
            {
              vmovddup xmm0, xmm1
              vsqrtpd xmm1, xmm0
              vunpckhpd xmm1, xmm1, xmm1
            }
            v104 = 1.0 / *(double *)&_XMM1 * v132;
            v110 = 1.0 / *(double *)&_XMM1 * v129;
            v111 = 1.0 / *(double *)&_XMM1 * v128;
            v42 = 1.0 / *(double *)&_XMM1 * v130;
          }
        }
        v137 = *(_BYTE *)(v19 + 0x1CD);
        v138 = *sub_1403B43F0((unsigned __int64 *)(v19 + 0x48), &v213);
        v139 = *sub_1403B43F0((unsigned __int64 *)(v19 + 0x40), &v214);
        v140 = *(_QWORD *)(v19 + 0x18);
        v221[0] = v110;
        v221[1] = v111;
        v221[2] = v42;
        v221[3] = v104;
        v222 = v172;
        v223 = v173;
        *(_BYTE *)(v19 + 0x1CD) = sub_145E37120((__int64)v221, v184, v140, v139, v138, v26, v137, v168);
      }
    }
  }
  if ( *(float *)(v19 + 0x1B4) > *(float *)(v19 + 0x1B0) )
  {
    v148 = *(_BYTE **)(a1 + 0x178);
    if ( v148 && *v148 && dword_149FB1608 )
    {
      if ( *(_BYTE *)(v19 + 0x1DC) )
      {
        v152 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL))(
                 qword_149C8DF28,
                 *(unsigned int *)(v19 + 0x28));
        if ( v152
          || (v152 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x10LL))(qword_149C8DF28)) != 0 )
        {
          v153 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v152 + 0x150LL))(
                   v152,
                   v231,
                   v19 + 0x158);
          v154 = *(_DWORD *)(v19 + 0x1D8);
          v209 = 1.0;
          v206 = *(__m256 *)v153;
          v207 = *(_OWORD *)(v153 + 0x20);
          v208 = *(_QWORD *)(v153 + 0x30);
          __asm { vzeroupper }
          sub_145E3B110(v154, (__int64)&v206);
        }
      }
      else
      {
        if ( ++*(_DWORD *)(a1 + 0x180) > 0x1E8480u )
          *(_DWORD *)(a1 + 0x180) = 0xF4241;
        v149 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x68LL))(
                 qword_149C8DF28,
                 *(unsigned int *)(v19 + 0x28));
        if ( v149
          || (v149 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x10LL))(qword_149C8DF28)) != 0 )
        {
          v150 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v149 + 0x150LL))(
                   v149,
                   v230,
                   v19 + 0x158);
          v151 = *(_DWORD *)(a1 + 0x180);
          v205 = 1.0;
          v202 = *(__m256 *)v150;
          v203 = *(_OWORD *)(v150 + 0x20);
          v204 = *(_QWORD *)(v150 + 0x30);
          *(_DWORD *)(v19 + 0x1D8) = v151;
          __asm { vzeroupper }
          sub_145E2C090(v151, (__int64)&v202, "Projectile+Shell", "bullet");
          *(_BYTE *)(v19 + 0x1DC) = 1;
        }
      }
    }
    if ( *(int *)(n29 + 0x12F4) > 0 )
    {
      v155 = (__int64 *)(*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x590LL))(qword_149C8E018);
      if ( v155 )
      {
        v156 = *v155;
        LODWORD(v168) = 0xFF0000FF;
        (*(void (__fastcall **)(__int64 *, double *, double **, double *, double **, int, unsigned int))(v156 + 0x30))(
          v155,
          &v185,
          &v168,
          &v192,
          &v168,
          0x3F800000,
          0xFFFFFFFF);
      }
    }
    v147 = 1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 0x154) == *(_DWORD *)(v19 + 0xC0) )
      *(_DWORD *)(a1 + 0x154) = 0xFFFFFFFF;
    if ( dword_149FB1608 && *(_BYTE *)(v19 + 0x1DC) )
    {
      sub_145E2DBD0(*(_DWORD *)(v19 + 0x1D8));
      *(_BYTE *)(v19 + 0x1DC) = 0;
    }
    if ( *(_QWORD *)(v19 + 0x1D0) && sub_1403C4E50(*(_QWORD *)(v19 + 0x18) + 0x100LL) )
    {
      v141 = *(_QWORD *)(v19 + 0x1D0);
      v142 = *(void (__fastcall **)(__int64, _QWORD, _QWORD, __int64))(*(_QWORD *)v141 + 0x20LL);
      v143 = AK::WriteBytesMem::Count((AK::WriteBytesMem *)(*(_QWORD *)(v19 + 0x18) + 0x120LL));
      v144 = AK::WriteBytesMem::Count((AK::WriteBytesMem *)(*(_QWORD *)(v19 + 0x18) + 0x100LL));
      LOBYTE(v145) = 1;
      v142(v141, v144, v143, v145);
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(v19 + 0x1D0) + 0x58LL))(*(_QWORD *)(v19 + 0x1D0));
      _Whereptr = *(const vraudio::AudioBuffer ***)(a1 + 0x120);
      if ( _Whereptr != *(const vraudio::AudioBuffer ***)(a1 + 0x128) )
      {
        *_Whereptr = *(const vraudio::AudioBuffer **)(v19 + 0x1D0);
        *(_QWORD *)(a1 + 0x120) += 8LL;
        sub_145E2ED90(v19);
        v147 = 0;
        goto LABEL_99;
      }
      std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        (std::vector<vraudio::AudioBuffer const *> *)(a1 + 0x118),
        _Whereptr,
        (const vraudio::AudioBuffer **)(v19 + 0x1D0));
    }
    sub_145E2ED90(v19);
    v147 = 0;
  }
LABEL_99:
  v157 = *(_DWORD *)(v19 + 0x14);
  if ( v157 )
  {
    *(_DWORD *)(v19 + 0x14) = v157 - 1;
  }
  else
  {
    *(_DWORD *)(v19 + 0x10) = 0xFFFFFFFF;
    v158 = _InterlockedCompareExchange((volatile signed __int32 *)v19, 0, 1);
    if ( v158 == 1 )
      *(_QWORD *)(v19 + 8) = &p_Src;
    else
      sub_1403DF590(v19, v158);
  }
  rw_lock_release_read_lock(a1 + 0xC8);
  v181 = __rdtsc();
  qword_149C89AA8(&n0x5300);
  return v147;
}

// --- End Function: sub_145E3B8B0 (0x145E3B8B0) ---

// --- Function: sub_145E3C7C0 (0x145E3C7C0) ---
__int64 __fastcall sub_145E3C7C0(__int64 a1, float a2)
{
  __int128 v2; // xmm8
  __int64 v4; // rsi
  signed __int64 v5; // rdx
  __int64 _Newcapacity_1; // r13
  __int64 v7; // r8
  __int64 v8; // rax
  __int128 v9; // xmm6
  double v10; // xmm7_8
  __int128 *v11; // r14
  int *v12; // rdi
  unsigned int v13; // r12d
  __int64 p_p_Src_1; // r8
  unsigned __int64 v15; // rax
  const void *v16; // rcx
  unsigned __int64 _Newcapacity_2; // rax
  __int64 v18; // r12
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // r12
  __int64 v21; // rax
  _QWORD *_Newvec; // rdi
  bool v23; // zf
  __int64 v24; // rcx
  int v25; // eax
  __int64 v26; // r12
  __int64 v27; // rax
  __int128 v28; // xmm1
  unsigned __int64 n0x200000; // rax
  __int64 v30; // rax
  __int128 *v31; // rdi
  signed __int64 v32; // rbx
  __int64 v33; // rdx
  int v34; // esi
  unsigned __int64 v35; // r14
  __int64 v36; // rdi
  unsigned int v37; // ebx
  __int64 v38; // rax
  __int64 v39; // r8
  int v40; // ecx
  __int64 v41; // rcx
  int v42; // eax
  unsigned __int64 n0x200000_1; // rax
  __int64 v44; // rcx
  char v46; // [rsp+38h] [rbp-D0h]
  __int128 v47; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v48; // [rsp+50h] [rbp-B8h]
  signed __int64 v49; // [rsp+58h] [rbp-B0h] BYREF
  const ULONG_PTR *p_p_Src; // [rsp+60h] [rbp-A8h]
  unsigned int v51; // [rsp+68h] [rbp-A0h]
  int v52; // [rsp+6Ch] [rbp-9Ch]
  unsigned __int64 v53; // [rsp+78h] [rbp-90h] BYREF
  unsigned __int64 _Newcapacity; // [rsp+80h] [rbp-88h]
  __int128 *v55; // [rsp+88h] [rbp-80h]
  signed __int64 *p_rw_lock_state; // [rsp+90h] [rbp-78h]
  int *v57; // [rsp+98h] [rbp-70h]
  int v58; // [rsp+A0h] [rbp-68h] BYREF
  __int128 *v59; // [rsp+A8h] [rbp-60h]
  signed __int64 *v60; // [rsp+B0h] [rbp-58h]
  int *v61; // [rsp+B8h] [rbp-50h]
  int v62; // [rsp+C0h] [rbp-48h] BYREF
  __int128 v63; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v64; // [rsp+D8h] [rbp-30h]
  int n0x5300; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v66; // [rsp+ECh] [rbp-1Ch]
  int v67; // [rsp+F4h] [rbp-14h]
  unsigned __int64 v68; // [rsp+F8h] [rbp-10h]
  unsigned __int64 v69; // [rsp+100h] [rbp-8h]
  __int64 v70; // [rsp+108h] [rbp+0h]
  __int64 v71; // [rsp+110h] [rbp+8h]
  __m256 v72; // [rsp+138h] [rbp+30h]
  __int128 v73; // [rsp+158h] [rbp+50h]
  _QWORD v74[4]; // [rsp+168h] [rbp+60h] BYREF
  __int64 v75; // [rsp+188h] [rbp+80h] BYREF
  void (__fastcall *n2_2)(__int64, __int64 *); // [rsp+190h] [rbp+88h]
  unsigned __int64 (__fastcall *p_sub_145E09110)(__int64, __int64, int); // [rsp+1A0h] [rbp+98h] BYREF
  void (__fastcall *n2)(int, unsigned __int64 (__fastcall **)(__int64, __int64, int), unsigned __int64 (__fastcall **)(__int64, __int64, int)); // [rsp+1A8h] [rbp+A0h]
  __int64 v79; // [rsp+1B0h] [rbp+A8h]
  __int64 v80; // [rsp+1B8h] [rbp+B0h] BYREF
  void (__fastcall *n2_1)(__int64, __int64 *); // [rsp+1C0h] [rbp+B8h]
  int _Newcapacity_3; // [rsp+1D0h] [rbp+C8h]
  unsigned __int64 v83[2]; // [rsp+1D8h] [rbp+D0h] BYREF
  __int64 v84; // [rsp+1E8h] [rbp+E0h]
  char n0x10; // [rsp+1F8h] [rbp+F0h]
  __int128 v86; // [rsp+258h] [rbp+150h]

  v86 = v2;
  n0x5300 = 0x5300;
  v67 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v66 = 1;
  v68 = __rdtsc();
  qword_149C89AA0(
    &n0x5300,
    &word_149FB19C0,
    "CProjectileManager::UpdateProjectiles",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileManager.cpp",
    0x1D6);
  v4 = a1 + 0xC8;
  HIWORD(n0x5300) = word_149FB19C0;
  if ( *(_DWORD *)(a1 + 0xD8) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0xDC);
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)v4);
    if ( (v5 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0xC8, v5, (const char *)&p_Src, (const char *)&p_Src, 1);
  }
  _Newcapacity_1 = (__int64)(*(_QWORD *)(a1 + 0x88) - *(_QWORD *)(a1 + 0x80)) >> 2;
  v46 = sub_14452C910();
  v64 = 0x7FF0000000000001LL;
  *((_QWORD *)&v63 + 1) = 0x7FF0000000000001LL;
  v7 = *(_QWORD *)qword_149C8DFD8;
  *(_QWORD *)&v63 = 0x7FF0000000000001LL;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(v7 + 0xF8))(qword_149C8DFD8, &v53);
  if ( is_entity_descriptor_valid_or_accessible(&v53) )
  {
    v8 = (*(__int64 (__fastcall **)(unsigned __int64, __int128 *, __int64))(*(_QWORD *)(v53 & 0xFFFFFFFFFFFFLL) + 0x2C8LL))(
           v53 & 0xFFFFFFFFFFFFLL,
           &v63,
           1);
    v9 = *(_OWORD *)v8;
    v10 = *(double *)(v8 + 0x10);
  }
  else
  {
    v10 = *(double *)&v64;
    v9 = v63;
  }
  v48 = 0;
  v49 = 0;
  p_p_Src = &p_Src;
  v11 = &v47;
  v52 = 0;
  v12 = &v62;
  v59 = &v47;
  v61 = &v62;
  v47 = 0;
  v51 = 0xFFFFFFFF;
  v60 = &v49;
  v62 = 1;
  __asm { vzeroupper }
  v13 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( v13 == 0xFFFFFFFF )
  {
    v52 = 1;
  }
  else
  {
    p_p_Src_1 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v15 = _InterlockedCompareExchange64(&v49, 0x200000, 0);
    if ( v15 )
      sub_1403E1120((__int64)&v49, v15, p_p_Src_1, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      p_p_Src = (const ULONG_PTR *)p_p_Src_1;
    v12 = v61;
    v11 = v59;
    v51 = v13;
  }
  v16 = *(const void **)v11;
  _Newcapacity_2 = (__int64)(*((_QWORD *)v11 + 2) - *(_QWORD *)v11) >> 4;
  _Newcapacity = (int)_Newcapacity_1;
  if ( (int)_Newcapacity_1 > _Newcapacity_2 )
  {
    if ( (unsigned __int64)(int)_Newcapacity_1 > 0xFFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v18 = *((_QWORD *)v11 + 1) - (_QWORD)v16;
    allocSize = 0x10LL * (int)_Newcapacity_1;
    _Newsize = v18 >> 4;
    if ( allocSize < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)sub_1402A65A0(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E3880();
      v21 = sub_1402A65A0(allocSize + 0x27);
      if ( !v21 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v21 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v21;
    }
    memmove(_Newvec, *(const void **)v11, *((_QWORD *)v11 + 1) - *(_QWORD *)v11);
    std::vector<Eigen::Triplet<double,int>>::_Change_array(
      (std::vector<Eigen::Triplet<double,int>> *)v11,
      (Eigen::Triplet<double,int> *const)_Newvec,
      _Newsize,
      _Newcapacity);
    v12 = v61;
  }
  v23 = (*v12)-- == 1;
  if ( !v23 )
    goto LABEL_28;
  v24 = (__int64)v60;
  v25 = *((_DWORD *)v60 + 5);
  if ( v25 )
  {
    *((_DWORD *)v60 + 5) = v25 - 1;
LABEL_28:
    v26 = 0;
    goto LABEL_29;
  }
  *((_DWORD *)v60 + 4) = 0xFFFFFFFF;
  v26 = 0;
  n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v24, 0, 0x200000);
  if ( n0x200000 == 0x200000 )
    *(_QWORD *)(v24 + 8) = &p_Src;
  else
    rw_lock_handle_write_release_contention(v24, n0x200000);
LABEL_29:
  sub_1402B3B60((__int64)&v75, 0x53, 4, "CProjectileManager::UpdateProjectiles");
  LOBYTE(v72.m256_f32[3]) = v46;
  *((_QWORD *)&v73 + 1) = &v47;
  _Newcapacity_3 = _Newcapacity_1;
  n0x10 = 0x10;
  *(_QWORD *)v72.m256_f32 = a1;
  v72.m256_f32[2] = a2;
  *(_OWORD *)&v72.m256_f32[4] = v9;
  *(double *)&v73 = v10;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, unsigned __int64 (__fastcall **)(__int64, __int64, int)))n2)(2, &p_sub_145E09110);
    n2 = 0;
  }
  p_sub_145E09110 = 0;
  v27 = sub_1402A65A0(0x30u);
  if ( v27 )
  {
    v28 = v73;
    *(__m256 *)v27 = v72;
    *(_OWORD *)(v27 + 0x20) = v28;
    v79 = v27;
  }
  else
  {
    v79 = 0;
  }
  p_sub_145E09110 = sub_145E09110;
  n2 = sub_145E0A310;
  __asm { vzeroupper }
  v30 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, &v75);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x48LL))(qword_149C8E038, v30);
  v58 = 1;
  p_rw_lock_state = &v49;
  v31 = &v47;
  v55 = &v47;
  v57 = &v58;
  if ( v51 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++v52;
  }
  else
  {
    v32 = _InterlockedIncrement64(&v49);
    if ( (v32 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch((__int64)&v49, v32, (const char *)&p_Src, (const char *)&p_Src, 1);
    v31 = v55;
  }
  qword_149C89AE0("Projectiles: %u Removed: %u", _Newcapacity_1, (__int64)(*((_QWORD *)v31 + 1) - *(_QWORD *)v31) >> 4);
  rw_lock_release_read_lock(a1 + 0xC8);
  sub_1402E0A70(a1 + 0xC8, "CProjectileManager::UpdateProjectiles", "m_projectilesLock", 1);
  v33 = *(_QWORD *)v55;
  if ( (__int64)(*((_QWORD *)v55 + 1) - *(_QWORD *)v55) >> 4 )
  {
    v34 = 0;
    v35 = 4 * _Newcapacity;
    do
    {
      v36 = *(int *)(v26 + v33);
      v37 = *(_DWORD *)(v26 + v33 + 8);
      v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0x428LL))(qword_149C8DF40);
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v38 + 0x10LL))(v38, v37);
      v39 = *(_QWORD *)(a1 + 0x80);
      v35 -= 4LL;
      ++v34;
      v26 += 0x10;
      LODWORD(_Newcapacity_1) = _Newcapacity_1 - 1;
      v40 = *(_DWORD *)(v39 + 4 * v36);
      *(_DWORD *)(v39 + 4 * v36) = *(_DWORD *)(v35 + v39);
      *(_DWORD *)(v35 + v39) = v40;
      v33 = *(_QWORD *)v55;
    }
    while ( v34 < (unsigned __int64)((__int64)(*((_QWORD *)v55 + 1) - *(_QWORD *)v55) >> 4) );
    v4 = a1 + 0xC8;
  }
  sub_145DFC180(
    (_QWORD *)(a1 + 0x58),
    v74,
    *(_QWORD *)(a1 + 0x78),
    (int *)(*(_QWORD *)(a1 + 0x80) + 4LL * (int)_Newcapacity_1),
    *(int **)(a1 + 0x88));
  v41 = *(_QWORD *)(a1 + 0x80) + 4LL * (int)_Newcapacity_1;
  if ( v41 != *(_QWORD *)(a1 + 0x88) )
    *(_QWORD *)(a1 + 0x88) = v41;
  if ( v4 )
  {
    v42 = *(_DWORD *)(v4 + 0x14);
    if ( v42 )
    {
      *(_DWORD *)(v4 + 0x14) = v42 - 1;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      n0x200000_1 = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0, 0x200000);
      if ( n0x200000_1 == 0x200000 )
        *(_QWORD *)(v4 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v4, n0x200000_1);
    }
  }
  v23 = (*v57)-- == 1;
  if ( v23 )
    rw_lock_release_read_lock((__int64)p_rw_lock_state);
  if ( v83[0] )
  {
    sub_1403A6820((__int64)v83, v83[0], (v84 - v83[0]) & 0xFFFFFFFFFFFFFFF8uLL);
    v83[0] = 0;
    v83[1] = 0;
    v84 = 0;
  }
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, &v80);
    n2_1 = 0;
  }
  v80 = 0;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, unsigned __int64 (__fastcall **)(__int64, __int64, int)))n2)(2, &p_sub_145E09110);
    n2 = 0;
  }
  p_sub_145E09110 = 0;
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, &v75);
    n2_2 = 0;
  }
  v44 = v47;
  v75 = 0;
  if ( (_QWORD)v47 )
  {
    if ( ((v48 - (_QWORD)v47) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      v44 = *(_QWORD *)(v47 - 8);
      if ( (unsigned __int64)(v47 - v44 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A6590(v44);
    v47 = 0;
    v48 = 0;
  }
  v69 = __rdtsc();
  return qword_149C89AA8(&n0x5300);
}

// --- End Function: sub_145E3C7C0 (0x145E3C7C0) ---

// --- Function: sub_146202A40 (0x146202A40) ---
_QWORD *__fastcall sub_146202A40(__int64 a1, _QWORD *a2)
{
  if ( is_valid_handle_typeA((__int64 *)(a1 + 0x2F8)) )
    *a2 = *(_QWORD *)((*(_QWORD *)(a1 + 0x2F8) & 0xFFFFFFFFFFFFLL) + 8);
  else
    sub_1402B3CF0(a2);
  return a2;
}

// --- End Function: sub_146202A40 (0x146202A40) ---

// --- Function: sub_146580240 (0x146580240) ---
__int64 __fastcall sub_146580240(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x200);
  if ( v1 )
    return sub_1443ADBC0(v1);
  else
    return 0xFFFFFFFFLL;
}

// --- End Function: sub_146580240 (0x146580240) ---

// --- Function: sub_146581420 (0x146581420) ---
__int64 __fastcall sub_146581420(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x200);
  if ( v1 )
    return sub_1443B09E0(v1);
  else
    return 0;
}

// --- End Function: sub_146581420 (0x146581420) ---

// --- Function: sub_146583C90 (0x146583C90) ---
bool __fastcall sub_146583C90(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rax

  v2 = *(_QWORD *)(a1 + 0x200);
  if ( !v2 || !sub_1443AE730(v2) )
    return 0;
  v3 = *(_QWORD *)(a1 + 0x200);
  if ( !v3 )
    return (*(unsigned int (**)(void))(MEMORY[0] + 0x7E0LL))() == 2;
  v4 = sub_1443AE730(v3);
  return (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x7E0LL))(v4) == 2;
}

// --- End Function: sub_146583C90 (0x146583C90) ---

// --- Function: sub_1465DCF30 (0x1465DCF30) ---
void *sub_1465DCF30()
{
  if ( (dword_149FBE970 & 1) == 0 )
  {
    dword_149FBE970 |= 1u;
    sub_1465E1B90(&unk_149FBE920, 0);
    atexit(nullsub_122);
  }
  return &unk_149FBE920;
}

// --- End Function: sub_1465DCF30 (0x1465DCF30) ---

// --- Function: sub_1465DD010 (0x1465DD010) ---
void sub_1465DD010()
{
  __int64 v0; // rbx
  __int64 v1; // rax

  v0 = qword_149FBE618;
  if ( qword_149FBE618 && *(_BYTE *)(qword_149FBE618 + 0xEB3) && *(_BYTE *)(qword_149FBE618 + 0xB68) )
  {
    v1 = sub_144F13530();
    if ( v1 )
      sub_144F0D5E0(v1);
    *(_BYTE *)(v0 + 0xEB3) = 0;
  }
}

// --- End Function: sub_1465DD010 (0x1465DD010) ---

// --- Function: sub_1465DD080 (0x1465DD080) ---
__int64 __fastcall sub_1465DD080(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  volatile signed __int32 *v4; // rcx
  __int64 result; // rax

  if ( a1 != a2 )
  {
    v3 = a1;
    do
    {
      v4 = *(volatile signed __int32 **)(v3 + 8);
      if ( v4 )
      {
        result = (unsigned int)_InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF);
        if ( (_DWORD)result == 1 )
          result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
      }
      v3 += 0x10;
    }
    while ( v3 != a2 );
  }
  return result;
}

// --- End Function: sub_1465DD080 (0x1465DD080) ---

// --- Function: sub_1465DD300 (0x1465DD300) ---
void __fastcall sub_1465DD300(__int64 *a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbp
  __int64 v6; // rdx
  __int64 v8; // r13
  __int64 v11; // rcx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v17; // rax
  __int64 v18; // rsi
  __int64 v19; // r14
  __int64 v20; // r8
  __int64 v21; // r14
  _QWORD *v22; // rdi
  _QWORD *v23; // rcx
  __int64 v24; // rax
  __int64 v25; // rdx
  volatile signed __int32 *v26; // rcx
  __int64 v27; // rcx
  _QWORD *v28; // rcx
  unsigned __int64 v29; // r14
  __int64 v30; // rdx
  __int64 v31; // [rsp+60h] [rbp+8h]

  if ( !a4 )
    return;
  v4 = a1[1];
  v6 = a1[2];
  v8 = *a1;
  if ( a4 > (v6 - v4) >> 4 )
  {
    v11 = (v4 - v8) >> 4;
    if ( a4 > 0xFFFFFFFFFFFFFFFLL - v11 )
      unknown_libname_10();
    v12 = v11 + a4;
    v13 = (v6 - v8) >> 4;
    v31 = v11 + a4;
    v14 = v13 >> 1;
    if ( v13 <= 0xFFFFFFFFFFFFFFFLL - (v13 >> 1) )
    {
      v15 = v12;
      if ( v14 + v13 >= v12 )
        v15 = v14 + v13;
      if ( v15 <= 0xFFFFFFFFFFFFFFFLL )
      {
        allocSize = 0x10 * v15;
        if ( 0x10 * v15 < 0x1000 )
        {
          if ( allocSize )
            v18 = sub_1402A65A0(allocSize);
          else
            v18 = 0;
LABEL_16:
          v19 = (a2 - v8) >> 4;
          sub_1465DD5F0(a3, a4, v18 + 0x10 * v19, a1);
          if ( a4 == 1 && a2 == v4 )
          {
            v20 = v18;
          }
          else
          {
            sub_1465DD640(v8, a2, v18, a1);
            v8 = a2;
            v20 = v18 + 0x10 * (v19 + a4);
          }
          sub_1465DD640(v8, v4, v20, a1);
          sub_1402E1280(a1, v18, v31, v15);
          return;
        }
        if ( allocSize + 0x27 >= allocSize )
        {
          v17 = sub_1402A65A0(allocSize + 0x27);
          if ( !v17 )
            invalid_parameter_noinfo_noreturn();
          v18 = (v17 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
          *(_QWORD *)(v18 - 8) = v17;
          goto LABEL_16;
        }
      }
    }
    sub_1402E3880();
  }
  v21 = 0x10 * a4;
  if ( a4 >= (v4 - a2) >> 4 )
  {
    v28 = (_QWORD *)(v21 + a2);
    if ( a2 != v4 )
    {
      v29 = 0x1FFFFFFFFFFFFFFELL * a4;
      v30 = 8 - 0x10 * a4;
      do
      {
        *v28 = 0;
        v28[1] = 0;
        *v28 = v28[v29];
        v28[1] = *(_QWORD *)((char *)v28 + v30);
        v28[v29] = 0;
        *(_QWORD *)((char *)v28 + v30) = 0;
        v28 += 2;
      }
      while ( &v28[v29] != (_QWORD *)v4 );
    }
    a1[1] = (__int64)v28;
    sub_1465DD080(a2, v4);
    v27 = a3;
  }
  else
  {
    v22 = (_QWORD *)(v4 - v21);
    v23 = (_QWORD *)a1[1];
    if ( v4 - v21 != v4 )
    {
      do
      {
        *v23 = 0;
        v23[1] = 0;
        *v23 = v23[0xFFFFFFFE * a4];
        v23[1] = v23[v21 / 0xFFFFFFFFFFFFFFF8uLL + 1];
        v23[0xFFFFFFFE * a4] = 0;
        v23[v21 / 0xFFFFFFFFFFFFFFF8uLL + 1] = 0;
        v23 += 2;
      }
      while ( &v23[v21 / 0xFFFFFFFFFFFFFFF8uLL] != (_QWORD *)v4 );
    }
    a1[1] = (__int64)v23;
    while ( v22 != (_QWORD *)a2 )
    {
      v24 = v22[0xFFFFFFFE];
      v22 += 0xFFFFFFFE;
      v25 = v22[1];
      *v22 = 0;
      v22[1] = 0;
      v26 = (volatile signed __int32 *)v22[(unsigned __int64)v21 / 8 + 1];
      v22[(unsigned __int64)v21 / 8] = v24;
      v22[(unsigned __int64)v21 / 8 + 1] = v25;
      if ( v26 && _InterlockedExchangeAdd(v26 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v26 + 8LL))(v26);
    }
    sub_1465DD080(a2, v21 + a2);
    v27 = a3;
  }
  sub_1465DD5F0(v27, a4, a2, a1);
}

// --- End Function: sub_1465DD300 (0x1465DD300) ---

// --- Function: sub_1465DD5F0 (0x1465DD5F0) ---
_QWORD *__fastcall sub_1465DD5F0(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *result; // rax
  __int64 *v4; // r8
  char *v5; // r9
  __int64 v6; // rcx

  result = a3;
  if ( a2 )
  {
    v4 = (__int64 *)(a1 + 8);
    v5 = (char *)result - a1;
    do
    {
      *result = 0;
      *(__int64 *)((char *)v4 + (_QWORD)v5) = 0;
      if ( *v4 )
      {
        *result = v4[0xFFFFFFFF];
        v6 = *v4;
        *(__int64 *)((char *)v4 + (_QWORD)v5) = *v4;
        _InterlockedIncrement((volatile signed __int32 *)(v6 + 0xC));
      }
      result += 2;
      v4 += 2;
      --a2;
    }
    while ( a2 );
  }
  return result;
}

// --- End Function: sub_1465DD5F0 (0x1465DD5F0) ---

// --- Function: sub_1465DD640 (0x1465DD640) ---
char *__fastcall sub_1465DD640(char *a1, char *a2, char *a3)
{
  signed __int64 v3; // rcx

  if ( a1 != a2 )
  {
    v3 = a1 - a3;
    do
    {
      *(_QWORD *)a3 = 0;
      *((_QWORD *)a3 + 1) = 0;
      *(_QWORD *)a3 = *(_QWORD *)&a3[v3];
      *((_QWORD *)a3 + 1) = *(_QWORD *)&a3[v3 + 8];
      *(_QWORD *)&a3[v3] = 0;
      *(_QWORD *)&a3[v3 + 8] = 0;
      a3 += 0x10;
    }
    while ( &a3[v3] != a2 );
  }
  return a3;
}

// --- End Function: sub_1465DD640 (0x1465DD640) ---

// --- Function: sub_1465DD690 (0x1465DD690) ---
char __fastcall sub_1465DD690(
        int n3,
        __int64 a2,
        void *p_SystemInit,
        __int64 p_Discipline_init_failed:_%u___%s,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 ThreadLogContextSlot,
        __int64 a10,
        const char **a11)
{
  void *v13; // rsp
  unsigned __int64 v14; // rax
  const char *p_null_1; // rdx
  const char *p_null; // rcx
  __int64 v18; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  __int64 v23; // [rsp+A0h] [rbp-E0h]
  const char *p_Unnamed_UInt; // [rsp+A8h] [rbp-D8h]
  __int64 v25; // [rsp+B0h] [rbp-D0h]
  __int64 (__fastcall *p_sub_140A38BB0)(unsigned __int16 *, __int64, int); // [rsp+B8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_140A38BB0_1)(unsigned __int16 *, __int64, int); // [rsp+C0h] [rbp-C0h]
  __int64 v28; // [rsp+C8h] [rbp-B8h]
  bool (__fastcall *p_unknown_libname)(_WORD *, _WORD *); // [rsp+D0h] [rbp-B0h]
  __int64 v30; // [rsp+D8h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E9230)(__int64); // [rsp+E0h] [rbp-A0h]
  __int64 (__fastcall *p_sub_1403E8F30)(); // [rsp+E8h] [rbp-98h]
  unsigned __int64 v33; // [rsp+F0h] [rbp-90h]
  __int16 v34; // [rsp+F8h] [rbp-88h]
  __int64 n2; // [rsp+100h] [rbp-80h]
  __int64 n0x15; // [rsp+108h] [rbp-78h]
  const char *p_null_2; // [rsp+110h] [rbp-70h]
  const char *p_Unnamed_Text; // [rsp+118h] [rbp-68h]
  __int64 v39; // [rsp+120h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EF740)(const char *, _BYTE *, size_t, __int64, char); // [rsp+128h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EF1F0)(const char *, _BYTE *, int); // [rsp+130h] [rbp-50h]
  __int64 v42; // [rsp+138h] [rbp-48h]
  bool (__fastcall *p_sub_1403EB9C0)(unsigned __int8 *, unsigned __int8 *); // [rsp+140h] [rbp-40h]
  __int64 v44; // [rsp+148h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E9230_1)(__int64); // [rsp+150h] [rbp-30h]
  __int64 (__fastcall *p_sub_1403E8F30_1)(); // [rsp+158h] [rbp-28h]
  unsigned __int64 v47; // [rsp+160h] [rbp-20h]
  __int16 v48; // [rsp+168h] [rbp-18h]
  __int64 n8; // [rsp+170h] [rbp-10h]
  unsigned __int64 v50; // [rsp+178h] [rbp-8h]

  v13 = alloca(0x150);
  v23 = a10;
  p_Unnamed_UInt = "Unnamed_UInt";
  p_sub_140A38BB0 = sub_140A38BB0;
  p_sub_140A38BB0_1 = sub_140A38BB0;
  p_unknown_libname = unknown_libname_20;
  p_sub_1403E9230 = sub_1403E9230;
  p_sub_1403E8F30 = sub_1403E8F30;
  __Val_0___[0] = ThreadLogContextSlot;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  v14 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v34 = 0;
  v25 = 0;
  v28 = 0;
  v30 = 0;
  v33 = 0xFFFFFFFFFFFFFFFFuLL;
  n2 = 2;
  n0x15 = 0x15;
  p_null_1 = *a11;
  p_Unnamed_Text = "Unnamed_Text";
  p_null_2 = p_null_1;
  p_sub_1403EF740 = sub_1403EF740;
  p_sub_1403EF1F0 = sub_1403EF1F0;
  p_sub_1403EB9C0 = sub_1403EB9C0;
  p_sub_1403E9230_1 = sub_1403E9230;
  p_sub_1403E8F30_1 = sub_1403E8F30;
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  v48 = 0;
  v39 = 0;
  v42 = 0;
  v44 = 0;
  v47 = 0xFFFFFFFFFFFFFFFFuLL;
  n8 = 8;
  do
    ++v14;
  while ( p_null[v14] );
  v50 = v14 + 2;
  LODWORD(v18) = a6;
  return sub_140306CF0(
           n3,
           a2,
           p_SystemInit,
           p_Discipline_init_failed:_%u___%s,
           (__int64)__Val_0___,
           3u,
           a5,
           v18,
           a7,
           a8);
}

// --- End Function: sub_1465DD690 (0x1465DD690) ---

// --- Function: sub_1465DD8E0 (0x1465DD8E0) ---
char __fastcall sub_1465DD8E0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v12; // rsp
  const char *p_null; // rcx
  unsigned __int64 v14; // rax
  __int64 v16; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  _QWORD *v21; // [rsp+A0h] [rbp-E0h]
  Error **p_Error; // [rsp+A8h] [rbp-D8h]
  __int64 v23; // [rsp+B0h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1403EF810)(__int64, void *, size_t, __int64, char); // [rsp+B8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403EF370)(__int64, __int64, __int64, __int64); // [rsp+C0h] [rbp-C0h]
  __int64 v26; // [rsp+C8h] [rbp-B8h]
  bool (__fastcall *p_sub_1403EBA20)(__int64, __int64); // [rsp+D0h] [rbp-B0h]
  __int64 v28; // [rsp+D8h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E9250)(__int64); // [rsp+E0h] [rbp-A0h]
  _QWORD *(__fastcall *p_sub_1403E8F70)(_QWORD *); // [rsp+E8h] [rbp-98h]
  unsigned __int64 v31; // [rsp+F0h] [rbp-90h]
  char v32; // [rsp+F8h] [rbp-88h]
  char v33; // [rsp+F9h] [rbp-87h]
  __int64 n0x18; // [rsp+100h] [rbp-80h]
  unsigned __int64 v35; // [rsp+108h] [rbp-78h]
  _QWORD *v36; // [rsp+110h] [rbp-70h]
  const char *p_ErrorCode; // [rsp+118h] [rbp-68h]
  __int64 v38; // [rsp+120h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EF3A0)(__int64, __int64, __int64); // [rsp+128h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EF3A0_1)(__int64, __int64, __int64); // [rsp+130h] [rbp-50h]
  __int64 v41; // [rsp+138h] [rbp-48h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+140h] [rbp-40h]
  __int64 v43; // [rsp+148h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E9240)(__int64); // [rsp+150h] [rbp-30h]
  _OWORD *(__fastcall *p_sub_1403E8F40)(_OWORD *); // [rsp+158h] [rbp-28h]
  unsigned __int64 v46; // [rsp+160h] [rbp-20h]
  char v47; // [rsp+168h] [rbp-18h]
  char v48; // [rsp+169h] [rbp-17h]
  __int64 n0x10; // [rsp+170h] [rbp-10h]
  __int64 n0x15; // [rsp+178h] [rbp-8h]

  v12 = alloca(0x150);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  p_Error = "Error";
  v21 = a10;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v33 = 0;
  v23 = *a10;
  p_sub_1403EF810 = sub_1403EF810;
  p_sub_1403EF370 = sub_1403EF370;
  p_sub_1403EBA20 = sub_1403EBA20;
  p_sub_1403E9250 = sub_1403E9250;
  p_sub_1403E8F70 = sub_1403E8F70;
  v26 = 0;
  v28 = 0;
  v31 = 0xFFFFFFFFFFFFFFFFuLL;
  v32 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  v14 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v14;
  while ( p_null[v14] );
  v35 = v14;
  v36 = a11;
  p_ErrorCode = "ErrorCode";
  v48 = 0;
  v38 = *a11;
  p_sub_1403EF3A0 = sub_1403EF3A0;
  p_sub_1403EF3A0_1 = sub_1403EF3A0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E9240 = sub_1403E9240;
  p_sub_1403E8F40 = sub_1403E8F40;
  LODWORD(v16) = a6;
  v41 = 0;
  v43 = 0;
  v46 = 0xFFFFFFFFFFFFFFFFuLL;
  v47 = 0;
  n0x10 = 0x10;
  n0x15 = 0x15;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 3u, a5, v16, a7, a8);
}

// --- End Function: sub_1465DD8E0 (0x1465DD8E0) ---

// --- Function: sub_1465E1B90 (0x1465E1B90) ---
__int64 __fastcall sub_1465E1B90(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 result; // rax

  *(_QWORD *)(a1 + 0x20) = a2;
  *(_QWORD *)(a1 + 8) = "services";
  *(_QWORD *)(a1 + 0x40) = a1;
  *(_QWORD *)(a1 + 0x10) = "discipline_enforcement";
  *(_QWORD *)(a1 + 0x18) = "Discipline Enforcement Configuration";
  *(_QWORD *)a1 = &off_1482DC368;
  *(_QWORD *)(a1 + 0x28) = &off_1482B5178;
  *(_QWORD *)(a1 + 0x30) = off_148CFA3A0;       // "eac_enable_initialisation_check"
  *(_QWORD *)(a1 + 0x38) = 0;
  v3 = *(_QWORD *)(a1 + 0x20);
  if ( v3 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v3 + 0x60LL))(v3, a1, a1 + 0x28);
  *(_QWORD *)(a1 + 0x28) = &off_1482B51A8;
  result = a1;
  *(_DWORD *)(a1 + 0x48) = 1;
  return result;
}

// --- End Function: sub_1465E1B90 (0x1465E1B90) ---

// --- Function: sub_1465E3F20 (0x1465E3F20) ---
int __fastcall sub_1465E3F20(__int64 a1, char *p_game_map, const char *p_Unknown)
{
  unsigned __int64 v3; // rax
  int result; // eax

  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v3;
  while ( byte_149C8E140[v3] );
  result = snprintf_s(&byte_149C8E140[v3], 0x80 - v3, 0xFFFFFFFFFFFFFFFFuLL, "<%s>%s</>\n", p_game_map, p_Unknown);
  byte_149C8E1BF = 0;
  return result;
}

// --- End Function: sub_1465E3F20 (0x1465E3F20) ---

// --- Function: sub_1465E3F80 (0x1465E3F80) ---
void __fastcall sub_1465E3F80(__int64 a1)
{
  __int64 v1; // rdi
  void (__fastcall *v2)(__int64, __int64, __int64); // rbx
  __int64 v3; // rax
  _BYTE v4[176]; // [rsp+20h] [rbp-D8h] BYREF
  __int64 v5; // [rsp+D0h] [rbp-28h] BYREF

  v1 = qword_149C8DFE0;
  v2 = *(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DFE0 + 0xC8LL);
  v3 = sub_1404214A0((__int64)v4, 0x7552, *(const void ***)(a1 + 0x10));
  v2(v1, v3, 0x1E);
  sub_140373CC0(&v5);
}

// --- End Function: sub_1465E3F80 (0x1465E3F80) ---

// --- Function: sub_1465E4000 (0x1465E4000) ---
void __fastcall sub_1465E4000(__int64 a1)
{
  __int64 v1; // rdi
  void (__fastcall *v2)(__int64, __int64, __int64); // rbx
  __int64 v3; // rax
  _BYTE v4[176]; // [rsp+20h] [rbp-D8h] BYREF
  __int64 v5; // [rsp+D0h] [rbp-28h] BYREF

  v1 = qword_149C8DFE0;
  v2 = *(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149C8DFE0 + 0xC8LL);
  v3 = sub_1404214A0((__int64)v4, 0x7551, *(const void ***)(a1 + 0x10));
  v2(v1, v3, 0x1E);
  sub_140373CC0(&v5);
}

// --- End Function: sub_1465E4000 (0x1465E4000) ---

// --- Function: sub_1465E4080 (0x1465E4080) ---
void __fastcall sub_1465E4080(int a1, void (__fastcall **a2)(__int64 a1), void (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 v5; // rdi
  const void **v6; // rsi
  void **v7; // rax
  void **v8; // rdi

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        v5 = (__int64)a2[2];
        if ( v5 )
        {
          sub_140373CC0(a2[2]);
          sub_1402A6590(v5);
        }
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v6 = (const void **)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64))1;
      }
      else
      {
        v7 = (void **)sub_1402A65A0(8u);
        v8 = v7;
        if ( v7 )
          sub_14035DE10(v7, v6);
        else
          v8 = 0;
        a2[2] = (void (__fastcall *)(__int64))v8;
        *a2 = sub_1465E3F80;
        a2[1] = (void (__fastcall *)(__int64))sub_1465E4080;
      }
    }
  }
}

// --- End Function: sub_1465E4080 (0x1465E4080) ---

// --- Function: sub_1465E41D0 (0x1465E41D0) ---
void __fastcall sub_1465E41D0(int a1, void (__fastcall **a2)(__int64 a1), void (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 v5; // rdi
  const void **v6; // rsi
  void **v7; // rax
  void **v8; // rdi

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        v5 = (__int64)a2[2];
        if ( v5 )
        {
          sub_140373CC0(a2[2]);
          sub_1402A6590(v5);
        }
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v6 = (const void **)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64))1;
      }
      else
      {
        v7 = (void **)sub_1402A65A0(8u);
        v8 = v7;
        if ( v7 )
          sub_14035DE10(v7, v6);
        else
          v8 = 0;
        a2[2] = (void (__fastcall *)(__int64))v8;
        *a2 = sub_1465E4000;
        a2[1] = (void (__fastcall *)(__int64))sub_1465E41D0;
      }
    }
  }
}

// --- End Function: sub_1465E41D0 (0x1465E41D0) ---

// --- Function: sub_1465E4B20 (0x1465E4B20) ---
__int64 __fastcall sub_1465E4B20(__int64 a1)
{
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rsi
  _QWORD *v6; // rax
  float v8; // xmm2_4
  __int64 v10; // rax
  const ULONG_PTR *p_p_Src; // r13
  unsigned int n6_1; // r15d
  unsigned __int16 v13; // ax
  __int64 v14; // rcx
  _QWORD *v15; // rax
  int n3; // eax
  int n2; // ebx
  __int64 v18; // rcx
  _QWORD *v19; // rax
  const void **v20; // rax
  size_t Size_1; // r12
  size_t n0x7F_1; // rbx
  _BYTE *Src_1; // rax
  _BYTE *Src_2; // rbx
  size_t *v25; // rsi
  __int64 v26; // rax
  size_t Size_2; // rbx
  size_t Size_4; // rax
  char *v29; // r12
  unsigned __int64 n8; // rdx
  size_t v31; // rcx
  const char *p_@LOC_BADTOKEN_1; // rcx
  const char *p_@LOC_BADSTRING; // rax
  __int64 v34; // rax
  __int64 v35; // rbx
  __int64 v36; // rax
  __int64 *v37; // rax
  const void **v38; // rax
  int v39; // ebx
  __int64 v40; // rax
  const char *p_@Frontend_Login_Concat; // [rsp+40h] [rbp-C0h] BYREF
  size_t Size_3; // [rsp+48h] [rbp-B8h] BYREF
  int v43; // [rsp+50h] [rbp-B0h]
  const char *p_@ui_error_type_services_connection; // [rsp+58h] [rbp-A8h] BYREF
  const void *v45; // [rsp+60h] [rbp-A0h] BYREF
  int n6; // [rsp+68h] [rbp-98h]
  int n3_1; // [rsp+6Ch] [rbp-94h]
  __int64 v48; // [rsp+70h] [rbp-90h] BYREF
  void (*p_sub_1465DD010)(); // [rsp+78h] [rbp-88h] BYREF
  unsigned __int64 n2_1; // [rsp+80h] [rbp-80h]
  __int64 v51; // [rsp+88h] [rbp-78h]
  size_t Size; // [rsp+90h] [rbp-70h]
  __int64 n0x7F; // [rsp+98h] [rbp-68h]
  void *Src; // [rsp+A0h] [rbp-60h]
  _BYTE v55[136]; // [rsp+A8h] [rbp-58h] BYREF

  if ( !byte_149C8E51E )
    return 1;
  v3 = (*(__int64 (**)(void))(*(_QWORD *)qword_149C8E050 + 0x58LL))();
  v4 = sub_144F13530();
  v48 = v4;
  v5 = v4;
  if ( !v3 || !v4 )
    return 0;
  if ( *(_BYTE *)(a1 + 0xB68) )
  {
    Size_3 = 0;
    if ( sub_14059CAF0((_QWORD *)(a1 + 0xB60), &Size_3) )
    {
      v6 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
                       qword_149C8DF80,
                       &v48);
      sub_14059CA60(v6, &p_@ui_error_type_services_connection, (_QWORD *)(a1 + 0xB60));
      _XMM0 = sub_14059CC00();
      v8 = *(float *)(a1 + 0xB5C);
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      if ( *(float *)&_XMM1 > v8 )
      {
        sub_140D19250(
          (__int64)"W:/p4-src/CryEngine/Code/GameSDK/GameDll/Game.cpp",
          0x969,
          (__int64)"{SERVICE_ERROR_TIMEOUT_ELAPSED} - timeout expired [%f] seconds, closing client.",
          v8);
        return 0xFFFFFFFFFFFFFFFFuLL;
      }
    }
    if ( !(**(__int64 (__fastcall ***)(__int64))(v5 + 0x308))(v5 + 0x308) )
    {
      sub_140D19250(
        (__int64)"W:/p4-src/CryEngine/Code/GameSDK/GameDll/Game.cpp",
        0x972,
        (__int64)"{SERVICE_ERROR_POPUP_DISMISSED} - pop-up dismissed, closing client.");
      return 0xFFFFFFFFFFFFFFFFuLL;
    }
    return 0;
  }
  v10 = *(_QWORD *)v3;
  p_p_Src = &p_Src;
  v43 = 0;
  n6 = (*(__int64 (__fastcall **)(__int64))(v10 + 0x78))(v3);
  n6_1 = n6;
  if ( n6 > 6 )
  {
    *(_BYTE *)(a1 + 0xB68) = 1;
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x60LL))(v3);
    v14 = *(_QWORD *)v3;
    v43 = v13 + 0x4A38;
    p_p_Src = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64, _QWORD))(v14 + 0x80))(v3, n6_1);
    v15 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, const char **))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
                      qword_149C8DF80,
                      &p_@ui_error_type_services_connection);
    LogTraceConditional("CIG account login failed : code [%d] Time[%lli]", n6_1, *v15);
  }
  n3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x68LL))(v3);
  n3_1 = n3;
  n2 = n3;
  if ( n3 >= 3 )
  {
    *(_BYTE *)(a1 + 0xB68) = 1;
    v18 = *(_QWORD *)v3;
    v43 = n3 + 0x2710;
    p_p_Src = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64, _QWORD))(v18 + 0x70))(v3, (unsigned int)n3);
    if ( (n2 == 2 || n2 == 5 || n2 == 6 || (unsigned int)(n2 - 7) <= 1) && byte_149C8E515 )
      *(_QWORD *)(a1 + 0xB60) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, const char **))(*(_QWORD *)qword_149C8DF80
                                                                                             + 0x48LL))(
                                             qword_149C8DF80,
                                             &p_@ui_error_type_services_connection);
    v19 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, const char **))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
                      qword_149C8DF80,
                      &p_@ui_error_type_services_connection);
    LogTraceConditional("CIG online service connection failed : code [%d]  Time[%lli]", n2, *v19);
  }
  if ( !*(_BYTE *)(a1 + 0xB68) && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x38LL))(v3) )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3) )
    {
      *(_BYTE *)(a1 + 0xEB3) = 1;
      v20 = (const void **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x50LL))(v3);
      sub_144F1B8B0(v5, v20);
    }
    return 0;
  }
  if ( *(_BYTE *)(a1 + 0xEB3) && !*(_BYTE *)(a1 + 0xB68) )
  {
    sub_144F0D5E0(v5);
    *(_BYTE *)(a1 + 0xEB3) = 0;
  }
  if ( n6_1 == 1 )
    return 0;
  if ( *(_BYTE *)(a1 + 0xB68) )
  {
    v55[0] = 0;
    Size_1 = 0;
    Src = v55;
    Size = 0;
    n0x7F = 0x7F;
    n0x7F_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n0x7F_1;
    while ( aUiServicesErro_0[n0x7F_1] );
    if ( n0x7F_1 )
    {
      Src_1 = v55;
      if ( n0x7F_1 + 1 > 0x80 )
      {
        Src_1 = (_BYTE *)allocWithProfilerInfo(n0x7F_1 + 1, 0);
        qword_149C80C40 += n0x7F_1 + 1;
        n0x7F = n0x7F_1;
      }
      Src = Src_1;
      Size = n0x7F_1;
      Src_1[n0x7F_1] = 0;
      memcpy(Src, "@ui_services_error_", n0x7F_1);
      Src_2 = Src;
      Size_1 = Size;
    }
    else
    {
      Src_2 = v55;
    }
    v25 = (size_t *)(a1 + 0xB70);
    if ( Size_1 > *(_QWORD *)(a1 + 0xB78) )
    {
      sub_140502730((_QWORD *)(a1 + 0xB70));
      sub_140418940((__int64 *)(a1 + 0xB70), Size_1);
    }
    memmove(*(void **)(a1 + 0xB80), Src_2, Size_1);
    v26 = *(_QWORD *)(a1 + 0xB80);
    *v25 = Size_1;
    *(_BYTE *)(Size_1 + v26) = 0;
    if ( Src != v55 )
    {
      qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - n0x7F;
      sub_147715880(Src);
    }
    if ( p_p_Src )
    {
      Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++Size_2;
      while ( *((_BYTE *)p_p_Src + Size_2) );
      if ( Size_2 )
      {
        Size_4 = *v25;
        v29 = *(char **)(a1 + 0xB80);
        Size_3 = Size_4;
        p_@Frontend_Login_Concat = (const char *)(Size_4 + Size_2);
        if ( Size_4 + Size_2 <= *(_QWORD *)(a1 + 0xB78) )
        {
          memcpy(&v29[Size_4], p_p_Src, Size_2);
          *v25 += Size_2;
          *(_BYTE *)(*v25 + *(_QWORD *)(a1 + 0xB80)) = 0;
        }
        else
        {
          n8 = 2 * Size_4;
          if ( 2 * Size_4 <= Size_4 + Size_2 )
            n8 = Size_4 + Size_2;
          if ( n8 )
          {
            if ( n8 < 8 )
              n8 = 8;
            sub_140418940((__int64 *)(a1 + 0xB70), n8);
            memcpy(*(void **)(a1 + 0xB80), v29, Size_3);
            memcpy((void *)(*(_QWORD *)(a1 + 0xB80) + Size_3), p_p_Src, Size_2);
            v31 = *(_QWORD *)(a1 + 0xB80) + Size_3;
            *v25 = (size_t)p_@Frontend_Login_Concat;
            *(_BYTE *)(v31 + Size_2) = 0;
          }
          if ( v29 != (char *)(a1 + 0xB88) )
          {
            qword_149C80C40 += 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 0xB78);
            sub_147715880(v29);
          }
        }
      }
    }
    p_@LOC_BADTOKEN_1 = *(const char **)(a1 + 0xB80);
    p_@ui_error_type_services_connection = "@ui_error_type_services_connection";
    if ( p_@LOC_BADTOKEN_1 )
    {
      p_@LOC_BADSTRING = "@LOC_BADTOKEN";
      if ( *p_@LOC_BADTOKEN_1 == 0x40 )
        p_@LOC_BADSTRING = p_@LOC_BADTOKEN_1;
    }
    else
    {
      p_@LOC_BADSTRING = "@LOC_BADSTRING";
    }
    p_@Frontend_Login_Concat = p_@LOC_BADSTRING;
    sub_140361D70(&v45, (unsigned __int8 **)&p_@Frontend_Login_Concat);
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x38LL))(v3) )
    {
      p_@Frontend_Login_Concat = "@Frontend_Login_Concat";
      sub_140361D70(&Size_3, (unsigned __int8 **)&p_@Frontend_Login_Concat);
      v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x50LL))(v3);
      v35 = sub_1402A4EC0(v34);
      v36 = sub_1402A4EC0((__int64)&v45);
      v37 = sub_1403A27F0(&p_@Frontend_Login_Concat, (const wchar_t **)&Size_3, v36, v35);
      sub_14037AF60((__int64 *)&v45, v37);
      sub_140373CC0(&p_@Frontend_Login_Concat);
      sub_140373CC0(&Size_3);
    }
    v51 = 0;
    p_sub_1465DD010 = sub_1465DD010;
    n2_1 = 1;
    v38 = (const void **)sub_140361D70(
                           &p_@Frontend_Login_Concat,
                           (unsigned __int8 **)&p_@ui_error_type_services_connection);
    v39 = v43;
    sub_144F1AE70(v48, v43, v38, &v45, &p_sub_1465DD010);
    sub_140373CC0(&p_@Frontend_Login_Concat);
    if ( n2_1 >= 2 )
      ((void (__fastcall *)(__int64, void (**)()))n2_1)(2, &p_sub_1465DD010);
    v40 = sub_1449F4B50();
    sub_144A12990(v40, (__int64)"login", v39, n3_1, n6, (__int64)"<no additional info>", 0.0, (__int64)"NotSet");
    sub_140373CC0(&v45);
    return 0;
  }
  return 1;
}

// --- End Function: sub_1465E4B20 (0x1465E4B20) ---

// --- Function: sub_1465E54F0 (0x1465E54F0) ---
void sub_1465E54F0()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rax
  __int64 v42; // rax
  __int64 v43; // rax
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // rax

  if ( Parameter_0 )
  {
    (*(void (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_0 + 0x20LL))(Parameter_0);
    v0 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000000B);
    if ( v0 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v0 + 8LL))(v0);
    v1 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000001C);
    if ( v1 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 8LL))(v1);
    v2 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000015);
    if ( v2 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 8LL))(v2);
    v3 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000016);
    if ( v3 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8LL))(v3);
    v4 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000010);
    if ( v4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
    v5 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000000D);
    if ( v5 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
    v6 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000017);
    if ( v6 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
    v7 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x8000000DLL);
    if ( v7 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
    v8 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x50000000);
    if ( v8 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x10LL))(v8);
    v9 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000000F);
    if ( v9 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v9 + 8LL))(v9);
    v10 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000000);
    if ( v10 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
    v11 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000011);
    if ( v11 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
    v12 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000004);
    if ( v12 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 8LL))(v12);
    v13 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x7000001);
    if ( v13 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 8LL))(v13);
    v14 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x11000001);
    if ( v14 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 8LL))(v14);
    v15 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x11000004);
    if ( v15 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 8LL))(v15);
    v16 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x60000000);
    if ( v16 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x10LL))(v16);
    v17 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x60000001);
    if ( v17 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x10LL))(v17);
    v18 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x11000002);
    if ( v18 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 8LL))(v18);
    v19 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x11000003);
    if ( v19 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 8LL))(v19);
    v20 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x11000005);
    if ( v20 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v20 + 8LL))(v20);
    v21 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x70000000);
    if ( v21 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v21 + 8LL))(v21);
    v22 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0xF000002);
    if ( v22 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 8LL))(v22);
    v23 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_0 + 0x88LL))(Parameter_0);
    if ( v23 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x18LL))(v23);
    v24 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000007);
    if ( v24 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 8LL))(v24);
    v25 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000008);
    if ( v25 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x10LL))(v25);
    v26 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000000E);
    if ( v26 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x10LL))(v26);
    v27 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000018);
    if ( v27 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x10LL))(v27);
    v28 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000009);
    if ( v28 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v28 + 8LL))(v28);
    v29 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000014);
    if ( v29 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v29 + 8LL))(v29);
    v30 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x8000000BLL);
    if ( v30 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v30 + 8LL))(v30);
    v31 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x8000000CLL);
    if ( v31 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x10LL))(v31);
    v32 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x11000006);
    if ( v32 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v32 + 8LL))(v32);
    v33 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000012);
    if ( v33 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v33 + 8LL))(v33);
    v34 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x20000001);
    if ( v34 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x38LL))(v34);
    v35 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x20000002);
    if ( v35 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 0x28LL))(v35);
    v36 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x20000003);
    if ( v36 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x28LL))(v36);
    v37 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x15000001);
    if ( v37 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v37 + 8LL))(v37);
    v38 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x15000002);
    if ( v38 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v38 + 8LL))(v38);
    v39 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x15000000);
    if ( v39 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v39 + 8LL))(v39);
    v40 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x21000000);
    if ( v40 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
    v41 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000013);
    if ( v41 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v41 + 8LL))(v41);
    v42 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x12900000);
    if ( v42 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v42 + 8LL))(v42);
    v43 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x55000000);
    if ( v43 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v43 + 8LL))(v43);
    v44 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x10000019);
    if ( v44 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v44 + 8LL))(v44);
    v45 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000001A);
    if ( v45 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v45 + 8LL))(v45);
    v46 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(Parameter_0, 0x1000001B);
    if ( v46 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v46 + 8LL))(v46);
    sub_144DD3BA0();
    sub_143E41760();
    sub_14356A3E0();
    sub_144C4B170();
    sub_143706FB0();
    sub_144C4B3F0();
  }
}

// --- End Function: sub_1465E54F0 (0x1465E54F0) ---

// --- Function: sub_1465E62A0 (0x1465E62A0) ---
_QWORD *__fastcall sub_1465E62A0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rbx
  __int64 v4; // rax
  __int16 n4; // dx
  __int64 v6; // rbx
  __int64 v7; // rax
  __int16 n4_1; // dx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 0xC08);
  v10 = v2;
  if ( v2
    && (v4 = sub_1403B84E0(v2 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v4 + 4), n4 != 4)
    && *(_WORD *)(v4 + 2) == (HIWORD(v2) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v10))
    && (v6 = *sub_1465492B0(v2 & 0xFFFFFFFFFFFFLL, &v10), (v10 = v6) != 0)
    && (v7 = sub_1403B84E0(v6 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v7 + 4), n4_1 != 4)
    && *(_WORD *)(v7 + 2) == (HIWORD(v6) & 0xFFF)
    && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140395350(&v10)) )
  {
    *a2 = *(_QWORD *)((v6 & 0xFFFFFFFFFFFFLL) + 8);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1465E62A0 (0x1465E62A0) ---

// --- Function: sub_1465E63C0 (0x1465E63C0) ---
_QWORD *__fastcall sub_1465E63C0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v5; // [rsp+40h] [rbp+18h] BYREF

  sub_1465E62A0(a1, &v5);
  if ( is_entity_descriptor_valid_or_accessible(&v5) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 8LL))(
      v5 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = *(_QWORD *)(a1 + 0xC10);
  return a2;
}

// --- End Function: sub_1465E63C0 (0x1465E63C0) ---

// --- Function: sub_1465E6470 (0x1465E6470) ---
_QWORD *__fastcall sub_1465E6470(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0xC10);
  return a2;
}

// --- End Function: sub_1465E6470 (0x1465E6470) ---

// --- Function: sub_1465E67B0 (0x1465E67B0) ---
__int64 __fastcall sub_1465E67B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xC58);
}

// --- End Function: sub_1465E67B0 (0x1465E67B0) ---

// --- Function: sub_1465E7430 (0x1465E7430) ---
__int64 __fastcall sub_1465E7430(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xC60);
}

// --- End Function: sub_1465E7430 (0x1465E7430) ---

// --- Function: sub_1465E7760 (0x1465E7760) ---
void __fastcall sub_1465E7760(_BYTE *a1)
{
  __int64 v2; // r14
  int v3; // ebx
  int *ThreadLogContextSlot_5; // rax
  __int64 v5; // rax
  __int64 v6; // rbx
  int v7; // ebx
  int *ThreadLogContextSlot_4; // rax
  int v9; // edi
  int v10; // ebx
  int *ThreadLogContextSlot_3; // rax
  __int64 *v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rbx
  unsigned __int8 **v15; // rax
  const void **v16; // rbx
  const void **v17; // rax
  int v18; // ebx
  int *ThreadLogContextSlot; // rax
  __int64 *v20; // rax
  _QWORD *v21; // rax
  __int64 v22; // rbx
  unsigned __int8 **v23; // rax
  const void **v24; // rbx
  const void **v25; // rax
  int v26; // ebx
  int *ThreadLogContextSlot_1; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  int v30; // ebx
  int *ThreadLogContextSlot_2; // rax
  __int64 *StringObjectFromString; // rax
  _QWORD *v33; // rax
  __int64 v34; // rbx
  unsigned __int8 **v35; // rax
  const void **v36; // rbx
  const void **v37; // rax
  int v38; // [rsp+20h] [rbp-E0h]
  const char *v39; // [rsp+28h] [rbp-D8h]
  __int64 v40; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v41[2]; // [rsp+68h] [rbp-98h] BYREF
  unsigned int *p_sub_1465DCF30; // [rsp+70h] [rbp-90h]
  __int128 v43; // [rsp+78h] [rbp-88h] BYREF
  __int64 v44; // [rsp+88h] [rbp-78h]
  __int64 v45; // [rsp+90h] [rbp-70h] BYREF
  char v46; // [rsp+98h] [rbp-68h] BYREF
  __int64 p_@ui_disconnect_cause_anticheat; // [rsp+A0h] [rbp-60h] BYREF
  void *v48; // [rsp+A8h] [rbp-58h] BYREF
  const char *p_@ui_disconnect_cause_anticheat_1; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v50[2]; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v51; // [rsp+C8h] [rbp-38h] BYREF
  __int64 v52; // [rsp+D0h] [rbp-30h] BYREF
  int v53; // [rsp+D8h] [rbp-28h] BYREF
  unsigned __int16 p_sub_1465DCF30_1; // [rsp+DCh] [rbp-24h]
  _WORD v55[5]; // [rsp+DEh] [rbp-22h] BYREF
  void *v56[2]; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v57; // [rsp+F8h] [rbp-8h] BYREF
  _QWORD v58[2]; // [rsp+100h] [rbp+0h] BYREF
  _QWORD v59[5]; // [rsp+110h] [rbp+10h] BYREF
  __int64 v60; // [rsp+138h] [rbp+38h] BYREF
  __int64 v61; // [rsp+140h] [rbp+40h] BYREF
  __int64 v62; // [rsp+148h] [rbp+48h] BYREF
  _QWORD v63[5]; // [rsp+150h] [rbp+50h] BYREF
  __int64 v64[4]; // [rsp+178h] [rbp+78h] BYREF
  char v65; // [rsp+198h] [rbp+98h]
  __int64 v66; // [rsp+250h] [rbp+150h] BYREF
  _QWORD v67[5]; // [rsp+260h] [rbp+160h] BYREF
  __int64 v68; // [rsp+288h] [rbp+188h] BYREF
  __int64 v69; // [rsp+290h] [rbp+190h] BYREF
  __int64 v70; // [rsp+298h] [rbp+198h] BYREF
  _QWORD v71[5]; // [rsp+2A0h] [rbp+1A0h] BYREF
  __int64 v72; // [rsp+2C8h] [rbp+1C8h]
  char v73; // [rsp+2E8h] [rbp+1E8h]
  __int64 v74; // [rsp+3A0h] [rbp+2A0h] BYREF
  char v75[1024]; // [rsp+3B0h] [rbp+2B0h] BYREF

  v2 = sub_144F13530();
  if ( v2 )
  {
    v5 = (**(__int64 (__fastcall ***)(__int64))qword_149C8E0A8)(qword_149C8E0A8);
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x40LL))(v5);
    if ( v6 )
    {
      if ( !a1[0xEB2] )
      {
        (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E070 + 0x28LL))(qword_149C8E070, v59);
        v9 = *(_DWORD *)((*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E070 + 0x28LL))(
                           qword_149C8E070,
                           v67)
                       + 0x20);
        if ( v73 != 1 )
          sub_140373CC0(&v74);
        if ( v72 )
          sub_1402A6590(v72);
        sub_140373CC0(v71);
        sub_140373CC0(&v70);
        sub_140373CC0(&v69);
        sub_140373CC0(&v68);
        sub_140373CC0(v67);
        if ( v9 && !(*(unsigned __int8 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v6 + 0x70LL))(v6, v64) )
        {
          (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v6 + 0x18LL))(v6, &v53);
          switch ( v53 )
          {
            case 2:
              a1[0xB54] = 1;
              break;
            case 3:
              if ( !a1[0xEB1] )
              {
                v40 = 0x6000000DALL;
                *(_QWORD *)v41 = &v40;
                p_sub_1465DCF30 = v41;
                v26 = invokeGlobalCallbackAndMaskStatusBits(
                        3,
                        (__int64)v41,
                        (__int64)"HandleEACResult Failed",
                        "Anticheat failed with error: $$ ($$)");
                if ( (v26 & 0xFFFFF) != 0 )
                {
                  p_sub_1465DCF30 = (unsigned int *)p_sub_1465DCF30_1;
                  *((_QWORD *)&v43 + 1) = *(_QWORD *)&v55[1];
                  *(_QWORD *)v41 = 0;
                  *(_QWORD *)&v43 = 0;
                  v44 = 0;
                  ThreadLogContextSlot_1 = getThreadLogContextSlot();
                  v40 = 0x6000000DALL;
                  v56[0] = &v40;
                  v56[1] = v41;
                  *(_OWORD *)v50 = 0;
                  sub_1465DD8E0(
                    3,
                    (__int64)v56,
                    "HandleEACResult Failed",
                    (__int64)"Anticheat failed with error: $$ ($$)",
                    1,
                    v26,
                    v50,
                    0,
                    (__int64)ThreadLogContextSlot_1,
                    &v43,
                    v41);
                  sub_1402A6590(v44);
                }
                a1[0xEB1] = 1;
              }
              v28 = qword_149FBE918;
              if ( !qword_149FBE918 )
              {
                v29 = *(_QWORD *)qword_149C8E0F8;
                *(_QWORD *)v41 = &v46;
                p_sub_1465DCF30 = (unsigned int *)sub_1465DCF30;
                v28 = (*(__int64 (__fastcall **)(__int64, __int64 *, const char *, unsigned int *))(v29 + 0x48))(
                        qword_149C8E0F8,
                        &qword_149FBE918,
                        "SEACInitialisationConfig",
                        v41);
                *(_QWORD *)v41 = 0xFFFFFFFFFFFFFFFFuLL;
              }
              if ( *(_DWORD *)(v28 + 0x48) )
              {
                v40 = 0x6000000DALL;
                v58[0] = &v40;
                v58[1] = v41;
                v30 = invokeGlobalCallbackAndMaskStatusBits(
                        3,
                        (__int64)v58,
                        (__int64)"HandleEACResult Blocking Error",
                        "Closing client");
                if ( (v30 & 0xFFFFF) != 0 )
                {
                  ThreadLogContextSlot_2 = getThreadLogContextSlot();
                  v50[0] = (__int64)&v45;
                  v50[1] = (__int64)&v46;
                  v45 = 0x6000000DALL;
                  v43 = 0;
                  sub_140354250(
                    3,
                    (__int64)v50,
                    "HandleEACResult Blocking Error",
                    (__int64)"Closing client",
                    1,
                    v30,
                    &v43,
                    0,
                    (__int64)ThreadLogContextSlot_2);
                }
                StringObjectFromString = (__int64 *)CreateStringObjectFromString(v56, v75);
                sub_14035DDF0(&p_@ui_disconnect_cause_anticheat_1, StringObjectFromString);
                sub_14035DDF0(&v48, (__int64 *)&p_@ui_disconnect_cause_anticheat_1);
                v33 = (_QWORD *)sub_1402A65A0(8u);
                v34 = (__int64)v33;
                if ( v33 )
                {
                  sub_14035DDF0(v33, (__int64 *)&v48);
                  v44 = v34;
                }
                else
                {
                  v44 = 0;
                }
                *(_QWORD *)&v43 = sub_1465E4000;
                *((_QWORD *)&v43 + 1) = sub_1465E41D0;
                sub_140373CC0(&v48);
                sub_140373CC0(&p_@ui_disconnect_cause_anticheat_1);
                v35 = (unsigned __int8 **)sub_140421990(&v57, 0x7551);
                v36 = (const void **)sub_140361C90(&v51, v35);
                p_@ui_disconnect_cause_anticheat = (__int64)"@ui_disconnect_cause_anticheat";
                v37 = (const void **)sub_140361D70(&v52, (unsigned __int8 **)&p_@ui_disconnect_cause_anticheat);
                sub_144F1AE70(v2, 0x7551u, v37, v36, &v43);
                sub_140373CC0(&v52);
                sub_140373CC0(&v51);
                sub_140373CC0(&v57);
                if ( *((_QWORD *)&v43 + 1) >= 2u )
                {
                  (*((void (__fastcall **)(__int64, __int128 *))&v43 + 1))(2, &v43);
                  *((_QWORD *)&v43 + 1) = 0;
                }
                *(_QWORD *)&v43 = 0;
                sub_140373CC0(v56);
                a1[0xEB2] = 1;
              }
              break;
            case 4:
              v40 = 0x6000000DALL;
              *(_QWORD *)v41 = &v40;
              p_sub_1465DCF30 = v41;
              v18 = invokeGlobalCallbackAndMaskStatusBits(
                      3,
                      (__int64)v41,
                      (__int64)"HandleEACResult Violation Detected",
                      "Anticheat detected a file violation: %u - %s",
                      v38,
                      v39);
              if ( (v18 & 0xFFFFF) != 0 )
              {
                p_@ui_disconnect_cause_anticheat = *(_QWORD *)&v55[1];
                ThreadLogContextSlot = getThreadLogContextSlot();
                v40 = 0x6000000DALL;
                *(_QWORD *)v41 = &v40;
                p_sub_1465DCF30 = v41;
                *(_OWORD *)v50 = 0;
                sub_1465DD690(
                  3,
                  (__int64)v41,
                  (void *)"HandleEACResult Violation Detected",
                  (__int64)"Anticheat detected a file violation: %u - %s",
                  1,
                  v18,
                  v50,
                  0,
                  (__int64)ThreadLogContextSlot,
                  (__int64)v55,
                  (const char **)&p_@ui_disconnect_cause_anticheat);
              }
              v20 = (__int64 *)CreateStringObjectFromString(&v48, v75);
              sub_14035DDF0(&v40, v20);
              sub_14035DDF0(&v45, &v40);
              v21 = (_QWORD *)sub_1402A65A0(8u);
              v22 = (__int64)v21;
              if ( v21 )
              {
                sub_14035DDF0(v21, &v45);
                v44 = v22;
              }
              else
              {
                v44 = 0;
              }
              *(_QWORD *)&v43 = sub_1465E3F80;
              *((_QWORD *)&v43 + 1) = sub_1465E4080;
              sub_140373CC0(&v45);
              sub_140373CC0(&v40);
              v23 = (unsigned __int8 **)sub_140421990(&p_@ui_disconnect_cause_anticheat_1, 0x7552);
              v24 = (const void **)sub_140361C90(&v51, v23);
              p_@ui_disconnect_cause_anticheat = (__int64)"@ui_disconnect_cause_anticheat";
              v25 = (const void **)sub_140361D70(&v52, (unsigned __int8 **)&p_@ui_disconnect_cause_anticheat);
              sub_144F1AE70(v2, 0x7551u, v25, v24, &v43);
              sub_140373CC0(&v52);
              sub_140373CC0(&v51);
              sub_140373CC0(&p_@ui_disconnect_cause_anticheat_1);
              if ( *((_QWORD *)&v43 + 1) >= 2u )
              {
                (*((void (__fastcall **)(__int64, __int128 *))&v43 + 1))(2, &v43);
                *((_QWORD *)&v43 + 1) = 0;
              }
              *(_QWORD *)&v43 = 0;
              sub_140373CC0(&v48);
              a1[0xEB2] = 1;
              break;
            case 6:
              v40 = 0x6000000DALL;
              *(_QWORD *)v41 = &v40;
              p_sub_1465DCF30 = v41;
              v10 = invokeGlobalCallbackAndMaskStatusBits(
                      3,
                      (__int64)v41,
                      (__int64)"HandleEACResult No Launcher",
                      "Anticheat detected that the game was started without the launcher");
              if ( (v10 & 0xFFFFF) != 0 )
              {
                ThreadLogContextSlot_3 = getThreadLogContextSlot();
                *(_QWORD *)v41 = &v40;
                p_sub_1465DCF30 = v41;
                v40 = 0x6000000DALL;
                *(_OWORD *)v50 = 0;
                sub_140354250(
                  3,
                  (__int64)v41,
                  "HandleEACResult No Launcher",
                  (__int64)"Anticheat detected that the game was started without the launcher",
                  1,
                  v10,
                  v50,
                  0,
                  (__int64)ThreadLogContextSlot_3);
              }
              v12 = (__int64 *)CreateStringObjectFromString((void **)&p_@ui_disconnect_cause_anticheat, v75);
              sub_14035DDF0(&v40, v12);
              sub_14035DDF0(&v45, &v40);
              v13 = (_QWORD *)sub_1402A65A0(8u);
              v14 = (__int64)v13;
              if ( v13 )
              {
                sub_14035DDF0(v13, &v45);
                v44 = v14;
              }
              else
              {
                v44 = 0;
              }
              *(_QWORD *)&v43 = sub_1465E4000;
              *((_QWORD *)&v43 + 1) = sub_1465E41D0;
              sub_140373CC0(&v45);
              sub_140373CC0(&v40);
              v15 = (unsigned __int8 **)sub_140421990(&v52, 0x7551);
              v16 = (const void **)sub_140361C90(&v51, v15);
              p_@ui_disconnect_cause_anticheat_1 = "@ui_disconnect_cause_anticheat";
              v17 = (const void **)sub_140361D70(&v48, (unsigned __int8 **)&p_@ui_disconnect_cause_anticheat_1);
              sub_144F1AE70(v2, 0x7551u, v17, v16, &v43);
              sub_140373CC0(&v48);
              sub_140373CC0(&v51);
              sub_140373CC0(&v52);
              if ( *((_QWORD *)&v43 + 1) >= 2u )
              {
                (*((void (__fastcall **)(__int64, __int128 *))&v43 + 1))(2, &v43);
                *((_QWORD *)&v43 + 1) = 0;
              }
              *(_QWORD *)&v43 = 0;
              sub_140373CC0(&p_@ui_disconnect_cause_anticheat);
              a1[0xEB2] = 1;
              break;
          }
          sub_140373CC0(&v55[1]);
        }
        if ( v65 != 1 )
          sub_140373CC0(&v66);
        if ( v64[0] )
          sub_1402A6590(v64[0]);
        sub_140373CC0(v63);
        sub_140373CC0(&v62);
        sub_140373CC0(&v61);
        sub_140373CC0(&v60);
        sub_140373CC0(v59);
      }
    }
    else
    {
      v40 = 0x6000000DALL;
      *(_QWORD *)v41 = &v40;
      p_sub_1465DCF30 = v41;
      v7 = invokeGlobalCallbackAndMaskStatusBits(
             3,
             (__int64)v41,
             (__int64)"HandleEACResult DisciplineServiceExternal",
             "Discipline service not available");
      if ( (v7 & 0xFFFFF) != 0 )
      {
        ThreadLogContextSlot_4 = getThreadLogContextSlot();
        *(_QWORD *)v41 = &v40;
        p_sub_1465DCF30 = v41;
        v40 = 0x6000000DALL;
        *(_OWORD *)v50 = 0;
        sub_140354250(
          3,
          (__int64)v41,
          "HandleEACResult DisciplineServiceExternal",
          (__int64)"Discipline service not available",
          1,
          v7,
          v50,
          0,
          (__int64)ThreadLogContextSlot_4);
      }
    }
  }
  else
  {
    v40 = 0x6000000DALL;
    *(_QWORD *)v41 = &v40;
    p_sub_1465DCF30 = v41;
    v3 = invokeGlobalCallbackAndMaskStatusBits(
           3,
           (__int64)v41,
           (__int64)"HandleEACResult GlobalGameUI",
           "GlobalGameUI not available");
    if ( (v3 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot_5 = getThreadLogContextSlot();
      *(_QWORD *)v41 = &v40;
      p_sub_1465DCF30 = v41;
      v40 = 0x6000000DALL;
      *(_OWORD *)v50 = 0;
      sub_140354250(
        3,
        (__int64)v41,
        "HandleEACResult GlobalGameUI",
        (__int64)"GlobalGameUI not available",
        1,
        v3,
        v50,
        0,
        (__int64)ThreadLogContextSlot_5);
    }
  }
}

// --- End Function: sub_1465E7760 (0x1465E7760) ---

// --- Function: sub_1465F0750 (0x1465F09C7) ---
__int64 __fastcall sub_1465F0750(__int64 a1, __int64 a2, unsigned int a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int64 v7; // rdx
  __int64 v8; // rdx
  int n2; // esi
  double _XMM0; // kr00_8
  unsigned __int8 *v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v26; // rax
  __int64 v27; // rax
  _QWORD *v28; // rcx
  __int64 *v29; // rcx
  _QWORD *v30; // rcx
  __int64 v31; // rcx
  __int64 v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // r14
  void (__fastcall *v41)(__int64, _QWORD); // rbx
  unsigned __int8 v42; // al
  __int64 v43; // rax
  __int64 v44; // rax
  __int64 v45; // rdx
  __int64 v46; // rcx
  __int64 v47; // r14
  void (__fastcall *v48)(__int64, _QWORD); // rbx
  unsigned __int8 v49; // al
  __int64 v50; // rcx
  __int64 v51; // rcx
  __int64 v52; // rcx
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rbx
  unsigned __int8 v56; // r14
  __int64 v57; // rax
  __int64 v58; // rax
  int v59; // ebx
  __int64 v60; // rax
  __int64 v61; // rdi
  void (__fastcall *v62)(__int64, __int64, _QWORD); // rbx
  __int64 v63; // rax
  unsigned __int8 *v65; // rax
  __int64 v66; // rbx
  __int64 v69; // rcx
  __int64 v70; // rax
  __int64 v71; // rax
  __int64 v72; // r8
  __int64 n2_1; // rdx
  __int64 v74; // rbx
  __int64 v75; // rax
  unsigned int v76; // eax
  __int64 v77; // rdx
  __m128 v78; // xmm0
  __int128 v80; // kr00_16
  _BYTE v82[12]; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v83; // [rsp+44h] [rbp-C4h] BYREF
  __int64 v84; // [rsp+4Ch] [rbp-BCh]
  int v85; // [rsp+54h] [rbp-B4h]
  unsigned __int64 v86; // [rsp+58h] [rbp-B0h]
  unsigned __int64 v87; // [rsp+60h] [rbp-A8h]
  __int64 v88; // [rsp+68h] [rbp-A0h]
  __int64 v89; // [rsp+70h] [rbp-98h]
  int n5; // [rsp+98h] [rbp-70h] BYREF
  __int64 v91; // [rsp+A0h] [rbp-68h] BYREF
  _BYTE v92[8]; // [rsp+A8h] [rbp-60h] BYREF
  _BYTE v93[8]; // [rsp+B0h] [rbp-58h] BYREF
  _BYTE v94[176]; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v95; // [rsp+168h] [rbp+60h] BYREF
  __int128 v96; // [rsp+188h] [rbp+80h]
  __int128 v97; // [rsp+198h] [rbp+90h]

  v97 = v3;
  v96 = v4;
  ++dword_149C8E13C;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E080 + 0x10LL))(qword_149C8E080);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E080 + 0x120LL))(qword_149C8E080, 0);
  LOBYTE(v7) = 1;
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E080 + 0x120LL))(qword_149C8E080, v7);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF80 + 0x10LL))(qword_149C8DF80);
  LOBYTE(v8) = 0xF;
  (*(void (__fastcall **)(_LocaleUpdate *, __int64))(*(_QWORD *)qword_149C8E018 + 0x490LL))(qword_149C8E018, v8);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x680LL))(qword_149C8DFE0);
  HIDWORD(v83) = 0x1600;
  v85 = 0;
  v87 = 0;
  v88 = 0;
  v89 = 0;
  v84 = 1;
  v86 = __rdtsc();
  n2 = 1;
  qword_149C89AA0(
    (char *)&v83 + 4,
    &word_149FBE8C0,
    "SimulateFrame",
    "W:/p4-src/CryEngine/Code/GameSDK/GameDll/Game.cpp",
    0x6D7);
  HIWORD(v83) = word_149FBE8C0;
  if ( (dword_149FBE8C8 & 1) == 0 )
  {
    dword_149FBE8C8 |= 1u;
    (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, v82);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    dword_149FBE8C4 = _XMM1;
  }
  (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, v82);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  HIDWORD(_XMM0) = DWORD1(_XMM1);
  *(float *)&_XMM0 = *(float *)&_XMM1 - *(float *)&dword_149FBE8C4;
  v15 = sub_142F566B0(_XMM0, 1, 1, 0);
  snprintf_s(DstBuf_, 0x80u, 0xFFFFFFFFFFFFFFFFuLL, "<%s>%s</>\n", "up", (const char *)v15);
  byte_149C8E1BF = 0;
  v16 = *(_QWORD *)(qword_149FBE618 + 0xC48);
  if ( v16 )
  {
    v17 = sub_1404B90A0(v16);
    if ( v17 )
    {
      sub_144F1D030(v17);
      v18 = *(_QWORD *)(a1 + 0xC98);
      if ( v18 )
        sub_142AD6F20(v18);
    }
  }
  (*(void (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, v82, 0);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
  if ( Parameter_0 )
    (*(void (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_0 + 0x18LL))(Parameter_0);
  v21 = sub_1466F95E0();
  sub_142D04080(v21);
  sub_142BDC810(*(_QWORD *)(a1 + 0xCB0));
  v22 = *(_QWORD *)(a1 + 0xCC0);
  if ( v22 )
    sub_14447B650(v22);
  v23 = *(_QWORD *)(a1 + 0xCB8);
  if ( v23 )
    sub_143F552C0(v23);
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x38LL))(*(_QWORD *)(a1 + 0xE8), 1, a3);
  if ( qword_149C8E0E0 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E0E0 + 0x18LL))(qword_149C8E0E0);
  sub_14306AB20(*(_QWORD *)(a1 + 0xC40), *(double *)&_XMM6);
  (*(void (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, v82, 1);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm7, xmm0, xmm0 }
  sub_1465F1240(a1);
  if ( !(*(unsigned __int8 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x58LL))(*(_QWORD *)(a1 + 0xE8)) )
  {
    v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x658LL))(qword_149C8DFE0);
    if ( v26 )
    {
      v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x50LL))(v26);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x30LL))(v27);
    }
    sub_14586B8A0(*(_QWORD *)(a1 + 0x100));
    if ( qword_149C8E0D0 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E0D0 + 0xB8LL))(qword_149C8E0D0);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xC90) + 0x20LL))(*(_QWORD *)(a1 + 0xC90));
    sub_1434ED130(*(_QWORD *)(a1 + 0x160));
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x240LL))(*(_QWORD *)(a1 + 0xE8)) )
      sub_143AFAB60(*(_QWORD **)(a1 + 0xC58));
    if ( byte_149C8E1C0 )
    {
      v28 = *(_QWORD **)(a1 + 0xD30);
      if ( v28 )
        sub_1431E2B90(v28);
    }
    v29 = *(__int64 **)(a1 + 0xD70);
    if ( v29 )
      sub_1434411E0(v29);
    v30 = *(_QWORD **)(a1 + 0xD68);
    if ( v30 )
      sub_1431E2F10(v30);
    v31 = *(_QWORD *)(a1 + 0xD00);
    if ( v31 )
      sub_1431E31B0(v31, *(float *)&_XMM6);
    v32 = *(_QWORD *)(a1 + 0xDC0);
    if ( v32 )
      sub_1431E2EE0(v32);
    v33 = *(_QWORD *)(a1 + 0xDC8);
    if ( v33 )
      sub_143E3CCC0(v33);
    v34 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(qword_149C8DFB8 + 0xE8) + 0x180LL))(*(_QWORD *)(qword_149C8DFB8 + 0xE8));
    v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x28LL))(v34);
    if ( v35 )
    {
      v36 = sub_146581420(v35);
      if ( v36 )
      {
        v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x578LL))(v36);
        if ( v37 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v37 + 8LL))(v37);
      }
    }
    v38 = *(_QWORD *)(a1 + 0xDE0);
    if ( v38 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v38 + 8LL))(v38);
    v39 = *(_QWORD *)(a1 + 0xDD8);
    if ( v39 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v39 + 8LL))(v39);
  }
  v40 = qword_149C8E0D8;
  if ( qword_149C8E0D8 )
  {
    v41 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E0D8 + 0x20LL);
    v42 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x58LL))(*(_QWORD *)(a1 + 0xE8));
    v41(v40, v42);
  }
  if ( qword_149C8E0C0 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E0C0 + 8LL))(qword_149C8E0C0);
  sub_1465E54F0();
  v43 = qword_149F5AFD0;
  if ( !qword_149F5AFD0 )
  {
    v44 = sub_1402A65A0(0x60u);
    if ( v44 )
      v43 = sub_1430E8350(v44);
    else
      v43 = 0;
    qword_149F5AFD0 = v43;
  }
  sub_1431E2A30(v43);
  sub_1465F1190(a1);
  sub_142F7FF80(*(_QWORD *)(a1 + 0xC88));
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x40LL))(*(_QWORD *)(a1 + 0xE8), 1, a3);
  v46 = *(_QWORD *)(a1 + 0xD88);
  if ( v46 )
    sub_145E3C7C0(v46, *(float *)&_XMM6);
  v47 = qword_149C8E0E0;
  if ( qword_149C8E0E0 )
  {
    v48 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E0E0 + 0x20LL);
    v49 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x58LL))(*(_QWORD *)(a1 + 0xE8));
    v48(v47, v49);
  }
  v50 = *(_QWORD *)(a1 + 0xC38);
  if ( v50 )
    sub_143066D50(v50);
  v51 = *(_QWORD *)(a1 + 0xDF0);
  if ( v51 && dword_149FB1608 )
    sub_145E37C30(v51);
  v52 = *(_QWORD *)(a1 + 0x170);
  if ( v52 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v52 + 0x30LL))(v52);
  if ( qword_149C8E0D0 )
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8E0D0 + 0xC8LL))(qword_149C8E0D0, v45, a3);
  if ( *(_BYTE *)(a1 + 0xB51) != (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x388LL))(qword_149C8DFE0) )
    *(_BYTE *)(a1 + 0xB51) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x388LL))(qword_149C8DFE0);
  v53 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x128LL))(*(_QWORD *)(a1 + 0xE8));
  v54 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v53 + 0xB0LL))(v53, "debug");
  v55 = v54;
  if ( v54 )
  {
    v56 = *(_BYTE *)(a1 + 0xB51);
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v54 + 0xB8LL))(v54) != v56 )
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v55 + 0xB0LL))(v55, v56);
  }
  if ( (_WORD)qword_149C8E516 )
    goto LABEL_95;
  v57 = (**(__int64 (__fastcall ***)(__int64))qword_149C8E0A8)(qword_149C8E0A8);
  v58 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v57 + 0x40LL))(v57);
  if ( !v58 )
    goto LABEL_78;
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v58 + 0x18LL))(v58, &n5);
  if ( !n5 || n5 == 5 )
  {
    *(_BYTE *)(a1 + 0xB54) = 1;
    sub_140373CC0(&v91);
    goto LABEL_79;
  }
  if ( n5 != 2 || !*(_BYTE *)(a1 + 0xB54) )
  {
    *(_BYTE *)(a1 + 0xB54) = 0;
    sub_140373CC0(&v91);
LABEL_78:
    sub_1465E7760((_BYTE *)a1);
    *(_BYTE *)(a1 + 0xB53) = 1;
    goto LABEL_79;
  }
  sub_140373CC0(&v91);
LABEL_79:
  v59 = sub_1465E4B20(a1);
  v60 = sub_14554D170();
  if ( v59 )
    n2 = (v59 >> 0x1F) + 3;
  sub_145526A10(v60, n2);
  if ( v59 < 0 )
  {
    v61 = qword_149C8DFE0;
    v62 = *(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DFE0 + 0xC8LL);
    v63 = sub_140421510((__int64)v94, 0x7548, "Back-end services are unresponsive");
    v62(v61, v63, 0);
    sub_140373CC0(&v95);
    v87 = __rdtsc();
    return qword_149C89AA8((char *)&v83 + 4);
  }
  v65 = (unsigned __int8 *)sub_14554D170();
  sub_14551CC20(v65);
  v66 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E050 + 0x58LL))(qword_149C8E050);
  if ( v66 )
  {
    (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, v92);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm2, xmm0, xmm0 }
    if ( (float)(*(float *)&_XMM2 - *(float *)&dword_149FBE8CC) >= 30.0 )
    {
      v69 = *(_QWORD *)(a1 + 0xE8);
      dword_149FBE8CC = _XMM2;
      v70 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v69 + 0x180LL))(v69);
      v71 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v70 + 0x28LL))(v70);
      if ( v71 )
      {
        v72 = (unsigned int)sub_146580240(v71);
        n2_1 = 2;
        if ( !byte_149C8E1C0 )
          n2_1 = 3;
        (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v66 + 0x88LL))(v66, n2_1, v72);
      }
      else
      {
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v66 + 0x88LL))(v66, 4);
      }
    }
    if ( byte_149BC4910 == 1 )
    {
      v74 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x238LL))(qword_149C8DFE0);
      if ( v74 )
      {
        v75 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)qword_149C8DFD0 + 0xC0LL))(
                qword_149C8DFD0,
                "preferred_region_id");
        v76 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v75 + 0x10LL))(v75);
        (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v74 + 0x20LL))(v74, v76);
      }
      byte_149BC4910 = 0;
    }
  }
LABEL_95:
  sub_143A3D9A0();
  if ( qword_149C8E100 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E100 + 0x20LL))(qword_149C8E100);
  LOBYTE(v77) = 1;
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E080 + 0x128LL))(qword_149C8E080, v77);
  v87 = __rdtsc();
  qword_149C89AA8((char *)&v83 + 4);
  if ( !(_BYTE)qword_149C8E516 )
  {
    HIDWORD(v83) = 0x1600;
    v84 = 0;
    v85 = 1;
    v87 = 0;
    v88 = 0;
    v89 = 0;
    v86 = __rdtsc();
    qword_149C89AA0(
      (char *)&v83 + 4,
      &word_149FBE8D0,
      "ThrottleFrameRate",
      "W:/p4-src/CryEngine/Code/GameSDK/GameDll/Game.cpp",
      0x920);
    HIWORD(v83) = word_149FBE8D0;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x188LL))(qword_149C8DFE0);
    if ( !(_BYTE)qword_149C8E516
      || ((*(void (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x920LL))(qword_149C8E018),
          !(_BYTE)qword_149C8E516) )
    {
      (*(void (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x918LL))(qword_149C8E018);
    }
    (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149C8DF80 + 0x68LL))(qword_149C8DF80, v93);
    v78 = sub_14059CC00();
    *((_QWORD *)&v80 + 1) = v78.m128_u64[1];
    *(double *)&v80 = *(double *)v78.m128_u64 * 1000.0;
    _XMM0 = v80;
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x180LL))(qword_149C8DFE0);
    v87 = __rdtsc();
    qword_149C89AA8((char *)&v83 + 4);
  }
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E080 + 0x128LL))(qword_149C8E080, 0);
}

// --- End Function: sub_1465F0750 (0x1465F09C7) ---

// --- Function: sub_1465F1190 (0x1465F1190) ---
void __fastcall sub_1465F1190(__int64 a1)
{
  float v3; // xmm2_4
  int n3; // eax

  if ( !BYTE1(qword_149C8E516) )
  {
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(qword_149C8DF80, 1);
    _XMM0 = sub_14059CC00();
    v3 = *(float *)(a1 + 0xEAC);
    n3 = *(_DWORD *)(a1 + 0xEA8);
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    if ( !n3 )
    {
      if ( (float)(*(float *)&_XMM1 - v3) < 10.0 )
        return;
      goto LABEL_10;
    }
    if ( n3 == 1 )
    {
      *(float *)(a1 + 0xEAC) = *(float *)&_XMM1;
      *(_DWORD *)(a1 + 0xEA8) = 2;
      return;
    }
    if ( (float)(*(float *)&_XMM1 - v3) >= 10.0 || n3 == 3 && (float)(*(float *)&_XMM1 - v3) >= 3.0 )
    {
LABEL_10:
      *(float *)(a1 + 0xEAC) = *(float *)&_XMM1;
      *(_DWORD *)(a1 + 0xEA8) = 0;
    }
  }
}

// --- End Function: sub_1465F1190 (0x1465F1190) ---

// --- Function: sub_1465F1240 (0x1465F1240) ---
__int64 __fastcall sub_1465F1240(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rax
  int n2; // ecx
  __int64 n4; // rcx
  char v10; // al
  _QWORD *v11; // rdi
  _QWORD *v12; // rax
  float v13; // xmm7_4
  int v14; // eax
  __int64 *v15; // rbx
  float v16; // kr00_4
  const wchar_t *v17; // rax
  __int64 v18; // rcx
  __int64 *v19; // rbx
  __int64 v20; // rdx
  volatile signed __int32 *v21; // rdi
  signed __int32 v22; // eax
  signed __int32 v23; // ett
  volatile signed __int32 *v24; // rcx
  int v25; // edi
  __int64 v26; // r8
  unsigned __int64 v27; // rax
  __int64 *v28; // rsi
  __int64 v29; // rbx
  __int64 v30; // rdi
  volatile signed __int32 *v31; // rcx
  __int64 v33; // rcx
  int v34; // eax
  unsigned __int64 n0x200000; // rax
  __int128 v37; // [rsp+48h] [rbp-79h] BYREF
  __int64 *v38; // [rsp+58h] [rbp-69h]
  __int64 v39; // [rsp+60h] [rbp-61h]
  int *v40; // [rsp+68h] [rbp-59h]
  int v41; // [rsp+70h] [rbp-51h] BYREF
  int n0x5F00; // [rsp+78h] [rbp-49h] BYREF
  __int64 v43; // [rsp+7Ch] [rbp-45h]
  int v44; // [rsp+84h] [rbp-3Dh]
  unsigned __int64 v45; // [rsp+88h] [rbp-39h]
  unsigned __int64 v46; // [rsp+90h] [rbp-31h]
  __int64 v47; // [rsp+98h] [rbp-29h]
  __int64 v48; // [rsp+A0h] [rbp-21h]
  __int128 v49; // [rsp+C8h] [rbp+7h]
  __int128 v50; // [rsp+D8h] [rbp+17h]
  __int128 v51; // [rsp+E8h] [rbp+27h]

  v5 = *(_QWORD *)(a1 + 0xE8);
  v49 = v3;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x180LL))(v5);
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x28LL))(v6);
  if ( v7 && !sub_146583C90(v7) && byte_149C8E515 )
  {
    n2 = *(_DWORD *)(n29 + 0xCC);
    if ( n2 == 2 )
    {
LABEL_9:
      v11 = (_QWORD *)qword_149FBE640;
      if ( qword_149FBE640
        || ((v12 = (_QWORD *)sub_1402A65A0(8u)) == 0
          ? (v11 = 0, qword_149FBE640 = 0)
          : (v11 = sub_140361D70(v12, (unsigned __int8 **)qword_149FBE638), qword_149FBE640 = (__int64)v11),
            v11) )
      {
        v51 = v1;
        v50 = v2;
        v13 = (float)(*(int (**)(void))(*(_QWORD *)qword_149C8E018 + 0x178LL))() * 0.5;
        v14 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x180LL))(qword_149C8E018);
        v15 = (__int64 *)qword_149C8E018;
        v16 = (float)v14 - 40.0;
        v17 = (const wchar_t *)sub_1402A4EC0((__int64)v11);
        v37 = xmmword_1486940C0;
        sub_1402C7510(v15, v13, v16, 2.0, &v37, 1u, (__int64)"%ls", v17);
      }
    }
    else if ( n2 == 1 )
    {
      n4 = 0;
      while ( 1 )
      {
        v10 = String2_[n4++];
        if ( v10 != aPtu[n4 - 1] )
          break;
        if ( n4 == 4 )
          goto LABEL_9;
      }
    }
  }
  n0x5F00 = 0x5F00;
  v43 = 1;
  v44 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v45 = __rdtsc();
  qword_149C89AA0(
    &n0x5F00,
    &word_149FBE8BC,
    "TaskDomain::Run",
    "W:/p4-src/CryEngine/Code/GameSDK/GameDll/Game.cpp",
    0x6A1);
  v18 = *(_QWORD *)(a1 + 0xE20);
  HIWORD(n0x5F00) = word_149FBE8BC;
  sub_1431D2700(v18);
  v19 = *(__int64 **)(a1 + 0xE30);
  while ( v19 != *(__int64 **)(a1 + 0xE38) )
  {
    v20 = v19[1];
    v21 = 0;
    if ( !v20 )
      goto LABEL_20;
    v22 = *(_DWORD *)(v20 + 8);
    if ( !v22 )
      goto LABEL_20;
    while ( 1 )
    {
      v23 = v22;
      v22 = _InterlockedCompareExchange((volatile signed __int32 *)(v20 + 8), v22 + 1, v22);
      if ( v23 == v22 )
        break;
      if ( !v22 )
        goto LABEL_20;
    }
    v21 = (volatile signed __int32 *)v19[1];
    if ( *v19 )
    {
      sub_1431D2700(*v19);
      v19 += 2;
    }
    else
    {
LABEL_20:
      sub_14350B400(v19 + 2, *(__int64 **)(a1 + 0xE38), v19);
      v24 = *(volatile signed __int32 **)(*(_QWORD *)(a1 + 0xE38) - 8LL);
      if ( v24 && _InterlockedExchangeAdd(v24 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v24 + 8LL))(v24);
      *(_QWORD *)(a1 + 0xE38) -= 0x10LL;
    }
    if ( v21 )
    {
      if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
        if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v21 + 8LL))(v21);
      }
    }
  }
  v41 = 1;
  v38 = (__int64 *)(a1 + 0xE48);
  v39 = a1 + 0xE60;
  v40 = &v41;
  v25 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0xE70) == v25 )
  {
    ++*(_DWORD *)(a1 + 0xE74);
  }
  else
  {
    v26 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v27 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0xE60), 0x200000, 0);
    if ( v27 )
      sub_1403E1120(a1 + 0xE60, v27, v26, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(a1 + 0xE68) = v26;
    *(_DWORD *)(a1 + 0xE70) = v25;
  }
  sub_1465DD300((__int64 *)(a1 + 0xE30), *(_QWORD *)(a1 + 0xE38), *v38, (v38[1] - *v38) >> 4);
  v28 = v38;
  v29 = *v38;
  v30 = v38[1];
  if ( *v38 != v30 )
  {
    do
    {
      v31 = *(volatile signed __int32 **)(v29 + 8);
      if ( v31 && _InterlockedExchangeAdd(v31 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v31 + 8LL))(v31);
      v29 += 0x10;
    }
    while ( v29 != v30 );
    v28[1] = *v28;
  }
  if ( (*v40)-- == 1 )
  {
    v33 = v39;
    v34 = *(_DWORD *)(v39 + 0x14);
    if ( v34 )
    {
      *(_DWORD *)(v39 + 0x14) = v34 - 1;
    }
    else
    {
      *(_DWORD *)(v39 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v33, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v33 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v33, n0x200000);
    }
  }
  v46 = __rdtsc();
  qword_149C89AA8(&n0x5F00);
  return 0;
}

// --- End Function: sub_1465F1240 (0x1465F1240) ---

// --- Function: sub_1466F95E0 (0x1466F95E0) ---
void *sub_1466F95E0()
{
  return &unk_149FC2CB0;
}

// --- End Function: sub_1466F95E0 (0x1466F95E0) ---

// --- Function: sub_146B1D0B0 (0x146B1D0B0) ---
__m128i *__fastcall sub_146B1D0B0(__m128i *a1, __m128i *a2, __int64 a3)
{
  __m128i *i; // rsi
  __m128i v5; // xmm0
  __int64 v6; // r15
  __int8 epi8; // r13
  __m128i *v8; // r14
  __int64 v9; // rdx
  __int64 v10; // r9
  unsigned int v11; // r10d
  __int64 *v12; // rax
  __int64 *v13; // r9
  __m128i *v14; // rbx
  __int64 v15; // rbp
  __int64 v16; // r9

  if ( a1 == a2 )
    return a2;
  for ( i = a1 + 1; i != a2; ++i )
  {
    v5 = *i;
    v6 = i->m128i_i64[0];
    epi8 = _mm_extract_epi8(*i, 8);
    v8 = i;
    v9 = 0x2E0LL * *(unsigned __int16 *)(i->m128i_i64[0] + 0x10);
    v10 = 0x2E0LL * *(unsigned __int16 *)(a1->m128i_i64[0] + 0x10);
    v11 = *(_DWORD *)(0x20 * __popcnt(((1LL << epi8) - 1) & *(_QWORD *)(v9 + a3 + 0x42B8))
                    + *(_QWORD *)(v9 + a3 + 0x4150)
                    + 0x18);
    if ( v11 >= *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v10 + a3 + 0x42B8) & ((1LL << a1->m128i_i8[8]) - 1))
                          + *(_QWORD *)(v10 + a3 + 0x4150)
                          + 0x18) )
    {
      v14 = i + 0xFFFFFFFF;
      v15 = i[0xFFFFFFFF].m128i_i64[0];
      if ( v11 < *(_DWORD *)(0x20
                           * __popcnt(
                               *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v15 + 0x10) + a3 + 0x42B8)
                             & ((1LL << i[0xFFFFFFFF].m128i_i8[8]) - 1))
                           + *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v15 + 0x10) + a3 + 0x4150)
                           + 0x18) )
      {
        do
        {
          v8->m128i_i64[0] = v15;
          v8->m128i_i8[8] = v14->m128i_i8[8];
          v8 = v14;
          v14 += 0xFFFFFFFF;
          v15 = v14->m128i_i64[0];
          v16 = 0x2E0LL * *(unsigned __int16 *)(v14->m128i_i64[0] + 0x10);
        }
        while ( *(_DWORD *)(0x20
                          * __popcnt(
                              ((1LL << epi8) - 1)
                            & *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v6 + 0x10) + a3 + 0x42B8))
                          + *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v6 + 0x10) + a3 + 0x4150)
                          + 0x18) < *(_DWORD *)(0x20
                                              * __popcnt(*(_QWORD *)(v16 + a3 + 0x42B8) & ((1LL << v14->m128i_i8[8]) - 1))
                                              + *(_QWORD *)(v16 + a3 + 0x4150)
                                              + 0x18) );
        epi8 = _mm_extract_epi8(v5, 8);
      }
      v8->m128i_i64[0] = v6;
      v8->m128i_i8[8] = epi8;
    }
    else
    {
      if ( i != a1 )
      {
        v12 = &i->m128i_i64[1];
        do
        {
          v13 = v12;
          v12 += 0xFFFFFFFE;
          v12[1] = v12[0xFFFFFFFF];
          *(_BYTE *)v13 = *(_BYTE *)v12;
        }
        while ( v12 + 0xFFFFFFFF != (__int64 *)a1 );
      }
      a1->m128i_i64[0] = v6;
      a1->m128i_i8[8] = epi8;
    }
  }
  return a2;
}

// --- End Function: sub_146B1D0B0 (0x146B1D0B0) ---

// --- Function: sub_146B1D660 (0x146B1D660) ---
void __fastcall sub_146B1D660(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rbp
  __int64 v5; // r10
  __int64 v6; // r15
  __int128 *v7; // r12
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 v10; // rsi
  _BYTE *v11; // rdi
  __int64 v12; // rbx
  __int64 v13; // r9
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rax
  __int64 v17; // rdi
  __int64 v18; // rsi
  __int64 v19; // rax
  __int64 v20; // rax
  __int128 v21; // [rsp+0h] [rbp-48h]
  __int64 v22; // [rsp+50h] [rbp+8h]
  __int64 v23; // [rsp+58h] [rbp+10h]
  __int64 v24; // [rsp+68h] [rbp+20h]

  v3 = (a2 - a1) >> 4;
  v23 = v3;
  v4 = v3 >> 1;
  if ( v3 >> 1 > 0 )
  {
    v5 = v3 - 1;
    v6 = (v3 - 1) >> 1;
    v24 = v6;
    v7 = (__int128 *)(a1 + 0x10 * v4);
    v22 = v3 - 1;
    do
    {
      --v4;
      v7 += 0xFFFFFFFF;
      v8 = v4;
      v9 = v4;
      v21 = *v7;
      if ( v4 < v6 )
      {
        do
        {
          v10 = 2 * v9;
          v11 = (_BYTE *)(a1 + 0x10 * (2 * v9 + 2));
          v12 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v11 + 0x10LL);
          v13 = 0x2E0LL * *(unsigned __int16 *)(*((_QWORD *)v11 + 0xFFFFFFFE) + 0x10LL);
          v14 = 2 * v8;
          v9 = v10
             + 2LL
             - (*(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v12 + a3 + 0x42B8) & ((1LL << v11[8]) - 1))
                          + *(_QWORD *)(v12 + a3 + 0x4150)
                          + 0x18) < *(_DWORD *)(0x20
                                              * __popcnt(*(_QWORD *)(v13 + a3 + 0x42B8) & ((1LL << v11[0xFFFFFFF8]) - 1))
                                              + *(_QWORD *)(v13 + a3 + 0x4150)
                                              + 0x18));
          *(_QWORD *)(a1 + 8 * v14) = *(_QWORD *)(a1 + 0x10 * v9);
          *(_BYTE *)(a1 + 8 * v14 + 8) = *(_BYTE *)(a1 + 0x10 * v9 + 8);
          v8 = v9;
        }
        while ( v9 < v6 );
        v3 = v23;
        v5 = v22;
      }
      if ( v8 == v6 && (v3 & 1) == 0 )
      {
        v15 = 2 * v3;
        v16 = 2 * v8;
        *(_QWORD *)(a1 + 8 * v16) = *(_QWORD *)(a1 + 8 * v15 - 0x10);
        *(_BYTE *)(a1 + 8 * v16 + 8) = *(_BYTE *)(a1 + 8 * v15 - 8);
        v8 = v5;
      }
      if ( v4 < v8 )
      {
        do
        {
          v17 = (v8 - 1) >> 1;
          v18 = *(_QWORD *)(a1 + 0x10 * v17);
          if ( *(_DWORD *)(0x20
                         * __popcnt(
                             *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v18 + 0x10) + a3 + 0x42B8)
                           & ((1LL << *(_BYTE *)(a1 + 0x10 * v17 + 8)) - 1))
                         + *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v18 + 0x10) + a3 + 0x4150)
                         + 0x18) >= *(_DWORD *)(0x20
                                              * __popcnt(
                                                  ((1LL << SBYTE8(v21)) - 1)
                                                & *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v21 + 0x10) + a3 + 0x42B8))
                                              + *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v21 + 0x10) + a3 + 0x4150)
                                              + 0x18) )
            break;
          v19 = 2 * v8;
          *(_QWORD *)(a1 + 8 * v19) = v18;
          *(_BYTE *)(a1 + 8 * v19 + 8) = *(_BYTE *)(a1 + 0x10 * v17 + 8);
          v8 = v17;
        }
        while ( v4 < v17 );
      }
      v3 = v23;
      v20 = 2 * v8;
      *(_QWORD *)(a1 + 8 * v20) = v21;
      v5 = v23 - 1;
      v6 = v24;
      *(_BYTE *)(a1 + 8 * v20 + 8) = BYTE8(v21);
    }
    while ( v4 > 0 );
  }
}

// --- End Function: sub_146B1D660 (0x146B1D660) ---

// --- Function: sub_146B1DD60 (0x146B1DD60) ---
__int64 __fastcall sub_146B1DD60(_BYTE *a1, _BYTE *a2, _BYTE *a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v6; // rbp
  char v8; // cl
  __int64 v9; // rdx
  char v10; // al
  char v11; // cl
  __int64 v12; // r14
  char v13; // bp
  __int64 v14; // rdx
  __int64 v15; // r10
  __int64 result; // rax
  char v17; // al
  __int64 v18; // rdi
  __int64 v19; // r10
  __int64 v20; // rdx
  char v21; // cl

  v4 = *(_QWORD *)a1;
  v6 = *(_QWORD *)a2;
  v8 = a2[8];
  v9 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)a2 + 0x10LL);
  if ( *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v9 + a4 + 0x42B8) & ((1LL << v8) - 1))
                 + *(_QWORD *)(v9 + a4 + 0x4150)
                 + 0x18) < *(_DWORD *)(0x20
                                     * __popcnt(
                                         *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v4 + 0x10) + a4 + 0x42B8)
                                       & ((1LL << a1[8]) - 1))
                                     + *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v4 + 0x10) + a4 + 0x4150)
                                     + 0x18)
    && a2 != a1 )
  {
    *(_QWORD *)a2 = v4;
    v10 = a1[8];
    *(_QWORD *)a1 = v6;
    v11 = a2[8];
    a2[8] = v10;
    a1[8] = v11;
  }
  v12 = *(_QWORD *)a3;
  v13 = a2[8];
  v14 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)a3 + 0x10LL);
  v15 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)a2 + 0x10LL);
  result = *(_QWORD *)(v15 + a4 + 0x4150);
  if ( *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v14 + a4 + 0x42B8) & ((1LL << a3[8]) - 1))
                 + *(_QWORD *)(v14 + a4 + 0x4150)
                 + 0x18) < *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v15 + a4 + 0x42B8) & ((1LL << v13) - 1))
                                     + result
                                     + 0x18) )
  {
    if ( a3 != a2 )
    {
      *(_QWORD *)a3 = *(_QWORD *)a2;
      v17 = a2[8];
      *(_QWORD *)a2 = v12;
      v13 = a3[8];
      a3[8] = v17;
      a2[8] = v13;
    }
    v18 = *(_QWORD *)a2;
    v19 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)a2 + 0x10LL);
    v20 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)a1 + 0x10LL);
    result = *(unsigned int *)(0x20 * __popcnt(*(_QWORD *)(v20 + a4 + 0x42B8) & ((1LL << a1[8]) - 1))
                             + *(_QWORD *)(v20 + a4 + 0x4150)
                             + 0x18);
    if ( *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v19 + a4 + 0x42B8) & ((1LL << v13) - 1))
                   + *(_QWORD *)(v19 + a4 + 0x4150)
                   + 0x18) < (unsigned int)result
      && a2 != a1 )
    {
      *(_QWORD *)a2 = *(_QWORD *)a1;
      result = (unsigned __int8)a1[8];
      *(_QWORD *)a1 = v18;
      v21 = a2[8];
      a2[8] = result;
      a1[8] = v21;
    }
  }
  return result;
}

// --- End Function: sub_146B1DD60 (0x146B1DD60) ---

// --- Function: sub_146B1DF60 (0x146B1DF60) ---
_QWORD *__fastcall sub_146B1DF60(_QWORD *a1, _BYTE *a2, _BYTE *a3, __int64 a4)
{
  _QWORD *v4; // r14
  _BYTE *v6; // rbx
  __int64 n0x28; // rsi
  __int64 v9; // r14
  __int64 v10; // rsi
  _BYTE *v11; // rbp
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // r9
  _BYTE *v16; // r10
  __int64 v17; // rcx
  __int64 v18; // rdi
  _BYTE *v19; // r11
  __int64 v20; // r8
  unsigned int v21; // edx
  __int64 v22; // rax
  unsigned __int64 v23; // rcx
  __int64 v24; // rdx
  unsigned int v25; // r8d
  __int64 v26; // rdx
  __int64 v27; // rax
  unsigned __int64 v28; // rcx
  _BYTE *v29; // r11
  _BYTE *v30; // rdi
  __int64 v31; // r8
  __int64 v32; // rdx
  unsigned int v33; // edx
  __int64 v34; // rax
  unsigned __int64 v35; // rcx
  __int64 v36; // rax
  char v37; // cl
  bool v38; // zf
  _BYTE *v39; // rsi
  __int64 v40; // rdx
  __int64 v41; // r8
  unsigned int v42; // edx
  __int64 v43; // rax
  unsigned __int64 v44; // rcx
  __int64 v45; // rax
  char v46; // cl
  __int64 v47; // rcx
  char v48; // al
  __int64 v49; // rcx
  char v50; // al
  __int64 v51; // rcx
  char v52; // al
  __int64 v53; // rcx
  char v54; // al
  __int64 v55; // rcx
  char v56; // al
  _QWORD *result; // rax

  v4 = a1;
  v6 = &a2[0x10 * ((a3 - a2) >> 5)];
  n0x28 = (a3 + 0xFFFFFFF0 - a2) >> 4;
  if ( n0x28 <= 0x28 )
  {
    sub_146B1DD60(a2, v6, a3 + 0xFFFFFFF0, a4);
  }
  else
  {
    v9 = (n0x28 + 1) >> 3;
    v10 = 0x10 * v9;
    v9 *= 0x20;
    v11 = &a2[v10];
    sub_146B1DD60(a2, &a2[v10], &a2[v9], a4);
    sub_146B1DD60(&v6[-v10], v6, &v6[v10], v12);
    sub_146B1DD60(&a3[-v9 + 0xFFFFFFF0LL], &a3[-v10 + 0xFFFFFFF0LL], a3 + 0xFFFFFFF0, v13);
    sub_146B1DD60(v11, v6, &a3[-v10 + 0xFFFFFFF0LL], v14);
    v4 = a1;
  }
  v16 = v6 + 0x10;
  if ( a2 < v6 )
  {
    v17 = *(_QWORD *)v6;
    do
    {
      v18 = *((_QWORD *)v6 + 0xFFFFFFFE);
      v19 = v6 + 0xFFFFFFF0;
      v20 = 0x2E0LL * *(unsigned __int16 *)(v17 + 0x10);
      v21 = *(_DWORD *)(0x20
                      * __popcnt(
                          *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v18 + 0x10) + v15 + 0x42B8)
                        & ((1LL << v6[0xFFFFFFF8]) - 1))
                      + *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v18 + 0x10) + v15 + 0x4150)
                      + 0x18);
      v22 = *(_QWORD *)(v20 + v15 + 0x4150);
      v23 = 0x20 * __popcnt(*(_QWORD *)(v20 + v15 + 0x42B8) & ((1LL << v6[8]) - 1));
      if ( v21 < *(_DWORD *)(v23 + v22 + 0x18) )
        break;
      if ( v21 > *(_DWORD *)(v23 + v22 + 0x18) )
        break;
      v6 += 0xFFFFFFF0;
      v17 = v18;
    }
    while ( a2 < v19 );
  }
  if ( v16 < a3 )
  {
    v24 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v6 + 0x10LL);
    v25 = *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v24 + v15 + 0x42B8) & ((1LL << v6[8]) - 1))
                    + *(_QWORD *)(v24 + v15 + 0x4150)
                    + 0x18);
    do
    {
      v26 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v16 + 0x10LL);
      v27 = *(_QWORD *)(v26 + v15 + 0x4150);
      v28 = 0x20 * __popcnt(*(_QWORD *)(v26 + v15 + 0x42B8) & ((1LL << v16[8]) - 1));
      if ( *(_DWORD *)(v28 + v27 + 0x18) < v25 )
        break;
      if ( *(_DWORD *)(v28 + v27 + 0x18) > v25 )
        break;
      v16 += 0x10;
    }
    while ( v16 < a3 );
  }
  v29 = v16;
  v30 = v6;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( ; v29 < a3; v29 += 0x10 )
      {
        v31 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v29 + 0x10LL);
        v32 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v6 + 0x10LL);
        v33 = *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v32 + v15 + 0x42B8) & ((1LL << v6[8]) - 1))
                        + *(_QWORD *)(v32 + v15 + 0x4150)
                        + 0x18);
        v34 = *(_QWORD *)(v31 + v15 + 0x4150);
        v35 = 0x20 * __popcnt(*(_QWORD *)(v31 + v15 + 0x42B8) & ((1LL << v29[8]) - 1));
        if ( v33 >= *(_DWORD *)(v35 + v34 + 0x18) )
        {
          if ( v33 > *(_DWORD *)(v35 + v34 + 0x18) )
            break;
          if ( v16 != v29 )
          {
            v36 = *(_QWORD *)v16;
            *(_QWORD *)v16 = *(_QWORD *)v29;
            *(_QWORD *)v29 = v36;
            v37 = v16[8];
            v16[8] = v29[8];
            v29[8] = v37;
          }
          v16 += 0x10;
        }
      }
      v38 = v30 == a2;
      if ( v30 > a2 )
      {
        v39 = v30 + 0xFFFFFFF0;
        do
        {
          v40 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v39 + 0x10LL);
          v41 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v6 + 0x10LL);
          v42 = *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v40 + v15 + 0x42B8) & ((1LL << v39[8]) - 1))
                          + *(_QWORD *)(v40 + v15 + 0x4150)
                          + 0x18);
          v43 = *(_QWORD *)(v41 + v15 + 0x4150);
          v44 = 0x20 * __popcnt(*(_QWORD *)(v41 + v15 + 0x42B8) & ((1LL << v6[8]) - 1));
          if ( v42 >= *(_DWORD *)(v44 + v43 + 0x18) )
          {
            if ( v42 > *(_DWORD *)(v44 + v43 + 0x18) )
              break;
            v6 += 0xFFFFFFF0;
            if ( v6 != v39 )
            {
              v45 = *(_QWORD *)v6;
              *(_QWORD *)v6 = *(_QWORD *)v39;
              *(_QWORD *)v39 = v45;
              v46 = v6[8];
              v6[8] = v39[8];
              v39[8] = v46;
            }
          }
          v30 += 0xFFFFFFF0;
          v39 += 0xFFFFFFF0;
        }
        while ( a2 < v30 );
        v38 = v30 == a2;
      }
      if ( v38 )
        break;
      v30 += 0xFFFFFFF0;
      if ( v29 == a3 )
      {
        v6 += 0xFFFFFFF0;
        if ( v30 != v6 )
        {
          v51 = *(_QWORD *)v30;
          *(_QWORD *)v30 = *(_QWORD *)v6;
          v52 = v6[8];
          *(_QWORD *)v6 = v51;
          LOBYTE(v51) = v30[8];
          v30[8] = v52;
          v6[8] = v51;
        }
        v16 += 0xFFFFFFF0;
        if ( v6 != v16 )
        {
          v53 = *(_QWORD *)v6;
          *(_QWORD *)v6 = *(_QWORD *)v16;
          v54 = v16[8];
          *(_QWORD *)v16 = v53;
          LOBYTE(v53) = v6[8];
          v6[8] = v54;
          v16[8] = v53;
        }
      }
      else
      {
        if ( v29 != v30 )
        {
          v55 = *(_QWORD *)v29;
          *(_QWORD *)v29 = *(_QWORD *)v30;
          v56 = v30[8];
          *(_QWORD *)v30 = v55;
          LOBYTE(v55) = v29[8];
          v29[8] = v56;
          v30[8] = v55;
        }
        v29 += 0x10;
      }
    }
    if ( v29 == a3 )
      break;
    if ( v16 != v29 && v6 != v16 )
    {
      v47 = *(_QWORD *)v6;
      *(_QWORD *)v6 = *(_QWORD *)v16;
      v48 = v16[8];
      *(_QWORD *)v16 = v47;
      LOBYTE(v47) = v6[8];
      v6[8] = v48;
      v16[8] = v47;
    }
    v16 += 0x10;
    if ( v6 != v29 )
    {
      v49 = *(_QWORD *)v6;
      *(_QWORD *)v6 = *(_QWORD *)v29;
      v50 = v29[8];
      *(_QWORD *)v29 = v49;
      LOBYTE(v49) = v6[8];
      v6[8] = v50;
      v29[8] = v49;
    }
    v6 += 0x10;
    v29 += 0x10;
  }
  result = v4;
  *v4 = v6;
  v4[1] = v16;
  return result;
}

// --- End Function: sub_146B1DF60 (0x146B1DF60) ---

// --- Function: sub_146B1F280 (0x146B1F280) ---
__int64 __fastcall sub_146B1F280(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5)
{
  __int64 v7; // r12
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 i; // r14
  __int64 v11; // rsi
  _BYTE *v12; // rdi
  __int64 v13; // rbx
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // r13
  __int64 v17; // rdx
  __int64 v18; // rsi
  __int64 v19; // r14
  __int64 v20; // r10
  __int64 v21; // rdx
  __int64 v22; // rdx
  __int64 result; // rax

  v7 = a2;
  v8 = a3 - 1;
  v9 = a2;
  for ( i = v8 >> 1; v9 < i; a2 = v9 )
  {
    v11 = 2 * v9;
    v12 = (_BYTE *)(a1 + 0x10 * (2 * v9 + 2));
    v13 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)v12 + 0x10LL);
    v14 = 0x2E0LL * *(unsigned __int16 *)(*((_QWORD *)v12 + 0xFFFFFFFE) + 0x10LL);
    v15 = 2 * a2;
    v9 = v11
       + 2LL
       - (*(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v13 + a5 + 0x42B8) & ((1LL << v12[8]) - 1))
                    + *(_QWORD *)(v13 + a5 + 0x4150)
                    + 0x18) < *(_DWORD *)(0x20
                                        * __popcnt(*(_QWORD *)(v14 + a5 + 0x42B8) & ((1LL << v12[0xFFFFFFF8]) - 1))
                                        + *(_QWORD *)(v14 + a5 + 0x4150)
                                        + 0x18));
    *(_QWORD *)(a1 + 8 * v15) = *(_QWORD *)(a1 + 0x10 * v9);
    *(_BYTE *)(a1 + 8 * v15 + 8) = *(_BYTE *)(a1 + 0x10 * v9 + 8);
  }
  if ( v9 == i && (a3 & 1) == 0 )
  {
    v16 = 2 * a3;
    v17 = 2 * a2;
    *(_QWORD *)(a1 + 8 * v17) = *(_QWORD *)(a1 + 8 * v16 - 0x10);
    *(_BYTE *)(a1 + 8 * v17 + 8) = *(_BYTE *)(a1 + 8 * v16 - 8);
    a2 = v8;
  }
  if ( v7 < a2 )
  {
    do
    {
      v18 = (a2 - 1) >> 1;
      v19 = *(_QWORD *)(a1 + 0x10 * v18);
      v20 = 0x2E0LL * *(unsigned __int16 *)(*(_QWORD *)a4 + 0x10LL);
      if ( *(_DWORD *)(0x20
                     * __popcnt(
                         *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v19 + 0x10) + a5 + 0x42B8)
                       & ((1LL << *(_BYTE *)(a1 + 0x10 * v18 + 8)) - 1))
                     + *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v19 + 0x10) + a5 + 0x4150)
                     + 0x18) >= *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v20 + a5 + 0x42B8) & ((1LL << a4[8]) - 1))
                                          + *(_QWORD *)(v20 + a5 + 0x4150)
                                          + 0x18) )
        break;
      v21 = 2 * a2;
      *(_QWORD *)(a1 + 8 * v21) = v19;
      *(_BYTE *)(a1 + 8 * v21 + 8) = *(_BYTE *)(a1 + 0x10 * v18 + 8);
      a2 = v18;
    }
    while ( v7 < v18 );
  }
  v22 = 2 * a2;
  *(_QWORD *)(a1 + 8 * v22) = *(_QWORD *)a4;
  result = (unsigned __int8)a4[8];
  *(_BYTE *)(a1 + 8 * v22 + 8) = result;
  return result;
}

// --- End Function: sub_146B1F280 (0x146B1F280) ---

// --- Function: sub_146B1FC60 (0x146B1FC60) ---
void __fastcall sub_146B1FC60(__m128i *a1, __m128i *a2, __int64 a3, __int64 a4)
{
  __m128i *v6; // rsi
  __m128i *v7; // rdi
  __m128i v8; // kr00_16
  __m128i *v9; // rsi
  __m128i v10; // xmm0
  __int8 v11; // al
  __m128i v12; // [rsp+30h] [rbp-28h] BYREF

  v6 = a2;
  v7 = a1;
  if ( (__int64)(((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFF0uLL) <= 0x200 )
  {
LABEL_7:
    sub_146B1D0B0(v7, v6, a4);
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_146B1DF60(&v12, v7, v6, a4);
      v8 = v12;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((v12.m128i_i64[0] - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF0uLL) >= (__int64)(((unsigned __int64)v6
                                                                                          - v12.m128i_i64[1])
                                                                                         & 0xFFFFFFFFFFFFFFF0uLL) )
      {
        sub_146B1FC60(v12.m128i_i64[1], v6, a3, a4);
        v6 = (__m128i *)v8.m128i_i64[0];
      }
      else
      {
        sub_146B1FC60(v7, v12.m128i_i64[0], a3, a4);
        v7 = (__m128i *)v8.m128i_i64[1];
      }
      if ( (__int64)(((char *)v6 - (char *)v7) & 0xFFFFFFFFFFFFFFF0uLL) <= 0x200 )
        goto LABEL_7;
    }
    sub_146B1D660((__int64)v7, (__int64)v6, a4);
    if ( (__int64)(((char *)v6 - (char *)v7) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x20 )
    {
      v9 = v6 + 0xFFFFFFFF;
      do
      {
        v10 = *v9;
        v9->m128i_i64[0] = v7->m128i_i64[0];
        v11 = v7->m128i_i8[8];
        v12 = v10;
        v9->m128i_i8[8] = v11;
        sub_146B1F280((__int64)v7, 0, v9 - v7, &v12, a4);
        v9 += 0xFFFFFFFF;
      }
      while ( (__int64)(((unsigned __int64)v9->m128i_u64 + 0x10LL - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x20 );
    }
  }
}

// --- End Function: sub_146B1FC60 (0x146B1FC60) ---

// --- Function: sub_146B29BE0 (0x146B29BE0) ---
__int64 __fastcall sub_146B29BE0(unsigned int *a1)
{
  int v2; // eax
  __int64 v3; // r8
  __int64 v4; // rdx
  __int64 v5; // r13
  __int64 p_rw_lock_state; // r15
  signed __int64 v7; // rdx
  __int64 v8; // rsi
  unsigned __int64 i; // rbp
  __int64 v10; // rdi
  unsigned __int8 v11; // r12
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rbx
  bool v17; // al
  __int64 v18; // r13
  __int64 p_rw_lock_state_1; // r12
  signed __int64 v20; // rbx
  __int64 v21; // rax
  unsigned __int64 v22; // rsi
  _BYTE *v23; // rbx
  __int64 v24; // rdi
  unsigned __int8 v25; // bp
  unsigned __int8 v26; // r15
  __int64 v27; // rbx
  int v28; // edi
  __int64 v29; // r8
  unsigned __int64 v30; // rax
  unsigned int n9; // eax
  int n0x242; // ecx
  unsigned int v33; // eax
  __int64 v34; // rdi
  int v35; // ecx
  unsigned __int64 n0x200000; // rax
  unsigned __int64 v38[9]; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int64 v39; // [rsp+80h] [rbp+8h] BYREF
  unsigned __int64 v40; // [rsp+90h] [rbp+18h] BYREF
  unsigned __int64 v41; // [rsp+98h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x18LL))(qword_149C8E038);
  v3 = v2;
  if ( v2 )
  {
    v4 = 0;
    do
    {
      v4 += 0x40;
      *(_DWORD *)(v4 + *(_QWORD *)(*(_QWORD *)a1 + 0x174070LL) - 0x40) = 0;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 0x174070LL) + v4 - 0x3C) = 0;
      --v3;
    }
    while ( v3 );
  }
  sub_146B4AE20(*(_QWORD *)a1, a1[4], v3);
  v5 = *(_QWORD *)a1;
  p_rw_lock_state = *(_QWORD *)a1 + 0xA0LL;
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state + 0x14);
  }
  else
  {
    v7 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (v7 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        p_rw_lock_state,
        v7,
        "CEntityComponentUpdateScheduler::ExecuteBackgroundDeferredActivateComponent",
        "m_arrBackgroundDeferredActivateComponentLock",
        1);
  }
  v39 = 0;
  v8 = sub_1403DAFD0(v5 + 0x30, &v39);
  for ( i = v39 >> 4; i; --i )
  {
    v10 = *(_QWORD *)v8;
    v11 = *(_BYTE *)(v8 + 8);
    if ( *(_QWORD *)v8 )
    {
      v12 = *(_QWORD *)(v10 + 8);
      v41 = v12;
      if ( v12 )
      {
        v13 = v12;
        v14 = HIWORD(v12);
        v15 = v13 & 0xFFFFFFFFFFFFLL;
        v16 = (v14 & 0xF000) != 0 ? v15 & 0xFFFFFF000000LL : v15 - 6;
        if ( *(_WORD *)(v16 + 2) == (v14 & 0xFFF) )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v17 = is_thread_privileged_or_bypass_mode()) )
            v17 = 1;
          if ( *(_WORD *)(v16 + 4) == 2 && v17 || sub_140395410(&v41) )
          {
            sub_146B2E900(v5, v10, v11, 0);
            _InterlockedDecrement16((volatile signed __int16 *)(v10 + 0x22));
          }
        }
      }
    }
    v8 += 0x10;
  }
  rw_lock_release_read_lock(p_rw_lock_state);
  sub_146B39500(*(_QWORD *)a1);
  v18 = *(_QWORD *)a1;
  p_rw_lock_state_1 = *(_QWORD *)a1 + 0x1B0LL;
  if ( *(_DWORD *)(p_rw_lock_state_1 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state_1 + 0x14);
  }
  else
  {
    v20 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state_1);
    if ( (v20 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        p_rw_lock_state_1,
        v20,
        "CEntityComponentUpdateScheduler::ExecuteBackgroundDeferredComponentFrequencyUpdates",
        "m_arrBackgroundDeferredComponentFrequencyUpdateChangesLock",
        1);
  }
  v40 = 0;
  v21 = sub_1403DAFD0(v18 + 0x140, &v40);
  v22 = v40 >> 4;
  if ( v40 >> 4 )
  {
    v23 = (_BYTE *)(v21 + 0xD);
    do
    {
      v24 = *(_QWORD *)(v23 + 0xFFFFFFF3);
      v25 = v23[0xFFFFFFFF];
      v26 = *v23;
      if ( v24 )
      {
        v38[0] = *(_QWORD *)(v24 + 8);
        if ( is_entity_descriptor_valid_or_accessible(v38) )
        {
          sub_146B4D390(v18, v24, v25, v26);
          _InterlockedDecrement16((volatile signed __int16 *)(v24 + 0x22));
        }
      }
      v23 += 0x10;
      --v22;
    }
    while ( v22 );
  }
  rw_lock_release_read_lock(p_rw_lock_state_1);
  v27 = *((_QWORD *)a1 + 1) + 8LL;
  v28 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v27 + 0x10) == v28 )
  {
    ++*(_DWORD *)(v27 + 0x14);
  }
  else
  {
    v29 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v30 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0x200000, 0);
    if ( v30 )
      sub_1403E1120(
        v27,
        v30,
        v29,
        "CEntityComponentUpdateScheduler::QueueUpdateComponentPass::<lambda_1>::operator ()",
        "rPerPassState.bIsRunningLock",
        1);
    else
      *(_QWORD *)(v27 + 8) = v29;
    *(_DWORD *)(v27 + 0x10) = v28;
  }
  *(_BYTE *)(*((_QWORD *)a1 + 1) + 1LL) = 1;
  sub_146B2F560(*(_QWORD *)a1);
  sub_146B41050(*(_QWORD *)a1 + 0x174EF0LL, *(_QWORD *)(*((_QWORD *)a1 + 1) + 0x440LL) >> 3);
  *(_QWORD *)(*((_QWORD *)a1 + 1) + 0x470LL) = 0;
  n9 = a1[4];
  if ( n9 <= 9 )
  {
    n0x242 = 0x242;
    if ( _bittest(&n0x242, n9) )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xD0LL))(qword_149C8DF28);
  }
  v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x18LL))(qword_149C8E038);
  v34 = *(_QWORD *)(*((_QWORD *)a1 + 1) + 0x440LL) >> 3;
  if ( v33 < (unsigned int)v34 )
    LODWORD(v34) = v33;
  if ( v27 )
  {
    v35 = *(_DWORD *)(v27 + 0x14);
    if ( v35 )
    {
      *(_DWORD *)(v27 + 0x14) = v35 - 1;
    }
    else
    {
      *(_DWORD *)(v27 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v27 + 8) = &p_Src;
      else
        rw_lock_handle_write_release_contention(v27, n0x200000);
    }
  }
  return (unsigned int)v34;
}

// --- End Function: sub_146B29BE0 (0x146B29BE0) ---

// --- Function: sub_146B2DA00 (0x146B2DA00) ---
__int64 __fastcall sub_146B2DA00(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 n9; // rdx
  unsigned __int64 v5; // r13
  int n0x242; // eax
  bool v7; // r8
  __int64 v8; // r15
  char *v9; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rbx
  bool i; // cf
  unsigned __int64 *v13; // r12
  __int64 v14; // r12
  __int64 *v15; // rsi
  char *v16; // rbx
  char *v17; // rcx
  __int64 v18; // r14
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rdx
  __int64 v21; // rax
  char *v22; // rcx
  __int64 *v23; // rdx
  char *Size; // r8
  unsigned __int64 v25; // rsi
  unsigned __int64 v26; // rax
  unsigned __int64 *v27; // rsi
  __int64 v28; // r12
  unsigned __int64 v29; // rbx
  _QWORD *j; // rcx
  __int64 result; // rax
  _BYTE *v32; // rdx
  unsigned __int64 v33; // [rsp+50h] [rbp-19h] BYREF
  __int64 v34; // [rsp+58h] [rbp-11h]
  unsigned __int64 v35; // [rsp+60h] [rbp-9h]
  _DWORD *v36; // [rsp+68h] [rbp-1h]
  char v37[8]; // [rsp+70h] [rbp+7h] BYREF
  void *Src[2]; // [rsp+78h] [rbp+Fh] BYREF
  __int64 *v39; // [rsp+88h] [rbp+1Fh]
  bool v40; // [rsp+D0h] [rbp+67h]
  __int64 v42; // [rsp+E8h] [rbp+7Fh] BYREF

  n9 = *(unsigned int *)(a1 + 0x10);
  v5 = a3;
  v7 = 0;
  if ( (unsigned int)n9 <= 9 )
  {
    n0x242 = 0x242;
    if ( _bittest(&n0x242, n9) )
      v7 = 1;
  }
  v40 = v7;
  v36 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x920LL);
  *v36 = n9;
  if ( v7 )
  {
    LOBYTE(n9) = 1;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF28 + 0xE0LL))(qword_149C8DF28, n9);
  }
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 0x174070LL) + (v5 << 6);
  *(_OWORD *)Src = 0;
  v39 = 0;
  v9 = (char *)sub_140394E70((__int64)Src, 0x80u);
  memmove(v9, Src[0], (char *)Src[1] - (char *)Src[0]);
  if ( Src[0] )
    sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], ((char *)v39 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
  v10 = *(_QWORD *)(a1 + 8);
  Src[0] = v9;
  Src[1] = v9;
  v39 = (__int64 *)(v9 + 0x80);
  v35 = *(_QWORD *)(v10 + 0x440) >> 3;
  v11 = _InterlockedExchangeAdd64((volatile signed __int64 *)(v10 + 0x470), 1u);
  for ( i = v11 < v35; i; i = v11 < v35 )
  {
    v13 = (unsigned __int64 *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x420LL) + 8 * v11);
    if ( is_entity_descriptor_valid_or_accessible(v13) && (v14 = *v13 & 0xFFFFFFFFFFFFLL) != 0 )
    {
      v15 = (__int64 *)Src[1];
      if ( ((char *)Src[1] - (char *)Src[0]) >> 3 )
      {
        Src[1] = Src[0];
        v15 = (__int64 *)Src[0];
      }
      if ( v15 == v39 )
      {
        v18 = ((char *)v15 - (char *)Src[0]) >> 3;
        if ( v18 == 0x1FFFFFFFFFFFFFFFLL )
          unknown_libname_10();
        v5 = v18 + 1;
        v19 = ((char *)v39 - (char *)Src[0]) >> 3;
        v20 = v19 >> 1;
        if ( v19 <= 0x1FFFFFFFFFFFFFFFLL - (v19 >> 1) )
        {
          v21 = v20 + v19;
          if ( v20 + v19 < v5 )
            v21 = v18 + 1;
        }
        else
        {
          v21 = 0x1FFFFFFFFFFFFFFFLL;
        }
        v34 = 8 * v21;
        v16 = (char *)sub_140394E70((__int64)Src, 8 * v21);
        v22 = v16;
        *(_QWORD *)&v16[8 * v18] = v14;
        v23 = (__int64 *)Src[0];
        if ( v15 == Src[1] )
        {
          Size = (char *)((char *)Src[1] - (char *)Src[0]);
        }
        else
        {
          memmove(v16, Src[0], (char *)v15 - (char *)Src[0]);
          v22 = &v16[8 * v18 + 8];
          Size = (char *)((char *)Src[1] - (char *)v15);
          v23 = v15;
        }
        memmove(v22, v23, (size_t)Size);
        if ( Src[0] )
          sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], ((char *)v39 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
        v17 = &v16[8 * v5];
        LOBYTE(v5) = a3;
        v39 = (__int64 *)&v16[v34];
        Src[0] = v16;
      }
      else
      {
        *v15 = v14;
        v16 = (char *)Src[0];
        v17 = (char *)Src[1] + 8;
      }
      Src[1] = v17;
      v25 = 0;
      if ( (v17 - v16) >> 3 )
      {
        do
        {
          sub_146B52350(
            *(_QWORD *)a1,
            *(_QWORD *)(a1 + 8) + 0x3B0,
            *(_QWORD *)&v16[8 * v25++],
            (unsigned __int8)v5,
            *(_DWORD *)(a1 + 0x10),
            v8 + 4,
            v8,
            *(_BYTE *)(a1 + 0x14),
            (__int64)Src);
          v16 = (char *)Src[0];
        }
        while ( v25 < ((char *)Src[1] - (char *)Src[0]) >> 3 );
      }
    }
    else
    {
      *(_QWORD *)sub_1403CE4A0(*(_QWORD *)a1 + 0x174880LL, 8u, 0) = v11;
    }
    _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)a1 + 0x1F4F18LL));
    v11 = _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(a1 + 8) + 0x470LL), 1u);
  }
  sub_146B48AE0(*(_QWORD *)a1 + 0x174EF0LL, &v33, (unsigned __int8)v5);
  v26 = v33;
  if ( (v33 & 0xFFFF000000000000uLL) != 0 )
  {
    do
    {
      v27 = (unsigned __int64 *)(v26 & 0xFFFFFFFFFFFFLL);
      v28 = (v26 & 0xFFFFFFFFFFFFLL) + 8 * HIWORD(v26);
      if ( (v26 & 0xFFFFFFFFFFFFLL) != v28 )
      {
        do
        {
          if ( is_entity_descriptor_valid_or_accessible(v27) )
          {
            v42 = *v27 & 0xFFFFFFFFFFFFLL;
            if ( v42 )
            {
              if ( ((char *)Src[1] - (char *)Src[0]) >> 3 )
                Src[1] = Src[0];
              sub_1402A8EB0(Src, &v42);
              v29 = 0;
              for ( j = Src[0]; v29 < ((char *)Src[1] - (char *)Src[0]) >> 3; j = Src[0] )
                sub_146B52350(
                  *(_QWORD *)a1,
                  *(_QWORD *)(a1 + 8) + 0x3B0,
                  j[v29++],
                  (unsigned __int8)v5,
                  *(_DWORD *)(a1 + 0x10),
                  v8 + 4,
                  v8,
                  *(_BYTE *)(a1 + 0x14),
                  (__int64)Src);
            }
          }
          else
          {
            v42 = 0;
          }
          ++v27;
        }
        while ( v27 != (unsigned __int64 *)v28 );
      }
      _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)a1 + 0x1F4F18LL));
      v26 = *(_QWORD *)sub_146B48AE0(*(_QWORD *)a1 + 0x174EF0LL, v37, (unsigned __int8)v5);
      v33 = v26;
    }
    while ( v26 >= 0x1000000000000LL );
  }
  if ( v40 )
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0xE0LL))(qword_149C8DF28, 0);
  result = (__int64)v36;
  v32 = Src[0];
  *v36 = 0xF;
  if ( v32 )
    return sub_1403A6820((__int64)Src, (unsigned __int64)v32, ((char *)v39 - v32) & 0xFFFFFFFFFFFFFFF8uLL);
  return result;
}

// --- End Function: sub_146B2DA00 (0x146B2DA00) ---

// --- Function: sub_146B2DA00 (0x146B2DCC0) ---
__int64 __fastcall sub_146B2DA00(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 n9; // rdx
  unsigned __int64 v5; // r13
  int n0x242; // eax
  bool v7; // r8
  __int64 v8; // r15
  char *v9; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rbx
  bool i; // cf
  unsigned __int64 *v13; // r12
  __int64 v14; // r12
  __int64 *v15; // rsi
  char *v16; // rbx
  char *v17; // rcx
  __int64 v18; // r14
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rdx
  __int64 v21; // rax
  char *v22; // rcx
  __int64 *v23; // rdx
  char *Size; // r8
  unsigned __int64 v25; // rsi
  unsigned __int64 v26; // rax
  unsigned __int64 *v27; // rsi
  __int64 v28; // r12
  unsigned __int64 v29; // rbx
  _QWORD *j; // rcx
  __int64 result; // rax
  _BYTE *v32; // rdx
  unsigned __int64 v33; // [rsp+50h] [rbp-19h] BYREF
  __int64 v34; // [rsp+58h] [rbp-11h]
  unsigned __int64 v35; // [rsp+60h] [rbp-9h]
  _DWORD *v36; // [rsp+68h] [rbp-1h]
  char v37[8]; // [rsp+70h] [rbp+7h] BYREF
  void *Src[2]; // [rsp+78h] [rbp+Fh] BYREF
  __int64 *v39; // [rsp+88h] [rbp+1Fh]
  bool v40; // [rsp+D0h] [rbp+67h]
  __int64 v42; // [rsp+E8h] [rbp+7Fh] BYREF

  n9 = *(unsigned int *)(a1 + 0x10);
  v5 = a3;
  v7 = 0;
  if ( (unsigned int)n9 <= 9 )
  {
    n0x242 = 0x242;
    if ( _bittest(&n0x242, n9) )
      v7 = 1;
  }
  v40 = v7;
  v36 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x920LL);
  *v36 = n9;
  if ( v7 )
  {
    LOBYTE(n9) = 1;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF28 + 0xE0LL))(qword_149C8DF28, n9);
  }
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 0x174070LL) + (v5 << 6);
  *(_OWORD *)Src = 0;
  v39 = 0;
  v9 = (char *)sub_140394E70((__int64)Src, 0x80u);
  memmove(v9, Src[0], (char *)Src[1] - (char *)Src[0]);
  if ( Src[0] )
    sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], ((char *)v39 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
  v10 = *(_QWORD *)(a1 + 8);
  Src[0] = v9;
  Src[1] = v9;
  v39 = (__int64 *)(v9 + 0x80);
  v35 = *(_QWORD *)(v10 + 0x440) >> 3;
  v11 = _InterlockedExchangeAdd64((volatile signed __int64 *)(v10 + 0x470), 1u);
  for ( i = v11 < v35; i; i = v11 < v35 )
  {
    v13 = (unsigned __int64 *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x420LL) + 8 * v11);
    if ( is_entity_descriptor_valid_or_accessible(v13) && (v14 = *v13 & 0xFFFFFFFFFFFFLL) != 0 )
    {
      v15 = (__int64 *)Src[1];
      if ( ((char *)Src[1] - (char *)Src[0]) >> 3 )
      {
        Src[1] = Src[0];
        v15 = (__int64 *)Src[0];
      }
      if ( v15 == v39 )
      {
        v18 = ((char *)v15 - (char *)Src[0]) >> 3;
        if ( v18 == 0x1FFFFFFFFFFFFFFFLL )
          unknown_libname_10();
        v5 = v18 + 1;
        v19 = ((char *)v39 - (char *)Src[0]) >> 3;
        v20 = v19 >> 1;
        if ( v19 <= 0x1FFFFFFFFFFFFFFFLL - (v19 >> 1) )
        {
          v21 = v20 + v19;
          if ( v20 + v19 < v5 )
            v21 = v18 + 1;
        }
        else
        {
          v21 = 0x1FFFFFFFFFFFFFFFLL;
        }
        v34 = 8 * v21;
        v16 = (char *)sub_140394E70((__int64)Src, 8 * v21);
        v22 = v16;
        *(_QWORD *)&v16[8 * v18] = v14;
        v23 = (__int64 *)Src[0];
        if ( v15 == Src[1] )
        {
          Size = (char *)((char *)Src[1] - (char *)Src[0]);
        }
        else
        {
          memmove(v16, Src[0], (char *)v15 - (char *)Src[0]);
          v22 = &v16[8 * v18 + 8];
          Size = (char *)((char *)Src[1] - (char *)v15);
          v23 = v15;
        }
        memmove(v22, v23, (size_t)Size);
        if ( Src[0] )
          sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], ((char *)v39 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
        v17 = &v16[8 * v5];
        LOBYTE(v5) = a3;
        v39 = (__int64 *)&v16[v34];
        Src[0] = v16;
      }
      else
      {
        *v15 = v14;
        v16 = (char *)Src[0];
        v17 = (char *)Src[1] + 8;
      }
      Src[1] = v17;
      v25 = 0;
      if ( (v17 - v16) >> 3 )
      {
        do
        {
          sub_146B52350(
            *(_QWORD *)a1,
            *(_QWORD *)(a1 + 8) + 0x3B0,
            *(_QWORD *)&v16[8 * v25++],
            (unsigned __int8)v5,
            *(_DWORD *)(a1 + 0x10),
            v8 + 4,
            v8,
            *(_BYTE *)(a1 + 0x14),
            (__int64)Src);
          v16 = (char *)Src[0];
        }
        while ( v25 < ((char *)Src[1] - (char *)Src[0]) >> 3 );
      }
    }
    else
    {
      *(_QWORD *)sub_1403CE4A0(*(_QWORD *)a1 + 0x174880LL, 8u, 0) = v11;
    }
    _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)a1 + 0x1F4F18LL));
    v11 = _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(a1 + 8) + 0x470LL), 1u);
  }
  sub_146B48AE0(*(_QWORD *)a1 + 0x174EF0LL, &v33, (unsigned __int8)v5);
  v26 = v33;
  if ( (v33 & 0xFFFF000000000000uLL) != 0 )
  {
    do
    {
      v27 = (unsigned __int64 *)(v26 & 0xFFFFFFFFFFFFLL);
      v28 = (v26 & 0xFFFFFFFFFFFFLL) + 8 * HIWORD(v26);
      if ( (v26 & 0xFFFFFFFFFFFFLL) != v28 )
      {
        do
        {
          if ( is_entity_descriptor_valid_or_accessible(v27) )
          {
            v42 = *v27 & 0xFFFFFFFFFFFFLL;
            if ( v42 )
            {
              if ( ((char *)Src[1] - (char *)Src[0]) >> 3 )
                Src[1] = Src[0];
              sub_1402A8EB0(Src, &v42);
              v29 = 0;
              for ( j = Src[0]; v29 < ((char *)Src[1] - (char *)Src[0]) >> 3; j = Src[0] )
                sub_146B52350(
                  *(_QWORD *)a1,
                  *(_QWORD *)(a1 + 8) + 0x3B0,
                  j[v29++],
                  (unsigned __int8)v5,
                  *(_DWORD *)(a1 + 0x10),
                  v8 + 4,
                  v8,
                  *(_BYTE *)(a1 + 0x14),
                  (__int64)Src);
            }
          }
          else
          {
            v42 = 0;
          }
          ++v27;
        }
        while ( v27 != (unsigned __int64 *)v28 );
      }
      _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)a1 + 0x1F4F18LL));
      v26 = *(_QWORD *)sub_146B48AE0(*(_QWORD *)a1 + 0x174EF0LL, v37, (unsigned __int8)v5);
      v33 = v26;
    }
    while ( v26 >= 0x1000000000000LL );
  }
  if ( v40 )
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0xE0LL))(qword_149C8DF28, 0);
  result = (__int64)v36;
  v32 = Src[0];
  *v36 = 0xF;
  if ( v32 )
    return sub_1403A6820((__int64)Src, (unsigned __int64)v32, ((char *)v39 - v32) & 0xFFFFFFFFFFFFFFF8uLL);
  return result;
}

// --- End Function: sub_146B2DA00 (0x146B2DCC0) ---

// --- Function: sub_146B30150 (0x146B30150) ---
__int64 __fastcall sub_146B30150(__int64 a1)
{
  return sub_146B29BE0(*(unsigned int **)(a1 + 0x10));
}

// --- End Function: sub_146B30150 (0x146B30150) ---

// --- Function: sub_146B30240 (0x146B30240) ---
__int64 __fastcall sub_146B30240(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  return sub_146B2DA00(*(_QWORD *)(a1 + 0x10), a2, a3);
}

// --- End Function: sub_146B30240 (0x146B30240) ---

// --- Function: sub_146B30260 (0x146B30260) ---
__int64 __fastcall sub_146B30260(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int n9; // eax
  int n0x242; // ecx
  __int64 result; // rax
  __int64 v5; // r9
  __int64 v6; // r8

  v1 = *(_QWORD *)(a1 + 0x10);
  *(_BYTE *)(*(_QWORD *)(v1 + 0x10) + 1LL) = 0;
  n9 = *(_DWORD *)(v1 + 8);
  if ( n9 <= 9 )
  {
    n0x242 = 0x242;
    if ( _bittest(&n0x242, n9) )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xD8LL))(qword_149C8DF28);
  }
  sub_146B48EE0(*(_QWORD *)v1, *(unsigned int *)(v1 + 8));
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x18LL))(qword_149C8E038);
  v5 = (int)result;
  if ( (_DWORD)result )
  {
    v6 = 0;
    do
    {
      v6 += 0x40;
      *(_DWORD *)(*(_QWORD *)v1 + 0x17405CLL) += *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 0x174070LL) + v6 - 0x40);
      result = *(_QWORD *)(*(_QWORD *)v1 + 0x174070LL);
      *(_DWORD *)(*(_QWORD *)v1 + 0x174060LL) += *(_DWORD *)(result + v6 - 0x3C);
      --v5;
    }
    while ( v5 );
  }
  return result;
}

// --- End Function: sub_146B30260 (0x146B30260) ---

// --- Function: sub_146B30310 (0x146B30310) ---
__int64 __fastcall sub_146B30310(__int64 a1)
{
  return *(_QWORD *)(**(_QWORD **)(a1 + 0x10) + 0x50LL * *(int *)(*(_QWORD *)(a1 + 0x10) + 8LL) + 0x174A40) >> 5;
}

// --- End Function: sub_146B30310 (0x146B30310) ---

// --- Function: sub_146B30330 (0x146B30330) ---
__int64 __fastcall sub_146B30330(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 result; // rax
  __m256 v7; // [rsp+20h] [rbp-48h] BYREF
  __m256 v8; // [rsp+40h] [rbp-28h]

  v2 = *(_QWORD *)(a1 + 0x10);
  v3 = *(_QWORD *)(*(_QWORD *)v2 + 0x50LL * *(int *)(v2 + 0x10) + 0x174A20) + 0x20 * a2;
  v4 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v5 = *(_QWORD *)(v2 + 8);
  *(_DWORD *)(v4 + 0x920) = 0x10;
  v7 = *(__m256 *)(v5 + 0x3B0);
  v8 = *(__m256 *)(v5 + 0x3D0);
  v7.m256_f32[5] = *(float *)(v3 + 0x18);
  __asm { vzeroupper }
  result = (*(__int64 (__fastcall **)(_QWORD, __m256 *))(v3 + 8))(*(_QWORD *)v3, &v7);
  *(_DWORD *)(v4 + 0x920) = 0xF;
  return result;
}

// --- End Function: sub_146B30330 (0x146B30330) ---

// --- Function: sub_146B303D0 (0x146B303D0) ---
void __fastcall sub_146B303D0(__int64 a1)
{
  sub_1403D37D0(
    **(_QWORD **)(a1 + 0x10) + 0x174A20LL + 0x50LL * *(int *)(*(_QWORD *)(a1 + 0x10) + 8LL),
    0xFFFFFFFFFFFFFFFFuLL);
}

// --- End Function: sub_146B303D0 (0x146B303D0) ---

// --- Function: sub_146B309F0 (0x146B309F0) ---
void __fastcall sub_146B309F0(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        v6 = sub_1402A65A0(0x18u);
        v7 = v6;
        if ( v6 )
        {
          *(_OWORD *)v6 = *(_OWORD *)v5;
          *(double *)(v6 + 0x10) = *((double *)v5 + 2);
        }
        else
        {
          v7 = 0;
        }
        a2[2] = (__int64 (__fastcall *)(__int64))v7;
        *a2 = sub_146B30150;
        a2[1] = (__int64 (__fastcall *)(__int64))sub_146B309F0;
      }
    }
  }
}

// --- End Function: sub_146B309F0 (0x146B309F0) ---

// --- Function: sub_146B30F90 (0x146B30F90) ---
void __fastcall sub_146B30F90(
        int a1,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2, unsigned __int8 a3),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2, unsigned __int8 a3))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64, __int64, unsigned __int8); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64, unsigned __int8))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64, unsigned __int8))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64, unsigned __int8))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64, unsigned __int8))1;
      }
      else
      {
        v6 = sub_1402A65A0(0x18u);
        v7 = v6;
        if ( v6 )
        {
          *(_OWORD *)v6 = *(_OWORD *)v5;
          *(double *)(v6 + 0x10) = *((double *)v5 + 2);
        }
        else
        {
          v7 = 0;
        }
        a2[2] = (__int64 (__fastcall *)(__int64, __int64, unsigned __int8))v7;
        *a2 = sub_146B30240;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64, unsigned __int8))sub_146B30F90;
      }
    }
  }
}

// --- End Function: sub_146B30F90 (0x146B30F90) ---

// --- Function: sub_146B31200 (0x146B31200) ---
void __fastcall sub_146B31200(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        v6 = sub_1402A65A0(0x18u);
        v7 = v6;
        if ( v6 )
        {
          *(_OWORD *)v6 = *(_OWORD *)v5;
          *(double *)(v6 + 0x10) = *((double *)v5 + 2);
        }
        else
        {
          v7 = 0;
        }
        a2[2] = (__int64 (__fastcall *)(__int64))v7;
        *a2 = sub_146B30260;
        a2[1] = (__int64 (__fastcall *)(__int64))sub_146B31200;
      }
    }
  }
}

// --- End Function: sub_146B31200 (0x146B31200) ---

// --- Function: sub_146B31440 (0x146B31440) ---
void __fastcall sub_146B31440(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64); // rdi
  __int64 (__fastcall *v6)(__int64); // rax
  __int64 (__fastcall *v7)(__int64); // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        v6 = (__int64 (__fastcall *)(__int64))sub_1402A65A0(0x10u);
        v7 = v6;
        if ( v6 )
          *(_OWORD *)v6 = *(_OWORD *)v5;
        else
          v7 = 0;
        a2[2] = v7;
        *a2 = sub_146B30310;
        a2[1] = (__int64 (__fastcall *)(__int64))sub_146B31440;
      }
    }
  }
}

// --- End Function: sub_146B31440 (0x146B31440) ---

// --- Function: sub_146B31560 (0x146B31560) ---
void __fastcall sub_146B31560(
        int a1,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64, __int64); // rdi
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v6 = sub_1402A65A0(0x18u);
        v7 = v6;
        if ( v6 )
        {
          *(_OWORD *)v6 = *(_OWORD *)v5;
          *(double *)(v6 + 0x10) = *((double *)v5 + 2);
        }
        else
        {
          v7 = 0;
        }
        a2[2] = (__int64 (__fastcall *)(__int64, __int64))v7;
        *a2 = sub_146B30330;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))sub_146B31560;
      }
    }
  }
}

// --- End Function: sub_146B31560 (0x146B31560) ---

// --- Function: sub_146B31680 (0x146B31680) ---
void __fastcall sub_146B31680(int a1, void (__fastcall **a2)(__int64 a1), void (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  void (__fastcall *v5)(__int64); // rdi
  void (__fastcall *v6)(__int64); // rax
  void (__fastcall *v7)(__int64); // rcx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64))1;
      }
      else
      {
        v6 = (void (__fastcall *)(__int64))sub_1402A65A0(0x10u);
        v7 = v6;
        if ( v6 )
          *(_OWORD *)v6 = *(_OWORD *)v5;
        else
          v7 = 0;
        a2[2] = v7;
        *a2 = sub_146B303D0;
        a2[1] = (void (__fastcall *)(__int64))sub_146B31680;
      }
    }
  }
}

// --- End Function: sub_146B31680 (0x146B31680) ---

// --- Function: sub_146B317A0 (0x146B317A0) ---
void __fastcall sub_146B317A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6, _DWORD *a7)
{
  bool v11; // al
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  int v24; // r8d
  char v25; // cl
  _QWORD *v26; // rdx
  _BYTE v27[2]; // [rsp+30h] [rbp-58h] BYREF
  __int16 v28; // [rsp+32h] [rbp-56h]
  int v29; // [rsp+34h] [rbp-54h]
  __int64 v30; // [rsp+38h] [rbp-50h]
  unsigned __int64 v31; // [rsp+40h] [rbp-48h]
  unsigned __int64 v32; // [rsp+48h] [rbp-40h]
  __int64 v33; // [rsp+50h] [rbp-38h]
  __int64 v34; // [rsp+58h] [rbp-30h]

  switch ( *(_BYTE *)(a5 + 0x20) )
  {
    case 0:
      goto LABEL_7;
    case 1:
      v11 = sub_14041CEA0(a3);
      break;
    case 2:
      v11 = !sub_14041CEA0(a3);
      break;
    default:
      return;
  }
  if ( v11 )
  {
LABEL_7:
    if ( (*(_WORD *)(a1 + 0x174058) & *(_WORD *)(a5 + 0x22)) != 0 )
    {
      if ( (unsigned __int8)sub_146B436F0(*(unsigned int *)(a4 + 0xC)) )
      {
LABEL_63:
        v23 = *(unsigned __int16 *)(a2 + 0x10);
        v24 = *(_DWORD *)(a3 + 0x2D8);
        if ( (_WORD)v23 == 0xFFFF )
          v25 = 0;
        else
          v25 = *(_BYTE *)(0x2E0 * v23 + a1 + 0x4062);
        v28 = 0;
        v30 = 0;
        v32 = 0;
        v33 = 0;
        v34 = 0;
        v29 = v24;
        v27[1] = v25;
        v31 = __rdtsc();
        v27[0] = 0;
        qword_149C89AA0(
          v27,
          &word_1516F05B8,
          "CEntityComponentUpdateScheduler::CallComponentEventHandler",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
          0x9C3);
        v28 = word_1516F05B8;
        sub_1404D8EF0((_OWORD *)(a4 + 0x10));
        v26 = (_QWORD *)(a4 + 0xC0);
        if ( *(_WORD *)(a4 + 8) )
          v26 = (_QWORD *)*v26;
        (*(void (__fastcall **)(__int64, _QWORD *))a5)(a2, v26);
        sub_1404D5120();
        v32 = __rdtsc();
        qword_149C89AA8(v27);
        ++*a7;
      }
      else
      {
        switch ( *(_WORD *)(a5 + 0x10) )
        {
          case 0:
            return;
          case 1:
            goto LABEL_63;
          case 2:
            v12 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v12, a6) )
              goto LABEL_63;
            break;
          case 3:
            if ( (unsigned __int8)sub_146B420E0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 4:
            if ( (unsigned __int8)sub_146B41DE0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 5:
            v13 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v13, a6) && (unsigned __int8)sub_146B420E0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 6:
            v14 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v14, a6) && (unsigned __int8)sub_146B41DE0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 7:
            if ( (unsigned __int8)sub_146B434B0(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 8:
            if ( (unsigned __int8)sub_146B43270(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 9:
            v15 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v15, a6) && (unsigned __int8)sub_146B434B0(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xA:
            v16 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v16, a6) && (unsigned __int8)sub_146B43270(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xB:
            if ( (unsigned __int8)sub_146B42BC0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xC:
            v17 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v17, a6) && (unsigned __int8)sub_146B42BC0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xD:
            if ( (unsigned __int8)sub_146B42250(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xE:
            if ( (unsigned __int8)sub_146B41F50(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xF:
            v18 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v18, a6) && (unsigned __int8)sub_146B42250(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x10:
            v19 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v19, a6) && (unsigned __int8)sub_146B41F50(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x11:
            if ( (unsigned __int8)sub_146B43590(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x12:
            if ( (unsigned __int8)sub_146B43350(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x13:
            v20 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v20, a6) && (unsigned __int8)sub_146B43590(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x14:
            v21 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v21, a6) && (unsigned __int8)sub_146B43350(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x15:
            if ( (unsigned __int8)sub_146B42CB0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x16:
            v22 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v22, a6) && (unsigned __int8)sub_146B42CB0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          default:
            __debugbreak();
            goto LABEL_63;
        }
      }
    }
  }
}

// --- End Function: sub_146B317A0 (0x146B317A0) ---

// --- Function: sub_146B317A0 (0x146B31C46) ---
void __fastcall sub_146B317A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6, _DWORD *a7)
{
  bool v11; // al
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  int v24; // r8d
  char v25; // cl
  _QWORD *v26; // rdx
  _BYTE v27[2]; // [rsp+30h] [rbp-58h] BYREF
  __int16 v28; // [rsp+32h] [rbp-56h]
  int v29; // [rsp+34h] [rbp-54h]
  __int64 v30; // [rsp+38h] [rbp-50h]
  unsigned __int64 v31; // [rsp+40h] [rbp-48h]
  unsigned __int64 v32; // [rsp+48h] [rbp-40h]
  __int64 v33; // [rsp+50h] [rbp-38h]
  __int64 v34; // [rsp+58h] [rbp-30h]

  switch ( *(_BYTE *)(a5 + 0x20) )
  {
    case 0:
      goto LABEL_7;
    case 1:
      v11 = sub_14041CEA0(a3);
      break;
    case 2:
      v11 = !sub_14041CEA0(a3);
      break;
    default:
      return;
  }
  if ( v11 )
  {
LABEL_7:
    if ( (*(_WORD *)(a1 + 0x174058) & *(_WORD *)(a5 + 0x22)) != 0 )
    {
      if ( (unsigned __int8)sub_146B436F0(*(unsigned int *)(a4 + 0xC)) )
      {
LABEL_63:
        v23 = *(unsigned __int16 *)(a2 + 0x10);
        v24 = *(_DWORD *)(a3 + 0x2D8);
        if ( (_WORD)v23 == 0xFFFF )
          v25 = 0;
        else
          v25 = *(_BYTE *)(0x2E0 * v23 + a1 + 0x4062);
        v28 = 0;
        v30 = 0;
        v32 = 0;
        v33 = 0;
        v34 = 0;
        v29 = v24;
        v27[1] = v25;
        v31 = __rdtsc();
        v27[0] = 0;
        qword_149C89AA0(
          v27,
          &word_1516F05B8,
          "CEntityComponentUpdateScheduler::CallComponentEventHandler",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
          0x9C3);
        v28 = word_1516F05B8;
        sub_1404D8EF0((_OWORD *)(a4 + 0x10));
        v26 = (_QWORD *)(a4 + 0xC0);
        if ( *(_WORD *)(a4 + 8) )
          v26 = (_QWORD *)*v26;
        (*(void (__fastcall **)(__int64, _QWORD *))a5)(a2, v26);
        sub_1404D5120();
        v32 = __rdtsc();
        qword_149C89AA8(v27);
        ++*a7;
      }
      else
      {
        switch ( *(_WORD *)(a5 + 0x10) )
        {
          case 0:
            return;
          case 1:
            goto LABEL_63;
          case 2:
            v12 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v12, a6) )
              goto LABEL_63;
            break;
          case 3:
            if ( (unsigned __int8)sub_146B420E0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 4:
            if ( (unsigned __int8)sub_146B41DE0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 5:
            v13 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v13, a6) && (unsigned __int8)sub_146B420E0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 6:
            v14 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v14, a6) && (unsigned __int8)sub_146B41DE0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 7:
            if ( (unsigned __int8)sub_146B434B0(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 8:
            if ( (unsigned __int8)sub_146B43270(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 9:
            v15 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v15, a6) && (unsigned __int8)sub_146B434B0(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xA:
            v16 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v16, a6) && (unsigned __int8)sub_146B43270(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xB:
            if ( (unsigned __int8)sub_146B42BC0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xC:
            v17 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v17, a6) && (unsigned __int8)sub_146B42BC0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xD:
            if ( (unsigned __int8)sub_146B42250(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xE:
            if ( (unsigned __int8)sub_146B41F50(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0xF:
            v18 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v18, a6) && (unsigned __int8)sub_146B42250(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x10:
            v19 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v19, a6) && (unsigned __int8)sub_146B41F50(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x11:
            if ( (unsigned __int8)sub_146B43590(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x12:
            if ( (unsigned __int8)sub_146B43350(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x13:
            v20 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v20, a6) && (unsigned __int8)sub_146B43590(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x14:
            v21 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v21, a6) && (unsigned __int8)sub_146B43350(a1, a3, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x15:
            if ( (unsigned __int8)sub_146B42CB0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          case 0x16:
            v22 = *(_QWORD *)(a2 + 0x58);
            if ( _bittest64(&v22, a6) && (unsigned __int8)sub_146B42CB0(a1, a3, a2, *(unsigned __int8 *)(a5 + 0x12)) )
              goto LABEL_63;
            break;
          default:
            __debugbreak();
            goto LABEL_63;
        }
      }
    }
  }
}

// --- End Function: sub_146B317A0 (0x146B31C46) ---

// --- Function: sub_146B32F30 (0x146B32F30) ---
__int64 __fastcall sub_146B32F30(__int64 a1, _BYTE *a2, int a3)
{
  __int64 *v3; // rbx
  _BYTE v5[2]; // [rsp+30h] [rbp-58h] BYREF
  __int16 v6; // [rsp+32h] [rbp-56h]
  __int64 v7; // [rsp+34h] [rbp-54h]
  int v8; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v9; // [rsp+40h] [rbp-48h]
  unsigned __int64 v10; // [rsp+48h] [rbp-40h]
  __int64 v11; // [rsp+50h] [rbp-38h]
  __int64 v12; // [rsp+58h] [rbp-30h]
  int v13; // [rsp+A0h] [rbp+18h] BYREF

  v13 = a3;
  v3 = (__int64 *)(a2 + 8);
  v6 = 0;
  v7 = 1;
  v8 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v9 = __rdtsc();
  v5[1] = *a2;
  v5[0] = 0;
  qword_149C89AA0(
    v5,
    &word_1516F0788,
    "Resolve Teleport",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\Streaming/EntityTeleportManager.cpp",
    0x45);
  v6 = word_1516F0788;
  sub_1423A3F10(v3, v3 + 2, &v13);
  v10 = __rdtsc();
  return qword_149C89AA8(v5);
}

// --- End Function: sub_146B32F30 (0x146B32F30) ---

// --- Function: sub_146B39A80 (0x146B39A80) ---
__int64 *__fastcall sub_146B39A80(
        __int64 a1,
        __int64 *a2,
        __m128i *a3,
        unsigned __int16 a4,
        unsigned __int8 a5,
        char a6)
{
  __int64 v8; // r9
  int epi32; // ecx
  __int64 v10; // rdx
  __m128i v11; // rt0
  __int64 v12; // rsi
  __int64 *result; // rax
  __m128i v14; // [rsp+20h] [rbp-58h]
  __m128i v15; // [rsp+30h] [rbp-48h]

  _InterlockedIncrement((volatile signed __int32 *)(a1 + 0x80024));
  v8 = 2LL * a4;
  while ( 1 )
  {
    epi32 = _mm_extract_epi32(*a3, 2);
    v14 = *a3;
    v14.m128i_i32[2] = epi32 & 0x9FFFFFFF ^ (epi32 & 0x9FFFFFFF ^ ((epi32 & 0x9FFFFFFF) + 1)) & 0x1FFFFFFF;
    v11.m128i_i64[0] = a3->m128i_i64[0];
    v11.m128i_i64[1] = _mm_extract_epi64(*a3, 1);
    _InterlockedCompareExchange128((volatile signed __int64 *)(a1 + 8 * v8 + 0x10), v14.m128i_i64[1], 0, v11.m128i_i64);
    v10 = v11.m128i_i64[1];
    v12 = a3->m128i_i64[0];
    v15 = v11;
    if ( v11.m128i_i64[0] == a3->m128i_i64[0] && v10 == a3->m128i_i64[1] )
      break;
    *a3 = v15;
  }
  if ( (a3->m128i_i32[2] & 0x40000000) != 0 )
    qword_149C78FD8(a1 + 8 * v8 + 0x18);
  result = a2;
  if ( a6 )
    *(_WORD *)(*(_QWORD *)(a1 + 0x80030) + 2LL * a5) = 0xFFFF;
  *a2 = v12;
  return result;
}

// --- End Function: sub_146B39A80 (0x146B39A80) ---

// --- Function: sub_146B3CB00 (0x146B3CB00) ---
const ULONG_PTR *__fastcall sub_146B3CB00(__int64 a1, unsigned __int16 a2)
{
  if ( a2 == 0xFFFF )
    return &p_Src;
  else
    return *(const ULONG_PTR **)(*(_QWORD *)(a1 + 0x38) + 8LL * a2);
}

// --- End Function: sub_146B3CB00 (0x146B3CB00) ---

// --- Function: sub_146B41DE0 (0x146B41DE0) ---
bool __fastcall sub_146B41DE0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  bool v11; // bl
  __int64 v12; // rax
  unsigned int v13; // edx
  __int64 v14; // rcx
  bool v15; // zf

  v4 = a4;
  if ( a3 )
  {
    if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149C026BC;
    }
    else
    {
      v9 = _InterlockedIncrement64(&rw_lock_state);
      if ( (v9 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(
          (__int64)&rw_lock_state,
          v9,
          "CEntityComponentUpdateScheduler::IsAggregateCompleteBoundsInRange",
          "CEntity::s_aggregateHierarchyLock",
          1);
    }
    v10 = (_QWORD *)sub_14234CA40(a2);
    if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
    {
      v11 = 0;
    }
    else
    {
      v12 = sub_146C53B40(qword_1516F1F98, v10);
      v13 = *(_DWORD *)(v12 + 0x8C);
      if ( v13 == 0xFFFFFFFF )
      {
LABEL_14:
        v15 = *(_BYTE *)(v4 + v12 + 0x74) == 0;
      }
      else
      {
        while ( 1 )
        {
          v14 = *(_QWORD *)(qword_1516F1F98 + 0x180) + 0x20LL * v13;
          if ( *(_QWORD *)v14 == a3 )
            break;
          v13 = *(_DWORD *)(v14 + 0x18);
          if ( v13 == 0xFFFFFFFF )
            goto LABEL_14;
        }
        v15 = *(_BYTE *)(v4 + v14 + 0xC) == 0;
      }
      v11 = !v15;
    }
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return v11;
  }
  else
  {
    v7 = (_QWORD *)sub_14234CA40(a2);
    return *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
        && *(_BYTE *)(v4 + sub_146C53B40(qword_1516F1F98, v7) + 0x74) != 0;
  }
}

// --- End Function: sub_146B41DE0 (0x146B41DE0) ---

// --- Function: sub_146B41F50 (0x146B41F50) ---
bool __fastcall sub_146B41F50(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  __int64 v11; // rax
  unsigned int v12; // edx
  __int64 v13; // rcx
  bool v14; // zf
  bool v15; // bl

  v5 = a4;
  if ( BYTE1(qword_149C8E516) )
    return 0;
  if ( !a3 )
  {
    v7 = (_QWORD *)sub_14234CA40(a2);
    if ( *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF )
      return *(_BYTE *)(v5 + sub_146C53B40(qword_1516F1F98, v7) + 0x7C) != 0;
    return 0;
  }
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v9 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v9 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v9,
        "CEntityComponentUpdateScheduler::IsAggregateCompleteBoundsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v10 = (_QWORD *)sub_14234CA40(a2);
  if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return 0;
  }
  else
  {
    v11 = sub_146C53B40(qword_1516F1F98, v10);
    v12 = *(_DWORD *)(v11 + 0x90);
    if ( v12 == 0xFFFFFFFF )
    {
LABEL_14:
      v14 = *(_BYTE *)(v5 + v11 + 0x7C) == 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = *(_QWORD *)(qword_1516F1F98 + 0x1E0) + 0x18LL * v12;
        if ( *(_QWORD *)v13 == a3 )
          break;
        v12 = *(_DWORD *)(v13 + 0x10);
        if ( v12 == 0xFFFFFFFF )
          goto LABEL_14;
      }
      v14 = *(_BYTE *)(v5 + v13 + 0xC) == 0;
    }
    v15 = !v14;
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return v15;
  }
}

// --- End Function: sub_146B41F50 (0x146B41F50) ---

// --- Function: sub_146B420E0 (0x146B420E0) ---
bool __fastcall sub_146B420E0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  bool v11; // bl
  __int64 v12; // rax
  unsigned int v13; // edx
  __int64 v14; // rcx
  bool v15; // zf

  v4 = a4;
  if ( a3 )
  {
    if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149C026BC;
    }
    else
    {
      v9 = _InterlockedIncrement64(&rw_lock_state);
      if ( (v9 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(
          (__int64)&rw_lock_state,
          v9,
          "CEntityComponentUpdateScheduler::IsAggregateRenderingBoundsInRange",
          "CEntity::s_aggregateHierarchyLock",
          1);
    }
    v10 = (_QWORD *)sub_14234CA40(a2);
    if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
    {
      v11 = 0;
    }
    else
    {
      v12 = sub_146C53B40(qword_1516F1F98, v10);
      v13 = *(_DWORD *)(v12 + 0x8C);
      if ( v13 == 0xFFFFFFFF )
      {
LABEL_14:
        v15 = *(_BYTE *)(v4 + v12 + 0x70) == 0;
      }
      else
      {
        while ( 1 )
        {
          v14 = *(_QWORD *)(qword_1516F1F98 + 0x180) + 0x20LL * v13;
          if ( *(_QWORD *)v14 == a3 )
            break;
          v13 = *(_DWORD *)(v14 + 0x18);
          if ( v13 == 0xFFFFFFFF )
            goto LABEL_14;
        }
        v15 = *(_BYTE *)(v4 + v14 + 8) == 0;
      }
      v11 = !v15;
    }
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return v11;
  }
  else
  {
    v7 = (_QWORD *)sub_14234CA40(a2);
    return *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
        && *(_BYTE *)(v4 + sub_146C53B40(qword_1516F1F98, v7) + 0x70) != 0;
  }
}

// --- End Function: sub_146B420E0 (0x146B420E0) ---

// --- Function: sub_146B42250 (0x146B42250) ---
bool __fastcall sub_146B42250(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  __int64 v11; // rax
  unsigned int v12; // edx
  __int64 v13; // rcx
  bool v14; // zf
  bool v15; // bl

  v5 = a4;
  if ( BYTE1(qword_149C8E516) )
    return 0;
  if ( !a3 )
  {
    v7 = (_QWORD *)sub_14234CA40(a2);
    if ( *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF )
      return *(_BYTE *)(v5 + sub_146C53B40(qword_1516F1F98, v7) + 0x78) != 0;
    return 0;
  }
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v9 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v9 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v9,
        "CEntityComponentUpdateScheduler::IsAggregateRenderingBoundsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v10 = (_QWORD *)sub_14234CA40(a2);
  if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return 0;
  }
  else
  {
    v11 = sub_146C53B40(qword_1516F1F98, v10);
    v12 = *(_DWORD *)(v11 + 0x90);
    if ( v12 == 0xFFFFFFFF )
    {
LABEL_14:
      v14 = *(_BYTE *)(v5 + v11 + 0x78) == 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = *(_QWORD *)(qword_1516F1F98 + 0x1E0) + 0x18LL * v12;
        if ( *(_QWORD *)v13 == a3 )
          break;
        v12 = *(_DWORD *)(v13 + 0x10);
        if ( v12 == 0xFFFFFFFF )
          goto LABEL_14;
      }
      v14 = *(_BYTE *)(v5 + v13 + 8) == 0;
    }
    v15 = !v14;
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return v15;
  }
}

// --- End Function: sub_146B42250 (0x146B42250) ---

// --- Function: sub_146B42BC0 (0x146B42BC0) ---
bool __fastcall sub_146B42BC0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  signed __int64 v8; // rdx
  _QWORD *v9; // rax
  bool v10; // bl

  v5 = a4;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v8 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v8 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v8,
        "CEntityComponentUpdateScheduler::IsComponentInRange",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v9 = (_QWORD *)sub_14234CA40(a2);
  v10 = *(_DWORD *)((*v9 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
     && *(_BYTE *)(v5 + 0x20LL * *(unsigned __int16 *)(a3 + 0x62) + *(_QWORD *)sub_146C53B40(qword_1516F1F98, v9) + 0xC) != 0;
  rw_lock_release_read_lock((__int64)&rw_lock_state);
  return v10;
}

// --- End Function: sub_146B42BC0 (0x146B42BC0) ---

// --- Function: sub_146B42CB0 (0x146B42CB0) ---
bool __fastcall sub_146B42CB0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  signed __int64 v8; // rdx
  _QWORD *v9; // rax
  bool v10; // bl

  v5 = a4;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v8 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v8 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v8,
        "CEntityComponentUpdateScheduler::IsComponentIsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v9 = (_QWORD *)sub_14234CA40(a2);
  v10 = *(_DWORD *)((*v9 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
     && *(_BYTE *)(v5 + 0x20LL * *(unsigned __int16 *)(a3 + 0x62) + *(_QWORD *)sub_146C53B40(qword_1516F1F98, v9) + 0x10) != 0;
  rw_lock_release_read_lock((__int64)&rw_lock_state);
  return v10;
}

// --- End Function: sub_146B42CB0 (0x146B42CB0) ---

// --- Function: sub_146B42DF0 (0x146B42DF0) ---
bool __fastcall sub_146B42DF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v8; // rdi
  _BYTE *v9; // rbx
  bool v10; // al
  char v12; // al
  char v13; // al

  if ( !a2 )
    return 0;
  if ( *(_BYTE *)(a2 + 0xD) >= 5u )
    return 0;
  v8 = *(_QWORD *)(a4 + 0xF8) + 0x20LL * a5;
  v9 = (_BYTE *)(*(_QWORD *)(a3 + 0x18) + 0xCLL * a5);
  if ( v9[3] )
    return 0;
  if ( *(_BYTE *)(v8 + 0x11) )
  {
    if ( *(_BYTE *)(v8 + 0x11) == 1 )
    {
      v10 = sub_14041CEA0(a2);
    }
    else
    {
      if ( *(_BYTE *)(v8 + 0x11) != 2 )
        return 0;
      v10 = !sub_14041CEA0(a2);
    }
    if ( v10 )
      goto LABEL_10;
    return 0;
  }
LABEL_10:
  if ( !v9[4] )
  {
    switch ( *(_WORD *)(v8 + 8) )
    {
      case 0:
        return 0;
      case 1:
        return 1;
      case 2:
        return *v9 != 0;
      case 3:
        if ( v9[2] )
          return 1;
        v12 = sub_146B420E0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v12 != 0;
      case 4:
        if ( v9[2] )
          return 1;
        v12 = sub_146B41DE0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v12 != 0;
      case 5:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B420E0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v13 != 0;
      case 6:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B41DE0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v13 != 0;
      case 7:
        if ( v9[2] )
          return 1;
        v12 = sub_146B434B0(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v12 != 0;
      case 8:
        if ( v9[2] )
          return 1;
        v12 = sub_146B43270(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v12 != 0;
      case 9:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B434B0(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v13 != 0;
      case 0xA:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B43270(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v13 != 0;
      case 0xB:
        if ( v9[2] )
          return 1;
        v12 = sub_146B42BC0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v12 != 0;
      case 0xC:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B42BC0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v13 != 0;
      case 0xD:
        if ( v9[2] )
          return 1;
        v12 = sub_146B42250(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v12 != 0;
      case 0xE:
        if ( v9[2] )
          return 1;
        v12 = sub_146B41F50(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v12 != 0;
      case 0xF:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B42250(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v13 != 0;
      case 0x10:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B41F50(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v13 != 0;
      case 0x11:
        if ( v9[2] )
          return 1;
        v12 = sub_146B43590(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v12 != 0;
      case 0x12:
        if ( v9[2] )
          return 1;
        v12 = sub_146B43350(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v12 != 0;
      case 0x13:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B43590(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v13 != 0;
      case 0x14:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B43350(a1, a2, *(unsigned __int8 *)(v8 + 0xA));
        return v13 != 0;
      case 0x15:
        if ( v9[2] )
          return 1;
        v12 = sub_146B42CB0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v12 != 0;
      case 0x16:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        v13 = sub_146B42CB0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
        return v13 != 0;
      default:
        __debugbreak();
        return 0;
    }
  }
  return 1;
}

// --- End Function: sub_146B42DF0 (0x146B42DF0) ---

// --- Function: sub_146B43270 (0x146B43270) ---
bool __fastcall sub_146B43270(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v6; // rdx
  _QWORD *v7; // rax
  bool v8; // bl

  v4 = a3;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v6 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v6 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v6,
        "CEntityComponentUpdateScheduler::IsEntityCompleteBoundsInRange",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v7 = (_QWORD *)sub_14234CA40(a2);
  v8 = *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
    && *(_BYTE *)(*(_QWORD *)(sub_146C53B40(qword_1516F1F98, v7) + 8)
                + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                + v4
                + 0x1C) != 0;
  rw_lock_release_read_lock((__int64)&rw_lock_state);
  return v8;
}

// --- End Function: sub_146B43270 (0x146B43270) ---

// --- Function: sub_146B43350 (0x146B43350) ---
bool __fastcall sub_146B43350(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v5; // rdx
  _QWORD *v6; // rax
  bool v8; // bl

  v4 = a3;
  if ( BYTE1(qword_149C8E516) || (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v5 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v5 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v5,
        "CEntityComponentUpdateScheduler::IsEntityCompleteBoundsIsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v6 = (_QWORD *)sub_14234CA40(a2);
  if ( *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return 0;
  }
  else
  {
    v8 = *(_BYTE *)(*(_QWORD *)(sub_146C53B40(qword_1516F1F98, v6) + 8)
                  + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                  + v4
                  + 0x24) != 0;
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return v8;
  }
}

// --- End Function: sub_146B43350 (0x146B43350) ---

// --- Function: sub_146B434B0 (0x146B434B0) ---
bool __fastcall sub_146B434B0(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v6; // rdx
  _QWORD *v7; // rax
  bool v8; // bl

  v4 = a3;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v6 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v6 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v6,
        "CEntityComponentUpdateScheduler::IsEntityRenderingBoundsInRange",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v7 = (_QWORD *)sub_14234CA40(a2);
  v8 = *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
    && *(_BYTE *)(*(_QWORD *)(sub_146C53B40(qword_1516F1F98, v7) + 8)
                + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                + v4
                + 0x18) != 0;
  rw_lock_release_read_lock((__int64)&rw_lock_state);
  return v8;
}

// --- End Function: sub_146B434B0 (0x146B434B0) ---

// --- Function: sub_146B43590 (0x146B43590) ---
bool __fastcall sub_146B43590(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v5; // rdx
  _QWORD *v6; // rax
  bool v8; // bl

  v4 = a3;
  if ( BYTE1(qword_149C8E516) || (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149C026BC;
  }
  else
  {
    v5 = _InterlockedIncrement64(&rw_lock_state);
    if ( (v5 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)&rw_lock_state,
        v5,
        "CEntityComponentUpdateScheduler::IsEntityRenderingBoundsIsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v6 = (_QWORD *)sub_14234CA40(a2);
  if ( *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return 0;
  }
  else
  {
    v8 = *(_BYTE *)(*(_QWORD *)(sub_146C53B40(qword_1516F1F98, v6) + 8)
                  + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                  + v4
                  + 0x20) != 0;
    rw_lock_release_read_lock((__int64)&rw_lock_state);
    return v8;
  }
}

// --- End Function: sub_146B43590 (0x146B43590) ---

// --- Function: sub_146B436F0 (0x146B436F0) ---
bool __fastcall sub_146B436F0(int event_key_from_source_location_1)
{
  int event_key_from_source_location; // eax
  int event_key_from_source_location_2; // eax
  int event_key_from_source_location_3; // eax
  int event_key_from_source_location_4; // eax
  int event_key_from_source_location_5; // eax
  int event_key_from_source_location_6; // eax
  int event_key_from_source_location_7; // eax
  int event_key_from_source_location_8; // eax
  int event_key_from_source_location_9; // eax
  int event_key_from_source_location_10; // eax
  int event_key_from_source_location_11; // eax
  int event_key_from_source_location_12; // eax
  int event_key_from_source_location_13; // eax
  int event_key_from_source_location_14; // eax
  int event_key_from_source_location_15; // eax
  int event_key_from_source_location_16; // eax
  int event_key_from_source_location_17; // eax
  int event_key_from_source_location_18; // eax
  int event_key_from_source_location_19; // eax
  int event_key_from_source_location_20; // eax
  int event_key_from_source_location_21; // eax
  int event_key_from_source_location_22; // eax
  int event_key_from_source_location_23; // eax
  int event_key_from_source_location_24; // eax
  int event_key_from_source_location_25; // eax
  int event_key_from_source_location_26; // eax
  int event_key_from_source_location_27; // eax
  int event_key_from_source_location_28; // eax
  int event_key_from_source_location_29; // eax
  int event_key_from_source_location_30; // eax
  int event_key_from_source_location_31; // eax
  int event_key_from_source_location_32; // eax
  int event_key_from_source_location_33; // eax
  int event_key_from_source_location_34; // eax
  int event_key_from_source_location_35; // eax
  int event_key_from_source_location_36; // eax
  int event_key_from_source_location_37; // eax
  int event_key_from_source_location_38; // eax
  int event_key_from_source_location_39; // eax
  int event_key_from_source_location_40; // eax
  int event_key_from_source_location_41; // eax
  int event_key_from_source_location_42; // eax
  int event_key_from_source_location_43; // eax
  int event_key_from_source_location_44; // eax
  int event_key_from_source_location_45; // eax
  int event_key_from_source_location_46; // eax
  int event_key_from_source_location_47; // eax
  int event_key_from_source_location_48; // eax
  int event_key_from_source_location_49; // eax
  int event_key_from_source_location_50; // eax
  int event_key_from_source_location_51; // eax
  int event_key_from_source_location_52; // eax
  int event_key_from_source_location_53; // eax
  int event_key_from_source_location_54; // eax
  int event_key_from_source_location_55; // eax
  int event_key_from_source_location_56; // eax
  int event_key_from_source_location_57; // eax
  int event_key_from_source_location_58; // eax
  int event_key_from_source_location_59; // eax
  int event_key_from_source_location_60; // eax

  event_key_from_source_location = ::event_key_from_source_location_13;
  if ( !::event_key_from_source_location_13 )
    event_key_from_source_location = get_event_key_from_source_location(
                                       &::event_key_from_source_location_13,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                       0xA);
  if ( event_key_from_source_location_1 == event_key_from_source_location )
    return 1;
  event_key_from_source_location_2 = ::event_key_from_source_location_14;
  if ( !::event_key_from_source_location_14 )
    event_key_from_source_location_2 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_14,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x13);
  if ( event_key_from_source_location_1 == event_key_from_source_location_2 )
    return 1;
  event_key_from_source_location_3 = ::event_key_from_source_location_15;
  if ( !::event_key_from_source_location_15 )
    event_key_from_source_location_3 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_15,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x1C);
  if ( event_key_from_source_location_1 == event_key_from_source_location_3 )
    return 1;
  event_key_from_source_location_4 = ::event_key_from_source_location_16;
  if ( !::event_key_from_source_location_16 )
    event_key_from_source_location_4 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_16,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x25);
  if ( event_key_from_source_location_1 == event_key_from_source_location_4 )
    return 1;
  event_key_from_source_location_5 = ::event_key_from_source_location_17;
  if ( !::event_key_from_source_location_17 )
    event_key_from_source_location_5 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_17,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x54);
  if ( event_key_from_source_location_1 == event_key_from_source_location_5 )
    return 1;
  event_key_from_source_location_6 = ::event_key_from_source_location_18;
  if ( !::event_key_from_source_location_18 )
    event_key_from_source_location_6 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_18,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x5D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_6 )
    return 1;
  event_key_from_source_location_7 = ::event_key_from_source_location_19;
  if ( !::event_key_from_source_location_19 )
    event_key_from_source_location_7 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_19,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x66);
  if ( event_key_from_source_location_1 == event_key_from_source_location_7 )
    return 1;
  event_key_from_source_location_8 = ::event_key_from_source_location_20;
  if ( !::event_key_from_source_location_20 )
    event_key_from_source_location_8 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_20,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x6F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_8 )
    return 1;
  event_key_from_source_location_9 = ::event_key_from_source_location_21;
  if ( !::event_key_from_source_location_21 )
    event_key_from_source_location_9 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_21,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x2F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_9 )
    return 1;
  event_key_from_source_location_10 = ::event_key_from_source_location_22;
  if ( !::event_key_from_source_location_22 )
    event_key_from_source_location_10 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_22,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x38);
  if ( event_key_from_source_location_1 == event_key_from_source_location_10 )
    return 1;
  event_key_from_source_location_11 = ::event_key_from_source_location_23;
  if ( !::event_key_from_source_location_23 )
    event_key_from_source_location_11 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_23,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x41);
  if ( event_key_from_source_location_1 == event_key_from_source_location_11 )
    return 1;
  event_key_from_source_location_12 = ::event_key_from_source_location_24;
  if ( !::event_key_from_source_location_24 )
    event_key_from_source_location_12 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_24,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x4A);
  if ( event_key_from_source_location_1 == event_key_from_source_location_12 )
    return 1;
  event_key_from_source_location_13 = ::event_key_from_source_location_25;
  if ( !::event_key_from_source_location_25 )
    event_key_from_source_location_13 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_25,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x79);
  if ( event_key_from_source_location_1 == event_key_from_source_location_13 )
    return 1;
  event_key_from_source_location_14 = ::event_key_from_source_location_26;
  if ( !::event_key_from_source_location_26 )
    event_key_from_source_location_14 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_26,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x82);
  if ( event_key_from_source_location_1 == event_key_from_source_location_14 )
    return 1;
  event_key_from_source_location_15 = ::event_key_from_source_location_27;
  if ( !::event_key_from_source_location_27 )
    event_key_from_source_location_15 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_27,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x8B);
  if ( event_key_from_source_location_1 == event_key_from_source_location_15 )
    return 1;
  event_key_from_source_location_16 = ::event_key_from_source_location_28;
  if ( !::event_key_from_source_location_28 )
    event_key_from_source_location_16 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_28,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x94);
  if ( event_key_from_source_location_1 == event_key_from_source_location_16 )
    return 1;
  event_key_from_source_location_17 = ::event_key_from_source_location_29;
  if ( !::event_key_from_source_location_29 )
    event_key_from_source_location_17 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_29,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x17C);
  if ( event_key_from_source_location_1 == event_key_from_source_location_17 )
    return 1;
  event_key_from_source_location_18 = ::event_key_from_source_location_30;
  if ( !::event_key_from_source_location_30 )
    event_key_from_source_location_18 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_30,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x18D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_18 )
    return 1;
  event_key_from_source_location_19 = ::event_key_from_source_location_31;
  if ( !::event_key_from_source_location_31 )
    event_key_from_source_location_19 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_31,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1A1);
  if ( event_key_from_source_location_1 == event_key_from_source_location_19 )
    return 1;
  event_key_from_source_location_20 = ::event_key_from_source_location_32;
  if ( !::event_key_from_source_location_32 )
    event_key_from_source_location_20 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_32,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1B6);
  if ( event_key_from_source_location_1 == event_key_from_source_location_20 )
    return 1;
  event_key_from_source_location_21 = ::event_key_from_source_location_33;
  if ( !::event_key_from_source_location_33 )
    event_key_from_source_location_21 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_33,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1CD);
  if ( event_key_from_source_location_1 == event_key_from_source_location_21 )
    return 1;
  event_key_from_source_location_22 = ::event_key_from_source_location_34;
  if ( !::event_key_from_source_location_34 )
    event_key_from_source_location_22 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_34,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1DE);
  if ( event_key_from_source_location_1 == event_key_from_source_location_22 )
    return 1;
  event_key_from_source_location_23 = ::event_key_from_source_location_35;
  if ( !::event_key_from_source_location_35 )
    event_key_from_source_location_23 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_35,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1F2);
  if ( event_key_from_source_location_1 == event_key_from_source_location_23 )
    return 1;
  event_key_from_source_location_24 = ::event_key_from_source_location_36;
  if ( !::event_key_from_source_location_36 )
    event_key_from_source_location_24 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_36,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x207);
  if ( event_key_from_source_location_1 == event_key_from_source_location_24 )
    return 1;
  event_key_from_source_location_25 = ::event_key_from_source_location_37;
  if ( !::event_key_from_source_location_37 )
    event_key_from_source_location_25 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_37,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x9E);
  if ( event_key_from_source_location_1 == event_key_from_source_location_25 )
    return 1;
  event_key_from_source_location_26 = ::event_key_from_source_location_38;
  if ( !::event_key_from_source_location_38 )
    event_key_from_source_location_26 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_38,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xA7);
  if ( event_key_from_source_location_1 == event_key_from_source_location_26 )
    return 1;
  event_key_from_source_location_27 = ::event_key_from_source_location_39;
  if ( !::event_key_from_source_location_39 )
    event_key_from_source_location_27 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_39,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xB0);
  if ( event_key_from_source_location_1 == event_key_from_source_location_27 )
    return 1;
  event_key_from_source_location_28 = ::event_key_from_source_location_40;
  if ( !::event_key_from_source_location_40 )
    event_key_from_source_location_28 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_40,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xB9);
  if ( event_key_from_source_location_1 == event_key_from_source_location_28 )
    return 1;
  event_key_from_source_location_29 = ::event_key_from_source_location_41;
  if ( !::event_key_from_source_location_41 )
    event_key_from_source_location_29 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_41,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xC3);
  if ( event_key_from_source_location_1 == event_key_from_source_location_29 )
    return 1;
  event_key_from_source_location_30 = ::event_key_from_source_location_42;
  if ( !::event_key_from_source_location_42 )
    event_key_from_source_location_30 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_42,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xCC);
  if ( event_key_from_source_location_1 == event_key_from_source_location_30 )
    return 1;
  event_key_from_source_location_31 = ::event_key_from_source_location_43;
  if ( !::event_key_from_source_location_43 )
    event_key_from_source_location_31 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_43,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xD5);
  if ( event_key_from_source_location_1 == event_key_from_source_location_31 )
    return 1;
  event_key_from_source_location_32 = ::event_key_from_source_location_44;
  if ( !::event_key_from_source_location_44 )
    event_key_from_source_location_32 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_44,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xDE);
  if ( event_key_from_source_location_1 == event_key_from_source_location_32 )
    return 1;
  event_key_from_source_location_33 = ::event_key_from_source_location_45;
  if ( !::event_key_from_source_location_45 )
    event_key_from_source_location_33 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_45,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xE8);
  if ( event_key_from_source_location_1 == event_key_from_source_location_33 )
    return 1;
  event_key_from_source_location_34 = ::event_key_from_source_location_46;
  if ( !::event_key_from_source_location_46 )
    event_key_from_source_location_34 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_46,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xF1);
  if ( event_key_from_source_location_1 == event_key_from_source_location_34 )
    return 1;
  event_key_from_source_location_35 = ::event_key_from_source_location_47;
  if ( !::event_key_from_source_location_47 )
    event_key_from_source_location_35 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_47,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xFA);
  if ( event_key_from_source_location_1 == event_key_from_source_location_35 )
    return 1;
  event_key_from_source_location_36 = ::event_key_from_source_location_48;
  if ( !::event_key_from_source_location_48 )
    event_key_from_source_location_36 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_48,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x103);
  if ( event_key_from_source_location_1 == event_key_from_source_location_36 )
    return 1;
  event_key_from_source_location_37 = ::event_key_from_source_location_49;
  if ( !::event_key_from_source_location_49 )
    event_key_from_source_location_37 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_49,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x10D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_37 )
    return 1;
  event_key_from_source_location_38 = ::event_key_from_source_location_50;
  if ( !::event_key_from_source_location_50 )
    event_key_from_source_location_38 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_50,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x116);
  if ( event_key_from_source_location_1 == event_key_from_source_location_38 )
    return 1;
  event_key_from_source_location_39 = ::event_key_from_source_location_51;
  if ( !::event_key_from_source_location_51 )
    event_key_from_source_location_39 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_51,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x11F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_39 )
    return 1;
  event_key_from_source_location_40 = ::event_key_from_source_location_52;
  if ( !::event_key_from_source_location_52 )
    event_key_from_source_location_40 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_52,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x128);
  if ( event_key_from_source_location_1 == event_key_from_source_location_40 )
    return 1;
  event_key_from_source_location_41 = ::event_key_from_source_location_53;
  if ( !::event_key_from_source_location_53 )
    event_key_from_source_location_41 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_53,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x21E);
  if ( event_key_from_source_location_1 == event_key_from_source_location_41 )
    return 1;
  event_key_from_source_location_42 = ::event_key_from_source_location_54;
  if ( !::event_key_from_source_location_54 )
    event_key_from_source_location_42 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_54,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x22F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_42 )
    return 1;
  event_key_from_source_location_43 = ::event_key_from_source_location_55;
  if ( !::event_key_from_source_location_55 )
    event_key_from_source_location_43 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_55,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x243);
  if ( event_key_from_source_location_1 == event_key_from_source_location_43 )
    return 1;
  event_key_from_source_location_44 = ::event_key_from_source_location_56;
  if ( !::event_key_from_source_location_56 )
    event_key_from_source_location_44 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_56,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x258);
  if ( event_key_from_source_location_1 == event_key_from_source_location_44 )
    return 1;
  event_key_from_source_location_45 = ::event_key_from_source_location_57;
  if ( !::event_key_from_source_location_57 )
    event_key_from_source_location_45 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_57,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x26F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_45 )
    return 1;
  event_key_from_source_location_46 = ::event_key_from_source_location_58;
  if ( !::event_key_from_source_location_58 )
    event_key_from_source_location_46 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_58,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x280);
  if ( event_key_from_source_location_1 == event_key_from_source_location_46 )
    return 1;
  event_key_from_source_location_47 = ::event_key_from_source_location_59;
  if ( !::event_key_from_source_location_59 )
    event_key_from_source_location_47 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_59,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x294);
  if ( event_key_from_source_location_1 == event_key_from_source_location_47 )
    return 1;
  event_key_from_source_location_48 = ::event_key_from_source_location_60;
  if ( !::event_key_from_source_location_60 )
    event_key_from_source_location_48 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_60,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2A9);
  if ( event_key_from_source_location_1 == event_key_from_source_location_48 )
    return 1;
  event_key_from_source_location_49 = event_key_from_source_location_61;
  if ( !event_key_from_source_location_61 )
    event_key_from_source_location_49 = get_event_key_from_source_location(
                                          &event_key_from_source_location_61,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x132);
  if ( event_key_from_source_location_1 == event_key_from_source_location_49 )
    return 1;
  event_key_from_source_location_50 = event_key_from_source_location_62;
  if ( !event_key_from_source_location_62 )
    event_key_from_source_location_50 = get_event_key_from_source_location(
                                          &event_key_from_source_location_62,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x13B);
  if ( event_key_from_source_location_1 == event_key_from_source_location_50 )
    return 1;
  event_key_from_source_location_51 = event_key_from_source_location_63;
  if ( !event_key_from_source_location_63 )
    event_key_from_source_location_51 = get_event_key_from_source_location(
                                          &event_key_from_source_location_63,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x144);
  if ( event_key_from_source_location_1 == event_key_from_source_location_51 )
    return 1;
  event_key_from_source_location_52 = event_key_from_source_location_64;
  if ( !event_key_from_source_location_64 )
    event_key_from_source_location_52 = get_event_key_from_source_location(
                                          &event_key_from_source_location_64,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x14D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_52 )
    return 1;
  event_key_from_source_location_53 = event_key_from_source_location_65;
  if ( !event_key_from_source_location_65 )
    event_key_from_source_location_53 = get_event_key_from_source_location(
                                          &event_key_from_source_location_65,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x157);
  if ( event_key_from_source_location_1 == event_key_from_source_location_53 )
    return 1;
  event_key_from_source_location_54 = event_key_from_source_location_66;
  if ( !event_key_from_source_location_66 )
    event_key_from_source_location_54 = get_event_key_from_source_location(
                                          &event_key_from_source_location_66,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x160);
  if ( event_key_from_source_location_1 == event_key_from_source_location_54 )
    return 1;
  event_key_from_source_location_55 = event_key_from_source_location_67;
  if ( !event_key_from_source_location_67 )
    event_key_from_source_location_55 = get_event_key_from_source_location(
                                          &event_key_from_source_location_67,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x169);
  if ( event_key_from_source_location_1 == event_key_from_source_location_55 )
    return 1;
  event_key_from_source_location_56 = event_key_from_source_location_68;
  if ( !event_key_from_source_location_68 )
    event_key_from_source_location_56 = get_event_key_from_source_location(
                                          &event_key_from_source_location_68,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x172);
  if ( event_key_from_source_location_1 == event_key_from_source_location_56 )
    return 1;
  event_key_from_source_location_57 = event_key_from_source_location_69;
  if ( !event_key_from_source_location_69 )
    event_key_from_source_location_57 = get_event_key_from_source_location(
                                          &event_key_from_source_location_69,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2C0);
  if ( event_key_from_source_location_1 == event_key_from_source_location_57 )
    return 1;
  event_key_from_source_location_58 = event_key_from_source_location_70;
  if ( !event_key_from_source_location_70 )
    event_key_from_source_location_58 = get_event_key_from_source_location(
                                          &event_key_from_source_location_70,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2D1);
  if ( event_key_from_source_location_1 == event_key_from_source_location_58 )
    return 1;
  event_key_from_source_location_59 = event_key_from_source_location_71;
  if ( !event_key_from_source_location_71 )
    event_key_from_source_location_59 = get_event_key_from_source_location(
                                          &event_key_from_source_location_71,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2E5);
  if ( event_key_from_source_location_1 == event_key_from_source_location_59 )
    return 1;
  event_key_from_source_location_60 = event_key_from_source_location_72;
  if ( !event_key_from_source_location_72 )
    event_key_from_source_location_60 = get_event_key_from_source_location(
                                          &event_key_from_source_location_72,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2FA);
  return event_key_from_source_location_1 == event_key_from_source_location_60;
}

// --- End Function: sub_146B436F0 (0x146B436F0) ---

// --- Function: sub_146B48AE0 (0x146B48AE0) ---
__int64 *__fastcall sub_146B48AE0(__int64 a1, __int64 *a2, unsigned __int8 a3)
{
  __int64 v4; // r15
  _BYTE *v6; // r12
  unsigned __int16 v7; // di
  __int64 v8; // r13
  __m128i v9; // rt0
  __int64 v10; // rcx
  __int64 v11; // rdx
  signed __int32 v12; // eax
  unsigned __int64 v13; // rdi
  unsigned int v14; // ecx
  __int64 v15; // r11
  __m128i v16; // rt0
  __m128i v17; // xmm0
  int epi32; // r8d
  __int64 v19; // r9
  __int128 v20; // rax
  __int128 v21; // rt0
  __int32 v22; // edx
  __m128i v23; // rt0
  unsigned __int8 v25; // [rsp+20h] [rbp-E0h]
  char v26; // [rsp+28h] [rbp-D8h]
  __m128i v28; // [rsp+40h] [rbp-C0h] BYREF
  __int128 v29; // [rsp+50h] [rbp-B0h]
  __m128i v30; // [rsp+60h] [rbp-A0h]
  __int64 v31; // [rsp+70h] [rbp-90h]
  __int128 v32; // [rsp+80h] [rbp-80h]
  __int64 v33; // [rsp+90h] [rbp-70h]
  __int64 v34; // [rsp+98h] [rbp-68h]
  __int128 v35; // [rsp+A0h] [rbp-60h]
  __int64 v36; // [rsp+B0h] [rbp-50h]
  __int64 v37; // [rsp+B8h] [rbp-48h]
  __m128i v38; // [rsp+C0h] [rbp-40h]
  __int64 v39; // [rsp+D0h] [rbp-30h]
  __int64 v40; // [rsp+D8h] [rbp-28h]
  __m128i v41; // [rsp+E0h] [rbp-20h] BYREF
  __m128i v42; // [rsp+F0h] [rbp-10h]
  __m128i v43; // [rsp+100h] [rbp+0h]
  __m128i v44; // [rsp+110h] [rbp+10h]
  __int128 v45; // [rsp+120h] [rbp+20h]
  __int128 v46; // [rsp+130h] [rbp+30h]

  v4 = a3;
  v6 = (_BYTE *)(a3 + *(_QWORD *)(a1 + 0x80040));
  *(_QWORD *)&v29 = v6;
  *v6 = 1;
  if ( *(_BYTE *)(a3 + *(_QWORD *)(a1 + 0x80038)) )
  {
    *a2 = *(_QWORD *)(a1 + 0x80010);
    *v6 = 0;
    return a2;
  }
  v7 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 8), 1u) & 0x7FFF;
  v32 = 0u;
  v8 = a1 + 0x10LL * v7;
  v33 = 0;
  v34 = 0;
  v9.m128i_i64[0] = 0;
  v9.m128i_i64[1] = _mm_extract_epi64((__m128i)0LL, 1);
  _InterlockedCompareExchange128((volatile signed __int64 *)(v8 + 0x10), 0, 0, v9.m128i_i64);
  v43 = v9;
  v28 = v9;
  if ( (v9.m128i_i32[2] & 0x20000000) != 0 )
  {
    v26 = 0;
    v25 = a3;
LABEL_5:
    v41 = v28;
    sub_146B39A80(a1, a2, &v41, v7, v25, v26);
LABEL_25:
    *v6 = 0;
    return a2;
  }
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0x78LL))(qword_149C8E038) )
  {
LABEL_24:
    *a2 = *(_QWORD *)(a1 + 0x80010);
    goto LABEL_25;
  }
  v10 = *(_QWORD *)(a1 + 0x80030);
  v11 = 2 * v4;
  v31 = v11;
  *(_WORD *)(v10 + v11) = v7;
  v12 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x80028), 0xFFFFFFFF, 0);
  if ( v12 == 0xFFFFFFFF )
  {
LABEL_23:
    *(_BYTE *)(v4 + *(_QWORD *)(a1 + 0x80038)) = 1;
    goto LABEL_24;
  }
  if ( v12 )
  {
    v22 = v28.m128i_i32[2];
    if ( v28.m128i_i32[2] >= 0 )
    {
      while ( (v22 & 0x20000000) == 0 )
      {
        (*(void (__fastcall **)(__int64, __int64, __int8 *))(*(_QWORD *)qword_149C8E038 + 0x80LL))(
          qword_149C8E038,
          v8 + 0x18,
          &v28.m128i_i8[8]);
        v29 = 0u;
        v46 = 0u;
        v39 = 0;
        v40 = 0;
        v23.m128i_i64[0] = 0;
        v23.m128i_i64[1] = _mm_extract_epi64((__m128i)0LL, 1);
        _InterlockedCompareExchange128((volatile signed __int64 *)(v8 + 0x10), 0, 0, v23.m128i_i64);
        v22 = v23.m128i_i32[2];
        *(_QWORD *)&v46 = v23.m128i_i64[0];
        v28 = v23;
        if ( v23.m128i_i32[2] < 0 )
          goto LABEL_23;
      }
      v26 = 1;
      v25 = a3;
      goto LABEL_5;
    }
    goto LABEL_23;
  }
  v13 = 0;
  *(_BYTE *)(a1 + 0x80018) = a3;
  if ( *(_DWORD *)(a1 + 0x8002C) )
  {
    do
    {
      if ( (_BYTE)v13 != a3 )
      {
        v14 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 0x80030) + 2 * v13);
        if ( (_WORD)v14 != 0xFFFF )
        {
          v35 = 0u;
          v37 = 0;
          v15 = a1 + 0x10LL * v14;
          v36 = 0;
          v16.m128i_i64[0] = 0;
          v16.m128i_i64[1] = _mm_extract_epi64((__m128i)0LL, 1);
          _InterlockedCompareExchange128((volatile signed __int64 *)(v15 + 0x10), 0, 0, v16.m128i_i64);
          v44 = v16;
          v17 = v16;
          v30 = v16;
          epi32 = _mm_extract_epi32(v16, 2);
          v19 = v16.m128i_i64[0];
          while ( 1 )
          {
            v42 = v17;
            v38.m128i_i64[0] = v19;
            v38.m128i_i32[2] = epi32;
            v42.m128i_i32[2] = epi32 & 0x1FFFFFFF | 0x80000000;
            v38.m128i_i32[3] = (unsigned __int64)_mm_extract_epi64(v17, 1) >> 0x20;
            *(_QWORD *)&v21 = v19;
            *((_QWORD *)&v21 + 1) = _mm_extract_epi64(v38, 1);
            _InterlockedCompareExchange128(
              (volatile signed __int64 *)(v15 + 0x10),
              v42.m128i_i64[1],
              0,
              (signed __int64 *)&v21);
            v20 = v21;
            v45 = v21;
            if ( v21 == __PAIR128__(__PAIR64__(v38.m128i_u32[3], epi32), v19) )
              break;
            epi32 = DWORD2(v20);
            v19 = v20;
            v30 = (__m128i)v20;
            v17 = (__m128i)v20;
          }
          if ( (epi32 & 0x40000000) != 0 )
            qword_149C78FD8(v15 + 0x18);
        }
      }
      ++v13;
    }
    while ( v13 < *(unsigned int *)(a1 + 0x8002C) );
    v6 = (_BYTE *)v29;
    v11 = v31;
  }
  *(_WORD *)(v11 + *(_QWORD *)(a1 + 0x80030)) = 0xFFFF;
  *a2 = *(_QWORD *)(a1 + 0x80010);
  *v6 = 0;
  return a2;
}

// --- End Function: sub_146B48AE0 (0x146B48AE0) ---

// --- Function: sub_146B48EE0 (0x146B48EE0) ---
void __fastcall sub_146B48EE0(_QWORD *a1, unsigned int a2)
{
  unsigned __int64 n8_1; // r9
  __int64 v3; // r15
  _QWORD *v4; // r13
  unsigned int v5; // ebx
  __int64 v6; // r14
  _QWORD *v7; // rbx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rbp
  __int64 v10; // rsi
  unsigned __int64 n8; // rax
  __int64 v12; // rax
  _QWORD *v13; // r12
  __int64 v14; // r13
  __int64 v15; // rbx
  __int64 v16; // rdi
  __int64 v17; // rsi
  __int64 v18; // r14
  _QWORD *v19; // rdi
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rcx
  __int64 v22; // rax
  __int64 v23; // rbp
  _QWORD *v24; // r8
  __int64 v25; // r9
  __int64 v26; // rbx
  __int64 i; // rdi
  _QWORD *v28; // rdi
  __int64 j; // rbx
  __int64 v30; // r8
  __int64 v31; // rdx
  _QWORD *v34; // [rsp+70h] [rbp+18h]

  n8_1 = a1[0x2E914];
  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( n8_1 >= 8 )
  {
    v6 = (int)a2;
    v7 = &a1[0x8F * (int)a2 + 0xBD];
    sub_146B20050(
      a1[0x2E910],
      a1[0x2E910] + (n8_1 & 0xFFFFFFFFFFFFFFF8uLL),
      (__int64)(n8_1 & 0xFFFFFFFFFFFFFFF8uLL) >> 3,
      (unsigned __int8)a1);
    v8 = 0;
    v9 = v4[0x2E914] >> 3;
    if ( v9 )
    {
      do
      {
        v10 = *(_QWORD *)(v4[0x2E910] + 8 * v8);
        n8 = v7[4];
        if ( v10 != (n8 >> 3) - 1 )
        {
          if ( n8 >> 3 )
          {
            do
            {
              if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(*v7 + 8 * (n8 >> 3) - 8)) )
                break;
              sub_1403CAE60(v7, 8);
              n8 = v7[4];
            }
            while ( n8 >= 8 );
          }
          v12 = v7[4] >> 3;
          if ( !v12 )
            break;
          *(_QWORD *)(*v7 + 8 * v10) = *(_QWORD *)(*v7 + 8 * v12 - 8);
          *(_DWORD *)((*(_QWORD *)(*v7 + 8 * v10) & 0xFFFFFFFFFFFFLL) + 0x18 * v6 + 0x370) = v10;
        }
        sub_1403CAE60(v7, 8);
        ++v8;
      }
      while ( v8 < v9 );
    }
    v5 = a2;
  }
  sub_1403D37D0((__int64)(v4 + 0x2E910), 0xFFFFFFFFFFFFFFFFuLL);
  v13 = (_QWORD *)v4[0x2E924];
  v34 = &v13[v4[0x2E928] >> 3];
  if ( v13 != v34 )
  {
    v14 = 0x18LL * (int)v5;
    do
    {
      v15 = 0;
      v16 = 0;
      v17 = v14 + (*v13 & 0xFFFFFFFFFFFFLL) + 0x380;
      v18 = *(_WORD *)(v17 + 6) & 0x1FFF;
      if ( (*(_WORD *)(v17 + 6) & 0x1FFF) != 0 )
      {
        do
        {
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(8 * v16
                                                                           + (*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL))) )
          {
            if ( v16 != v15 )
            {
              *(_QWORD *)((*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL) + 8 * v15) = *(_QWORD *)((*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL)
                                                                                     + 8 * v16);
              *(_DWORD *)((*(_QWORD *)((*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL) + 8 * v15) & 0xFFFFFFFFFFFFLL) + v14 + 0x374) = v15;
            }
            ++v15;
          }
          ++v16;
        }
        while ( v16 != v18 );
        v3 = 0;
      }
      v19 = (_QWORD *)(*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL);
      v20 = (v15 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
      if ( v20 == (((HIWORD(*(_QWORD *)v17) & 0x1FFFLL) + 3) & 0xFFFFFFFFFFFFFFFCuLL) )
      {
        v21 = (v15 << 0x30) ^ ((v15 << 0x30) ^ *(_QWORD *)v17) & 0xE000FFFFFFFFFFFFuLL;
      }
      else
      {
        v22 = allocWithProfilerInfo(8 * v20, (struct _exception *)8);
        v23 = v22;
        if ( v15 )
        {
          v24 = v19;
          v25 = v15;
          do
          {
            *(_QWORD *)((char *)v24 + v22 - (_QWORD)v19) = *v24;
            *v24++ = 0;
            --v25;
          }
          while ( v25 );
        }
        sub_147715880(v19);
        v21 = v23
            ^ (v23
             ^ (v15 << 0x30))
            & 0xFFFF000000000000uLL
            ^ (*(_QWORD *)v17
             ^ (v15 << 0x30))
            & 0xE000000000000000uLL;
      }
      ++v13;
      *(_QWORD *)v17 = v21;
    }
    while ( v13 != v34 );
    v4 = a1;
  }
  sub_1403D37D0((__int64)(v4 + 0x2E924), 0xFFFFFFFFFFFFFFFFuLL);
  v26 = v4[0x2E91A];
  for ( i = v26 + 8LL * (v4[0x2E91E] >> 3); v26 != i; v26 += 8 )
    sub_146B36040(v4, v26, a2);
  sub_1403D37D0((__int64)(v4 + 0x2E91A), 0xFFFFFFFFFFFFFFFFuLL);
  v28 = v4 + 0x2E92E;
  for ( j = v4[0x2E932] >> 4; j; --j )
  {
    v30 = *(unsigned __int8 *)(v3 + *v28 + 8);
    v31 = *(_QWORD *)(v3 + *v28);
    *(_BYTE *)(*(_QWORD *)(v31 + 0x18)
             + 0xC
             * __popcnt(((1LL << *(_BYTE *)(v3 + *v28 + 8)) - 1) & v4[0x5C * *(unsigned __int16 *)(v31 + 0x10) + 0x857])
             + 0xA) = 0;
    sub_146B2E900(v4, v31, v30, 0);
    v3 += 0x10;
  }
  sub_1403D37D0((__int64)v28, 0xFFFFFFFFFFFFFFFFuLL);
}

// --- End Function: sub_146B48EE0 (0x146B48EE0) ---

// --- Function: sub_146B49B10 (0x146B49B10) ---
char __fastcall sub_146B49B10(__int64 a1, signed __int64 *a2, char a3)
{
  _QWORD *v5; // rax
  unsigned __int64 v6; // rsi
  volatile signed __int64 *v7; // r15
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // r14
  int v10; // edx
  __int128 v11; // rt0
  _QWORD *v12; // rax
  __int64 v14; // rdi
  __m128i v15; // rt0
  __m128i v16; // xmm6
  signed __int64 epi64; // r8
  int v18; // esi
  __int64 v19; // rdx
  __m128i v20; // rt0
  __m128i v21; // rt0
  signed __int64 *v22; // r13
  signed __int64 v23; // rbx
  __int64 v24; // rdx
  __m128i v25; // rt0
  int v26[4]; // [rsp+30h] [rbp-D0h] BYREF
  __m128i v27; // [rsp+40h] [rbp-C0h]
  signed __int64 *v28; // [rsp+50h] [rbp-B0h]
  __int128 v29; // [rsp+60h] [rbp-A0h]
  __int64 v30; // [rsp+70h] [rbp-90h]
  __int64 v31; // [rsp+78h] [rbp-88h]
  __int128 v32; // [rsp+80h] [rbp-80h]
  __int64 v33; // [rsp+90h] [rbp-70h]
  __int64 v34; // [rsp+98h] [rbp-68h]
  __int128 v35; // [rsp+A0h] [rbp-60h]
  __int64 v36; // [rsp+B0h] [rbp-50h]
  __int64 v37; // [rsp+B8h] [rbp-48h]
  int n0x1600; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v39; // [rsp+C4h] [rbp-3Ch]
  int n2; // [rsp+CCh] [rbp-34h]
  unsigned __int64 v41; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v42; // [rsp+D8h] [rbp-28h]
  __int64 v43; // [rsp+E0h] [rbp-20h]
  __int64 v44; // [rsp+E8h] [rbp-18h]
  __m128i v45; // [rsp+110h] [rbp+10h]
  __m128i v46; // [rsp+120h] [rbp+20h]
  __m128i v47; // [rsp+130h] [rbp+30h]
  __m128i v48; // [rsp+140h] [rbp+40h]
  __int128 v49; // [rsp+150h] [rbp+50h]

  v28 = a2;
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 0x80020));
  if ( *(_QWORD *)(a1 + 0x80050) && (v5 = (_QWORD *)sub_1403E78F0((volatile signed __int64 *)(a1 + 0x80050))) != 0 )
  {
    v6 = v5[1];
    v7 = (volatile signed __int64 *)(a1 + 0x80060);
    sub_1403E79B0((volatile signed __int64 *)(a1 + 0x80060), v5);
  }
  else
  {
    v6 = _InterlockedExchangeAdd64((volatile signed __int64 *)a1, 1u);
    v7 = (volatile signed __int64 *)(a1 + 0x80060);
  }
  v8 = v6 & 0x7FFF;
  v9 = v6 >> 0xF;
  if ( a3 )
    goto LABEL_12;
  v29 = 0u;
  v30 = 0;
  v31 = 0;
  *(_QWORD *)&v11 = 0;
  *((_QWORD *)&v11 + 1) = _mm_extract_epi64((__m128i)0LL, 1);
  _InterlockedCompareExchange128((volatile signed __int64 *)(a1 + 0x10 * (v8 + 1)), 0, 0, (signed __int64 *)&v11);
  v10 = DWORD2(v11);
  v49 = v11;
  if ( (DWORD2(v11) & 0x20000000) != 0 )
    goto LABEL_8;
  if ( (v10 & 0x1FFFFFFF) == (_DWORD)v9 )
  {
LABEL_12:
    _InterlockedIncrement((volatile signed __int32 *)(a1 + 0x80028));
    v32 = 0u;
    v14 = 0x10 * v8 + a1;
    v33 = 0;
    v34 = 0;
    v15.m128i_i64[0] = 0;
    v15.m128i_i64[1] = _mm_extract_epi64((__m128i)0LL, 1);
    _InterlockedCompareExchange128((volatile signed __int64 *)(v14 + 0x10), 0, 0, v15.m128i_i64);
    v45 = v15;
    v16 = v15;
    while ( 1 )
    {
      epi64 = _mm_extract_epi64(v16, 1);
      if ( (epi64 & 0x20000000) == 0 && (epi64 & 0x1FFFFFFF) == (_DWORD)v9 )
        break;
      v27 = v16;
      v18 = epi64 | 0x40000000;
      v27.m128i_i32[2] = epi64 | 0x40000000;
      v47 = v16;
      v20.m128i_i64[0] = v16.m128i_i64[0];
      v20.m128i_i64[1] = _mm_extract_epi64(v16, 1);
      _InterlockedCompareExchange128(
        (volatile signed __int64 *)(v14 + 0x10),
        v27.m128i_i64[1],
        v16.m128i_i64[0],
        v20.m128i_i64);
      v19 = v20.m128i_i64[1];
      v47 = v20;
      if ( v20.m128i_i64[0] == v16.m128i_i64[0] && v19 == epi64 )
      {
        n0x1600 = 0x1600;
        v39 = 0;
        n2 = 2;
        v42 = 0;
        v43 = 0;
        v44 = 0;
        v41 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_1516F0810,
          "Stalled on Full Extra Work Queue",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\IJobManager_ExtraWorkQueue_64bitPayload.h",
          0xFA);
        HIWORD(n0x1600) = word_1516F0810;
        v26[0] = v18;
        qword_149C78FC8(v14 + 0x18, v26, 4, 0xFFFFFFFFLL);
        v35 = 0u;
        v46 = 0u;
        v36 = 0;
        v37 = 0;
        v21.m128i_i64[0] = 0;
        v21.m128i_i64[1] = _mm_extract_epi64((__m128i)0LL, 1);
        _InterlockedCompareExchange128((volatile signed __int64 *)(v14 + 0x10), 0, 0, v21.m128i_i64);
        v46 = v21;
        v16 = v21;
        v42 = __rdtsc();
        qword_149C89AA8(&n0x1600);
      }
      else
      {
        v16 = v47;
      }
    }
    v22 = v28;
    while ( 1 )
    {
      v23 = *v22;
      v27 = v16;
      v27.m128i_i32[2] = _mm_extract_epi32(v16, 2) & 0x9FFFFFFF | 0x20000000;
      v48 = v16;
      v25.m128i_i64[0] = v16.m128i_i64[0];
      v25.m128i_i64[1] = _mm_extract_epi64(v16, 1);
      _InterlockedCompareExchange128((volatile signed __int64 *)(v14 + 0x10), v27.m128i_i64[1], v23, v25.m128i_i64);
      v24 = v25.m128i_i64[1];
      v48 = v25;
      if ( v25.m128i_i64[0] == v16.m128i_i64[0] && v24 == epi64 )
        break;
      v16 = v48;
      epi64 = _mm_extract_epi64(v48, 1);
    }
    if ( (epi64 & 0x40000000) != 0 )
      qword_149C78FD8(v14 + 0x18);
    return 1;
  }
  else
  {
LABEL_8:
    v12 = (_QWORD *)sub_1403E78F0(v7);
    if ( !v12 )
    {
      v12 = (_QWORD *)sub_1402A65A0(0x10u);
      if ( v12 )
        *v12 = 0;
    }
    v12[1] = v6;
    sub_1403E79B0((volatile signed __int64 *)(a1 + 0x80050), v12);
    return 0;
  }
}

// --- End Function: sub_146B49B10 (0x146B49B10) ---

// --- Function: sub_146B4A6C0 (0x146B4A6C0) ---
__int64 __fastcall sub_146B4A6C0(__int64 a1, int n0xD_1, void **a3)
{
  __int64 n0xD; // r15
  __int64 v6; // rbx
  __int64 v7; // rax
  int v8; // eax
  float v10; // xmm2_4
  double v12; // xmm2_8
  __int64 n5; // r8
  char *v14; // r13
  unsigned __int64 v15; // r14
  char *v16; // rdi
  char *v17; // rdx
  unsigned __int64 v18; // r12
  char *v19; // rbx
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // r12
  int n0x242; // eax
  const char *v26; // rax
  char *v27; // rax
  char *v28; // rax
  char *v29; // rdi
  _OWORD *v30; // rax
  __int64 v31; // rax
  _OWORD *v32; // rax
  __int64 v33; // rax
  _BYTE *v34; // rdx
  const char *v36; // [rsp+20h] [rbp-E0h]
  char v37; // [rsp+30h] [rbp-D0h]
  __int128 v38; // [rsp+38h] [rbp-C8h]
  __int128 v39; // [rsp+38h] [rbp-C8h]
  __int128 v40; // [rsp+38h] [rbp-C8h]
  double v41; // [rsp+48h] [rbp-B8h]
  double v42; // [rsp+48h] [rbp-B8h]
  __int128 v43; // [rsp+50h] [rbp-B0h]
  _QWORD Src[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int64 (__fastcall *p_sub_146B30310)(__int64); // [rsp+70h] [rbp-90h] BYREF
  void (__fastcall *n2_3)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+78h] [rbp-88h]
  _OWORD *v47; // [rsp+80h] [rbp-80h]
  __int64 (__fastcall *p_sub_146B30330)(__int64, __int64); // [rsp+88h] [rbp-78h] BYREF
  void (__fastcall *n2_4)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+90h] [rbp-70h]
  __int64 v50; // [rsp+98h] [rbp-68h]
  void (__fastcall *p_sub_146B303D0)(__int64); // [rsp+A0h] [rbp-60h] BYREF
  void (__fastcall *n2_5)(int, void (__fastcall **)(__int64), void (__fastcall **)(__int64)); // [rsp+A8h] [rbp-58h]
  _OWORD *v53; // [rsp+B0h] [rbp-50h]
  char v54; // [rsp+BDh] [rbp-43h]
  void *v55[2]; // [rsp+C0h] [rbp-40h] BYREF
  char *v56; // [rsp+D0h] [rbp-30h]
  char v57; // [rsp+E0h] [rbp-20h]
  __int64 (__fastcall *p_sub_146B30150)(__int64); // [rsp+130h] [rbp+30h] BYREF
  void (__fastcall *n2)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+138h] [rbp+38h]
  __int64 v60; // [rsp+140h] [rbp+40h]
  __int64 (__fastcall *p_sub_146B30240)(__int64, __int64, unsigned __int8); // [rsp+148h] [rbp+48h] BYREF
  void (__fastcall *n2_1)(int, __int64 (__fastcall **)(__int64, __int64, unsigned __int8), __int64 (__fastcall **)(__int64, __int64, unsigned __int8)); // [rsp+150h] [rbp+50h]
  __int64 v63; // [rsp+158h] [rbp+58h]
  __int64 (__fastcall *p_sub_146B30260)(__int64); // [rsp+160h] [rbp+60h] BYREF
  void (__fastcall *n2_2)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+168h] [rbp+68h]
  __int64 v66; // [rsp+170h] [rbp+70h]
  void *v67; // [rsp+180h] [rbp+80h] BYREF
  char *v68; // [rsp+188h] [rbp+88h]
  __int64 v69; // [rsp+190h] [rbp+90h]
  char v70; // [rsp+1A0h] [rbp+A0h]

  n0xD = n0xD_1;
  if ( n0xD_1 == 1 )
  {
    _InterlockedExchange((volatile __int32 *)(a1 + 0x174064), *(_DWORD *)(a1 + 0x174060));
    _InterlockedExchange((volatile __int32 *)(a1 + 0x174068), *(_DWORD *)(a1 + 0x17405C));
    *(_QWORD *)(a1 + 0x17405C) = 0;
  }
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E038 + 0x48LL))(
    qword_149C8E038,
    *(_QWORD *)(a1 + 8LL * n0xD_1 + 0x174E80));
  if ( qword_149C8E000 )
    v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E000 + 0x1E8LL))(qword_149C8E000);
  else
    v37 = 0;
  v6 = 0x478 * n0xD;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x3D0LL))(qword_149C8DFE0);
  sub_14037C160(0x478 * n0xD + a1 + 0x1E8, v7);
  if ( qword_149C8E018 )
  {
    v8 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x538LL))(qword_149C8E018);
  }
  else if ( qword_149C7C520 )
  {
    v8 = *(_DWORD *)(qword_149C7C520 + 0x48);
  }
  else
  {
    v8 = dword_149C8E13C;
  }
  *(_DWORD *)(v6 + a1 + 0x578) = v8;
  *(_QWORD *)(v6 + a1 + 0x580) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80
                                                                                       + 0x38LL))(
                                              qword_149C8DF80,
                                              0);
  _XMM0 = sub_14059CC00();
  v10 = *(float *)(v6 + a1 + 0x308);
  *(float *)(v6 + a1 + 0x590) = v10;
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  *(float *)(v6 + a1 + 0x588) = *(float *)&_XMM1;
  *(float *)(v6 + a1 + 0x594) = v10 * v10;
  *(_QWORD *)&_XMM1 = *(_QWORD *)(v6 + a1 + 0x220);
  v12 = *(double *)(v6 + a1 + 0x240);
  *(_QWORD *)(v6 + a1 + 0x5A0) = *(_QWORD *)(v6 + a1 + 0x200);
  *(double *)(v6 + a1 + 0x5A8) = *(double *)&_XMM1;
  *(double *)(v6 + a1 + 0x5B0) = v12;
  *(_QWORD *)(v6 + a1 + 0x598) = 0x478 * n0xD + a1 + 0x1E8;
  v36 = sub_1403B0260(n0xD);
  n5 = 5;
  if ( (_DWORD)n0xD == 0xD )
    n5 = 1;
  sub_1402B3B60((__int64)&p_sub_146B30150, 0x10, n5, "UpdateComponetPass (%s)", v36);
  if ( &v67 != a3 )
  {
    v14 = (char *)*a3;
    v15 = ((_BYTE *)a3[1] - (_BYTE *)*a3) >> 3;
    if ( v15 > (v69 - (__int64)v67) >> 3 )
    {
      sub_1407EDF30((unsigned __int64 *)&v67, v15);
      v16 = (char *)v67;
      v17 = v14;
LABEL_16:
      memmove(v16, v17, 8 * v15);
      v68 = &v16[8 * v15];
      goto LABEL_20;
    }
    v18 = (v68 - (_BYTE *)v67) >> 3;
    if ( v15 > v18 )
    {
      memmove(v67, v14, 8 * v18);
      v16 = v68;
      v17 = &v14[8 * v18];
      v15 -= v18;
      goto LABEL_16;
    }
    v19 = (char *)v67 + 8 * v15;
    memmove(v67, v14, 8 * v15);
    v68 = v19;
  }
LABEL_20:
  v20 = 0x478 * n0xD + a1 + 0x1C8;
  v70 = 1;
  *(_QWORD *)&v38 = a1;
  LODWORD(v41) = n0xD;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2)(2, &p_sub_146B30150);
    n2 = 0;
  }
  p_sub_146B30150 = 0;
  v21 = sub_1402A65A0(0x18u);
  if ( v21 )
  {
    *((_QWORD *)&v38 + 1) = 0x478 * n0xD + a1 + 0x1C8;
    *(_OWORD *)v21 = v38;
    *(double *)(v21 + 0x10) = v41;
    v60 = v21;
  }
  else
  {
    v60 = 0;
  }
  *(_QWORD *)&v39 = a1;
  p_sub_146B30150 = sub_146B30150;
  n2 = sub_146B309F0;
  BYTE4(v41) = v37;
  *((_QWORD *)&v39 + 1) = 0x478 * n0xD + a1 + 0x1C8;
  LODWORD(v41) = n0xD;
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64, unsigned __int8)))n2_1)(
      2,
      &p_sub_146B30240);
    n2_1 = 0;
  }
  p_sub_146B30240 = 0;
  v22 = sub_1402A65A0(0x18u);
  if ( v22 )
  {
    *(_OWORD *)v22 = v39;
    *(double *)(v22 + 0x10) = v41;
    v63 = v22;
  }
  else
  {
    v63 = 0;
  }
  *(_QWORD *)&v39 = a1;
  p_sub_146B30240 = sub_146B30240;
  n2_1 = sub_146B30F90;
  DWORD2(v39) = n0xD;
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2_2)(2, &p_sub_146B30260);
    n2_2 = 0;
  }
  p_sub_146B30260 = 0;
  v23 = sub_1402A65A0(0x18u);
  if ( v23 )
  {
    *(_OWORD *)v23 = v39;
    *(double *)(v23 + 0x10) = COERCE_DOUBLE(0x478 * n0xD + a1 + 0x1C8);
    v66 = v23;
  }
  else
  {
    v66 = 0;
  }
  p_sub_146B30260 = sub_146B30260;
  n2_2 = sub_146B31200;
  v24 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall **)(__int64)))(*(_QWORD *)qword_149C8E038 + 0x28LL))(
          qword_149C8E038,
          &p_sub_146B30150);
  if ( (unsigned int)n0xD > 9 || (n0x242 = 0x242, !_bittest(&n0x242, n0xD)) )
  {
    v26 = sub_1403B0260(n0xD);
    sub_1402B3B60((__int64)&p_sub_146B30310, 0x10, 4, "UpdateComponetAsyncLowPriorityLeafPass (%s)", v26);
    Src[0] = v24;
    if ( (v56 - (char *)v55[0]) >> 3 )
    {
      if ( ((char *)v55[1] - (char *)v55[0]) >> 3 )
      {
        v28 = (char *)v55[0] + 8;
        *(_QWORD *)v55[0] = v24;
      }
      else
      {
        memmove(v55[0], Src, 0);
        v29 = (char *)v55[1];
        memmove(v55[1], Src, 8u);
        v28 = v29 + 8;
        v20 = 0x478 * n0xD + a1 + 0x1C8;
      }
    }
    else
    {
      if ( v55[0] )
      {
        sub_1403A6820((__int64)v55, (unsigned __int64)v55[0], 0);
        *(_OWORD *)v55 = 0;
        v56 = 0;
      }
      v27 = (char *)sub_140394E70((__int64)v55, 8u);
      v55[0] = v27;
      v20 = 0x478 * n0xD + a1 + 0x1C8;
      v56 = v27 + 8;
      *(_QWORD *)v27 = Src[0];
      v28 = v27 + 8;
    }
    v55[1] = v28;
    v57 = 1;
    v54 = 1;
    *(_QWORD *)&v43 = a1;
    DWORD2(v43) = n0xD;
    if ( (unsigned __int64)n2_3 >= 2 )
    {
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2_3)(2, &p_sub_146B30310);
      n2_3 = 0;
    }
    p_sub_146B30310 = 0;
    v30 = (_OWORD *)sub_1402A65A0(0x10u);
    if ( v30 )
    {
      *v30 = v43;
      v47 = v30;
    }
    else
    {
      v47 = 0;
    }
    *(_QWORD *)&v40 = a1;
    p_sub_146B30310 = sub_146B30310;
    n2_3 = sub_146B31440;
    *((_QWORD *)&v40 + 1) = v20;
    LODWORD(v42) = n0xD;
    if ( (unsigned __int64)n2_4 >= 2 )
    {
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))n2_4)(2, &p_sub_146B30330);
      n2_4 = 0;
    }
    p_sub_146B30330 = 0;
    v31 = sub_1402A65A0(0x18u);
    if ( v31 )
    {
      *(_OWORD *)v31 = v40;
      HIDWORD(v42) = (unsigned __int64)(0x478 * n0xD + a1 + 0x1C8) >> 0x20;
      *(double *)(v31 + 0x10) = v42;
      v50 = v31;
    }
    else
    {
      v50 = 0;
    }
    *(_QWORD *)&v43 = a1;
    p_sub_146B30330 = sub_146B30330;
    n2_4 = sub_146B31560;
    DWORD2(v43) = n0xD;
    if ( (unsigned __int64)n2_5 >= 2 )
    {
      ((void (__fastcall *)(__int64, void (__fastcall **)(__int64)))n2_5)(2, &p_sub_146B303D0);
      n2_5 = 0;
    }
    p_sub_146B303D0 = 0;
    v32 = (_OWORD *)sub_1402A65A0(0x10u);
    if ( v32 )
    {
      *v32 = v43;
      v53 = v32;
    }
    else
    {
      v53 = 0;
    }
    p_sub_146B303D0 = sub_146B303D0;
    n2_5 = sub_146B31680;
    v33 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall **)(__int64)))(*(_QWORD *)qword_149C8E038 + 0x28LL))(
            qword_149C8E038,
            &p_sub_146B30310);
    v34 = v55[0];
    *(_QWORD *)(a1 + 8 * n0xD + 0x174E80) = v33;
    if ( v34 )
    {
      sub_1403A6820((__int64)v55, (unsigned __int64)v34, (v56 - v34) & 0xFFFFFFFFFFFFFFF8uLL);
      *(_OWORD *)v55 = 0;
      v56 = 0;
    }
    if ( (unsigned __int64)n2_5 >= 2 )
    {
      ((void (__fastcall *)(__int64, void (__fastcall **)(__int64)))n2_5)(2, &p_sub_146B303D0);
      n2_5 = 0;
    }
    p_sub_146B303D0 = 0;
    if ( (unsigned __int64)n2_4 >= 2 )
    {
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))n2_4)(2, &p_sub_146B30330);
      n2_4 = 0;
    }
    p_sub_146B30330 = 0;
    if ( (unsigned __int64)n2_3 >= 2 )
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2_3)(2, &p_sub_146B30310);
  }
  sub_1402B6C70(&p_sub_146B30150);
  return v24;
}

// --- End Function: sub_146B4A6C0 (0x146B4A6C0) ---

// --- Function: sub_146B50410 (0x146B50410) ---
__int64 __fastcall sub_146B50410(_QWORD *a1)
{
  __int64 result; // rax
  char *v3; // rdx
  __int64 *v4; // rbx
  char *v5; // rdi
  __int64 v9; // rcx
  __int64 v10; // r15
  _QWORD *v11; // rax
  char *v12; // rsi
  __int64 *v13; // r14
  __int64 v17; // rcx
  __int64 v21; // rcx
  __int64 v22; // rbx
  __int64 v25; // r9
  int v29; // r8d
  bool v30; // zf
  int v31; // edx
  int v32; // eax
  bool v33; // r8
  char v34; // dl
  __int64 v35; // [rsp+28h] [rbp-50h] BYREF
  __int64 v36; // [rsp+30h] [rbp-48h] BYREF
  __int64 v37; // [rsp+38h] [rbp-40h] BYREF

  result = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v35);
  v3 = (char *)a1[1];
  v4 = (__int64 *)a1[2];
  v5 = v3;
  if ( *v3 < (char)0xFFFFFFFF )
  {
    _XMM1 = xmmword_1482B5BC0;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm1, xmmword ptr [rdi]
        vpmovmskb eax, xmm0
      }
      _BitScanForward((unsigned int *)&v9, _EAX + 1);
      result = (unsigned int)v9;
      v5 += (unsigned int)v9;
      v4 += v9;
    }
    while ( *v5 < (char)0xFFFFFFFF );
  }
  if ( v5 != &v3[a1[4]] )
  {
    do
    {
      v10 = *v4;
      v11 = sub_14059CA60(&v35, &v37, (_QWORD *)(*v4 + 0x38));
      v36 = (unsigned int)(int)(float)(10000000.0 * *(float *)&dword_149C025F4);
      v12 = v5 + 1;
      v13 = v4 + 1;
      if ( sub_14059CAD0(v11, &v36) )
      {
        ++v5;
        ++v4;
        if ( *v12 < (char)0xFFFFFFFF )
        {
          _XMM1 = xmmword_1482B5BC0;
          do
          {
            __asm
            {
              vpcmpgtb xmm0, xmm1, xmmword ptr [rdi]
              vpmovmskb eax, xmm0
            }
            _BitScanForward((unsigned int *)&v17, _EAX + 1);
            v5 += (unsigned int)v17;
            v4 += v17;
          }
          while ( *v5 < (char)0xFFFFFFFF );
        }
      }
      else
      {
        sub_146B32F30((__int64)a1, (_BYTE *)(v10 + 0x10), 9);
        if ( *v12 < (char)0xFFFFFFFF )
        {
          _XMM1 = xmmword_1482B5BC0;
          do
          {
            __asm
            {
              vpcmpgtb xmm0, xmm1, xmmword ptr [rsi]
              vpmovmskb eax, xmm0
            }
            _BitScanForward((unsigned int *)&v21, _EAX + 1);
            v12 += (unsigned int)v21;
            v13 += v21;
          }
          while ( *v12 < (char)0xFFFFFFFF );
        }
        v22 = *v4;
        sub_140373AF0(v22 + 0x18);
        sub_1402A6590(v22);
        --a1[3];
        _XMM1 = xmmword_1482B5BB0;
        __asm { vpcmpeqb xmm0, xmm1, xmmword ptr [rdi] }
        v25 = (__int64)&v5[-a1[1] - 0x10];
        __asm
        {
          vpmovmskb eax, xmm0
          vpcmpeqb xmm1, xmm1, xmmword ptr [rcx+rdx]
          vpmovmskb ecx, xmm1
        }
        v33 = 0;
        if ( _ECX && _EAX )
        {
          _BitScanForward((unsigned int *)&v29, _EAX);
          v30 = !_BitScanReverse((unsigned int *)&v31, _ECX << 0x10);
          v32 = v30 ? 0x20 : 0x1F - v31;
          if ( (unsigned int)(v29 + v32) < 0x10 )
            v33 = 1;
        }
        v34 = 0xFE;
        v4 = v13;
        if ( v33 )
          v34 = 0x80;
        *v5 = v34;
        v5 = v12;
        *(_BYTE *)((a1[4] & 0xFLL) + (v25 & a1[4]) + a1[1] + 1) = v34;
        a1[7] += v33;
      }
      result = a1[1] + a1[4];
    }
    while ( v5 != (char *)result );
  }
  return result;
}

// --- End Function: sub_146B50410 (0x146B50410) ---

// --- Function: sub_146B52350 (0x146B52350) ---
void __fastcall sub_146B52350(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        signed int n9,
        _DWORD *a6,
        _DWORD *a7,
        char a8,
        void **p_Src)
{
  __int64 v10; // r12
  _BYTE *v11; // rbx
  signed int n9_2; // r15d
  int *v13; // rsi
  _BYTE *v14; // r14
  bool v15; // zf
  int v16; // eax
  __int64 v17; // rdi
  __int64 v18; // rax
  unsigned __int64 v19; // rcx
  char v20; // di
  char v21; // r9
  __int64 v22; // r14
  int v23; // r8d
  __int64 v24; // rcx
  __int64 v25; // rax
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // rax
  __int64 v28; // rdx
  __int64 n0x10_4; // rsi
  __int64 v30; // r14
  __int64 v31; // r12
  __int64 v32; // rcx
  __int64 v33; // r14
  __int64 v34; // r15
  __int16 v35; // bx
  int v36; // edi
  char v37; // al
  bool v38; // al
  __int64 v39; // rax
  signed int n9_1; // ebx
  int v41; // eax
  signed int *v42; // rax
  unsigned __int64 v43; // rdx
  signed int *v44; // rcx
  __int64 v45; // rcx
  _QWORD *v46; // rcx
  __int64 n0x10_5; // r15
  __int64 *v48; // rdi
  unsigned int n0x40; // ebx
  unsigned int v50; // esi
  __int64 v51; // rax
  _DWORD *v52; // rcx
  unsigned __int64 v53; // r9
  _QWORD *v54; // rcx
  unsigned int n0xFFFF; // esi
  _QWORD *v56; // rdi
  _QWORD *v57; // rbx
  __int64 v58; // rax
  int v59; // ecx
  unsigned __int64 v60; // rdi
  char v61; // r9
  char v62; // al
  unsigned int v63; // ecx
  unsigned int v64; // eax
  __int64 v65; // rdi
  __m256i v66; // ymm1
  int v68; // ecx
  __m256 *v70; // rax
  char v71; // al
  char v72; // al
  signed int *v73; // rax
  unsigned __int64 v74; // rdx
  signed int *v75; // rcx
  __int64 v76; // rdi
  _QWORD *v77; // rbx
  __int64 v78; // rcx
  unsigned __int64 v79; // rbx
  __int64 v80; // rdx
  __int64 v81; // rbx
  __int64 v82; // rdx
  __int64 i; // rcx
  unsigned __int64 v84; // r8
  char *v85; // rdi
  __int64 v86; // rbx
  unsigned __int64 v87; // rcx
  unsigned __int64 v88; // rcx
  __int64 v89; // rax
  __int64 v90; // rsi
  _OWORD *v91; // rdx
  __int64 v92; // r8
  char v93; // di
  unsigned __int64 v94; // rbx
  unsigned __int16 v95; // bx
  _QWORD *v96; // rax
  unsigned __int16 v97; // cx
  char v98; // si
  unsigned __int64 n0x10; // rax
  __int64 v100; // rdi
  unsigned __int64 n0x10_3; // r12
  unsigned __int64 *v102; // rbx
  char v103; // r14
  unsigned __int64 v104; // rbx
  unsigned __int16 v105; // bx
  _QWORD *v106; // rax
  unsigned __int16 v107; // cx
  unsigned __int64 n0x10_2; // r12
  __int64 v109; // rbx
  void **p_Src_1; // r14
  __int64 n4; // rcx
  __int64 v112; // rdi
  unsigned __int64 v113; // r15
  char v114; // cl
  unsigned __int64 v115; // rdx
  unsigned __int16 v116; // ax
  unsigned __int64 *v117; // rbx
  signed __int64 v118; // rdi
  __int64 v119; // rax
  char v120; // [rsp+48h] [rbp-C0h]
  int v121; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v122; // [rsp+58h] [rbp-B0h]
  __int64 v123; // [rsp+60h] [rbp-A8h]
  unsigned __int64 n0x10_1; // [rsp+68h] [rbp-A0h]
  int *v125; // [rsp+70h] [rbp-98h]
  __int64 n9_3; // [rsp+78h] [rbp-90h]
  int n0x1000; // [rsp+88h] [rbp-80h] BYREF
  int v128; // [rsp+8Ch] [rbp-7Ch]
  __int64 v129; // [rsp+90h] [rbp-78h]
  unsigned __int64 v130; // [rsp+98h] [rbp-70h]
  unsigned __int64 v131; // [rsp+A0h] [rbp-68h]
  __int64 v132; // [rsp+A8h] [rbp-60h]
  __int64 v133; // [rsp+B0h] [rbp-58h]
  __int64 v134; // [rsp+D8h] [rbp-30h]
  _QWORD *v135; // [rsp+E0h] [rbp-28h]
  unsigned __int64 v136; // [rsp+E8h] [rbp-20h] BYREF
  _QWORD *v137; // [rsp+F0h] [rbp-18h]
  __int64 v138; // [rsp+F8h] [rbp-10h] BYREF
  __int64 v139; // [rsp+100h] [rbp-8h]
  __int64 v140; // [rsp+108h] [rbp+0h]
  __int64 v141; // [rsp+110h] [rbp+8h]
  unsigned __int64 v142; // [rsp+118h] [rbp+10h]
  __int64 v143; // [rsp+120h] [rbp+18h] BYREF
  _DWORD v144[2]; // [rsp+128h] [rbp+20h] BYREF
  __int64 v145; // [rsp+130h] [rbp+28h]
  unsigned __int64 v146; // [rsp+138h] [rbp+30h]
  unsigned __int64 v147; // [rsp+140h] [rbp+38h]
  __int64 v148; // [rsp+148h] [rbp+40h]
  __int64 v149; // [rsp+150h] [rbp+48h]
  __m256 v150; // [rsp+178h] [rbp+70h]
  __m256 v151; // [rsp+198h] [rbp+90h] BYREF
  __m256i v152; // [rsp+1B8h] [rbp+B0h]
  char v155; // [rsp+228h] [rbp+120h]
  unsigned __int64 n0x10_6; // [rsp+228h] [rbp+120h]

  if ( a3 )
  {
    v10 = a1;
    if ( *(_BYTE *)(a3 + 0xD) == 4 )
    {
      v11 = (_BYTE *)(a3 + 8);
      if ( !(_BYTE)qword_149C8E516 || (*(_DWORD *)v11 & 2) == 0 )
      {
        n9_2 = n9;
        v144[0] = 0x1000;
        v123 = 3LL * n9;
        v145 = 0;
        v147 = 0;
        v148 = 0;
        v149 = 0;
        v13 = (int *)(a3 + 0x2D8);
        v146 = __rdtsc();
        v144[1] = *(_DWORD *)(a3 + 0x2D8);
        qword_149C89AA0(
          v144,
          &word_1516F05A8,
          "Update ECUS Group Entity",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
          0x5F5);
        v14 = v11;
        HIWORD(v144[0]) = word_1516F05A8;
        v125 = v13;
        n9_3 = n9;
        if ( dword_1516F1E90 )
        {
          v15 = (*v11 & 1) == 0;
          v125 = v13;
          n9_3 = n9;
          if ( !v15 )
          {
            v125 = v13;
            n9_3 = n9;
            if ( n9 != 9 )
            {
              v16 = *(unsigned __int16 *)(a3 + 0x4D0);
              if ( !_bittest(&v16, n9) )
              {
LABEL_167:
                v147 = __rdtsc();
                qword_149C89AA8(v144);
                return;
              }
              n9_3 = n9;
              *(_WORD *)(a3 + 0x4D0) = v16 & ~(1 << n9);
              v14 = (_BYTE *)(a3 + 8);
              v125 = (int *)(a3 + 0x2D8);
            }
          }
        }
        v17 = v123;
        v18 = *(_QWORD *)(a3 + 8 * v123 + 0x378);
        *(_QWORD *)(a3 + 8 * v123 + 0x378) = v18 & 0xDFFFFFFFFFFFFFFFuLL;
        if ( (v18 & 0x2000000000000000LL) != 0 )
        {
          n0x1000 = 0x1000;
          v129 = 0;
          v131 = 0;
          v132 = 0;
          v133 = 0;
          v130 = __rdtsc();
          v128 = *v13;
          qword_149C89AA0(
            &n0x1000,
            &word_1516F05AC,
            "Dependency Sort Components in Entity",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
            0x706);
          v19 = *(_QWORD *)(a3 + 8 * v17 + 0x378);
          HIWORD(n0x1000) = word_1516F05AC;
          sub_146B1FC60(
            (__m128i *)(v19 & 0xFFFFFFFFFFFFLL),
            (__m128i *)((v19 & 0xFFFFFFFFFFFFLL) + 0x10 * (HIWORD(v19) & 0x1FFF)),
            HIWORD(v19) & 0x1FFF,
            v10);
          v131 = __rdtsc();
          qword_149C89AA8(&n0x1000);
          v11 = v14;
        }
        v20 = 0;
        v21 = 0;
        v22 = v123;
        v23 = *(_DWORD *)v11 >> 0xD;
        LOBYTE(v23) = (*(_DWORD *)v11 & 0x2000) != 0;
        v24 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
        v25 = *(_QWORD *)(a3 + 0x4C8);
        v155 = 0;
        LODWORD(v122) = v23;
        *(_QWORD *)(v24 + 0x928) = v25;
        v26 = *(_QWORD *)(a3 + 8 * v22 + 0x378);
        v120 = 0;
        v27 = HIWORD(v26);
        v28 = v26 & 0xFFFFFFFFFFFFLL;
        v135 = (_QWORD *)v28;
        v139 = v28 + 0x10 * (v27 & 0x1FFF);
        if ( v28 != v139 )
        {
          while ( 1 )
          {
            n0x10_4 = *(_QWORD *)v28;
            v30 = v10 + 0x4058;
            n0x10_1 = n0x10_4;
            v32 = 0x2E0LL * *(unsigned __int16 *)(n0x10_4 + 0x10);
            v141 = *(_QWORD *)(n0x10_4 + 0x18);
            v31 = v141;
            v33 = v32 + v30;
            v142 = __popcnt(*(_QWORD *)(v33 + 0x260) & ((1LL << *(_BYTE *)(v28 + 8)) - 1));
            v134 = *(_QWORD *)(v33 + 0xF8) + 0x20 * v142;
            v34 = 3 * v142;
            v140 = 3 * v142;
            v35 = *(_WORD *)(v134 + 0x1C);
            v36 = *v125;
            v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)n0x10_4 + 0x20LL))(n0x10_4);
            LOWORD(v121) = v35;
            v129 = 0;
            v131 = 0;
            v132 = 0;
            v133 = 0;
            n0x1000 = 0;
            BYTE1(n0x1000) = v37;
            v130 = __rdtsc();
            v128 = v36;
            qword_149C89AA0(&n0x1000, &v121, &::p_Src, &::p_Src, 0);
            HIWORD(n0x1000) = v121;
            v38 = *(_BYTE *)(v31 + 4 * v34 + 1) || *(_BYTE *)(n0x10_4 + 0x20);
            v20 = v38 | v155;
            v155 |= v38;
            v39 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)n0x10_4 + 0x40LL))(n0x10_4);
            if ( *(_BYTE *)(n0x10_4 + 0x20) && v39 )
            {
              *(_BYTE *)(v31 + 4 * v34 + 8) = 4;
              *(_BYTE *)(n0x10_4 + 0x20) = 0;
              *a7 += sub_1403CE280(v39 + 8);
            }
            n9_1 = n9;
            if ( *(_BYTE *)(v31 + 4 * v34 + 1) )
            {
              v41 = *(_DWORD *)(v33 + 0xA8);
              if ( _bittest(&v41, n9) )
              {
                *(_BYTE *)(v31 + 4 * v34 + 8) = 4;
                v42 = *(signed int **)(v33 + 0xC8);
                v43 = (__int64)(*(_QWORD *)(v33 + 0xD0) - (_QWORD)v42) >> 3;
                while ( v43 )
                {
                  if ( v42[2 * (v43 >> 1)] >= n9 )
                  {
                    v43 >>= 1;
                  }
                  else
                  {
                    v42 += 2 * (v43 >> 1) + 2;
                    v43 += 0xFFFFFFFFFFFFFFFFuLL - (v43 >> 1);
                  }
                }
                v44 = *(signed int **)(v33 + 0xD0);
                if ( v42 == v44 )
                  goto LABEL_32;
                if ( n9 < *v42 )
                  v42 = *(signed int **)(v33 + 0xD0);
                if ( v42 == v44 )
LABEL_32:
                  v45 = 0xFFFFFFFFLL;
                else
                  v45 = (unsigned int)v42[1];
                v46 = (_QWORD *)(*(_QWORD *)(n0x10_4 + 0x50) + 0x10 * v45);
                *(_BYTE *)(v31 + 4 * v34 + 1) = 0;
                n0x10_5 = n0x10_4;
                v137 = v46;
                v48 = (__int64 *)*v46;
LABEL_34:
                n0x40 = 0;
                while ( v48 && n0x40 < *((_DWORD *)v48 + 2) )
                {
                  v50 = *((_DWORD *)v48 + n0x40 + 3);
                  if ( v50 != 0xFFFFFFFF )
                  {
                    v51 = sub_146C4FB50(qword_1516F1F78, v50);
                    v52 = *(_DWORD **)(v33 + 0xB0);
                    v53 = (*(_QWORD *)(v33 + 0xB8) - (_QWORD)v52) / 0x30LL;
                    while ( v53 )
                    {
                      if ( v52[0xC * (v53 >> 1)] >= *(_DWORD *)(v51 + 0xC) )
                      {
                        v53 >>= 1;
                      }
                      else
                      {
                        v52 += 0xC * (v53 >> 1) + 0xC;
                        v53 += 0xFFFFFFFFFFFFFFFFuLL - (v53 >> 1);
                      }
                    }
                    if ( v52 != *(_DWORD **)(v33 + 0xB8) && *(_DWORD *)(v51 + 0xC) < *v52 )
                      v52 = *(_DWORD **)(v33 + 0xB8);
                    sub_146B317A0(
                      a1,
                      n0x10_5,
                      a3,
                      v51,
                      (__int64)(v52 + 2),
                      ((int)v52 - *(_DWORD *)(v33 + 0xB0)) / 0x30,
                      a7);
                    sub_146C77E70(qword_1516F1F78, v50);
                  }
                  if ( ++n0x40 == *((_DWORD *)v48 + 2) || n0x40 == 0x40 )
                  {
                    v48 = (__int64 *)*v48;
                    goto LABEL_34;
                  }
                }
                v54 = v137;
                n0xFFFF = 0;
                v34 = v140;
                v56 = 0;
                v31 = v141;
                v57 = (_QWORD *)*v137;
                if ( *v137 )
                {
                  do
                  {
                    v58 = (__int64)v57;
                    v57 = (_QWORD *)*v57;
                    *(_DWORD *)(v58 + 8) = 0;
                    if ( n0xFFFF < 0xFFFF )
                    {
                      v56 = (_QWORD *)v58;
                    }
                    else
                    {
                      if ( v56 )
                      {
                        *v56 = 0;
                        v56 = 0;
                      }
                      sub_1402A6590(v58);
                    }
                    ++n0xFFFF;
                  }
                  while ( v57 );
                  v54 = v137;
                }
                n9_1 = n9;
                n0x10_4 = n0x10_1;
                v20 = v155;
                v54[1] = *v54;
              }
            }
            if ( *(_BYTE *)(v31 + 4 * v34 + 4) || v20 || !a8 || (_BYTE)v122 )
              break;
            v59 = *(_DWORD *)(a3 + 0x4D4);
            if ( v59 != 0xFFFFFFFF )
            {
              if ( (unsigned int)(dword_149C8E13C - v59) <= 2 )
                break;
              *(_DWORD *)(a3 + 0x4D4) = 0xFFFFFFFF;
            }
            v131 = __rdtsc();
            qword_149C89AA8(&n0x1000);
LABEL_97:
            v10 = a1;
            v28 = (__int64)(v135 + 2);
            v135 = (_QWORD *)v28;
            if ( v28 == v139 )
            {
              n9_2 = n9;
              LOBYTE(v23) = v122;
              v21 = v120;
              v22 = v123;
              goto LABEL_99;
            }
          }
          if ( !*(_QWORD *)v134 || (v60 = v142, !sub_146B42DF0(a1, a3, n0x10_4, v33, v142)) )
          {
            if ( !*(_BYTE *)(n0x10_4 + 0x20) && !*(_BYTE *)(v31 + 4 * v34 + 1) )
            {
              v71 = *(_BYTE *)(v31 + 4 * v34 + 8);
              if ( !v71 || (v72 = v71 - 1, (*(_BYTE *)(v31 + 4 * v34 + 8) = v72) == 0) )
              {
                v120 = 1;
                *v135 = 0;
                *(_BYTE *)(v31 + 4 * v34 + 9) = 0;
                v73 = *(signed int **)(v33 + 0xC8);
                v74 = (__int64)(*(_QWORD *)(v33 + 0xD0) - (_QWORD)v73) >> 3;
                while ( v74 )
                {
                  if ( v73[2 * (v74 >> 1)] >= n9_1 )
                  {
                    v74 >>= 1;
                  }
                  else
                  {
                    v73 += 2 * (v74 >> 1) + 2;
                    v74 += 0xFFFFFFFFFFFFFFFFuLL - (v74 >> 1);
                  }
                }
                v75 = *(signed int **)(v33 + 0xD0);
                if ( v73 != v75 )
                {
                  if ( n9_1 < *v73 )
                    v73 = *(signed int **)(v33 + 0xD0);
                  if ( v73 != v75 )
                  {
                    v76 = *(_QWORD *)(n0x10_4 + 0x50) + 0x10LL * (unsigned int)v73[1];
                    v77 = *(_QWORD **)v76;
                    if ( *(_QWORD *)v76 )
                    {
                      do
                      {
                        v78 = (__int64)v77;
                        v77 = (_QWORD *)*v77;
                        sub_1402A6590(v78);
                      }
                      while ( v77 );
                    }
                    *(_QWORD *)v76 = 0;
                    *(_QWORD *)(v76 + 8) = 0;
                  }
                }
              }
            }
            goto LABEL_96;
          }
          v61 = *(_BYTE *)(v31 + 4 * v34 + 4);
          v62 = *(_BYTE *)(v31 + 4 * v34 + 7) + 1;
          *(_BYTE *)(v31 + 4 * v34 + 8) = 4;
          *(_BYTE *)(v31 + 4 * v34 + 7) = v62;
          if ( v61
            || (v63 = *(unsigned __int8 *)(v31 + 4 * v34 + 5), (_BYTE)v63)
            && (v64 = *(unsigned __int8 *)(v31 + 4 * v34 + 6), *(_BYTE *)(v31 + 4 * v34 + 6) = v64 + 1, !(v64 % v63)) )
          {
            v65 = *(_QWORD *)(v33 + 0xF8) + 0x20 * v60;
            if ( (*(_WORD *)(a1 + 0x174058) & *(_WORD *)(v65 + 0x12)) != 0 )
            {
              if ( v61 )
                *(_BYTE *)(v31 + 4 * v34 + 4) = v61 - 1;
              v66 = *(__m256i *)(a2 + 0x20);
              v151 = *(__m256 *)a2;
              v152 = v66;
              __asm { vzeroupper }
              _XMM0 = sub_14059CC00();
              v68 = *(unsigned __int8 *)(v65 + 0x14);
              __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
              v151.m256_f32[5] = *(float *)&_XMM1;
              if ( v68 )
              {
                if ( v68 == 1 )
                {
                  *(_QWORD *)v150.m256_f32 = n0x10_4;
                  v150.m256_f32[6] = *(float *)&_XMM1;
                  *(_QWORD *)&v150.m256_f32[2] = *(_QWORD *)v134;
                  v70 = (__m256 *)sub_1403CE4A0(a1 + 0x50 * n9_3 + 0x174A20, 0x20u, 0);
                  *v70 = v150;
                  *(_BYTE *)(v31 + 4 * v34 + 7) = 0;
                  ++*a6;
                  goto LABEL_96;
                }
              }
              else
              {
                (*(void (__fastcall **)(__int64, __m256 *))v134)(n0x10_4, &v151);
              }
              *(_BYTE *)(v31 + 4 * v34 + 7) = 0;
              ++*a6;
            }
          }
LABEL_96:
          v131 = __rdtsc();
          __asm { vzeroupper }
          qword_149C89AA8(&n0x1000);
          v20 = v155;
          goto LABEL_97;
        }
LABEL_99:
        if ( a8 && !(_BYTE)v23 && v20 )
          *(_DWORD *)(a3 + 0x4D4) = dword_149C8E13C;
        if ( v21 )
        {
          v79 = *(_QWORD *)(a3 + 8 * v22 + 0x378);
          v80 = HIWORD(v79) & 0x1FFF;
          v81 = v79 & 0xFFFFFFFFFFFFLL;
          v82 = v81 + 0x10 * v80;
          if ( v81 != v82 )
          {
            do
            {
              if ( !*(_QWORD *)v81 )
                break;
              v81 += 0x10;
            }
            while ( v81 != v82 );
            if ( v81 != v82 )
            {
              for ( i = v81 + 0x10; i != v82; i += 0x10 )
              {
                if ( *(_QWORD *)i )
                {
                  *(_QWORD *)v81 = *(_QWORD *)i;
                  *(_BYTE *)(v81 + 8) = *(_BYTE *)(i + 8);
                  v81 += 0x10;
                }
              }
            }
          }
          v84 = *(_QWORD *)(a3 + 8 * v22 + 0x378);
          v85 = (char *)(v84 & 0xFFFFFFFFFFFFLL);
          v86 = (__int64)(v81 - (v84 & 0xFFFFFFFFFFFFLL)) >> 4;
          v87 = (v86 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
          if ( v87 == (((HIWORD(v84) & 0x1FFF) + 3) & 0xFFFFFFFFFFFFFFFCuLL) )
          {
            v88 = (v86 << 0x30) ^ (v84 ^ (v86 << 0x30)) & 0xE000FFFFFFFFFFFFuLL;
          }
          else
          {
            v89 = allocWithProfilerInfo(0x10 * v87, (struct _exception *)8);
            v90 = v89;
            if ( v86 )
            {
              v91 = (_OWORD *)v89;
              v92 = v86;
              do
              {
                *v91 = *(_OWORD *)&v85[(_QWORD)v91 - v89];
                ++v91;
                --v92;
              }
              while ( v92 );
            }
            sub_147715880(v85);
            v88 = v90
                ^ ((v86 << 0x30)
                 ^ v90)
                & 0xFFFF000000000000uLL
                ^ (*(_QWORD *)(a3 + 8 * v22 + 0x378)
                 ^ (v86 << 0x30))
                & 0xE000000000000000uLL;
          }
          *(_QWORD *)(a3 + 8 * v22 + 0x378) = v88;
          if ( (v88 & 0x1FFF000000000000LL) == 0 && (*(_WORD *)(a3 + 8 * v22 + 0x386) & 0x1FFF) == 0 )
          {
            v93 = sub_146C64D40(a3);
            if ( v93 )
              v94 = a3 & 0xFFFFFFFFFF000000uLL;
            else
              v94 = a3 - 6;
            v95 = *(_WORD *)(v94 + 2);
            v96 = (_QWORD *)sub_1403CE4A0(v10 + 0x1748D0, 8u, 0);
            v97 = v95 | 0x2000;
            if ( !v93 )
              v97 = v95;
            *v96 = a3 | ((unsigned __int64)v97 << 0x30);
          }
        }
        v98 = 0;
        *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x928LL) = 0;
        n0x10 = *(_WORD *)(a3 + 8 * v22 + 0x386) & 0x1FFF;
        n0x10_1 = n0x10;
        if ( n0x10 >= 0x10 || n9_2 == 9 )
        {
          n0x10_2 = 0;
          n0x10_6 = 0;
          if ( n0x10 )
          {
            v109 = a1;
            p_Src_1 = p_Src;
            do
            {
              n4 = n0x10 - n0x10_2;
              if ( n0x10 - n0x10_2 > 4 )
                n4 = 4;
              v112 = (*(_QWORD *)(a3 + 8 * v123 + 0x380) + 8 * n0x10_2) & 0xFFFFFFFFFFFFLL;
              v136 = v112 | (n4 << 0x30);
              v113 = v112 + 8 * HIWORD(v136);
              if ( v112 != v113 )
              {
                do
                {
                  if ( (!is_entity_descriptor_valid_or_accessible((unsigned __int64 *)v112)
                     || (*(_QWORD *)v112 & 0xFFFFFFFFFFFFLL) == 0)
                    && !v98 )
                  {
                    v98 = 1;
                    v114 = sub_146C64D40(a3);
                    if ( v114 )
                      v115 = a3 & 0xFFFFFFFFFF000000uLL;
                    else
                      v115 = a3 - 6;
                    v116 = *(_WORD *)(v115 + 2) | 0x2000;
                    if ( !v114 )
                      v116 = *(_WORD *)(v115 + 2);
                    *(_QWORD *)sub_1403CE4A0(v109 + 0x174920, 8u, 0) = a3 | ((unsigned __int64)v116 << 0x30);
                    v109 = a1;
                  }
                  v112 += 8;
                }
                while ( v112 != v113 );
                n0x10_2 = n0x10_6;
                p_Src_1 = p_Src;
              }
              if ( !sub_146B49B10(v109 + 0x174EF0, (signed __int64 *)&v136, 0) )
              {
                v117 = (unsigned __int64 *)(v136 & 0xFFFFFFFFFFFFLL);
                v118 = (v136 & 0xFFFFFFFFFFFFLL) + 8LL * HIWORD(v136);
                if ( (v136 & 0xFFFFFFFFFFFFLL) != v118 )
                {
                  do
                  {
                    if ( is_entity_descriptor_valid_or_accessible(v117) )
                      v119 = *v117 & 0xFFFFFFFFFFFFLL;
                    else
                      v119 = 0;
                    v143 = v119;
                    sub_1402A8EB0(p_Src_1, &v143);
                    ++v117;
                  }
                  while ( v117 != (unsigned __int64 *)v118 );
                }
                v109 = a1;
              }
              n0x10 = n0x10_1;
              n0x10_2 += 4LL;
              n0x10_6 = n0x10_2;
            }
            while ( n0x10_2 < n0x10_1 );
          }
        }
        else
        {
          v100 = 0;
          if ( n0x10 )
          {
            n0x10_3 = n0x10;
            while ( 1 )
            {
              v102 = (unsigned __int64 *)((*(_QWORD *)(a3 + 8 * v22 + 0x380) & 0xFFFFFFFFFFFFLL) + 8 * v100);
              if ( !is_entity_descriptor_valid_or_accessible(v102) )
                break;
              v138 = *v102 & 0xFFFFFFFFFFFFLL;
              if ( !v138 )
                goto LABEL_133;
              sub_1402A8EB0(p_Src, &v138);
LABEL_141:
              if ( ++v100 >= n0x10_3 )
                goto LABEL_167;
            }
            v138 = 0;
LABEL_133:
            if ( !v98 )
            {
              v98 = 1;
              v103 = sub_146C64D40(a3);
              if ( v103 )
                v104 = a3 & 0xFFFFFFFFFF000000uLL;
              else
                v104 = a3 - 6;
              v105 = *(_WORD *)(v104 + 2);
              v106 = (_QWORD *)sub_1403CE4A0(a1 + 0x174920, 8u, 0);
              v107 = v105 | 0x2000;
              v15 = v103 == 0;
              v22 = v123;
              if ( v15 )
                v107 = v105;
              *v106 = a3 | ((unsigned __int64)v107 << 0x30);
            }
            goto LABEL_141;
          }
        }
        goto LABEL_167;
      }
    }
  }
}

// --- End Function: sub_146B52350 (0x146B52350) ---

// --- Function: sub_146B52350 (0x146B52900) ---
void __fastcall sub_146B52350(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        signed int n9,
        _DWORD *a6,
        _DWORD *a7,
        char a8,
        void **p_Src)
{
  __int64 v10; // r12
  _BYTE *v11; // rbx
  signed int n9_2; // r15d
  int *v13; // rsi
  _BYTE *v14; // r14
  bool v15; // zf
  int v16; // eax
  __int64 v17; // rdi
  __int64 v18; // rax
  unsigned __int64 v19; // rcx
  char v20; // di
  char v21; // r9
  __int64 v22; // r14
  int v23; // r8d
  __int64 v24; // rcx
  __int64 v25; // rax
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // rax
  __int64 v28; // rdx
  __int64 n0x10_4; // rsi
  __int64 v30; // r14
  __int64 v31; // r12
  __int64 v32; // rcx
  __int64 v33; // r14
  __int64 v34; // r15
  __int16 v35; // bx
  int v36; // edi
  char v37; // al
  bool v38; // al
  __int64 v39; // rax
  signed int n9_1; // ebx
  int v41; // eax
  signed int *v42; // rax
  unsigned __int64 v43; // rdx
  signed int *v44; // rcx
  __int64 v45; // rcx
  _QWORD *v46; // rcx
  __int64 n0x10_5; // r15
  __int64 *v48; // rdi
  unsigned int n0x40; // ebx
  unsigned int v50; // esi
  __int64 v51; // rax
  _DWORD *v52; // rcx
  unsigned __int64 v53; // r9
  _QWORD *v54; // rcx
  unsigned int n0xFFFF; // esi
  _QWORD *v56; // rdi
  _QWORD *v57; // rbx
  __int64 v58; // rax
  int v59; // ecx
  unsigned __int64 v60; // rdi
  char v61; // r9
  char v62; // al
  unsigned int v63; // ecx
  unsigned int v64; // eax
  __int64 v65; // rdi
  __m256i v66; // ymm1
  int v68; // ecx
  __m256 *v70; // rax
  char v71; // al
  char v72; // al
  signed int *v73; // rax
  unsigned __int64 v74; // rdx
  signed int *v75; // rcx
  __int64 v76; // rdi
  _QWORD *v77; // rbx
  __int64 v78; // rcx
  unsigned __int64 v79; // rbx
  __int64 v80; // rdx
  __int64 v81; // rbx
  __int64 v82; // rdx
  __int64 i; // rcx
  unsigned __int64 v84; // r8
  char *v85; // rdi
  __int64 v86; // rbx
  unsigned __int64 v87; // rcx
  unsigned __int64 v88; // rcx
  __int64 v89; // rax
  __int64 v90; // rsi
  _OWORD *v91; // rdx
  __int64 v92; // r8
  char v93; // di
  unsigned __int64 v94; // rbx
  unsigned __int16 v95; // bx
  _QWORD *v96; // rax
  unsigned __int16 v97; // cx
  char v98; // si
  unsigned __int64 n0x10; // rax
  __int64 v100; // rdi
  unsigned __int64 n0x10_3; // r12
  unsigned __int64 *v102; // rbx
  char v103; // r14
  unsigned __int64 v104; // rbx
  unsigned __int16 v105; // bx
  _QWORD *v106; // rax
  unsigned __int16 v107; // cx
  unsigned __int64 n0x10_2; // r12
  __int64 v109; // rbx
  void **p_Src_1; // r14
  __int64 n4; // rcx
  __int64 v112; // rdi
  unsigned __int64 v113; // r15
  char v114; // cl
  unsigned __int64 v115; // rdx
  unsigned __int16 v116; // ax
  unsigned __int64 *v117; // rbx
  signed __int64 v118; // rdi
  __int64 v119; // rax
  char v120; // [rsp+48h] [rbp-C0h]
  int v121; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v122; // [rsp+58h] [rbp-B0h]
  __int64 v123; // [rsp+60h] [rbp-A8h]
  unsigned __int64 n0x10_1; // [rsp+68h] [rbp-A0h]
  int *v125; // [rsp+70h] [rbp-98h]
  __int64 n9_3; // [rsp+78h] [rbp-90h]
  int n0x1000; // [rsp+88h] [rbp-80h] BYREF
  int v128; // [rsp+8Ch] [rbp-7Ch]
  __int64 v129; // [rsp+90h] [rbp-78h]
  unsigned __int64 v130; // [rsp+98h] [rbp-70h]
  unsigned __int64 v131; // [rsp+A0h] [rbp-68h]
  __int64 v132; // [rsp+A8h] [rbp-60h]
  __int64 v133; // [rsp+B0h] [rbp-58h]
  __int64 v134; // [rsp+D8h] [rbp-30h]
  _QWORD *v135; // [rsp+E0h] [rbp-28h]
  unsigned __int64 v136; // [rsp+E8h] [rbp-20h] BYREF
  _QWORD *v137; // [rsp+F0h] [rbp-18h]
  __int64 v138; // [rsp+F8h] [rbp-10h] BYREF
  __int64 v139; // [rsp+100h] [rbp-8h]
  __int64 v140; // [rsp+108h] [rbp+0h]
  __int64 v141; // [rsp+110h] [rbp+8h]
  unsigned __int64 v142; // [rsp+118h] [rbp+10h]
  __int64 v143; // [rsp+120h] [rbp+18h] BYREF
  _DWORD v144[2]; // [rsp+128h] [rbp+20h] BYREF
  __int64 v145; // [rsp+130h] [rbp+28h]
  unsigned __int64 v146; // [rsp+138h] [rbp+30h]
  unsigned __int64 v147; // [rsp+140h] [rbp+38h]
  __int64 v148; // [rsp+148h] [rbp+40h]
  __int64 v149; // [rsp+150h] [rbp+48h]
  __m256 v150; // [rsp+178h] [rbp+70h]
  __m256 v151; // [rsp+198h] [rbp+90h] BYREF
  __m256i v152; // [rsp+1B8h] [rbp+B0h]
  char v155; // [rsp+228h] [rbp+120h]
  unsigned __int64 n0x10_6; // [rsp+228h] [rbp+120h]

  if ( a3 )
  {
    v10 = a1;
    if ( *(_BYTE *)(a3 + 0xD) == 4 )
    {
      v11 = (_BYTE *)(a3 + 8);
      if ( !(_BYTE)qword_149C8E516 || (*(_DWORD *)v11 & 2) == 0 )
      {
        n9_2 = n9;
        v144[0] = 0x1000;
        v123 = 3LL * n9;
        v145 = 0;
        v147 = 0;
        v148 = 0;
        v149 = 0;
        v13 = (int *)(a3 + 0x2D8);
        v146 = __rdtsc();
        v144[1] = *(_DWORD *)(a3 + 0x2D8);
        qword_149C89AA0(
          v144,
          &word_1516F05A8,
          "Update ECUS Group Entity",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
          0x5F5);
        v14 = v11;
        HIWORD(v144[0]) = word_1516F05A8;
        v125 = v13;
        n9_3 = n9;
        if ( dword_1516F1E90 )
        {
          v15 = (*v11 & 1) == 0;
          v125 = v13;
          n9_3 = n9;
          if ( !v15 )
          {
            v125 = v13;
            n9_3 = n9;
            if ( n9 != 9 )
            {
              v16 = *(unsigned __int16 *)(a3 + 0x4D0);
              if ( !_bittest(&v16, n9) )
              {
LABEL_167:
                v147 = __rdtsc();
                qword_149C89AA8(v144);
                return;
              }
              n9_3 = n9;
              *(_WORD *)(a3 + 0x4D0) = v16 & ~(1 << n9);
              v14 = (_BYTE *)(a3 + 8);
              v125 = (int *)(a3 + 0x2D8);
            }
          }
        }
        v17 = v123;
        v18 = *(_QWORD *)(a3 + 8 * v123 + 0x378);
        *(_QWORD *)(a3 + 8 * v123 + 0x378) = v18 & 0xDFFFFFFFFFFFFFFFuLL;
        if ( (v18 & 0x2000000000000000LL) != 0 )
        {
          n0x1000 = 0x1000;
          v129 = 0;
          v131 = 0;
          v132 = 0;
          v133 = 0;
          v130 = __rdtsc();
          v128 = *v13;
          qword_149C89AA0(
            &n0x1000,
            &word_1516F05AC,
            "Dependency Sort Components in Entity",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
            0x706);
          v19 = *(_QWORD *)(a3 + 8 * v17 + 0x378);
          HIWORD(n0x1000) = word_1516F05AC;
          sub_146B1FC60(
            (__m128i *)(v19 & 0xFFFFFFFFFFFFLL),
            (__m128i *)((v19 & 0xFFFFFFFFFFFFLL) + 0x10 * (HIWORD(v19) & 0x1FFF)),
            HIWORD(v19) & 0x1FFF,
            v10);
          v131 = __rdtsc();
          qword_149C89AA8(&n0x1000);
          v11 = v14;
        }
        v20 = 0;
        v21 = 0;
        v22 = v123;
        v23 = *(_DWORD *)v11 >> 0xD;
        LOBYTE(v23) = (*(_DWORD *)v11 & 0x2000) != 0;
        v24 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
        v25 = *(_QWORD *)(a3 + 0x4C8);
        v155 = 0;
        LODWORD(v122) = v23;
        *(_QWORD *)(v24 + 0x928) = v25;
        v26 = *(_QWORD *)(a3 + 8 * v22 + 0x378);
        v120 = 0;
        v27 = HIWORD(v26);
        v28 = v26 & 0xFFFFFFFFFFFFLL;
        v135 = (_QWORD *)v28;
        v139 = v28 + 0x10 * (v27 & 0x1FFF);
        if ( v28 != v139 )
        {
          while ( 1 )
          {
            n0x10_4 = *(_QWORD *)v28;
            v30 = v10 + 0x4058;
            n0x10_1 = n0x10_4;
            v32 = 0x2E0LL * *(unsigned __int16 *)(n0x10_4 + 0x10);
            v141 = *(_QWORD *)(n0x10_4 + 0x18);
            v31 = v141;
            v33 = v32 + v30;
            v142 = __popcnt(*(_QWORD *)(v33 + 0x260) & ((1LL << *(_BYTE *)(v28 + 8)) - 1));
            v134 = *(_QWORD *)(v33 + 0xF8) + 0x20 * v142;
            v34 = 3 * v142;
            v140 = 3 * v142;
            v35 = *(_WORD *)(v134 + 0x1C);
            v36 = *v125;
            v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)n0x10_4 + 0x20LL))(n0x10_4);
            LOWORD(v121) = v35;
            v129 = 0;
            v131 = 0;
            v132 = 0;
            v133 = 0;
            n0x1000 = 0;
            BYTE1(n0x1000) = v37;
            v130 = __rdtsc();
            v128 = v36;
            qword_149C89AA0(&n0x1000, &v121, &::p_Src, &::p_Src, 0);
            HIWORD(n0x1000) = v121;
            v38 = *(_BYTE *)(v31 + 4 * v34 + 1) || *(_BYTE *)(n0x10_4 + 0x20);
            v20 = v38 | v155;
            v155 |= v38;
            v39 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)n0x10_4 + 0x40LL))(n0x10_4);
            if ( *(_BYTE *)(n0x10_4 + 0x20) && v39 )
            {
              *(_BYTE *)(v31 + 4 * v34 + 8) = 4;
              *(_BYTE *)(n0x10_4 + 0x20) = 0;
              *a7 += sub_1403CE280(v39 + 8);
            }
            n9_1 = n9;
            if ( *(_BYTE *)(v31 + 4 * v34 + 1) )
            {
              v41 = *(_DWORD *)(v33 + 0xA8);
              if ( _bittest(&v41, n9) )
              {
                *(_BYTE *)(v31 + 4 * v34 + 8) = 4;
                v42 = *(signed int **)(v33 + 0xC8);
                v43 = (__int64)(*(_QWORD *)(v33 + 0xD0) - (_QWORD)v42) >> 3;
                while ( v43 )
                {
                  if ( v42[2 * (v43 >> 1)] >= n9 )
                  {
                    v43 >>= 1;
                  }
                  else
                  {
                    v42 += 2 * (v43 >> 1) + 2;
                    v43 += 0xFFFFFFFFFFFFFFFFuLL - (v43 >> 1);
                  }
                }
                v44 = *(signed int **)(v33 + 0xD0);
                if ( v42 == v44 )
                  goto LABEL_32;
                if ( n9 < *v42 )
                  v42 = *(signed int **)(v33 + 0xD0);
                if ( v42 == v44 )
LABEL_32:
                  v45 = 0xFFFFFFFFLL;
                else
                  v45 = (unsigned int)v42[1];
                v46 = (_QWORD *)(*(_QWORD *)(n0x10_4 + 0x50) + 0x10 * v45);
                *(_BYTE *)(v31 + 4 * v34 + 1) = 0;
                n0x10_5 = n0x10_4;
                v137 = v46;
                v48 = (__int64 *)*v46;
LABEL_34:
                n0x40 = 0;
                while ( v48 && n0x40 < *((_DWORD *)v48 + 2) )
                {
                  v50 = *((_DWORD *)v48 + n0x40 + 3);
                  if ( v50 != 0xFFFFFFFF )
                  {
                    v51 = sub_146C4FB50(qword_1516F1F78, v50);
                    v52 = *(_DWORD **)(v33 + 0xB0);
                    v53 = (*(_QWORD *)(v33 + 0xB8) - (_QWORD)v52) / 0x30LL;
                    while ( v53 )
                    {
                      if ( v52[0xC * (v53 >> 1)] >= *(_DWORD *)(v51 + 0xC) )
                      {
                        v53 >>= 1;
                      }
                      else
                      {
                        v52 += 0xC * (v53 >> 1) + 0xC;
                        v53 += 0xFFFFFFFFFFFFFFFFuLL - (v53 >> 1);
                      }
                    }
                    if ( v52 != *(_DWORD **)(v33 + 0xB8) && *(_DWORD *)(v51 + 0xC) < *v52 )
                      v52 = *(_DWORD **)(v33 + 0xB8);
                    sub_146B317A0(
                      a1,
                      n0x10_5,
                      a3,
                      v51,
                      (__int64)(v52 + 2),
                      ((int)v52 - *(_DWORD *)(v33 + 0xB0)) / 0x30,
                      a7);
                    sub_146C77E70(qword_1516F1F78, v50);
                  }
                  if ( ++n0x40 == *((_DWORD *)v48 + 2) || n0x40 == 0x40 )
                  {
                    v48 = (__int64 *)*v48;
                    goto LABEL_34;
                  }
                }
                v54 = v137;
                n0xFFFF = 0;
                v34 = v140;
                v56 = 0;
                v31 = v141;
                v57 = (_QWORD *)*v137;
                if ( *v137 )
                {
                  do
                  {
                    v58 = (__int64)v57;
                    v57 = (_QWORD *)*v57;
                    *(_DWORD *)(v58 + 8) = 0;
                    if ( n0xFFFF < 0xFFFF )
                    {
                      v56 = (_QWORD *)v58;
                    }
                    else
                    {
                      if ( v56 )
                      {
                        *v56 = 0;
                        v56 = 0;
                      }
                      sub_1402A6590(v58);
                    }
                    ++n0xFFFF;
                  }
                  while ( v57 );
                  v54 = v137;
                }
                n9_1 = n9;
                n0x10_4 = n0x10_1;
                v20 = v155;
                v54[1] = *v54;
              }
            }
            if ( *(_BYTE *)(v31 + 4 * v34 + 4) || v20 || !a8 || (_BYTE)v122 )
              break;
            v59 = *(_DWORD *)(a3 + 0x4D4);
            if ( v59 != 0xFFFFFFFF )
            {
              if ( (unsigned int)(dword_149C8E13C - v59) <= 2 )
                break;
              *(_DWORD *)(a3 + 0x4D4) = 0xFFFFFFFF;
            }
            v131 = __rdtsc();
            qword_149C89AA8(&n0x1000);
LABEL_97:
            v10 = a1;
            v28 = (__int64)(v135 + 2);
            v135 = (_QWORD *)v28;
            if ( v28 == v139 )
            {
              n9_2 = n9;
              LOBYTE(v23) = v122;
              v21 = v120;
              v22 = v123;
              goto LABEL_99;
            }
          }
          if ( !*(_QWORD *)v134 || (v60 = v142, !sub_146B42DF0(a1, a3, n0x10_4, v33, v142)) )
          {
            if ( !*(_BYTE *)(n0x10_4 + 0x20) && !*(_BYTE *)(v31 + 4 * v34 + 1) )
            {
              v71 = *(_BYTE *)(v31 + 4 * v34 + 8);
              if ( !v71 || (v72 = v71 - 1, (*(_BYTE *)(v31 + 4 * v34 + 8) = v72) == 0) )
              {
                v120 = 1;
                *v135 = 0;
                *(_BYTE *)(v31 + 4 * v34 + 9) = 0;
                v73 = *(signed int **)(v33 + 0xC8);
                v74 = (__int64)(*(_QWORD *)(v33 + 0xD0) - (_QWORD)v73) >> 3;
                while ( v74 )
                {
                  if ( v73[2 * (v74 >> 1)] >= n9_1 )
                  {
                    v74 >>= 1;
                  }
                  else
                  {
                    v73 += 2 * (v74 >> 1) + 2;
                    v74 += 0xFFFFFFFFFFFFFFFFuLL - (v74 >> 1);
                  }
                }
                v75 = *(signed int **)(v33 + 0xD0);
                if ( v73 != v75 )
                {
                  if ( n9_1 < *v73 )
                    v73 = *(signed int **)(v33 + 0xD0);
                  if ( v73 != v75 )
                  {
                    v76 = *(_QWORD *)(n0x10_4 + 0x50) + 0x10LL * (unsigned int)v73[1];
                    v77 = *(_QWORD **)v76;
                    if ( *(_QWORD *)v76 )
                    {
                      do
                      {
                        v78 = (__int64)v77;
                        v77 = (_QWORD *)*v77;
                        sub_1402A6590(v78);
                      }
                      while ( v77 );
                    }
                    *(_QWORD *)v76 = 0;
                    *(_QWORD *)(v76 + 8) = 0;
                  }
                }
              }
            }
            goto LABEL_96;
          }
          v61 = *(_BYTE *)(v31 + 4 * v34 + 4);
          v62 = *(_BYTE *)(v31 + 4 * v34 + 7) + 1;
          *(_BYTE *)(v31 + 4 * v34 + 8) = 4;
          *(_BYTE *)(v31 + 4 * v34 + 7) = v62;
          if ( v61
            || (v63 = *(unsigned __int8 *)(v31 + 4 * v34 + 5), (_BYTE)v63)
            && (v64 = *(unsigned __int8 *)(v31 + 4 * v34 + 6), *(_BYTE *)(v31 + 4 * v34 + 6) = v64 + 1, !(v64 % v63)) )
          {
            v65 = *(_QWORD *)(v33 + 0xF8) + 0x20 * v60;
            if ( (*(_WORD *)(a1 + 0x174058) & *(_WORD *)(v65 + 0x12)) != 0 )
            {
              if ( v61 )
                *(_BYTE *)(v31 + 4 * v34 + 4) = v61 - 1;
              v66 = *(__m256i *)(a2 + 0x20);
              v151 = *(__m256 *)a2;
              v152 = v66;
              __asm { vzeroupper }
              _XMM0 = sub_14059CC00();
              v68 = *(unsigned __int8 *)(v65 + 0x14);
              __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
              v151.m256_f32[5] = *(float *)&_XMM1;
              if ( v68 )
              {
                if ( v68 == 1 )
                {
                  *(_QWORD *)v150.m256_f32 = n0x10_4;
                  v150.m256_f32[6] = *(float *)&_XMM1;
                  *(_QWORD *)&v150.m256_f32[2] = *(_QWORD *)v134;
                  v70 = (__m256 *)sub_1403CE4A0(a1 + 0x50 * n9_3 + 0x174A20, 0x20u, 0);
                  *v70 = v150;
                  *(_BYTE *)(v31 + 4 * v34 + 7) = 0;
                  ++*a6;
                  goto LABEL_96;
                }
              }
              else
              {
                (*(void (__fastcall **)(__int64, __m256 *))v134)(n0x10_4, &v151);
              }
              *(_BYTE *)(v31 + 4 * v34 + 7) = 0;
              ++*a6;
            }
          }
LABEL_96:
          v131 = __rdtsc();
          __asm { vzeroupper }
          qword_149C89AA8(&n0x1000);
          v20 = v155;
          goto LABEL_97;
        }
LABEL_99:
        if ( a8 && !(_BYTE)v23 && v20 )
          *(_DWORD *)(a3 + 0x4D4) = dword_149C8E13C;
        if ( v21 )
        {
          v79 = *(_QWORD *)(a3 + 8 * v22 + 0x378);
          v80 = HIWORD(v79) & 0x1FFF;
          v81 = v79 & 0xFFFFFFFFFFFFLL;
          v82 = v81 + 0x10 * v80;
          if ( v81 != v82 )
          {
            do
            {
              if ( !*(_QWORD *)v81 )
                break;
              v81 += 0x10;
            }
            while ( v81 != v82 );
            if ( v81 != v82 )
            {
              for ( i = v81 + 0x10; i != v82; i += 0x10 )
              {
                if ( *(_QWORD *)i )
                {
                  *(_QWORD *)v81 = *(_QWORD *)i;
                  *(_BYTE *)(v81 + 8) = *(_BYTE *)(i + 8);
                  v81 += 0x10;
                }
              }
            }
          }
          v84 = *(_QWORD *)(a3 + 8 * v22 + 0x378);
          v85 = (char *)(v84 & 0xFFFFFFFFFFFFLL);
          v86 = (__int64)(v81 - (v84 & 0xFFFFFFFFFFFFLL)) >> 4;
          v87 = (v86 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
          if ( v87 == (((HIWORD(v84) & 0x1FFF) + 3) & 0xFFFFFFFFFFFFFFFCuLL) )
          {
            v88 = (v86 << 0x30) ^ (v84 ^ (v86 << 0x30)) & 0xE000FFFFFFFFFFFFuLL;
          }
          else
          {
            v89 = allocWithProfilerInfo(0x10 * v87, (struct _exception *)8);
            v90 = v89;
            if ( v86 )
            {
              v91 = (_OWORD *)v89;
              v92 = v86;
              do
              {
                *v91 = *(_OWORD *)&v85[(_QWORD)v91 - v89];
                ++v91;
                --v92;
              }
              while ( v92 );
            }
            sub_147715880(v85);
            v88 = v90
                ^ ((v86 << 0x30)
                 ^ v90)
                & 0xFFFF000000000000uLL
                ^ (*(_QWORD *)(a3 + 8 * v22 + 0x378)
                 ^ (v86 << 0x30))
                & 0xE000000000000000uLL;
          }
          *(_QWORD *)(a3 + 8 * v22 + 0x378) = v88;
          if ( (v88 & 0x1FFF000000000000LL) == 0 && (*(_WORD *)(a3 + 8 * v22 + 0x386) & 0x1FFF) == 0 )
          {
            v93 = sub_146C64D40(a3);
            if ( v93 )
              v94 = a3 & 0xFFFFFFFFFF000000uLL;
            else
              v94 = a3 - 6;
            v95 = *(_WORD *)(v94 + 2);
            v96 = (_QWORD *)sub_1403CE4A0(v10 + 0x1748D0, 8u, 0);
            v97 = v95 | 0x2000;
            if ( !v93 )
              v97 = v95;
            *v96 = a3 | ((unsigned __int64)v97 << 0x30);
          }
        }
        v98 = 0;
        *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x928LL) = 0;
        n0x10 = *(_WORD *)(a3 + 8 * v22 + 0x386) & 0x1FFF;
        n0x10_1 = n0x10;
        if ( n0x10 >= 0x10 || n9_2 == 9 )
        {
          n0x10_2 = 0;
          n0x10_6 = 0;
          if ( n0x10 )
          {
            v109 = a1;
            p_Src_1 = p_Src;
            do
            {
              n4 = n0x10 - n0x10_2;
              if ( n0x10 - n0x10_2 > 4 )
                n4 = 4;
              v112 = (*(_QWORD *)(a3 + 8 * v123 + 0x380) + 8 * n0x10_2) & 0xFFFFFFFFFFFFLL;
              v136 = v112 | (n4 << 0x30);
              v113 = v112 + 8 * HIWORD(v136);
              if ( v112 != v113 )
              {
                do
                {
                  if ( (!is_entity_descriptor_valid_or_accessible((unsigned __int64 *)v112)
                     || (*(_QWORD *)v112 & 0xFFFFFFFFFFFFLL) == 0)
                    && !v98 )
                  {
                    v98 = 1;
                    v114 = sub_146C64D40(a3);
                    if ( v114 )
                      v115 = a3 & 0xFFFFFFFFFF000000uLL;
                    else
                      v115 = a3 - 6;
                    v116 = *(_WORD *)(v115 + 2) | 0x2000;
                    if ( !v114 )
                      v116 = *(_WORD *)(v115 + 2);
                    *(_QWORD *)sub_1403CE4A0(v109 + 0x174920, 8u, 0) = a3 | ((unsigned __int64)v116 << 0x30);
                    v109 = a1;
                  }
                  v112 += 8;
                }
                while ( v112 != v113 );
                n0x10_2 = n0x10_6;
                p_Src_1 = p_Src;
              }
              if ( !sub_146B49B10(v109 + 0x174EF0, (signed __int64 *)&v136, 0) )
              {
                v117 = (unsigned __int64 *)(v136 & 0xFFFFFFFFFFFFLL);
                v118 = (v136 & 0xFFFFFFFFFFFFLL) + 8LL * HIWORD(v136);
                if ( (v136 & 0xFFFFFFFFFFFFLL) != v118 )
                {
                  do
                  {
                    if ( is_entity_descriptor_valid_or_accessible(v117) )
                      v119 = *v117 & 0xFFFFFFFFFFFFLL;
                    else
                      v119 = 0;
                    v143 = v119;
                    sub_1402A8EB0(p_Src_1, &v143);
                    ++v117;
                  }
                  while ( v117 != (unsigned __int64 *)v118 );
                }
                v109 = a1;
              }
              n0x10 = n0x10_1;
              n0x10_2 += 4LL;
              n0x10_6 = n0x10_2;
            }
            while ( n0x10_2 < n0x10_1 );
          }
        }
        else
        {
          v100 = 0;
          if ( n0x10 )
          {
            n0x10_3 = n0x10;
            while ( 1 )
            {
              v102 = (unsigned __int64 *)((*(_QWORD *)(a3 + 8 * v22 + 0x380) & 0xFFFFFFFFFFFFLL) + 8 * v100);
              if ( !is_entity_descriptor_valid_or_accessible(v102) )
                break;
              v138 = *v102 & 0xFFFFFFFFFFFFLL;
              if ( !v138 )
                goto LABEL_133;
              sub_1402A8EB0(p_Src, &v138);
LABEL_141:
              if ( ++v100 >= n0x10_3 )
                goto LABEL_167;
            }
            v138 = 0;
LABEL_133:
            if ( !v98 )
            {
              v98 = 1;
              v103 = sub_146C64D40(a3);
              if ( v103 )
                v104 = a3 & 0xFFFFFFFFFF000000uLL;
              else
                v104 = a3 - 6;
              v105 = *(_WORD *)(v104 + 2);
              v106 = (_QWORD *)sub_1403CE4A0(a1 + 0x174920, 8u, 0);
              v107 = v105 | 0x2000;
              v15 = v103 == 0;
              v22 = v123;
              if ( v15 )
                v107 = v105;
              *v106 = a3 | ((unsigned __int64)v107 << 0x30);
            }
            goto LABEL_141;
          }
        }
        goto LABEL_167;
      }
    }
  }
}

// --- End Function: sub_146B52350 (0x146B52900) ---

// --- Function: sub_146B92760 (0x146B92760) ---
__int64 __fastcall sub_146B92760(__int64 a1)
{
  __m128 v2; // xmm11
  signed __int64 v5; // rdi
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // r15
  __int128 n0x58635FA9; // xmm9
  __int64 v12; // rax
  __int64 v13; // rdi
  __int64 v14; // rcx
  float *v15; // rax
  __m128 v18; // xmm0
  float v21; // xmm7_4
  float v22; // xmm5_4
  float v23; // xmm4_4
  float v24; // xmm12_4
  float v25; // xmm10_4
  float v26; // xmm0_4
  float v27; // xmm14_4
  float v28; // xmm11_4
  float v29; // xmm6_4
  float v30; // xmm5_4
  float v31; // xmm4_4
  float v32; // xmm9_4
  float v33; // xmm7_4
  float v34; // xmm8_4
  float v35; // xmm3_4
  float v36; // xmm0_4
  float v37; // xmm12_4
  float v38; // xmm14_4
  __m128 v39; // kr00_16
  float v40; // xmm11_4
  __m128 v41; // xmm9
  float v42; // xmm10_4
  float v43; // xmm8_4
  float v44; // xmm13_4
  float v45; // xmm4_4
  float v46; // xmm7_4
  float v47; // xmm6_4
  float v48; // xmm4_4
  __m128 v49; // kr00_16
  __m128 v50; // xmm5
  __m128 v51; // kr00_16
  float v52; // xmm4_4
  __m128 v53; // xmm3
  __m128 v54; // kr00_16
  float v55; // xmm6_4
  __m128 v56; // kr00_16
  __m128 v57; // xmm5
  __m128 v58; // kr00_16
  __m128 v59; // xmm4
  __m128 v60; // xmm1
  __m128 v61; // kr00_16
  __m128 v62; // kr00_16
  __m128 v63; // xmm2
  __m128 v64; // kr00_16
  __m128 v65; // kr00_16
  float v68; // xmm12_4
  volatile signed __int64 *v69; // rdi
  int v70; // esi
  __int64 v71; // r8
  unsigned __int64 v72; // rax
  __m128 v74; // kr00_16
  __m128 v75; // xmm4
  __m128 v76; // kr00_16
  __m128 v77; // xmm0
  int v80; // eax
  unsigned __int64 n0x200000; // rax
  __m128 v83; // [rsp+30h] [rbp-D0h] BYREF
  float v84; // [rsp+40h] [rbp-C0h]
  float v85; // [rsp+44h] [rbp-BCh]
  _BYTE v86[24]; // [rsp+48h] [rbp-B8h]
  float v87; // [rsp+60h] [rbp-A0h]
  float v88; // [rsp+64h] [rbp-9Ch]
  __m128 v89; // [rsp+70h] [rbp-90h]
  __int128 v90; // [rsp+80h] [rbp-80h]
  int n0xF00; // [rsp+90h] [rbp-70h] BYREF
  __int64 v92; // [rsp+94h] [rbp-6Ch]
  int v93; // [rsp+9Ch] [rbp-64h]
  unsigned __int64 v94; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v95; // [rsp+A8h] [rbp-58h]
  __int64 v96; // [rsp+B0h] [rbp-50h]
  __int64 v97; // [rsp+B8h] [rbp-48h]
  __int128 v98; // [rsp+E0h] [rbp-20h]
  __m128 v99; // [rsp+F0h] [rbp-10h]
  __m128 v100; // [rsp+100h] [rbp+0h]
  char v101; // [rsp+110h] [rbp+10h] BYREF
  float v102; // [rsp+228h] [rbp+128h]
  float v103; // [rsp+230h] [rbp+130h]
  float v104; // [rsp+238h] [rbp+138h] BYREF

  n0xF00 = 0xF00;
  v93 = 0;
  v95 = 0;
  v96 = 0;
  v97 = 0;
  v92 = 1;
  v94 = __rdtsc();
  qword_149C89AA0(
    &n0xF00,
    &word_1516F179C,
    "CRenderProxy::CalcLocalBounds",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\RenderProxy.cpp",
    0x5A5);
  HIWORD(n0xF00) = word_1516F179C;
  if ( (*(_DWORD *)(a1 + 0x194) & 4) == 0 )
  {
    v2 = (__m128)0xD8635FA9;
    LODWORD(_XMM7) = 0xD8635FA9;
    _XMM13 = 0;
    *(float *)&v86[0x14] = -9.9999999e14;
    v104 = 0.0;
    *(_OWORD *)&v86[4] = xmmword_1485A9340;
    if ( *(_DWORD *)(a1 + 0x240) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0x244);
    }
    else
    {
      v5 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x230));
      if ( (v5 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(a1 + 0x230, v5, "CRenderProxy::CalcLocalBounds", "m_SlotsLock", 1);
      LODWORD(_XMM7) = *(_DWORD *)&v86[0x14];
    }
    v6 = 0;
    v7 = (__int64)(*(_QWORD *)(a1 + 0xE8) - *(_QWORD *)(a1 + 0xE0)) >> 3;
    if ( !v7 )
      goto LABEL_20;
    n0x58635FA9 = 0x58635FA9u;
    _XMM10 = (__m128)*(unsigned int *)&v86[0x10];
    _XMM8 = (__m128)*(unsigned int *)&v86[0xC];
    _XMM6 = *(unsigned int *)&v86[4];
    v103 = 9.9999999e14;
    *(float *)v86 = 9.9999999e14;
    v100 = (__m128)*(unsigned int *)&v86[0x10];
    v99 = (__m128)*(unsigned int *)&v86[0xC];
    v90 = *(unsigned int *)&v86[8];
    v98 = *(unsigned int *)&v86[4];
    do
    {
      v12 = *(_QWORD *)(a1 + 0xE0);
      v13 = *(_QWORD *)(v12 + 8 * v6);
      if ( v13 )
      {
        if ( (*(_BYTE *)(v13 + 0xD8) & 1) != 0 )
        {
          v14 = *(_QWORD *)(v12 + 8 * v6);
          v83 = (__m128)xmmword_148348F30;
          v84 = v2.m128_f32[0];
          v85 = v2.m128_f32[0];
          if ( (unsigned __int8)sub_146BC0D90(v14, &v83, &v104) )
          {
            is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8));
            if ( *(_QWORD *)v13 )
            {
              v15 = (float *)sub_146BCA050(a1, (unsigned int)&v101, v6, 0, 2);
              if ( v83.m128_f32[0] <= v83.m128_f32[3] )
              {
                v21 = *v15;
                v22 = v15[1];
                v23 = v15[2];
                v24 = v22 * (float)(v23 + v23);
                v25 = *v15 * (float)(v23 + v23);
                v87 = 1.0 - (float)((float)(v21 + v21) * v21);
                v102 = (float)(v22 + v22) * v22;
                v26 = v15[3];
                v27 = (float)(v21 + v21) * v26;
                v28 = (float)(v22 + v22) * v26;
                v29 = (float)(v22 + v22) * v21;
                v30 = (float)(v23 + v23) * v23;
                v31 = v26 * (float)(v23 + v23);
                v32 = (float)(v83.m128_f32[3] - v83.m128_f32[0]) * 0.5;
                v33 = (float)(v84 - v83.m128_f32[1]) * 0.5;
                v34 = (float)(v85 - v83.m128_f32[2]) * 0.5;
                v35 = v87;
                v88 = (float)((float)((float)(fabs((float)(1.0 - v102) - v30) * v32) + (float)(fabs(v29 - v31) * v33))
                            + (float)(fabs(v25 + v28) * v34))
                    * v15[7];
                v87 = (float)((float)((float)(fabs(v31 + v29) * v32) + (float)(fabs(v87 - v30) * v33))
                            + (float)(fabs(v24 - v27) * v34))
                    * v15[7];
                v36 = v24 + v27;
                v37 = v15[7];
                v38 = v15[1];
                v39 = (__m128)LODWORD(v84);
                v40 = (float)((float)((float)(fabs(v25 - v28) * v32)
                                    + (float)(COERCE_FLOAT(LODWORD(v36) & 0x7FFFFFFF) * v33))
                            + (float)(fabs(v35 - v102) * v34))
                    * v37;
                v39.m128_f32[0] = (float)(v84 + v83.m128_f32[1]) * 0.5;
                v41 = v39;
                v42 = (float)(v85 + v83.m128_f32[2]) * 0.5;
                v43 = (float)(v83.m128_f32[3] + v83.m128_f32[0]) * 0.5;
                v44 = v15[2];
                v45 = v15[3];
                v46 = (float)((float)(v38 * v42) - (float)(v39.m128_f32[0] * v44)) + (float)(v43 * v45);
                v47 = (float)((float)(v43 * v44) - (float)(*v15 * v42)) + (float)(v39.m128_f32[0] * v45);
                v48 = (float)((float)(*v15 * v39.m128_f32[0]) - (float)(v38 * v43)) + (float)(v42 * v45);
                v49 = (__m128)LODWORD(v38);
                v49.m128_f32[0] = (float)(v38 * v48) - (float)(v47 * v44);
                v50 = v49;
                v51 = (__m128)*(unsigned int *)v15;
                v52 = (float)(v46 * v44) - (float)(*v15 * v48);
                v51.m128_f32[0] = (float)(*v15 * v47) - (float)(v38 * v46);
                v53 = v51;
                v54 = v50;
                v55 = (float)((float)((float)(v50.m128_f32[0] + v43) + v50.m128_f32[0]) * v37) + v15[4];
                v54.m128_f32[0] = v55 + v88;
                _XMM14 = v54;
                v56 = v41;
                v56.m128_f32[0] = v41.m128_f32[0] + v52;
                n0x58635FA9 = LODWORD(v103);
                v56.m128_f32[0] = (float)((float)(v56.m128_f32[0] + v52) * v37) + v15[5];
                v57 = v56;
                v58 = v53;
                v58.m128_f32[0] = (float)((float)((float)(v53.m128_f32[0] + v42) + v53.m128_f32[0]) * v37) + v15[6];
                v59 = v58;
                v61 = v57;
                v61.m128_f32[0] = v57.m128_f32[0] - v87;
                v60 = v61;
                v62 = v57;
                v62.m128_f32[0] = v57.m128_f32[0] + v87;
                _XMM12 = v62;
                v64 = v59;
                v64.m128_f32[0] = v59.m128_f32[0] - v40;
                v63 = v64;
                v65 = v59;
                v65.m128_f32[0] = v59.m128_f32[0] + v40;
                _XMM13 = v65;
                v2 = (__m128)0xD8635FA9;
                v83.m128_f32[0] = v55 - v88;
                v83.m128_f32[2] = v63.m128_f32[0];
                v85 = v65.m128_f32[0];
                _XMM15 = v63;
                v83.m128_f32[1] = v60.m128_f32[0];
                v83.m128_f32[3] = _XMM14.m128_f32[0];
                v84 = _XMM12.m128_f32[0];
                v18 = v60;
              }
              else
              {
                v83 = (__m128)xmmword_148348F30;
                _XMM14 = _mm_shuffle_ps(v83, v83, 0xFF);
                _XMM15 = _mm_shuffle_ps(v83, v83, 0xAA);
                v18 = _mm_shuffle_ps(v83, v83, 0x55);
                v84 = v2.m128_f32[0];
                v85 = v2.m128_f32[0];
                _XMM12 = v2;
                _XMM13 = v2;
              }
            }
            else
            {
              _XMM13 = (__m128)LODWORD(v85);
              _XMM12 = (__m128)LODWORD(v84);
              _XMM14 = (__m128)v83.m128_u32[3];
              _XMM15 = (__m128)v83.m128_u32[2];
              v18 = (__m128)v83.m128_u32[1];
            }
            v89 = v18;
            is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8));
            _XMM0 = v89;
            __asm { vminss  xmm6, xmm0, xmm6 }
            __asm { vminss  xmm9, xmm9, xmm8 }
            __asm { vminss  xmm0, xmm15, xmm0 }
            __asm
            {
              vmaxss  xmm8, xmm14, xmm8
              vmaxss  xmm10, xmm12, xmm10
              vmaxss  xmm7, xmm13, xmm7
            }
            *(float *)&v86[8] = *(float *)&_XMM0;
            v90 = _XMM0;
            v103 = *(float *)&n0x58635FA9;
            *(float *)v86 = *(float *)&n0x58635FA9;
            *(float *)&v86[4] = *(float *)&_XMM6;
            *(float *)&v86[0xC] = _XMM8.m128_f32[0];
            *(float *)&v86[0x10] = _XMM10.m128_f32[0];
            *(float *)&v86[0x14] = *(float *)&_XMM7;
            v98 = _XMM6;
            v99 = _XMM8;
            v100 = _XMM10;
          }
        }
      }
      ++v6;
    }
    while ( v6 < v7 );
    _XMM13 = 0;
    if ( *(float *)&n0x58635FA9 <= _XMM8.m128_f32[0] )
    {
      v68 = *(float *)&v90;
    }
    else
    {
LABEL_20:
      _XMM6 = xmmword_148D60F60;
      LODWORD(n0x58635FA9) = 0x80000000;
      LODWORD(_XMM7) = 0;
      *(float *)&v86[0x14] = 0.0;
      *(float *)v86 = -0.0;
      *(_OWORD *)&v86[4] = xmmword_148D60F60;
      _XMM10 = _mm_shuffle_ps(*(__m128 *)&v86[4], *(__m128 *)&v86[4], 0xFF);
      _XMM8 = _mm_shuffle_ps(*(__m128 *)&v86[4], *(__m128 *)&v86[4], 0xAA);
      LODWORD(v68) = _mm_shuffle_ps(*(__m128 *)&v86[4], *(__m128 *)&v86[4], 0x55).m128_u32[0];
    }
    v69 = (volatile signed __int64 *)(a1 + 0x100);
    v70 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x110) == v70 )
    {
      ++*(_DWORD *)(a1 + 0x114);
    }
    else
    {
      v71 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v72 = _InterlockedCompareExchange64(v69, 0x200000, 0);
      if ( v72 )
        sub_1403E1120(a1 + 0x100, v72, v71, "CRenderProxy::CalcLocalBounds", "localBBoxLock", 1);
      else
        *(_QWORD *)(a1 + 0x108) = v71;
      LODWORD(_XMM7) = *(_DWORD *)&v86[0x14];
      _XMM10 = (__m128)*(unsigned int *)&v86[0x10];
      _XMM8 = (__m128)*(unsigned int *)&v86[0xC];
      v68 = *(float *)&v86[8];
      _XMM6 = *(unsigned int *)&v86[4];
      LODWORD(n0x58635FA9) = *(_DWORD *)v86;
      *(_DWORD *)(a1 + 0x110) = v70;
    }
    __asm { vunpcklps xmm1, xmm10, xmm7 }
    *(_OWORD *)(a1 + 0x118) = *(_OWORD *)v86;
    *(double *)(a1 + 0x128) = *(double *)&_XMM1;
    *(double *)&v86[0x10] = *(double *)&_XMM1;
    if ( *(float *)&n0x58635FA9 <= _XMM8.m128_f32[0] )
    {
      v74 = (__m128)_XMM6;
      v74.m128_f32[0] = (float)((float)(*(float *)&_XMM6 * *(float *)&_XMM6)
                              + (float)(*(float *)&n0x58635FA9 * *(float *)&n0x58635FA9))
                      + (float)(v68 * v68);
      v75 = _mm_sqrt_ps(_mm_shuffle_ps(v74, v74, 0));
      v76 = _XMM8;
      v76.m128_f32[0] = (float)((float)(_XMM8.m128_f32[0] * _XMM8.m128_f32[0])
                              + (float)(_XMM10.m128_f32[0] * _XMM10.m128_f32[0]))
                      + (float)(*(float *)&_XMM7 * *(float *)&_XMM7);
      v77 = _mm_sqrt_ps(_mm_shuffle_ps(v76, v76, 0));
      _XMM0 = _mm_shuffle_ps(v77, v77, 0xFF);
      _mm_shuffle_ps(v75, v75, 0xFF);
      __asm { vmaxss  xmm13, xmm0, xmm4 }
    }
    __asm { vmaxss  xmm0, xmm13, [rbp+110h+arg_18] }
    *(float *)(a1 + 0x130) = *(float *)&_XMM0;
    if ( a1 != 0xFFFFFFFFFFFFFF00uLL )
    {
      v80 = *(_DWORD *)(a1 + 0x114);
      if ( v80 )
      {
        *(_DWORD *)(a1 + 0x114) = v80 - 1;
      }
      else
      {
        *(_DWORD *)(a1 + 0x110) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64(v69, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
          *(_QWORD *)(a1 + 0x108) = &p_Src;
        else
          rw_lock_handle_write_release_contention(a1 + 0x100, n0x200000);
      }
    }
    *(_DWORD *)(a1 + 0x194) |= 2u;
    rw_lock_release_read_lock(a1 + 0x230);
  }
  v95 = __rdtsc();
  return qword_149C89AA8(&n0xF00);
}

// --- End Function: sub_146B92760 (0x146B92760) ---

// --- Function: sub_146BC11D0 (0x146BC11D0) ---
__int64 __fastcall sub_146BC11D0(__int64 a1, __int64 a2)
{
  signed __int64 v4; // rdx
  double v5; // xmm1_8

  if ( (*(_DWORD *)(a1 + 0x194) & 2) == 0 )
    sub_146B92760(a1);
  if ( *(_DWORD *)(a1 + 0x110) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x114);
  }
  else
  {
    v4 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x100));
    if ( (v4 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0x100, v4, "CRenderProxy::GetLocalBounds", "localBBoxLock", 1);
  }
  v5 = *(double *)(a1 + 0x128);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 0x118);
  *(double *)(a2 + 0x10) = v5;
  rw_lock_release_read_lock(a1 + 0x100);
  return a2;
}

// --- End Function: sub_146BC11D0 (0x146BC11D0) ---

// --- Function: sub_146C1FF30 (0x146C1FF30) ---
unsigned __int64 __fastcall sub_146C1FF30(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r14
  __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // r14
  char v16; // cl
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rcx
  unsigned __int64 result; // rax

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 5;
  if ( v5 == 0x7FFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 5;
  v10 = v9 >> 1;
  if ( v9 > 0x7FFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_23;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_23;
  allocSize = 0x20 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_23:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_13:
  v15 = v14 + (v4 & 0xFFFFFFFFFFFFFFE0uLL);
  *(_QWORD *)v15 = *(_QWORD *)a3;
  v16 = *(_BYTE *)(v15 + 0x1B);
  *(_QWORD *)(v15 + 8) = *(_QWORD *)(a3 + 8);
  *(_DWORD *)(v15 + 0x10) = *(_DWORD *)(a3 + 0x10);
  *(_DWORD *)(v15 + 0x14) = *(_DWORD *)(a3 + 0x14);
  *(_WORD *)(v15 + 0x18) = *(_WORD *)(a3 + 0x18);
  *(_BYTE *)(v15 + 0x1A) = *(_BYTE *)(a3 + 0x1A);
  *(_BYTE *)(v15 + 0x1B) ^= (*(_BYTE *)(a3 + 0x1B) ^ v16) & 1;
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    sub_146C25A00(v18, v17, v14, a1);
  }
  else
  {
    sub_146C25BC0(v18, a2, v14, a1);
    sub_146C25BC0(a2, a1[1], v15 + 0x20, a1);
  }
  v19 = *a1;
  if ( *a1 )
  {
    if ( ((a1[2] - v19) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v19);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v19 - *(_QWORD *)(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(_QWORD *)(v19 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = v14;
  result = v15;
  a1[1] = v14 + 0x20 * v8;
  a1[2] = allocSize + v14;
  return result;
}

// --- End Function: sub_146C1FF30 (0x146C1FF30) ---

// --- Function: sub_146C21D80 (0x146C21D80) ---
_UNKNOWN **__fastcall sub_146C21D80(__int64 a1, __int64 a2, char a3)
{
  _UNKNOWN **result; // rax
  __int64 v6; // r13
  __int64 v7; // rbp
  __int64 v8; // r9
  __int64 v9; // r12
  int *v10; // r14
  __int64 v11; // rax
  __int64 v12; // rdi
  __int64 v13; // r8
  char v14; // cl
  __int64 v15; // rdi
  __int64 v16; // rdx
  char v17; // cl
  __int64 v18; // rdi
  __int64 v19; // rdx
  char v20; // cl
  int v21; // [rsp+20h] [rbp-58h]
  _QWORD v22[2]; // [rsp+30h] [rbp-48h] BYREF
  int v23; // [rsp+40h] [rbp-38h]
  int v24; // [rsp+44h] [rbp-34h]
  __int16 v25; // [rsp+48h] [rbp-30h]
  char v26; // [rsp+4Ah] [rbp-2Eh]
  char v27; // [rsp+4Bh] [rbp-2Dh]
  _UNKNOWN *retaddr; // [rsp+78h] [rbp+0h] BYREF

  result = &retaddr;
  v6 = (a2 - a1) >> 5;
  v7 = (a2 - a1) >> 6;
  if ( v7 > 0 )
  {
    v8 = v6 - 1;
    v9 = (v6 - 1) >> 1;
    v10 = (int *)(a1 + 0x20 * v7 + 0x10);
    do
    {
      v11 = *((_QWORD *)v10 + 0xFFFFFFFA);
      v10 += 0xFFFFFFF8;
      v22[0] = v11;
      --v7;
      *((_QWORD *)v10 + 0xFFFFFFFE) = 0;
      v12 = v7;
      v13 = v7;
      v14 = *((_BYTE *)v10 + 0xB);
      v22[1] = *((_QWORD *)v10 + 0xFFFFFFFF);
      v23 = *v10;
      v24 = v10[1];
      v25 = *((_WORD *)v10 + 4);
      v26 = *((_BYTE *)v10 + 0xA);
      v27 = v27 & 0xFE | v14 & 1;
      if ( v7 < v9 )
      {
        do
        {
          v15 = a1 + 0x20 * v12;
          v13 = 2 * v13 + !sub_14059CAF0((_QWORD *)((v13 << 6) + a1 + 0x48), (_QWORD *)((v13 << 6) + a1 + 0x28)) + 1LL;
          v16 = a1 + 0x20 * v13;
          *(_QWORD *)v15 = *(_QWORD *)v16;
          *(_QWORD *)v16 = 0;
          v17 = *(_BYTE *)(v15 + 0x1B);
          *(_QWORD *)(v15 + 8) = *(_QWORD *)(v16 + 8);
          *(_DWORD *)(v15 + 0x10) = *(_DWORD *)(v16 + 0x10);
          *(_DWORD *)(v15 + 0x14) = *(_DWORD *)(v16 + 0x14);
          *(_WORD *)(v15 + 0x18) = *(_WORD *)(v16 + 0x18);
          *(_BYTE *)(v15 + 0x1A) = *(_BYTE *)(v16 + 0x1A);
          *(_BYTE *)(v15 + 0x1B) ^= (*(_BYTE *)(v16 + 0x1B) ^ v17) & 1;
          v12 = v13;
        }
        while ( v13 < v9 );
        v8 = v6 - 1;
      }
      if ( v12 == v9 && (v6 & 1) == 0 )
      {
        v18 = a1 + 0x20 * v12;
        v19 = a1 + 0x20 * v6;
        *(_QWORD *)v18 = *(_QWORD *)(v19 - 0x20);
        *(_QWORD *)(v19 - 0x20) = 0;
        v20 = *(_BYTE *)(v18 + 0x1B);
        *(_QWORD *)(v18 + 8) = *(_QWORD *)(v19 - 0x18);
        *(_DWORD *)(v18 + 0x10) = *(_DWORD *)(v19 - 0x10);
        *(_DWORD *)(v18 + 0x14) = *(_DWORD *)(v19 - 0xC);
        *(_WORD *)(v18 + 0x18) = *(_WORD *)(v19 - 8);
        *(_BYTE *)(v18 + 0x1A) = *(_BYTE *)(v19 - 6);
        *(_BYTE *)(v18 + 0x1B) ^= (*(_BYTE *)(v19 - 5) ^ v20) & 1;
        v12 = v8;
      }
      LOBYTE(v21) = a3;
      result = (_UNKNOWN **)sub_146C23A80(a1, v12, v7, v22, v21);
      v8 = v6 - 1;
    }
    while ( v7 > 0 );
  }
  return result;
}

// --- End Function: sub_146C21D80 (0x146C21D80) ---

// --- Function: sub_146C21F90 (0x146C21F90) ---
char __fastcall sub_146C21F90(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // rdx
  __int64 v5; // r15
  __int64 v6; // r8
  __int64 v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // rdi
  __int64 v10; // rbp
  __int64 v11; // r14
  unsigned int v12; // eax
  __int64 v13; // r13
  __int64 v14; // rbp
  __int64 v15; // r14
  __int64 v17; // [rsp+20h] [rbp-58h]
  __int64 v18; // [rsp+30h] [rbp-48h]
  _UNKNOWN *retaddr; // [rsp+78h] [rbp+0h] BYREF
  __int64 v20; // [rsp+80h] [rbp+8h]
  __int64 v21; // [rsp+88h] [rbp+10h]

  v2 = (__int64)&retaddr;
  v4 = (a2 - a1) >> 3;
  v21 = v4;
  v5 = v4 >> 1;
  if ( v4 >> 1 > 0 )
  {
    v6 = v4 - 1;
    v7 = (v4 - 1) >> 1;
    v20 = v7;
    v18 = v4 - 1;
    do
    {
      v8 = *(_QWORD *)(a1 + 8 * v5-- - 8);
      v9 = v5;
      v2 = v5;
      *(_QWORD *)(a1 + 8 * v5) = 0;
      if ( v5 < v7 )
      {
        do
        {
          v17 = 2 * v2;
          v10 = *(_QWORD *)(a1 + 0x10 * v2 + 8) & 0xFFFFFFFFFFFFLL;
          v11 = *(_QWORD *)(a1 + 0x10 * v2 + 0x10) & 0xFFFFFFFFFFFFLL;
          if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v11 + 0x298), (_QWORD *)(v10 + 0x298)) )
            v12 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v11 + 0x298), (_QWORD *)(v10 + 0x298)) >> 0x1F;
          else
            LOBYTE(v12) = *(_QWORD *)(v11 + 0x10) < *(_QWORD *)(v10 + 0x10);
          v2 = v17 + 1 + ((unsigned __int8)v12 ^ 1LL);
          *(_QWORD *)(a1 + 8 * v9) = *(_QWORD *)(a1 + 8 * v2);
          v9 = v2;
          *(_QWORD *)(a1 + 8 * v2) = 0;
        }
        while ( v2 < v20 );
        v7 = v20;
        v4 = v21;
        v6 = v18;
      }
      if ( v2 == v7 && (v4 & 1) == 0 )
      {
        v2 = *(_QWORD *)(a1 + 8 * v4 - 8);
        *(_QWORD *)(a1 + 8 * v9) = v2;
        v9 = v6;
        *(_QWORD *)(a1 + 8 * v4 - 8) = 0;
      }
      if ( v5 < v9 )
      {
        v13 = v8 & 0xFFFFFFFFFFFFLL;
        do
        {
          v14 = (v9 - 1) >> 1;
          v15 = *(_QWORD *)(a1 + 8 * v14) & 0xFFFFFFFFFFFFLL;
          if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v15 + 0x298), (_QWORD *)(v13 + 0x298)) )
            LODWORD(v2) = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v15 + 0x298), (_QWORD *)(v13 + 0x298)) >> 0x1F;
          else
            LOBYTE(v2) = *(_QWORD *)(v15 + 0x10) < *(_QWORD *)((v8 & 0xFFFFFFFFFFFFLL) + 0x10);
          if ( !(_BYTE)v2 )
            break;
          v2 = *(_QWORD *)(a1 + 8 * v14);
          *(_QWORD *)(a1 + 8 * v9) = v2;
          v9 = (v9 - 1) >> 1;
          *(_QWORD *)(a1 + 8 * v14) = 0;
        }
        while ( v5 < v14 );
        v7 = v20;
      }
      v4 = v21;
      *(_QWORD *)(a1 + 8 * v9) = v8;
      v6 = v21 - 1;
    }
    while ( v5 > 0 );
  }
  return v2;
}

// --- End Function: sub_146C21F90 (0x146C21F90) ---

// --- Function: sub_146C22D90 (0x146C22D90) ---
char **__fastcall sub_146C22D90(char **a1, char *a2, char *a3)
{
  unsigned __int64 v3; // r13
  char *v4; // rcx
  char *v5; // rdi
  __int64 n0x28; // rax
  __int64 v7; // rax
  __int64 v8; // r15
  __int64 v9; // r14
  char *v10; // rbp
  __int64 v11; // r8
  char *v12; // rsi
  char *v13; // r14
  __int64 v14; // rbp
  __int64 v15; // rbx
  unsigned int v16; // eax
  __int64 v17; // rbx
  __int64 v18; // rbp
  unsigned int v19; // eax
  __int64 v20; // rbx
  __int64 v21; // rbp
  unsigned int v22; // eax
  __int64 v23; // rbx
  __int64 v24; // rbp
  unsigned int v25; // eax
  char *v26; // rbx
  char *v27; // r15
  __int64 v28; // rbp
  __int64 v29; // r14
  unsigned int v30; // eax
  __int64 v31; // rbp
  __int64 v32; // r14
  unsigned int v33; // eax
  __int64 v34; // rax
  bool v35; // zf
  char *v36; // r14
  __int64 v37; // rbp
  __int64 v38; // r13
  unsigned int v39; // eax
  __int64 v40; // rbp
  __int64 v41; // r13
  unsigned int v42; // eax
  __int64 v43; // rax
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rax
  char **result; // rax
  char *v50; // [rsp+20h] [rbp-58h]
  char *v51; // [rsp+28h] [rbp-50h]
  char *v52; // [rsp+30h] [rbp-48h]

  v3 = (unsigned __int64)a3;
  v4 = a2;
  v5 = &a2[8 * ((a3 - a2) >> 4)];
  n0x28 = (a3 + 0xFFFFFFF8 - a2) >> 3;
  if ( n0x28 <= 0x28 )
  {
    v11 = (__int64)(a3 + 0xFFFFFFF8);
  }
  else
  {
    v7 = (n0x28 + 1) >> 3;
    v8 = 0x10 * v7;
    v9 = 8 * v7;
    v10 = &a2[8 * v7];
    sub_146C223B0(a2, v10, &a2[0x10 * v7]);
    sub_146C223B0(&v5[-v9], v5, &v5[v9]);
    sub_146C223B0(v3 - 8 - v8, v3 - 8 - v9, v3 - 8);
    v11 = v3 - 8 - v9;
    v4 = v10;
  }
  sub_146C223B0(v4, v5, v11);
  v12 = v5 + 8;
  v50 = v5 + 8;
  if ( a2 < v5 )
  {
    do
    {
      v13 = v5 + 0xFFFFFFF8;
      v14 = *((_QWORD *)v5 + 0xFFFFFFFF) & 0xFFFFFFFFFFFFLL;
      v15 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
      if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v14 + 0x298), (_QWORD *)(v15 + 0x298)) )
        v16 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v14 + 0x298), (_QWORD *)(v15 + 0x298)) >> 0x1F;
      else
        LOBYTE(v16) = *(_QWORD *)(v14 + 0x10) < *(_QWORD *)(v15 + 0x10);
      if ( (_BYTE)v16 )
        break;
      v17 = *(_QWORD *)v13 & 0xFFFFFFFFFFFFLL;
      v18 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
      if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v18 + 0x298), (_QWORD *)(v17 + 0x298)) )
        v19 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v18 + 0x298), (_QWORD *)(v17 + 0x298)) >> 0x1F;
      else
        LOBYTE(v19) = *(_QWORD *)(v18 + 0x10) < *(_QWORD *)(v17 + 0x10);
      if ( (_BYTE)v19 )
        break;
      v5 += 0xFFFFFFF8;
    }
    while ( a2 < v13 );
    v3 = (unsigned __int64)a3;
  }
  if ( (unsigned __int64)v12 < v3 )
  {
    do
    {
      v20 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
      v21 = *(_QWORD *)v12 & 0xFFFFFFFFFFFFLL;
      if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v21 + 0x298), (_QWORD *)(v20 + 0x298)) )
        v22 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v21 + 0x298), (_QWORD *)(v20 + 0x298)) >> 0x1F;
      else
        LOBYTE(v22) = *(_QWORD *)(v21 + 0x10) < *(_QWORD *)(v20 + 0x10);
      if ( (_BYTE)v22 )
        break;
      v23 = *(_QWORD *)v12 & 0xFFFFFFFFFFFFLL;
      v24 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
      if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v24 + 0x298), (_QWORD *)(v23 + 0x298)) )
        v25 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v24 + 0x298), (_QWORD *)(v23 + 0x298)) >> 0x1F;
      else
        LOBYTE(v25) = *(_QWORD *)(v24 + 0x10) < *(_QWORD *)(v23 + 0x10);
      if ( (_BYTE)v25 )
        break;
      v12 += 8;
    }
    while ( (unsigned __int64)v12 < v3 );
    v50 = v12;
  }
  v26 = v12;
  v51 = v5;
  v27 = v5;
  while ( 2 )
  {
    while ( 2 )
    {
      v52 = v26;
LABEL_28:
      if ( (unsigned __int64)v26 < v3 )
      {
        while ( 1 )
        {
          v28 = *(_QWORD *)v26 & 0xFFFFFFFFFFFFLL;
          v29 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
          if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v29 + 0x298), (_QWORD *)(v28 + 0x298)) )
            v30 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v29 + 0x298), (_QWORD *)(v28 + 0x298)) >> 0x1F;
          else
            LOBYTE(v30) = *(_QWORD *)(v29 + 0x10) < *(_QWORD *)(v28 + 0x10);
          if ( !(_BYTE)v30 )
          {
            v31 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
            v32 = *(_QWORD *)v26 & 0xFFFFFFFFFFFFLL;
            if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v32 + 0x298), (_QWORD *)(v31 + 0x298)) )
              v33 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v32 + 0x298), (_QWORD *)(v31 + 0x298)) >> 0x1F;
            else
              LOBYTE(v33) = *(_QWORD *)(v32 + 0x10) < *(_QWORD *)(v31 + 0x10);
            if ( (_BYTE)v33 )
            {
LABEL_41:
              v27 = v51;
              v50 = v12;
              v52 = v26;
              break;
            }
            if ( v12 != v26 )
            {
              v34 = *(_QWORD *)v12;
              *(_QWORD *)v12 = 0;
              *(_QWORD *)v12 = *(_QWORD *)v26;
              *(_QWORD *)v26 = v34;
            }
            v12 += 8;
          }
          v26 += 8;
          if ( v26 >= a3 )
            goto LABEL_41;
        }
      }
      v35 = v27 == a2;
      if ( v27 <= a2 )
        goto LABEL_56;
      v36 = v27 + 0xFFFFFFF8;
      while ( 1 )
      {
        v37 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
        v38 = *(_QWORD *)v36 & 0xFFFFFFFFFFFFLL;
        if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v38 + 0x298), (_QWORD *)(v37 + 0x298)) )
          v39 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v38 + 0x298), (_QWORD *)(v37 + 0x298)) >> 0x1F;
        else
          LOBYTE(v39) = *(_QWORD *)(v38 + 0x10) < *(_QWORD *)(v37 + 0x10);
        if ( !(_BYTE)v39 )
          break;
LABEL_54:
        v27 += 0xFFFFFFF8;
        v36 += 0xFFFFFFF8;
        if ( a2 >= v27 )
          goto LABEL_55;
      }
      v40 = *(_QWORD *)v36 & 0xFFFFFFFFFFFFLL;
      v41 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFLL;
      if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v41 + 0x298), (_QWORD *)(v40 + 0x298)) )
        v42 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v41 + 0x298), (_QWORD *)(v40 + 0x298)) >> 0x1F;
      else
        LOBYTE(v42) = *(_QWORD *)(v41 + 0x10) < *(_QWORD *)(v40 + 0x10);
      if ( !(_BYTE)v42 )
      {
        v5 += 0xFFFFFFF8;
        if ( v5 != v36 )
        {
          v43 = *(_QWORD *)v5;
          *(_QWORD *)v5 = 0;
          *(_QWORD *)v5 = *(_QWORD *)v36;
          *(_QWORD *)v36 = v43;
        }
        goto LABEL_54;
      }
LABEL_55:
      v26 = v52;
      v35 = v27 == a2;
      v12 = v50;
      v51 = v27;
LABEL_56:
      v3 = (unsigned __int64)a3;
      if ( !v35 )
      {
        v27 += 0xFFFFFFF8;
        v51 = v27;
        if ( v26 != a3 )
        {
          v48 = *(_QWORD *)v26;
          *(_QWORD *)v26 = 0;
          *(_QWORD *)v26 = *(_QWORD *)v27;
          v26 += 8;
          *(_QWORD *)v27 = v48;
          v51 = v27;
          continue;
        }
        v5 += 0xFFFFFFF8;
        if ( v27 != v5 )
        {
          v46 = *(_QWORD *)v27;
          *(_QWORD *)v27 = 0;
          *(_QWORD *)v27 = *(_QWORD *)v5;
          *(_QWORD *)v5 = v46;
        }
        v47 = *(_QWORD *)v5;
        v12 += 0xFFFFFFF8;
        *(_QWORD *)v5 = 0;
        v50 = v12;
        *(_QWORD *)v5 = *(_QWORD *)v12;
        *(_QWORD *)v12 = v47;
        goto LABEL_28;
      }
      break;
    }
    if ( v26 != a3 )
    {
      if ( v12 != v26 )
      {
        v44 = *(_QWORD *)v5;
        *(_QWORD *)v5 = 0;
        *(_QWORD *)v5 = *(_QWORD *)v12;
        *(_QWORD *)v12 = v44;
      }
      v45 = *(_QWORD *)v5;
      v12 += 8;
      *(_QWORD *)v5 = 0;
      *(_QWORD *)v5 = *(_QWORD *)v26;
      v5 += 8;
      *(_QWORD *)v26 = v45;
      v26 += 8;
      v50 = v12;
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v5;
  a1[1] = v12;
  return result;
}

// --- End Function: sub_146C22D90 (0x146C22D90) ---

// --- Function: sub_146C23670 (0x146C23670) ---
__int64 __fastcall sub_146C23670(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v5; // r15
  __int64 v7; // rsi
  __int64 v9; // rbx
  __int64 i; // r10
  __int64 v13; // rbx
  __int64 v14; // rdx
  char v15; // cl
  __int64 v16; // r14
  __int64 v17; // rbx
  char v18; // cl

  v5 = a3 - 1;
  v7 = (a3 - 1) >> 1;
  v9 = a2;
  for ( i = a2; i < v7; v9 = i )
  {
    v13 = a1 + 0x20 * v9;
    i = 2 * i + !sub_14059CAF0((_QWORD *)((i << 6) + a1 + 0x48), (_QWORD *)((i << 6) + a1 + 0x28)) + 1LL;
    v14 = a1 + 0x20 * i;
    *(_QWORD *)v13 = *(_QWORD *)v14;
    *(_QWORD *)v14 = 0;
    v15 = *(_BYTE *)(v13 + 0x1B);
    *(_QWORD *)(v13 + 8) = *(_QWORD *)(v14 + 8);
    *(_DWORD *)(v13 + 0x10) = *(_DWORD *)(v14 + 0x10);
    *(_DWORD *)(v13 + 0x14) = *(_DWORD *)(v14 + 0x14);
    *(_WORD *)(v13 + 0x18) = *(_WORD *)(v14 + 0x18);
    *(_BYTE *)(v13 + 0x1A) = *(_BYTE *)(v14 + 0x1A);
    *(_BYTE *)(v13 + 0x1B) ^= (*(_BYTE *)(v14 + 0x1B) ^ v15) & 1;
  }
  if ( i == v7 && (a3 & 1) == 0 )
  {
    v16 = 0x20 * a3;
    v17 = a1 + 0x20 * v9;
    *(_QWORD *)v17 = *(_QWORD *)(v16 + a1 - 0x20);
    *(_QWORD *)(v16 + a1 - 0x20) = 0;
    v18 = *(_BYTE *)(v17 + 0x1B);
    *(_QWORD *)(v17 + 8) = *(_QWORD *)(v16 + a1 - 0x18);
    *(_DWORD *)(v17 + 0x10) = *(_DWORD *)(v16 + a1 - 0x10);
    *(_DWORD *)(v17 + 0x14) = *(_DWORD *)(v16 + a1 - 0xC);
    *(_WORD *)(v17 + 0x18) = *(_WORD *)(v16 + a1 - 8);
    *(_BYTE *)(v17 + 0x1A) = *(_BYTE *)(v16 + a1 - 6);
    *(_BYTE *)(v17 + 0x1B) ^= (*(_BYTE *)(v16 + a1 - 5) ^ v18) & 1;
    v9 = v5;
  }
  return sub_146C23A80(a1, v9, a2, a4, a5);
}

// --- End Function: sub_146C23670 (0x146C23670) ---

// --- Function: sub_146C238C0 (0x146C238C0) ---
__int64 __fastcall sub_146C238C0(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // r14
  __int64 v8; // r13
  bool v9; // zf
  __int64 v10; // r13
  __int64 v11; // rsi
  __int64 v12; // rbp
  unsigned int v13; // eax
  __int64 v14; // rbp
  __int64 v15; // rsi
  __int64 v16; // r14
  unsigned int v17; // eax
  __int64 result; // rax
  __int64 v19; // [rsp+70h] [rbp+8h]
  __int64 v20; // [rsp+78h] [rbp+10h]
  __int64 v21; // [rsp+80h] [rbp+18h]
  _QWORD *v22; // [rsp+88h] [rbp+20h]

  v22 = a4;
  v21 = a3;
  v19 = a2;
  v5 = a3 - 1;
  v6 = a2;
  v20 = a3 - 1;
  v7 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2 == v7;
  if ( a2 < v7 )
  {
    do
    {
      v10 = 2 * a2;
      v11 = *(_QWORD *)(a1 + 0x10 * a2 + 8) & 0xFFFFFFFFFFFFLL;
      v12 = *(_QWORD *)(a1 + 0x10 * a2 + 0x10) & 0xFFFFFFFFFFFFLL;
      if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v12 + 0x298), (_QWORD *)(v11 + 0x298)) )
        v13 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v12 + 0x298), (_QWORD *)(v11 + 0x298)) >> 0x1F;
      else
        LOBYTE(v13) = *(_QWORD *)(v12 + 0x10) < *(_QWORD *)(v11 + 0x10);
      a2 = v10 + ((unsigned __int8)v13 ^ 1LL) + 1;
      *(_QWORD *)(a1 + 8 * v6) = *(_QWORD *)(a1 + 8 * a2);
      v6 = a2;
      *(_QWORD *)(a1 + 8 * a2) = 0;
      v9 = a2 == v7;
    }
    while ( a2 < v7 );
    v8 = v19;
    a3 = v21;
    a4 = v22;
    v5 = v20;
  }
  if ( v9 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * v6) = *(_QWORD *)(a1 + 8 * a3 - 8);
    v6 = v5;
    *(_QWORD *)(a1 + 8 * a3 - 8) = 0;
  }
  if ( v8 < v6 )
  {
    do
    {
      v14 = *a4 & 0xFFFFFFFFFFFFLL;
      v15 = (v6 - 1) >> 1;
      v16 = *(_QWORD *)(a1 + 8 * v15) & 0xFFFFFFFFFFFFLL;
      if ( (unsigned int)sub_1403E8B60((unsigned __int8 **)(v16 + 0x298), (_QWORD *)(v14 + 0x298)) )
        v17 = (unsigned int)sub_1403E8B60((unsigned __int8 **)(v16 + 0x298), (_QWORD *)(v14 + 0x298)) >> 0x1F;
      else
        LOBYTE(v17) = *(_QWORD *)(v16 + 0x10) < *(_QWORD *)(v14 + 0x10);
      if ( !(_BYTE)v17 )
        break;
      a4 = v22;
      *(_QWORD *)(a1 + 8 * v6) = *(_QWORD *)(a1 + 8 * v15);
      v6 = (v6 - 1) >> 1;
      *(_QWORD *)(a1 + 8 * v15) = 0;
    }
    while ( v8 < v15 );
  }
  result = *v22;
  *(_QWORD *)(a1 + 8 * v6) = *v22;
  *v22 = 0;
  return result;
}

// --- End Function: sub_146C238C0 (0x146C238C0) ---

// --- Function: sub_146C23A80 (0x146C23A80) ---
__int64 __fastcall sub_146C23A80(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rbx
  __int64 v8; // rdi
  __int64 v9; // rsi
  __int64 v10; // rbx
  char v11; // cl
  __int64 v12; // rbx
  char v13; // cl
  __int64 result; // rax

  v6 = a2;
  if ( a3 < a2 )
  {
    do
    {
      v8 = (v6 - 1) >> 1;
      v9 = a1 + 0x20 * v8;
      if ( !sub_14059CAF0((_QWORD *)(v9 + 8), (_QWORD *)(a4 + 8)) )
        break;
      v10 = a1 + 0x20 * v6;
      *(_QWORD *)v10 = *(_QWORD *)v9;
      *(_QWORD *)v9 = 0;
      v11 = *(_BYTE *)(v10 + 0x1B);
      *(_QWORD *)(v10 + 8) = *(_QWORD *)(v9 + 8);
      *(_DWORD *)(v10 + 0x10) = *(_DWORD *)(v9 + 0x10);
      *(_DWORD *)(v10 + 0x14) = *(_DWORD *)(v9 + 0x14);
      *(_WORD *)(v10 + 0x18) = *(_WORD *)(v9 + 0x18);
      *(_BYTE *)(v10 + 0x1A) = *(_BYTE *)(v9 + 0x1A);
      *(_BYTE *)(v10 + 0x1B) ^= (*(_BYTE *)(v9 + 0x1B) ^ v11) & 1;
      v6 = v8;
    }
    while ( a3 < v8 );
  }
  v12 = a1 + 0x20 * v6;
  *(_QWORD *)v12 = *(_QWORD *)a4;
  *(_QWORD *)a4 = 0;
  v13 = *(_BYTE *)(v12 + 0x1B);
  *(_QWORD *)(v12 + 8) = *(_QWORD *)(a4 + 8);
  *(_DWORD *)(v12 + 0x10) = *(_DWORD *)(a4 + 0x10);
  *(_DWORD *)(v12 + 0x14) = *(_DWORD *)(a4 + 0x14);
  *(_WORD *)(v12 + 0x18) = *(_WORD *)(a4 + 0x18);
  result = *(unsigned __int8 *)(a4 + 0x1A);
  *(_BYTE *)(v12 + 0x1A) = result;
  *(_BYTE *)(v12 + 0x1B) ^= (*(_BYTE *)(a4 + 0x1B) ^ v13) & 1;
  return result;
}

// --- End Function: sub_146C23A80 (0x146C23A80) ---

// --- Function: sub_146C25650 (0x146C25650) ---
char __fastcall sub_146C25650(char *n0x100_15, char *n0x100_14, __int64 a3, unsigned __int8 a4)
{
  signed __int64 n0x100; // rax
  char *n0x100_9; // rbp
  char *n0x100_3; // rsi
  char *n0x100_10; // r15
  char *n0x100_12; // r14
  char **n0x100_1; // r12
  char *n0x100_16; // rbx
  char **n0x100_5; // r13
  __int64 v14; // r14
  _QWORD *v15; // rbp
  unsigned int v16; // eax
  char *v17; // r14
  char *n0x100_13; // rax
  char *v19; // rdi
  __int64 v20; // rcx
  _QWORD *n0x100_2; // rdx
  char **n0x100_4; // rdi
  char *v23; // r14
  __int64 v24; // r14
  char **n0x100_7; // [rsp+30h] [rbp-68h]
  unsigned __int8 **v27; // [rsp+38h] [rbp-60h]
  char *n0x100_11; // [rsp+48h] [rbp-50h] BYREF
  char *n0x100_17; // [rsp+50h] [rbp-48h]
  char *n0x100_6; // [rsp+A0h] [rbp+8h] BYREF
  char *n0x100_8; // [rsp+A8h] [rbp+10h]

  n0x100_8 = n0x100_14;
  n0x100_6 = n0x100_15;
  n0x100 = (n0x100_14 - n0x100_15) & 0xFFFFFFFFFFFFFFF8uLL;
  n0x100_9 = n0x100_14;
  n0x100_3 = n0x100_15;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( n0x100_3 != n0x100_9 )
    {
      n0x100_1 = (char **)(n0x100_3 + 8);
      n0x100_7 = (char **)(n0x100_3 + 8);
      if ( n0x100_3 + 8 != n0x100_9 )
      {
        do
        {
          n0x100_16 = *n0x100_1;
          n0x100_5 = n0x100_1;
          *n0x100_1 = 0;
          v14 = *(_QWORD *)n0x100_3 & 0xFFFFFFFFFFFFLL;
          n0x100_11 = n0x100_16;
          v15 = (_QWORD *)(((unsigned __int64)n0x100_16 & 0xFFFFFFFFFFFFLL) + 0x10);
          v27 = (unsigned __int8 **)(((unsigned __int64)n0x100_16 & 0xFFFFFFFFFFFFLL) + 0x298);
          if ( (unsigned int)sub_1403E8B60(v27, (_QWORD *)(v14 + 0x298)) )
            v16 = (unsigned int)sub_1403E8B60(
                                  (unsigned __int8 **)(((unsigned __int64)n0x100_16 & 0xFFFFFFFFFFFFLL) + 0x298),
                                  (_QWORD *)(v14 + 0x298)) >> 0x1F;
          else
            LOBYTE(v16) = *(_QWORD *)(((unsigned __int64)n0x100_16 & 0xFFFFFFFFFFFFLL) + 0x10) < *(_QWORD *)(v14 + 0x10);
          if ( (_BYTE)v16 )
          {
            for ( n0x100 = (signed __int64)n0x100_1; (char *)n0x100 != n0x100_3; *(_QWORD *)n0x100 = 0 )
            {
              v20 = *(_QWORD *)(n0x100 - 8);
              n0x100_2 = (_QWORD *)n0x100;
              n0x100 -= 8LL;
              *n0x100_2 = v20;
            }
            *(_QWORD *)n0x100_3 = n0x100_16;
          }
          else
          {
            for ( n0x100_4 = n0x100_1; ; *n0x100_4 = 0 )
            {
              v23 = n0x100_4[0xFFFFFFFF];
              n0x100_4 += 0xFFFFFFFF;
              v24 = (unsigned __int64)v23 & 0xFFFFFFFFFFFFLL;
              if ( (unsigned int)sub_1403E8B60(v27, (_QWORD *)(v24 + 0x298)) )
              {
                LODWORD(n0x100) = (unsigned int)sub_1403E8B60(v27, (_QWORD *)(v24 + 0x298)) >> 0x1F;
                v15 = (_QWORD *)(((unsigned __int64)n0x100_16 & 0xFFFFFFFFFFFFLL) + 0x10);
              }
              else
              {
                LOBYTE(n0x100) = *v15 < *(_QWORD *)(v24 + 0x10);
              }
              if ( !(_BYTE)n0x100 )
                break;
              *n0x100_5 = *n0x100_4;
              n0x100_5 = n0x100_4;
            }
            n0x100_3 = n0x100_6;
            n0x100_1 = n0x100_7;
            *n0x100_5 = n0x100_11;
          }
          n0x100_7 = ++n0x100_1;
        }
        while ( n0x100_1 != (char **)n0x100_8 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_146C22D90(&n0x100_11, n0x100_3, n0x100_9);
      n0x100_10 = n0x100_11;
      n0x100_12 = n0x100_17;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((n0x100_11 - n0x100_3) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((n0x100_9 - n0x100_17)
                                                                                & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_146C25650(n0x100_17, n0x100_9, a3, a4);
        n0x100_9 = n0x100_10;
        n0x100_8 = n0x100_10;
      }
      else
      {
        sub_146C25650(n0x100_3, n0x100_11, a3, a4);
        n0x100_3 = n0x100_12;
        n0x100_6 = n0x100_12;
      }
      n0x100 = (n0x100_9 - n0x100_3) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    sub_146C21F90((__int64)n0x100_3, (__int64)n0x100_9);
    n0x100 = (n0x100_9 - n0x100_3) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v17 = n0x100_9 + 0xFFFFFFF8;
      do
      {
        n0x100_13 = *(char **)v17;
        *(_QWORD *)v17 = 0;
        n0x100_6 = n0x100_13;
        *(_QWORD *)v17 = *(_QWORD *)n0x100_3;
        v19 = v17;
        *(_QWORD *)n0x100_3 = 0;
        LOBYTE(n0x100) = sub_146C238C0((__int64)n0x100_3, 0, (v17 - n0x100_3) >> 3, &n0x100_6);
        v17 += 0xFFFFFFF8;
      }
      while ( (__int64)((v19 - n0x100_3) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_146C25650 (0x146C25650) ---

// --- Function: sub_146C25A00 (0x146C25A00) ---
_QWORD *__fastcall sub_146C25A00(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // r8
  char *v6; // r10
  __int64 v7; // rax
  char v8; // dl

  if ( a1 != a2 )
  {
    v5 = a1 + 0x10;
    v6 = (char *)a3 - a1;
    do
    {
      v7 = *(_QWORD *)(v5 - 0x10);
      v5 += 0x20;
      *a3 = v7;
      a3 += 4;
      v8 = v6[v5 - 0x15];
      *(_QWORD *)&v6[v5 - 0x28] = *(_QWORD *)(v5 - 0x28);
      *(_DWORD *)&v6[v5 - 0x20] = *(_DWORD *)(v5 - 0x20);
      *(_DWORD *)&v6[v5 - 0x1C] = *(_DWORD *)(v5 - 0x1C);
      *(_WORD *)&v6[v5 - 0x18] = *(_WORD *)(v5 - 0x18);
      v6[v5 - 0x16] = *(_BYTE *)(v5 - 0x16);
      v6[v5 - 0x15] ^= (*(_BYTE *)(v5 - 0x15) ^ v8) & 1;
    }
    while ( v5 - 0x10 != a2 );
  }
  return a3;
}

// --- End Function: sub_146C25A00 (0x146C25A00) ---

// --- Function: sub_146C25BC0 (0x146C25BC0) ---
_QWORD *__fastcall sub_146C25BC0(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // r9
  char *v5; // r10
  __int64 v6; // r8
  __int64 v7; // rax
  char v8; // dl

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = (char *)a3 - a1;
    v6 = a1 + 0x10;
    do
    {
      v7 = *(_QWORD *)(v6 - 0x10);
      v6 += 0x20;
      *v3 = v7;
      *(_QWORD *)(v6 - 0x30) = 0;
      v3 += 4;
      v8 = v5[v6 - 0x15];
      *(_QWORD *)&v5[v6 - 0x28] = *(_QWORD *)(v6 - 0x28);
      *(_DWORD *)&v5[v6 - 0x20] = *(_DWORD *)(v6 - 0x20);
      *(_DWORD *)&v5[v6 - 0x1C] = *(_DWORD *)(v6 - 0x1C);
      *(_WORD *)&v5[v6 - 0x18] = *(_WORD *)(v6 - 0x18);
      v5[v6 - 0x16] = *(_BYTE *)(v6 - 0x16);
      v5[v6 - 0x15] ^= (*(_BYTE *)(v6 - 0x15) ^ v8) & 1;
    }
    while ( v6 - 0x10 != a2 );
  }
  return v3;
}

// --- End Function: sub_146C25BC0 (0x146C25BC0) ---

// --- Function: sub_146C26D30 (0x146C26D30) ---
char __fastcall sub_146C26D30(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10,
        const char **a11)
{
  void *v15; // rsp
  __int64 v17; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  __int64 v22; // [rsp+A0h] [rbp-E0h] BYREF

  v15 = alloca(0x150);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[9] = sub_1403E8F30;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_140B5EA90((__int64)&v22, a10, a11);
  LODWORD(v17) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 3u, a5, v17, a7, a8);
}

// --- End Function: sub_146C26D30 (0x146C26D30) ---

// --- Function: sub_146C26E70 (0x146C26E70) ---
char __fastcall sub_146C26E70(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        const char **a12)
{
  void *v16; // rsp
  __int64 v18; // [rsp+18h] [rbp-1D8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-1C0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-168h]
  __int64 n0xB0; // [rsp+90h] [rbp-160h]
  __int64 n0xA8; // [rsp+98h] [rbp-158h]
  __int64 v23; // [rsp+A0h] [rbp-150h]
  const char *p_Unnamed_ULong; // [rsp+A8h] [rbp-148h]
  __int64 v25; // [rsp+B0h] [rbp-140h]
  __int64 (__fastcall *p_sub_1405099D0)(_QWORD *, __int64, __int64); // [rsp+B8h] [rbp-138h]
  __int64 (__fastcall *p_sub_1405099D0_1)(_QWORD *, __int64, __int64); // [rsp+C0h] [rbp-130h]
  __int64 v28; // [rsp+C8h] [rbp-128h]
  bool (__fastcall *p_??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_pt)(_QWORD *, _QWORD *); // [rsp+D0h] [rbp-120h]
  __int64 v30; // [rsp+D8h] [rbp-118h]
  __int64 (__fastcall *p_sub_1403E9230)(__int64); // [rsp+E0h] [rbp-110h]
  __int64 (__fastcall *p_sub_1403E8F30)(); // [rsp+E8h] [rbp-108h]
  unsigned __int64 v33; // [rsp+F0h] [rbp-100h]
  __int16 v34; // [rsp+F8h] [rbp-F8h]
  __int64 n8; // [rsp+100h] [rbp-F0h]
  __int64 n0x15; // [rsp+108h] [rbp-E8h]
  __int64 v37; // [rsp+110h] [rbp-E0h] BYREF

  v16 = alloca(0x1C0);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  v23 = a10;
  p_Unnamed_ULong = "Unnamed_ULong";
  p_sub_1405099D0 = sub_1405099D0;
  p_sub_1405099D0_1 = sub_1405099D0;
  p_??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_pt = std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>;
  p_sub_1403E9230 = sub_1403E9230;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  v34 = 0;
  v25 = 0;
  v28 = 0;
  v30 = 0;
  p_sub_1403E8F30 = sub_1403E8F30;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v33 = 0xFFFFFFFFFFFFFFFFuLL;
  n8 = 8;
  n0x15 = 0x15;
  sub_140B5EA90((__int64)&v37, a11, a12);
  LODWORD(v18) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 4u, a5, v18, a7, a8);
}

// --- End Function: sub_146C26E70 (0x146C26E70) ---

// --- Function: sub_146C299A0 (0x146C299A0) ---
__int64 __fastcall sub_146C299A0(__int64 a1, __int64 a2)
{
  __int64 n2; // r10
  char v3; // r9
  __int64 result; // rax
  _QWORD v5[2]; // [rsp+30h] [rbp-28h] BYREF
  int v6; // [rsp+40h] [rbp-18h]
  int v7; // [rsp+44h] [rbp-14h]
  __int16 v8; // [rsp+48h] [rbp-10h]
  char v9; // [rsp+4Ah] [rbp-Eh]
  char v10; // [rsp+4Bh] [rbp-Dh]

  n2 = (a2 - a1) >> 5;
  if ( n2 >= 2 )
  {
    v5[0] = *(_QWORD *)(a2 - 0x20);
    *(_QWORD *)(a2 - 0x20) = 0;
    v3 = *(_BYTE *)(a2 - 5);
    v5[1] = *(_QWORD *)(a2 - 0x18);
    v6 = *(_DWORD *)(a2 - 0x10);
    v7 = *(_DWORD *)(a2 - 0xC);
    v8 = *(_WORD *)(a2 - 8);
    v9 = *(_BYTE *)(a2 - 6);
    v10 = v10 & 0xFE | v3 & 1;
    return sub_146C23A80(a1, n2 - 1, 0, (__int64)v5);
  }
  return result;
}

// --- End Function: sub_146C299A0 (0x146C299A0) ---

// --- Function: sub_146C2ED80 (0x146C2ED80) ---
void __fastcall sub_146C2ED80(__int64 *a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 v6; // rbx
  __int64 v7; // rdi
  char *n0x100; // rbx
  double v9; // xmm6_8
  int v10; // edi
  bool v11; // zf
  int v12; // ebp
  const void *v13; // rax
  char *v14; // rbp
  __int64 v15; // rsi
  char *n0x100_1; // rdi
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rdi
  __int64 v19; // rax
  __int64 *v20; // rdx
  __int64 *v21; // rcx
  __int64 v22; // rax
  char *n0x100_2; // rsi
  __int64 v24; // rcx
  void (__fastcall *v25)(__int64 *, __int64); // r9
  const char *v26; // [rsp+88h] [rbp+10h] BYREF
  __int64 v27; // [rsp+90h] [rbp+18h] BYREF

  sub_14035E090(&v26);
  if ( a3 )
  {
    v6 = a3;
    do
    {
      sub_140387CB0((__int64)&v26, (__int64)"  ");
      --v6;
    }
    while ( v6 );
  }
  v7 = *a2 & 0xFFFFFFFFFFFFLL;
  n0x100 = 0;
  v9 = *(double *)(*(_QWORD *)(v7 + 0x330) + 0x18LL);
  if ( (*(_BYTE *)(v7 + 0x4F8) & 3) != 0 )
  {
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(v7 + 0x4E0))
      || (v11 = *(_QWORD *)(v7 + 0x4E8) == *(_QWORD *)(v7 + 0x18), v10 = 1, !v11) )
    {
      v10 = 0;
    }
  }
  else
  {
    v10 = 1;
  }
  v12 = (unsigned __int8)sub_146C65180(*a2 & 0xFFFFFFFFFFFFLL);
  if ( is_entity_descriptor_valid_or_accessible(a2) )
    v13 = (const void *)(*a2 & 0xFFFFFFFFFFFFLL);
  else
    v13 = 0;
  LogTraceConditional(
    "%s %4d %s (%p), AggGroup %d Agg %d Radius %f",
    v26,
    a3,
    *(const char **)((*a2 & 0xFFFFFFFFFFFFLL) + 0x298),
    v13,
    v12,
    v10,
    v9);
  v14 = 0;
  v15 = *a2 & 0xFFFFFFFFFFFFLL;
  n0x100_1 = 0;
  v17 = (__int64)(*(_QWORD *)(v15 + 0x308) - *(_QWORD *)(v15 + 0x300)) >> 3;
  if ( v17 )
  {
    if ( v17 > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v18 = 8 * v17;
    if ( 8 * v17 < 0x1000 )
    {
      if ( v18 )
        n0x100 = (char *)sub_1402A65A0(8 * v17);
    }
    else
    {
      if ( v18 + 0x27 < v18 )
        sub_1402E3880();
      v19 = sub_1402A65A0(v18 + 0x27);
      if ( !v19 )
        goto LABEL_33;
      n0x100 = (char *)((v19 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      *((_QWORD *)n0x100 + 0xFFFFFFFF) = v19;
    }
    v20 = *(__int64 **)(v15 + 0x308);
    v14 = &n0x100[v18];
    v21 = *(__int64 **)(v15 + 0x300);
    for ( n0x100_1 = n0x100; v21 != v20; n0x100_1 += 8 )
    {
      v22 = *v21++;
      *(_QWORD *)n0x100_1 = v22;
    }
  }
  sub_146C25650(n0x100, n0x100_1, (n0x100_1 - n0x100) >> 3, (unsigned __int8)v26);
  for ( n0x100_2 = n0x100; n0x100_2 != n0x100_1; n0x100_2 += 8 )
  {
    v24 = *a1;
    v27 = *(_QWORD *)n0x100_2;
    v25 = *(void (__fastcall **)(__int64 *, __int64))v24;
    if ( *(_QWORD *)(v24 + 8) == 1 )
      v25(&v27, a3 + 1);
    else
      ((void (__fastcall *)(__int64, __int64 *, __int64))v25)(v24, &v27, a3 + 1);
  }
  if ( n0x100 )
  {
    if ( ((v14 - n0x100) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_31:
      sub_1402A6590((__int64)n0x100);
      goto LABEL_32;
    }
    if ( (unsigned __int64)&n0x100[-*((_QWORD *)n0x100 + 0xFFFFFFFF) - 8] <= 0x1F )
    {
      n0x100 = (char *)*((_QWORD *)n0x100 + 0xFFFFFFFF);
      goto LABEL_31;
    }
LABEL_33:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_32:
  sub_140373CC0(&v26);
}

// --- End Function: sub_146C2ED80 (0x146C2ED80) ---

// --- Function: sub_146C3ADD0 (0x146C3ADD0) ---
__int64 sub_146C3ADD0()
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E000 + 0x270LL))(qword_149C8E000);
}

// --- End Function: sub_146C3ADD0 (0x146C3ADD0) ---

// --- Function: sub_146C3B130 (0x146C3B130) ---
void __fastcall sub_146C3B130(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 v3; // rax
  __int64 *v4; // rcx
  unsigned __int64 v5; // [rsp+30h] [rbp+8h] BYREF

  v3 = *a2;
  v4 = *(__int64 **)(a1 + 0x10);
  *a2 = 0;
  v5 = v3;
  sub_146C2ED80(v4, &v5, a3);
}

// --- End Function: sub_146C3B130 (0x146C3B130) ---

// --- Function: sub_146C3B9A0 (0x146C3B9A0) ---
void __fastcall sub_146C3B9A0(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      a2[1] = 1;
    }
    else
    {
      a2[2] = sub_1402A65A0(1u);
      *a2 = sub_146C3ADD0;
      a2[1] = sub_146C3B9A0;
    }
  }
}

// --- End Function: sub_146C3B9A0 (0x146C3B9A0) ---

// --- Function: sub_146C3C390 (0x146C3C390) ---
void __fastcall sub_146C3C390(
        int a1,
        void (__fastcall **a2)(__int64 a1, unsigned __int64 *a2, __int64 a3),
        void (__fastcall **a3)(__int64 a1, unsigned __int64 *a2, __int64 a3))
{
  int v4; // ecx
  void (__fastcall *v5)(__int64, unsigned __int64 *, __int64); // rdi
  void (__fastcall *v6)(__int64, unsigned __int64 *, __int64); // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64, unsigned __int64 *, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64, unsigned __int64 *, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (void (__fastcall *)(__int64, unsigned __int64 *, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (void (__fastcall *)(__int64, unsigned __int64 *, __int64))1;
      }
      else
      {
        v6 = (void (__fastcall *)(__int64, unsigned __int64 *, __int64))sub_1402A65A0(8u);
        if ( v6 )
          *(_QWORD *)v6 = *(_QWORD *)v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_146C3B130;
        a2[1] = (void (__fastcall *)(__int64, unsigned __int64 *, __int64))sub_146C3C390;
      }
    }
  }
}

// --- End Function: sub_146C3C390 (0x146C3C390) ---

// --- Function: sub_146C43CB0 (0x146C43CB0) ---
__int64 __fastcall sub_146C43CB0(__int64 a1, char a2)
{
  __int64 v2; // rdi
  int v5; // ebx
  __int64 v6; // r8
  unsigned __int64 v7; // rax
  double *v8; // rax
  unsigned __int64 v9; // rbp
  double v10; // xmm2_8
  double v11; // xmm1_8
  double v12; // xmm0_8
  unsigned __int128 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // r15
  __int64 v16; // rbx
  int v17; // r9d
  int v18; // eax
  unsigned __int64 n0x200000; // rax
  double v21[3]; // [rsp+30h] [rbp-88h] BYREF
  __m128 v22; // [rsp+48h] [rbp-70h] BYREF
  double v23; // [rsp+58h] [rbp-60h]
  __m128 v24; // [rsp+60h] [rbp-58h] BYREF
  double v25; // [rsp+70h] [rbp-48h]

  v2 = a1 + 8;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v5 )
  {
    ++*(_DWORD *)(v2 + 0x14);
  }
  else
  {
    v6 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v7 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( v7 )
      sub_1403E1120(v2, v7, v6, "CEntityAggregateManager::DebugDraw", "m_UpdateQueueLock", 1);
    else
      *(_QWORD *)(v2 + 8) = v6;
    *(_DWORD *)(v2 + 0x10) = v5;
  }
  sub_146C92A20(a1);
  v8 = (double *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x60LL))(gEnv);
  v9 = 0;
  v10 = v8[0xB];
  v11 = v8[7];
  v12 = v8[3];
  v13 = *(unsigned __int64 *)(a1 + 0x40) * (unsigned __int128)0x7E460ADA04EEBC6DuLL;
  v21[0] = v12;
  v21[1] = v11;
  v21[2] = v10;
  if ( *((_QWORD *)&v13 + 1) >> 0xD )
  {
    v14 = 0;
    do
    {
      v15 = *(_QWORD *)(a1 + 0x20);
      if ( *(_DWORD *)(v14 + v15) == 2 )
      {
        v16 = *(_QWORD *)(v14 + v15 + 8);
        (*(void (__fastcall **)(__int64, __m128 *, double *))(*(_QWORD *)v16 + 0xF8LL))(v16, &v22, v21);
        v25 = v23 + 1.099511627776e12;
        v24 = _mm_add_pd((__m128)xmmword_148D6F0A0, v22);
        sub_146C46F90(v14 + v15 + 0x4018, v14 + v15 + 0x4018, (unsigned int)&v24, v17, v16, a2);
      }
      ++v9;
      *(_QWORD *)&v13 = 0x7E460ADA04EEBC6DLL * *(_QWORD *)(a1 + 0x40);
      v14 += 0x40E0;
    }
    while ( v9 < *(_QWORD *)(a1 + 0x40) / 0x40E0uLL );
  }
  if ( v2 )
  {
    v18 = *(_DWORD *)(v2 + 0x14);
    if ( v18 )
    {
      *(_QWORD *)&v13 = (unsigned int)(v18 - 1);
      *(_DWORD *)(v2 + 0x14) = v13;
    }
    else
    {
      *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        *(_QWORD *)&v13 = &p_Src;
        *(_QWORD *)(v2 + 8) = &p_Src;
      }
      else
      {
        *(_QWORD *)&v13 = rw_lock_handle_write_release_contention(v2, n0x200000);
      }
    }
  }
  return v13;
}

// --- End Function: sub_146C43CB0 (0x146C43CB0) ---

// --- Function: sub_146C43ED0 (0x146C43ED0) ---
double *__fastcall sub_146C43ED0(__int64 a1, __int64 *a2, float a3, int *a4)
{
  __int128 v4; // xmm7
  __int128 v5; // xmm10
  __int128 v6; // xmm12
  __int128 v7; // xmm13
  __int128 v8; // xmm14
  __int128 v9; // xmm15
  __int64 v10; // rbx
  int v11; // esi
  int *v12; // r12
  __int64 *v13; // r14
  __int64 v14; // rax
  __int64 v15; // rcx
  double *result; // rax
  double v18; // xmm10_8
  double v19; // xmm14_8
  char v20; // r13
  float v21; // xmm13_4
  __int64 v22; // rcx
  __int64 v23; // rbx
  _QWORD *v24; // rax
  _QWORD *v27; // rax
  int **v28; // rcx
  _QWORD *v29; // rax
  __int128 n0x3F800000; // xmm8
  __int64 v31; // rax
  _QWORD *v32; // rax
  __int64 v33; // rcx
  __int64 v34; // rax
  _QWORD *v35; // rax
  __int64 v36; // rax
  __int64 v37; // rax
  const char **v38; // rax
  unsigned __int64 v39; // r8
  float *v40; // rdx
  float v41; // xmm11_4
  float v42; // xmm12_4
  float v43; // xmm9_4
  __int64 v44; // r13
  __int64 v45; // rax
  char *SubStr_2; // r9
  const void *v47; // rdi
  size_t n0x1FF_6; // rbx
  char *SubStr_1; // rax
  char i; // r8
  char v51; // cl
  __int64 v52; // r12
  __int64 v53; // rdi
  __int64 v54; // rax
  __int64 (__fastcall *v55)(__int64, __int64 *, __int64); // rbx
  __int64 v56; // rax
  void **v57; // rax
  __int64 (__fastcall *v58)(__int64, __int64); // rbx
  __int64 v59; // rax
  const char *v60; // rax
  const void **v61; // r14
  __int64 n0x1FF_14; // rax
  size_t n0x1FF_10; // rbx
  unsigned __int64 allocSize; // rdi
  _BYTE *v65; // rax
  char *Str_1; // r9
  char v67; // r8
  char v68; // cl
  __int64 v69; // rax
  double *v70; // rax
  const char *p_NONE; // rbx
  __int64 v72; // rcx
  __int128 v73; // kr00_16
  _WORD *v77; // rcx
  __int64 v78; // rax
  __int64 v79; // rax
  const void *v80; // rcx
  unsigned __int64 v81; // rax
  _WORD *v82; // rcx
  float v83; // xmm6_4
  __int64 v84; // rax
  double v85; // kr00_8
  __int64 v86; // rax
  _LocaleUpdate *v87; // rdi
  const void *v88; // rbx
  double v89; // xmm0_8
  __int64 v92; // rax
  float v95; // xmm8_4
  int v96; // ecx
  float v97; // xmm10_4
  float v99; // xmm11_4
  float v101; // xmm9_4
  float v102; // xmm7_4
  __int64 v103; // rdi
  __int64 v104; // rcx
  void (__fastcall *v105)(__int64, _BYTE *, __int64, _QWORD, unsigned int *, __int64 *, unsigned int); // rbx
  __int64 v106; // rax
  double v107; // xmm0_8
  double v108; // xmm1_8
  double v109; // xmm2_8
  double v110; // xmm3_8
  double v111; // xmm4_8
  double v112; // xmm5_8
  __int64 v113; // rbx
  __int64 (__fastcall *v114)(__int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v116; // rbx
  __int64 v117; // rax
  __int16 n4; // dx
  __int64 v119; // rax
  __m128 v122; // kr00_16
  __m128 v124; // xmm2
  __int64 v125; // [rsp+20h] [rbp-E0h]
  __int64 v126; // [rsp+20h] [rbp-E0h]
  unsigned int v127; // [rsp+40h] [rbp-C0h] BYREF
  __int128 v128; // [rsp+48h] [rbp-B8h] BYREF
  double v129; // [rsp+58h] [rbp-A8h]
  __int64 v130; // [rsp+60h] [rbp-A0h] BYREF
  int *v131; // [rsp+68h] [rbp-98h] BYREF
  __int16 n0xFFFF_1; // [rsp+70h] [rbp-90h] BYREF
  __int64 v133; // [rsp+78h] [rbp-88h] BYREF
  _QWORD v134[2]; // [rsp+80h] [rbp-80h] BYREF
  __int128 v135; // [rsp+90h] [rbp-70h] BYREF
  double v136; // [rsp+A0h] [rbp-60h]
  void *v137; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v138; // [rsp+B8h] [rbp-48h]
  _BYTE v139[16]; // [rsp+C0h] [rbp-40h] BYREF
  int v140; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v141; // [rsp+D4h] [rbp-2Ch]
  int v142; // [rsp+DCh] [rbp-24h]
  __int64 v143; // [rsp+F0h] [rbp-10h]
  __int64 v144; // [rsp+F8h] [rbp-8h]
  __int64 v145; // [rsp+100h] [rbp+0h]
  unsigned int v146; // [rsp+114h] [rbp+14h]
  unsigned int v147; // [rsp+118h] [rbp+18h]
  int v148; // [rsp+11Ch] [rbp+1Ch]
  unsigned __int64 v149; // [rsp+120h] [rbp+20h]
  float v150; // [rsp+128h] [rbp+28h]
  int v151; // [rsp+12Ch] [rbp+2Ch]
  char v152[8]; // [rsp+130h] [rbp+30h] BYREF
  _BYTE v153[24]; // [rsp+138h] [rbp+38h] BYREF
  double v154; // [rsp+150h] [rbp+50h]
  double v155; // [rsp+158h] [rbp+58h]
  double v156; // [rsp+160h] [rbp+60h]
  size_t n0x1FF_11; // [rsp+170h] [rbp+70h]
  __int64 n0x1FF_9; // [rsp+178h] [rbp+78h]
  void *v159; // [rsp+180h] [rbp+80h]
  _BYTE v160[520]; // [rsp+188h] [rbp+88h] BYREF
  unsigned __int64 v161; // [rsp+390h] [rbp+290h] BYREF
  __int64 n0x1FF; // [rsp+398h] [rbp+298h]
  _BYTE *v163; // [rsp+3A0h] [rbp+2A0h]
  _BYTE v164[520]; // [rsp+3A8h] [rbp+2A8h] BYREF
  size_t n0x1FF_7; // [rsp+5B0h] [rbp+4B0h]
  __int64 n0x1FF_5; // [rsp+5B8h] [rbp+4B8h]
  char *SubStr; // [rsp+5C0h] [rbp+4C0h]
  _BYTE v168[520]; // [rsp+5C8h] [rbp+4C8h] BYREF
  __int64 v169; // [rsp+7D0h] [rbp+6D0h] BYREF
  __int64 n0x1FF_12; // [rsp+7D8h] [rbp+6D8h]
  char *Str; // [rsp+7E0h] [rbp+6E0h]
  _BYTE v172[520]; // [rsp+7E8h] [rbp+6E8h] BYREF
  unsigned __int64 v173; // [rsp+9F0h] [rbp+8F0h] BYREF
  __int64 n0x1FF_8; // [rsp+9F8h] [rbp+8F8h]
  const char *v175; // [rsp+A00h] [rbp+900h]
  _BYTE v176[520]; // [rsp+A08h] [rbp+908h] BYREF
  __int64 v177; // [rsp+C10h] [rbp+B10h] BYREF
  __int64 n0x1FF_1; // [rsp+C18h] [rbp+B18h]
  _BYTE *v179; // [rsp+C20h] [rbp+B20h]
  _BYTE v180[520]; // [rsp+C28h] [rbp+B28h] BYREF
  __int64 v181; // [rsp+E30h] [rbp+D30h] BYREF
  __int64 n0x1FF_2; // [rsp+E38h] [rbp+D38h]
  _BYTE *v183; // [rsp+E40h] [rbp+D40h]
  _BYTE v184[520]; // [rsp+E48h] [rbp+D48h] BYREF
  __int64 v185; // [rsp+1050h] [rbp+F50h] BYREF
  __int64 n0x1FF_13; // [rsp+1058h] [rbp+F58h]
  _BYTE *v187; // [rsp+1060h] [rbp+F60h]
  _BYTE v188[520]; // [rsp+1068h] [rbp+F68h] BYREF
  __int64 v189; // [rsp+1270h] [rbp+1170h] BYREF
  __int64 n0x1FF_4; // [rsp+1278h] [rbp+1178h]
  _BYTE *v191; // [rsp+1280h] [rbp+1180h]
  _BYTE v192[520]; // [rsp+1288h] [rbp+1188h] BYREF
  __int64 v193; // [rsp+1490h] [rbp+1390h] BYREF
  __int64 n0x1FF_3; // [rsp+1498h] [rbp+1398h]
  _BYTE *v195; // [rsp+14A0h] [rbp+13A0h]
  _BYTE v196[520]; // [rsp+14A8h] [rbp+13A8h] BYREF
  __int128 v197; // [rsp+16C0h] [rbp+15C0h]
  __int128 v198; // [rsp+16D0h] [rbp+15D0h]
  __int128 v199; // [rsp+16E0h] [rbp+15E0h]
  __int128 v200; // [rsp+16F0h] [rbp+15F0h]
  __int128 v201; // [rsp+1710h] [rbp+1610h]
  __int128 v202; // [rsp+1740h] [rbp+1640h]

  v202 = v4;
  v201 = v5;
  v198 = v8;
  v197 = v9;
  v10 = a1;
  v130 = a1;
  v11 = 0;
  v131 = a4;
  v127 = 0;
  v12 = a4;
  v13 = a2;
  v134[0] = a2;
  v14 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x590LL))(qword_149C8E018);
  v15 = *v13;
  v138 = v14;
  result = (double *)sub_146C5D7C0(v15 & 0xFFFFFFFFFFFFLL, &v140, 0);
  _XMM15 = *((unsigned __int64 *)result + 3);
  v18 = result[0xB];
  v19 = result[7];
  *(double *)&v153[0x10] = v18;
  if ( *(double *)&_XMM15 != 0.0 || v19 != 0.0 || v18 != 0.0 )
  {
    v20 = 1;
    v200 = v6;
    v199 = v7;
    v21 = 1.2;
    v164[0] = 0;
    v163 = v164;
    v161 = 0;
    n0x1FF = 0x1FF;
    if ( !dword_1516F1EC0 && !n2_5 )
    {
      v22 = *v13 & 0xFFFFFFFFFFFFLL;
      if ( a3 < 0.0 )
      {
        v38 = (const char **)sub_146C556B0(v22, &v131);
        sub_1404B0960((__int64)&v161, "%s\n", *v38);
        sub_140373CC0(&v131);
        v127 = 0xFF00FFFF;
        n0x3F800000 = 0x3F800000u;
      }
      else
      {
        v23 = sub_146C5B680(v22);
        if ( v23 )
        {
          v24 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                            qword_149C8DF80,
                            0);
          v131 = *(int **)(v23 + 0x188);
          sub_14059CA60(v24, &v133, &v131);
          _XMM0 = sub_14059CC00();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          v27 = (_QWORD *)sub_146C556B0(*v13 & 0xFFFFFFFFFFFFLL, v134);
          sub_1404B0960((__int64)&v161, "%.3f ms : %s (%0.2f ago)\n", a3, *v27, *(float *)&_XMM1);
          v28 = (int **)v134;
        }
        else
        {
          v29 = (_QWORD *)sub_146C556B0(*v13 & 0xFFFFFFFFFFFFLL, &v131);
          sub_1404B0960((__int64)&v161, "%.3f ms : %s\n", a3, *v29);
          v28 = &v131;
        }
        sub_140373CC0(v28);
        if ( a3 <= 0.5 )
        {
          v21 = 1.1;
          if ( sub_146C586A0(*v13 & 0xFFFFFFFFFFFFLL) )
          {
            v31 = sub_146C586A0(*v13 & 0xFFFFFFFFFFFFLL);
            v32 = sub_142E61D20(v31, &v133);
            if ( HIWORD_w(v32) )
            {
              v33 = *v13 & 0xFFFFFFFFFFFFLL;
              v140 = 1;
              v150 = 0.0;
              v141 = 0xFFFFFFFFFFFFFFFFuLL;
              v142 = 0;
              v148 = 0;
              v151 = 0;
              v149 = 0xFFFFFFFFFFFFFFFFuLL;
              HIDWORD(v143) = 0xFFF7FFFF;
              v146 = 0xFFBFFFFF;
              v147 = 0xFFBFFFFF;
              v34 = sub_146C586A0(v33);
              v35 = sub_142E61D20(v34, &v133);
              (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)(*v35 & 0xFFFFFFFFFFFFLL) + 0x28LL))(
                *v35 & 0xFFFFFFFFFFFFLL,
                &v140);
              v180[0] = 0;
              v179 = v180;
              v177 = 0;
              n0x1FF_1 = 0x1FF;
              v36 = sub_1404B0960((__int64)&v177, "Physics: %8.5f %8.5f %8.5f\n", v143, v144, v145);
              sub_1402E13B0(&v161, *(const void **)(v36 + 0x10), *(_QWORD *)v36);
              if ( v179 != v180 )
              {
                qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
                sub_147715880(v179);
              }
            }
          }
          sub_146C58D00(*v13 & 0xFFFFFFFFFFFFLL, (__int64)&v128, 2u, 0);
          v184[0] = 0;
          v183 = v184;
          v181 = 0;
          n0x1FF_2 = 0x1FF;
          v37 = sub_1404B0960((__int64)&v181, "Entity:  %8.5f %8.5f %8.5f\n", v128, v129);
          sub_1402E13B0(&v161, *(const void **)(v37 + 0x10), *(_QWORD *)v37);
          if ( v183 != v184 )
          {
            qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_2;
            sub_147715880(v183);
          }
        }
        else
        {
          v21 = 1.3;
        }
        v10 = v130;
        v127 = 0xFF00FFFF;
        n0x3F800000 = 0x3F800000u;
      }
LABEL_73:
      if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DE8 + 0x10LL))(qword_1516F1DE8) )
        goto LABEL_92;
      v70 = (double *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v10 + 0xE0) + 0x3D0LL))(*(_QWORD *)(v10 + 0xE0));
      p_NONE = "NONE";
      v72 = *v13 & 0xFFFFFFFFFFFFLL;
      v129 = 0.0;
      *((_QWORD *)&v73 + 1) = *((_QWORD *)&_XMM15 + 1);
      *(double *)&v73 = (*(double *)&_XMM15 - v70[3]) * (*(double *)&_XMM15 - v70[3])
                      + (v19 - v70[7]) * (v19 - v70[7])
                      + (v18 - v70[0xB]) * (v18 - v70[0xB]);
      _XMM2 = v73;
      __asm
      {
        vmovddup xmm0, xmm2
        vsqrtpd xmm7, xmm0
      }
      v128 = 0;
      if ( *v12 )
      {
        sub_146C71280(v72, &v128);
        v82 = (_WORD *)v128;
        if ( (_QWORD)v128 != *((_QWORD *)&v128 + 1) )
        {
          while ( *v82 != *(_WORD *)((*v13 & 0xFFFFFFFFFFFFLL) + 0x124) )
          {
            if ( ++v82 == *((_WORD **)&v128 + 1) )
              goto LABEL_87;
          }
          p_NONE = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(qword_149C8DFC8);
        }
LABEL_87:
        v83 = *(float *)((*v13 & 0xFFFFFFFFFFFFLL) + 0x120);
        v84 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x738LL))(qword_149C8DFE0);
        v196[0] = 0;
        v193 = 0;
        v85 = v83 * *(double *)(v84 + 0x58);
        n0x1FF_3 = 0x1FF;
        v195 = v196;
        __asm { vmovhpd [rsp+1790h+var_1770], xmm7 }
        v86 = sub_1404B0960(
                (__int64)&v193,
                "Streaming Radius: %f\n\tDefined by: %s\n\tDistance: %.2f\n\tExpected stream out distance: %.2f",
                *(float *)((*v13 & 0xFFFFFFFFFFFFLL) + 0x120),
                p_NONE,
                v126,
                v85);
        sub_1402E13B0(&v161, *(const void **)(v86 + 0x10), *(_QWORD *)v86);
        v80 = v195;
        if ( v195 == v196 )
          goto LABEL_90;
        v81 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_3;
      }
      else
      {
        sub_146C71280(v72, &v128);
        v77 = (_WORD *)v128;
        if ( (_QWORD)v128 != *((_QWORD *)&v128 + 1) )
        {
          while ( *v77 != *(_WORD *)((*v13 & 0xFFFFFFFFFFFFLL) + 0x126) )
          {
            if ( ++v77 == *((_WORD **)&v128 + 1) )
              goto LABEL_80;
          }
          p_NONE = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC8 + 0x20LL))(qword_149C8DFC8);
        }
LABEL_80:
        v192[0] = 0;
        v191 = v192;
        v78 = *v13 & 0xFFFFFFFFFFFFLL;
        v189 = 0;
        n0x1FF_4 = 0x1FF;
        __asm { vmovhpd [rsp+1790h+var_1770], xmm7 }
        v79 = sub_1404B0960(
                (__int64)&v189,
                "Rendering Radius: %f\n\tDefined by: %s\n\tDistance: %.2f\n\t",
                *(float *)(v78 + 0x11C),
                p_NONE,
                v125);
        sub_1402E13B0(&v161, *(const void **)(v79 + 0x10), *(_QWORD *)v79);
        v80 = v191;
        if ( v191 == v192 )
          goto LABEL_90;
        v81 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_4;
      }
      qword_149C78668 += v81;
      sub_147715880(v80);
LABEL_90:
      if ( (_QWORD)v128 )
        sub_1403A6820((__int64)&v128, v128, 2 * ((__int64)(*(_QWORD *)&v129 - v128) >> 1));
LABEL_92:
      if ( v161 )
      {
        v87 = qword_149C8E018;
        v88 = v163;
        v89 = (*(double (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x208LL))(qword_149C8E018);
        __asm
        {
          vinsertps xmm8, xmm8, xmm11, 10h
          vunpcklpd xmm1, xmm15, xmm14
        }
        v136 = *(double *)&v153[0x10];
        v135 = _XMM1;
        v92 = *(_QWORD *)v87;
        __asm
        {
          vinsertps xmm8, xmm8, xmm12, 20h ; ' '
          vinsertps xmm8, xmm8, xmm9, 30h ; '0'
        }
        *(_DWORD *)v153 = 0x61;
        *(float *)&v154 = *(float *)&v89 * v21;
        *(float *)&v153[0x14] = *(float *)&v89 * v21;
        v128 = _XMM8;
        *(_OWORD *)&v153[4] = _XMM8;
        (*(void (__fastcall **)(_LocaleUpdate *, __int128 *, _BYTE *, const void *))(v92 + 0x550))(
          v87,
          &v135,
          v153,
          v88);
      }
      if ( !v20 )
        goto LABEL_121;
      v95 = -9.9999999e14;
      v96 = *v12;
      v128 = xmmword_148348F30;
      v97 = -9.9999999e14;
      if ( v96 )
      {
        if ( v96 != 1 )
        {
          v99 = *((float *)&v128 + 3);
          _XMM6.m128_i32[0] = v128;
          goto LABEL_99;
        }
        _XMM1 = (__m128)*(unsigned int *)((*v13 & 0xFFFFFFFFFFFFLL) + 0x120);
      }
      else
      {
        if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DF0 + 0x10LL))(qword_1516F1DF0) )
        {
          v113 = *v13 & 0xFFFFFFFFFFFFLL;
          v114 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v113 + 0x340LL);
          n0xFFFF = n0xFFFF_35;
          if ( n0xFFFF_35 == (__int16)0xFFFF )
          {
            n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                            + 0x10LL))(
                                  qword_149C8DFC8,
                                  &v130,
                                  "RenderProxy");
            n0xFFFF_35 = n0xFFFF;
          }
          n0xFFFF_1 = n0xFFFF;
          v116 = *(_QWORD *)v114(v113, v139, &n0xFFFF_1);
          v133 = v116;
          if ( v116 )
          {
            v117 = sub_1403B84E0(v116 & 0xFFFFFFFFFFFFLL);
            n4 = *(_WORD *)(v117 + 4);
            if ( n4 != 4
              && *(_WORD *)(v117 + 2) == (HIWORD(v116) & 0xFFF)
              && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v133)) )
            {
              v119 = sub_146BC11D0(v116 & 0xFFFFFFFFFFFFLL, (__int64)v153);
              _XMM6 = *(__m128 *)v119;
              *(_QWORD *)&_XMM0 = *(_QWORD *)(v119 + 0x10);
              goto LABEL_115;
            }
          }
        }
        _XMM1 = (__m128)*(unsigned int *)((*v13 & 0xFFFFFFFFFFFFLL) + 0x11C);
      }
      v122 = _mm_shuffle_ps(_XMM1, _XMM1, 0);
      v122.m128_i32[0] = _XMM1.m128_i32[0] ^ 0x80000000;
      _XMM6 = v122;
      __asm
      {
        vinsertps xmm6, xmm6, xmm0, 10h
        vinsertps xmm6, xmm6, xmm0, 20h ; ' '
        vunpcklps xmm0, xmm1, xmm1
      }
LABEL_115:
      v129 = *(double *)&_XMM0;
      v95 = *(float *)&v129;
      v97 = *((float *)&v129 + 1);
      v99 = _mm_shuffle_ps(_XMM6, _XMM6, 0xFF).m128_f32[0];
      v128 = (__int128)_XMM6;
      if ( _XMM6.m128_f32[0] == v99 )
      {
        v101 = _mm_shuffle_ps(_XMM6, _XMM6, 0x55).m128_f32[0];
        if ( v101 == *(float *)&v129 )
        {
          v102 = _mm_shuffle_ps(_XMM6, _XMM6, 0xAA).m128_f32[0];
          if ( v102 == *((float *)&v129 + 1) )
          {
            v124 = (__m128)xmmword_148D6F090;
            v95 = 0.1;
            v97 = 0.1;
            LODWORD(v99) = _mm_shuffle_ps(v124, v124, 0xFF).m128_u32[0];
            LODWORD(v102) = _mm_shuffle_ps(v124, v124, 0xAA).m128_u32[0];
            LODWORD(v101) = _mm_shuffle_ps(v124, v124, 0x55).m128_u32[0];
            _XMM6.m128_i32[0] = 0xBDCCCCCD;
          }
          goto LABEL_101;
        }
LABEL_100:
        v102 = *((float *)&v128 + 2);
LABEL_101:
        v103 = v138;
        v104 = *v13 & 0xFFFFFFFFFFFFLL;
        LODWORD(v130) = 1;
        v105 = *(void (__fastcall **)(__int64, _BYTE *, __int64, _QWORD, unsigned int *, __int64 *, unsigned int))(*(_QWORD *)v138 + 0xA0LL);
        v106 = sub_146C5D7C0(v104, &v140, 0);
        if ( _XMM6.m128_f32[0] <= v99 )
        {
          v107 = _XMM6.m128_f32[0];
          v109 = v101;
          v110 = v102;
          v108 = v99;
          v111 = v95;
          v112 = v97;
        }
        else
        {
          v107 = 1.0e150;
          v108 = -1.0e150;
          v109 = 1.0e150;
          v110 = 1.0e150;
          v111 = -1.0e150;
          v112 = -1.0e150;
        }
        *(double *)v153 = v107;
        *(double *)&v153[8] = v109;
        *(double *)&v153[0x10] = v110;
        v154 = v108;
        v155 = v111;
        v156 = v112;
        v105(v103, v153, v106, 0, &v127, &v130, 0xFFFFFFFF);
LABEL_121:
        result = (double *)v164;
        if ( v163 != v164 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
          return (double *)sub_147715880(v163);
        }
        return result;
      }
LABEL_99:
      v101 = *((float *)&v128 + 1);
      goto LABEL_100;
    }
    v39 = *(_QWORD *)((*v13 & 0xFFFFFFFFFFFFLL) + 0x10);
    v40 = (float *)((char *)&unk_148D6C990 + 0x10 * (v39 % 9));
    n0x3F800000 = *(unsigned int *)v40;
    v41 = v40[1];
    v42 = v40[2];
    v43 = v40[3];
    if ( n2_5 )
    {
      v44 = sub_146C73360(*v13 & 0xFFFFFFFFFFFFLL, 0);
      if ( sub_1403BDD40(v44) )
      {
        v45 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DE0 + 0x28LL))(qword_1516F1DE0);
        SubStr_2 = v168;
        v168[0] = 0;
        SubStr = v168;
        v47 = (const void *)v45;
        n0x1FF_7 = 0;
        n0x1FF_5 = 0x1FF;
        if ( v45 )
        {
          n0x1FF_6 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++n0x1FF_6;
          while ( *(_BYTE *)(v45 + n0x1FF_6) );
          if ( n0x1FF_6 )
          {
            SubStr_1 = v168;
            if ( n0x1FF_6 + 1 > 0x200 )
            {
              SubStr_1 = (char *)allocWithProfilerInfo(n0x1FF_6 + 1, 0);
              qword_149C78668 += n0x1FF_6 + 1;
              n0x1FF_5 = n0x1FF_6;
            }
            SubStr = SubStr_1;
            n0x1FF_7 = n0x1FF_6;
            SubStr_1[n0x1FF_6] = 0;
            memcpy(SubStr, v47, n0x1FF_6);
            SubStr_2 = SubStr;
            v13 = (__int64 *)v134[0];
          }
        }
        for ( i = *SubStr_2; *SubStr_2; i = *SubStr_2 )
        {
          ++SubStr_2;
          v51 = i + 0x20;
          if ( (unsigned __int8)(i - 0x41) > 0x19u )
            v51 = i;
          SubStr_2[0xFFFFFFFF] = v51;
        }
        v176[0] = 0;
        v175 = v176;
        v173 = 0;
        v52 = 0;
        n0x1FF_8 = 0x1FF;
        if ( sub_1403BAC10(v44) )
        {
          while ( 1 )
          {
            v53 = qword_149C8DF38;
            v54 = *(_QWORD *)qword_149C8DF38;
            if ( n2_5 < 2 )
            {
              v58 = *(__int64 (__fastcall **)(__int64, __int64))(v54 + 0x40);
              v59 = sub_1403BABD0(v44, (__int64)v139, v52);
              v11 |= 2u;
              v60 = (const char *)v58(v53, v59);
              v57 = CreateStringObjectFromString(&v137, v60);
            }
            else
            {
              v55 = *(__int64 (__fastcall **)(__int64, __int64 *, __int64))(v54 + 0x48);
              v56 = sub_1403BABD0(v44, (__int64)v152, v52);
              v11 |= 1u;
              v57 = (void **)v55(v53, &v133, v56);
            }
            v61 = (const void **)v57;
            v160[0] = 0;
            n0x1FF_11 = 0;
            v159 = v160;
            n0x1FF_9 = 0x1FF;
            n0x1FF_14 = sub_1403EBE30(v57);
            n0x1FF_10 = n0x1FF_14;
            if ( n0x1FF_14 )
            {
              allocSize = n0x1FF_14 + 1;
              v65 = v160;
              if ( allocSize <= 0x200 )
              {
                n0x1FF_9 = 0x1FF;
              }
              else
              {
                v65 = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
                qword_149C78668 += allocSize;
                n0x1FF_9 = n0x1FF_10;
              }
              v159 = v65;
              n0x1FF_11 = n0x1FF_10;
              v65[n0x1FF_10] = 0;
              memcpy(v159, *v61, n0x1FF_10);
            }
            if ( (v11 & 2) != 0 )
            {
              v11 &= ~2u;
              sub_140373CC0(&v137);
            }
            if ( (v11 & 1) != 0 )
            {
              v11 &= ~1u;
              sub_140373CC0(&v133);
            }
            if ( !n0x1FF_7 )
              goto LABEL_57;
            Str = v172;
            v172[0] = 0;
            v169 = 0;
            n0x1FF_12 = 0x1FF;
            sub_1402A6440((__int64)&v169, v159, n0x1FF_11);
            Str_1 = Str;
            v67 = *Str;
            if ( *Str )
            {
              do
              {
                ++Str_1;
                v68 = v67 + 0x20;
                if ( (unsigned __int8)(v67 - 0x41) > 0x19u )
                  v68 = v67;
                Str_1[0xFFFFFFFF] = v68;
                v67 = *Str_1;
              }
              while ( *Str_1 );
              Str_1 = Str;
            }
            if ( strstr(Str_1, SubStr) )
              break;
            if ( Str != v172 )
            {
              qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_12;
              sub_147715880(Str);
            }
LABEL_60:
            if ( v159 != v160 )
            {
              qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_9;
              sub_147715880(v159);
            }
            if ( ++v52 >= (unsigned __int64)sub_1403BAC10(v44) )
            {
              v13 = (__int64 *)v134[0];
              goto LABEL_64;
            }
          }
          if ( Str != v172 )
          {
            qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_12;
            sub_147715880(Str);
          }
LABEL_57:
          if ( v173 )
            sub_1402E13B0(&v173, "\n", 1u);
          sub_1402E13B0(&v173, v159, n0x1FF_11);
          goto LABEL_60;
        }
LABEL_64:
        sub_1402A59F0((__int64)&v161, "Name: %s\nTags: %s\n", *(const char **)((*v13 & 0xFFFFFFFFFFFFLL) + 0x298), v175);
        if ( v175 != v176 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_8;
          sub_147715880(v175);
        }
        if ( SubStr != v168 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_5;
          sub_147715880(SubStr);
        }
        v10 = v130;
        v20 = 1;
        v12 = v131;
      }
      else
      {
        v20 = 0;
      }
    }
    else
    {
      v188[0] = 0;
      v187 = v188;
      v185 = 0;
      n0x1FF_13 = 0x1FF;
      v69 = sub_1404B0960((__int64)&v185, "EntityId: %llu\n", v39);
      sub_1402E13B0(&v161, *(const void **)(v69 + 0x10), *(_QWORD *)v69);
      if ( v187 != v188 )
      {
        qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_13;
        sub_147715880(v187);
      }
    }
    BYTE2(v127) = (int)(float)(v42 * 255.0);
    HIBYTE(v127) = (int)(float)(v43 * 255.0);
    LOBYTE(v127) = (int)(float)(*(float *)&n0x3F800000 * 255.0);
    BYTE1(v127) = (int)(float)(v41 * 255.0);
    goto LABEL_73;
  }
  return result;
}

// --- End Function: sub_146C43ED0 (0x146C43ED0) ---

// --- Function: sub_146C44F80 (0x146C44F80) ---
void sub_146C44F80()
{
  __int64 *v0; // rax
  __int64 v1; // rdi
  __int64 (__fastcall *v2)(__int64, unsigned __int64 *, _QWORD); // rbx
  __int64 v3; // rax
  _QWORD *v4; // rax
  unsigned __int64 v5; // rax
  int v6; // ebx
  char *p_p_Src; // r8
  unsigned __int64 v8; // rax
  int v9; // ebx
  char *p_p_Src_1; // r8
  unsigned __int64 v11; // rax
  unsigned __int64 n0x200000; // rax
  unsigned __int64 n0x200000_1; // rax
  void (__fastcall *p_sub_146C3B130)(__int64, unsigned __int64 *, __int64); // [rsp+30h] [rbp-38h] BYREF
  void (__fastcall *p_sub_146C3C390)(int, void (__fastcall **)(__int64, unsigned __int64 *, __int64), void (__fastcall **)(__int64, unsigned __int64 *, __int64)); // [rsp+38h] [rbp-30h]
  __int64 *v16; // [rsp+40h] [rbp-28h]
  unsigned __int64 v17; // [rsp+78h] [rbp+10h] BYREF
  unsigned __int64 v18; // [rsp+80h] [rbp+18h] BYREF

  if ( byte_1516F224E )
  {
    v0 = (__int64 *)sub_1402A65A0(8u);
    if ( v0 )
    {
      *v0 = (__int64)&p_sub_146C3B130;
      v16 = v0;
    }
    else
    {
      v16 = 0;
    }
    v1 = qword_149C8DFC0;
    p_sub_146C3B130 = sub_146C3B130;
    p_sub_146C3C390 = sub_146C3C390;
    v2 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x120LL);
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
    v4 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v3 + 0x1D8LL))(v3, &v17);
    v5 = *(_QWORD *)v2(v1, &v18, *v4);
    v17 = v5;
    if ( p_sub_146C3C390 == (void (__fastcall *)(int, void (__fastcall **)(__int64, unsigned __int64 *, __int64), void (__fastcall **)(__int64, unsigned __int64 *, __int64)))1 )
    {
      ((void (__fastcall *)(unsigned __int64 *, _QWORD))p_sub_146C3B130)(&v17, 0);
    }
    else if ( p_sub_146C3B130 == sub_146C3B130 )
    {
      v18 = v5;
      v17 = 0;
      sub_146C2ED80(v16, &v18, 0);
    }
    else
    {
      p_sub_146C3B130((__int64)&p_sub_146C3B130, &v17, 0);
    }
    byte_1516F224E = 0;
    if ( (unsigned __int64)p_sub_146C3C390 >= 2 )
      ((void (__fastcall *)(__int64, void (__fastcall **)(__int64, unsigned __int64 *, __int64)))p_sub_146C3C390)(
        2,
        &p_sub_146C3B130);
  }
  else if ( dword_1516F1EB0 )
  {
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( dword_149C026B8 == v6 )
    {
      ++dword_149C026BC;
    }
    else
    {
      p_p_Src = *(char **)(NtCurrentTeb_w() + 0x20);
      v8 = _InterlockedCompareExchange64(&rw_lock_state, 0x200000, 0);
      if ( v8 )
        sub_1403E1120(
          (__int64)&rw_lock_state,
          v8,
          (__int64)p_p_Src,
          "CEntitySystem::DebugDrawAggregates",
          "CEntity::s_aggregateHierarchyLock",
          1);
      else
        p_p_Src_0 = p_p_Src;
      dword_149C026B8 = v6;
    }
    v9 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( dword_149C026A0 == v9 )
    {
      ++dword_149C026A4;
    }
    else
    {
      p_p_Src_1 = *(char **)(NtCurrentTeb_w() + 0x20);
      v11 = _InterlockedCompareExchange64(&qword_149C02690, 0x200000, 0);
      if ( v11 )
        sub_1403E1120(
          (__int64)&qword_149C02690,
          v11,
          (__int64)p_p_Src_1,
          "CEntitySystem::DebugDrawAggregates",
          "CEntityAggregateRadius::s_aggregateRadiusHierarchyLock",
          1);
      else
        ::p_p_Src = p_p_Src_1;
      dword_149C026A0 = v9;
    }
    sub_146C43CB0(qword_1516F1F98, dword_1516F1EB0 != 1);
    if ( dword_149C026A4 )
    {
      --dword_149C026A4;
    }
    else
    {
      dword_149C026A0 = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(&qword_149C02690, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        ::p_p_Src = (char *)&p_Src;
      else
        rw_lock_handle_write_release_contention((__int64)&qword_149C02690, n0x200000);
    }
    if ( dword_149C026BC )
    {
      --dword_149C026BC;
    }
    else
    {
      dword_149C026B8 = 0xFFFFFFFF;
      n0x200000_1 = _InterlockedCompareExchange64(&rw_lock_state, 0, 0x200000);
      if ( n0x200000_1 == 0x200000 )
        p_p_Src_0 = (char *)&p_Src;
      else
        rw_lock_handle_write_release_contention((__int64)&rw_lock_state, n0x200000_1);
    }
  }
}

// --- End Function: sub_146C44F80 (0x146C44F80) ---

// --- Function: sub_146C45240 (0x146C45240) ---
const ULONG_PTR *__fastcall sub_146C45240(__int64 a1)
{
  const ULONG_PTR *result; // rax
  __int128 v3; // xmm8
  __int64 v4; // rbx
  int v5; // edi
  unsigned int v6; // eax
  _QWORD *v7; // rax
  _QWORD *v8; // rdi
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rax
  __int64 v12; // rsi
  __int64 v13; // rsi
  bool v14; // al
  _QWORD *v15; // rax
  __int64 *v16; // rbp
  __int128 v17; // kr00_16
  const char *v18; // rsi
  const char *v19; // rax
  int v20; // eax
  __int128 v21; // [rsp+50h] [rbp-E8h] BYREF
  __int128 v22; // [rsp+60h] [rbp-D8h] BYREF
  _QWORD v23[4]; // [rsp+70h] [rbp-C8h] BYREF
  _UNKNOWN *retaddr; // [rsp+138h] [rbp+0h] BYREF
  unsigned __int64 v25; // [rsp+148h] [rbp+10h] BYREF
  __int64 v26; // [rsp+150h] [rbp+18h]
  char v27; // [rsp+158h] [rbp+20h] BYREF

  result = (const ULONG_PTR *)&retaddr;
  if ( byte_149C8E515 )
  {
    v3 = 0;
    v21 = xmmword_1482BB410;
    sub_1402C7510(
      (__int64 *)qword_149C8E018,
      10.0,
      8.0,
      1.5,
      &v21,
      0,
      (__int64)"Active physicalized entities at origin:");
    v4 = a1 + 0xE8;
    v26 = a1 + 0xE8;
    v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0xF8) == v5 )
    {
      ++*(_DWORD *)(a1 + 0xFC);
    }
    else
    {
      v6 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
      if ( v6 )
        sub_1403C6E80(a1 + 0xE8, v6, (__int64)&p_Src, 1);
      else
        *(_QWORD *)(a1 + 0xF0) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0xF8) = v5;
    }
    v7 = *(_QWORD **)(a1 + 0x100);
    v8 = (_QWORD *)*v7;
    if ( (_QWORD *)*v7 != v7 )
    {
      do
      {
        v9 = v8[2];
        v25 = v9;
        if ( v9 )
        {
          v10 = v9;
          v11 = HIWORD(v9);
          v12 = v10 & 0xFFFFFFFFFFFFLL;
          v13 = (v11 & 0xF000) != 0 ? v12 & 0xFFFFFF000000LL : v12 - 6;
          if ( *(_WORD *)(v13 + 2) == (v11 & 0xFFF) )
          {
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v14 = is_thread_privileged_or_bypass_mode()) )
              v14 = 1;
            if ( *(_WORD *)(v13 + 4) == 2 && v14 || sub_140395410(&v25) )
            {
              v15 = (_QWORD *)sub_146C58840(v25 & 0xFFFFFFFFFFFFLL, &v27);
              if ( *v15 )
              {
                if ( *(_QWORD *)((*v15 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*v15)
                  && (*(_BYTE *)((v25 & 0xFFFFFFFFFFFFLL) + 8) & 1) == 0 )
                {
                  sub_146C58D00(v25 & 0xFFFFFFFFFFFFLL, (__int64)v23, 0, 0);
                  if ( COERCE_DOUBLE(v23[0] & 0x7FFFFFFFFFFFFFFFLL) < 250.0
                    && COERCE_DOUBLE(v23[1] & 0x7FFFFFFFFFFFFFFFLL) < 250.0
                    && COERCE_DOUBLE(v23[2] & 0x7FFFFFFFFFFFFFFFLL) < 250.0 )
                  {
                    v16 = (__int64 *)qword_149C8E018;
                    v17 = v3;
                    *(float *)&v17 = *(float *)&v3 + 25.0;
                    v3 = v17;
                    v18 = *(const char **)((v25 & 0xFFFFFFFFFFFFLL) + 0x298);
                    v19 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)((v25 & 0xFFFFFFFFFFFFLL) + 0x20)
                                                                          + 0x18LL))(*(_QWORD *)((v25 & 0xFFFFFFFFFFFFLL)
                                                                                               + 0x20));
                    v22 = xmmword_1482BB410;
                    sub_1402C7510(v16, 10.0, *(float *)&v17 + 8.0, 1.5, &v22, 0, (__int64)"[%s] %s", v19, v18);
                  }
                }
              }
            }
          }
        }
        v8 = (_QWORD *)*v8;
      }
      while ( v8 != *(_QWORD **)(a1 + 0x100) );
      v4 = v26;
    }
    v20 = *(_DWORD *)(v4 + 0x14);
    if ( v20 )
    {
      result = (const ULONG_PTR *)(unsigned int)(v20 - 1);
      *(_DWORD *)(v4 + 0x14) = (_DWORD)result;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      result = (const ULONG_PTR *)(unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
      if ( (_DWORD)result == 1 )
        *(_QWORD *)(v4 + 8) = &p_Src;
      else
        return sub_1403DF590(v4, (unsigned int)result);
    }
  }
  return result;
}

// --- End Function: sub_146C45240 (0x146C45240) ---

// --- Function: sub_146C45630 (0x146C45630) ---
_BYTE *__fastcall sub_146C45630(__int64 a1, int *a2)
{
  int v2; // r13d
  __int64 v3; // rcx
  double *v4; // rax
  double v5; // xmm9_8
  double v6; // xmm10_8
  double v7; // xmm11_8
  double v8; // xmm0_8
  float v9; // kr00_4
  __int64 v10; // rax
  char *SubStr_2; // r9
  const void *v12; // rdi
  size_t n0x1FF_1; // rbx
  char *SubStr_1; // rax
  char i; // r8
  char v16; // cl
  __int64 v17; // rax
  char *SubStr_6; // r9
  const void *v19; // rdi
  size_t n0x1FF_4; // rbx
  char *SubStr_5; // rax
  char j; // r8
  char v23; // cl
  _BYTE *v24; // rdi
  size_t n0x1FF_7; // rbx
  _BYTE *v26; // rax
  _BYTE *v27; // rdi
  size_t n0x1FF_10; // rbx
  char *SubStr_7; // rax
  char *SubStr_8; // r9
  char k; // r8
  char v32; // cl
  bool v33; // r14
  __int64 v34; // rsi
  __int64 v35; // rdi
  int v36; // ebx
  unsigned int v37; // eax
  _QWORD *v38; // rax
  _QWORD *v39; // rsi
  char v40; // di
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rbx
  unsigned __int64 v43; // rax
  __int64 v44; // rbx
  __int64 v45; // rbx
  bool v46; // al
  const char *p_Str; // r8
  _BYTE *v48; // r14
  size_t n0x1FF_13; // rbx
  void *p_Str_2; // rax
  char Str_1; // r9
  char Str_2; // cl
  char *v53; // rax
  __int64 v54; // rax
  const void *v55; // r14
  size_t n0x1FF_16; // rbx
  void *p_Str_5; // rax
  char Str_3; // r9
  char Str_4; // cl
  char *v60; // rax
  int v61; // eax
  unsigned __int64 v62; // rax
  __int16 v63; // rbx^6
  __int64 v64; // rax
  __int16 n2; // cx
  __int64 v66; // rcx
  __int64 v67; // rax
  const void **v68; // rax
  __int64 v69; // rax
  const void **v70; // r15
  __int64 n0x1FF_21; // rax
  size_t n0x1FF_19; // rbx
  unsigned __int64 allocSize; // r14
  char *p_Str_6; // rax
  char Str_5; // r9
  char Str_6; // cl
  char *v77; // rax
  unsigned __int32 v78; // eax
  _BYTE *result; // rax
  bool v80; // [rsp+28h] [rbp-E0h]
  bool v81; // [rsp+29h] [rbp-DFh]
  bool v82; // [rsp+2Ah] [rbp-DEh]
  int v83; // [rsp+2Ch] [rbp-DCh] BYREF
  __int64 v84; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v85; // [rsp+38h] [rbp-D0h]
  __int64 v86; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v87; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v88; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v89; // [rsp+58h] [rbp-B0h] BYREF
  int *v90; // [rsp+60h] [rbp-A8h]
  __int64 v91; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v92; // [rsp+70h] [rbp-98h]
  double v93; // [rsp+78h] [rbp-90h] BYREF
  double v94; // [rsp+80h] [rbp-88h]
  double v95; // [rsp+88h] [rbp-80h]
  size_t n0x1FF_20; // [rsp+98h] [rbp-70h]
  __int64 n0x1FF_18; // [rsp+A0h] [rbp-68h]
  char *p_Str_4; // [rsp+A8h] [rbp-60h]
  _BYTE v99[520]; // [rsp+B0h] [rbp-58h] BYREF
  size_t n0x1FF_14; // [rsp+2B8h] [rbp+1B0h]
  __int64 n0x1FF_12; // [rsp+2C0h] [rbp+1B8h]
  void *p_Str_1; // [rsp+2C8h] [rbp+1C0h]
  char Str[520]; // [rsp+2D0h] [rbp+1C8h] BYREF
  size_t n0x1FF_17; // [rsp+4D8h] [rbp+3D0h]
  __int64 n0x1FF_15; // [rsp+4E0h] [rbp+3D8h]
  void *p_Str_3; // [rsp+4E8h] [rbp+3E0h]
  char v107[520]; // [rsp+4F0h] [rbp+3E8h] BYREF
  size_t n0x1FF_11; // [rsp+6F8h] [rbp+5F0h]
  __int64 n0x1FF_9; // [rsp+700h] [rbp+5F8h]
  char *SubStr_4; // [rsp+708h] [rbp+600h]
  _BYTE v111[520]; // [rsp+710h] [rbp+608h] BYREF
  size_t n0x1FF_8; // [rsp+918h] [rbp+810h]
  __int64 n0x1FF_6; // [rsp+920h] [rbp+818h]
  void *v114; // [rsp+928h] [rbp+820h]
  _BYTE v115[520]; // [rsp+930h] [rbp+828h] BYREF
  size_t n0x1FF_5; // [rsp+B38h] [rbp+A30h]
  __int64 n0x1FF_3; // [rsp+B40h] [rbp+A38h]
  char *SubStr_3; // [rsp+B48h] [rbp+A40h]
  _BYTE v119[520]; // [rsp+B50h] [rbp+A48h] BYREF
  size_t n0x1FF_2; // [rsp+D58h] [rbp+C50h]
  __int64 n0x1FF; // [rsp+D60h] [rbp+C58h]
  char *SubStr; // [rsp+D68h] [rbp+C60h]
  _BYTE v123[520]; // [rsp+D70h] [rbp+C68h] BYREF

  v2 = 0;
  v83 = 0;
  v85 = a1;
  v3 = *(_QWORD *)(a1 + 0xE0);
  v90 = a2;
  v4 = (double *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x3D0LL))(v3);
  v5 = v4[3];
  v6 = v4[7];
  v7 = v4[0xB];
  v8 = (*(double (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DC0 + 0x20LL))(qword_1516F1DC0);
  v9 = *(float *)&v8 * *(float *)&v8;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DC8 + 0x28LL))(qword_1516F1DC8);
  SubStr_2 = v123;
  v123[0] = 0;
  SubStr = v123;
  v12 = (const void *)v10;
  n0x1FF_2 = 0;
  n0x1FF = 0x1FF;
  if ( v10 )
  {
    n0x1FF_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n0x1FF_1;
    while ( *(_BYTE *)(v10 + n0x1FF_1) );
    if ( n0x1FF_1 )
    {
      SubStr_1 = v123;
      if ( n0x1FF_1 + 1 > 0x200 )
      {
        SubStr_1 = (char *)allocWithProfilerInfo(n0x1FF_1 + 1, 0);
        qword_149C78668 += n0x1FF_1 + 1;
        n0x1FF = n0x1FF_1;
      }
      SubStr = SubStr_1;
      n0x1FF_2 = n0x1FF_1;
      SubStr_1[n0x1FF_1] = 0;
      memcpy(SubStr, v12, n0x1FF_1);
      SubStr_2 = SubStr;
    }
  }
  for ( i = *SubStr_2; *SubStr_2; i = *SubStr_2 )
  {
    ++SubStr_2;
    v16 = i + 0x20;
    if ( (unsigned __int8)(i - 0x41) > 0x19u )
      v16 = i;
    SubStr_2[0xFFFFFFFF] = v16;
  }
  v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DD0 + 0x28LL))(qword_1516F1DD0);
  SubStr_6 = v119;
  v119[0] = 0;
  SubStr_3 = v119;
  v19 = (const void *)v17;
  n0x1FF_5 = 0;
  n0x1FF_3 = 0x1FF;
  if ( v17 )
  {
    n0x1FF_4 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n0x1FF_4;
    while ( *(_BYTE *)(v17 + n0x1FF_4) );
    if ( n0x1FF_4 )
    {
      SubStr_5 = v119;
      if ( n0x1FF_4 + 1 > 0x200 )
      {
        SubStr_5 = (char *)allocWithProfilerInfo(n0x1FF_4 + 1, 0);
        qword_149C78668 += n0x1FF_4 + 1;
        n0x1FF_3 = n0x1FF_4;
      }
      SubStr_3 = SubStr_5;
      n0x1FF_5 = n0x1FF_4;
      SubStr_5[n0x1FF_4] = 0;
      memcpy(SubStr_3, v19, n0x1FF_4);
      SubStr_6 = SubStr_3;
    }
  }
  for ( j = *SubStr_6; *SubStr_6; j = *SubStr_6 )
  {
    ++SubStr_6;
    v23 = j + 0x20;
    if ( (unsigned __int8)(j - 0x41) > 0x19u )
      v23 = j;
    SubStr_6[0xFFFFFFFF] = v23;
  }
  v24 = (_BYTE *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DD8 + 0x28LL))(qword_1516F1DD8);
  v115[0] = 0;
  n0x1FF_8 = 0;
  v114 = v115;
  n0x1FF_6 = 0x1FF;
  if ( v24 )
  {
    n0x1FF_7 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n0x1FF_7;
    while ( v24[n0x1FF_7] );
    if ( n0x1FF_7 )
    {
      v26 = v115;
      if ( n0x1FF_7 + 1 > 0x200 )
      {
        v26 = (_BYTE *)allocWithProfilerInfo(n0x1FF_7 + 1, 0);
        qword_149C78668 += n0x1FF_7 + 1;
        n0x1FF_6 = n0x1FF_7;
      }
      v114 = v26;
      n0x1FF_8 = n0x1FF_7;
      v26[n0x1FF_7] = 0;
      memcpy(v114, v24, n0x1FF_7);
    }
  }
  v27 = (_BYTE *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DE0 + 0x28LL))(qword_1516F1DE0);
  v111[0] = 0;
  n0x1FF_11 = 0;
  SubStr_4 = v111;
  n0x1FF_9 = 0x1FF;
  if ( v27 )
  {
    n0x1FF_10 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n0x1FF_10;
    while ( v27[n0x1FF_10] );
    if ( n0x1FF_10 )
    {
      SubStr_7 = v111;
      if ( n0x1FF_10 + 1 > 0x200 )
      {
        SubStr_7 = (char *)allocWithProfilerInfo(n0x1FF_10 + 1, 0);
        qword_149C78668 += n0x1FF_10 + 1;
        n0x1FF_9 = n0x1FF_10;
      }
      SubStr_4 = SubStr_7;
      n0x1FF_11 = n0x1FF_10;
      SubStr_7[n0x1FF_10] = 0;
      memcpy(SubStr_4, v27, n0x1FF_10);
    }
  }
  SubStr_8 = SubStr_4;
  for ( k = *SubStr_4; *SubStr_8; k = *SubStr_8 )
  {
    ++SubStr_8;
    v32 = k + 0x20;
    if ( (unsigned __int8)(k - 0x41) > 0x19u )
      v32 = k;
    SubStr_8[0xFFFFFFFF] = v32;
  }
  v33 = n0x1FF_2 != 0;
  v80 = n0x1FF_2 != 0;
  LOBYTE(v83) = n0x1FF_5 != 0;
  v81 = n0x1FF_8 != 0;
  v82 = n0x1FF_11 != 0;
  if ( !n0x1FF_8
    || (*(unsigned __int8 (__fastcall **)(__int64, void *))(*(_QWORD *)qword_149C8DFC8 + 0x18LL))(qword_149C8DFC8, v114) )
  {
    v34 = v85;
    v35 = v85 + 0xE8;
    v92 = v85 + 0xE8;
    v36 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v85 + 0xF8) == v36 )
    {
      ++*(_DWORD *)(v85 + 0xFC);
    }
    else
    {
      v37 = _InterlockedCompareExchange((volatile signed __int32 *)v35, 1, 0);
      if ( v37 )
        sub_1403C6E80(v35, v37, (__int64)&p_Src, 1);
      else
        *(_QWORD *)(v85 + 0xF0) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v35 + 0x10) = v36;
    }
    v38 = *(_QWORD **)(v34 + 0x100);
    v39 = (_QWORD *)*v38;
    if ( (_QWORD *)*v38 != v38 )
    {
      v40 = v83;
      while ( 1 )
      {
        v41 = v39[2];
        v84 = v41;
        if ( !v41 )
          goto LABEL_105;
        v42 = v41;
        v43 = HIWORD(v41);
        v44 = v42 & 0xFFFFFFFFFFFFLL;
        v45 = (v43 & 0xF000) != 0 ? v44 & 0xFFFFFF000000LL : v44 - 6;
        if ( *(_WORD *)(v45 + 2) != (v43 & 0xFFF) )
          goto LABEL_105;
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v46 = is_thread_privileged_or_bypass_mode()) )
          v46 = 1;
        if ( (*(_WORD *)(v45 + 4) != 2 || !v46) && !sub_140395410(&v84) )
          goto LABEL_105;
        if ( *(_BYTE *)((v84 & 0xFFFFFFFFFFFFLL) + 0xD) != 4 )
          goto LABEL_105;
        if ( v9 > 0.0 )
        {
          sub_146C58D00(v84 & 0xFFFFFFFFFFFFLL, (__int64)&v93, 0, 0);
          if ( (v94 - v6) * (v94 - v6) + (v93 - v5) * (v93 - v5) + (v95 - v7) * (v95 - v7) > v9 )
            goto LABEL_105;
        }
        if ( !v33 )
          goto LABEL_83;
        p_Str = Str;
        v48 = *(_BYTE **)((v84 & 0xFFFFFFFFFFFFLL) + 0x298);
        Str[0] = 0;
        p_Str_1 = Str;
        n0x1FF_14 = 0;
        n0x1FF_12 = 0x1FF;
        if ( v48 )
        {
          n0x1FF_13 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++n0x1FF_13;
          while ( v48[n0x1FF_13] );
          if ( n0x1FF_13 )
          {
            p_Str_2 = Str;
            if ( n0x1FF_13 + 1 > 0x200 )
            {
              p_Str_2 = (void *)allocWithProfilerInfo(n0x1FF_13 + 1, 0);
              qword_149C78668 += n0x1FF_13 + 1;
              n0x1FF_12 = n0x1FF_13;
            }
            p_Str_1 = p_Str_2;
            n0x1FF_14 = n0x1FF_13;
            *((_BYTE *)p_Str_2 + n0x1FF_13) = 0;
            memcpy(p_Str_1, v48, n0x1FF_13);
            p_Str = (const char *)p_Str_1;
          }
        }
        Str_1 = *p_Str;
        if ( *p_Str )
        {
          do
          {
            ++p_Str;
            Str_2 = Str_1 + 0x20;
            if ( (unsigned __int8)(Str_1 - 0x41) > 0x19u )
              Str_2 = Str_1;
            *((_BYTE *)p_Str + 0xFFFFFFFF) = Str_2;
            Str_1 = *p_Str;
          }
          while ( *p_Str );
          p_Str = (const char *)p_Str_1;
        }
        if ( p_Str )
        {
          v53 = strstr(p_Str, SubStr);
          p_Str = (const char *)p_Str_1;
          if ( v53 )
          {
            if ( v53 - (_BYTE *)p_Str_1 != 0xFFFFFFFFFFFFFFFFuLL )
              break;
          }
        }
        if ( p_Str != Str )
        {
          v62 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_12;
LABEL_111:
          qword_149C78668 += v62;
          sub_147715880(p_Str);
        }
LABEL_104:
        v33 = v80;
LABEL_105:
        v39 = (_QWORD *)*v39;
        if ( v39 == *(_QWORD **)(v85 + 0x100) )
        {
          v35 = v92;
          goto LABEL_107;
        }
      }
      if ( p_Str_1 != Str )
      {
        qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_12;
        sub_147715880(p_Str_1);
      }
LABEL_83:
      if ( v40 )
      {
        v54 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)((v84 & 0xFFFFFFFFFFFFLL) + 0x20) + 0x18LL))(*(_QWORD *)((v84 & 0xFFFFFFFFFFFFLL) + 0x20));
        p_Str = v107;
        v107[0] = 0;
        p_Str_3 = v107;
        v55 = (const void *)v54;
        n0x1FF_17 = 0;
        n0x1FF_15 = 0x1FF;
        if ( v54 )
        {
          n0x1FF_16 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++n0x1FF_16;
          while ( *(_BYTE *)(v54 + n0x1FF_16) );
          if ( n0x1FF_16 )
          {
            p_Str_5 = v107;
            if ( n0x1FF_16 + 1 > 0x200 )
            {
              p_Str_5 = (void *)allocWithProfilerInfo(n0x1FF_16 + 1, 0);
              qword_149C78668 += n0x1FF_16 + 1;
              n0x1FF_15 = n0x1FF_16;
            }
            p_Str_3 = p_Str_5;
            n0x1FF_17 = n0x1FF_16;
            *((_BYTE *)p_Str_5 + n0x1FF_16) = 0;
            memcpy(p_Str_3, v55, n0x1FF_16);
            p_Str = (const char *)p_Str_3;
          }
        }
        Str_3 = *p_Str;
        if ( *p_Str )
        {
          do
          {
            ++p_Str;
            Str_4 = Str_3 + 0x20;
            if ( (unsigned __int8)(Str_3 - 0x41) > 0x19u )
              Str_4 = Str_3;
            *((_BYTE *)p_Str + 0xFFFFFFFF) = Str_4;
            Str_3 = *p_Str;
          }
          while ( *p_Str );
          p_Str = (const char *)p_Str_3;
        }
        if ( !p_Str
          || (v60 = strstr(p_Str, SubStr_3), p_Str = (const char *)p_Str_3, !v60)
          || v60 - (_BYTE *)p_Str_3 == 0xFFFFFFFFFFFFFFFFuLL )
        {
          if ( p_Str == v107 )
            goto LABEL_104;
          v62 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_15;
          goto LABEL_111;
        }
        if ( p_Str_3 != v107 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_15;
          sub_147715880(p_Str_3);
        }
      }
      if ( !v81 )
        goto LABEL_120;
      (*(void (__fastcall **)(__int64, int *, void *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
        qword_149C8DFC8,
        &v83,
        v114);
      if ( *(_BYTE *)((v84 & 0xFFFFFFFFFFFFLL) + 0xD) == 7 )
      {
        v86 = 0;
        v87 = 0;
      }
      else
      {
        sub_146C540A0(v84 & 0xFFFFFFFFFFFFLL, &v86, (unsigned __int16)v83);
        v63 = HIWORD(v86);
        v87 = v86;
        if ( v86 )
        {
          v64 = sub_1403B84E0(v86 & 0xFFFFFFFFFFFFLL);
          n2 = *(_WORD *)(v64 + 4);
          if ( n2 != 4 )
          {
            if ( *(_WORD *)(v64 + 2) != (v63 & 0xFFF) )
            {
              v33 = v80;
              goto LABEL_105;
            }
            if ( n2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v87) )
            {
LABEL_120:
              if ( !v82 )
                goto LABEL_143;
              v66 = v84 & 0xFFFFFFFFFFFFLL;
              if ( n2_5 < 2 )
              {
                v69 = sub_146C73360(v66, 0);
                v2 |= 2u;
                v68 = (const void **)sub_1403BADE0(v69, &v88);
              }
              else
              {
                v67 = sub_146C73360(v66, 0);
                v2 |= 1u;
                v68 = (const void **)sub_1403BAC50(v67, &v89);
              }
              v70 = v68;
              v99[0] = 0;
              n0x1FF_20 = 0;
              p_Str_4 = v99;
              n0x1FF_18 = 0x1FF;
              n0x1FF_21 = sub_1403EBE30(v68);
              n0x1FF_19 = n0x1FF_21;
              if ( n0x1FF_21 )
              {
                allocSize = n0x1FF_21 + 1;
                p_Str_6 = v99;
                if ( allocSize <= 0x200 )
                {
                  n0x1FF_18 = 0x1FF;
                }
                else
                {
                  p_Str_6 = (char *)allocWithProfilerInfo(allocSize, 0);
                  qword_149C78668 += allocSize;
                  n0x1FF_18 = n0x1FF_19;
                }
                p_Str_4 = p_Str_6;
                n0x1FF_20 = n0x1FF_19;
                p_Str_6[n0x1FF_19] = 0;
                memcpy(p_Str_4, *v70, n0x1FF_19);
              }
              if ( (v2 & 2) != 0 )
              {
                v2 &= ~2u;
                sub_140373CC0(&v88);
              }
              if ( (v2 & 1) != 0 )
              {
                v2 &= ~1u;
                sub_140373CC0(&v89);
              }
              p_Str = p_Str_4;
              Str_5 = *p_Str_4;
              if ( *p_Str_4 )
              {
                do
                {
                  ++p_Str;
                  Str_6 = Str_5 + 0x20;
                  if ( (unsigned __int8)(Str_5 - 0x41) > 0x19u )
                    Str_6 = Str_5;
                  *((_BYTE *)p_Str + 0xFFFFFFFF) = Str_6;
                  Str_5 = *p_Str;
                }
                while ( *p_Str );
                p_Str = p_Str_4;
              }
              if ( p_Str )
              {
                v77 = strstr(p_Str, SubStr_4);
                p_Str = p_Str_4;
                if ( v77 )
                {
                  if ( v77 - p_Str_4 != 0xFFFFFFFFFFFFFFFFuLL )
                  {
                    if ( p_Str_4 != v99 )
                    {
                      qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_18;
                      sub_147715880(p_Str_4);
                    }
LABEL_143:
                    v91 = v84;
                    sub_146C43ED0(v85, &v91, -1.0, v90);
                    goto LABEL_104;
                  }
                }
              }
              if ( p_Str == v99 )
                goto LABEL_104;
              v62 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_18;
              goto LABEL_111;
            }
          }
        }
      }
      goto LABEL_104;
    }
LABEL_107:
    v61 = *(_DWORD *)(v35 + 0x14);
    if ( v61 )
    {
      *(_DWORD *)(v35 + 0x14) = v61 - 1;
    }
    else
    {
      *(_DWORD *)(v35 + 0x10) = 0xFFFFFFFF;
      v78 = _InterlockedCompareExchange((volatile signed __int32 *)v35, 0, 1);
      if ( v78 == 1 )
        *(_QWORD *)(v35 + 8) = &p_Src;
      else
        sub_1403DF590(v35, v78);
    }
  }
  if ( SubStr_4 != v111 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_9;
    sub_147715880(SubStr_4);
  }
  if ( v114 != v115 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_6;
    sub_147715880(v114);
  }
  if ( SubStr_3 != v119 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_3;
    sub_147715880(SubStr_3);
  }
  result = v123;
  if ( SubStr != v123 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
    return (_BYTE *)sub_147715880(SubStr);
  }
  return result;
}

// --- End Function: sub_146C45630 (0x146C45630) ---

// --- Function: sub_146C46340 (0x146C46340) ---
void __fastcall sub_146C46340(__int64 a1)
{
  __int64 v2; // rax
  void (__fastcall ***v3)(_QWORD, __int128 *); // rsi
  __int64 v4; // rax
  __int64 v5; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  volatile signed __int32 *v8; // rcx
  int v9; // eax
  unsigned __int32 v10; // eax
  __int64 v11; // rcx
  __int128 v12; // [rsp+20h] [rbp-38h] BYREF
  __int64 v13; // [rsp+30h] [rbp-28h]
  unsigned __int64 __Val_0__; // [rsp+68h] [rbp+10h] BYREF
  __int64 v15; // [rsp+70h] [rbp+18h] BYREF

  if ( qword_149C8E0B8 )
  {
    if ( Parameter_0 )
    {
      v2 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(
             Parameter_0,
             0x80000000LL);
      v3 = (void (__fastcall ***)(_QWORD, __int128 *))v2;
      if ( v2 )
      {
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x10LL))(v2) )
        {
          if ( (dword_1516F22A0 & 1) == 0 )
          {
            dword_1516F22A0 |= 1u;
            v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0xC0LL))(qword_149C8DFC0);
            v5 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v4 + 0x20LL))(
                   v4,
                   "StreamingObjectContainer");
            dword_1516F229C = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x28LL))(v5);
          }
          v13 = 0;
          v12 = 0;
          sub_14035DC00(&v15, a1 + 0xE8, 1);
          v6 = *(_QWORD **)(a1 + 0x100);
          v7 = (_QWORD *)*v6;
          if ( (_QWORD *)*v6 != v6 )
          {
            do
            {
              __Val_0__ = v7[2];
              if ( is_entity_descriptor_valid_or_accessible(&__Val_0__)
                && *(_BYTE *)((__Val_0__ & 0xFFFFFFFFFFFFLL) + 0xD) == 4 )
              {
                if ( *((_QWORD *)&v12 + 1) == v13 )
                {
                  std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                    (std::vector<vraudio::AudioBuffer const *> *)&v12,
                    *((const vraudio::AudioBuffer **const *)&v12 + 1),
                    (const vraudio::AudioBuffer **)&__Val_0__);
                }
                else
                {
                  **((_QWORD **)&v12 + 1) = __Val_0__;
                  *((_QWORD *)&v12 + 1) += 8LL;
                }
              }
              v7 = (_QWORD *)*v7;
            }
            while ( v7 != *(_QWORD **)(a1 + 0x100) );
          }
          (**v3)(v3, &v12);
          v8 = (volatile signed __int32 *)v15;
          v9 = *(_DWORD *)(v15 + 0x14);
          if ( v9 )
          {
            *(_DWORD *)(v15 + 0x14) = v9 - 1;
          }
          else
          {
            *(_DWORD *)(v15 + 0x10) = 0xFFFFFFFF;
            v10 = _InterlockedCompareExchange(v8, 0, 1);
            if ( v10 == 1 )
              *(_QWORD *)(v15 + 8) = &p_Src;
            else
              sub_1403DF590(v15, v10);
          }
          v11 = v12;
          if ( (_QWORD)v12 )
          {
            if ( ((v13 - (_QWORD)v12) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
            {
              v11 = *(_QWORD *)(v12 - 8);
              if ( (unsigned __int64)(v12 - v11 - 8) > 0x1F )
                invalid_parameter_noinfo_noreturn();
            }
            sub_1402A6590(v11);
          }
        }
      }
    }
  }
}

// --- End Function: sub_146C46340 (0x146C46340) ---

// --- Function: sub_146C46540 (0x146C46540) ---
__int64 __fastcall sub_146C46540(__int64 a1)
{
  __int128 v1; // xmm6
  __int64 v5; // rax
  int n0x3E8; // eax
  _QWORD *v7; // rbx
  __int64 v8; // rdi
  int v9; // ebx
  unsigned int v10; // eax
  _QWORD *v11; // rsi
  _QWORD *v12; // rbx
  unsigned __int64 v13; // rax
  __int64 v14; // r14
  unsigned __int64 v15; // rax
  __int64 v16; // r14
  bool v17; // al
  const char *v18; // rax
  int v19; // eax
  unsigned __int64 v20; // rax
  __int64 v21; // r15
  __int64 inserted; // rdx
  unsigned __int64 v23; // r14
  __int64 v24; // rcx
  __int64 v25; // rax
  __int128 v26; // xmm0
  __int64 *v27; // rcx
  _BYTE *v28; // rax
  unsigned __int32 v29; // eax
  __int64 SubStr_4; // rax
  __int64 v31; // rdi
  _QWORD *j; // rbx
  __int64 v33; // r12
  __int64 v34; // rsi
  __int64 v35; // r14
  __int64 *SubStr_5; // r15
  __int64 v37; // r8
  __int64 v38; // rcx
  unsigned __int64 v39; // rax
  __int64 **v40; // rax
  __int64 i; // rax
  __int64 *v42; // rcx
  __int64 *v43; // rdi
  __int64 *SubStr_6; // rcx
  __int128 n0x41D00000; // xmm6
  __int64 *SubStr_1; // r14
  __int64 v47; // rbx
  __int64 SubStr_7; // rax
  __int64 SubStr_8; // rcx
  __int64 v50; // rcx
  __int64 v51; // rsi
  void *v52; // rax
  __int64 v53; // r9
  _QWORD *v54; // rdi
  _QWORD *v55; // rsi
  int v56; // r13d
  int v57; // r12d
  __int64 v58; // rbx
  __int64 v59; // r15
  bool v60; // al
  __int64 *v61; // rdi
  __int128 n0x41D00000_1; // kr00_16
  __int64 v63; // rbx
  __int64 v64; // rcx
  const char *SubStr; // [rsp+40h] [rbp-C0h] BYREF
  __int64 *SubStr_2; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v68; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v69; // [rsp+58h] [rbp-A8h] BYREF
  __int128 v70; // [rsp+60h] [rbp-A0h] BYREF
  __int64 *v71; // [rsp+70h] [rbp-90h] BYREF
  __int128 v72; // [rsp+78h] [rbp-88h]
  __int64 *SubStr_3; // [rsp+90h] [rbp-70h] BYREF
  _OWORD v74[7]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v76; // [rsp+168h] [rbp+68h] BYREF
  void *v77; // [rsp+170h] [rbp+70h] BYREF
  void *v78; // [rsp+178h] [rbp+78h] BYREF

  v74[6] = v1;
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(qword_149C8DF80, 0);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
  if ( (dword_1516F2298 & 1) == 0 )
  {
    qword_1516F2288 = 0;
    dword_1516F2298 |= 1u;
    qword_1516F2290 = 0;
    v5 = sub_1402A65A0(0x40u);
    *(_QWORD *)v5 = v5;
    *(_QWORD *)(v5 + 8) = v5;
    *(_QWORD *)(v5 + 0x10) = v5;
    *(_WORD *)(v5 + 0x18) = 0x101;
    qword_1516F2288 = v5;
    atexit(sub_148284620);
  }
  n0x3E8 = ::n0x3E8;
  if ( ::n0x3E8 < 0x3E8 )
    n0x3E8 = 0x3E8;
  if ( (float)(*(float *)&_XMM6 - *(float *)&dword_1516F2280) >= (float)((float)n0x3E8 * 0.001) )
  {
    dword_1516F2280 = _XMM6;
    CreateStringObjectFromString((void **)&SubStr, off_149C025A8);
    sub_1403C7440((char **)&SubStr);
    v7 = (_QWORD *)qword_1516F2288;
    sub_1413B53B0((__int64)&qword_1516F2288, (__int64)&qword_1516F2288, *(__int64 **)(qword_1516F2288 + 8));
    v7[1] = v7;
    v8 = a1 + 0xE8;
    *v7 = v7;
    v7[2] = v7;
    qword_1516F2290 = 0;
    v9 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0xF8) == v9 )
    {
      ++*(_DWORD *)(a1 + 0xFC);
    }
    else
    {
      v10 = _InterlockedCompareExchange((volatile signed __int32 *)v8, 1, 0);
      if ( v10 )
        sub_1403C6E80(a1 + 0xE8, v10, (__int64)&p_Src, 1);
      else
        *(_QWORD *)(a1 + 0xF0) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0xF8) = v9;
    }
    v11 = *(_QWORD **)(a1 + 0x100);
    v12 = (_QWORD *)*v11;
    if ( (_QWORD *)*v11 != v11 )
    {
      while ( 1 )
      {
        v13 = v12[2];
        v69 = v13;
        if ( !v13 )
          goto LABEL_27;
        v14 = v13 & 0xFFFFFFFFFFFFLL;
        v15 = HIWORD(v13);
        v16 = (v15 & 0xF000) != 0 ? v14 & 0xFFFFFF000000LL : v14 - 6;
        if ( *(_WORD *)(v16 + 2) != (v15 & 0xFFF) )
          goto LABEL_27;
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v17 = is_thread_privileged_or_bypass_mode()) )
          v17 = 1;
        if ( (*(_WORD *)(v16 + 4) != 2 || !v17) && !sub_140395410(&v69) )
          goto LABEL_27;
        if ( sub_1403C3450(&SubStr) )
          goto LABEL_31;
        v18 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)((v69 & 0xFFFFFFFFFFFFLL) + 0x20) + 0x18LL))(*(_QWORD *)((v69 & 0xFFFFFFFFFFFFLL) + 0x20));
        CreateStringObjectFromString(&v78, v18);
        sub_1403C7440((char **)&v78);
        if ( sub_1403EA1B0((__int64 *)&v78, SubStr, 0) != 0xFFFFFFFFFFFFFFFFuLL )
          break;
        sub_140373CC0(&v78);
LABEL_27:
        v12 = (_QWORD *)*v12;
        if ( v12 == v11 )
          goto LABEL_28;
      }
      sub_140373CC0(&v78);
LABEL_31:
      v20 = v69;
      DWORD2(v72) = 0;
      v21 = qword_1516F2288;
      inserted = qword_1516F2288;
      v23 = *(_QWORD *)((v69 & 0xFFFFFFFFFFFFLL) + 0x20);
      v24 = *(_QWORD *)(qword_1516F2288 + 8);
      *(_QWORD *)&v72 = v24;
      while ( !*(_BYTE *)(v24 + 0x19) )
      {
        *(_QWORD *)&v72 = v24;
        if ( *(_QWORD *)(v24 + 0x20) >= v23 )
        {
          inserted = v24;
          DWORD2(v72) = 1;
          v24 = *(_QWORD *)v24;
        }
        else
        {
          v24 = *(_QWORD *)(v24 + 0x10);
          DWORD2(v72) = 0;
        }
      }
      if ( *(_BYTE *)(inserted + 0x19) || v23 < *(_QWORD *)(inserted + 0x20) )
      {
        if ( qword_1516F2290 == 0x3FFFFFFFFFFFFFFLL )
          unknown_libname_7();
        v25 = sub_1402A65A0(0x40u);
        v26 = v72;
        *(_QWORD *)(v25 + 0x20) = v23;
        *(_QWORD *)(v25 + 0x28) = 0;
        *(_QWORD *)(v25 + 0x30) = 0;
        *(_QWORD *)(v25 + 0x38) = 0;
        *(_QWORD *)v25 = v21;
        *(_QWORD *)(v25 + 8) = v21;
        *(_QWORD *)(v25 + 0x10) = v21;
        *(_WORD *)(v25 + 0x18) = 0;
        v74[0] = v26;
        inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                     (__int64 **)&qword_1516F2288,
                     (__int64)v74,
                     v25);
        v20 = v69;
      }
      v27 = *(__int64 **)((v20 & 0xFFFFFFFFFFFFLL) + 0x10);
      v28 = *(_BYTE **)(inserted + 0x30);
      v71 = v27;
      if ( v28 == *(_BYTE **)(inserted + 0x38) )
      {
        sub_1402A93C0(inserted + 0x28, v28, &v71);
      }
      else
      {
        *(_QWORD *)v28 = v27;
        *(_QWORD *)(inserted + 0x30) += 8LL;
      }
      goto LABEL_27;
    }
LABEL_28:
    v19 = *(_DWORD *)(v8 + 0x14);
    if ( v19 )
    {
      *(_DWORD *)(v8 + 0x14) = v19 - 1;
    }
    else
    {
      *(_DWORD *)(v8 + 0x10) = 0xFFFFFFFF;
      v29 = _InterlockedCompareExchange((volatile signed __int32 *)v8, 0, 1);
      if ( v29 == 1 )
        *(_QWORD *)(v8 + 8) = &p_Src;
      else
        sub_1403DF590(v8, v29);
    }
    sub_140373CC0(&SubStr);
  }
  v68 = 0;
  SubStr_4 = sub_1402A65A0(0x30u);
  *(_QWORD *)SubStr_4 = SubStr_4;
  *(_QWORD *)(SubStr_4 + 8) = SubStr_4;
  *(_QWORD *)(SubStr_4 + 0x10) = SubStr_4;
  *(_WORD *)(SubStr_4 + 0x18) = 0x101;
  v31 = qword_1516F2288;
  SubStr_2 = (__int64 *)SubStr_4;
  j = *(_QWORD **)qword_1516F2288;
  while ( j != (_QWORD *)v31 )
  {
    v33 = j[6];
    v34 = j[5];
    v35 = j[4];
    SubStr_5 = SubStr_2;
    v37 = sub_1402A65A0(0x30u);
    *(_QWORD *)(v37 + 0x20) = (v33 - v34) >> 3;
    *(_QWORD *)(v37 + 0x28) = v35;
    *(_QWORD *)v37 = SubStr_5;
    *(_QWORD *)(v37 + 8) = SubStr_5;
    *(_QWORD *)(v37 + 0x10) = SubStr_5;
    *(_WORD *)(v37 + 0x18) = 0;
    DWORD2(v72) = 0;
    v38 = SubStr_2[1];
    *(_QWORD *)&v72 = v38;
    if ( !*(_BYTE *)(v38 + 0x19) )
    {
      v39 = *(_QWORD *)(v37 + 0x20);
      do
      {
        *(_QWORD *)&v72 = v38;
        if ( v39 >= *(_QWORD *)(v38 + 0x20) )
        {
          v38 = *(_QWORD *)(v38 + 0x10);
          DWORD2(v72) = 0;
        }
        else
        {
          v38 = *(_QWORD *)v38;
          DWORD2(v72) = 1;
        }
      }
      while ( !*(_BYTE *)(v38 + 0x19) );
    }
    if ( v68 == 0x555555555555555LL )
      unknown_libname_7();
    v70 = v72;
    std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
      &SubStr_2,
      (__int64)&v70,
      v37);
    v40 = (__int64 **)j[2];
    if ( *((_BYTE *)v40 + 0x19) )
    {
      for ( i = j[1]; !*(_BYTE *)(i + 0x19); i = *(_QWORD *)(i + 8) )
      {
        if ( j != *(_QWORD **)(i + 0x10) )
          break;
        j = (_QWORD *)i;
      }
      j = (_QWORD *)i;
    }
    else
    {
      v42 = *v40;
      for ( j = (_QWORD *)j[2]; !*((_BYTE *)v42 + 0x19); v42 = (__int64 *)*v42 )
        j = v42;
    }
  }
  if ( v68 )
  {
    v43 = (__int64 *)qword_149C8E018;
    v71 = (__int64 *)qword_149C8E018;
    v70 = xmmword_1482BB410;
    CreateStringObjectFromString(&v77, "Entity Class");
    if ( off_149C025A8 && *off_149C025A8 )
    {
      sub_140387CB0((__int64)&v77, (__int64)" [");
      sub_140387CB0((__int64)&v77, (__int64)off_149C025A8);
      sub_140387CB0((__int64)&v77, (__int64)"]");
    }
    sub_1403A78C0(v43, 50.0, 11.0, 1.2, &v70, 0, (__int64)&format_string_, v77);
    sub_1403A78C0(v43, 250.0, 11.0, 1.2, &v70, 1u, (__int64)"Total");
    sub_1403A78C0(v43, 350.0, 11.0, 1.2, &v70, 1u, (__int64)"Hidden");
    SubStr_6 = SubStr_2;
    n0x41D00000 = 0x41D00000u;
    SubStr_3 = SubStr_2;
    SubStr_1 = (__int64 *)*SubStr_2;
    SubStr = (const char *)SubStr_1;
    if ( SubStr_2 == SubStr_1 )
      goto LABEL_108;
    v47 = qword_1516F2288;
    while ( 1 )
    {
      if ( *((_BYTE *)SubStr_6 + 0x19) )
      {
        SubStr_7 = SubStr_6[2];
      }
      else
      {
        SubStr_7 = *SubStr_6;
        if ( *(_BYTE *)(*SubStr_6 + 0x19) )
        {
          for ( SubStr_7 = SubStr_6[1]; !*(_BYTE *)(SubStr_7 + 0x19); SubStr_7 = *(_QWORD *)(SubStr_7 + 8) )
          {
            if ( SubStr_6 != *(__int64 **)SubStr_7 )
              break;
            SubStr_6 = (__int64 *)SubStr_7;
          }
          if ( *((_BYTE *)SubStr_6 + 0x19) )
            SubStr_7 = (__int64)SubStr_6;
        }
        else
        {
          for ( SubStr_8 = *(_QWORD *)(SubStr_7 + 0x10);
                !*(_BYTE *)(SubStr_8 + 0x19);
                SubStr_8 = *(_QWORD *)(SubStr_8 + 0x10) )
          {
            SubStr_7 = SubStr_8;
          }
        }
      }
      v50 = *(_QWORD *)(v47 + 8);
      v51 = v47;
      while ( !*(_BYTE *)(v50 + 0x19) )
      {
        if ( *(_QWORD *)(v50 + 0x20) >= *(_QWORD *)(SubStr_7 + 0x28) )
        {
          v51 = v50;
          v50 = *(_QWORD *)v50;
        }
        else
        {
          v50 = *(_QWORD *)(v50 + 0x10);
        }
      }
      if ( *(_BYTE *)(v51 + 0x19) || *(_QWORD *)(SubStr_7 + 0x28) < *(_QWORD *)(v51 + 0x20) )
        v51 = v47;
      if ( v51 == v47 )
        goto LABEL_107;
      v52 = (void *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v51 + 0x20) + 0x18LL))(*(_QWORD *)(v51 + 0x20));
      v54 = *(_QWORD **)(v51 + 0x28);
      v55 = *(_QWORD **)(v51 + 0x30);
      v78 = v52;
      if ( v54 == v55 )
        goto LABEL_106;
      v56 = 0;
      v57 = 0;
      do
      {
        LOBYTE(v53) = 1;
        sub_146C54DB0(a1, &v76, *v54, v53);
        v58 = v76;
        if ( v76 )
        {
          v59 = (v76 & 0xF000000000000000uLL) != 0 ? v76 & 0xFFFFFF000000LL : (v76 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v59 + 2) == (HIWORD(v76) & 0xFFF) )
          {
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v60 = is_thread_privileged_or_bypass_mode(), v58 = v76, v60) )
              v60 = 1;
            if ( *(_WORD *)(v59 + 4) != 2 || !v60 )
            {
              if ( !sub_140395410(&v76) )
                goto LABEL_104;
              v58 = v76;
            }
            ++v56;
            if ( (*(_BYTE *)((v58 & 0xFFFFFFFFFFFFLL) + 8) & 1) != 0 )
              ++v57;
          }
        }
LABEL_104:
        ++v54;
      }
      while ( v54 != v55 );
      v61 = v71;
      sub_1403A78C0(v71, 50.0, *(float *)&n0x41D00000, 1.0, &v70, 0, (__int64)&format_string_, v78);
      sub_1403A78C0(v61, 250.0, *(float *)&n0x41D00000, 1.0, &v70, 1u, (__int64)"%u", v56);
      sub_1403A78C0(v61, 350.0, *(float *)&n0x41D00000, 1.0, &v70, 1u, (__int64)"%u", v57);
      SubStr_1 = (__int64 *)SubStr;
      n0x41D00000_1 = n0x41D00000;
      *(float *)&n0x41D00000_1 = *(float *)&n0x41D00000 + 12.0;
      n0x41D00000 = n0x41D00000_1;
LABEL_106:
      v47 = qword_1516F2288;
LABEL_107:
      sub_140627B80(&SubStr_3);
      SubStr_6 = SubStr_3;
      if ( SubStr_3 == SubStr_1 )
      {
LABEL_108:
        sub_140373CC0(&v77);
        break;
      }
    }
  }
  v63 = SubStr_2[1];
  while ( !*(_BYTE *)(v63 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<std::pair<double const ,int> > > *)&SubStr_2,
      (std::allocator<std::_Tree_node<std::pair<double const ,int>,void *> > *)&SubStr_2,
      *(_QWORD *)(v63 + 0x10));
    v64 = v63;
    v63 = *(_QWORD *)v63;
    sub_1402A6590(v64);
  }
  return sub_1402A6590((__int64)SubStr_2);
}

// --- End Function: sub_146C46540 (0x146C46540) ---

// --- Function: sub_146C46F90 (0x146C46F90) ---
_UNKNOWN **__fastcall sub_146C46F90(int a1, __int64 a2, double *a3, int a4, __int64 a5, char a6)
{
  double v6; // xmm3_8
  __int128 v7; // xmm6
  __int128 v8; // xmm7
  __int128 v9; // xmm8
  _UNKNOWN **result; // rax
  double v11; // xmm4_8
  double v18; // xmm8_8
  __int128 v26; // kr00_16
  double v27; // kr00_8
  __int64 v30; // rsi
  int v31; // edi
  char v32; // r13
  __int64 v33; // r14
  __int64 v34; // r12
  __int64 v35; // rbx
  __int64 v36; // rax
  __int64 *v37; // rax
  __int64 v40; // rcx
  __int64 v41; // rbx
  __int64 v42; // rax
  __int64 *v43; // rax
  __int64 v46; // rcx
  __int64 v47; // rbx
  double v48; // xmm1_8
  int v49; // edx
  __int128 v50; // [rsp+30h] [rbp-88h] BYREF
  double v51; // [rsp+40h] [rbp-78h]
  __int128 v52; // [rsp+50h] [rbp-68h]
  __int128 v53; // [rsp+60h] [rbp-58h]
  __int128 v54; // [rsp+70h] [rbp-48h]
  _UNKNOWN *retaddr; // [rsp+B8h] [rbp+0h] BYREF
  int v56; // [rsp+C0h] [rbp+8h]
  unsigned int v57; // [rsp+C8h] [rbp+10h] BYREF

  result = &retaddr;
  v56 = a1;
  v11 = a3[2];
  _XMM2 = *(_OWORD *)a3;
  _XMM0 = *(unsigned __int64 *)(a2 + 8);
  _XMM1 = *(unsigned __int64 *)(a2 + 0x10);
  __asm { vmaxsd  xmm0, xmm0, xmm2 }
  v54 = v7;
  v52 = v9;
  v18 = v6;
  __asm
  {
    vminsd  xmm3, xmm0, qword ptr [rdx+20h]
    vunpckhpd xmm2, xmm2, xmm2
    vmaxsd  xmm0, xmm1, xmm2
  }
  _XMM1 = *(unsigned __int64 *)(a2 + 0x18);
  v53 = v8;
  __asm { vminsd  xmm7, xmm0, qword ptr [rdx+28h] }
  __asm
  {
    vmaxsd  xmm0, xmm1, xmm4
    vminsd  xmm6, xmm0, qword ptr [rdx+30h]
  }
  *((_QWORD *)&v26 + 1) = *((_QWORD *)&_XMM3 + 1);
  v27 = (*(double *)&_XMM3 - *a3) * (*(double *)&_XMM3 - *a3);
  *(double *)&_XMM0 = (*(double *)&_XMM7 - a3[1]) * (*(double *)&_XMM7 - a3[1]);
  *(double *)&_XMM1 = *(double *)&_XMM6 - a3[2];
  v51 = v11;
  *(double *)&v26 = v27 + *(double *)&_XMM0 + (*(double *)&_XMM6 - a3[2]) * *(double *)&_XMM1;
  _XMM2 = v26;
  __asm { vsqrtsd xmm3, xmm2, xmm2 }
  if ( *(double *)&_XMM3 <= v18 )
  {
    v30 = a5;
    v31 = 0;
    v32 = a6;
    v33 = *(unsigned __int16 *)(a2 + 0x88);
    if ( *(_WORD *)(a2 + 0x88) )
    {
      v34 = 0;
      if ( a6 )
      {
        do
        {
          v35 = *(_QWORD *)(v34 + *(_QWORD *)(a2 + 0x70));
          (*(void (__fastcall **)(__int64, __int128 *, __int64))(*(_QWORD *)v30 + 0x170LL))(v30, &v50, v35 + 0x48);
          v36 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
          v37 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x340LL))(v36);
          _XMM2 = *(unsigned __int64 *)(v35 + 0x60);
          __asm { vcvtpd2ps xmm2, xmm2 }
          v40 = *v37;
          v57 = 0xFF008000;
          result = (_UNKNOWN **)(*(__int64 (__fastcall **)(__int64 *, __int128 *, _QWORD, unsigned int *, int))(v40 + 0x138))(
                                  v37,
                                  &v50,
                                  *(_QWORD *)(v40 + 0x138),
                                  &v57,
                                  0x3F800000);
          v34 += 0x30;
          --v33;
        }
        while ( v33 );
      }
      else
      {
        do
        {
          v41 = *(_QWORD *)(v34 + *(_QWORD *)(a2 + 0x70));
          (*(void (__fastcall **)(__int64, __int128 *, __int64))(*(_QWORD *)v30 + 0x170LL))(v30, &v50, v41 + 0x48);
          v42 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
          v43 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v42 + 0x340LL))(v42);
          _XMM2 = *(unsigned __int64 *)(v41 + 0x68);
          __asm { vcvtpd2ps xmm2, xmm2 }
          v46 = *v43;
          v57 = 0xFF008000;
          result = (_UNKNOWN **)(*(__int64 (__fastcall **)(__int64 *, __int128 *, _QWORD, unsigned int *, int))(v46 + 0x138))(
                                  v43,
                                  &v50,
                                  *(_QWORD *)(v46 + 0x138),
                                  &v57,
                                  0x3F800000);
          v34 += 0x30;
          --v33;
        }
        while ( v33 );
      }
      a1 = v56;
    }
    v47 = *(unsigned __int8 *)(a2 + 0x98);
    if ( *(_BYTE *)(a2 + 0x98) )
    {
      do
      {
        v48 = a3[2];
        v49 = v31 + *(_QWORD *)(a2 + 0x68);
        v50 = *(_OWORD *)a3;
        v51 = v48;
        result = (_UNKNOWN **)sub_146C46F90(a1, v49, (unsigned int)&v50, a4, v30, v32);
        a1 = v56;
        v31 += 0xA0;
        --v47;
      }
      while ( v47 );
    }
  }
  return result;
}

// --- End Function: sub_146C46F90 (0x146C46F90) ---

// --- Function: sub_146C4B3F0 (0x146C4B3F0) ---
__int64 __fastcall sub_146C4B3F0(__int64 a1)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdi
  _QWORD *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rdi
  _QWORD *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v16; // rbx
  _QWORD *v17; // rax
  __int64 v18; // rbx
  __int128 v20; // [rsp+30h] [rbp-D0h] BYREF
  _QWORD *v21; // [rsp+40h] [rbp-C0h]
  __int64 v22; // [rsp+48h] [rbp-B8h] BYREF
  int n0x1000; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v24; // [rsp+54h] [rbp-ACh]
  int v25; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v26; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v27; // [rsp+68h] [rbp-98h]
  __int64 v28; // [rsp+70h] [rbp-90h]
  __int64 v29; // [rsp+78h] [rbp-88h]
  _QWORD v30[3]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 (*p_sub_146C3ADD0)(); // [rsp+B8h] [rbp-48h] BYREF
  void (__fastcall *n2)(__int64, __int64 (**)()); // [rsp+C0h] [rbp-40h]
  __int64 v33; // [rsp+C8h] [rbp-38h]
  int v34; // [rsp+E8h] [rbp-18h]
  void *v35; // [rsp+F0h] [rbp-10h] BYREF

  n0x1000 = 0x1000;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v24 = 1;
  v26 = __rdtsc();
  qword_149C89AA0(
    &n0x1000,
    &word_1516F22AC,
    "CEntitySystem::DoUpdateLoop",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\EntitySystem.cpp",
    0xE16);
  v2 = *(_QWORD *)(a1 + 0x7F8);
  v20 = 0;
  HIWORD(n0x1000) = word_1516F22AC;
  v21 = 0;
  v3 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v3;
  v21 = v3 + 1;
  *v3 = 0xFFFFFFFFFFFFFFFFuLL;
  *((_QWORD *)&v20 + 1) = v3 + 1;
  v4 = sub_146B4A6C0(v2, 4, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  v5 = *(_QWORD *)(a1 + 0x7F8);
  v22 = v4;
  v20 = 0;
  v21 = 0;
  v6 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v6;
  v21 = v6 + 1;
  *v6 = v4;
  *((_QWORD *)&v20 + 1) = v6 + 1;
  v7 = sub_146B4A6C0(v5, 5, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  v8 = *(_QWORD *)(a1 + 0x7F8);
  v22 = v7;
  v20 = 0;
  v21 = 0;
  v9 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v9;
  v21 = v9 + 1;
  *v9 = v7;
  *((_QWORD *)&v20 + 1) = v9 + 1;
  v10 = sub_146B4A6C0(v8, 6, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  v11 = *(_QWORD *)(a1 + 0x7F8);
  v22 = v10;
  v20 = 0;
  v21 = 0;
  v12 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v12;
  v21 = v12 + 1;
  *v12 = v10;
  *((_QWORD *)&v20 + 1) = v12 + 1;
  v13 = sub_146B4A6C0(v11, 7, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  sub_1402B3B60((__int64)v30, 0x26, 5, "MovieSystem-InitializeSequences");
  v22 = v13;
  sub_1405F1730(&v35, (char *)&v22, 1u);
  v34 = 1;
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, &p_sub_146C3ADD0);
    n2 = 0;
  }
  p_sub_146C3ADD0 = 0;
  v33 = sub_1402A65A0(1u);
  p_sub_146C3ADD0 = sub_146C3ADD0;
  n2 = (void (__fastcall *)(__int64, __int64 (**)()))sub_146C3B9A0;
  v14 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, v30);
  v15 = *(_QWORD *)(a1 + 0x7F8);
  v21 = 0;
  v20 = 0;
  v16 = v14;
  v17 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v17;
  v21 = v17 + 1;
  *v17 = v16;
  *((_QWORD *)&v20 + 1) = v17 + 1;
  v18 = sub_146B4A6C0(v15, 8, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x48LL))(qword_149C8E038, v18);
  sub_1402B6C70(v30);
  v27 = __rdtsc();
  return qword_149C89AA8(&n0x1000);
}

// --- End Function: sub_146C4B3F0 (0x146C4B3F0) ---

// --- Function: sub_146C4B3F0 (0x146C4B767) ---
__int64 __fastcall sub_146C4B3F0(__int64 a1)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdi
  _QWORD *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rdi
  _QWORD *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v16; // rbx
  _QWORD *v17; // rax
  __int64 v18; // rbx
  __int128 v20; // [rsp+30h] [rbp-D0h] BYREF
  _QWORD *v21; // [rsp+40h] [rbp-C0h]
  __int64 v22; // [rsp+48h] [rbp-B8h] BYREF
  int n0x1000; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v24; // [rsp+54h] [rbp-ACh]
  int v25; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v26; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v27; // [rsp+68h] [rbp-98h]
  __int64 v28; // [rsp+70h] [rbp-90h]
  __int64 v29; // [rsp+78h] [rbp-88h]
  _QWORD v30[3]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 (*p_sub_146C3ADD0)(); // [rsp+B8h] [rbp-48h] BYREF
  void (__fastcall *n2)(__int64, __int64 (**)()); // [rsp+C0h] [rbp-40h]
  __int64 v33; // [rsp+C8h] [rbp-38h]
  int v34; // [rsp+E8h] [rbp-18h]
  void *v35; // [rsp+F0h] [rbp-10h] BYREF

  n0x1000 = 0x1000;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v24 = 1;
  v26 = __rdtsc();
  qword_149C89AA0(
    &n0x1000,
    &word_1516F22AC,
    "CEntitySystem::DoUpdateLoop",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\EntitySystem.cpp",
    0xE16);
  v2 = *(_QWORD *)(a1 + 0x7F8);
  v20 = 0;
  HIWORD(n0x1000) = word_1516F22AC;
  v21 = 0;
  v3 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v3;
  v21 = v3 + 1;
  *v3 = 0xFFFFFFFFFFFFFFFFuLL;
  *((_QWORD *)&v20 + 1) = v3 + 1;
  v4 = sub_146B4A6C0(v2, 4, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  v5 = *(_QWORD *)(a1 + 0x7F8);
  v22 = v4;
  v20 = 0;
  v21 = 0;
  v6 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v6;
  v21 = v6 + 1;
  *v6 = v4;
  *((_QWORD *)&v20 + 1) = v6 + 1;
  v7 = sub_146B4A6C0(v5, 5, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  v8 = *(_QWORD *)(a1 + 0x7F8);
  v22 = v7;
  v20 = 0;
  v21 = 0;
  v9 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v9;
  v21 = v9 + 1;
  *v9 = v7;
  *((_QWORD *)&v20 + 1) = v9 + 1;
  v10 = sub_146B4A6C0(v8, 6, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  v11 = *(_QWORD *)(a1 + 0x7F8);
  v22 = v10;
  v20 = 0;
  v21 = 0;
  v12 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v12;
  v21 = v12 + 1;
  *v12 = v10;
  *((_QWORD *)&v20 + 1) = v12 + 1;
  v13 = sub_146B4A6C0(v11, 7, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  sub_1402B3B60((__int64)v30, 0x26, 5, "MovieSystem-InitializeSequences");
  v22 = v13;
  sub_1405F1730(&v35, (char *)&v22, 1u);
  v34 = 1;
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, &p_sub_146C3ADD0);
    n2 = 0;
  }
  p_sub_146C3ADD0 = 0;
  v33 = sub_1402A65A0(1u);
  p_sub_146C3ADD0 = sub_146C3ADD0;
  n2 = (void (__fastcall *)(__int64, __int64 (**)()))sub_146C3B9A0;
  v14 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, v30);
  v15 = *(_QWORD *)(a1 + 0x7F8);
  v21 = 0;
  v20 = 0;
  v16 = v14;
  v17 = (_QWORD *)sub_140394E70((__int64)&v20, 8u);
  *(_QWORD *)&v20 = v17;
  v21 = v17 + 1;
  *v17 = v16;
  *((_QWORD *)&v20 + 1) = v17 + 1;
  v18 = sub_146B4A6C0(v15, 8, (void **)&v20);
  if ( (_QWORD)v20 )
    sub_1403A6820((__int64)&v20, v20, ((unsigned __int64)v21 - v20) & 0xFFFFFFFFFFFFFFF8uLL);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x48LL))(qword_149C8E038, v18);
  sub_1402B6C70(v30);
  v27 = __rdtsc();
  return qword_149C89AA8(&n0x1000);
}

// --- End Function: sub_146C4B3F0 (0x146C4B767) ---

// --- Function: sub_146C4FB50 (0x146C4FB50) ---
__int64 __fastcall sub_146C4FB50(__int64 a1, unsigned int a2)
{
  return *(_QWORD *)(0x60 * ((unsigned __int64)a2 >> 0x18) + *(_QWORD *)(a1 + 0xF10)) + 0xF0LL * (a2 & 0xFFFFFF);
}

// --- End Function: sub_146C4FB50 (0x146C4FB50) ---

// --- Function: sub_146C4FB80 (0x146C4FB80) ---
unsigned __int64 __fastcall sub_146C4FB80(__int64 *a1, __int64 a2)
{
  __int64 v2; // r11
  __int64 v3; // r10
  __int64 v4; // r8
  unsigned __int64 result; // rax
  int n0x40; // ecx

  v2 = *a1;
  v3 = *a1 - 1;
  v4 = a1[2];
  result = v3
         & (0x80000001
          * ((0x15
            * ((0x109 * ((~a2 + (a2 << 0x15)) ^ ((unsigned __int64)(~a2 + (a2 << 0x15)) >> 0x18)))
             ^ ((0x109 * ((~a2 + (a2 << 0x15)) ^ ((unsigned __int64)(~a2 + (a2 << 0x15)) >> 0x18))) >> 0xE)))
           ^ ((0x15
             * ((0x109 * ((~a2 + (a2 << 0x15)) ^ ((unsigned __int64)(~a2 + (a2 << 0x15)) >> 0x18)))
              ^ ((0x109 * ((~a2 + (a2 << 0x15)) ^ ((unsigned __int64)(~a2 + (a2 << 0x15)) >> 0x18))) >> 0xE))) >> 0x1C)));
  if ( *(_QWORD *)(v4 + 8 * result) != a2 )
  {
    n0x40 = 0x40;
    while ( *(_QWORD *)(v4 + 8 * result) != a2 )
    {
      --n0x40;
      result = v3 & (result + 1);
      if ( n0x40 <= 0 )
        return v2;
    }
  }
  return result;
}

// --- End Function: sub_146C4FB80 (0x146C4FB80) ---

// --- Function: sub_146C53B40 (0x146C53B40) ---
__int64 __fastcall sub_146C53B40(__int64 a1, _QWORD *a2)
{
  return *(_QWORD *)(a1 + 0x120) + 0xC0LL * *(unsigned int *)((*a2 & 0xFFFFFFFFFFFFLL) + 0x2F0);
}

// --- End Function: sub_146C53B40 (0x146C53B40) ---

// --- Function: sub_146C540A0 (0x146C540A0) ---
unsigned __int64 *__fastcall sub_146C540A0(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // r9
  __int64 v5; // r10
  __int64 v7; // r11
  __int64 v8; // rdx
  unsigned __int64 *v9; // rcx
  unsigned __int64 *result; // rax
  __int64 v11; // rcx
  unsigned __int16 *v12; // rdi
  unsigned __int16 *v13; // rbp
  unsigned __int64 v14; // rbx
  __int64 v15; // rax
  __int16 n4; // cx
  unsigned __int64 v17; // [rsp+50h] [rbp+8h] BYREF

  v4 = a3 >> 6;
  v5 = 1LL << (a3 & 0x3F);
  v7 = *(_QWORD *)(a1 + 8 * (a3 >> 6) + 0x140);
  if ( (v7 & v5) != 0 )
  {
    v8 = 0;
    if ( v4 )
    {
      v9 = (unsigned __int64 *)(a1 + 0x140);
      do
      {
        v8 += __popcnt(*v9++);
        --v4;
      }
      while ( v4 );
    }
    result = a2;
    *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 8 * (v8 + __popcnt(v7 & (v5 - 1))));
  }
  else
  {
    v11 = *(_QWORD *)(qword_149C8DFC8 + 0x70);
    v12 = *(unsigned __int16 **)(v11 + 0x18 * a3);
    v13 = *(unsigned __int16 **)(v11 + 0x18 * a3 + 8);
    if ( v12 == v13 )
    {
LABEL_14:
      *a2 = 0;
    }
    else
    {
      while ( 1 )
      {
        sub_146C540A0(a1, &v17, *v12);
        if ( v17 )
        {
          v14 = HIWORD(v17);
          v15 = sub_1403B84E0(v17 & 0xFFFFFFFFFFFFLL);
          n4 = *(_WORD *)(v15 + 4);
          if ( n4 != 4
            && *(_WORD *)(v15 + 2) == (v14 & 0xFFF)
            && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v17)) )
          {
            break;
          }
        }
        if ( ++v12 == v13 )
          goto LABEL_14;
      }
      *a2 = v17;
    }
    return a2;
  }
  return result;
}

// --- End Function: sub_146C540A0 (0x146C540A0) ---

// --- Function: sub_146C54DB0 (0x146C54DB0) ---
unsigned __int64 *__fastcall sub_146C54DB0(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3, char a4)
{
  const char *v5; // rbx
  __int64 v8; // r9
  _QWORD *v9; // rcx
  unsigned __int64 v10; // rdx
  char v11; // al
  bool v12; // si
  signed __int64 v13; // rdx
  __int64 p_rw_lock_state; // rcx
  signed __int64 v15; // rdx
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  __int64 v18; // r14
  unsigned __int64 v19; // rax
  __int64 v20; // r14
  bool v21; // al
  int v22; // r14d
  int *ThreadLogContextSlot; // rax
  unsigned __int64 v24; // rax
  signed __int64 v25; // r15
  signed __int64 v26; // rdx
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // rax
  __int64 v29; // r14
  bool v30; // al
  int v31; // r14d
  int *ThreadLogContextSlot_1; // rax
  __int64 v34; // [rsp+20h] [rbp-E0h]
  const char *v35; // [rsp+28h] [rbp-D8h]
  const char *v36; // [rsp+30h] [rbp-D0h]
  bool v37; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v38; // [rsp+68h] [rbp-98h] BYREF
  unsigned __int64 v39; // [rsp+70h] [rbp-90h] BYREF
  const char *v40; // [rsp+78h] [rbp-88h] BYREF
  const char *v41; // [rsp+80h] [rbp-80h] BYREF
  const char *v42; // [rsp+88h] [rbp-78h] BYREF
  int *p_n0xD1; // [rsp+90h] [rbp-70h] BYREF
  _BYTE *v44; // [rsp+98h] [rbp-68h]
  __int128 v45; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v46; // [rsp+B0h] [rbp-50h] BYREF
  __int128 v47; // [rsp+B8h] [rbp-48h] BYREF
  int n0xD1; // [rsp+C8h] [rbp-38h] BYREF
  int n0x2B; // [rsp+CCh] [rbp-34h]
  int n0x30_1; // [rsp+D0h] [rbp-30h]
  _BYTE v51[4]; // [rsp+D4h] [rbp-2Ch] BYREF
  __int64 CurrentThreadId; // [rsp+D8h] [rbp-28h] BYREF
  int n0x30; // [rsp+E0h] [rbp-20h]
  char v54; // [rsp+E4h] [rbp-1Ch] BYREF
  __int64 v55; // [rsp+E8h] [rbp-18h] BYREF
  char *v56; // [rsp+F0h] [rbp-10h] BYREF
  const char *v57; // [rsp+150h] [rbp+50h] BYREF

  v57 = (const char *)a3;
  v5 = (const char *)a3;
  if ( a3 )
  {
    v8 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
    if ( v8 )
    {
      v9 = *(_QWORD **)(v8 + 0x10);
      v10 = (__int64)(*(_QWORD *)(v8 + 0x18) - (_QWORD)v9) >> 4;
      while ( v10 )
      {
        if ( v9[2 * (v10 >> 1)] >= (unsigned __int64)v5 )
        {
          v10 >>= 1;
        }
        else
        {
          v9 += 2 * (v10 >> 1) + 2;
          v10 += 0xFFFFFFFFFFFFFFFFuLL - (v10 >> 1);
        }
      }
      if ( v9 != *(_QWORD **)(v8 + 0x18) && (unsigned __int64)v5 >= *v9 )
      {
        *a2 = v9[1];
        return a2;
      }
      v11 = dword_1516F1EA4;
      v12 = dword_1516F1EA4 != 0;
      v37 = dword_149C0258C != 0;
      if ( dword_1516F1EA4 || dword_149C0258C )
        v11 = 1;
      if ( *(_DWORD *)(v8 + 8) == 1 || !v11 || !a4 )
      {
        if ( *(_DWORD *)(a1 + 0x140) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
        {
          ++*(_DWORD *)(a1 + 0x144);
        }
        else
        {
          v25 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x130));
          if ( (v25 & 0x200000) != 0 )
            rw_lock_acquire_read_lock_dispatch(
              a1 + 0x130,
              v25,
              "CEntitySystem::GetEntityFromIDInternal",
              "m_lookupLock",
              1);
          v5 = v57;
        }
        sub_146C67110(a1 + 0x148, a2, v5);
        p_rw_lock_state = a1 + 0x130;
        goto LABEL_90;
      }
      if ( *(_DWORD *)(a1 + 0x1038) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(a1 + 0x103C);
      }
      else
      {
        v13 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x1028));
        if ( (v13 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            a1 + 0x1028,
            v13,
            "CEntitySystem::GetEntityFromIDInternal",
            "m_canAccessEntityFromSpawnFiberLock",
            1);
        v5 = v57;
      }
      sub_140C0B920((_QWORD *)(a1 + 0x1040), &v46, (unsigned __int64 *)&v57);
      p_rw_lock_state = a1 + 0x1028;
      if ( v46 != *(_QWORD *)(a1 + 0x1048) )
      {
        *a2 = *(_QWORD *)(v46 + 0x18);
LABEL_90:
        rw_lock_release_read_lock(p_rw_lock_state);
        return a2;
      }
      if ( !v12 )
        goto LABEL_26;
      rw_lock_release_read_lock(p_rw_lock_state);
      if ( *(_DWORD *)(a1 + 0x140) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(a1 + 0x144);
      }
      else
      {
        v15 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x130));
        if ( (v15 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            a1 + 0x130,
            v15,
            "CEntitySystem::GetEntityFromIDInternal",
            "m_lookupLock",
            1);
        v5 = v57;
      }
      v16 = sub_146C4FB80((__int64 *)(a1 + 0x148), (__int64)v5);
      if ( v16 >= *(_QWORD *)(a1 + 0x148) )
      {
        v38 = 0;
      }
      else
      {
        v17 = *(_QWORD *)(*(_QWORD *)(a1 + 0x160) + 8 * v16);
        v38 = v17;
        if ( v17 )
        {
          v18 = v17 & 0xFFFFFFFFFFFFLL;
          v19 = HIWORD(v17);
          v20 = (v19 & 0xF000) != 0 ? v18 & 0xFFFFFF000000LL : v18 - 6;
          if ( *(_WORD *)(v20 + 2) == (v19 & 0xFFF) )
          {
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v21 = is_thread_privileged_or_bypass_mode()) )
              v21 = 1;
            if ( *(_WORD *)(v20 + 4) == 2 && v21 || sub_140395410(&v38) )
            {
              sub_146C556B0(v38 & 0xFFFFFFFFFFFFLL, &v40);
              CurrentThreadId = 0x2B000000D1LL;
              v55 = (__int64)&CurrentThreadId;
              v56 = &v54;
              n0x30 = 0x30;
              v22 = invokeGlobalCallbackAndMaskStatusBits(
                      3,
                      (__int64)&v55,
                      (__int64)"GetEntityFromID CrossBatchAccess",
                      "GetEntityFromID CrossBatchAccess: Entity %llu (%s) is a streamable entity that already spawned but"
                      " it is being accessed by spawning fiber",
                      v34,
                      v35);
              if ( (v22 & 0xFFFFF) != 0 )
              {
                v41 = v40;
                v42 = v5;
                ThreadLogContextSlot = getThreadLogContextSlot();
                n0xD1 = 0xD1;
                p_n0xD1 = &n0xD1;
                n0x2B = 0x2B;
                v44 = v51;
                n0x30_1 = 0x30;
                v45 = 0;
                sub_146C26D30(
                  3,
                  (__int64)&p_n0xD1,
                  "GetEntityFromID CrossBatchAccess",
                  (__int64)"GetEntityFromID CrossBatchAccess: Entity %llu (%s) is a streamable entity that already spawne"
                           "d but it is being accessed by spawning fiber",
                  1,
                  v22,
                  &v45,
                  0,
                  (__int64)ThreadLogContextSlot,
                  (__int64)&v42,
                  &v41);
              }
              sub_140373CC0(&v40);
            }
          }
        }
      }
      p_rw_lock_state = a1 + 0x130;
      if ( v37 )
      {
LABEL_26:
        *a2 = 0;
        goto LABEL_90;
      }
      v24 = v38;
      v38 = 0;
    }
    else
    {
      if ( *(_DWORD *)(a1 + 0x140) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(a1 + 0x144);
      }
      else
      {
        v26 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x130));
        if ( (v26 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            a1 + 0x130,
            v26,
            "CEntitySystem::GetEntityFromIDInternal",
            "m_lookupLock",
            1);
        v5 = v57;
      }
      v27 = sub_146C4FB80((__int64 *)(a1 + 0x148), (__int64)v5);
      if ( v27 >= *(_QWORD *)(a1 + 0x148) )
        v28 = 0;
      else
        v28 = *(_QWORD *)(*(_QWORD *)(a1 + 0x160) + 8 * v27);
      v39 = v28;
      if ( !*(_BYTE *)(NtCurrentTeb_w() + 0x12D) )
        is_thread_privileged_or_bypass_mode();
      if ( (dword_149C0258C || dword_1516F1EA4) && a4 && *(_QWORD *)NtCurrentTeb_w() && v39 )
      {
        v29 = (v39 & 0xF000000000000000uLL) != 0 ? v39 & 0xFFFFFF000000LL : (v39 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v29 + 2) == (HIWORD(v39) & 0xFFF) )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v30 = is_thread_privileged_or_bypass_mode()) )
            v30 = 1;
          if ( (*(_WORD *)(v29 + 4) == 2 && v30 || sub_140395410(&v39))
            && *(_BYTE *)((v39 & 0xFFFFFFFFFFFFLL) + 0xD) < 4u )
          {
            if ( dword_1516F1EA4 )
            {
              sub_146C556B0(v39 & 0xFFFFFFFFFFFFLL, &v40);
              n0xD1 = 0xD1;
              p_n0xD1 = &n0xD1;
              n0x2B = 0x2B;
              v44 = v51;
              n0x30_1 = 0x30;
              v31 = invokeGlobalCallbackAndMaskStatusBits(
                      3,
                      (__int64)&p_n0xD1,
                      (__int64)"GetEntityFromID Uninitialized CrossBatchAccess",
                      "GetEntityFromID Uninitialized CrossBatchAccess: Non-main thread (%llu) is trying to access uniniti"
                      "alized Entity %llu (%s)",
                      v34,
                      v35,
                      v36);
              if ( (v31 & 0xFFFFF) != 0 )
              {
                v42 = v40;
                v41 = v5;
                CurrentThreadId = GetCurrentThreadId();
                ThreadLogContextSlot_1 = getThreadLogContextSlot();
                v55 = 0x2B000000D1LL;
                *(_QWORD *)&v45 = &v55;
                *((_QWORD *)&v45 + 1) = (char *)&v56 + 4;
                LODWORD(v56) = 0x30;
                v47 = 0;
                sub_146C26E70(
                  3,
                  (__int64)&v45,
                  "GetEntityFromID Uninitialized CrossBatchAccess",
                  (__int64)"GetEntityFromID Uninitialized CrossBatchAccess: Non-main thread (%llu) is trying to access un"
                           "initialized Entity %llu (%s)",
                  1,
                  v31,
                  &v47,
                  0,
                  (__int64)ThreadLogContextSlot_1,
                  (__int64)&CurrentThreadId,
                  (__int64)&v41,
                  &v42);
              }
              sub_140373CC0(&v40);
            }
            if ( dword_149C0258C )
            {
              *a2 = 0;
              p_rw_lock_state = a1 + 0x130;
              goto LABEL_90;
            }
          }
        }
      }
      v24 = v39;
      p_rw_lock_state = a1 + 0x130;
      v39 = 0;
    }
    *a2 = v24;
    goto LABEL_90;
  }
  *a2 = 0;
  return a2;
}

// --- End Function: sub_146C54DB0 (0x146C54DB0) ---

// --- Function: sub_146C556B0 (0x146C556B0) ---
void **__fastcall sub_146C556B0(unsigned __int64 a1, void **a2)
{
  _BYTE *v4; // rdi
  size_t n0x1FF_1; // rbx
  _BYTE *v6; // rax
  char v7; // dl
  unsigned __int64 v8; // rcx
  unsigned __int16 v9; // ax
  size_t Size; // r8
  void **v11; // rax
  void **v12; // rsi
  const char *v13; // rbx
  const char *v14; // rdi
  const char *v15; // rax
  void **v16; // rax
  const char *v18; // [rsp+30h] [rbp-D0h] BYREF
  const char *v19; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int64 v20[2]; // [rsp+40h] [rbp-C0h] BYREF
  size_t n0x1FF_2; // [rsp+50h] [rbp-B0h] BYREF
  __int64 n0x1FF; // [rsp+58h] [rbp-A8h]
  void *v23; // [rsp+60h] [rbp-A0h]
  _BYTE v24[520]; // [rsp+68h] [rbp-98h] BYREF

  sub_14035E090(&v19);
  sub_14035E090(&v18);
  v4 = *(_BYTE **)(a1 + 0x298);
  v23 = v24;
  v24[0] = 0;
  n0x1FF_2 = 0;
  n0x1FF = 0x1FF;
  if ( v4 )
  {
    n0x1FF_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n0x1FF_1;
    while ( v4[n0x1FF_1] );
    if ( n0x1FF_1 )
    {
      v6 = v24;
      if ( n0x1FF_1 + 1 > 0x200 )
      {
        v6 = (_BYTE *)allocWithProfilerInfo(n0x1FF_1 + 1, 0);
        qword_149C78668 += n0x1FF_1 + 1;
        n0x1FF = n0x1FF_1;
      }
      v23 = v6;
      n0x1FF_2 = n0x1FF_1;
      v6[n0x1FF_1] = 0;
      memcpy(v23, v4, n0x1FF_1);
    }
  }
  if ( qword_1516F20B8 > a1 || a1 >= qword_1516F20C0 + qword_1516F20B8 )
  {
    v7 = 0;
    v8 = a1 - 6;
  }
  else
  {
    v7 = 1;
    v8 = a1 & 0xFFFFFFFFFF000000uLL;
  }
  v9 = *(_WORD *)(v8 + 2) | 0x2000;
  if ( !v7 )
    v9 = *(_WORD *)(v8 + 2);
  v20[0] = a1 | ((unsigned __int64)v9 << 0x30);
  if ( is_entity_descriptor_valid_or_accessible(v20) )
  {
    sub_146C56D10(a1, &v19, &v18);
  }
  else
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( aUninitialized_1[Size] );
    sub_1402E13B0(&n0x1FF_2, "(uninitialized)", Size);
  }
  sub_14035E090(v20);
  v12 = v11;
  v13 = v19;
  v14 = v18;
  v15 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x20) + 0x18LL))(*(_QWORD *)(a1 + 0x20));
  v16 = sub_1403ACC80(v12, "%s - Class(%s) - Context(%s) - Socpak(%s)", (const char *)v23, v15, v14, v13);
  sub_14035DE10(a2, (const void **)v16);
  sub_140373CC0(v20);
  if ( v23 != v24 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
    sub_147715880(v23);
  }
  sub_140373CC0(&v18);
  sub_140373CC0(&v19);
  return a2;
}

// --- End Function: sub_146C556B0 (0x146C556B0) ---

// --- Function: sub_146C56D10 (0x146C56D10) ---
char __fastcall sub_146C56D10(__int64 a1, _QWORD *a2, void **a3)
{
  int v6; // eax
  bool v7; // r12
  __int64 v9; // rbx
  __int64 (__fastcall *v10)(__int64, _BYTE *, __int64 *); // rdi
  __int16 n0xFFFF_2; // ax
  __int64 v12; // rbx
  __int64 v13; // r8
  __int16 n4; // dx
  __int64 v15; // rax
  const char *p_%s_Movable; // rdx
  __int64 (__fastcall *v17)(__int64, _BYTE *, __int64 *); // rbx
  __int16 n0xFFFF; // ax
  __int64 v19; // rbx
  __int64 v20; // rax
  __int16 n4_1; // r8
  __int64 v22; // rax
  __int64 (__fastcall *v23)(__int64, _BYTE *, __int64 *); // rbx
  __int16 n0xFFFF_3; // ax
  bool valid; // al
  const char *p_Movable; // r8
  __int64 (__fastcall *v27)(__int64, _BYTE *, __int64 *); // rbx
  __int16 n0xFFFF_1; // ax
  __int64 v29; // rdi
  __int64 (__fastcall *v30)(__int64, _QWORD); // rbx
  unsigned int v31; // eax
  __int64 v32; // rax
  const char *p_Unstreamable; // r8
  __int64 (__fastcall *v34)(__int64, _BYTE *, __int64 *); // rbx
  __int16 n0xFFFF_4; // ax
  __int64 v36; // rbx
  __int64 v37; // r8
  __int16 n4_2; // dx
  __int64 v39; // rax
  const char *p_Unstreamable_1; // r8
  _BYTE v41[16]; // [rsp+20h] [rbp-20h] BYREF
  __int64 v42; // [rsp+70h] [rbp+30h] BYREF
  __int64 v43; // [rsp+88h] [rbp+48h] BYREF

  assignCStringToStringStructure((__int64)a2, (__int64)&p_Src);
  assignCStringToStringStructure((__int64)a3, (__int64)&p_Src);
  v6 = *(_DWORD *)(a1 + 0x118);
  v7 = (v6 & 0x2000) != 0;
  if ( (_BYTE)qword_149C8E516 && (v6 & 1) != 0 )
  {
    assignCStringToStringStructure((__int64)a3, (__int64)"Placed editor object");
    return 1;
  }
  v42 = *(_QWORD *)(a1 + 0x18);
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v42) )
  {
    v9 = *(_QWORD *)(a1 + 0x18) & 0xFFFFFFFFFFFFLL;
    v10 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v9 + 0x340LL);
    n0xFFFF_2 = n0xFFFF_36;
    if ( n0xFFFF_36 == (__int16)0xFFFF )
    {
      n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                        + 0x10LL))(
                              qword_149C8DFC8,
                              &v43,
                              "IEntityComponentObjectContainer");
      n0xFFFF_36 = n0xFFFF_2;
    }
    LOWORD(v42) = n0xFFFF_2;
    v12 = *(_QWORD *)v10(v9, v41, &v42);
    v42 = v12;
    if ( v12 )
    {
      v13 = sub_1403B84E0(v12 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v13 + 4);
      if ( n4 != 4
        && *(_WORD *)(v13 + 2) == (HIWORD(v12) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v42)) )
      {
        v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v12 & 0xFFFFFFFFFFFFLL) + 0x578LL))(v12 & 0xFFFFFFFFFFFFLL);
        assignCStringToStringStructure((__int64)a2, v15);
        p_%s_Movable = "%s Immovable";
LABEL_33:
        p_Unstreamable = "Streamable";
        if ( v7 )
          p_Unstreamable = "Unstreamable";
        sub_1403ACC80(a3, p_%s_Movable, p_Unstreamable);
        return !sub_1403C3450(a2);
      }
    }
  }
  else
  {
    v17 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)a1 + 0x340LL);
    n0xFFFF = n0xFFFF_36;
    if ( n0xFFFF_36 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                      + 0x10LL))(
                            qword_149C8DFC8,
                            &v43,
                            "IEntityComponentObjectContainer");
      n0xFFFF_36 = n0xFFFF;
    }
    LOWORD(v42) = n0xFFFF;
    v19 = *(_QWORD *)v17(a1, v41, &v42);
    v42 = v19;
    if ( v19 )
    {
      v20 = sub_1403B84E0(v19 & 0xFFFFFFFFFFFFLL);
      n4_1 = *(_WORD *)(v20 + 4);
      if ( n4_1 != 4
        && *(_WORD *)(v20 + 2) == (HIWORD(v19) & 0xFFF)
        && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v42)) )
      {
        v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v19 & 0xFFFFFFFFFFFFLL) + 0x578LL))(v19 & 0xFFFFFFFFFFFFLL);
        assignCStringToStringStructure((__int64)a2, v22);
        if ( v7 )
        {
          assignCStringToStringStructure((__int64)a3, (__int64)"Unstreamable Immovable");
          return !sub_1403C3450(a2);
        }
        v23 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)a1 + 0x340LL);
        n0xFFFF_3 = n0xFFFF_37;
        if ( n0xFFFF_37 == (__int16)0xFFFF )
        {
          n0xFFFF_3 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                            + 0x10LL))(
                                  qword_149C8DFC8,
                                  &v43,
                                  "EntityComponentDynamicInstanceProperties");
          n0xFFFF_37 = n0xFFFF_3;
        }
        LOWORD(v42) = n0xFFFF_3;
        v42 = *(_QWORD *)v23(a1, v41, &v42);
        valid = is_valid_handle_typeA(&v42);
        p_Movable = "Immovable";
        if ( valid )
          p_Movable = "Movable";
        sub_1403ACC80(a3, "Streamable %s", p_Movable);
        return !sub_1403C3450(a2);
      }
    }
    v27 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)a1 + 0x340LL);
    n0xFFFF_1 = n0xFFFF_37;
    if ( n0xFFFF_37 == (__int16)0xFFFF )
    {
      n0xFFFF_1 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                        + 0x10LL))(
                              qword_149C8DFC8,
                              &v43,
                              "EntityComponentDynamicInstanceProperties");
      n0xFFFF_37 = n0xFFFF_1;
    }
    LOWORD(v42) = n0xFFFF_1;
    v43 = *(_QWORD *)v27(a1, v41, &v42);
    v42 = v43;
    if ( is_valid_handle_typeA(&v42) )
    {
      v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x258LL))(qword_149C8DFE0);
      v30 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v29 + 0xF8LL);
      v31 = sub_1403B9CD0(v43 & 0xFFFFFFFFFFFFLL);
      v32 = v30(v29, v31);
      assignCStringToStringStructure((__int64)a2, v32);
      p_%s_Movable = "%s Movable";
      goto LABEL_33;
    }
    v34 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)a1 + 0x340LL);
    n0xFFFF_4 = n0xFFFF_38;
    if ( n0xFFFF_38 == (__int16)0xFFFF )
    {
      n0xFFFF_4 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                        + 0x10LL))(
                              qword_149C8DFC8,
                              &v43,
                              "IAttachableComponent");
      n0xFFFF_38 = n0xFFFF_4;
    }
    LOWORD(v42) = n0xFFFF_4;
    v36 = *(_QWORD *)v34(a1, v41, &v42);
    v42 = v36;
    if ( v36 )
    {
      v37 = sub_1403B84E0(v36 & 0xFFFFFFFFFFFFLL);
      n4_2 = *(_WORD *)(v37 + 4);
      if ( n4_2 != 4
        && *(_WORD *)(v37 + 2) == (HIWORD(v36) & 0xFFF)
        && (n4_2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140395350(&v42)) )
      {
        v39 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v36 & 0xFFFFFFFFFFFFLL) + 0x608LL))(v36 & 0xFFFFFFFFFFFFLL);
        if ( v39 )
        {
          v42 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0xD0LL))(v39) + 8);
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v42) )
            return sub_146C56D10(v42 & 0xFFFFFFFFFFFFLL, a2, a3);
        }
      }
    }
    p_Unstreamable_1 = "Streamable";
    if ( v7 )
      p_Unstreamable_1 = "Unstreamable";
    sub_1403ACC80(a3, "%s Runtime-spawned", p_Unstreamable_1);
  }
  return 0;
}

// --- End Function: sub_146C56D10 (0x146C56D10) ---

// --- Function: sub_146C586A0 (0x146C586A0) ---
__int64 __fastcall sub_146C586A0(__int64 a1)
{
  unsigned __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4_1; // dx
  __int64 v5; // rdi
  __int64 v6; // rax
  __int16 n4_2; // cx
  unsigned __int16 n0xFFFF; // ax
  unsigned __int64 v10; // rbx
  __int64 v11; // rsi
  __int64 v12; // rax
  __int16 n4; // cx
  unsigned __int64 v14; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v15; // [rsp+48h] [rbp+10h] BYREF

  v1 = *(_QWORD *)(a1 + 0x4D8);
  v14 = v1;
  if ( !v1
    || (v3 = sub_1403B84E0(v1 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v3 + 4), n4_1 == 4)
    || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF)
    || (n4_1 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_140322850(&v14) )
  {
    n0xFFFF = n0xFFFF_39;
    if ( n0xFFFF_39 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                               + 0x10LL))(
                            qword_149C8DFC8,
                            &v14,
                            "PhysicalProxy");
      n0xFFFF_39 = n0xFFFF;
    }
    if ( *(_BYTE *)(a1 + 0xD) == 7 )
    {
      *(_QWORD *)(a1 + 0x4D8) = 0;
    }
    else
    {
      sub_146C540A0(a1, &v15, n0xFFFF);
      v10 = v15;
      v14 = v15;
      *(_QWORD *)(a1 + 0x4D8) = v15;
      if ( v10 )
      {
        v11 = v10 & 0xFFFFFFFFFFFFLL;
        v12 = sub_1403B84E0(v10 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(v12 + 4);
        if ( n4 != 4
          && *(_WORD *)(v12 + 2) == (HIWORD(v10) & 0xFFF)
          && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v14)) )
        {
          return v11;
        }
      }
    }
    return 0;
  }
  v5 = v1 & 0xFFFFFFFFFFFFLL;
  v6 = sub_1403B84E0(v1 & 0xFFFFFFFFFFFFLL);
  n4_2 = *(_WORD *)(v6 + 4);
  if ( n4_2 == 4
    || *(_WORD *)(v6 + 2) != (HIWORD(v1) & 0xFFF)
    || (n4_2 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_140322850(&v14) )
  {
    return 0;
  }
  return v5;
}

// --- End Function: sub_146C586A0 (0x146C586A0) ---

// --- Function: sub_146C58840 (0x146C58840) ---
unsigned __int64 *__fastcall sub_146C58840(__int64 a1, unsigned __int64 *a2)
{
  __int64 v4; // rax
  unsigned __int64 *result; // rax
  unsigned __int16 n0xFFFF; // ax
  __int16 v7; // rbx^6
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int16 n4; // cx
  __int64 v11; // rcx
  unsigned __int64 v12; // [rsp+50h] [rbp+18h] BYREF
  unsigned __int64 v13; // [rsp+58h] [rbp+20h] BYREF

  v4 = sub_146C586A0(a1);
  if ( v4 && (sub_142E61D20(v4, &v12), v12) && *(_QWORD *)((v12 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v12) )
  {
    *a2 = v12;
    return a2;
  }
  else
  {
    n0xFFFF = n0xFFFF_40;
    if ( n0xFFFF_40 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 *, const char *))(*(_QWORD *)qword_149C8DFC8
                                                                                               + 0x10LL))(
                            qword_149C8DFC8,
                            &v12,
                            "RopeProxy");
      n0xFFFF_40 = n0xFFFF;
    }
    if ( *(_BYTE *)(a1 + 0xD) != 7
      && (sub_146C540A0(a1, &v13, n0xFFFF), v7 = HIWORD(v13), v13)
      && (v8 = v13 & 0xFFFFFFFFFFFFLL, v9 = sub_1403B84E0(v13 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v9 + 4), n4 != 4)
      && *(_WORD *)(v9 + 2) == (v7 & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v13))
      && v8
      && (v11 = *(_QWORD *)(v8 + 0x70)) != 0 )
    {
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v11 + 0xE8LL))(v11, a2);
      return a2;
    }
    else
    {
      result = a2;
      *a2 = 0;
    }
  }
  return result;
}

// --- End Function: sub_146C58840 (0x146C58840) ---

// --- Function: sub_146C58D00 (0x146C58D00) ---
__int64 __fastcall sub_146C58D00(__int64 a1, __int64 a2, unsigned int n2_1, unsigned __int8 n2_2)
{
  int n2; // ebx
  unsigned __int64 *v6; // rcx
  __int64 v9; // rax
  char v11; // di
  char v12; // bp
  __int64 p_rw_lock_state; // rbx
  signed __int64 v14; // rdx
  signed __int64 v15; // r12
  bool v16; // zf
  __int64 n0xF8; // rax

  n2 = n2_2;
  v6 = *(unsigned __int64 **)(a1 + 0x130);
  if ( v6 )
  {
    if ( is_entity_descriptor_valid_or_accessible(v6) )
    {
      v9 = *(_QWORD *)(a1 + 0x130);
      if ( *(_DWORD *)(v9 + 0x10) == 5 )
      {
        sub_146C58D00(*(_QWORD *)v9 & 0xFFFFFFFFFFFFLL, a2, n2_1, n2);
        return a2;
      }
    }
  }
  if ( !(_BYTE)n2 || n2 == 2 )
  {
    v11 = 0;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xE8LL))(qword_149C8DF28);
  }
  else
  {
    v11 = 1;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xE8LL))(qword_149C8DF28) )
    {
      v12 = 1;
      p_rw_lock_state = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x98LL))(qword_149C8DF28);
      if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(p_rw_lock_state + 0x14);
      }
      else
      {
        v14 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
        if ( (v14 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            p_rw_lock_state,
            v14,
            "CEntity::GetPos",
            "gEnv->pZoneSystem->GetGlobalStateLock()",
            1);
      }
      goto LABEL_14;
    }
  }
  v12 = 0;
  p_rw_lock_state = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x98LL))(qword_149C8DF28);
LABEL_14:
  if ( v11 )
  {
    if ( *(_DWORD *)(a1 + 0xD0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0xD4);
    }
    else
    {
      v15 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0xC0));
      if ( (v15 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(a1 + 0xC0, v15, "CEntity::GetPos", "m_cross_ecus_state.updateLock", 1);
    }
  }
  if ( n2_1 == 2 )
  {
    v16 = v11 == 0;
    n0xF8 = 0xF8;
    if ( !v11 )
      n0xF8 = 0x48;
    *(_OWORD *)a2 = *(_OWORD *)(n0xF8 + a1);
    *(double *)(a2 + 0x10) = *(double *)(n0xF8 + a1 + 0x10);
  }
  else
  {
    (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)qword_149C8DF28 + 0x2D8LL))(
      qword_149C8DF28,
      a2,
      a1 + 0x2A8,
      n2_1);
    v16 = v11 == 0;
  }
  if ( !v16 )
    rw_lock_release_read_lock(a1 + 0xC0);
  if ( v12 )
    rw_lock_release_read_lock(p_rw_lock_state);
  return a2;
}

// --- End Function: sub_146C58D00 (0x146C58D00) ---

// --- Function: sub_146C5B680 (0x146C5B680) ---
unsigned __int64 __fastcall sub_146C5B680(__int64 a1)
{
  unsigned __int16 n0xFFFF; // ax
  __int16 v3; // rbx^6
  unsigned __int64 v4; // rdi
  __int64 v5; // rax
  __int16 n4; // cx
  char v8; // [rsp+30h] [rbp+8h] BYREF
  unsigned __int64 v9; // [rsp+38h] [rbp+10h] BYREF

  n0xFFFF = n0xFFFF_41;
  if ( n0xFFFF_41 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149C8DFC8 + 0x10LL))(
                          qword_149C8DFC8,
                          &v8,
                          "RenderProxy");
    n0xFFFF_41 = n0xFFFF;
  }
  if ( *(_BYTE *)(a1 + 0xD) != 7
    && (sub_146C540A0(a1, &v9, n0xFFFF), v3 = HIWORD(v9), v9)
    && (v4 = v9 & 0xFFFFFFFFFFFFLL, v5 = sub_1403B84E0(v9 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v5 + 4), n4 != 4)
    && *(_WORD *)(v5 + 2) == (v3 & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v9)) )
  {
    return v4;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_146C5B680 (0x146C5B680) ---

// --- Function: sub_146C5C540 (0x146C5C540) ---
__int64 __fastcall sub_146C5C540(unsigned __int64 a1, __int64 a2, int n2_1, int a4, char a5, unsigned __int8 n2)
{
  unsigned __int64 *v7; // rcx
  __int64 v10; // r12
  _DWORD *v11; // rax
  unsigned __int64 *v13; // rcx
  signed __int64 v14; // rdx
  char v15; // dl
  unsigned __int64 v16; // rcx
  unsigned __int16 v17; // ax
  unsigned __int64 v18; // rdx
  __int64 v19; // rbx
  __int64 v20; // rdi
  unsigned __int64 v21; // rax
  bool v22; // al
  int v23; // edx
  char v24; // di
  char v25; // r15
  __int64 p_rw_lock_state; // rbx
  signed __int64 v27; // rdx
  signed __int64 v28; // r13
  bool v29; // zf
  __int64 n0xD8; // rdx
  unsigned __int64 i; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int64 v32; // [rsp+38h] [rbp-40h] BYREF
  unsigned __int64 v33; // [rsp+40h] [rbp-38h] BYREF
  __int128 v34; // [rsp+48h] [rbp-30h] BYREF
  __int64 v35; // [rsp+58h] [rbp-20h]

  v7 = *(unsigned __int64 **)(a1 + 0x130);
  v10 = a2;
  if ( v7 )
  {
    if ( is_entity_descriptor_valid_or_accessible(v7) )
    {
      v11 = *(_DWORD **)(a1 + 0x130);
      if ( v11[4] == 5 )
      {
        sub_146C5C540(*v11, v10, n2_1, a4, a5, n2);
        return v10;
      }
    }
  }
  if ( a5 )
  {
    if ( *(_BYTE *)(a1 + 0xB8) )
    {
      v13 = *(unsigned __int64 **)(a1 + 0x130);
      if ( v13 )
      {
        if ( is_entity_descriptor_valid_or_accessible(v13) )
        {
          if ( dword_149C026B8 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
          {
            ++dword_149C026BC;
          }
          else
          {
            v14 = _InterlockedIncrement64(&rw_lock_state);
            if ( (v14 & 0x200000) != 0 )
              rw_lock_acquire_read_lock_dispatch(
                (__int64)&rw_lock_state,
                v14,
                "CEntity::GetTransform",
                "s_aggregateHierarchyLock",
                1);
          }
          v35 = 0;
          v34 = 0;
          if ( qword_1516F20B8 > a1 || a1 >= qword_1516F20C0 + qword_1516F20B8 )
          {
            v15 = 0;
            v16 = a1 - 6;
          }
          else
          {
            v15 = 1;
            v16 = a1 & 0xFFFFFFFFFF000000uLL;
          }
          v17 = *(_WORD *)(v16 + 2) | 0x2000;
          if ( !v15 )
            v17 = *(_WORD *)(v16 + 2);
          v33 = a1 | ((unsigned __int64)v17 << 0x30);
          sub_146C1FA70(&v34, &v33);
          for ( i = **(_QWORD **)(a1 + 0x130);
                is_entity_descriptor_valid_or_accessible(&i);
                i = **(_QWORD **)((i & 0xFFFFFFFFFFFFLL) + 0x130) )
          {
            sub_146C1F760(&v34, &i);
          }
          v18 = v34;
          v19 = *((_QWORD *)&v34 + 1) - 8LL;
          v20 = *(_QWORD *)(*((_QWORD *)&v34 + 1) - 8LL);
          if ( *((_QWORD *)&v34 + 1) - 8LL != (_QWORD)v34 )
          {
            do
            {
              v21 = *(_QWORD *)(v19 - 8);
              v19 -= 8;
              v32 = v21;
              v22 = is_entity_descriptor_valid_or_accessible(&v32);
              v23 = v32;
              if ( !v22 )
                v23 = 0;
              sub_146C8D200(v20, v23, n2, 0, 0);
              v18 = v34;
              LODWORD(v20) = v32;
            }
            while ( v19 != (_QWORD)v34 );
            v10 = a2;
          }
          if ( v18 )
          {
            sub_1403A6820((__int64)&v34, v18, (v35 - v18) & 0xFFFFFFFFFFFFFFF8uLL);
            v34 = 0;
            v35 = 0;
          }
          rw_lock_release_read_lock((__int64)&rw_lock_state);
        }
      }
    }
  }
  if ( !n2 || n2 == 2 )
  {
    v24 = 0;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xE8LL))(qword_149C8DF28);
  }
  else
  {
    v24 = 1;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xE8LL))(qword_149C8DF28) )
    {
      v25 = 1;
      p_rw_lock_state = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x98LL))(qword_149C8DF28);
      if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(p_rw_lock_state + 0x14);
      }
      else
      {
        v27 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
        if ( (v27 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            p_rw_lock_state,
            v27,
            "CEntity::GetTransform",
            "gEnv->pZoneSystem->GetGlobalStateLock()",
            1);
      }
      goto LABEL_38;
    }
  }
  v25 = 0;
  p_rw_lock_state = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x98LL))(qword_149C8DF28);
LABEL_38:
  if ( v24 )
  {
    if ( *(_DWORD *)(a1 + 0xD0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0xD4);
    }
    else
    {
      v28 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0xC0));
      if ( (v28 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(a1 + 0xC0, v28, "CEntity::GetTransform", "m_cross_ecus_state.updateLock", 1);
    }
  }
  if ( n2_1 == 2 )
  {
    v29 = v24 == 0;
    n0xD8 = 0xD8;
    if ( !v24 )
      n0xD8 = 0x28;
    *(_QWORD *)(v10 + 0x18) = *(_QWORD *)(n0xD8 + a1 + 0x18);
    *(_QWORD *)v10 = *(_QWORD *)(n0xD8 + a1);
    *(_QWORD *)(v10 + 8) = *(_QWORD *)(n0xD8 + a1 + 8);
    *(_QWORD *)(v10 + 0x10) = *(_QWORD *)(n0xD8 + a1 + 0x10);
    *(_OWORD *)(v10 + 0x20) = *(_OWORD *)(n0xD8 + a1 + 0x20);
    *(double *)(v10 + 0x30) = *(double *)(n0xD8 + a1 + 0x30);
    *(_QWORD *)(v10 + 0x38) = *(_QWORD *)(n0xD8 + a1 + 0x38);
  }
  else
  {
    (*(void (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)qword_149C8DF28 + 0x2F0LL))(
      qword_149C8DF28,
      v10,
      a1 + 0x2A8);
    v29 = v24 == 0;
  }
  if ( !v29 )
    rw_lock_release_read_lock(a1 + 0xC0);
  if ( v25 )
    rw_lock_release_read_lock(p_rw_lock_state);
  return v10;
}

// --- End Function: sub_146C5C540 (0x146C5C540) ---

// --- Function: sub_146C5D7C0 (0x146C5D7C0) ---
double *__fastcall sub_146C5D7C0(unsigned __int64 a1, double *a2, unsigned __int8 n2)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int128 v5; // xmm8
  __int128 v6; // xmm9
  __int128 v7; // xmm10
  __int128 v8; // xmm11
  __int128 v9; // xmm12
  __int128 v10; // xmm13
  __int128 v11; // xmm14
  double v13; // xmm8_8
  double v14; // xmm3_8
  double *result; // rax
  double v16; // xmm6_8
  double v17; // xmm12_8
  double v18; // xmm14_8
  double v19; // xmm10_8
  double v20; // xmm9_8
  double v21; // xmm13_8
  double v22; // xmm11_8
  double v23; // xmm3_8
  double v24; // kr00_8
  double v25; // xmm5_8
  double v26; // xmm8_8
  double v27; // xmm2_8
  double v28; // xmm0_8
  double v29; // xmm1_8
  double v30; // [rsp+30h] [rbp-D8h] BYREF
  double v31; // [rsp+38h] [rbp-D0h]
  double v32; // [rsp+40h] [rbp-C8h]
  double v33; // [rsp+48h] [rbp-C0h]
  double v34; // [rsp+50h] [rbp-B8h]
  double v35; // [rsp+58h] [rbp-B0h]
  double v36; // [rsp+60h] [rbp-A8h]
  double v37; // [rsp+68h] [rbp-A0h]
  __int128 v38; // [rsp+70h] [rbp-98h]
  __int128 v39; // [rsp+80h] [rbp-88h]
  __int128 v40; // [rsp+90h] [rbp-78h]
  __int128 v41; // [rsp+A0h] [rbp-68h]
  __int128 v42; // [rsp+B0h] [rbp-58h]
  __int128 v43; // [rsp+C0h] [rbp-48h]
  __int128 v44; // [rsp+D0h] [rbp-38h]
  __int128 v45; // [rsp+E0h] [rbp-28h]
  __int128 v46; // [rsp+F0h] [rbp-18h]

  v46 = v3;
  v45 = v4;
  v44 = v5;
  v43 = v6;
  v42 = v7;
  v41 = v8;
  v40 = v9;
  v39 = v10;
  v38 = v11;
  sub_146C5C540(a1, (__int64)&v30, 0, dword_149C8E13C, 0, n2);
  v13 = v30;
  v14 = v31;
  result = a2;
  v16 = v32 + v32;
  v17 = (v13 + v13) * v33;
  v18 = 1.0 - (v13 + v13) * v13;
  v19 = (v14 + v14) * v33;
  v20 = (v14 + v14) * v30;
  v21 = (v14 + v14) * v14;
  v22 = (v32 + v32) * v31;
  v23 = (v32 + v32) * v33;
  v24 = (v32 + v32) * v32;
  v25 = v37;
  *a2 = (1.0 - v21 - v24) * v37;
  v26 = v16 * v13;
  a2[1] = (v20 - v23) * v25;
  v27 = v34;
  a2[2] = (v26 + v19) * v25;
  a2[3] = v27;
  a2[4] = (v23 + v20) * v25;
  a2[5] = (v18 - v24) * v25;
  v28 = v35;
  a2[6] = (v22 - v17) * v25;
  a2[7] = v28;
  a2[8] = (v26 - v19) * v25;
  a2[9] = (v22 + v17) * v25;
  v29 = v36;
  a2[0xA] = (v18 - v21) * v25;
  a2[0xB] = v29;
  return result;
}

// --- End Function: sub_146C5D7C0 (0x146C5D7C0) ---

// --- Function: sub_146C64D40 (0x146C64D40) ---
bool __fastcall sub_146C64D40(unsigned __int64 a1)
{
  return qword_1516F20B8 <= a1 && a1 < qword_1516F20C0 + qword_1516F20B8;
}

// --- End Function: sub_146C64D40 (0x146C64D40) ---

// --- Function: sub_146C65180 (0x146C65180) ---
bool __fastcall sub_146C65180(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  if ( (*(_DWORD *)(a1 + 0x118) & 0x1800) == 0x1000
    && is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x318))
    && (((unsigned __int8)(*(_DWORD *)(a1 + 0x118) >> 0xD)
       ^ (unsigned __int8)(*(_DWORD *)((*(_QWORD *)(a1 + 0x318) & 0xFFFFFFFFFFFFLL) + 0x118) >> 0xD))
      & 1) != 0 )
  {
    return 1;
  }
  if ( (*(_BYTE *)(a1 + 0x4F8) & 3) == 0 )
  {
    v4 = *(_QWORD *)(a1 + 0x4F0);
    if ( is_entity_descriptor_valid_or_accessible(&v4) )
    {
      v2 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v4 & 0xFFFFFFFFFFFFLL);
      if ( v2 )
        return (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x48LL))(v2) != 2;
    }
    return 1;
  }
  return 0;
}

// --- End Function: sub_146C65180 (0x146C65180) ---

// --- Function: sub_146C67110 (0x146C67110) ---
_QWORD *__fastcall sub_146C67110(__int64 *a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v5; // rax

  v5 = sub_146C4FB80(a1, a3);
  if ( v5 >= *a1 )
    *a2 = 0;
  else
    *a2 = *(_QWORD *)(a1[3] + 8 * v5);
  return a2;
}

// --- End Function: sub_146C67110 (0x146C67110) ---

// --- Function: sub_146C71280 (0x146C71280) ---
unsigned __int64 __fastcall sub_146C71280(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  __int64 v6; // r14
  __int64 v7; // rbp
  char *v8; // rsi
  _QWORD *v9; // rsi
  _QWORD *i; // rbx

  v4 = (__int64)(*(_QWORD *)(a1 + 0x248) - *(_QWORD *)(a1 + 0x240)) >> 3;
  result = (__int64)(*(_QWORD *)(a2 + 0x10) - *(_QWORD *)a2) >> 1;
  if ( v4 > result )
  {
    if ( v4 > 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v6 = 2 * v4;
    v7 = (__int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 1;
    v8 = (char *)sub_140394E70(a2, 2 * v4);
    memmove(v8, *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
    if ( *(_QWORD *)a2 )
      sub_1403A6820(a2, *(_QWORD *)a2, 2 * ((__int64)(*(_QWORD *)(a2 + 0x10) - *(_QWORD *)a2) >> 1));
    *(_QWORD *)a2 = v8;
    *(_QWORD *)(a2 + 8) = &v8[2 * v7];
    result = (unsigned __int64)&v8[v6];
    *(_QWORD *)(a2 + 0x10) = &v8[v6];
  }
  v9 = *(_QWORD **)(a1 + 0x248);
  for ( i = *(_QWORD **)(a1 + 0x240); i != v9; ++i )
    result = sub_140309F90((unsigned __int64 *)a2, (_WORD *)((*i & 0xFFFFFFFFFFFFLL) + 0x10));
  return result;
}

// --- End Function: sub_146C71280 (0x146C71280) ---

// --- Function: sub_146C73360 (0x146C73360) ---
__int64 __fastcall sub_146C73360(__int64 a1)
{
  char v2; // r14
  __int64 p_rw_lock_state; // rdi
  signed __int64 v4; // rdx
  signed __int64 v5; // rsi
  __int64 v6; // rsi

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0xE8LL))(qword_149C8DF28);
  p_rw_lock_state = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x98LL))(qword_149C8DF28);
  if ( !v2 )
  {
    if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(p_rw_lock_state + 0x14);
    }
    else
    {
      v4 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
      if ( (v4 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(
          p_rw_lock_state,
          v4,
          "CEntity::ReadTags",
          "gEnv->pZoneSystem->GetGlobalStateLock()",
          1);
    }
  }
  if ( *(_DWORD *)(a1 + 0xD0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0xD4);
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0xC0));
    if ( (v5 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0xC0, v5, "CEntity::ReadTags", "m_cross_ecus_state.updateLock", 1);
  }
  v6 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF28 + 0x400LL))(qword_149C8DF28, a1 + 0x2A8);
  rw_lock_release_read_lock(a1 + 0xC0);
  if ( !v2 )
    rw_lock_release_read_lock(p_rw_lock_state);
  return v6;
}

// --- End Function: sub_146C73360 (0x146C73360) ---

// --- Function: sub_146C77E70 (0x146C77E70) ---
signed __int16 __fastcall sub_146C77E70(_QWORD *a1, unsigned int a2)
{
  unsigned __int64 v2; // rdi
  unsigned int *v3; // rbx
  signed __int16 result; // ax
  char *v5; // rcx

  v2 = a1[0x1E2] + 0x60 * ((unsigned __int64)a2 >> 0x18);
  v3 = (unsigned int *)(*(_QWORD *)v2 + 0xF0LL * (a2 & 0xFFFFFF));
  result = _InterlockedExchangeAdd16((volatile signed __int16 *)v3 + 5, 0xFFFFu);
  if ( result == 1 )
  {
    if ( (unsigned __int64)v3[3] >= a1[0x1E7] >> 2 )
      __debugbreak();
    if ( _InterlockedDecrement((volatile signed __int32 *)(a1[0x1E3] + 4LL * v3[3])) == 0xFFFFFFFF )
      __debugbreak();
    if ( *((_WORD *)v3 + 4) )
      v5 = (char *)*((_QWORD *)v3 + 0x18);
    else
      v5 = (char *)(v3 + 0x30);
    (*(void (__fastcall **)(char *))v3)(v5);
    if ( *((_WORD *)v3 + 4) )
      sub_147715880(*((const void **)v3 + 0x18));
    if ( (unsigned __int64)v3 < *(_QWORD *)v2 || (unsigned __int64)v3 >= *(_QWORD *)(v2 + 0x28) + *(_QWORD *)v2 )
      __debugbreak();
    memset(v3, 0xCE, 0xF0u);
    return sub_1403E79B0((volatile signed __int64 *)(v2 + 0x50), v3);
  }
  return result;
}

// --- End Function: sub_146C77E70 (0x146C77E70) ---

// --- Function: sub_146C84D10 (0x146C84D9E) ---
__int64 __fastcall sub_146C84D10(__int64 a1)
{
  int n2; // eax
  int *v3; // rdx
  __int64 v6; // r15
  signed __int64 v7; // rdx
  __int64 v8; // rbx
  void (__fastcall *v9)(__int64, void *, __int64); // rdi
  int *v10; // rax
  int v11; // edi
  void (__fastcall *v12)(__int64, void *, _QWORD); // rbx
  __int64 v13; // rbx
  void (__fastcall *v14)(__int64, void *, __int64); // rdi
  volatile signed __int32 *v15; // rbx
  int v16; // edi
  unsigned int v17; // eax
  __int64 v18; // rdi
  void (__fastcall *v19)(__int64, void *, __int64); // rsi
  int v20; // eax
  unsigned __int32 v21; // eax
  __int64 v22; // rbx
  void (__fastcall *v23)(__int64, void *, __int64); // rdi
  int v25; // [rsp+30h] [rbp-D0h] BYREF
  int v26; // [rsp+34h] [rbp-CCh] BYREF
  void *v27; // [rsp+38h] [rbp-C8h] BYREF
  void *v28; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v29; // [rsp+48h] [rbp-B8h] BYREF
  int n0x1400_1; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v31; // [rsp+54h] [rbp-ACh]
  int v32; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v33; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v34; // [rsp+68h] [rbp-98h]
  __int64 v35; // [rsp+70h] [rbp-90h]
  __int64 v36; // [rsp+78h] [rbp-88h]
  int n0x1400; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v38; // [rsp+A4h] [rbp-5Ch]
  int v39; // [rsp+ACh] [rbp-54h]
  unsigned __int64 v40; // [rsp+B0h] [rbp-50h]
  unsigned __int64 v41; // [rsp+B8h] [rbp-48h]
  __int64 v42; // [rsp+C0h] [rbp-40h]
  __int64 v43; // [rsp+C8h] [rbp-38h]
  _QWORD v44[2]; // [rsp+F0h] [rbp-10h] BYREF
  const void *v45; // [rsp+160h] [rbp+60h] BYREF
  void *v46; // [rsp+168h] [rbp+68h] BYREF
  void *v47; // [rsp+170h] [rbp+70h] BYREF
  void *v48; // [rsp+178h] [rbp+78h] BYREF

  n0x1400 = 0x1400;
  v39 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v38 = 1;
  v40 = __rdtsc();
  qword_149C89AA0(
    &n0x1400,
    &word_1516F2250,
    "CEntitySystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\EntitySystem.cpp",
    0x929);
  HIWORD(n0x1400) = word_1516F2250;
  sub_146C8FFF0(a1);
  sub_146C4B3F0(a1);
  n2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1DB8 + 0x10LL))(qword_1516F1DB8);
  if ( n2 )
  {
    if ( n2 == 1 )
    {
      v25 = 0;
      v3 = &v25;
    }
    else
    {
      if ( n2 != 2 )
        goto LABEL_7;
      v26 = 1;
      v3 = &v26;
    }
    sub_146C45630(a1, v3);
  }
LABEL_7:
  if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)qword_1516F1E30 + 0x10LL))(qword_1516F1E30) )
    sub_146C45240(a1);
  sub_146C44F80();
  if ( n0x3E8 > 0 )
    sub_146C46540(a1);
  sub_146C46340(a1);
  if ( BYTE1(qword_149C8E516) )
  {
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v29);
    sub_14059CA60(&v29, v44, &qword_1516F2258);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    if ( *(float *)&_XMM1 > 10.0 )
    {
      n0x1400_1 = 0x1400;
      v31 = 0;
      v32 = 0;
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v33 = __rdtsc();
      qword_149C89AA0(
        &n0x1400_1,
        &word_1516F2260,
        "EntityMetrics",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\EntitySystem.cpp",
        0x949);
      HIWORD(n0x1400_1) = word_1516F2260;
      qword_1516F2258 = v29;
      if ( qword_149C8E050 )
      {
        v6 = (*(__int64 (**)(void))(*(_QWORD *)qword_149C8E050 + 0xA8LL))();
        if ( v6 )
        {
          sub_14035E090(&v45);
          (*(void (__fastcall **)(__int64, const void **))(*(_QWORD *)v6 + 0x20LL))(v6, &v45);
          if ( *(_DWORD *)(a1 + 0x140) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
          {
            ++*(_DWORD *)(a1 + 0x144);
          }
          else
          {
            v7 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x130));
            if ( (v7 & 0x200000) != 0 )
              rw_lock_acquire_read_lock_dispatch(a1 + 0x130, v7, "CEntitySystem::Update", "m_lookupLock", 1);
          }
          v8 = *(_QWORD *)(a1 + 0x150);
          v9 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v6 + 0x18LL);
          sub_14035DE10(&v46, &v45);
          sub_140387CB0((__int64)&v46, (__int64)"entities.total");
          v9(v6, v46, v8);
          sub_140373CC0(&v46);
          rw_lock_release_read_lock(a1 + 0x130);
          v10 = *(int **)(a1 + 0x1080);
          v11 = 0;
          if ( v10 )
            v11 = *v10;
          v12 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v6 + 0x18LL);
          sub_14035DE10(&v47, &v45);
          sub_140387CB0((__int64)&v47, (__int64)"entities.queuedbatches");
          v12(v6, v47, v11);
          sub_140373CC0(&v47);
          v13 = *(_QWORD *)(a1 + 0xD38);
          v14 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v6 + 0x18LL);
          sub_14035DE10(&v48, &v45);
          sub_140387CB0((__int64)&v48, (__int64)"entities.blockedbatches");
          v14(v6, v48, v13);
          sub_140373CC0(&v48);
          v15 = (volatile signed __int32 *)(a1 + 0xE8);
          v16 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
          if ( *(_DWORD *)(a1 + 0xF8) == v16 )
          {
            ++*(_DWORD *)(a1 + 0xFC);
          }
          else
          {
            v17 = _InterlockedCompareExchange(v15, 1, 0);
            if ( v17 )
              sub_1403C6E80(a1 + 0xE8, v17, (__int64)"CEntitySystem::Update", 1);
            else
              *(_QWORD *)(a1 + 0xF0) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
            *(_DWORD *)(a1 + 0xF8) = v16;
          }
          v18 = *(_QWORD *)(a1 + 0x108);
          v19 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v6 + 0x18LL);
          sub_14035DE10(&v27, &v45);
          sub_140387CB0((__int64)&v27, (__int64)"entities.all");
          v19(v6, v27, v18);
          sub_140373CC0(&v27);
          v20 = *(_DWORD *)(a1 + 0xFC);
          if ( v20 )
          {
            *(_DWORD *)(a1 + 0xFC) = v20 - 1;
          }
          else
          {
            *(_DWORD *)(a1 + 0xF8) = 0xFFFFFFFF;
            v21 = _InterlockedCompareExchange(v15, 0, 1);
            if ( v21 == 1 )
              *(_QWORD *)(a1 + 0xF0) = &p_Src;
            else
              sub_1403DF590(a1 + 0xE8, v21);
          }
          v22 = *(_QWORD *)(a1 + 0x118);
          v23 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v6 + 0x18LL);
          sub_14035DE10(&v28, &v45);
          sub_140387CB0((__int64)&v28, (__int64)"entities.deleted");
          v23(v6, v28, v22);
          sub_140373CC0(&v28);
          sub_140373CC0(&v45);
        }
      }
      v34 = __rdtsc();
      qword_149C89AA8(&n0x1400_1);
    }
  }
  sub_146B50410(*(_QWORD **)(a1 + 0x7F0));
  v41 = __rdtsc();
  return qword_149C89AA8(&n0x1400);
}

// --- End Function: sub_146C84D10 (0x146C84D9E) ---

// --- Function: sub_146C8FFF0 (0x146C8FFF0) ---
__int64 __fastcall sub_146C8FFF0(__int64 a1)
{
  volatile signed __int32 *v2; // rdi
  int v3; // ebx
  unsigned int v4; // eax
  __int64 *v5; // r13
  _QWORD *v6; // rcx
  char v7; // r14
  unsigned __int64 *v8; // r12
  __int64 v9; // r8
  __int64 v10; // r10
  __int64 v11; // rax
  __int64 v12; // r8
  char v13; // cl
  char v14; // cl
  char v15; // dl
  char v16; // dl
  __int64 v17; // rdx
  char v18; // cl
  unsigned __int64 v19; // rax
  __int64 v20; // rbx
  unsigned __int64 v21; // rax
  __int64 v22; // rbx
  bool v23; // al
  unsigned __int64 v24; // rbx
  __int64 v25; // rax
  __int16 n4; // dx
  __m256i *v27; // rax
  __m256i v28; // ymm1
  signed __int64 v29; // rbx
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // r8
  __int64 v32; // r13
  unsigned __int64 allocSize; // r13
  char *v34; // rax
  __m256i v35; // ymm1
  void *v36; // r8
  signed __int64 v37; // rbx
  void *v38; // rdx
  size_t Size; // r8
  char *v40; // rcx
  void **v41; // rax
  float v42; // xmm1_4
  float v43; // kr00_4
  float v44; // xmm0_4
  __int64 v45; // rdx
  char v46; // cl
  bool v47; // zf
  int v48; // eax
  unsigned __int32 v49; // eax
  char *v50; // r15
  char *v51; // rsi
  __int64 v52; // rdx
  __int64 v53; // r14
  __int16 v54; // bx
  __int64 v55; // rdi
  __int64 (*v56)(__int64, char *, const char *, ...); // rbx
  const ULONG_PTR *v57; // rax
  char v58; // al
  __int64 v59; // rcx
  int v61; // [rsp+20h] [rbp-E0h]
  __int16 v62; // [rsp+30h] [rbp-D0h] BYREF
  void *Src[2]; // [rsp+38h] [rbp-C8h] BYREF
  char *v64; // [rsp+48h] [rbp-B8h]
  char v65[8]; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v66; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int64 v67; // [rsp+60h] [rbp-A0h] BYREF
  unsigned __int64 v68; // [rsp+68h] [rbp-98h] BYREF
  void *v69; // [rsp+70h] [rbp-90h]
  char *v70; // [rsp+78h] [rbp-88h]
  signed __int64 v71; // [rsp+80h] [rbp-80h]
  _QWORD v72[2]; // [rsp+88h] [rbp-78h] BYREF
  int v73; // [rsp+98h] [rbp-68h]
  int v74; // [rsp+9Ch] [rbp-64h]
  __int16 v75; // [rsp+A0h] [rbp-60h]
  char v76; // [rsp+A2h] [rbp-5Eh]
  char v77; // [rsp+A3h] [rbp-5Dh]
  void *v78; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE v79[2]; // [rsp+B0h] [rbp-50h] BYREF
  __int16 v80; // [rsp+B2h] [rbp-4Eh]
  __int64 v81; // [rsp+B4h] [rbp-4Ch]
  int v82; // [rsp+BCh] [rbp-44h]
  unsigned __int64 v83; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v84; // [rsp+C8h] [rbp-38h]
  __int64 v85; // [rsp+D0h] [rbp-30h]
  __int64 v86; // [rsp+D8h] [rbp-28h]
  int n0xF00; // [rsp+100h] [rbp+0h] BYREF
  __int64 v88; // [rsp+104h] [rbp+4h]
  int v89; // [rsp+10Ch] [rbp+Ch]
  unsigned __int64 v90; // [rsp+110h] [rbp+10h]
  unsigned __int64 v91; // [rsp+118h] [rbp+18h]
  __int64 v92; // [rsp+120h] [rbp+20h]
  __int64 v93; // [rsp+128h] [rbp+28h]
  _BYTE v94[64]; // [rsp+150h] [rbp+50h]
  __m256 v95; // [rsp+190h] [rbp+90h] BYREF
  __int128 v96; // [rsp+1B0h] [rbp+B0h]
  double v97; // [rsp+1C0h] [rbp+C0h]

  n0xF00 = 0xF00;
  v89 = 0;
  v91 = 0;
  v92 = 0;
  v93 = 0;
  v88 = 1;
  v90 = __rdtsc();
  qword_149C89AA0(
    &n0xF00,
    &word_1516F22BC,
    "CEntitySystem::UpdateTimers",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\EntitySystem.cpp",
    0xEF9);
  v2 = (volatile signed __int32 *)(a1 + 0x838);
  *(_OWORD *)Src = 0;
  HIWORD(n0xF00) = word_1516F22BC;
  v64 = 0;
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x848) == v3 )
  {
    ++*(_DWORD *)(a1 + 0x84C);
  }
  else
  {
    v4 = _InterlockedCompareExchange(v2, 1, 0);
    if ( v4 )
      sub_1403C6E80(a1 + 0x838, v4, (__int64)"CEntitySystem::UpdateTimers", 1);
    else
      *(_QWORD *)(a1 + 0x840) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x848) = v3;
  }
  v5 = (__int64 *)(a1 + 0x850);
  if ( *(_QWORD *)(a1 + 0x850) != *(_QWORD *)(a1 + 0x858) )
  {
    if ( *(_BYTE *)(a1 + 0x888) )
    {
      sub_146C21D80(*(_QWORD *)(a1 + 0x850), *(_QWORD *)(a1 + 0x858), v62);
      *(_BYTE *)(a1 + 0x888) = 0;
    }
    v66 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                       qword_149C8DF80,
                       0);
    sub_14036F220((__int64)&v95);
    v6 = (_QWORD *)(*v5 + 8);
    LODWORD(v95.m256_f32[0]) = 2;
    if ( sub_14059CAD0(v6, &v66) )
    {
      v7 = v62;
      v8 = (unsigned __int64 *)(a1 + 0x868);
      do
      {
        v9 = *(_QWORD *)(a1 + 0x858);
        v10 = *v5;
        if ( (__int64)((v9 - *v5) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x40 )
        {
          v11 = *(_QWORD *)(v9 - 0x20);
          v12 = v9 - 0x20;
          v72[0] = v11;
          v13 = v77 & 0xFE;
          LOBYTE(v61) = v7;
          *(_QWORD *)v12 = 0;
          v72[1] = *(_QWORD *)(v12 + 8);
          v73 = *(_DWORD *)(v12 + 0x10);
          v74 = *(_DWORD *)(v12 + 0x14);
          v75 = *(_WORD *)(v12 + 0x18);
          v76 = *(_BYTE *)(v12 + 0x1A);
          v14 = *(_BYTE *)(v12 + 0x1B) & 1 | v13;
          *(_QWORD *)v12 = *(_QWORD *)v10;
          *(_QWORD *)v10 = 0;
          v15 = *(_BYTE *)(v12 + 0x1B);
          *(_QWORD *)(v12 + 8) = *(_QWORD *)(v10 + 8);
          *(_DWORD *)(v12 + 0x10) = *(_DWORD *)(v10 + 0x10);
          *(_DWORD *)(v12 + 0x14) = *(_DWORD *)(v10 + 0x14);
          *(_WORD *)(v12 + 0x18) = *(_WORD *)(v10 + 0x18);
          *(_BYTE *)(v12 + 0x1A) = *(_BYTE *)(v10 + 0x1A);
          v16 = (*(_BYTE *)(v10 + 0x1B) ^ v15) & 1;
          v77 = v14;
          *(_BYTE *)(v12 + 0x1B) ^= v16;
          sub_146C23670(v10, 0, (v12 - v10) >> 5, (__int64)v72, v61);
        }
        v17 = *(_QWORD *)(a1 + 0x858);
        *v8 = *(_QWORD *)(v17 - 0x20);
        *(_QWORD *)(v17 - 0x20) = 0;
        v18 = *(_BYTE *)(a1 + 0x883);
        *(_QWORD *)(a1 + 0x870) = *(_QWORD *)(v17 - 0x18);
        *(_DWORD *)(a1 + 0x878) = *(_DWORD *)(v17 - 0x10);
        *(_DWORD *)(a1 + 0x87C) = *(_DWORD *)(v17 - 0xC);
        *(_WORD *)(a1 + 0x880) = *(_WORD *)(v17 - 8);
        *(_BYTE *)(a1 + 0x882) = *(_BYTE *)(v17 - 6);
        *(_BYTE *)(a1 + 0x883) ^= (*(_BYTE *)(v17 - 5) ^ v18) & 1;
        *(_QWORD *)(a1 + 0x858) -= 0x20LL;
        v19 = *v8;
        if ( *v8 )
        {
          v20 = v19 & 0xFFFFFFFFFFFFLL;
          v21 = HIWORD(v19);
          v22 = (v21 & 0xF000) != 0 ? v20 & 0xFFFFFF000000LL : v20 - 6;
          if ( *(_WORD *)(v22 + 2) == (v21 & 0xFFF) )
          {
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v23 = is_thread_privileged_or_bypass_mode()) )
              v23 = 1;
            if ( *(_WORD *)(v22 + 4) == 2 && v23 || sub_140395410((_QWORD *)(a1 + 0x868)) )
            {
              if ( *(_BYTE *)((*v8 & 0xFFFFFFFFFFFFLL) + 0xD) == 7 )
              {
                v67 = 0;
                v68 = 0;
              }
              else
              {
                sub_146C540A0(*v8 & 0xFFFFFFFFFFFFLL, &v67, *(unsigned __int16 *)(a1 + 0x880));
                v24 = v67;
                v68 = v67;
                if ( v67 )
                {
                  v25 = sub_1403B84E0(v67 & 0xFFFFFFFFFFFFLL);
                  n4 = *(_WORD *)(v25 + 4);
                  if ( n4 != 4
                    && *(_WORD *)(v25 + 2) == (HIWORD(v24) & 0xFFF)
                    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140322850(&v68)) )
                  {
                    *(_QWORD *)&v95.m256_f32[2] = *v8;
                    *(_QWORD *)&v95.m256_f32[6] = *(unsigned __int16 *)(a1 + 0x880);
                    *(_QWORD *)&v96 = *(unsigned __int8 *)(a1 + 0x882);
                    *(_QWORD *)&v97 = *(unsigned int *)(a1 + 0x878);
                    v27 = (__m256i *)Src[1];
                    *(_QWORD *)v94 = v24;
                    v69 = Src[1];
                    *(__m256 *)&v94[8] = v95;
                    *(_OWORD *)&v94[0x28] = v96;
                    *(double *)&v94[0x38] = v97;
                    if ( Src[1] == v64 )
                    {
                      v29 = ((char *)Src[1] - (char *)Src[0]) >> 6;
                      if ( v29 == 0x3FFFFFFFFFFFFFFLL )
                      {
                        __asm { vzeroupper }
                        unknown_libname_10();
                      }
                      v30 = (v64 - (char *)Src[0]) >> 6;
                      v71 = v29 + 1;
                      v31 = v30 >> 1;
                      if ( v30 <= 0x3FFFFFFFFFFFFFFLL - (v30 >> 1) )
                      {
                        v32 = v30 + v31;
                        if ( v30 + v31 < v29 + 1 )
                          v32 = v29 + 1;
                      }
                      else
                      {
                        v32 = 0x3FFFFFFFFFFFFFFLL;
                      }
                      allocSize = v32 << 6;
                      __asm { vzeroupper }
                      v34 = (char *)sub_140394E70((__int64)Src, allocSize);
                      v35 = *(__m256i *)&v94[0x20];
                      v36 = v69;
                      v37 = v29 << 6;
                      v70 = v34;
                      *(__m256i *)&v34[v37] = *(__m256i *)v94;
                      *(__m256i *)&v34[v37 + 0x20] = v35;
                      v38 = Src[0];
                      if ( v36 == Src[1] )
                      {
                        Size = (char *)Src[1] - (char *)Src[0];
                        v40 = v34;
                        __asm { vzeroupper }
                      }
                      else
                      {
                        __asm { vzeroupper }
                        memmove(v34, Src[0], (size_t)v36 - (unsigned __int64)Src[0]);
                        v38 = v69;
                        v40 = &v70[v37 + 0x40];
                        Size = (char *)Src[1] - (char *)v69;
                      }
                      memmove(v40, v38, Size);
                      if ( Src[0] )
                        sub_1403A6820(
                          (__int64)Src,
                          (unsigned __int64)Src[0],
                          (v64 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFC0uLL);
                      Src[0] = v70;
                      Src[1] = &v70[0x40 * v71];
                      v64 = &v70[allocSize];
                      v5 = (__int64 *)(a1 + 0x850);
                    }
                    else
                    {
                      v28 = *(__m256i *)&v94[0x20];
                      *(__m256i *)Src[1] = *(__m256i *)v94;
                      v27[1] = v28;
                      Src[1] = (char *)Src[1] + 0x40;
                    }
                    if ( dword_1516F1E78 )
                    {
                      __asm { vzeroupper }
                      v41 = sub_146C556B0(*v8 & 0xFFFFFFFFFFFFLL, &v78);
                      LogTraceConditional(
                        "OnTimer Event (timerID=%d,time=%dms) for Entity %s",
                        *(unsigned __int8 *)(a1 + 0x882),
                        *(_DWORD *)(a1 + 0x878),
                        (const char *)*v41);
                      sub_140373CC0(&v78);
                    }
                    if ( (*(_BYTE *)(a1 + 0x883) & 1) != 0 )
                    {
                      __asm { vzeroupper }
                      v42 = (float)(unsigned int)sub_1405722D0((__int64)&qword_149A6A5E0);
                      v43 = (float)*(unsigned int *)(a1 + 0x87C);
                      v44 = (float)*(unsigned int *)(a1 + 0x878);
                      *(_QWORD *)(a1 + 0x870) = 0x2710LL
                                              * (unsigned int)(int)(float)((float)((float)(v43 * v42) * 2.3283064e-10)
                                                                         + v44);
                      sub_1402FE5E0((_QWORD *)(a1 + 0x870), &v66);
                      v45 = v5[1];
                      if ( v45 == v5[2] )
                      {
                        sub_146C1FF30(v5, v45, a1 + 0x868);
                      }
                      else
                      {
                        *(_QWORD *)v45 = *v8;
                        v46 = *(_BYTE *)(v45 + 0x1B);
                        *(_QWORD *)(v45 + 8) = *(_QWORD *)(a1 + 0x870);
                        *(_DWORD *)(v45 + 0x10) = *(_DWORD *)(a1 + 0x878);
                        *(_DWORD *)(v45 + 0x14) = *(_DWORD *)(a1 + 0x87C);
                        *(_WORD *)(v45 + 0x18) = *(_WORD *)(a1 + 0x880);
                        *(_BYTE *)(v45 + 0x1A) = *(_BYTE *)(a1 + 0x882);
                        *(_BYTE *)(v45 + 0x1B) ^= (*(_BYTE *)(a1 + 0x883) ^ v46) & 1;
                        v5[1] += 0x20;
                      }
                      if ( !*(_BYTE *)(a1 + 0x888) )
                        sub_146C299A0(*v5, *(_QWORD *)(a1 + 0x858));
                    }
                    else
                    {
                      --*(_BYTE *)((*v8 & 0xFFFFFFFFFFFFLL) + 0x12A);
                    }
                  }
                }
              }
            }
          }
        }
        v47 = *(_BYTE *)(a1 + 0x888) == 0;
        *(_BYTE *)(a1 + 0x882) = 0xFF;
        if ( !v47 )
          break;
        if ( *v5 == v5[1] )
          break;
        __asm { vzeroupper }
      }
      while ( sub_14059CAD0((_QWORD *)(*v5 + 8), &v66) );
    }
  }
  v48 = *(_DWORD *)(a1 + 0x84C);
  if ( v48 )
  {
    *(_DWORD *)(a1 + 0x84C) = v48 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x848) = 0xFFFFFFFF;
    v49 = _InterlockedCompareExchange(v2, 0, 1);
    if ( v49 == 1 )
    {
      *(_QWORD *)(a1 + 0x840) = &p_Src;
    }
    else
    {
      __asm { vzeroupper }
      sub_1403DF590(a1 + 0x838, v49);
    }
  }
  v50 = (char *)Src[1];
  v51 = (char *)Src[0];
  if ( Src[0] != Src[1] )
  {
    do
    {
      v52 = *(unsigned __int16 *)((*(_QWORD *)v51 & 0xFFFFFFFFFFFFLL) + 0x10);
      v53 = v52;
      v54 = word_149C0475C[v52];
      if ( !v54 )
      {
        v55 = qword_149C8E080;
        v56 = *(__int64 (**)(__int64, char *, const char *, ...))(*(_QWORD *)qword_149C8E080 + 0x138LL);
        __asm { vzeroupper }
        v57 = sub_146B3CB00(*(_QWORD *)(qword_1516F1F78 + 0x7E0), v52);
        v54 = *(_WORD *)v56(
                          v55,
                          v65,
                          "CEntity::SendEvent(%s - %s)",
                          off_149C04750,        // "ENTITY_EVENT_TIMER"
                          v57);
        word_149C0475C[v53] = v54;
      }
      __asm { vzeroupper }
      v58 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)v51 & 0xFFFFFFFFFFFFLL) + 0x20LL))(*(_QWORD *)v51 & 0xFFFFFFFFFFFFLL);
      v62 = v54;
      v80 = 0;
      v81 = 0;
      v82 = 0;
      v84 = 0;
      v85 = 0;
      v86 = 0;
      v79[1] = v58;
      v83 = __rdtsc();
      v79[0] = 0;
      qword_149C89AA0(v79, &v62, &p_Src, &p_Src, 0);
      v59 = *(_QWORD *)v51 & 0xFFFFFFFFFFFFLL;
      v80 = v62;
      (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v59 + 0x28LL))(v59, (_QWORD *)v51 + 1);
      v84 = __rdtsc();
      qword_149C89AA8(v79);
      v51 += 0x40;
    }
    while ( v51 != v50 );
    v51 = (char *)Src[0];
  }
  if ( v51 )
  {
    __asm { vzeroupper }
    sub_1403A6820((__int64)Src, (unsigned __int64)v51, (v64 - v51) & 0xFFFFFFFFFFFFFFC0uLL);
    *(_OWORD *)Src = 0;
    v64 = 0;
  }
  v91 = __rdtsc();
  __asm { vzeroupper }
  return qword_149C89AA8(&n0xF00);
}

// --- End Function: sub_146C8FFF0 (0x146C8FFF0) ---

// --- Function: sub_146C92A20 (0x146C92A20) ---
__int64 __fastcall sub_146C92A20(int *a1)
{
  int i; // eax
  _DWORD v4[4]; // [rsp+30h] [rbp-68h] BYREF
  int n0x1000; // [rsp+40h] [rbp-58h] BYREF
  __int64 v6; // [rsp+44h] [rbp-54h]
  int v7; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v8; // [rsp+50h] [rbp-48h]
  unsigned __int64 v9; // [rsp+58h] [rbp-40h]
  __int64 v10; // [rsp+60h] [rbp-38h]
  __int64 v11; // [rsp+68h] [rbp-30h]

  n0x1000 = 0x1000;
  v6 = 0;
  v7 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v8 = __rdtsc();
  qword_149C89AA0(
    &n0x1000,
    &word_1516F21DC,
    "CEntityAggregateManager::WaitForUpdateQueue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\Entity_AggregateManager.cpp",
    0x10CE);
  HIWORD(n0x1000) = word_1516F21DC;
  for ( i = *a1; *a1; i = *a1 )
  {
    v4[0] = i;
    qword_149C78FC8(a1, v4, 4, 0xFFFFFFFFLL);
  }
  v9 = __rdtsc();
  return qword_149C89AA8(&n0x1000);
}

// --- End Function: sub_146C92A20 (0x146C92A20) ---

// --- Function: sub_146D10F40 (0x146D10F40) ---
char __fastcall sub_146D10F40(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14)
{
  void *v18; // rsp
  __int64 v20; // [rsp+18h] [rbp-2B8h]
  _BYTE __Val_0___[592]; // [rsp+30h] [rbp-2A0h] BYREF

  v18 = alloca(0x2A0);
  sub_146D11030((unsigned int)__Val_0___, a9, a10, a11, a12, a13, a14);
  LODWORD(v20) = a6;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 6u, a5, v20, a7, a8);
}

// --- End Function: sub_146D10F40 (0x146D10F40) ---

// --- Function: sub_146D11030 (0x146D11030) ---
__int64 __fastcall sub_146D11030(
        __int64 __Val_0__,
        __int64 a2,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        _QWORD *a7)
{
  const char *p_null; // rdx
  unsigned __int64 v8; // rax
  __int64 n6; // rax

  *(_QWORD *)__Val_0__ = a2;
  *(_WORD *)(__Val_0__ + 0x58) = 0x100;
  *(_QWORD *)(__Val_0__ + 8) = "TraceContext";
  p_null = "null";
  *(_QWORD *)(__Val_0__ + 0x10) = 0;
  *(_QWORD *)(__Val_0__ + 0x18) = sub_1403EF930;
  *(_QWORD *)(__Val_0__ + 0x20) = sub_1403EF4D0;
  *(_QWORD *)(__Val_0__ + 0x30) = sub_1403EBBC0;
  *(_QWORD *)(__Val_0__ + 0x40) = sub_1403E9230;
  *(_QWORD *)(__Val_0__ + 0x48) = sub_1403E8F30;
  *(_QWORD *)(__Val_0__ + 0x78) = "Name";
  *(_QWORD *)(__Val_0__ + 0x28) = 0;
  *(_QWORD *)(__Val_0__ + 0x38) = 0;
  *(_QWORD *)(__Val_0__ + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(__Val_0__ + 0x60) = 0xB0;
  *(_QWORD *)(__Val_0__ + 0x68) = 0xA8;
  *(_QWORD *)(__Val_0__ + 0x70) = a3;
  *(_BYTE *)(__Val_0__ + 0xC9) = 0;
  *(_QWORD *)(__Val_0__ + 0x80) = *a3;
  *(_QWORD *)(__Val_0__ + 0x88) = sub_1403EF810;
  *(_QWORD *)(__Val_0__ + 0x90) = sub_1403EF370;
  *(_QWORD *)(__Val_0__ + 0xA0) = sub_1403EBA20;
  *(_QWORD *)(__Val_0__ + 0xB0) = sub_1403E9250;
  *(_QWORD *)(__Val_0__ + 0xB8) = sub_1403E8F70;
  *(_QWORD *)(__Val_0__ + 0x98) = 0;
  *(_QWORD *)(__Val_0__ + 0xA8) = 0;
  *(_QWORD *)(__Val_0__ + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0xC8) = 0;
  *(_QWORD *)(__Val_0__ + 0xD0) = 0x18;
  if ( a3[1] )
    p_null = (const char *)a3[1];
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v8;
  while ( p_null[v8] );
  *(_QWORD *)(__Val_0__ + 0xD8) = v8;
  *(_QWORD *)(__Val_0__ + 0xE0) = a4;
  *(_QWORD *)(__Val_0__ + 0xE8) = "Count";
  *(_BYTE *)(__Val_0__ + 0x139) = 0;
  *(_QWORD *)(__Val_0__ + 0xF0) = *a4;
  *(_QWORD *)(__Val_0__ + 0x150) = a5;
  *(_QWORD *)(__Val_0__ + 0x128) = sub_1403E8F40;
  *(_QWORD *)(__Val_0__ + 0xF8) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x100) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x108) = 0;
  *(_QWORD *)(__Val_0__ + 0x110) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0x118) = 0;
  *(_QWORD *)(__Val_0__ + 0x120) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x138) = 0;
  *(_QWORD *)(__Val_0__ + 0x140) = 0x10;
  *(_QWORD *)(__Val_0__ + 0x148) = 0x15;
  *(_QWORD *)(__Val_0__ + 0x158) = "Count";
  *(_BYTE *)(__Val_0__ + 0x1A9) = 0;
  *(_QWORD *)(__Val_0__ + 0x160) = *a5;
  *(_QWORD *)(__Val_0__ + 0x1C0) = a6;
  *(_QWORD *)(__Val_0__ + 0x198) = sub_1403E8F40;
  *(_QWORD *)(__Val_0__ + 0x168) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x170) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x178) = 0;
  *(_QWORD *)(__Val_0__ + 0x180) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0x188) = 0;
  *(_QWORD *)(__Val_0__ + 0x190) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x1A8) = 0;
  *(_QWORD *)(__Val_0__ + 0x1B0) = 0x10;
  *(_QWORD *)(__Val_0__ + 0x1B8) = 0x15;
  *(_QWORD *)(__Val_0__ + 0x1C8) = "Count";
  *(_BYTE *)(__Val_0__ + 0x219) = 0;
  *(_QWORD *)(__Val_0__ + 0x1D0) = *a6;
  *(_QWORD *)(__Val_0__ + 0x230) = a7;
  *(_QWORD *)(__Val_0__ + 0x208) = sub_1403E8F40;
  *(_QWORD *)(__Val_0__ + 0x1D8) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x1E0) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x1E8) = 0;
  *(_QWORD *)(__Val_0__ + 0x1F0) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0x1F8) = 0;
  *(_QWORD *)(__Val_0__ + 0x200) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x218) = 0;
  *(_QWORD *)(__Val_0__ + 0x220) = 0x10;
  *(_QWORD *)(__Val_0__ + 0x228) = 0x15;
  *(_QWORD *)(__Val_0__ + 0x238) = "Float";
  *(_BYTE *)(__Val_0__ + 0x289) = 0;
  *(_QWORD *)(__Val_0__ + 0x240) = *a7;
  *(_QWORD *)(__Val_0__ + 0x248) = sub_140509F20;
  *(_QWORD *)(__Val_0__ + 0x250) = sub_1405099F0;
  *(_QWORD *)(__Val_0__ + 0x260) = sub_140506D00;
  *(_QWORD *)(__Val_0__ + 0x270) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x278) = sub_1403E8F40;
  n6 = 6;
  *(_QWORD *)(__Val_0__ + 0x258) = 0;
  *(_QWORD *)(__Val_0__ + 0x268) = 0;
  *(_QWORD *)(__Val_0__ + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x288) = 0;
  *(_QWORD *)(__Val_0__ + 0x290) = 0x10;
  *(_QWORD *)(__Val_0__ + 0x298) = 0x1C;
  return n6;
}

// --- End Function: sub_146D11030 (0x146D11030) ---

// --- Function: sub_146D128D0 (0x146D128D0) ---
__int64 __fastcall sub_146D128D0(__int64 a1, __int64 a2)
{
  unsigned __int64 n0x800; // rbp
  int v5; // ebx
  unsigned int v6; // eax
  __m128i v7; // rt0
  __m128i v8; // xmm6
  __int64 v9; // rsi
  unsigned __int32 v10; // eax
  signed __int64 v11; // rax
  signed __int64 epi64; // r8
  __int64 v13; // rdx
  __m128i v14; // rt0
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rbx
  int v18; // eax
  unsigned __int32 v19; // eax
  __m128i v20; // [rsp+30h] [rbp-98h]

  if ( !a2 )
    return 0;
  n0x800 = (unsigned __int64)(a2 + 0x17) >> 3;
  if ( (unsigned int)n0x800 > 0x800 )
    __debugbreak();
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x20) == v5 )
  {
    ++*(_DWORD *)(a1 + 0x24);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x10), 1, 0);
    if ( v6 )
      sub_1403C6E80(a1 + 0x10, v6, (__int64)"CMemoryBufferQueue::AllocateMemoryBuffer", 1);
    else
      *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x20) = v5;
  }
  v7.m128i_i64[0] = 0;
  v7.m128i_i64[1] = _mm_extract_epi64((__m128i)0LL, 1);
  _InterlockedCompareExchange128((volatile signed __int64 *)a1, 0, 0, v7.m128i_i64);
  v8 = v7;
  while ( 1 )
  {
    v9 = v8.m128i_i64[0];
    if ( v8.m128i_i64[0] )
    {
      v10 = _InterlockedExchangeAdd((volatile signed __int32 *)(v8.m128i_i64[0] + 0x40), n0x800);
      if ( v10 + (unsigned int)n0x800 < 0x800 )
        break;
    }
    v11 = sub_146D137C0(a1);
    if ( !_InterlockedIncrement((volatile signed __int32 *)(v11 + 0x80)) )
      __debugbreak();
    epi64 = _mm_extract_epi64(v8, 1);
    v20.m128i_i64[0] = v11;
    v20.m128i_i64[1] = epi64 + 1;
    v14.m128i_i64[0] = v8.m128i_i64[0];
    v14.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128((volatile signed __int64 *)a1, epi64 + 1, v11, v14.m128i_i64);
    v13 = v14.m128i_i64[1];
    v8 = v14;
    if ( v14.m128i_i64[0] == v9 && v13 == epi64 )
    {
      if ( v9 && _InterlockedExchangeAdd((volatile signed __int32 *)(v9 + 0x80), 0xFFFFFFFF) == 1 )
      {
        v15 = *(_QWORD *)(v9 + 0x48);
        if ( !_InterlockedIncrement((volatile signed __int32 *)(v15 + 0x100)) )
          __debugbreak();
        sub_1403E79B0((volatile signed __int64 *)(v15 + 0x80), (_QWORD *)v9);
      }
      v8 = v20;
    }
    else if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 0x80), 0xFFFFFFFF) == 1 )
    {
      v16 = *(_QWORD *)(v11 + 0x48);
      if ( !_InterlockedIncrement((volatile signed __int32 *)(v16 + 0x100)) )
        __debugbreak();
      sub_1403E79B0((volatile signed __int64 *)(v16 + 0x80), (_QWORD *)v11);
    }
  }
  v17 = v8.m128i_i64[0] + 8LL * v10;
  *(_QWORD *)(v17 + 0x88) = 0;
  *(_QWORD *)(v17 + 0x90) = v8.m128i_i64[0];
  if ( !_InterlockedIncrement((volatile signed __int32 *)(v8.m128i_i64[0] + 0x80)) )
    __debugbreak();
  v18 = *(_DWORD *)(a1 + 0x24);
  if ( v18 )
  {
    *(_DWORD *)(a1 + 0x24) = v18 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x20) = 0xFFFFFFFF;
    v19 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x10), 0, 1);
    if ( v19 == 1 )
      *(_QWORD *)(a1 + 0x18) = &p_Src;
    else
      sub_1403DF590(a1 + 0x10, v19);
  }
  return v17 + 0x88;
}

// --- End Function: sub_146D128D0 (0x146D128D0) ---

// --- Function: sub_146D12B70 (0x146D12B70) ---
__int64 *__fastcall sub_146D12B70(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // edi
  unsigned int v3; // eax
  __int64 *v4; // rsi
  int v5; // eax
  unsigned __int32 v7; // eax
  __int64 v8; // rax
  int v9; // eax
  unsigned __int32 v10; // eax

  v1 = a1 + 0x40;
  v2 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v1 + 0x10) == v2 )
  {
    ++*(_DWORD *)(v1 + 0x14);
  }
  else
  {
    v3 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 1, 0);
    if ( v3 )
      sub_1403C6E80(v1, v3, (__int64)"CNetworkQueue::Dequeue", 1);
    else
      *(_QWORD *)(v1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v1 + 0x10) = v2;
  }
  v4 = *(__int64 **)(v1 + 0x18);
  if ( v4 )
  {
    v8 = *v4;
    *(_QWORD *)(v1 + 0x18) = *v4;
    if ( !v8 )
      *(_QWORD *)(v1 + 0x20) = 0;
    *v4 = 0;
    v9 = *(_DWORD *)(v1 + 0x14);
    if ( v9 )
    {
      *(_DWORD *)(v1 + 0x14) = v9 - 1;
    }
    else
    {
      *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
      v10 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
      if ( v10 == 1 )
        *(_QWORD *)(v1 + 8) = &p_Src;
      else
        sub_1403DF590(v1, v10);
    }
    return v4;
  }
  else
  {
    v5 = *(_DWORD *)(v1 + 0x14);
    if ( v5 )
    {
      *(_DWORD *)(v1 + 0x14) = v5 - 1;
      return 0;
    }
    else
    {
      *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
      if ( v7 == 1 )
        *(_QWORD *)(v1 + 8) = &p_Src;
      else
        sub_1403DF590(v1, v7);
      return 0;
    }
  }
}

// --- End Function: sub_146D12B70 (0x146D12B70) ---

// --- Function: sub_146D12C80 (0x146D12C80) ---
__int64 __fastcall sub_146D12C80(__int64 a1)
{
  return sub_146D12C90(a1 + 0x40);
}

// --- End Function: sub_146D12C80 (0x146D12C80) ---

// --- Function: sub_146D12C90 (0x146D12C90) ---
_BOOL8 __fastcall sub_146D12C90(__int64 a1)
{
  int v2; // edi
  unsigned int v3; // eax
  int v4; // ecx
  bool v5; // di
  _BOOL8 result; // rax
  unsigned __int32 v7; // eax

  v2 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v2 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v3 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v3 )
      sub_1403C6E80(a1, v3, (__int64)"CNetworkQueue::Empty", 1);
    else
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x10) = v2;
  }
  v4 = *(_DWORD *)(a1 + 0x14);
  v5 = *(_QWORD *)(a1 + 0x18) == 0;
  if ( v4 )
  {
    result = v5;
    *(_DWORD *)(a1 + 0x14) = v4 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
    if ( v7 == 1 )
      *(_QWORD *)(a1 + 8) = &p_Src;
    else
      sub_1403DF590(a1, v7);
    return v5;
  }
  return result;
}

// --- End Function: sub_146D12C90 (0x146D12C90) ---

// --- Function: sub_146D12D60 (0x146D12D60) ---
char __fastcall sub_146D12D60(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  int v6; // esi
  unsigned int v7; // eax
  _QWORD *v8; // rax
  int v9; // eax
  unsigned __int32 v10; // eax
  int v11; // eax
  unsigned __int32 v12; // eax

  if ( !a2 )
    return 0;
  v3 = a2[1];
  if ( !v3 || *(_QWORD *)(v3 + 0x48) != a1 )
    return 0;
  v4 = a1 + 0x40;
  if ( *a2 )
    return 0;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v6 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
    if ( v7 )
      sub_1403C6E80(v4, v7, (__int64)"CNetworkQueue::Enqueue", 1);
    else
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v4 + 0x10) = v6;
  }
  v8 = *(_QWORD **)(v4 + 0x20);
  if ( v8 == a2 )
  {
    v9 = *(_DWORD *)(v4 + 0x14);
    if ( v9 )
    {
      *(_DWORD *)(v4 + 0x14) = v9 - 1;
      return 0;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      v10 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
      if ( v10 == 1 )
        *(_QWORD *)(v4 + 8) = &p_Src;
      else
        sub_1403DF590(v4, v10);
      return 0;
    }
  }
  else
  {
    if ( v8 )
    {
      *v8 = a2;
    }
    else
    {
      if ( *(_QWORD *)(v4 + 0x18) )
        __debugbreak();
      *(_QWORD *)(v4 + 0x18) = a2;
    }
    *(_QWORD *)(v4 + 0x20) = a2;
    v11 = *(_DWORD *)(v4 + 0x14);
    if ( v11 )
    {
      *(_DWORD *)(v4 + 0x14) = v11 - 1;
      return 1;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      v12 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
      if ( v12 == 1 )
        *(_QWORD *)(v4 + 8) = &p_Src;
      else
        sub_1403DF590(v4, v12);
      return 1;
    }
  }
}

// --- End Function: sub_146D12D60 (0x146D12D60) ---

// --- Function: sub_146D12F00 (0x146D12F00) ---
char __fastcall sub_146D12F00(__int64 a1)
{
  _QWORD *v2; // rax

  v2 = (_QWORD *)sub_146D128D0(a1, 0x10);
  if ( v2 )
  {
    v2[3] = a1;
    v2[2] = &off_148D7DBC0;
    _InterlockedIncrement((volatile signed __int32 *)(a1 + 0x180));
    v2[2] = &off_148D7DBD0;
    _InterlockedIncrement((volatile signed __int32 *)(v2[3] + 0x1C0LL));
    LOBYTE(v2) = sub_146D12D60(a1, v2);
  }
  return (char)v2;
}

// --- End Function: sub_146D12F00 (0x146D12F00) ---

// --- Function: sub_146D131F0 (0x146D131F0) ---
__int64 __fastcall sub_146D131F0(__int64 a1)
{
  __int64 *v2; // rax
  unsigned __int64 v3; // rbx
  char v4; // si
  __int64 v5; // rcx
  _QWORD *v6; // rdx
  __int64 v7; // rcx
  unsigned int v8; // ebx
  unsigned int v10; // [rsp+30h] [rbp-49h] BYREF
  __int64 v11; // [rsp+38h] [rbp-41h]
  __int64 v12; // [rsp+40h] [rbp-39h]
  __int64 v13; // [rsp+48h] [rbp-31h]
  __int64 v14; // [rsp+50h] [rbp-29h]
  __int64 v15; // [rsp+58h] [rbp-21h]
  __int64 v16; // [rsp+60h] [rbp-19h]
  __int64 v17; // [rsp+68h] [rbp-11h]
  int n0x6400; // [rsp+70h] [rbp-9h] BYREF
  __int64 v19; // [rsp+74h] [rbp-5h]
  int v20; // [rsp+7Ch] [rbp+3h]
  unsigned __int64 v21; // [rsp+80h] [rbp+7h]
  unsigned __int64 v22; // [rsp+88h] [rbp+Fh]
  __int64 v23; // [rsp+90h] [rbp+17h]
  __int64 v24; // [rsp+98h] [rbp+1Fh]
  __int16 v25; // [rsp+E0h] [rbp+67h] BYREF

  v25 = *(_WORD *)(a1 + 0x140);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v20 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v12 = 0;
  n0x6400 = 0x6400;
  v19 = 1;
  v21 = __rdtsc();
  qword_149C89AA0(&n0x6400, &v25, &p_Src, &p_Src, 0);
  HIWORD(n0x6400) = v25;
  v10 = 0;
  v11 = 0;
  do
  {
    v2 = sub_146D12B70(a1);
    v3 = (unsigned __int64)v2;
    if ( !v2 )
      break;
    v4 = (*(__int64 (__fastcall **)(__int64 *, unsigned int *))(v2[2] + 8))(v2 + 2, &v10);
    (**(void (__fastcall ***)(__int64, _QWORD))(v3 + 0x10))(v3 + 0x10, 0);
    if ( *(_QWORD *)v3 )
      __debugbreak();
    if ( !*(_QWORD *)(v3 + 8) )
      __debugbreak();
    v5 = *(_QWORD *)(v3 + 8);
    if ( v5 + 0x88 > v3 || v3 >= v5 + 0x4088 )
      __debugbreak();
    v6 = *(_QWORD **)(v3 + 8);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v5 + 0x80), 0xFFFFFFFF) == 1 )
    {
      v7 = *(_QWORD *)(v5 + 0x48);
      if ( !_InterlockedIncrement((volatile signed __int32 *)(v7 + 0x100)) )
        __debugbreak();
      sub_1403E79B0((volatile signed __int64 *)(v7 + 0x80), v6);
    }
  }
  while ( v4 );
  sub_146D13BE0(a1, &v10);
  v8 = v10;
  v22 = __rdtsc();
  qword_149C89AA8(&n0x6400);
  return v8;
}

// --- End Function: sub_146D131F0 (0x146D131F0) ---

// --- Function: sub_146D131F0 (0x146D132BB) ---
__int64 __fastcall sub_146D131F0(__int64 a1)
{
  __int64 *v2; // rax
  unsigned __int64 v3; // rbx
  char v4; // si
  __int64 v5; // rcx
  _QWORD *v6; // rdx
  __int64 v7; // rcx
  unsigned int v8; // ebx
  unsigned int v10; // [rsp+30h] [rbp-49h] BYREF
  __int64 v11; // [rsp+38h] [rbp-41h]
  __int64 v12; // [rsp+40h] [rbp-39h]
  __int64 v13; // [rsp+48h] [rbp-31h]
  __int64 v14; // [rsp+50h] [rbp-29h]
  __int64 v15; // [rsp+58h] [rbp-21h]
  __int64 v16; // [rsp+60h] [rbp-19h]
  __int64 v17; // [rsp+68h] [rbp-11h]
  int n0x6400; // [rsp+70h] [rbp-9h] BYREF
  __int64 v19; // [rsp+74h] [rbp-5h]
  int v20; // [rsp+7Ch] [rbp+3h]
  unsigned __int64 v21; // [rsp+80h] [rbp+7h]
  unsigned __int64 v22; // [rsp+88h] [rbp+Fh]
  __int64 v23; // [rsp+90h] [rbp+17h]
  __int64 v24; // [rsp+98h] [rbp+1Fh]
  __int16 v25; // [rsp+E0h] [rbp+67h] BYREF

  v25 = *(_WORD *)(a1 + 0x140);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v20 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v12 = 0;
  n0x6400 = 0x6400;
  v19 = 1;
  v21 = __rdtsc();
  qword_149C89AA0(&n0x6400, &v25, &p_Src, &p_Src, 0);
  HIWORD(n0x6400) = v25;
  v10 = 0;
  v11 = 0;
  do
  {
    v2 = sub_146D12B70(a1);
    v3 = (unsigned __int64)v2;
    if ( !v2 )
      break;
    v4 = (*(__int64 (__fastcall **)(__int64 *, unsigned int *))(v2[2] + 8))(v2 + 2, &v10);
    (**(void (__fastcall ***)(__int64, _QWORD))(v3 + 0x10))(v3 + 0x10, 0);
    if ( *(_QWORD *)v3 )
      __debugbreak();
    if ( !*(_QWORD *)(v3 + 8) )
      __debugbreak();
    v5 = *(_QWORD *)(v3 + 8);
    if ( v5 + 0x88 > v3 || v3 >= v5 + 0x4088 )
      __debugbreak();
    v6 = *(_QWORD **)(v3 + 8);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v5 + 0x80), 0xFFFFFFFF) == 1 )
    {
      v7 = *(_QWORD *)(v5 + 0x48);
      if ( !_InterlockedIncrement((volatile signed __int32 *)(v7 + 0x100)) )
        __debugbreak();
      sub_1403E79B0((volatile signed __int64 *)(v7 + 0x80), v6);
    }
  }
  while ( v4 );
  sub_146D13BE0(a1, &v10);
  v8 = v10;
  v22 = __rdtsc();
  qword_149C89AA8(&n0x6400);
  return v8;
}

// --- End Function: sub_146D131F0 (0x146D132BB) ---

// --- Function: sub_146D13990 (0x146D13990) ---
__int64 __fastcall sub_146D13990(volatile __int32 *a1)
{
  __int64 result; // rax
  int v3[4]; // [rsp+30h] [rbp-68h] BYREF
  int n0x1600; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int n2; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  result = NtCurrentTeb_w();
  if ( !*(_QWORD *)result )
  {
    result = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
    if ( ++*(_DWORD *)(result + 0x930) == 1 )
    {
      result = NtCurrentTeb_w();
      if ( *(_BYTE *)(result + 0x12D) )
      {
        _InterlockedExchange(a1, 1);
      }
      else
      {
        n0x1600 = 0x1600;
        v8 = 0;
        v9 = 0;
        v10 = 0;
        v5 = 1;
        n2 = 2;
        v7 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_1516F40E4,
          "NetGlobalLock: Wait MT to lock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Utils/NetGlobalLock.cpp",
          0x74);
        HIWORD(n0x1600) = word_1516F40E4;
        v3[0] = 1;
        qword_149C78FC8(a1, v3, 4, 0xFFFFFFFFLL);
        v8 = __rdtsc();
        return qword_149C89AA8(&n0x1600);
      }
    }
  }
  return result;
}

// --- End Function: sub_146D13990 (0x146D13990) ---

// --- Function: sub_146D13AC0 (0x146D13AC0) ---
__int64 __fastcall sub_146D13AC0(__int64 a1, const char *a2, const char *a3, char a4)
{
  signed __int64 v8; // rdx
  __int64 result; // rax

  sub_146D13990((volatile __int32 *)a1);
  if ( *(_DWORD *)(a1 + 0x18) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x1C);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 8));
    if ( (v8 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 8, v8, a2, a3, a4);
  }
  result = NtCurrentTeb_w();
  if ( *(_BYTE *)(result + 0x12D) && *(_DWORD *)a1 )
  {
    result = NtCurrentTeb_w();
    if ( !*(_QWORD *)result )
    {
      _InterlockedExchange((volatile __int32 *)a1, 0);
      return qword_149C78FD8(a1);
    }
  }
  return result;
}

// --- End Function: sub_146D13AC0 (0x146D13AC0) ---

// --- Function: sub_146D13B70 (0x146D13B70) ---
__int64 __fastcall sub_146D13B70(__int64 a1)
{
  __int64 p_rw_lock_state; // rbx
  __int64 result; // rax
  unsigned __int64 current_lock_value; // rdx

  p_rw_lock_state = a1 + 8;
  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(result + 0x18)
    && (result = *(unsigned int *)(p_rw_lock_state + 0x14), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(p_rw_lock_state + 0x14) = result;
  }
  else
  {
    current_lock_value = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (current_lock_value & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
        return rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, current_lock_value);
    }
  }
  return result;
}

// --- End Function: sub_146D13B70 (0x146D13B70) ---

// --- Function: sub_146D13BE0 (0x146D13BE0) ---
void __fastcall sub_146D13BE0(__int64 a1, unsigned int *a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int64 v4; // r14
  unsigned int v6; // edi
  __int64 v8; // rax
  double v9; // xmm0_8
  float v10; // kr00_4
  float v11; // xmm6_4
  __int64 v12; // rcx
  __int64 v15; // rsi
  unsigned int v16; // ebx
  void (__fastcall *v17)(__int64, _QWORD, _QWORD); // rdi
  __int64 v18; // rax
  void (__fastcall *v19)(__int64, _QWORD, __int64); // rbx
  __int64 v20; // rax
  void (__fastcall *v21)(__int64, void *, _QWORD); // r12
  __int64 n0x1FF_6; // rax
  size_t n0x1FF_1; // rbx
  unsigned __int64 allocSize; // r14
  _BYTE *v25; // rax
  void (__fastcall *v26)(__int64, void *, unsigned __int64); // r12
  __int64 n0x1FF_7; // rax
  size_t n0x1FF_4; // rbx
  unsigned __int64 allocSize_1; // r14
  _BYTE *v30; // rax
  unsigned __int64 v31; // rax
  float v32; // xmm0_4
  int v33; // ebx
  int *ThreadLogContextSlot; // rax
  const void *v35; // [rsp+70h] [rbp-90h] BYREF
  unsigned int v36; // [rsp+78h] [rbp-88h]
  void *Src; // [rsp+80h] [rbp-80h] BYREF
  void *v38; // [rsp+88h] [rbp-78h] BYREF
  int v39; // [rsp+90h] [rbp-70h]
  void *v40; // [rsp+98h] [rbp-68h] BYREF
  void *v41; // [rsp+A0h] [rbp-60h] BYREF
  _DWORD v42[2]; // [rsp+A8h] [rbp-58h] BYREF
  _DWORD v43[2]; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v44; // [rsp+B8h] [rbp-48h] BYREF
  _DWORD *v45; // [rsp+C0h] [rbp-40h] BYREF
  _DWORD *v46; // [rsp+C8h] [rbp-38h]
  __int64 v47; // [rsp+D0h] [rbp-30h]
  _QWORD v48[2]; // [rsp+D8h] [rbp-28h] BYREF
  _QWORD v49[2]; // [rsp+E8h] [rbp-18h] BYREF
  _QWORD v50[2]; // [rsp+F8h] [rbp-8h] BYREF
  _QWORD v51[2]; // [rsp+108h] [rbp+8h] BYREF
  _QWORD v52[2]; // [rsp+118h] [rbp+18h] BYREF
  __int64 v53; // [rsp+128h] [rbp+28h] BYREF
  __int128 v54; // [rsp+130h] [rbp+30h] BYREF
  size_t n0x1FF_2; // [rsp+140h] [rbp+40h]
  __int64 n0x1FF; // [rsp+148h] [rbp+48h]
  void *v57; // [rsp+150h] [rbp+50h]
  _BYTE v58[520]; // [rsp+158h] [rbp+58h] BYREF
  size_t n0x1FF_5; // [rsp+360h] [rbp+260h]
  __int64 n0x1FF_3; // [rsp+368h] [rbp+268h]
  void *v61; // [rsp+370h] [rbp+270h]
  _BYTE v62[520]; // [rsp+378h] [rbp+278h] BYREF
  _BYTE v63[8]; // [rsp+580h] [rbp+480h] BYREF
  __int64 v64; // [rsp+588h] [rbp+488h]
  char *v65; // [rsp+590h] [rbp+490h]
  char v66; // [rsp+598h] [rbp+498h] BYREF
  _BYTE v67[8]; // [rsp+7A0h] [rbp+6A0h] BYREF
  __int64 v68; // [rsp+7A8h] [rbp+6A8h]
  char *v69; // [rsp+7B0h] [rbp+6B0h]
  char v70; // [rsp+7B8h] [rbp+6B8h] BYREF
  __int128 v71; // [rsp+9D0h] [rbp+8D0h]
  __int128 v72; // [rsp+9E0h] [rbp+8E0h]

  v72 = v2;
  v4 = *(unsigned int *)(a1 + 0x180);
  v6 = *(_DWORD *)(a1 + 0x1C0);
  LODWORD(v8) = *a2;
  v39 = *(_DWORD *)(a1 + 0x180);
  v36 = v6;
  if ( (_DWORD)v8 )
  {
    v9 = (*(double (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0xC0LL))(
           qword_149C8DF80,
           *((_QWORD *)a2 + 1));
    v10 = *(float *)&v9 * 1000.0;
    v8 = *a2;
    *(float *)&v9 = (float)v8;
    v11 = v10 / *(float *)&v9;
  }
  else
  {
    v11 = 0.0;
  }
  qword_149C89AF0((unsigned int)v8, &unk_1516F40D4, "Flushed Funcs:");
  qword_149C89AF0((unsigned int)v4, &unk_1516F40D8, "Qd. Funcs:");
  qword_149C89AF0(v6, &unk_1516F40DC, "Qd. Stops:");
  qword_149C89AE8(v12, &unk_1516F40E0, "Ave. Latency(ms):");
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v44);
  sub_14059CA60(&v44, &v53, (_QWORD *)(a1 + 0x150));
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  if ( *(float *)&_XMM1 >= 30.0 )
  {
    *(_QWORD *)(a1 + 0x150) = v44;
    if ( qword_149C8E050 )
    {
      v15 = (*(__int64 (**)(void))(*(_QWORD *)qword_149C8E050 + 0xA8LL))();
      if ( v15 )
      {
        v71 = v3;
        sub_14035E090(&v35);
        (*(void (__fastcall **)(__int64, const void **))(*(_QWORD *)v15 + 0x20LL))(v15, &v35);
        sub_140387CB0((__int64)&v35, (__int64)"net.func_queues.");
        sub_140387C60((__int64)&v35, (_QWORD *)(a1 + 0x148));
        v16 = *a2;
        v17 = *(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v15 + 8LL);
        sub_14035DE10(&v40, &v35);
        sub_140387CB0((__int64)&v40, (__int64)".flushed");
        v18 = sub_14035DCB0((__int64)v63, (const void **)&v40);
        v17(v15, *(_QWORD *)(v18 + 0x10), v16);
        if ( v65 != &v66 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - v64;
          sub_147715880(v65);
        }
        sub_140373CC0(&v40);
        v19 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v15 + 8LL);
        sub_14035DE10(&v41, &v35);
        sub_140387CB0((__int64)&v41, (__int64)".qfuncs");
        v20 = sub_14035DCB0((__int64)v67, (const void **)&v41);
        v19(v15, *(_QWORD *)(v20 + 0x10), v4);
        if ( v69 != &v70 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - v68;
          sub_147715880(v69);
        }
        sub_140373CC0(&v41);
        v21 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v15 + 8LL);
        sub_14035DE10(&Src, &v35);
        sub_140387CB0((__int64)&Src, (__int64)".qstops");
        v58[0] = 0;
        v57 = v58;
        n0x1FF_2 = 0;
        n0x1FF = 0x1FF;
        n0x1FF_6 = sub_1403EBE30(&Src);
        n0x1FF_1 = n0x1FF_6;
        if ( n0x1FF_6 )
        {
          allocSize = n0x1FF_6 + 1;
          v25 = v58;
          if ( allocSize <= 0x200 )
          {
            n0x1FF = 0x1FF;
          }
          else
          {
            v25 = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
            qword_149C78668 += allocSize;
            n0x1FF = n0x1FF_1;
          }
          v57 = v25;
          n0x1FF_2 = n0x1FF_1;
          v25[n0x1FF_1] = 0;
          memcpy(v57, Src, n0x1FF_1);
        }
        v21(v15, v57, v36);
        if ( v57 != v58 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
          sub_147715880(v57);
        }
        sub_140373CC0(&Src);
        v26 = *(void (__fastcall **)(__int64, void *, unsigned __int64))(*(_QWORD *)v15 + 8LL);
        sub_14035DE10(&v38, &v35);
        sub_140387CB0((__int64)&v38, (__int64)".latency");
        v62[0] = 0;
        v61 = v62;
        n0x1FF_5 = 0;
        n0x1FF_3 = 0x1FF;
        n0x1FF_7 = sub_1403EBE30(&v38);
        n0x1FF_4 = n0x1FF_7;
        if ( n0x1FF_7 )
        {
          allocSize_1 = n0x1FF_7 + 1;
          v30 = v62;
          if ( allocSize_1 <= 0x200 )
          {
            n0x1FF_3 = 0x1FF;
          }
          else
          {
            v30 = (_BYTE *)allocWithProfilerInfo(allocSize_1, 0);
            qword_149C78668 += allocSize_1;
            n0x1FF_3 = n0x1FF_4;
          }
          v61 = v30;
          n0x1FF_5 = n0x1FF_4;
          v30[n0x1FF_4] = 0;
          memcpy(v61, v38, n0x1FF_4);
        }
        v31 = 0;
        v32 = v11;
        if ( v11 >= 9.223372e18 )
        {
          v32 = v11 - 9.223372e18;
          if ( (float)(v11 - 9.223372e18) < 9.223372e18 )
            v31 = 0x8000000000000000uLL;
        }
        v26(v15, v61, v31 + (unsigned int)(int)v32);
        if ( v61 != v62 )
        {
          qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_3;
          sub_147715880(v61);
        }
        sub_140373CC0(&v38);
        sub_140373CC0(&v35);
        v6 = v36;
        LODWORD(v4) = v39;
      }
    }
    v42[0] = 0xD6;
    v45 = v42;
    v42[1] = 4;
    v46 = v43;
    v33 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)&v45,
            (__int64)"Functor Queue Stats",
            "Name: $$, flushed: $$, qfuncs: $$, qstops: $$, latency(ms) $$");
    if ( (v33 & 0xFFFFF) != 0 )
    {
      v48[0] = "latency";
      v49[0] = "qstops";
      v50[0] = "qfuncs";
      v50[1] = (unsigned int)v4;
      v51[1] = *a2;
      v46 = *(_DWORD **)(a1 + 0x148);
      *(double *)&v48[1] = v11;
      v49[1] = v6;
      v51[0] = 0;
      v45 = 0;
      v47 = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v43[0] = 0xD6;
      v52[0] = v43;
      v43[1] = 4;
      v52[1] = &v44;
      v54 = 0;
      sub_146D10F40(
        5,
        (__int64)v52,
        "Functor Queue Stats",
        (__int64)"Name: $$, flushed: $$, qfuncs: $$, qstops: $$, latency(ms) $$",
        1,
        v33,
        &v54,
        0,
        (__int64)ThreadLogContextSlot,
        (__int64)&v45,
        (__int64)v51,
        (__int64)v50,
        (__int64)v49,
        (__int64)v48);
      sub_1402A6590(v47);
    }
  }
}

// --- End Function: sub_146D13BE0 (0x146D13BE0) ---

// --- Function: sub_146D147A0 (0x146D147A0) ---
__int64 __fastcall sub_146D147A0(__int64 a1, const char *a2, const char *a3, char a4)
{
  int v8; // esi
  __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 result; // rax

  sub_146D13990((volatile __int32 *)a1);
  v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x18) == v8 )
  {
    ++*(_DWORD *)(a1 + 0x1C);
  }
  else
  {
    v9 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v10 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 8), 0x200000, 0);
    if ( v10 )
      sub_1403E1120(a1 + 8, v10, v9, a2, a3, a4);
    else
      *(_QWORD *)(a1 + 0x10) = v9;
    *(_DWORD *)(a1 + 0x18) = v8;
  }
  result = NtCurrentTeb_w();
  if ( *(_BYTE *)(result + 0x12D) && *(_DWORD *)a1 )
  {
    result = NtCurrentTeb_w();
    if ( !*(_QWORD *)result )
    {
      _InterlockedExchange((volatile __int32 *)a1, 0);
      return qword_149C78FD8(a1);
    }
  }
  return result;
}

// --- End Function: sub_146D147A0 (0x146D147A0) ---

// --- Function: sub_146D14860 (0x146D14860) ---
unsigned __int64 __fastcall sub_146D14860(__int64 a1, const char *a2, char a3)
{
  char v6; // si
  unsigned __int64 result; // rax

  v6 = 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) && !*(_QWORD *)NtCurrentTeb_w() )
  {
    v6 = 1;
    _InterlockedExchange((volatile __int32 *)a1, 1);
  }
  result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 8), 0x200000, 0);
  if ( result )
    result = sub_1403E1120(a1 + 8, result, (__int64)"CrossThreadOwner", a2, (const char *)&p_Src, a3);
  else
    *(_QWORD *)(a1 + 0x10) = "CrossThreadOwner";
  *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFE;
  if ( v6 )
  {
    _InterlockedExchange((volatile __int32 *)a1, 0);
    return qword_149C78FD8(a1);
  }
  return result;
}

// --- End Function: sub_146D14860 (0x146D14860) ---

// --- Function: sub_146D14920 (0x146D14920) ---
__int64 __fastcall sub_146D14920(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rcx
  unsigned __int64 n0x200000; // rax
  __int64 result; // rax

  v1 = *(_DWORD *)(a1 + 0x1C);
  v2 = a1 + 8;
  if ( v1 )
  {
    *(_DWORD *)(v2 + 0x14) = v1 - 1;
  }
  else
  {
    *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
      *(_QWORD *)(v2 + 8) = &p_Src;
    else
      rw_lock_handle_write_release_contention(v2, n0x200000);
  }
  result = NtCurrentTeb_w();
  if ( !*(_QWORD *)result )
  {
    result = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
    --*(_DWORD *)(result + 0x930);
  }
  return result;
}

// --- End Function: sub_146D14920 (0x146D14920) ---

// --- Function: sub_146D14990 (0x146D14990) ---
const ULONG_PTR *__fastcall sub_146D14990(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rcx
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int64 n0x200000; // rax

  v1 = *(_DWORD *)(a1 + 0x1C);
  v2 = a1 + 8;
  if ( v1 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v1 - 1);
    *(_DWORD *)(v2 + 0x14) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(v2 + 8) = &p_Src;
    }
    else
    {
      return rw_lock_handle_write_release_contention(v2, n0x200000);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_146D14990 (0x146D14990) ---

// --- Function: sub_146D22180 (0x146D22180) ---
int __fastcall sub_146D22180(__int64 a1)
{
  int result; // eax
  char buf; // [rsp+40h] [rbp+8h] BYREF

  (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &buf);
  result = sendto(*(_QWORD *)(a1 + 0x50), &buf, 8, 0, (const struct sockaddr *)(a1 + 0x38), 0x10);
  if ( result == 0xFFFFFFFF )
  {
    result = WSAGetLastError();
    if ( (unsigned int)(result - 0x2733) > 1 )
      return (unsigned int)LogFatalError("Wakeup socket sendto error %d", result);
  }
  return result;
}

// --- End Function: sub_146D22180 (0x146D22180) ---

// --- Function: sub_146D24330 (0x146D24330) ---
_QWORD *__fastcall sub_146D24330(__int64 *a1, __int64 a2)
{
  __int64 v4; // rdx
  __int64 v5; // rsi
  __int64 v6; // rdx
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v12; // rax
  __int64 v13; // rbx
  _QWORD *v14; // rsi
  _QWORD *v15; // r8
  __int64 v16; // rdx
  __int64 v17; // rcx

  v4 = (unsigned __int128)((a2 - *a1) * (__int128)0x6666666666666667LL) >> 0x40;
  v5 = ((unsigned __int64)v4 >> 0x3F) + (v4 >> 4);
  v6 = (a1[1] - *a1) / 0x28;
  if ( v6 == 0x666666666666666LL )
    unknown_libname_10();
  v7 = v6 + 1;
  v8 = (a1[2] - *a1) / 0x28;
  v9 = v8 >> 1;
  if ( v8 > 0x666666666666666LL - (v8 >> 1) )
    goto LABEL_18;
  v10 = v7;
  if ( v9 + v8 >= v7 )
    v10 = v9 + v8;
  if ( v10 > 0x666666666666666LL )
    goto LABEL_18;
  allocSize = 0x28 * v10;
  if ( 0x28 * v10 < 0x1000 )
  {
    if ( allocSize )
      v13 = sub_1402A65A0(allocSize);
    else
      v13 = 0;
    goto LABEL_14;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_18:
    sub_1402E3880();
  v12 = sub_1402A65A0(allocSize + 0x27);
  if ( !v12 )
    invalid_parameter_noinfo_noreturn();
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_14:
  v14 = (_QWORD *)(v13 + 0x28 * v5);
  *(__m256i *)v14 = (__m256i)0LL;
  v14[4] = 0;
  __asm { vzeroupper }
  sub_14035E090(v14);
  v14[1] = 0;
  v15 = (_QWORD *)v13;
  v14[2] = 0;
  v14[3] = 0;
  *((_DWORD *)v14 + 8) = 0;
  v16 = a1[1];
  v17 = *a1;
  if ( a2 != v16 )
  {
    sub_146D25E00(v17, a2, v13, a1);
    v16 = a1[1];
    v15 = v14 + 5;
    v17 = a2;
  }
  sub_146D25E00(v17, v16, v15, a1);
  sub_1415FF470(a1, v13, v7, v10);
  return v14;
}

// --- End Function: sub_146D24330 (0x146D24330) ---

// --- Function: ??$_Med3@PEAU?$pair@VEntityId@@_K@std@@VFirstLess@?$VectorMap@VEntityId@@_KU?$less@VEntityId@@@std@@V?$allocator@U?$pair@VEntityId@@_K@std@@@3@@@@std@@YAXPEAU?$pair@VEntityId@@_K@0@00VFirstLess@?$VectorMap@VEntityId@@_KU?$less@VEntityId@@@std@@V?$allocator@U?$pair@VEntityId@@_K@std@@@3@@@@Z (0x146D24CA0) ---
unsigned __int64 __fastcall std::_Med3<std::pair<EntityId,unsigned __int64> *,VectorMap<EntityId,unsigned __int64,std::less<EntityId>,std::allocator<std::pair<EntityId,unsigned __int64>>>::FirstLess>(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rcx
  unsigned __int64 result; // rax
  __int64 v8; // rcx
  unsigned __int64 v9; // rcx

  v3 = *a2;
  v5 = *a1;
  if ( *a2 < v5 && a2 != a1 )
  {
    *a2 = v5;
    *a1 = v3;
    v6 = a2[1];
    a2[1] = a1[1];
    a1[1] = v6;
  }
  result = *a3;
  if ( *a3 < *a2 )
  {
    if ( a3 != a2 )
    {
      *a3 = *a2;
      *a2 = result;
      v8 = a3[1];
      a3[1] = a2[1];
      a2[1] = v8;
    }
    result = *a2;
    if ( *a2 < *a1 && a2 != a1 )
    {
      *a2 = *a1;
      *a1 = result;
      result = a1[1];
      v9 = a2[1];
      a2[1] = result;
      a1[1] = v9;
    }
  }
  return result;
}

// --- End Function: ??$_Med3@PEAU?$pair@VEntityId@@_K@std@@VFirstLess@?$VectorMap@VEntityId@@_KU?$less@VEntityId@@@std@@V?$allocator@U?$pair@VEntityId@@_K@std@@@3@@@@std@@YAXPEAU?$pair@VEntityId@@_K@0@00VFirstLess@?$VectorMap@VEntityId@@_KU?$less@VEntityId@@@std@@V?$allocator@U?$pair@VEntityId@@_K@std@@@3@@@@Z (0x146D24CA0) ---

// --- Function: sub_146D25040 (0x146D25040) ---
unsigned __int64 **__fastcall sub_146D25040(unsigned __int64 **a1, unsigned __int64 *a2, char *a3)
{
  __int64 n0x28; // rbx
  __int64 v7; // rdi
  __int64 v8; // rbx
  unsigned __int64 *v9; // rsi
  unsigned __int64 *v10; // r11
  unsigned __int64 *v11; // rdx
  unsigned __int64 *v12; // r11
  unsigned __int64 *v13; // r11
  unsigned __int64 *v14; // r8
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rax
  unsigned __int64 *v17; // rdx
  unsigned __int64 v18; // rcx
  unsigned __int64 *v19; // rdx
  unsigned __int64 *v20; // r10
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rcx
  bool v23; // zf
  unsigned __int64 *v24; // r9
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rcx
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rcx
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rax
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // rax
  unsigned __int64 v41; // rcx
  unsigned __int64 **result; // rax

  n0x28 = (a3 + 0xFFFFFFF0 - (char *)a2) >> 4;
  if ( n0x28 <= 0x28 )
  {
    std::_Med3<std::pair<EntityId,unsigned __int64> *,VectorMap<EntityId,unsigned __int64,std::less<EntityId>,std::allocator<std::pair<EntityId,unsigned __int64>>>::FirstLess>(
      a2,
      &a2[2 * ((a3 - (char *)a2) >> 5)],
      (unsigned __int64 *)a3 + 0xFFFFFFFE);
  }
  else
  {
    v7 = (n0x28 + 1) >> 3;
    v8 = 0x10 * v7;
    v7 *= 0x20;
    v9 = &a2[(unsigned __int64)v8 / 8];
    std::_Med3<std::pair<EntityId,unsigned __int64> *,VectorMap<EntityId,unsigned __int64,std::less<EntityId>,std::allocator<std::pair<EntityId,unsigned __int64>>>::FirstLess>(
      a2,
      &a2[(unsigned __int64)v8 / 8],
      (unsigned __int64 *)((char *)a2 + v7));
    std::_Med3<std::pair<EntityId,unsigned __int64> *,VectorMap<EntityId,unsigned __int64,std::less<EntityId>,std::allocator<std::pair<EntityId,unsigned __int64>>>::FirstLess>(
      &v10[v8 / 0xFFFFFFFFFFFFFFF8uLL],
      v10,
      &v10[(unsigned __int64)v8 / 8]);
    std::_Med3<std::pair<EntityId,unsigned __int64> *,VectorMap<EntityId,unsigned __int64,std::less<EntityId>,std::allocator<std::pair<EntityId,unsigned __int64>>>::FirstLess>(
      (unsigned __int64 *)&a3[-v7 + 0xFFFFFFF0LL],
      (unsigned __int64 *)&a3[-v8 + 0xFFFFFFF0LL],
      (unsigned __int64 *)a3 + 0xFFFFFFFE);
    std::_Med3<std::pair<EntityId,unsigned __int64> *,VectorMap<EntityId,unsigned __int64,std::less<EntityId>,std::allocator<std::pair<EntityId,unsigned __int64>>>::FirstLess>(
      v9,
      v12,
      v11);
  }
  v14 = v13 + 2;
  if ( a2 < v13 )
  {
    v15 = *v13;
    do
    {
      v16 = v13[0xFFFFFFFE];
      v17 = v13 + 0xFFFFFFFE;
      if ( v16 < v15 )
        break;
      if ( v16 > v15 )
        break;
      v13 += 0xFFFFFFFE;
      v15 = v16;
    }
    while ( a2 < v17 );
  }
  if ( v14 < (unsigned __int64 *)a3 )
  {
    v18 = *v13;
    do
    {
      if ( *v14 < v18 )
        break;
      if ( *v14 > v18 )
        break;
      v14 += 2;
    }
    while ( v14 < (unsigned __int64 *)a3 );
  }
  v19 = v14;
  v20 = v13;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( ; v19 < (unsigned __int64 *)a3; v19 += 2 )
      {
        if ( *v13 >= *v19 )
        {
          if ( *v13 > *v19 )
            break;
          if ( v14 != v19 )
          {
            v21 = *v14;
            *v14 = *v19;
            *v19 = v21;
            v22 = v14[1];
            v14[1] = v19[1];
            v19[1] = v22;
          }
          v14 += 2;
        }
      }
      v23 = v20 == a2;
      if ( v20 > a2 )
      {
        v24 = v20 + 0xFFFFFFFE;
        do
        {
          if ( *v24 >= *v13 )
          {
            if ( *v24 > *v13 )
              break;
            v13 += 0xFFFFFFFE;
            if ( v13 != v24 )
            {
              v25 = *v13;
              *v13 = *v24;
              *v24 = v25;
              v26 = v13[1];
              v13[1] = v24[1];
              v24[1] = v26;
            }
          }
          v20 += 0xFFFFFFFE;
          v24 += 0xFFFFFFFE;
        }
        while ( a2 < v20 );
        v23 = v20 == a2;
      }
      if ( v23 )
        break;
      v20 += 0xFFFFFFFE;
      if ( v19 == (unsigned __int64 *)a3 )
      {
        v13 += 0xFFFFFFFE;
        if ( v20 != v13 )
        {
          v33 = *v20;
          *v20 = *v13;
          v34 = v13[1];
          *v13 = v33;
          v35 = v20[1];
          v20[1] = v34;
          v13[1] = v35;
        }
        v14 += 0xFFFFFFFE;
        if ( v13 != v14 )
        {
          v36 = *v13;
          *v13 = *v14;
          v37 = v14[1];
          *v14 = v36;
          v38 = v13[1];
          v13[1] = v37;
          v14[1] = v38;
        }
      }
      else
      {
        if ( v19 != v20 )
        {
          v39 = *v19;
          *v19 = *v20;
          v40 = v20[1];
          *v20 = v39;
          v41 = v19[1];
          v19[1] = v40;
          v20[1] = v41;
        }
        v19 += 2;
      }
    }
    if ( v19 == (unsigned __int64 *)a3 )
      break;
    if ( v14 != v19 && v13 != v14 )
    {
      v27 = *v13;
      *v13 = *v14;
      v28 = v14[1];
      *v14 = v27;
      v29 = v13[1];
      v13[1] = v28;
      v14[1] = v29;
    }
    v14 += 2;
    if ( v13 != v19 )
    {
      v30 = *v13;
      *v13 = *v19;
      v31 = v19[1];
      *v19 = v30;
      v32 = v13[1];
      v13[1] = v31;
      v19[1] = v32;
    }
    v13 += 2;
    v19 += 2;
  }
  *a1 = v13;
  result = a1;
  a1[1] = v14;
  return result;
}

// --- End Function: sub_146D25040 (0x146D25040) ---

// --- Function: sub_146D25400 (0x146D25400) ---
unsigned __int64 __fastcall sub_146D25400(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 i; // r11
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rcx
  unsigned __int64 v11; // r8
  __int64 v12; // rdx
  __int64 v13; // rdx
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v6 = a2;
  for ( i = a2; i < v5; a2 = i )
  {
    v8 = 2 * a2;
    i = 2 * i + 2LL - (*(_QWORD *)(a1 + 0x10 * (2 * i + 2)) < *(_QWORD *)(a1 + 0x10 * (2 * i + 2) - 0x10));
    *(_QWORD *)(a1 + 8 * v8) = *(_QWORD *)(a1 + 0x10 * i);
    *(_QWORD *)(a1 + 8 * v8 + 8) = *(_QWORD *)(a1 + 0x10 * i + 8);
  }
  if ( i == v5 && (a3 & 1) == 0 )
  {
    v9 = 2 * a2;
    *(_QWORD *)(a1 + 8 * v9) = *(_QWORD *)(a1 + 0x10 * a3 - 0x10);
    *(_QWORD *)(a1 + 8 * v9 + 8) = *(_QWORD *)(a1 + 0x10 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v6 < a2 )
  {
    do
    {
      v10 = (a2 - 1) >> 1;
      v11 = *(_QWORD *)(a1 + 0x10 * v10);
      if ( v11 >= *a4 )
        break;
      v12 = 2 * a2;
      *(_QWORD *)(a1 + 8 * v12) = v11;
      *(_QWORD *)(a1 + 8 * v12 + 8) = *(_QWORD *)(a1 + 0x10 * v10 + 8);
      a2 = v10;
    }
    while ( v6 < v10 );
  }
  v13 = 2 * a2;
  *(_QWORD *)(a1 + 8 * v13) = *a4;
  result = a4[1];
  *(_QWORD *)(a1 + 8 * v13 + 8) = result;
  return result;
}

// --- End Function: sub_146D25400 (0x146D25400) ---

// --- Function: sub_146D257F0 (0x146D257F0) ---
signed __int64 __fastcall sub_146D257F0(unsigned __int64 *a1, char *a2, __int64 a3, unsigned __int8 a4)
{
  signed __int64 n0x200; // rax
  char *v7; // rbp
  unsigned __int64 *v8; // rdi
  __int128 v9; // kr00_16
  unsigned __int64 *i; // r9
  unsigned __int64 n0x200_1; // r10
  signed __int64 *v12; // rdx
  unsigned __int64 v13; // r11
  _QWORD *v14; // r8
  _QWORD *v15; // rdx
  __int64 n2; // rsi
  __int64 v17; // r10
  __int64 v18; // r11
  __m128i *v19; // r14
  __int64 v20; // rax
  __int64 v21; // r9
  __m128i k; // xmm0
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rdx
  unsigned __int64 v26; // r8
  __int64 v27; // rax
  char *v28; // rsi
  __int128 v29; // xmm0
  unsigned __int64 v30; // rax
  signed __int64 *j; // rcx
  _OWORD v32[2]; // [rsp+30h] [rbp-28h] BYREF

  n0x200 = (a2 - (char *)a1) & 0xFFFFFFFFFFFFFFF0uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x200 <= 0x200 )
  {
LABEL_7:
    if ( v8 != (unsigned __int64 *)v7 )
    {
      for ( i = v8 + 2; i != (unsigned __int64 *)v7; i += 2 )
      {
        n0x200_1 = *i;
        v12 = (signed __int64 *)i;
        v13 = i[1];
        if ( *i >= *v8 )
        {
          n0x200 = i[0xFFFFFFFE];
          for ( j = (signed __int64 *)(i + 0xFFFFFFFE); n0x200_1 < n0x200; j += 0xFFFFFFFE )
          {
            *v12 = n0x200;
            v12[1] = j[1];
            v12 = j;
            n0x200 = j[0xFFFFFFFE];
          }
          *v12 = n0x200_1;
          v12[1] = v13;
        }
        else
        {
          if ( i != v8 )
          {
            v14 = i + 1;
            do
            {
              v15 = v14;
              v14 += 0xFFFFFFFE;
              v14[1] = v14[0xFFFFFFFF];
              n0x200 = *v14;
              *v15 = *v14;
            }
            while ( v14 + 0xFFFFFFFF != v8 );
          }
          *v8 = n0x200_1;
          v8[1] = v13;
        }
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_146D25040((unsigned __int64 **)v32, v8, v7);
      v9 = v32[0];
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((*(_QWORD *)&v32[0] - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF0uLL) >= (__int64)((unsigned __int64)&v7[-*((_QWORD *)&v32[0] + 1)]
                                                                                           & 0xFFFFFFFFFFFFFFF0uLL) )
      {
        sub_146D257F0(*((_QWORD *)&v32[0] + 1), v7, a3, a4);
        v7 = (char *)v9;
      }
      else
      {
        sub_146D257F0(v8, *(_QWORD *)&v32[0], a3, a4);
        v8 = (unsigned __int64 *)*((_QWORD *)&v9 + 1);
      }
      n0x200 = (v7 - (char *)v8) & 0xFFFFFFFFFFFFFFF0uLL;
      if ( n0x200 <= 0x200 )
        goto LABEL_7;
    }
    n2 = (v7 - (char *)v8) >> 4;
    v17 = (v7 - (char *)v8) >> 5;
    if ( v17 > 0 )
    {
      v18 = (n2 - 1) >> 1;
      v19 = (__m128i *)&v8[2 * v17];
      do
      {
        --v17;
        v19 += 0xFFFFFFFF;
        v20 = v17;
        v21 = v17;
        for ( k = *v19; v21 < v18; v20 = v21 )
        {
          v23 = 2 * v20;
          v21 = 2 * v21 + 2LL - (v8[4 * v21 + 4] < v8[4 * v21 + 2]);
          v8[v23] = v8[2 * v21];
          v8[v23 + 1] = v8[2 * v21 + 1];
        }
        if ( v21 == v18 && (n2 & 1) == 0 )
        {
          v24 = 2 * v20;
          v8[v24] = v8[2 * n2 - 2];
          v8[v24 + 1] = v8[2 * n2 - 1];
          v20 = n2 - 1;
        }
        if ( v17 < v20 )
        {
          do
          {
            v25 = (v20 - 1) >> 1;
            v26 = v8[2 * v25];
            if ( v26 >= k.m128i_i64[0] )
              break;
            v27 = 2 * v20;
            v8[v27] = v26;
            v8[v27 + 1] = v8[2 * v25 + 1];
            v20 = v25;
          }
          while ( v17 < v25 );
        }
        n0x200 = 2 * v20;
        v8[n0x200] = k.m128i_i64[0];
        v8[n0x200 + 1] = _mm_extract_epi64(k, 1);
      }
      while ( v17 > 0 );
    }
    if ( n2 >= 2 )
    {
      v28 = v7 + 0xFFFFFFF0;
      do
      {
        v29 = *(_OWORD *)v28;
        *(_QWORD *)v28 = *v8;
        v30 = v8[1];
        v32[0] = v29;
        *((_QWORD *)v28 + 1) = v30;
        sub_146D25400((__int64)v8, 0, (v28 - (char *)v8) >> 4, (unsigned __int64 *)v32);
        v28 += 0xFFFFFFF0;
        n0x200 = (unsigned __int64)&v28[0x10LL - (_QWORD)v8] & 0xFFFFFFFFFFFFFFF0uLL;
      }
      while ( n0x200 >= 0x20 );
    }
  }
  return n0x200;
}

// --- End Function: sub_146D257F0 (0x146D257F0) ---

// --- Function: sub_146D25E00 (0x146D25E00) ---
_QWORD *__fastcall sub_146D25E00(_DWORD *a1, _DWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rsi
  _DWORD *v5; // rbx
  char *v6; // rdi

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = a1 + 3;
    v6 = (char *)((char *)a3 - (char *)a1);
    do
    {
      sub_14035DDF0(v3, (__int64 *)(v5 + 0xFFFFFFFD));
      v3 += 5;
      *(_DWORD *)((char *)v5 + (_QWORD)v6 - 4) = v5[0xFFFFFFFF];
      *(_DWORD *)&v6[(_QWORD)v5] = *v5;
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 4) = v5[1];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 8) = v5[2];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 0xC) = v5[3];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 0x10) = v5[4];
      *(_DWORD *)((char *)v5 + (_QWORD)v6 + 0x14) = v5[5];
      v5 += 0xA;
    }
    while ( v5 + 0xFFFFFFFD != a2 );
  }
  return v3;
}

// --- End Function: sub_146D25E00 (0x146D25E00) ---

// --- Function: sub_146D2FDB0 (0x146D2FDB0) ---
__m128 __fastcall sub_146D2FDB0(__int64 p_rw_lock_state)
{
  signed __int64 v2; // rdx
  __int64 v3; // rcx
  __int128 v4; // xmm6
  float v5; // xmm1_4
  float v6; // kr00_4
  __int128 v7; // kr00_16
  int v8; // eax
  unsigned __int64 current_lock_value; // rdx

  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state + 0x14);
  }
  else
  {
    v2 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (v2 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(p_rw_lock_state, v2, "CPingCalculator::GetAverage", "m_lock", 1);
  }
  v3 = *(_QWORD *)(p_rw_lock_state + 0x18);
  if ( v3 )
  {
    if ( v3 < 0 )
    {
      v6 = (float)(*(_QWORD *)(p_rw_lock_state + 0x18) & 1uLL | (*(_QWORD *)(p_rw_lock_state + 0x18) >> 1));
      v5 = v6 + v6;
    }
    else
    {
      v5 = (float)v3;
    }
    v7 = *(unsigned int *)(p_rw_lock_state + 0x68);
    *(float *)&v7 = *(float *)(p_rw_lock_state + 0x68) / v5;
    v4 = v7;
  }
  else
  {
    v4 = 0;
  }
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18)
    && (v8 = *(_DWORD *)(p_rw_lock_state + 0x14)) != 0 )
  {
    *(_DWORD *)(p_rw_lock_state + 0x14) = v8 - 1;
    return (__m128)v4;
  }
  else
  {
    current_lock_value = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
      rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, current_lock_value);
    return (__m128)v4;
  }
}

// --- End Function: sub_146D2FDB0 (0x146D2FDB0) ---

// --- Function: sub_146D30040 (0x146D30040) ---
void __fastcall sub_146D30040(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm6
  float v7; // xmm0_4
  float v8; // xmm6_4
  double v9; // xmm0_8
  float v10[4]; // [rsp+20h] [rbp-28h] BYREF
  __int128 v11; // [rsp+30h] [rbp-18h]

  v11 = v3;
  copyStringStructure((void **)a3, (const void **)(a1 + 0xA0), a3);
  sub_146D30FD0(a1 + 0x290, v10, a2);
  v7 = v10[2];
  v8 = v10[1];
  *(float *)(a3 + 0x14) = v10[0] * 8.0;
  *(float *)(a3 + 0x20) = v7 * 100.0;
  *(float *)(a3 + 0x18) = v8;
  sub_146D30FD0(a1 + 0x12C0, v10, a2);
  *(float *)(a3 + 0x10) = v10[0] * 8.0;
  *(float *)(a3 + 0x1C) = v8;
  v9 = sub_146D306E0(a1 + 0x220);
  *(float *)(a3 + 8) = *(float *)&v9 * 1000.0;
  *(float *)(a3 + 0xC) = sub_146D2FDB0(a1 + 0x220).m128_f32[0] * 1000.0;
}

// --- End Function: sub_146D30040 (0x146D30040) ---

// --- Function: sub_146D306E0 (0x146D306E0) ---
__m128 __fastcall sub_146D306E0(__int64 p_rw_lock_state)
{
  signed __int64 v2; // rdx
  __int128 v3; // xmm6
  int v4; // eax
  unsigned __int64 current_lock_value; // rdx

  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(p_rw_lock_state + 0x14);
  }
  else
  {
    v2 = _InterlockedIncrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (v2 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(p_rw_lock_state, v2, "CPingCalculator::GetLast", "m_lock", 1);
  }
  if ( *(_QWORD *)(p_rw_lock_state + 0x18) )
    v3 = *(unsigned int *)(p_rw_lock_state
                         + 4LL * (((unsigned __int8)*(_QWORD *)(p_rw_lock_state + 0x20) - 1) & 0xF)
                         + 0x28);
  else
    v3 = 0;
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18)
    && (v4 = *(_DWORD *)(p_rw_lock_state + 0x14)) != 0 )
  {
    *(_DWORD *)(p_rw_lock_state + 0x14) = v4 - 1;
    return (__m128)v3;
  }
  else
  {
    current_lock_value = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
      rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, current_lock_value);
    return (__m128)v3;
  }
}

// --- End Function: sub_146D306E0 (0x146D306E0) ---

// --- Function: sub_146D30930 (0x146D30930) ---
__int64 __fastcall sub_146D30930(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rbx
  _QWORD *v5; // rbp
  volatile signed __int64 *v6; // r14
  signed __int64 v7; // rdi
  __int64 v8; // r8
  unsigned __int64 v9; // rdi
  __int64 v10; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v12; // rax
  _QWORD *v13; // rbx
  __int64 *j; // rbx
  _QWORD *v15; // rdi
  __int64 v16; // rbp
  __int64 v17; // rdi
  __int64 **v18; // rax
  __int64 *i; // rax
  __int64 *v20; // rcx
  int v21; // eax
  unsigned __int64 current_lock_value; // rdx
  int n0x6400; // [rsp+30h] [rbp-78h] BYREF
  __int64 v25; // [rsp+34h] [rbp-74h]
  int v26; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v27; // [rsp+40h] [rbp-68h]
  unsigned __int64 v28; // [rsp+48h] [rbp-60h]
  __int64 v29; // [rsp+50h] [rbp-58h]
  __int64 v30; // [rsp+58h] [rbp-50h]
  __int64 v31; // [rsp+B0h] [rbp+8h] BYREF

  n0x6400 = 0x6400;
  v26 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v25 = 1;
  v27 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516F89A4,
    "CNetNub::GetProfilingStatistics",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Gateway/NetNub.cpp",
    0x1A4);
  v4 = *(_QWORD **)(a2 + 0x38);
  v5 = *(_QWORD **)(a2 + 0x40);
  HIWORD(n0x6400) = word_1516F89A4;
  if ( v4 != v5 )
  {
    do
    {
      sub_140373CC0(v4);
      v4 += 5;
    }
    while ( v4 != v5 );
    *(_QWORD *)(a2 + 0x40) = *(_QWORD *)(a2 + 0x38);
  }
  v6 = (volatile signed __int64 *)(a1 + 0x178);
  if ( *(_DWORD *)(a1 + 0x188) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x18C);
  }
  else
  {
    v7 = _InterlockedIncrement64(v6);
    if ( (v7 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(a1 + 0x178, v7, "CNetNub::GetProfilingStatistics", "m_channelsLock", 1);
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v31);
  v8 = *(_QWORD *)(a2 + 0x38);
  v9 = *(_QWORD *)(a1 + 0x170);
  if ( v9 > (*(_QWORD *)(a2 + 0x48) - v8) / 0x28 )
  {
    if ( v9 > 0x666666666666666LL )
      unknown_libname_10();
    v10 = (*(_QWORD *)(a2 + 0x40) - v8) / 0x28;
    allocSize = 0x28 * v9;
    if ( 0x28 * v9 < 0x1000 )
    {
      if ( allocSize )
        v13 = (_QWORD *)sub_1402A65A0(allocSize);
      else
        v13 = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E3880();
      v12 = sub_1402A65A0(allocSize + 0x27);
      if ( !v12 )
        invalid_parameter_noinfo_noreturn();
      v13 = (_QWORD *)((v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      v13[0xFFFFFFFF] = v12;
    }
    sub_146D25E00(*(_DWORD **)(a2 + 0x38), *(_DWORD **)(a2 + 0x40), v13);
    sub_1415FF470((__int64 *)(a2 + 0x38), (__int64)v13, v10, v9);
  }
  j = **(__int64 ***)(a1 + 0x168);
  while ( !*((_BYTE *)j + 0x19) )
  {
    v15 = *(_QWORD **)(a2 + 0x40);
    v16 = j[7];
    if ( v15 == *(_QWORD **)(a2 + 0x48) )
    {
      sub_146D24330((__int64 *)(a2 + 0x38), *(_QWORD *)(a2 + 0x40));
    }
    else
    {
      *(__m256i *)v15 = (__m256i)0LL;
      v15[4] = 0;
      __asm { vzeroupper }
      sub_14035E090(v15);
      v15[1] = 0;
      v15[2] = 0;
      v15[3] = 0;
      *((_DWORD *)v15 + 8) = 0;
      *(_QWORD *)(a2 + 0x40) += 0x28LL;
    }
    v17 = *(_QWORD *)(a2 + 0x40);
    sub_146D30040(v16, v31, v17 - 0x28);
    *(float *)(a2 + 0x28) = *(float *)(v17 - 0x14) + *(float *)(a2 + 0x28);
    *(float *)(a2 + 0x2C) = *(float *)(v17 - 0x18) + *(float *)(a2 + 0x2C);
    v18 = (__int64 **)j[2];
    if ( *((_BYTE *)v18 + 0x19) )
    {
      for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
      {
        if ( j != (__int64 *)i[2] )
          break;
        j = i;
      }
      j = i;
    }
    else
    {
      v20 = *v18;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v20 + 0x19); v20 = (__int64 *)*v20 )
        j = v20;
    }
  }
  *(_DWORD *)(a2 + 0x30) = *(_DWORD *)(a1 + 0x18);
  *(_DWORD *)(a2 + 0x34) = *(_DWORD *)(a1 + 0x20);
  if ( *(_DWORD *)(a1 + 0x188) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) && (v21 = *(_DWORD *)(a1 + 0x18C)) != 0 )
  {
    *(_DWORD *)(a1 + 0x18C) = v21 - 1;
  }
  else
  {
    current_lock_value = _InterlockedDecrement64(v6);
    if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
      rw_lock_handle_release_contention((volatile signed __int64 *)(a1 + 0x178), current_lock_value);
  }
  v28 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146D30930 (0x146D30930) ---

// --- Function: sub_146D30FD0 (0x146D30FD0) ---
float *__fastcall sub_146D30FD0(__int64 a1, float *a2, __int64 a3)
{
  int v5; // edi
  unsigned int v6; // eax
  int v7; // eax
  unsigned __int32 v9; // eax
  __int64 *v10; // rdi
  bool v11; // al
  __int64 *v12; // rcx
  __int64 v13; // rax
  unsigned __int64 n2; // rcx
  _QWORD *v15; // rax
  _QWORD *v16; // rbp
  __int64 v17; // rdi
  int v20; // eax
  __int64 v21; // rdx
  __int64 v22; // rcx
  float v23; // xmm2_4
  float v24; // xmm0_4
  float v25; // kr00_4
  float v26; // xmm1_4
  float v27; // kr00_4
  __int64 v28; // rcx
  __int128 v29; // xmm0
  __int128 v30; // kr00_16
  __int128 v31; // kr00_16
  __int128 v33; // kr00_16
  unsigned __int32 v35; // eax
  __int64 v36; // [rsp+20h] [rbp-48h] BYREF
  __int64 v37; // [rsp+70h] [rbp+8h] BYREF
  __int64 v38; // [rsp+80h] [rbp+18h] BYREF
  __int64 v39; // [rsp+88h] [rbp+20h] BYREF

  v38 = a3;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x18) == v5 )
  {
    ++*(_DWORD *)(a1 + 0x1C);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 8), 1, 0);
    if ( v6 )
      sub_1403C6E80(a1 + 8, v6, (__int64)"CPacketRateCalculator::GetStatistics", 1);
    else
      *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x18) = v5;
  }
  if ( *(_QWORD *)(a1 + 0x20) >= 2u )
  {
    v10 = (__int64 *)(a1 + 0x20LL * (((unsigned __int8)*(_QWORD *)(a1 + 0x28) - 1) & 0x7F) + 0x30);
    v11 = sub_14059CAD0(&v38, v10);
    v12 = &v38;
    if ( v11 )
      v12 = v10;
    v13 = *v12;
    n2 = *(_QWORD *)(a1 + 0x20);
    v38 = v13;
    v37 = (unsigned int)(int)(float)(*(float *)(*(_QWORD *)a1 + 0x48LL) * 10000000.0);
    while ( n2 > 2 )
    {
      v15 = sub_14059CA60(
              &v38,
              &v39,
              (_QWORD *)(a1 + 0x20LL * (((unsigned __int8)*(_QWORD *)(a1 + 0x28) - (_BYTE)n2) & 0x7F) + 0x30));
      if ( !sub_14059CAF0(v15, &v37) )
        break;
      n2 = *(_QWORD *)(a1 + 0x20);
      if ( n2 )
        *(_QWORD *)(a1 + 0x20) = --n2;
    }
    v16 = (_QWORD *)(a1 + 0x20LL * (((unsigned int)*(_QWORD *)(a1 + 0x28) - *(_DWORD *)(a1 + 0x20)) & 0x7F));
    v17 = 0x20LL * (((unsigned __int8)*(_QWORD *)(a1 + 0x28) - 1) & 0x7F);
    sub_14059CA60(&v38, &v36, v16 + 6);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    if ( *(float *)&_XMM1 > 0.00000011920929 )
    {
      v21 = *(_QWORD *)(v17 + a1 + 0x38) - v16[7];
      v22 = *(_QWORD *)(v17 + a1 + 0x40) - v16[8];
      v23 = 1.0 / *(float *)&_XMM1;
      if ( v22 < 0 )
      {
        v25 = (float)(v22 & 1 | ((unsigned __int64)v22 >> 1));
        v24 = v25 + v25;
      }
      else
      {
        v24 = (float)v22;
      }
      *a2 = v24 * v23;
      if ( v21 < 0 )
      {
        v27 = (float)(v21 & 1 | ((unsigned __int64)v21 >> 1));
        v26 = v27 + v27;
      }
      else
      {
        v26 = (float)v21;
      }
      a2[1] = v26 * v23;
      if ( v21 )
      {
        v28 = *(_QWORD *)(v17 + a1 + 0x48) - v16[9];
        if ( v28 < 0 )
        {
          v31 = 0;
          *(float *)&v31 = (float)(v28 & 1 | ((unsigned __int64)v28 >> 1));
          *(float *)&v31 = *(float *)&v31 + *(float *)&v31;
          v29 = v31;
        }
        else
        {
          v30 = 0;
          *(float *)&v30 = (float)v28;
          v29 = v30;
        }
        v33 = v29;
        *(float *)&v33 = *(float *)&v29 / v26;
        _XMM3 = v33;
        LODWORD(_XMM2) = 0;
        if ( (float)(*(float *)&v29 / v26) >= 0.0 )
          __asm { vminss  xmm2, xmm3, xmm4 }
      }
      else
      {
        LODWORD(_XMM2) = 0;
      }
      v20 = *(_DWORD *)(a1 + 0x1C);
      a2[2] = *(float *)&_XMM2;
      if ( v20 )
        goto LABEL_23;
    }
    else
    {
      v20 = *(_DWORD *)(a1 + 0x1C);
      *(_QWORD *)a2 = 0;
      a2[2] = 0.0;
      if ( v20 )
      {
LABEL_23:
        *(_DWORD *)(a1 + 0x1C) = v20 - 1;
        return a2;
      }
    }
    *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFF;
    v35 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 8), 0, 1);
    if ( v35 == 1 )
      *(_QWORD *)(a1 + 0x10) = &p_Src;
    else
      sub_1403DF590(a1 + 8, v35);
    return a2;
  }
  v7 = *(_DWORD *)(a1 + 0x1C);
  *(_QWORD *)a2 = 0;
  a2[2] = 0.0;
  if ( v7 )
  {
    *(_DWORD *)(a1 + 0x1C) = v7 - 1;
    return a2;
  }
  else
  {
    *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFF;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 8), 0, 1);
    if ( v9 == 1 )
      *(_QWORD *)(a1 + 0x10) = &p_Src;
    else
      sub_1403DF590(a1 + 8, v9);
    return a2;
  }
}

// --- End Function: sub_146D30FD0 (0x146D30FD0) ---

// --- Function: sub_146D32DE0 (0x146D32DE0) ---
__int64 __fastcall sub_146D32DE0(__int64 a1)
{
  int n0x6400; // [rsp+30h] [rbp-58h] BYREF
  __int64 v4; // [rsp+34h] [rbp-54h]
  int v5; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v6; // [rsp+40h] [rbp-48h]
  unsigned __int64 v7; // [rsp+48h] [rbp-40h]
  __int64 v8; // [rsp+50h] [rbp-38h]
  __int64 v9; // [rsp+58h] [rbp-30h]

  n0x6400 = 0x6400;
  v4 = 1;
  v5 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v6 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516F89AC,
    "CNetNub::OnStartNetworkFrame",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Gateway/NetNub.cpp",
    0x1FB);
  HIWORD(n0x6400) = word_1516F89AC;
  sub_146D35A30(a1);
  v7 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146D32DE0 (0x146D32DE0) ---

// --- Function: sub_146D35A30 (0x146D35A30) ---
const ULONG_PTR *__fastcall sub_146D35A30(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // edi
  int v4; // esi
  unsigned int v5; // eax
  std::shared_ptr<gte::ETManifoldMesh::Triangle> **_Al; // r12
  _QWORD *v7; // rsi
  _QWORD *i; // r13
  __int64 v9; // rcx
  __int64 *v10; // r15
  __int64 v11; // r14
  void (__fastcall *v12)(__int64, __int64); // rbp
  __int64 v13; // rax
  std::shared_ptr<gte::ETManifoldMesh::Triangle> *_Last; // rdx
  int v15; // eax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int32 v17; // eax
  _BYTE v18[176]; // [rsp+30h] [rbp-1B8h] BYREF
  __int64 v19; // [rsp+E0h] [rbp-108h] BYREF
  _BYTE v20[176]; // [rsp+F0h] [rbp-F8h] BYREF
  __int64 v21; // [rsp+1A0h] [rbp-48h] BYREF

  v1 = a1 + 0x1A8;
  v2 = 0;
  v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v1 + 0x10) == v4 )
  {
    ++*(_DWORD *)(v1 + 0x14);
  }
  else
  {
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 1, 0);
    if ( v5 )
      sub_1403C6E80(v1, v5, (__int64)"CNetNub::ProcessReleasedGameChannels", 1);
    else
      *(_QWORD *)(v1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v1 + 0x10) = v4;
  }
  _Al = (std::shared_ptr<gte::ETManifoldMesh::Triangle> **)(a1 + 0x190);
  v7 = *(_QWORD **)(a1 + 0x190);
  for ( i = *(_QWORD **)(a1 + 0x198); v7 != i; v7 += 2 )
  {
    v9 = *v7;
    v10 = (__int64 *)(*v7 + 0x138LL);
    v11 = *v10;
    if ( *v10 )
    {
      v12 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 0x18LL);
      if ( *(_BYTE *)(v9 + 0x210) )
      {
        v2 |= 1u;
        v13 = sub_1423C48B0((__int64)v20, v9 + 0x150);
      }
      else
      {
        v2 |= 2u;
        v13 = sub_140421510((__int64)v18, 0x7557, "Channel Destroyed");
      }
      v12(v11, v13);
      if ( (v2 & 2) != 0 )
      {
        v2 &= ~2u;
        sub_140373CC0(&v19);
      }
      if ( (v2 & 1) != 0 )
      {
        v2 &= ~1u;
        sub_140373CC0(&v21);
      }
      sub_142389F40(v10);
    }
  }
  _Last = _Al[1];
  if ( *_Al != _Last )
  {
    std::_Destroy_range<std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle>>>(
      *_Al,
      _Last,
      (std::allocator<std::shared_ptr<gte::ETManifoldMesh::Triangle> > *)_Al);
    _Al[1] = *_Al;
  }
  v15 = *(_DWORD *)(v1 + 0x14);
  if ( v15 )
  {
    p_p_Src = (const ULONG_PTR *)(unsigned int)(v15 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_Src;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v17 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v17 == 1 )
    {
      p_p_Src = &p_Src;
      *(_QWORD *)(v1 + 8) = &p_Src;
    }
    else
    {
      return sub_1403DF590(v1, v17);
    }
  }
  return p_p_Src;
}

// --- End Function: sub_146D35A30 (0x146D35A30) ---

// --- Function: sub_146D64190 (0x146D64190) ---
// attributes: thunk
__int64 __fastcall sub_146D64190(__int64 a1)
{
  return sub_146D131F0(a1);
}

// --- End Function: sub_146D64190 (0x146D64190) ---

// --- Function: sub_146D96570 (0x146D96570) ---
bool __fastcall sub_146D96570(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v2 = sub_1403B84E0(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v2 + 4);
  if ( *(_WORD *)(v2 + 2) != (HIWORD(v1) & 0xFFF) || n4 == 4 )
    return 0;
  if ( n4 == 3 )
    return sub_140395230(*(_QWORD *)((v1 & 0xFFFFFFFFFFFFLL) + 8) & 0xFFFFFFFFFFFFLL);
  return 1;
}

// --- End Function: sub_146D96570 (0x146D96570) ---

// --- Function: sub_146D98FD0 (0x146D9913C) ---
char __fastcall sub_146D98FD0(__int64 a1, __int64 a2)
{
  LARGE_INTEGER v4; // rax
  int v5; // ebx
  int *ThreadLogContextSlot; // rax
  __int64 v7; // rcx
  int *p_n0xD6; // [rsp+50h] [rbp-48h] BYREF
  _QWORD *v10; // [rsp+58h] [rbp-40h]
  __int128 v11; // [rsp+60h] [rbp-38h] BYREF
  int n0xD6; // [rsp+70h] [rbp-28h] BYREF
  int n0x67; // [rsp+74h] [rbp-24h]
  int n0x8A; // [rsp+78h] [rbp-20h]
  int n0x8C; // [rsp+7Ch] [rbp-1Ch]
  _QWORD v16[3]; // [rsp+80h] [rbp-18h] BYREF

  ++*(_DWORD *)a2;
  v4 = (LARGE_INTEGER)(*(_QWORD *)&sub_1403E7AE0() - *(_QWORD *)(a1 + 0x40));
  if ( v4.QuadPart > 0 )
    *(_QWORD *)(a2 + 8) += v4.QuadPart;
  sub_1404D8EF0((_OWORD *)(a1 + 0x48));
  if ( sub_146D96570((__int64 *)(a1 + 0x10)) )
  {
    v7 = *(_QWORD *)(a1 + 0x10) & 0xFFFFFFFFFFFFLL;
    v11 = *(_OWORD *)(a1 + 0x18);
    (*(void (__fastcall **)(__int64, __int128 *, __int64))(*(_QWORD *)v7 + 0x5D8LL))(v7, &v11, a1 + 0x28);
  }
  else
  {
    n0xD6 = 0xD6;
    p_n0xD6 = &n0xD6;
    n0x67 = 0x67;
    v10 = v16;
    n0x8A = 0x8A;
    n0x8C = 0x8C;
    v5 = invokeGlobalCallbackAndMaskStatusBits(
           7,
           (__int64)&p_n0xD6,
           (__int64)"Remote Method Missing Entity",
           "Ignoring received remote method call because entity is missing. It has most likely been despawned.");
    if ( (v5 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot = getThreadLogContextSlot();
      p_n0xD6 = &n0xD6;
      v10 = v16;
      n0xD6 = 0xD6;
      v11 = 0;
      n0x67 = 0x67;
      n0x8A = 0x8A;
      n0x8C = 0x8C;
      sub_140354250(
        7,
        (__int64)&p_n0xD6,
        "Remote Method Missing Entity",
        (__int64)"Ignoring received remote method call because entity is missing. It has most likely been despawned.",
        1,
        v5,
        &v11,
        0,
        (__int64)ThreadLogContextSlot);
    }
  }
  sub_1404D5120();
  return 1;
}

// --- End Function: sub_146D98FD0 (0x146D9913C) ---

// --- Function: sub_146D99420 (0x146D99420) ---
__int64 __fastcall sub_146D99420(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1 + 0x100;
  sub_146D12F00(a1 + 0x100);
  return sub_146D131F0(v1);
}

// --- End Function: sub_146D99420 (0x146D99420) ---

// --- Function: sub_146D99650 (0x146D99650) ---
char __fastcall sub_146D99650(LARGE_INTEGER a1)
{
  __int64 v1; // rdi
  int v3; // ebx
  __int64 v4; // r8
  unsigned __int64 v5; // rax
  LARGE_INTEGER *p_p_Src; // rax
  __int64 *v7; // rbx
  __int64 *i; // rbp
  LARGE_INTEGER *p_p_Src_1; // rbx
  int *ThreadLogContextSlot; // rax
  int v11; // eax
  unsigned __int64 n0x200000; // rax

  v1 = a1.QuadPart + 0x520;
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v1 + 0x10) == v3 )
  {
    ++*(_DWORD *)(v1 + 0x14);
  }
  else
  {
    v4 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)v1, 0x200000, 0);
    if ( v5 )
      sub_1403E1120(v1, v5, v4, "CGameContextProxy::InterleaveAsyncParallelQueue", "m_interleaveRWLock", 1);
    else
      *(_QWORD *)(v1 + 8) = v4;
    *(_DWORD *)(v1 + 0x10) = v3;
  }
  LOBYTE(p_p_Src) = *(_BYTE *)(a1.QuadPart + 0x518);
  *(_BYTE *)(a1.QuadPart + 0x518) = 0;
  if ( (_BYTE)p_p_Src )
  {
    v7 = *(__int64 **)(a1.QuadPart + 0x500);
    for ( i = *(__int64 **)(a1.QuadPart + 0x508); v7 != i; ++v7 )
      sub_146D12F00(*v7);
    ((void (__fastcall *)(_QWORD))sub_146D99650)((LARGE_INTEGER)a1.QuadPart);
    p_p_Src = (LARGE_INTEGER *)sub_146D128D0(a1.QuadPart + 0x300, 0xD0);
    p_p_Src_1 = p_p_Src;
    if ( p_p_Src )
    {
      p_p_Src[3].QuadPart = a1.QuadPart + 0x300;
      p_p_Src[2].QuadPart = (LONGLONG)&off_148D7DBC0;
      _InterlockedIncrement((volatile signed __int32 *)(a1.QuadPart + 0x480));
      p_p_Src[4] = a1;
      p_p_Src[2].QuadPart = (LONGLONG)off_148D8E8B8;
      p_p_Src[5] = sub_1403E7AE0();
      ThreadLogContextSlot = getThreadLogContextSlot();
      *(_OWORD *)&p_p_Src_1[6].LowPart = *(_OWORD *)ThreadLogContextSlot;
      *(_OWORD *)&p_p_Src_1[8].LowPart = *((_OWORD *)ThreadLogContextSlot + 1);
      *(_OWORD *)&p_p_Src_1[0xA].LowPart = *((_OWORD *)ThreadLogContextSlot + 2);
      *(_OWORD *)&p_p_Src_1[0xC].LowPart = *((_OWORD *)ThreadLogContextSlot + 3);
      *(_OWORD *)&p_p_Src_1[0xE].LowPart = *((_OWORD *)ThreadLogContextSlot + 4);
      *(_OWORD *)&p_p_Src_1[0x10].LowPart = *((_OWORD *)ThreadLogContextSlot + 5);
      *(_OWORD *)&p_p_Src_1[0x12].LowPart = *((_OWORD *)ThreadLogContextSlot + 6);
      *(_OWORD *)&p_p_Src_1[0x14].LowPart = *((_OWORD *)ThreadLogContextSlot + 7);
      *(_OWORD *)&p_p_Src_1[0x16].LowPart = *((_OWORD *)ThreadLogContextSlot + 8);
      *(_OWORD *)&p_p_Src_1[0x18].LowPart = *((_OWORD *)ThreadLogContextSlot + 9);
      *(_OWORD *)&p_p_Src_1[0x1A].LowPart = *((_OWORD *)ThreadLogContextSlot + 0xA);
      LOBYTE(p_p_Src) = sub_146D12D60(a1.QuadPart + 0x300, p_p_Src_1);
    }
  }
  if ( v1 )
  {
    v11 = *(_DWORD *)(v1 + 0x14);
    if ( v11 )
    {
      LODWORD(p_p_Src) = v11 - 1;
      *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_Src;
    }
    else
    {
      *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v1, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_Src = (LARGE_INTEGER *)&p_Src;
        *(_QWORD *)(v1 + 8) = &p_Src;
      }
      else
      {
        LOBYTE(p_p_Src) = (unsigned __int8)rw_lock_handle_write_release_contention(v1, n0x200000);
      }
    }
  }
  return (char)p_p_Src;
}

// --- End Function: sub_146D99650 (0x146D99650) ---

// --- Function: sub_146D9AE20 (0x146D9AE20) ---
char __fastcall sub_146D9AE20(LARGE_INTEGER a1)
{
  sub_146D99650(a1);
  return sub_146D12F00(a1.QuadPart + 0x300);
}

// --- End Function: sub_146D9AE20 (0x146D9AE20) ---

// --- Function: sub_146DA5880 (0x146DA5880) ---
__int64 __fastcall sub_146DA5880(__int64 a1, _QWORD *a2, int a3, __int64 a4)
{
  int v6; // edi
  __int64 result; // rax
  unsigned __int64 v8; // rcx
  __int64 n0x400_3; // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  unsigned int v12; // eax
  int v13; // r14d
  int *ThreadLogContextSlot; // rax
  int n0x400; // edi
  bool v16; // cc
  int n0x400_1; // eax
  int n0x400_2; // kr00_4
  int v19; // edi
  unsigned __int64 v20; // rdx
  __int64 v21; // rcx
  int v22; // [rsp+58h] [rbp-61h]
  __int64 v23; // [rsp+60h] [rbp-59h]
  _QWORD v24[2]; // [rsp+68h] [rbp-51h] BYREF
  _QWORD v25[2]; // [rsp+78h] [rbp-41h] BYREF
  _QWORD v26[2]; // [rsp+88h] [rbp-31h] BYREF
  __int128 v27; // [rsp+98h] [rbp-21h] BYREF
  _DWORD v28[5]; // [rsp+A8h] [rbp-11h] BYREF
  char v29; // [rsp+BCh] [rbp+3h] BYREF
  _DWORD v30[5]; // [rsp+C0h] [rbp+7h] BYREF
  char v31; // [rsp+D4h] [rbp+1Bh] BYREF

  v23 = a4;
  v22 = a3;
  v6 = 0;
  if ( *a2 )
  {
LABEL_5:
    result = v6;
    _BitScanForward64(&v8, a2[v6]);
    for ( n0x400_3 = (unsigned int)(v8 + (v6 << 6));
          (unsigned int)n0x400_3 < 0x400;
          n0x400_3 = (unsigned int)(result + (v19 << 6)) )
    {
      result = 3 * n0x400_3;
      v10 = 0x18 * n0x400_3 + 0xDE0;
      v11 = *(_QWORD *)(v10 + a1 + 8);
      if ( v11 )
      {
        if ( (a3 & *(_DWORD *)(v10 + a1)) != 0 )
          result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 0xA0LL))(v11, a4);
      }
      else
      {
        v12 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x7E98), 1, 0);
        if ( v12 )
          sub_1403C6E80(a1 + 0x7E98, v12, (__int64)"CReplicationModel::ApplyToViews", 1);
        else
          *(_QWORD *)(a1 + 0x7EA0) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
        if ( ((*(_QWORD *)(a1 + 8LL * ((int)n0x400_3 >> 6) + 0x7EA8) >> (n0x400_3 & 0x3F)) & 1) == 0 )
        {
          v28[0] = 0xD6;
          v24[0] = v28;
          v28[1] = 0x67;
          v24[1] = &v29;
          v28[2] = 0x8A;
          v28[3] = 0x23;
          v28[4] = 0xA1;
          v13 = invokeGlobalCallbackAndMaskStatusBits(
                  2,
                  (__int64)v24,
                  (__int64)"Missing Subscription",
                  "Missing subscription listener for connection index $$");
          if ( (v13 & 0xFFFFF) != 0 )
          {
            v25[1] = (unsigned int)n0x400_3;
            v25[0] = 0;
            ThreadLogContextSlot = getThreadLogContextSlot();
            v30[0] = 0xD6;
            v26[0] = v30;
            v30[1] = 0x67;
            v26[1] = &v31;
            v30[2] = 0x8A;
            v30[3] = 0x23;
            v27 = 0;
            v30[4] = 0xA1;
            sub_140C686F0(
              2,
              (unsigned int)v26,
              (unsigned int)"Missing Subscription",
              (unsigned int)"Missing subscription listener for connection index $$",
              1,
              v13,
              (__int64)&v27,
              0,
              (__int64)ThreadLogContextSlot,
              (__int64)v25);
          }
        }
        result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x7E98), 0, 1);
        if ( (_DWORD)result == 1 )
          *(_QWORD *)(a1 + 0x7EA0) = &p_Src;
        else
          result = (__int64)sub_1403DF590(a1 + 0x7E98, (unsigned int)result);
      }
      n0x400 = n0x400_3 + 1;
      v16 = n0x400 < 0x400;
      if ( (unsigned int)n0x400 > 0x400 )
      {
        result = (__int64)LogFatalError(
                            "[%s] Attempting to read past the end of the bit array. Max-size = %d Position requested = %d",
                            "CCigBitSet<1024>::FindFirstSet",
                            0x400,
                            n0x400);
        v16 = n0x400 < 0x400;
      }
      if ( !v16 )
        break;
      n0x400_1 = 0;
      if ( n0x400 >= 0 )
        n0x400_1 = n0x400;
      n0x400_2 = n0x400_1;
      result = (unsigned int)(n0x400_1 % 0x40);
      v19 = n0x400_2 / 0x40;
      v20 = 0xFFFFFFFFFFFFFFFFuLL << result;
      v21 = n0x400_2 / 0x40;
      if ( ((0xFFFFFFFFFFFFFFFFuLL << result) & a2[v21]) == 0 )
      {
        v20 = 0xFFFFFFFFFFFFFFFFuLL;
        do
        {
          ++v19;
          if ( ++v21 >= 0x10 )
            return result;
        }
        while ( !a2[v21] );
      }
      a3 = v22;
      a4 = v23;
      _BitScanForward64((unsigned __int64 *)&result, v20 & a2[v19]);
    }
  }
  else
  {
    result = 0;
    while ( 1 )
    {
      ++v6;
      if ( ++result >= 0x10 )
        break;
      if ( a2[result] )
        goto LABEL_5;
    }
  }
  return result;
}

// --- End Function: sub_146DA5880 (0x146DA5880) ---

// --- Function: sub_146DECEA0 (0x146DECEA0) ---
__int64 __fastcall sub_146DECEA0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rbx

  v1 = *(_QWORD *)(a1 + 0x10);
  sub_146CB1560(*(_QWORD *)v1 + 0x910LL, *(_QWORD *)v1 + 0x960LL);
  v2 = *(_QWORD *)(*(_QWORD *)v1 + 0x980LL) >> 3;
  qword_149C89AF0((unsigned int)v2, &unk_1516FA7E4, "Dirty entities: ");
  sub_1403D37D0((__int64)&qword_1516FA790, 0xC3500);
  return (unsigned int)v2;
}

// --- End Function: sub_146DECEA0 (0x146DECEA0) ---

// --- Function: sub_146DED4B0 (0x146DED4B0) ---
__int64 __fastcall sub_146DED4B0(__int64 a1)
{
  return sub_146DE4290(*(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_146DED4B0 (0x146DED4B0) ---

// --- Function: sub_146DED500 (0x146DED500) ---
__int64 sub_146DED500()
{
  unsigned __int64 v0; // rbx

  v0 = (unsigned __int64)qword_1516FA7B0 >> 3;
  qword_149C89AF0((unsigned int)((unsigned __int64)qword_1516FA7B0 >> 3), &unk_1516FA7E8, "Callbacks: ");
  return (unsigned int)v0;
}

// --- End Function: sub_146DED500 (0x146DED500) ---

// --- Function: sub_146DED530 (0x146DED530) ---
__int64 __fastcall sub_146DED530(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(qword_1516FA790 + 8 * a2) & 0xFFFFFFFFFFFFLL)
                                            + 0x5E8LL))(*(_QWORD *)(qword_1516FA790 + 8 * a2) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_146DED530 (0x146DED530) ---

// --- Function: sub_146DEE860 (0x146DEE860) ---
void __fastcall sub_146DEE860(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64); // rdi
  __int64 (__fastcall *v6)(__int64); // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        v6 = (__int64 (__fastcall *)(__int64))sub_1402A65A0(8u);
        if ( v6 )
          *(_QWORD *)v6 = *(_QWORD *)v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_146DECEA0;
        a2[1] = (__int64 (__fastcall *)(__int64))sub_146DEE860;
      }
    }
  }
}

// --- End Function: sub_146DEE860 (0x146DEE860) ---

// --- Function: sub_146DEFA60 (0x146DEFA60) ---
void __fastcall sub_146DEFA60(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64); // rdi
  __int64 (__fastcall *v6)(__int64); // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
      }
      else
      {
        v6 = (__int64 (__fastcall *)(__int64))sub_1402A65A0(8u);
        if ( v6 )
          *(_QWORD *)v6 = *(_QWORD *)v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_146DED4B0;
        a2[1] = (__int64 (__fastcall *)(__int64))sub_146DEFA60;
      }
    }
  }
}

// --- End Function: sub_146DEFA60 (0x146DEFA60) ---

// --- Function: sub_146DEFD50 (0x146DEFD50) ---
void __fastcall sub_146DEFD50(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx
  _QWORD *v5; // rdi
  _QWORD *v6; // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = (_QWORD *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        v6 = (_QWORD *)sub_1402A65A0(8u);
        if ( v6 )
          *v6 = *v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_146DED4E0;
        a2[1] = sub_146DEFD50;
      }
    }
  }
}

// --- End Function: sub_146DEFD50 (0x146DEFD50) ---

// --- Function: sub_146DEFE70 (0x146DEFE70) ---
void __fastcall sub_146DEFE70(int a1, _QWORD *a2, _QWORD *a3)
{
  int v4; // ecx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = 1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      a2[1] = 1;
    }
    else
    {
      a2[2] = sub_1402A65A0(1u);
      *a2 = sub_146DED500;
      a2[1] = sub_146DEFE70;
    }
  }
}

// --- End Function: sub_146DEFE70 (0x146DEFE70) ---

// --- Function: sub_146DEFF60 (0x146DEFF60) ---
void __fastcall sub_146DEFF60(
        int a1,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else if ( *a3 )
  {
    if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
    }
    else
    {
      a2[2] = (__int64 (__fastcall *)(__int64, __int64))sub_1402A65A0(1u);
      *a2 = sub_146DED530;
      a2[1] = (__int64 (__fastcall *)(__int64, __int64))sub_146DEFF60;
    }
  }
}

// --- End Function: sub_146DEFF60 (0x146DEFF60) ---

// --- Function: sub_146E078B0 (0x146E078B0) ---
__int64 __fastcall sub_146E078B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v5; // r8

  v2 = qword_1516FAFC8;
  v3 = *(_QWORD *)(a1 + 8);
  sub_146D13AC0(qword_1516FAFC8 + 0x2F0, "CReplicationModel::GetContextStatistics", (const char *)&p_Src, 1);
  *(_QWORD *)a2 = *(_QWORD *)(v3 + 0x7F68);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 0x7FE0);
  *(_QWORD *)(a2 + 0x10) = *(_QWORD *)(v3 + 0x8038);
  *(_DWORD *)(a2 + 0x18) = *(_DWORD *)(v3 + 0x8040);
  *(_DWORD *)(a2 + 0x1C) = *(_DWORD *)(v3 + 0x8044);
  copyStringStructure((void **)(a2 + 0x20), (const void **)(v3 + 0x8048), v5);
  return sub_146D13B70(v2 + 0x2F0);
}

// --- End Function: sub_146E078B0 (0x146E078B0) ---

// --- Function: sub_146E10F90 (0x146E10F90) ---
__int64 __fastcall sub_146E10F90(__int64 a1)
{
  return sub_146E10FA0(*(_QWORD *)(a1 + 8));
}

// --- End Function: sub_146E10F90 (0x146E10F90) ---

// --- Function: sub_146E10FA0 (0x146E10FA0) ---
__int64 __fastcall sub_146E10FA0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v6; // rcx
  __m128 v7; // xmm0
  __int64 v8; // rcx
  unsigned int v9; // eax
  __int128 v11; // kr00_16
  _QWORD v14[2]; // [rsp+30h] [rbp-49h] BYREF
  _QWORD v15[2]; // [rsp+40h] [rbp-39h] BYREF
  int n0x6400; // [rsp+50h] [rbp-29h] BYREF
  __int64 v17; // [rsp+54h] [rbp-25h]
  int v18; // [rsp+5Ch] [rbp-1Dh]
  unsigned __int64 v19; // [rsp+60h] [rbp-19h]
  unsigned __int64 v20; // [rsp+68h] [rbp-11h]
  __int64 v21; // [rsp+70h] [rbp-9h]
  __int64 v22; // [rsp+78h] [rbp-1h]
  __int64 v23; // [rsp+A0h] [rbp+27h] BYREF
  __int128 v24; // [rsp+B0h] [rbp+37h] BYREF
  __int64 v25; // [rsp+E0h] [rbp+67h] BYREF

  n0x6400 = 0x6400;
  v18 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v17 = 1;
  v19 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516FA6D0,
    "CReplicationModel::OnEndNetworkFrame",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Replication/ReplicationModel.cpp",
    0x14F);
  HIWORD(n0x6400) = word_1516FA6D0;
  sub_146D131F0(a1 + 0x240);
  if ( *(_QWORD *)(a1 + 0xBA0) )
  {
    v14[0] = sub_146E1AE70(a1);
    sub_1402A8EB0(a2, v14);
    sub_1402A8EB0(a3, v14);
    if ( *(_QWORD *)(a1 + 0xBA0) )
    {
      v6 = *(_QWORD *)(a1 + 0x8070);
      if ( v6 )
      {
        sub_146D131F0(v6 + 0x100);
        if ( qword_149C8DFC0 )
          sub_146E1B720(*(_QWORD *)(a1 + 0x8070));
      }
    }
  }
  if ( !BYTE6(qword_149C8E516) && !byte_149C8E515 )
  {
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v25);
    sub_14059CA60(&v25, &v23, (_QWORD *)(a1 + 0x8050));
    v7 = sub_14059CC00();
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(_DWORD *)(a1 + 0x8058) + 1;
    *((_QWORD *)&v11 + 1) = v7.m128_u64[1];
    *(double *)&v11 = *(double *)v7.m128_u64 * 1000.0;
    _XMM0 = v11;
    *(_DWORD *)(a1 + 0x8058) = v9;
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    if ( v9 >= *(_DWORD *)(v8 + 0x70) && *(float *)&_XMM1 >= (float)*(int *)(v8 + 0x48) )
    {
      (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8DF80 + 0x70LL))(qword_149C8DF80, v15);
      v15[1] = 0;
      v24 = v15[0];
      sub_146DA5880(a1, (_QWORD *)(a1 + 0xBE0), 1, (__int64)&v24);
      *(_QWORD *)(a1 + 0x8050) = v25;
      *(_DWORD *)(a1 + 0x8058) = 0;
    }
  }
  if ( !*(_BYTE *)(a1 + 0x11) )
  {
    sub_146D12F00(a1 + 0x440);
    *(_BYTE *)(a1 + 0x11) = 1;
  }
  v20 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146E10FA0 (0x146E10FA0) ---

// --- Function: sub_146E145A0 (0x146E145A0) ---
__int64 __fastcall sub_146E145A0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rcx

  result = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(result + 0xBA0);
  if ( v2 )
    return sub_146D131F0(v2 + 0x300);
  return result;
}

// --- End Function: sub_146E145A0 (0x146E145A0) ---

// --- Function: sub_146E145C0 (0x146E145C0) ---
__int64 __fastcall sub_146E145C0(__int64 a1)
{
  return sub_146E145D0(*(_QWORD *)(a1 + 8));
}

// --- End Function: sub_146E145C0 (0x146E145C0) ---

// --- Function: sub_146E145D0 (0x146E145D0) ---
__int64 __fastcall sub_146E145D0(_QWORD *a1)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // rsi
  int v6; // ebp
  unsigned int v7; // eax
  __m128 v8; // xmm0
  __int128 v10; // kr00_16
  int v12; // eax
  unsigned __int32 v13; // eax
  __int64 v14; // rdi
  __int64 v15; // rbx
  _BYTE v17[16]; // [rsp+30h] [rbp-88h] BYREF
  int n0x6400; // [rsp+40h] [rbp-78h] BYREF
  __int64 v19; // [rsp+44h] [rbp-74h]
  int v20; // [rsp+4Ch] [rbp-6Ch]
  unsigned __int64 v21; // [rsp+50h] [rbp-68h]
  unsigned __int64 v22; // [rsp+58h] [rbp-60h]
  __int64 v23; // [rsp+60h] [rbp-58h]
  __int64 v24; // [rsp+68h] [rbp-50h]
  char v25; // [rsp+C0h] [rbp+8h] BYREF

  n0x6400 = 0x6400;
  v20 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v19 = 1;
  v21 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516FA6CC,
    "CReplicationModel::OnStartNetworkFrame_Sync",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Replication/ReplicationModel.cpp",
    0x12D);
  v2 = a1[0x174];
  HIWORD(n0x6400) = word_1516FA6CC;
  if ( v2 )
  {
    v3 = qword_1516FAFC8;
    sub_146D13AC0(qword_1516FAFC8 + 0x2F0, "CReplicationModel::OnStartNetworkFrame_Sync", (const char *)&p_Src, 1);
    sub_146D99420(v2);
    sub_146E559C0(a1);
    sub_146D9AE20((LARGE_INTEGER)v2);
    sub_146D13B70(v3 + 0x2F0);
  }
  v4 = a1[0x176];
  if ( v4 )
    sub_146D64190(v4);
  v5 = a1[0x3415];
  if ( v5 )
  {
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v5 + 0x28) == v6 )
    {
      ++*(_DWORD *)(v5 + 0x2C);
    }
    else
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 1, 0);
      if ( v7 )
        sub_1403C6E80(v5 + 0x18, v7, (__int64)"CLoadCostCalculator::MainThreadTick", 1);
      else
        *(_QWORD *)(v5 + 0x20) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v5 + 0x28) = v6;
    }
    ++*(_DWORD *)(v5 + 8);
    (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)qword_149C8DF80 + 0x70LL))(qword_149C8DF80, &v25);
    v8 = sub_14059CC00();
    *((_QWORD *)&v10 + 1) = v8.m128_u64[1];
    *(double *)&v10 = *(double *)v8.m128_u64 * 1000.0;
    _XMM0 = v10;
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    *(float *)(v5 + 0xC) = (float)(*(float *)&_XMM1 - *(float *)(v5 + 0x10)) + *(float *)(v5 + 0xC);
    *(_DWORD *)(v5 + 0x14) = *(_DWORD *)(sub_146E654E0(qword_1516FAFC8) + 0x2C);
    *(_QWORD *)(v5 + 0x30) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
                                          qword_149C8DF80,
                                          v17);
    v12 = *(_DWORD *)(v5 + 0x2C);
    if ( v12 )
    {
      *(_DWORD *)(v5 + 0x2C) = v12 - 1;
    }
    else
    {
      *(_DWORD *)(v5 + 0x28) = 0xFFFFFFFF;
      v13 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 0, 1);
      if ( v13 == 1 )
        *(_QWORD *)(v5 + 0x20) = &p_Src;
      else
        sub_1403DF590(v5 + 0x18, v13);
    }
  }
  v14 = (__int64)(a1 + 8);
  if ( !(unsigned __int8)sub_146D12C80(v14) )
  {
    v15 = qword_1516FAFC8 + 0x2F0;
    sub_146D147A0(qword_1516FAFC8 + 0x2F0, "CReplicationModel::OnStartNetworkFrame_Sync", (const char *)&p_Src, 1);
    sub_146D12F00(v14);
    sub_146D131F0(v14);
    if ( v15 )
      sub_146D14920(v15);
  }
  v22 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146E145D0 (0x146E145D0) ---

// --- Function: sub_146E1AE70 (0x146E1AE70) ---
__int64 __fastcall sub_146E1AE70(__int64 a1)
{
  volatile signed __int64 *v2; // rbx
  int v3; // esi
  __int64 v4; // r8
  unsigned __int64 v5; // rax
  int v6; // eax
  unsigned __int64 n0x200000; // rax
  unsigned __int64 *v8; // rbx
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  __int64 v12; // rbx
  int n0x6400; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v15; // [rsp+34h] [rbp-CCh]
  int v16; // [rsp+3Ch] [rbp-C4h]
  unsigned __int64 v17; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v18; // [rsp+48h] [rbp-B8h]
  __int64 v19; // [rsp+50h] [rbp-B0h]
  __int64 v20; // [rsp+58h] [rbp-A8h]
  unsigned __int64 v21[4]; // [rsp+80h] [rbp-80h] BYREF
  __int64 (__fastcall *p_sub_146DECAB0)(); // [rsp+A0h] [rbp-60h] BYREF
  __int64 (__fastcall *n2)(); // [rsp+A8h] [rbp-58h]
  _QWORD *v24; // [rsp+B0h] [rbp-50h]
  __int64 (__fastcall *p_sub_146DED4A0)(); // [rsp+B8h] [rbp-48h] BYREF
  __int64 (__fastcall *n2_1)(); // [rsp+C0h] [rbp-40h]
  _QWORD *v27; // [rsp+C8h] [rbp-38h]
  __int64 (__fastcall *p_sub_146DED4D0)(); // [rsp+D0h] [rbp-30h] BYREF
  __int64 (__fastcall *n2_2)(); // [rsp+D8h] [rbp-28h]
  _QWORD *v30; // [rsp+E0h] [rbp-20h]
  unsigned int v31; // [rsp+E8h] [rbp-18h]
  unsigned __int64 v32; // [rsp+F0h] [rbp-10h] BYREF
  unsigned __int64 v33; // [rsp+F8h] [rbp-8h]
  unsigned __int64 v34; // [rsp+100h] [rbp+0h]

  n0x6400 = 0x6400;
  v16 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v15 = 1;
  v17 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516FA760,
    "CReplicationModel::ReadReplicatedEntityChangesFromGame",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Replication/ReplicationModel.cpp",
    0x1842);
  HIWORD(n0x6400) = word_1516FA760;
  sub_1403D37D0(a1 + 0x8C0, 0xC3500);
  v2 = (volatile signed __int64 *)(a1 + 0x858);
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x868) == v3 )
  {
    ++*(_DWORD *)(a1 + 0x86C);
  }
  else
  {
    v4 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v5 = _InterlockedCompareExchange64(v2, 0x200000, 0);
    if ( v5 )
      sub_1403E1120(a1 + 0x858, v5, v4, (const char *)&p_Src, (const char *)&p_Src, 1);
    else
      *(_QWORD *)(a1 + 0x860) = v4;
    *(_DWORD *)(a1 + 0x868) = v3;
  }
  sub_146CB1560(a1 + 0x870, a1 + 0x8C0);
  if ( a1 != 0xFFFFFFFFFFFFF7A8uLL )
  {
    v6 = *(_DWORD *)(a1 + 0x86C);
    if ( v6 )
    {
      *(_DWORD *)(a1 + 0x86C) = v6 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x868) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(v2, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(a1 + 0x860) = &p_Src;
      else
        rw_lock_handle_write_release_contention(a1 + 0x858, n0x200000);
    }
  }
  sub_1402B3B60((__int64)&p_sub_146DECAB0, 0x64, 6, "ReadReplicatedEntityChangesFromGame");
  v8 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)qword_149C8DFC0 + 0x3E8LL))(
                             qword_149C8DFC0,
                             v21);
  if ( &v32 != v8 )
  {
    if ( v32 )
    {
      sub_1403A6820((__int64)&v32, v32, (v34 - v32) & 0xFFFFFFFFFFFFFFF8uLL);
      v32 = 0;
      v33 = 0;
      v34 = 0;
    }
    v32 = *v8;
    v33 = v8[1];
    v34 = v8[2];
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  if ( v21[0] )
    sub_1403A6820((__int64)v21, v21[0], (v21[2] - v21[0]) & 0xFFFFFFFFFFFFFFF8uLL);
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2)(2, &p_sub_146DECAB0);
    n2 = 0;
  }
  p_sub_146DECAB0 = 0;
  v9 = (_QWORD *)sub_1402A65A0(8u);
  if ( v9 )
  {
    *v9 = a1;
    v24 = v9;
  }
  else
  {
    v24 = 0;
  }
  p_sub_146DECAB0 = sub_146DECAB0;
  n2 = sub_146DEDEA0;
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2_1)(2, &p_sub_146DED4A0);
    n2_1 = 0;
  }
  p_sub_146DED4A0 = 0;
  v10 = (_QWORD *)sub_1402A65A0(8u);
  if ( v10 )
  {
    *v10 = a1;
    v27 = v10;
  }
  else
  {
    v27 = 0;
  }
  p_sub_146DED4A0 = sub_146DED4A0;
  n2_1 = sub_146DEF940;
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2_2)(2, &p_sub_146DED4D0);
    n2_2 = 0;
  }
  p_sub_146DED4D0 = 0;
  v11 = (_QWORD *)sub_1402A65A0(8u);
  if ( v11 )
  {
    *v11 = a1;
    v30 = v11;
  }
  else
  {
    v30 = 0;
  }
  p_sub_146DED4D0 = sub_146DED4D0;
  n2_2 = sub_146DEFC30;
  qword_149C89AF0(v31, &unk_1516FA764, "entities: ");
  v12 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall **)()))(*(_QWORD *)qword_149C8E038 + 0x28LL))(
          qword_149C8E038,
          &p_sub_146DECAB0);
  if ( v32 )
  {
    sub_1403A6820((__int64)&v32, v32, (v34 - v32) & 0xFFFFFFFFFFFFFFF8uLL);
    v32 = 0;
    v33 = 0;
    v34 = 0;
  }
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2_2)(2, &p_sub_146DED4D0);
    n2_2 = 0;
  }
  p_sub_146DED4D0 = 0;
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2_1)(2, &p_sub_146DED4A0);
    n2_1 = 0;
  }
  p_sub_146DED4A0 = 0;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2)(2, &p_sub_146DECAB0);
    n2 = 0;
  }
  p_sub_146DECAB0 = 0;
  v18 = __rdtsc();
  qword_149C89AA8(&n0x6400);
  return v12;
}

// --- End Function: sub_146E1AE70 (0x146E1AE70) ---

// --- Function: sub_146E1B720 (0x146E1B720) ---
__int64 __fastcall sub_146E1B720(__int64 a1)
{
  __int64 v2; // rax
  unsigned int v3; // r14d
  __int64 v4; // r8
  __int64 v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  bool v8; // cf
  __int64 v9; // rdi
  int v10; // ebx
  int *ThreadLogContextSlot_1; // rax
  __int64 v12; // rcx
  int v13; // ebx
  int *ThreadLogContextSlot; // rax
  __int128 v16; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v17; // [rsp+60h] [rbp-A0h]
  __int64 v18; // [rsp+68h] [rbp-98h] BYREF
  int n0x6400; // [rsp+70h] [rbp-90h] BYREF
  __int64 v20; // [rsp+74h] [rbp-8Ch]
  int v21; // [rsp+7Ch] [rbp-84h]
  unsigned __int64 v22; // [rsp+80h] [rbp-80h]
  unsigned __int64 v23; // [rsp+88h] [rbp-78h]
  __int64 v24; // [rsp+90h] [rbp-70h]
  __int64 v25; // [rsp+98h] [rbp-68h]
  _QWORD v26[2]; // [rsp+C0h] [rbp-40h] BYREF
  _QWORD v27[2]; // [rsp+D0h] [rbp-30h] BYREF
  _QWORD v28[2]; // [rsp+E0h] [rbp-20h] BYREF
  _QWORD v29[2]; // [rsp+F0h] [rbp-10h] BYREF
  __int128 v30; // [rsp+100h] [rbp+0h] BYREF
  __int128 v31; // [rsp+110h] [rbp+10h] BYREF
  _DWORD v32[4]; // [rsp+120h] [rbp+20h] BYREF
  _DWORD v33[4]; // [rsp+130h] [rbp+30h] BYREF
  _DWORD v34[4]; // [rsp+140h] [rbp+40h] BYREF
  _DWORD v35[4]; // [rsp+150h] [rbp+50h] BYREF
  __int64 v36; // [rsp+160h] [rbp+60h] BYREF

  v21 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  n0x6400 = 0x6400;
  v20 = 1;
  v22 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516FA8A4,
    "CStreamingBubbleManager::ReadUpdateBubblesFromGame",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Replication/StreamingBubbleManager.cpp",
    0x17);
  HIWORD(n0x6400) = word_1516FA8A4;
  v16 = 0;
  v17 = 0;
  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x2D0LL))(qword_149C8DFC0);
  (*(void (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v2 + 8LL))(v2, &v16);
  v3 = 0;
  if ( (*((_QWORD *)&v16 + 1) - (_QWORD)v16) / 0x58LL )
  {
    v4 = 0;
    do
    {
      v5 = v16 + 0x58 * v4;
      v6 = sub_146E57DC0(a1, v5 + 0x30);
      if ( v6 != *(_QWORD *)(a1 + 8) )
      {
        v7 = *(_QWORD *)(v5 + 0x30);
        v8 = v7 < *(_QWORD *)v6;
        if ( v7 == *(_QWORD *)v6 )
          v8 = *(_QWORD *)(v5 + 0x38) < *(_QWORD *)(v6 + 8);
        if ( !v8
          && (*(_QWORD *)v5 != *(_QWORD *)(v6 + 0x10)
           || *(double *)(v6 + 0x18) != *(double *)(v5 + 8)
           || *(double *)(v6 + 0x20) != *(double *)(v5 + 0x10)
           || *(double *)(v6 + 0x28) != *(double *)(v5 + 0x18)
           || *(double *)(v6 + 0x30) != *(double *)(v5 + 0x20)
           || *(_DWORD *)(v5 + 0x48) != *(_DWORD *)(v6 + 0x58)) )
        {
          v9 = *(_QWORD *)(a1 + 0x90);
          v18 = v5;
          sub_146DA6270(v9, v9 + 0xBE0, 0x400, &v18);
          if ( *(_QWORD *)(v5 + 0x30) || *(_QWORD *)(v5 + 0x38) )
          {
            v12 = *(_QWORD *)(v9 + 0x8070);
            if ( v12 )
            {
              sub_146E4FAD0(v12, v5);
            }
            else
            {
              v34[0] = 0xD6;
              v28[0] = v34;
              v34[1] = 0x67;
              v28[1] = v35;
              v34[2] = 0x8A;
              v34[3] = 0x9F;
              v13 = invokeGlobalCallbackAndMaskStatusBits(
                      3,
                      (__int64)v28,
                      (__int64)"Streaming Bubble Manager Null (Update)",
                      "The streaming bubble manager has not been initialized, streaming bubbles cannot be replicated to this host");
              if ( (v13 & 0xFFFFF) != 0 )
              {
                ThreadLogContextSlot = getThreadLogContextSlot();
                v29[0] = v35;
                v29[1] = &v36;
                v35[0] = 0xD6;
                v31 = 0;
                v35[1] = 0x67;
                v35[2] = 0x8A;
                v35[3] = 0x9F;
                sub_140354250(
                  3,
                  (__int64)v29,
                  "Streaming Bubble Manager Null (Update)",
                  (__int64)"The streaming bubble manager has not been initialized, streaming bubbles cannot be replicated to this host",
                  1,
                  v13,
                  &v31,
                  0,
                  (__int64)ThreadLogContextSlot);
              }
            }
          }
          else
          {
            v32[0] = 0xD6;
            v26[0] = v32;
            v32[1] = 0x67;
            v26[1] = v33;
            v32[2] = 0x8A;
            v32[3] = 0x9F;
            v10 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)v26,
                    (__int64)"Streaming Bubble Invalid (Update)",
                    "A streaming bubble must have a valid id to be changed");
            if ( (v10 & 0xFFFFF) != 0 )
            {
              ThreadLogContextSlot_1 = getThreadLogContextSlot();
              v27[0] = v33;
              v27[1] = v34;
              v33[0] = 0xD6;
              v30 = 0;
              v33[1] = 0x67;
              v33[2] = 0x8A;
              v33[3] = 0x9F;
              sub_140354250(
                3,
                (__int64)v27,
                "Streaming Bubble Invalid (Update)",
                (__int64)"A streaming bubble must have a valid id to be changed",
                1,
                v10,
                &v30,
                0,
                (__int64)ThreadLogContextSlot_1);
            }
          }
        }
      }
      v4 = ++v3;
    }
    while ( v3 < (unsigned __int64)((*((_QWORD *)&v16 + 1) - (_QWORD)v16) / 0x58LL) );
  }
  if ( (_QWORD)v16 )
  {
    sub_1403A6820((__int64)&v16, v16, 0x58 * ((v17 - (__int64)v16) / 0x58));
    v16 = 0;
    v17 = 0;
  }
  v23 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146E1B720 (0x146E1B720) ---

// --- Function: sub_146E559C0 (0x146E559C0) ---
__int64 __fastcall sub_146E559C0(__int64 a1)
{
  unsigned __int64 *v2; // rbx
  _QWORD *v3; // rax
  _QWORD *v4; // rax
  _QWORD *v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rax
  char v9[16]; // [rsp+30h] [rbp-D0h] BYREF
  int n0x6400; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v11; // [rsp+44h] [rbp-BCh]
  int v12; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v13; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v14; // [rsp+58h] [rbp-A8h]
  __int64 v15; // [rsp+60h] [rbp-A0h]
  __int64 v16; // [rsp+68h] [rbp-98h]
  unsigned __int64 v17[4]; // [rsp+90h] [rbp-70h] BYREF
  __int64 (__fastcall *p_sub_146DECEA0)(__int64); // [rsp+B0h] [rbp-50h] BYREF
  void (__fastcall *n2)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+B8h] [rbp-48h]
  _QWORD *v20; // [rsp+C0h] [rbp-40h]
  __int64 (__fastcall *p_sub_146DED4B0)(__int64); // [rsp+C8h] [rbp-38h] BYREF
  void (__fastcall *n2_1)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+D0h] [rbp-30h]
  _QWORD *v23; // [rsp+D8h] [rbp-28h]
  __int64 (__fastcall *p_sub_146DED4E0)(); // [rsp+E0h] [rbp-20h] BYREF
  void (__fastcall *n2_2)(__int64, __int64 (__fastcall **)()); // [rsp+E8h] [rbp-18h]
  _QWORD *v26; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v27; // [rsp+100h] [rbp+0h] BYREF
  unsigned __int64 v28; // [rsp+108h] [rbp+8h]
  unsigned __int64 v29; // [rsp+110h] [rbp+10h]
  __int64 (*p_sub_146DED500)(); // [rsp+170h] [rbp+70h] BYREF
  void (__fastcall *n2_3)(__int64, __int64 (**)()); // [rsp+178h] [rbp+78h]
  __int64 v32; // [rsp+180h] [rbp+80h]
  __int64 (__fastcall *p_sub_146DED530)(__int64, __int64); // [rsp+188h] [rbp+88h] BYREF
  void (__fastcall *n2_4)(int, __int64 (__fastcall **)(__int64, __int64), __int64 (__fastcall **)(__int64, __int64)); // [rsp+190h] [rbp+90h]
  __int64 v35; // [rsp+198h] [rbp+98h]
  void *v36; // [rsp+1C0h] [rbp+C0h] BYREF

  n0x6400 = 0x6400;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v11 = 1;
  v13 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516FA784,
    "CReplicationModel::WriteReplicatedEntityChangesToGame",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Replication/ReplicationModel.cpp",
    0x1A6E);
  HIWORD(n0x6400) = word_1516FA784;
  if ( (dword_1516FA7E0 & 1) == 0 )
  {
    dword_1516FA7E0 |= 1u;
    *(_QWORD *)v9 = &p_Src;
    sub_140361AC0((__int64)&qword_1516FA790, 0x1DCD65000LL, v9, 0xFFFFFFFFFFFFFFFFuLL);
    atexit(sub_148286160);
  }
  sub_1402B3B60((__int64)&p_sub_146DECEA0, 0x64, 2, "ReceiveDirtyValues");
  v2 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)qword_149C8DFC0 + 0x3E8LL))(
                             qword_149C8DFC0,
                             v17);
  if ( &v27 != v2 )
  {
    if ( v27 )
    {
      sub_1403A6820((__int64)&v27, v27, (v29 - v27) & 0xFFFFFFFFFFFFFFF8uLL);
      v27 = 0;
      v28 = 0;
      v29 = 0;
    }
    v27 = *v2;
    v28 = v2[1];
    v29 = v2[2];
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  if ( v17[0] )
    sub_1403A6820((__int64)v17, v17[0], (v17[2] - v17[0]) & 0xFFFFFFFFFFFFFFF8uLL);
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2)(2, &p_sub_146DECEA0);
    n2 = 0;
  }
  p_sub_146DECEA0 = 0;
  v3 = (_QWORD *)sub_1402A65A0(8u);
  if ( v3 )
  {
    *v3 = a1;
    v20 = v3;
  }
  else
  {
    v20 = 0;
  }
  p_sub_146DECEA0 = sub_146DECEA0;
  n2 = sub_146DEE860;
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2_1)(2, &p_sub_146DED4B0);
    n2_1 = 0;
  }
  p_sub_146DED4B0 = 0;
  v4 = (_QWORD *)sub_1402A65A0(8u);
  if ( v4 )
  {
    *v4 = a1;
    v23 = v4;
  }
  else
  {
    v23 = 0;
  }
  p_sub_146DED4B0 = sub_146DED4B0;
  n2_1 = sub_146DEFA60;
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, &p_sub_146DED4E0);
    n2_2 = 0;
  }
  p_sub_146DED4E0 = 0;
  v5 = (_QWORD *)sub_1402A65A0(8u);
  if ( v5 )
  {
    *v5 = a1;
    v26 = v5;
  }
  else
  {
    v26 = 0;
  }
  p_sub_146DED4E0 = sub_146DED4E0;
  n2_2 = (void (__fastcall *)(__int64, __int64 (__fastcall **)()))sub_146DEFD50;
  v6 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall **)(__int64)))(*(_QWORD *)qword_149C8E038 + 0x28LL))(
         qword_149C8E038,
         &p_sub_146DECEA0);
  sub_1402B3B60((__int64)&p_sub_146DED500, 0x64, 5, "PerformCallbacks");
  *(_QWORD *)v9 = v6;
  sub_1405F1730(&v36, v9, 1u);
  if ( (unsigned __int64)n2_3 >= 2 )
  {
    n2_3(2, &p_sub_146DED500);
    n2_3 = 0;
  }
  p_sub_146DED500 = 0;
  v32 = sub_1402A65A0(1u);
  p_sub_146DED500 = sub_146DED500;
  n2_3 = (void (__fastcall *)(__int64, __int64 (**)()))sub_146DEFE70;
  if ( (unsigned __int64)n2_4 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))n2_4)(2, &p_sub_146DED530);
    n2_4 = 0;
  }
  p_sub_146DED530 = 0;
  v35 = sub_1402A65A0(1u);
  p_sub_146DED530 = sub_146DED530;
  n2_4 = sub_146DEFF60;
  v7 = (*(__int64 (__fastcall **)(__int64, __int64 (**)()))(*(_QWORD *)qword_149C8E038 + 0x28LL))(
         qword_149C8E038,
         &p_sub_146DED500);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x48LL))(qword_149C8E038, v7);
  sub_1402B6C70(&p_sub_146DED500);
  if ( v27 )
  {
    sub_1403A6820((__int64)&v27, v27, (v29 - v27) & 0xFFFFFFFFFFFFFFF8uLL);
    v27 = 0;
    v28 = 0;
    v29 = 0;
  }
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, &p_sub_146DED4E0);
    n2_2 = 0;
  }
  p_sub_146DED4E0 = 0;
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2_1)(2, &p_sub_146DED4B0);
    n2_1 = 0;
  }
  p_sub_146DED4B0 = 0;
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2)(2, &p_sub_146DECEA0);
    n2 = 0;
  }
  p_sub_146DECEA0 = 0;
  v14 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146E559C0 (0x146E559C0) ---

// --- Function: sub_146E5F750 (0x146E5F750) ---
const ULONG_PTR *__fastcall sub_146E5F750(__int64 a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rcx

  v1 = *(__int64 **)(a1 + 0x10);
  *(_BYTE *)(*v1 + 0x908) = 1;
  v2 = *v1;
  if ( GetCurrentThreadId() != dword_1516FAFD0 )
  {
    v3 = *(_QWORD *)(v2 + 0x580);
    if ( v3 )
      sub_146D22180(v3);
  }
  return sub_146D14990(*v1 + 0x2F0);
}

// --- End Function: sub_146E5F750 (0x146E5F750) ---

// --- Function: sub_146E5FAB0 (0x146E5FAB0) ---
void __fastcall sub_146E5FAB0(
        int a1,
        const ULONG_PTR *(__fastcall **a2)(__int64 a1),
        const ULONG_PTR *(__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  const ULONG_PTR *(__fastcall *v5)(__int64); // rdi
  const ULONG_PTR *(__fastcall *v6)(__int64); // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A6590((__int64)a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (const ULONG_PTR *(__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (const ULONG_PTR *(__fastcall *)(__int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (const ULONG_PTR *(__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (const ULONG_PTR *(__fastcall *)(__int64))1;
      }
      else
      {
        v6 = (const ULONG_PTR *(__fastcall *)(__int64))sub_1402A65A0(8u);
        if ( v6 )
          *(_QWORD *)v6 = *(_QWORD *)v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_146E5F750;
        a2[1] = (const ULONG_PTR *(__fastcall *)(__int64))sub_146E5FAB0;
      }
    }
  }
}

// --- End Function: sub_146E5FAB0 (0x146E5FAB0) ---

// --- Function: sub_146E60B90 (0x146E60B90) ---
__int64 __fastcall sub_146E60B90(__int64 a1)
{
  __int64 v2; // rbx
  __int64 v5; // rcx
  __int64 v6; // rcx
  char *v7; // rbx
  char *v8; // rbx
  __int64 v9; // rcx
  __int64 v10; // rcx
  _BYTE *v11; // rdi
  _QWORD *v12; // rdx
  _QWORD *v13; // rbx
  unsigned __int128 v14; // kr00_16
  _QWORD *v15; // rax
  size_t Size; // rdi
  _BYTE *v17; // rdi
  _QWORD *v18; // rdx
  _QWORD *v19; // rbx
  _QWORD *v20; // rax
  size_t Size_1; // rdi
  _QWORD *v22; // rax
  void *v24[2]; // [rsp+38h] [rbp-D0h] BYREF
  char *Src; // [rsp+48h] [rbp-C0h]
  void *Src_8[2]; // [rsp+50h] [rbp-B8h] BYREF
  char *v27; // [rsp+60h] [rbp-A8h]
  __int64 v28; // [rsp+68h] [rbp-A0h]
  _QWORD v29[2]; // [rsp+74h] [rbp-94h] BYREF
  int v30; // [rsp+84h] [rbp-84h]
  unsigned __int64 v31; // [rsp+88h] [rbp-80h]
  unsigned __int64 v32; // [rsp+90h] [rbp-78h]
  __int64 v33; // [rsp+98h] [rbp-70h]
  __int64 v34; // [rsp+A0h] [rbp-68h]
  int n0x6400; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v36; // [rsp+CCh] [rbp-3Ch]
  int v37; // [rsp+D4h] [rbp-34h]
  unsigned __int64 v38; // [rsp+D8h] [rbp-30h]
  unsigned __int64 v39; // [rsp+E0h] [rbp-28h]
  __int64 v40; // [rsp+E8h] [rbp-20h]
  __int64 v41; // [rsp+F0h] [rbp-18h]
  __int64 v42; // [rsp+118h] [rbp+10h] BYREF
  void (__fastcall *n2_2)(__int64, __int64 *); // [rsp+120h] [rbp+18h]
  const ULONG_PTR *(__fastcall *p_sub_146E5F750)(__int64); // [rsp+130h] [rbp+28h] BYREF
  void (__fastcall *n2)(int, const ULONG_PTR *(__fastcall **)(__int64), const ULONG_PTR *(__fastcall **)(__int64)); // [rsp+138h] [rbp+30h]
  _QWORD *v46; // [rsp+140h] [rbp+38h]
  __int64 v47; // [rsp+148h] [rbp+40h] BYREF
  void (__fastcall *n2_1)(__int64, __int64 *); // [rsp+150h] [rbp+48h]
  int v49; // [rsp+160h] [rbp+58h]
  __int128 v50; // [rsp+168h] [rbp+60h] BYREF
  char *Src_1; // [rsp+178h] [rbp+70h]

  v37 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  n0x6400 = 0x6400;
  v36 = 1;
  v38 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_1516FB0C8,
    "CNetwork::DoSyncWithGame_FrameEnd",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Network.cpp",
    0x210);
  HIWORD(n0x6400) = word_1516FB0C8;
  HIDWORD(v29[0]) = 0x6400;
  v29[1] = 1;
  v30 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v31 = __rdtsc();
  qword_149C89AA0(
    (char *)v29 + 4,
    &word_1516FB1D0,
    "CNetwork::UpdateProfilingStatistics",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Network.cpp",
    0x382);
  v2 = *(_QWORD *)(a1 + 0x320);
  HIWORD(v29[0]) = word_1516FB1D0;
  v28 = v2;
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  *(float *)(a1 + 0x328) = *(float *)&_XMM1;
  _InterlockedAdd64((volatile signed __int64 *)(a1 + 0x320), -v2);
  sub_140421EA0(a1 + 0x920);
  v5 = *(_QWORD *)(a1 + 0x6C0);
  if ( v5 )
    sub_146E078B0(v5, a1 + 0x920);
  v6 = *(_QWORD *)(a1 + 0x588);
  if ( v6 )
    sub_146D30930(v6, a1 + 0x920);
  v32 = __rdtsc();
  qword_149C89AA8((char *)v29 + 4);
  v27 = 0;
  *(_OWORD *)Src_8 = 0;
  v7 = (char *)sub_140394E70((__int64)Src_8, 8u);
  memmove(v7, Src_8[0], (char *)Src_8[1] - (char *)Src_8[0]);
  if ( Src_8[0] )
    sub_1403A6820((__int64)Src_8, (unsigned __int64)Src_8[0], (v27 - (char *)Src_8[0]) & 0xFFFFFFFFFFFFFFF8uLL);
  Src_8[0] = v7;
  v27 = v7 + 8;
  Src_8[1] = v7;
  *(_OWORD *)v24 = 0;
  Src = 0;
  v8 = (char *)sub_140394E70((__int64)v24, 0x50u);
  memmove(v8, v24[0], (char *)v24[1] - (char *)v24[0]);
  if ( v24[0] )
    sub_1403A6820((__int64)v24, (unsigned __int64)v24[0], (Src - (char *)v24[0]) & 0xFFFFFFFFFFFFFFF8uLL);
  v24[0] = v8;
  Src = v8 + 0x50;
  v24[1] = v8;
  sub_146D14860(a1 + 0x2F0, (const char *)&p_Src, 1);
  v9 = *(_QWORD *)(a1 + 0x6C0);
  if ( v9 )
    sub_146E10F90(v9);
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0xE0LL))(qword_149C8DFE0) )
  {
    _InterlockedExchange((volatile __int32 *)(a1 + 0x314), 1);
    if ( GetCurrentThreadId() != dword_1516FAFD0 )
    {
      v10 = *(_QWORD *)(a1 + 0x580);
      if ( v10 )
        sub_146D22180(v10);
    }
    sub_146D14990(a1 + 0x2F0);
  }
  else
  {
    v11 = Src_8[1];
    v14 = *(_OWORD *)Src_8;
    v12 = (_QWORD *)(v14 >> 0x40);
    v13 = (_QWORD *)v14;
    if ( Src_8[0] != Src_8[1] )
    {
      do
      {
        if ( *v13 == 0xFFFFFFFFFFFFFFFFuLL )
          break;
        ++v13;
      }
      while ( v13 != Src_8[1] );
      if ( v13 != Src_8[1] )
      {
        v15 = v13 + 1;
        if ( v13 + 1 != Src_8[1] )
        {
          do
          {
            if ( *v15 != 0xFFFFFFFFFFFFFFFFuLL )
              *v13++ = *v15;
            ++v15;
          }
          while ( v15 != v12 );
          v11 = Src_8[1];
        }
      }
    }
    if ( v13 != v12 )
    {
      Size = v11 - (_BYTE *)v12;
      memmove(v13, v12, Size);
      Src_8[1] = (char *)v13 + Size;
    }
    v17 = v24[1];
    v18 = v24[1];
    v19 = v24[0];
    if ( v24[0] != v24[1] )
    {
      do
      {
        if ( *v19 == 0xFFFFFFFFFFFFFFFFuLL )
          break;
        ++v19;
      }
      while ( v19 != v24[1] );
      if ( v19 != v24[1] )
      {
        v20 = v19 + 1;
        if ( v19 + 1 != v24[1] )
        {
          do
          {
            if ( *v20 != 0xFFFFFFFFFFFFFFFFuLL )
              *v19++ = *v20;
            ++v20;
          }
          while ( v20 != v18 );
          v17 = v24[1];
        }
      }
    }
    if ( v19 != v18 )
    {
      Size_1 = v17 - (_BYTE *)v18;
      memmove(v19, v18, Size_1);
      v24[1] = (char *)v19 + Size_1;
    }
    sub_1402B3B60((__int64)&v42, 0x64, 0, "NetworkThreadWakeUp");
    if ( (_QWORD)v50 )
      sub_1403A6820((__int64)&v50, v50, (unsigned __int64)&Src_1[-v50] & 0xFFFFFFFFFFFFFFF8uLL);
    Src_1 = Src;
    Src = 0;
    v49 = 1;
    v50 = *(_OWORD *)v24;
    *(_OWORD *)v24 = 0;
    if ( (unsigned __int64)n2 >= 2 )
    {
      ((void (__fastcall *)(__int64, const ULONG_PTR *(__fastcall **)(__int64)))n2)(2, &p_sub_146E5F750);
      n2 = 0;
    }
    p_sub_146E5F750 = 0;
    v22 = (_QWORD *)sub_1402A65A0(8u);
    if ( v22 )
    {
      *v22 = a1;
      v46 = v22;
    }
    else
    {
      v46 = 0;
    }
    p_sub_146E5F750 = sub_146E5F750;
    n2 = sub_146E5FAB0;
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, &v42);
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)qword_149C8E038 + 0x40LL))(qword_149C8E038, Src_8);
    if ( (_QWORD)v50 )
    {
      sub_1403A6820((__int64)&v50, v50, (unsigned __int64)&Src_1[-v50] & 0xFFFFFFFFFFFFFFF8uLL);
      v50 = 0u;
      Src_1 = 0;
    }
    if ( (unsigned __int64)n2_1 >= 2 )
    {
      n2_1(2, &v47);
      n2_1 = 0;
    }
    v47 = 0;
    if ( (unsigned __int64)n2 >= 2 )
    {
      ((void (__fastcall *)(__int64, const ULONG_PTR *(__fastcall **)(__int64)))n2)(2, &p_sub_146E5F750);
      n2 = 0;
    }
    p_sub_146E5F750 = 0;
    if ( (unsigned __int64)n2_2 >= 2 )
    {
      n2_2(2, &v42);
      n2_2 = 0;
    }
    v42 = 0;
  }
  if ( v24[0] )
  {
    sub_1403A6820((__int64)v24, (unsigned __int64)v24[0], (Src - (char *)v24[0]) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_OWORD *)v24 = 0;
    Src = 0;
  }
  if ( Src_8[0] )
  {
    sub_1403A6820((__int64)Src_8, (unsigned __int64)Src_8[0], (v27 - (char *)Src_8[0]) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_OWORD *)Src_8 = 0;
    v27 = 0;
  }
  v39 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146E60B90 (0x146E60B90) ---

// --- Function: sub_146E64E50 (0x146E64E60) ---
__int64 __fastcall sub_146E64E50(__int64 a1)
{
  __int64 result; // rax

  result = sub_146E66810(a1, 0);
  *(_BYTE *)(a1 + 0x14F2) = 1;
  return result;
}

// --- End Function: sub_146E64E50 (0x146E64E60) ---

// --- Function: sub_146E654E0 (0x146E654E0) ---
__int64 __fastcall sub_146E654E0(__int64 a1)
{
  return a1 + 0x920;
}

// --- End Function: sub_146E654E0 (0x146E654E0) ---

// --- Function: sub_146E66810 (0x146E66810) ---
__int64 __fastcall sub_146E66810(__int64 a1, int a2)
{
  LARGE_INTEGER v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int16 v9[8]; // [rsp+30h] [rbp-59h] BYREF
  int n0x6400_1; // [rsp+40h] [rbp-49h] BYREF
  __int64 v11; // [rsp+44h] [rbp-45h]
  int v12; // [rsp+4Ch] [rbp-3Dh]
  unsigned __int64 v13; // [rsp+50h] [rbp-39h]
  unsigned __int64 v14; // [rsp+58h] [rbp-31h]
  __int64 v15; // [rsp+60h] [rbp-29h]
  __int64 v16; // [rsp+68h] [rbp-21h]
  int n0x6400; // [rsp+90h] [rbp+7h] BYREF
  __int64 v18; // [rsp+94h] [rbp+Bh]
  int v19; // [rsp+9Ch] [rbp+13h]
  unsigned __int64 v20; // [rsp+A0h] [rbp+17h]
  unsigned __int64 v21; // [rsp+A8h] [rbp+1Fh]
  __int64 v22; // [rsp+B0h] [rbp+27h]
  __int64 v23; // [rsp+B8h] [rbp+2Fh]

  n0x6400 = 0x6400;
  v18 = 0;
  v19 = 0;
  v9[0] = word_1516FAFD4[a2];
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v20 = __rdtsc();
  qword_149C89AA0(&n0x6400, v9, &p_Src, &p_Src, 0);
  HIWORD(n0x6400) = v9[0];
  if ( !*(_DWORD *)(a1 + 0x314) )
  {
    if ( !*(_BYTE *)(a1 + 0x14F0) || a2 )
    {
      if ( !*(_BYTE *)(a1 + 0x14F1) || a2 != 1 )
      {
        if ( a2 )
        {
          if ( a2 != 1 )
            goto LABEL_21;
          *(_QWORD *)(a1 + 0x330) -= sub_1403E7AE0().QuadPart;
          sub_146E60B90(a1);
        }
        else
        {
          v4 = sub_1403E7AE0();
          n0x6400_1 = 0x6400;
          *(_QWORD *)(a1 + 0x330) = -v4.QuadPart;
          v11 = 1;
          v12 = 0;
          v14 = 0;
          v15 = 0;
          v16 = 0;
          v13 = __rdtsc();
          qword_149C89AA0(
            &n0x6400_1,
            &word_1516FB0C4,
            "CNetwork::DoSyncWithGame_FrameStart",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Network.cpp",
            0x1FF);
          v5 = *(_QWORD *)(a1 + 0x6C0);
          HIWORD(n0x6400_1) = word_1516FB0C4;
          if ( v5 )
            sub_146E145C0(v5);
          v6 = *(_QWORD *)(a1 + 0x588);
          if ( v6 )
            sub_146D32DE0(v6);
          v7 = *(_QWORD *)(a1 + 0x6C0);
          if ( v7 )
            sub_146E145A0(v7);
          if ( qword_149C8DFC0 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x40LL))(qword_149C8DFC0);
          v14 = __rdtsc();
          qword_149C89AA8(&n0x6400_1);
        }
        *(_QWORD *)(a1 + 0x330) += sub_1403E7AE0().QuadPart;
        goto LABEL_21;
      }
      *(_BYTE *)(a1 + 0x14F1) = 0;
    }
    else
    {
      *(_BYTE *)(a1 + 0x14F1) = 1;
    }
  }
LABEL_21:
  v21 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146E66810 (0x146E66810) ---

// --- Function: sub_146E66810 (0x146E6699A) ---
__int64 __fastcall sub_146E66810(__int64 a1, int a2)
{
  LARGE_INTEGER v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int16 v9[8]; // [rsp+30h] [rbp-59h] BYREF
  int n0x6400_1; // [rsp+40h] [rbp-49h] BYREF
  __int64 v11; // [rsp+44h] [rbp-45h]
  int v12; // [rsp+4Ch] [rbp-3Dh]
  unsigned __int64 v13; // [rsp+50h] [rbp-39h]
  unsigned __int64 v14; // [rsp+58h] [rbp-31h]
  __int64 v15; // [rsp+60h] [rbp-29h]
  __int64 v16; // [rsp+68h] [rbp-21h]
  int n0x6400; // [rsp+90h] [rbp+7h] BYREF
  __int64 v18; // [rsp+94h] [rbp+Bh]
  int v19; // [rsp+9Ch] [rbp+13h]
  unsigned __int64 v20; // [rsp+A0h] [rbp+17h]
  unsigned __int64 v21; // [rsp+A8h] [rbp+1Fh]
  __int64 v22; // [rsp+B0h] [rbp+27h]
  __int64 v23; // [rsp+B8h] [rbp+2Fh]

  n0x6400 = 0x6400;
  v18 = 0;
  v19 = 0;
  v9[0] = word_1516FAFD4[a2];
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v20 = __rdtsc();
  qword_149C89AA0(&n0x6400, v9, &p_Src, &p_Src, 0);
  HIWORD(n0x6400) = v9[0];
  if ( !*(_DWORD *)(a1 + 0x314) )
  {
    if ( !*(_BYTE *)(a1 + 0x14F0) || a2 )
    {
      if ( !*(_BYTE *)(a1 + 0x14F1) || a2 != 1 )
      {
        if ( a2 )
        {
          if ( a2 != 1 )
            goto LABEL_21;
          *(_QWORD *)(a1 + 0x330) -= sub_1403E7AE0().QuadPart;
          sub_146E60B90(a1);
        }
        else
        {
          v4 = sub_1403E7AE0();
          n0x6400_1 = 0x6400;
          *(_QWORD *)(a1 + 0x330) = -v4.QuadPart;
          v11 = 1;
          v12 = 0;
          v14 = 0;
          v15 = 0;
          v16 = 0;
          v13 = __rdtsc();
          qword_149C89AA0(
            &n0x6400_1,
            &word_1516FB0C4,
            "CNetwork::DoSyncWithGame_FrameStart",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryNetwork\\Network.cpp",
            0x1FF);
          v5 = *(_QWORD *)(a1 + 0x6C0);
          HIWORD(n0x6400_1) = word_1516FB0C4;
          if ( v5 )
            sub_146E145C0(v5);
          v6 = *(_QWORD *)(a1 + 0x588);
          if ( v6 )
            sub_146D32DE0(v6);
          v7 = *(_QWORD *)(a1 + 0x6C0);
          if ( v7 )
            sub_146E145A0(v7);
          if ( qword_149C8DFC0 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x40LL))(qword_149C8DFC0);
          v14 = __rdtsc();
          qword_149C89AA8(&n0x6400_1);
        }
        *(_QWORD *)(a1 + 0x330) += sub_1403E7AE0().QuadPart;
        goto LABEL_21;
      }
      *(_BYTE *)(a1 + 0x14F1) = 0;
    }
    else
    {
      *(_BYTE *)(a1 + 0x14F1) = 1;
    }
  }
LABEL_21:
  v21 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_146E66810 (0x146E6699A) ---

// --- Function: sub_1471EA320 (0x1471EA320) ---
void __fastcall sub_1471EA320(unsigned __int64 *a1, _BYTE *a2, const void *a3, unsigned __int64 a4)
{
  _BYTE *v4; // rbp
  _BYTE *v6; // r15
  unsigned __int64 v8; // rcx
  __int64 v11; // rdx
  __int64 v12; // r8
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r13
  unsigned __int64 v15; // r8
  char *v16; // r14
  size_t Size_1; // r8
  const void *v18; // rdx
  char *v19; // rcx
  size_t Size; // r15
  unsigned __int64 v21; // r14
  char *v22; // rdi
  __int64 v23; // [rsp+78h] [rbp+10h]
  __int64 v25; // [rsp+88h] [rbp+20h]

  if ( a4 )
  {
    v4 = (_BYTE *)a1[1];
    v6 = (_BYTE *)*a1;
    v8 = a1[2];
    if ( a4 <= (__int64)(v8 - (_QWORD)v4) >> 3 )
    {
      Size = 8 * a4;
      v21 = (v4 - a2) >> 3;
      if ( a4 >= v21 )
      {
        v22 = &a2[Size];
        memmove(&a2[Size], a2, v4 - a2);
        a1[1] = (unsigned __int64)&v22[8 * v21];
      }
      else
      {
        memmove(v4, &v4[-Size], 8 * a4);
        a1[1] = (unsigned __int64)&v4[Size];
        memmove(&a2[Size], a2, &v4[-Size] - a2);
      }
      memmove(a2, a3, Size);
    }
    else
    {
      v11 = 0x1FFFFFFFFFFFFFFFLL;
      v12 = (v4 - v6) >> 3;
      if ( a4 > 0x1FFFFFFFFFFFFFFFLL - v12 )
        unknown_libname_10();
      v13 = (__int64)(v8 - (_QWORD)v6) >> 3;
      v14 = v12 + a4;
      v15 = v13 >> 1;
      if ( v13 <= 0x1FFFFFFFFFFFFFFFLL - (v13 >> 1) )
      {
        v11 = v15 + v13;
        if ( v15 + v13 < v14 )
          v11 = v14;
      }
      v25 = 8 * v11;
      v16 = (char *)sub_140394E70((__int64)a1, 8 * v11);
      v23 = (a2 - v6) >> 3;
      memmove(&v16[8 * v23], a3, 8 * a4);
      if ( a4 == 1 && a2 == v4 )
      {
        Size_1 = v4 - v6;
        v18 = v6;
        v19 = v16;
      }
      else
      {
        memmove(v16, v6, a2 - v6);
        v18 = a2;
        Size_1 = v4 - a2;
        v19 = &v16[8 * a4 + 8 * v23];
      }
      memmove(v19, v18, Size_1);
      if ( *a1 )
        sub_1403A6820((__int64)a1, *a1, (a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL);
      *a1 = (unsigned __int64)v16;
      a1[1] = (unsigned __int64)&v16[8 * v14];
      a1[2] = (unsigned __int64)&v16[v25];
    }
  }
}

// --- End Function: sub_1471EA320 (0x1471EA320) ---

// --- Function: sub_1475869C0 (0x1475869C0) ---
__int64 (*__fastcall sub_1475869C0(__int64 a1))(void)
{
  __int64 (*result)(void); // rax

  result = *(__int64 (**)(void))(a1 + 0x58);
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

// --- End Function: sub_1475869C0 (0x1475869C0) ---

// --- Function: sub_1475CF5F0 (0x1475CF5F0) ---
__int64 __fastcall sub_1475CF5F0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rbp
  int v4; // esi
  unsigned int v5; // eax
  __int64 *v6; // rax
  __int64 v7; // r14
  _QWORD *v8; // r15
  int v9; // eax
  __int64 p_p_Src; // rax
  unsigned __int32 v11; // eax
  _QWORD *i; // rsi
  _QWORD *v13; // rdi
  unsigned __int8 v14; // al
  void (__fastcall *v15)(_QWORD, _QWORD); // r9
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 v17; // rax
  __int128 v18; // [rsp+20h] [rbp-48h] BYREF

  v1 = a1 + 8;
  v18 = 0;
  v2 = 0;
  v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v1 + 0x10) == v4 )
  {
    ++*(_DWORD *)(v1 + 0x14);
  }
  else
  {
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 1, 0);
    if ( v5 )
      sub_1403C6E80(v1, v5, (__int64)"CHttpRequest::PollCallbacks", 1);
    else
      *(_QWORD *)(v1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v1 + 0x10) = v4;
  }
  v6 = (__int64 *)(a1 + 0x20);
  if ( (__int128 *)(a1 + 0x20) == &v18 )
  {
    v8 = (_QWORD *)*((_QWORD *)&v18 + 1);
    v7 = v18;
  }
  else
  {
    v7 = *v6;
    v8 = (_QWORD *)v6[1];
    v2 = v6[2];
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
  }
  v9 = *(_DWORD *)(v1 + 0x14);
  if ( v9 )
  {
    p_p_Src = (unsigned int)(v9 - 1);
    *(_DWORD *)(v1 + 0x14) = p_p_Src;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v11 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v11 == 1 )
    {
      p_p_Src = (__int64)&p_Src;
      *(_QWORD *)(v1 + 8) = &p_Src;
    }
    else
    {
      p_p_Src = (__int64)sub_1403DF590(v1, v11);
    }
  }
  for ( i = (_QWORD *)v7; i != v8; ++i )
  {
    v13 = (_QWORD *)*i;
    v14 = *(_BYTE *)(*i + 8LL);
    v15 = *(void (__fastcall **)(_QWORD, _QWORD))(*i + 0x20LL);
    if ( *(_QWORD *)(*i + 0x28LL) == 1 )
      v15(v14, *i);
    else
      ((void (__fastcall *)(_QWORD *, _QWORD, _QWORD))v15)(v13 + 4, v14, *i);
    n2 = (void (__fastcall *)(__int64, _QWORD *))v13[5];
    if ( (unsigned __int64)n2 >= 2 )
    {
      n2(2, v13 + 4);
      v13[5] = 0;
    }
    v13[4] = 0;
    sub_140373CC0(v13);
    p_p_Src = sub_1402A6590((__int64)v13);
  }
  if ( v7 )
  {
    v17 = v7;
    if ( ((v2 - v7) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      v7 = *(_QWORD *)(v7 - 8);
      if ( (unsigned __int64)(v17 - v7 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    return sub_1402A6590(v7);
  }
  return p_p_Src;
}

// --- End Function: sub_1475CF5F0 (0x1475CF5F0) ---

// --- Function: sub_1475E1D10 (0x1475E1D10) ---
__int64 __fastcall sub_1475E1D10(__int64 **a1)
{
  __time64_t Time_1; // rdx
  const char *v3; // r8
  signed int v4; // edi
  int v5; // r12d
  __int64 *v6; // rsi
  __int64 inserted; // rax
  __int64 v8; // rcx
  __int64 v9; // rax
  __int128 v10; // xmm0
  _QWORD *v11; // r14
  __int64 v12; // rbx
  __int64 v13; // rsi
  int v14; // r15d
  unsigned int i; // ebx
  bool v16; // zf
  unsigned int v17; // ecx
  const char *v19; // [rsp+28h] [rbp-D8h]
  char v20; // [rsp+38h] [rbp-C8h]
  int v21; // [rsp+38h] [rbp-C8h]
  int v22; // [rsp+40h] [rbp-C0h]
  char v23; // [rsp+50h] [rbp-B0h]
  int v24; // [rsp+64h] [rbp-9Ch]
  __time64_t Time; // [rsp+68h] [rbp-98h] BYREF
  __int64 v26; // [rsp+70h] [rbp-90h] BYREF
  __int128 v27; // [rsp+80h] [rbp-80h] BYREF
  int n0x1600; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v29; // [rsp+A4h] [rbp-5Ch]
  int v30; // [rsp+ACh] [rbp-54h]
  unsigned __int64 v31; // [rsp+B0h] [rbp-50h]
  unsigned __int64 v32; // [rsp+B8h] [rbp-48h]
  __int64 v33; // [rsp+C0h] [rbp-40h]
  __int64 v34; // [rsp+C8h] [rbp-38h]
  __int64 v35; // [rsp+F0h] [rbp-10h] BYREF
  __int64 n0x1FF; // [rsp+F8h] [rbp-8h]
  _BYTE *v37; // [rsp+100h] [rbp+0h]
  _BYTE v38[520]; // [rsp+108h] [rbp+8h] BYREF

  n0x1600 = 0x1600;
  v30 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 1;
  v31 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_151750518,
    "CSessionIDManager::UpdateSessionQR",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\SessionID/SessionIDManager.cpp",
    0x66);
  HIWORD(n0x1600) = word_151750518;
  if ( *((_BYTE *)a1 + 0x24) && byte_149C8E515 )
  {
    Time_1 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x38LL))(
                          qword_149C8DF80,
                          0)
           / 0x989680LL;
    Time = Time_1;
  }
  else
  {
    _time64(&Time);
    Time_1 = Time;
  }
  v3 = (const char *)a1[3];
  v37 = v38;
  v19 = (const char *)a1[2];
  v38[0] = 0;
  v35 = 0;
  n0x1FF = 0x1FF;
  sub_1402A59F0((__int64)&v35, "%s %s %lli %s", v3, &byte_149C8E727, Time_1, v19);
  if ( (dword_151750528 & 1) == 0 )
  {
    dword_151750528 |= 1u;
    sub_14035E090(&qword_151750520);
    atexit(sub_14828CDF0);
  }
  if ( (unsigned int)sub_1403E8B90(&qword_151750520, (__int64)v37) )
  {
    assignCStringToStringStructure((__int64)&qword_151750520, (__int64)v37);
    v20 = 1;
    if ( (unsigned __int8)sub_147731320(v37, &unk_151751480, byte_151750530, 0, 1, 0x28, 0xFFFFFFFF, v20) )
    {
      v4 = sub_1402FE5F0(byte_151750530);
      DWORD2(v27) = 0;
      v5 = v4 + 2;
      *((_DWORD *)a1 + 8) = v4 + 2;
      v6 = *a1;
      v24 = v4 + 2;
      inserted = (__int64)*a1;
      v8 = (*a1)[1];
      *(_QWORD *)&v27 = v8;
      while ( !*(_BYTE *)(v8 + 0x19) )
      {
        *(_QWORD *)&v27 = v8;
        if ( *(_DWORD *)(v8 + 0x20) >= v5 )
        {
          inserted = v8;
          DWORD2(v27) = 1;
          v8 = *(_QWORD *)v8;
        }
        else
        {
          v8 = *(_QWORD *)(v8 + 0x10);
          DWORD2(v27) = 0;
        }
      }
      if ( *(_BYTE *)(inserted + 0x19) || v5 < *(_DWORD *)(inserted + 0x20) )
      {
        if ( a1[1] == (__int64 *)0x38E38E38E38E38ELL )
          unknown_libname_7();
        v9 = sub_1402A65A0(0x48u);
        v10 = v27;
        *(_DWORD *)(v9 + 0x20) = v5;
        *(_QWORD *)(v9 + 0x28) = 0;
        *(_QWORD *)(v9 + 0x30) = 0;
        *(_QWORD *)(v9 + 0x38) = 0;
        *(_QWORD *)(v9 + 0x40) = 0;
        *(_QWORD *)v9 = v6;
        *(_QWORD *)(v9 + 8) = v6;
        *(_QWORD *)(v9 + 0x10) = v6;
        *(_WORD *)(v9 + 0x18) = 0;
        v27 = v10;
        inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                     a1,
                     (__int64)&v27,
                     v9);
      }
      v11 = (_QWORD *)(inserted + 0x28);
      if ( *(_QWORD *)(inserted + 0x28) )
        goto LABEL_27;
      v23 = 0;
      LOBYTE(v21) = 3;
      (*(void (__fastcall **)(_LocaleUpdate *, __int64 *, _QWORD, _QWORD, int, int, _QWORD, int, int, _QWORD, char))(*(_QWORD *)qword_149C8E018 + 0x348LL))(
        qword_149C8E018,
        &v26,
        (unsigned int)v5,
        (unsigned int)v5,
        1,
        1,
        0,
        v21,
        0x40001,
        0,
        v23);
      v12 = v26;
      if ( v26 )
      {
        if ( *v11 != v26 )
        {
          (**(void (__fastcall ***)(__int64))v26)(v26);
          if ( *v11 )
            (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v11 + 8LL))(*v11);
          *v11 = v12;
        }
        sub_14034F590((__int64)(v11 + 1), v5 * v5);
        if ( v26 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v26 + 8LL))(v26);
      }
      if ( *v11 )
      {
LABEL_27:
        if ( v4 >= (int)0xFFFFFFFF )
        {
          v13 = 0;
          v14 = v4 + 1;
          do
          {
            for ( i = 0xFFFFFFFF; (int)i < v14; ++v13 )
            {
              v16 = (unsigned __int8)sub_1477315A0(byte_151750530, i, (unsigned int)v4) == 0;
              v17 = 0xFFAFAFAF;
              if ( !v16 )
                v17 = 0xFF1E1E1E;
              ++i;
              *(_DWORD *)(v11[1] + 4 * v13) = v17;
            }
            --v4;
          }
          while ( v4 >= (int)0xFFFFFFFF );
          v5 = v24;
        }
        LOBYTE(v22) = 3;
        (*(void (__fastcall **)(_LocaleUpdate *, _QWORD *, _QWORD, _QWORD, _DWORD, int, int, _DWORD, int))(*(_QWORD *)qword_149C8E018 + 0x688LL))(
          qword_149C8E018,
          v11,
          v11[1],
          0,
          0,
          v5,
          v5,
          0,
          v22);
      }
    }
  }
  if ( v37 != v38 )
  {
    qword_149C78668 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
    sub_147715880(v37);
  }
  v32 = __rdtsc();
  return qword_149C89AA8(&n0x1600);
}

// --- End Function: sub_1475E1D10 (0x1475E1D10) ---

// --- Function: _InterlockedCompareExchange_w (0x1475E7EE0) ---
__int64 __fastcall sub_1475E7EE0(volatile signed __int32 *a1, signed __int32 a2, signed __int32 a3)
{
  return (unsigned int)_InterlockedCompareExchange(a1, a2, a3);
}

// --- End Function: _InterlockedCompareExchange_w (0x1475E7EE0) ---

// --- Function: sub_1475E8960 (0x1475E8960) ---
__int64 **__fastcall sub_1475E8960(__int64 **a1, __int64 a2, __int64 **a3, __int64 a4)
{
  unsigned __int64 v4; // rdi
  __int64 *v6; // rcx
  __int64 v8; // r14
  __int64 *v9; // r15
  __int64 v10; // rbp
  __int64 *v11; // rax
  unsigned __int64 v12; // rbx
  __int64 v13; // rsi
  unsigned __int64 v14; // r9
  char v15; // r12
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r10
  __int64 v18; // r12
  _QWORD *v19; // r8
  __int64 v20; // rax
  __int64 v21; // rdx
  unsigned __int64 v22; // r10
  unsigned __int64 v23; // r9
  __int64 *v24; // r8
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 *v27; // rdx
  __int64 v28; // rcx
  unsigned __int64 v29; // r10
  unsigned __int64 i; // rax
  __int64 *v31; // r9
  __int64 v32; // r8
  __int64 v33; // rdx
  __int64 *v34; // r8
  __int64 v35; // rdx
  unsigned __int64 v36; // rbx
  unsigned __int64 v38; // [rsp+38h] [rbp+10h]

  v4 = *(_QWORD *)(a2 + 0x10);
  v6 = *(__int64 **)a2;
  if ( *(_QWORD *)a2 )
    v8 = *v6;
  else
    v8 = 0;
  v9 = a3[2];
  if ( *a3 )
    v10 = **a3;
  else
    v10 = 0;
  v11 = *(__int64 **)a4;
  v12 = *(_QWORD *)(a4 + 0x10);
  if ( *(_QWORD *)a4 )
    v13 = *v11;
  else
    v13 = 0;
  if ( (__int64 *)v4 == v9 )
  {
    a1[1] = 0;
    a1[2] = (__int64 *)v12;
LABEL_24:
    *a1 = v11;
    return a1;
  }
  if ( v9 != (__int64 *)v12 )
  {
    v14 = (unsigned __int64)a3[2];
    v15 = *(_QWORD *)(a2 + 0x10);
    v38 = *(_QWORD *)(a2 + 0x10);
    v16 = v38;
    v17 = v38;
    do
    {
      if ( v16 == --v14 )
        break;
      v18 = v15 & 1;
      v19 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8 * ((*(_QWORD *)(v10 + 0x10) - 1LL) & (v14 >> 1)))
                     + 8 * (v14 & 1));
      v20 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 8 * ((*(_QWORD *)(v8 + 0x10) - 1LL) & (v17 >> 1)));
      v21 = *(_QWORD *)(v20 + 8 * v18);
      *(_QWORD *)(v20 + 8 * v18) = *v19;
      v16 = v38 + 1;
      *v19 = v21;
      v38 = v16;
      v17 = v16;
      v15 = v16;
    }
    while ( v16 != v14 );
    v22 = (unsigned __int64)v9;
    v23 = v12;
    do
    {
      if ( v22 == --v23 )
        break;
      v24 = (__int64 *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 8 * ((*(_QWORD *)(v13 + 0x10) - 1LL) & (v23 >> 1)))
                      + 8 * (v23 & 1));
      v25 = (*(_QWORD *)(v10 + 0x10) - 1LL) & (v22 >> 1);
      v26 = v22++ & 1;
      v27 = (__int64 *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8 * v25) + 8 * v26);
      v28 = *v27;
      *v27 = *v24;
      *v24 = v28;
    }
    while ( v22 != v23 );
    v29 = v4;
    for ( i = v12; v29 != i; *v31 = v35 )
    {
      if ( v29 == --i )
        break;
      v31 = (__int64 *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 8 * ((*(_QWORD *)(v13 + 0x10) - 1LL) & (i >> 1)))
                      + 8 * (i & 1));
      v32 = (*(_QWORD *)(v8 + 0x10) - 1LL) & (v29 >> 1);
      v33 = v29++ & 1;
      v34 = (__int64 *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8 * v32) + 8 * v33);
      v35 = *v34;
      *v34 = *v31;
    }
    v11 = *(__int64 **)a2;
    v36 = v12 - (_QWORD)v9;
    a1[1] = 0;
    *(_QWORD *)(a2 + 0x10) = v36 + v4;
    a1[2] = (__int64 *)(v36 + v4);
    goto LABEL_24;
  }
  a1[1] = 0;
  *a1 = v6;
  a1[2] = (__int64 *)v4;
  return a1;
}

// --- End Function: sub_1475E8960 (0x1475E8960) ---

// --- Function: sub_1475EBB00 (0x1475EBB00) ---
char __fastcall sub_1475EBB00(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax

  v2 = *a1 ^ *a2;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2 || ((*a1 ^ *a2) & 0xFFFFFF00) != 0 )
    LOBYTE(v2) = 1;
  return v2;
}

// --- End Function: sub_1475EBB00 (0x1475EBB00) ---

// --- Function: sub_1475EE1F0 (0x1475EE1F0) ---
__int64 sub_1475EE1F0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE58LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1475EE1F0 (0x1475EE1F0) ---

// --- Function: sub_1475F3500 (0x1475F3500) ---
char __fastcall sub_1475F3500(__int64 a1, unsigned __int8 a2, int a3, __int64 a4, __int64 a5, char a6)
{
  __int64 v6; // r15
  __int64 v10; // r14
  char v11; // di
  __int16 v12; // bx
  signed __int32 v13; // edx
  int v14; // r14d
  _QWORD *ThreadLocalStoragePointer; // rcx
  _QWORD *v16; // r12
  __int64 v17; // rax
  __int64 v18; // rax
  float v19; // xmm0_4
  float v20; // kr00_4
  float v21; // xmm1_4
  float v22; // kr00_4
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // r9
  __int64 v25; // rbx
  int v26; // r8d
  __int64 v27; // rdi
  unsigned __int64 v28; // r13
  int v29; // esi
  int v30; // eax
  int v31; // r15d
  unsigned __int64 v32; // rbx
  __int64 v33; // rdi
  void (__fastcall *v34)(unsigned __int64, _QWORD); // rax
  unsigned __int64 v35; // rax
  __int64 v36; // rdi
  unsigned int n8; // r10d
  unsigned __int64 n0x1000; // rcx
  bool v39; // cc
  unsigned __int64 v40; // rax
  unsigned __int64 v41; // rcx
  __int64 *v42; // rax
  __int64 v43; // r11
  unsigned __int64 v44; // r9
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // r9
  unsigned __int64 v47; // rax
  __int64 v48; // rdx
  __int64 v49; // rax
  __int64 v50; // rcx
  __int64 n8_1; // r15
  __int64 *v52; // rsi
  __int64 v53; // r14
  __int64 v54; // rbx
  bool v55; // di
  signed __int32 v56; // edx
  int v57; // r8d
  int v58; // r9d
  __int64 v59; // rdx
  __int64 v60; // rbx
  signed __int32 v62; // edx
  char v64; // [rsp+31h] [rbp-CFh]
  int v65; // [rsp+34h] [rbp-CCh]
  __int16 v66; // [rsp+38h] [rbp-C8h] BYREF
  __int16 v67; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v68; // [rsp+48h] [rbp-B8h]
  int v69; // [rsp+50h] [rbp-B0h]
  unsigned int v70; // [rsp+54h] [rbp-ACh]
  __int64 v71; // [rsp+58h] [rbp-A8h]
  __int64 v72; // [rsp+60h] [rbp-A0h]
  int v73; // [rsp+68h] [rbp-98h]
  __int64 v74; // [rsp+70h] [rbp-90h]
  _DWORD v75[3]; // [rsp+80h] [rbp-80h] BYREF
  int v76; // [rsp+8Ch] [rbp-74h]
  unsigned __int64 v77; // [rsp+90h] [rbp-70h]
  unsigned __int64 v78; // [rsp+98h] [rbp-68h]
  __int64 v79; // [rsp+A0h] [rbp-60h]
  __int64 v80; // [rsp+A8h] [rbp-58h]
  __int64 v81; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v82; // [rsp+D8h] [rbp-28h]
  _QWORD *v83; // [rsp+E0h] [rbp-20h]
  __int64 v84; // [rsp+E8h] [rbp-18h]
  __int64 v85; // [rsp+F0h] [rbp-10h] BYREF
  _QWORD v86[15]; // [rsp+F8h] [rbp-8h] BYREF

  v72 = a1;
  v68 = a4;
  v6 = 0x1E8 * (a1 & 0xFFF) + a4 + 0x30;
  v73 = a3;
  v81 = v6;
  sub_1475FF440(a4, v6);
  if ( *(_QWORD *)v6 != a1 || !*(_DWORD *)(v6 + 0x90) || a2 >= *(_BYTE *)(v6 + 0xB2) )
  {
    v62 = _InterlockedDecrement((volatile signed __int32 *)(v6 + 0x94));
    if ( !(_WORD)v62 && (v62 & 0xFF000000) != 0 )
      qword_149C78FD8(v6 + 0x94);
    return 0;
  }
  v10 = *(_QWORD *)(v6 + 8);
  v11 = *(_BYTE *)(v6 + 0xA0);
  v12 = *(_WORD *)(v6 + 0x9E);
  v64 = *(_BYTE *)(v6 + 0xB1);
  v74 = *(_QWORD *)(v6 + 0xA8);
  v69 = *(unsigned __int8 *)(v6 + 0xB0);
  v71 = v10;
  _InterlockedIncrement((volatile signed __int32 *)v10);
  v13 = _InterlockedDecrement((volatile signed __int32 *)(v6 + 0x94));
  if ( !(_WORD)v13 && (v13 & 0xFF000000) != 0 )
    qword_149C78FD8(v6 + 0x94);
  if ( *(int *)(v10 + 4) < 0 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)v10, 0xFFFFFFFF) == 1 )
      sub_1403E79B0((volatile signed __int64 *)(a4 + 0x20), (_QWORD *)v10);
    return 0;
  }
  v14 = 0;
  v65 = 0;
  HIWORD(v75[0]) = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v66 = v12;
  *(_QWORD *)&v75[1] = 1;
  LOBYTE(v75[0]) = 0;
  v77 = __rdtsc();
  BYTE1(v75[0]) = v11;
  qword_149C89AA0(v75, &v66, &p_Src, &p_Src, 0);
  ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
  HIWORD(v75[0]) = v66;
  v16 = (_QWORD *)ThreadLocalStoragePointer[TlsIndex];
  v83 = v16;
  v17 = v16[0x1C9];
  v16[0x1C9] = v75;
  v84 = v17;
  sub_1404D8EF0((_OWORD *)(v6 + 0x138));
  v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E080 + 0xD8LL))(qword_149C8E080);
  if ( v18 < 0 )
  {
    v20 = (float)(v18 & 1 | ((unsigned __int64)v18 >> 1));
    v19 = v20 + v20;
  }
  else
  {
    v19 = (float)v18;
  }
  v22 = v19 * 0.2;
  v21 = v19 * 0.2;
  v23 = 0;
  if ( (float)(v19 * 0.2) >= 9.223372e18 )
  {
    v21 = v22 - 9.223372e18;
    if ( (float)(v22 - 9.223372e18) < 9.223372e18 )
      v23 = 0x8000000000000000uLL;
  }
  v24 = v23 + (unsigned int)(int)v21;
  v82 = v24;
  v25 = v72;
  v26 = v69;
  v27 = v71;
  v28 = __rdtsc();
  v16[0x1C6] = v74;
  v16[0x1C7] = v25;
  v70 = -v26;
  v29 = _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 4), -v26);
  v30 = v29 - v26;
  v31 = v29 - v26;
  if ( v29 > 0 )
  {
    do
    {
      if ( v30 < 0 )
        v30 = 0;
      v32 = v30;
      if ( v30 < (unsigned __int64)(unsigned int)v29 )
      {
        v33 = v81;
        do
        {
          v34 = *(void (__fastcall **)(unsigned __int64, _QWORD))(v33 + 0x28);
          if ( *(_QWORD *)(v33 + 0x30) == 1 )
            v34(v32, a2);
          else
            ((void (__fastcall *)(__int64, unsigned __int64, _QWORD))v34)(v33 + 0x28, v32, a2);
          ++v32;
        }
        while ( v32 < (unsigned int)v29 );
        v16 = v83;
        v27 = v71;
        v26 = v69;
        v24 = v82;
      }
      if ( v31 < 0 )
        v31 = 0;
      v14 = v29 - v31 + v65;
      v65 = v14;
      if ( v64 == 1 && !a6 )
      {
        v35 = __rdtsc();
        if ( (((unsigned __int64)HIDWORD(v35) << 0x20) | (unsigned int)v35) - v28 > v24 )
        {
          if ( *(_DWORD *)(v27 + 4) + v26 )
          {
            v36 = v68;
            n8 = 0;
            n0x1000 = **(_QWORD **)(v68 + 0x1E8030);
            v39 = n0x1000 <= 0x1000;
            v85 = 0;
            memset(v86, 0, 0x18);
            v40 = n0x1000 - 0x1000;
            v41 = v16[0x1D4];
            if ( v39 )
              v40 = 0;
            v86[3] = 0;
            v86[4] = 0;
            if ( v41 < v40 )
              v41 = v40;
            v86[5] = 0;
            v16[0x1D4] = v41;
            v42 = *(__int64 **)(v36 + 0x1E8038);
            memset(&v86[6], 0, 0x48);
            v43 = *v42;
            do
            {
              v44 = v41;
              v45 = v41 & 0xFFF;
              v46 = v44 >> 0xC;
              v47 = *(_QWORD *)(v43 + 0x18 * v45) & 0xFFFFFFLL;
              if ( v47 >= v46 )
              {
                if ( v47 == v46 )
                {
                  v48 = (*(_QWORD *)(v43 + 0x18 * v45) >> 0x19) & 0x3FFFFFFFFFLL;
                  if ( v48 == 0x3FFFFFFFFFLL )
                    break;
                  v49 = v16[0x1D4];
                  v50 = 2LL * n8++;
                  v86[v50 - 1] = v48;
                  v86[v50] = v49;
                }
                ++v16[0x1D4];
              }
              else
              {
                _mm_pause();
              }
              v41 = v16[0x1D4];
            }
            while ( n8 < 8 );
            n8_1 = n8;
            if ( n8 )
            {
              v52 = &v85;
              do
              {
                v53 = *v52;
                v54 = v36 + 0x1E8 * (*v52 & 0xFFF);
                sub_1475FF440(v36, v54 + 0x30);
                v55 = *(_QWORD *)(v54 + 0x30) == v53
                   && *(_DWORD *)(v54 + 0xC0)
                   && a2 < *(_BYTE *)(v54 + 0xE2)
                   && *(_BYTE *)(v54 + 0xE1) != 1;
                v56 = _InterlockedDecrement((volatile signed __int32 *)(v54 + 0xC4));
                if ( !(_WORD)v56 && (v56 & 0xFF000000) != 0 )
                  qword_149C78FD8(v54 + 0xC4);
                if ( !v55 )
                  goto LABEL_61;
                if ( !v65 )
                  goto LABEL_60;
                if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v71 + 8), -v65) == v65 )
                {
                  sub_1475F8FE0(v68, v72, a2);
                  v55 = 0;
                  *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE30LL) = v74;
                }
                v65 = 0;
                if ( v55 )
                {
LABEL_60:
                  v78 = __rdtsc();
                  qword_149C89AA8(v75);
                  v36 = v68;
                  v57 = v73;
                  v58 = v68;
                  v16[0x1C6] = 0;
                  v16[0x1C7] = v53;
                  sub_1475F3500(v53, a2, v57, v58, a5, 0);
                  v75[0] = 0;
                  *(_QWORD *)&v75[1] = 1;
                  v76 = 0;
                  v16[0x1C7] = v72;
                  v78 = 0;
                  v79 = 0;
                  v80 = 0;
                  v67 = *(_WORD *)(v81 + 0x9E);
                  v77 = __rdtsc();
                  BYTE1(v75[0]) = *(_BYTE *)(v81 + 0xA0);
                  qword_149C89AA0(v75, &v67, &p_Src, &p_Src, 0);
                  HIWORD(v75[0]) = v67;
                  v16[0x1C6] = v74;
                }
                else
                {
LABEL_61:
                  v36 = v68;
                }
                v52 += 2;
                --n8_1;
              }
              while ( n8_1 );
              v14 = v65;
            }
            v27 = v71;
            v26 = v69;
            v28 = __rdtsc();
          }
        }
      }
      v29 = _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 4), v70);
      v24 = v82;
      v30 = v29 - v26;
      v31 = v29 - v26;
    }
    while ( v29 > 0 );
    v25 = v72;
  }
  v16[0x1C9] = v84;
  qword_149C89AE0("Jobs Executed %d", v14);
  sub_1404D5120();
  v78 = __rdtsc();
  qword_149C89AA8(v75);
  v16[0x1C7] = 0;
  if ( v14 && _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 8), -v14) == v14 )
  {
    v59 = v25;
    v60 = v68;
    sub_1475F8FE0(v68, v59, a2);
  }
  else
  {
    v60 = v68;
    v16[0x1C6] = 0;
  }
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)v27, 0xFFFFFFFF) == 1 )
    sub_1403E79B0((volatile signed __int64 *)(v60 + 0x20), (_QWORD *)v27);
  return 1;
}

// --- End Function: sub_1475F3500 (0x1475F3500) ---

// --- Function: sub_1475F3500 (0x1475F37E3) ---
char __fastcall sub_1475F3500(__int64 a1, unsigned __int8 a2, int a3, __int64 a4, __int64 a5, char a6)
{
  __int64 v6; // r15
  __int64 v10; // r14
  char v11; // di
  __int16 v12; // bx
  signed __int32 v13; // edx
  int v14; // r14d
  _QWORD *ThreadLocalStoragePointer; // rcx
  _QWORD *v16; // r12
  __int64 v17; // rax
  __int64 v18; // rax
  float v19; // xmm0_4
  float v20; // kr00_4
  float v21; // xmm1_4
  float v22; // kr00_4
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // r9
  __int64 v25; // rbx
  int v26; // r8d
  __int64 v27; // rdi
  unsigned __int64 v28; // r13
  int v29; // esi
  int v30; // eax
  int v31; // r15d
  unsigned __int64 v32; // rbx
  __int64 v33; // rdi
  void (__fastcall *v34)(unsigned __int64, _QWORD); // rax
  unsigned __int64 v35; // rax
  __int64 v36; // rdi
  unsigned int n8; // r10d
  unsigned __int64 n0x1000; // rcx
  bool v39; // cc
  unsigned __int64 v40; // rax
  unsigned __int64 v41; // rcx
  __int64 *v42; // rax
  __int64 v43; // r11
  unsigned __int64 v44; // r9
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // r9
  unsigned __int64 v47; // rax
  __int64 v48; // rdx
  __int64 v49; // rax
  __int64 v50; // rcx
  __int64 n8_1; // r15
  __int64 *v52; // rsi
  __int64 v53; // r14
  __int64 v54; // rbx
  bool v55; // di
  signed __int32 v56; // edx
  int v57; // r8d
  int v58; // r9d
  __int64 v59; // rdx
  __int64 v60; // rbx
  signed __int32 v62; // edx
  char v64; // [rsp+31h] [rbp-CFh]
  int v65; // [rsp+34h] [rbp-CCh]
  __int16 v66; // [rsp+38h] [rbp-C8h] BYREF
  __int16 v67; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v68; // [rsp+48h] [rbp-B8h]
  int v69; // [rsp+50h] [rbp-B0h]
  unsigned int v70; // [rsp+54h] [rbp-ACh]
  __int64 v71; // [rsp+58h] [rbp-A8h]
  __int64 v72; // [rsp+60h] [rbp-A0h]
  int v73; // [rsp+68h] [rbp-98h]
  __int64 v74; // [rsp+70h] [rbp-90h]
  _DWORD v75[3]; // [rsp+80h] [rbp-80h] BYREF
  int v76; // [rsp+8Ch] [rbp-74h]
  unsigned __int64 v77; // [rsp+90h] [rbp-70h]
  unsigned __int64 v78; // [rsp+98h] [rbp-68h]
  __int64 v79; // [rsp+A0h] [rbp-60h]
  __int64 v80; // [rsp+A8h] [rbp-58h]
  __int64 v81; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v82; // [rsp+D8h] [rbp-28h]
  _QWORD *v83; // [rsp+E0h] [rbp-20h]
  __int64 v84; // [rsp+E8h] [rbp-18h]
  __int64 v85; // [rsp+F0h] [rbp-10h] BYREF
  _QWORD v86[15]; // [rsp+F8h] [rbp-8h] BYREF

  v72 = a1;
  v68 = a4;
  v6 = 0x1E8 * (a1 & 0xFFF) + a4 + 0x30;
  v73 = a3;
  v81 = v6;
  sub_1475FF440(a4, v6);
  if ( *(_QWORD *)v6 != a1 || !*(_DWORD *)(v6 + 0x90) || a2 >= *(_BYTE *)(v6 + 0xB2) )
  {
    v62 = _InterlockedDecrement((volatile signed __int32 *)(v6 + 0x94));
    if ( !(_WORD)v62 && (v62 & 0xFF000000) != 0 )
      qword_149C78FD8(v6 + 0x94);
    return 0;
  }
  v10 = *(_QWORD *)(v6 + 8);
  v11 = *(_BYTE *)(v6 + 0xA0);
  v12 = *(_WORD *)(v6 + 0x9E);
  v64 = *(_BYTE *)(v6 + 0xB1);
  v74 = *(_QWORD *)(v6 + 0xA8);
  v69 = *(unsigned __int8 *)(v6 + 0xB0);
  v71 = v10;
  _InterlockedIncrement((volatile signed __int32 *)v10);
  v13 = _InterlockedDecrement((volatile signed __int32 *)(v6 + 0x94));
  if ( !(_WORD)v13 && (v13 & 0xFF000000) != 0 )
    qword_149C78FD8(v6 + 0x94);
  if ( *(int *)(v10 + 4) < 0 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)v10, 0xFFFFFFFF) == 1 )
      sub_1403E79B0((volatile signed __int64 *)(a4 + 0x20), (_QWORD *)v10);
    return 0;
  }
  v14 = 0;
  v65 = 0;
  HIWORD(v75[0]) = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v66 = v12;
  *(_QWORD *)&v75[1] = 1;
  LOBYTE(v75[0]) = 0;
  v77 = __rdtsc();
  BYTE1(v75[0]) = v11;
  qword_149C89AA0(v75, &v66, &p_Src, &p_Src, 0);
  ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
  HIWORD(v75[0]) = v66;
  v16 = (_QWORD *)ThreadLocalStoragePointer[TlsIndex];
  v83 = v16;
  v17 = v16[0x1C9];
  v16[0x1C9] = v75;
  v84 = v17;
  sub_1404D8EF0((_OWORD *)(v6 + 0x138));
  v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E080 + 0xD8LL))(qword_149C8E080);
  if ( v18 < 0 )
  {
    v20 = (float)(v18 & 1 | ((unsigned __int64)v18 >> 1));
    v19 = v20 + v20;
  }
  else
  {
    v19 = (float)v18;
  }
  v22 = v19 * 0.2;
  v21 = v19 * 0.2;
  v23 = 0;
  if ( (float)(v19 * 0.2) >= 9.223372e18 )
  {
    v21 = v22 - 9.223372e18;
    if ( (float)(v22 - 9.223372e18) < 9.223372e18 )
      v23 = 0x8000000000000000uLL;
  }
  v24 = v23 + (unsigned int)(int)v21;
  v82 = v24;
  v25 = v72;
  v26 = v69;
  v27 = v71;
  v28 = __rdtsc();
  v16[0x1C6] = v74;
  v16[0x1C7] = v25;
  v70 = -v26;
  v29 = _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 4), -v26);
  v30 = v29 - v26;
  v31 = v29 - v26;
  if ( v29 > 0 )
  {
    do
    {
      if ( v30 < 0 )
        v30 = 0;
      v32 = v30;
      if ( v30 < (unsigned __int64)(unsigned int)v29 )
      {
        v33 = v81;
        do
        {
          v34 = *(void (__fastcall **)(unsigned __int64, _QWORD))(v33 + 0x28);
          if ( *(_QWORD *)(v33 + 0x30) == 1 )
            v34(v32, a2);
          else
            ((void (__fastcall *)(__int64, unsigned __int64, _QWORD))v34)(v33 + 0x28, v32, a2);
          ++v32;
        }
        while ( v32 < (unsigned int)v29 );
        v16 = v83;
        v27 = v71;
        v26 = v69;
        v24 = v82;
      }
      if ( v31 < 0 )
        v31 = 0;
      v14 = v29 - v31 + v65;
      v65 = v14;
      if ( v64 == 1 && !a6 )
      {
        v35 = __rdtsc();
        if ( (((unsigned __int64)HIDWORD(v35) << 0x20) | (unsigned int)v35) - v28 > v24 )
        {
          if ( *(_DWORD *)(v27 + 4) + v26 )
          {
            v36 = v68;
            n8 = 0;
            n0x1000 = **(_QWORD **)(v68 + 0x1E8030);
            v39 = n0x1000 <= 0x1000;
            v85 = 0;
            memset(v86, 0, 0x18);
            v40 = n0x1000 - 0x1000;
            v41 = v16[0x1D4];
            if ( v39 )
              v40 = 0;
            v86[3] = 0;
            v86[4] = 0;
            if ( v41 < v40 )
              v41 = v40;
            v86[5] = 0;
            v16[0x1D4] = v41;
            v42 = *(__int64 **)(v36 + 0x1E8038);
            memset(&v86[6], 0, 0x48);
            v43 = *v42;
            do
            {
              v44 = v41;
              v45 = v41 & 0xFFF;
              v46 = v44 >> 0xC;
              v47 = *(_QWORD *)(v43 + 0x18 * v45) & 0xFFFFFFLL;
              if ( v47 >= v46 )
              {
                if ( v47 == v46 )
                {
                  v48 = (*(_QWORD *)(v43 + 0x18 * v45) >> 0x19) & 0x3FFFFFFFFFLL;
                  if ( v48 == 0x3FFFFFFFFFLL )
                    break;
                  v49 = v16[0x1D4];
                  v50 = 2LL * n8++;
                  v86[v50 - 1] = v48;
                  v86[v50] = v49;
                }
                ++v16[0x1D4];
              }
              else
              {
                _mm_pause();
              }
              v41 = v16[0x1D4];
            }
            while ( n8 < 8 );
            n8_1 = n8;
            if ( n8 )
            {
              v52 = &v85;
              do
              {
                v53 = *v52;
                v54 = v36 + 0x1E8 * (*v52 & 0xFFF);
                sub_1475FF440(v36, v54 + 0x30);
                v55 = *(_QWORD *)(v54 + 0x30) == v53
                   && *(_DWORD *)(v54 + 0xC0)
                   && a2 < *(_BYTE *)(v54 + 0xE2)
                   && *(_BYTE *)(v54 + 0xE1) != 1;
                v56 = _InterlockedDecrement((volatile signed __int32 *)(v54 + 0xC4));
                if ( !(_WORD)v56 && (v56 & 0xFF000000) != 0 )
                  qword_149C78FD8(v54 + 0xC4);
                if ( !v55 )
                  goto LABEL_61;
                if ( !v65 )
                  goto LABEL_60;
                if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v71 + 8), -v65) == v65 )
                {
                  sub_1475F8FE0(v68, v72, a2);
                  v55 = 0;
                  *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE30LL) = v74;
                }
                v65 = 0;
                if ( v55 )
                {
LABEL_60:
                  v78 = __rdtsc();
                  qword_149C89AA8(v75);
                  v36 = v68;
                  v57 = v73;
                  v58 = v68;
                  v16[0x1C6] = 0;
                  v16[0x1C7] = v53;
                  sub_1475F3500(v53, a2, v57, v58, a5, 0);
                  v75[0] = 0;
                  *(_QWORD *)&v75[1] = 1;
                  v76 = 0;
                  v16[0x1C7] = v72;
                  v78 = 0;
                  v79 = 0;
                  v80 = 0;
                  v67 = *(_WORD *)(v81 + 0x9E);
                  v77 = __rdtsc();
                  BYTE1(v75[0]) = *(_BYTE *)(v81 + 0xA0);
                  qword_149C89AA0(v75, &v67, &p_Src, &p_Src, 0);
                  HIWORD(v75[0]) = v67;
                  v16[0x1C6] = v74;
                }
                else
                {
LABEL_61:
                  v36 = v68;
                }
                v52 += 2;
                --n8_1;
              }
              while ( n8_1 );
              v14 = v65;
            }
            v27 = v71;
            v26 = v69;
            v28 = __rdtsc();
          }
        }
      }
      v29 = _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 4), v70);
      v24 = v82;
      v30 = v29 - v26;
      v31 = v29 - v26;
    }
    while ( v29 > 0 );
    v25 = v72;
  }
  v16[0x1C9] = v84;
  qword_149C89AE0("Jobs Executed %d", v14);
  sub_1404D5120();
  v78 = __rdtsc();
  qword_149C89AA8(v75);
  v16[0x1C7] = 0;
  if ( v14 && _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 8), -v14) == v14 )
  {
    v59 = v25;
    v60 = v68;
    sub_1475F8FE0(v68, v59, a2);
  }
  else
  {
    v60 = v68;
    v16[0x1C6] = 0;
  }
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)v27, 0xFFFFFFFF) == 1 )
    sub_1403E79B0((volatile signed __int64 *)(v60 + 0x20), (_QWORD *)v27);
  return 1;
}

// --- End Function: sub_1475F3500 (0x1475F37E3) ---

// --- Function: sub_1475F6510 (0x1475F6510) ---
__int64 sub_1475F6510()
{
  __int64 v0; // rax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return v0 + 0x42;
  else
    return NtCurrentTeb_w() + 0x12E;
}

// --- End Function: sub_1475F6510 (0x1475F6510) ---

// --- Function: sub_1475F6540 (0x1475F6540) ---
__int64 sub_1475F6540()
{
  return qword_151752480;
}

// --- End Function: sub_1475F6540 (0x1475F6540) ---

// --- Function: sub_1475F6800 (0x1475F6800) ---
unsigned __int64 __fastcall sub_1475F6800(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned int a4)
{
  unsigned __int64 result; // rax
  unsigned __int32 v5; // [rsp+20h] [rbp-88h] BYREF
  unsigned __int32 v6; // [rsp+24h] [rbp-84h]
  unsigned __int32 v7; // [rsp+28h] [rbp-80h] BYREF
  unsigned int *src; // [rsp+30h] [rbp-78h]
  unsigned __int32 v9; // [rsp+38h] [rbp-70h]
  unsigned int *v10; // [rsp+40h] [rbp-68h]
  __int64 v11; // [rsp+50h] [rbp-58h]
  _BYTE dst_[24]; // [rsp+58h] [rbp-50h] BYREF
  _BYTE dst__1[24]; // [rsp+70h] [rbp-38h] BYREF

  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 0x1E8038) + 8LL * a4);
  src = (unsigned int *)(0x18 * (a2 % 0x1000) + v11);
  qmemcpy(dst_, src, sizeof(dst_));
  v10 = src + 2;
  v5 = sub_14030B7B0(src + 2);
  while ( 1 )
  {
    result = v5 >> 8;
    if ( result > a3 )
      break;
    if ( v5 >> 8 == a3 )
    {
      v6 = (unsigned __int8)(v5 + 1) | v5 & 0xFFFFFF00;
      v7 = InterlockedCompareExchange_w((volatile signed __int32 *)v10, v6, v5);
      if ( !sub_1475EBB00(&v7, &v5) )
      {
        qmemcpy(dst__1, src, sizeof(dst__1));
        return sub_147609F80(src + 4);
      }
      v5 = v7;
    }
    else
    {
      _mm_pause();
      v9 = sub_14030B7B0(v10);
      v5 = v9;
    }
  }
  return result;
}

// --- End Function: sub_1475F6800 (0x1475F6800) ---

// --- Function: sub_1475F8550 (0x1475F8550) ---
_BOOL8 __fastcall sub_1475F8550(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rbx
  int v5; // edi
  unsigned int v6; // eax
  int v7; // ecx
  bool v8; // di
  unsigned __int32 v9; // eax

  v3 = a1 + 0x1E8040;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v5 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v6 )
      sub_1403C6E80(v3, v6, (__int64)"CBatchWorkerManager::IsBarrierDone", 1);
    else
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v3 + 0x10) = v5;
  }
  v7 = *(_DWORD *)(v3 + 0x14);
  v8 = a2 <= *(_QWORD *)(a1 + 0x1E8058);
  if ( v7 )
  {
    *(_DWORD *)(v3 + 0x14) = v7 - 1;
  }
  else
  {
    *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 0, 1);
    if ( v9 == 1 )
      *(_QWORD *)(v3 + 8) = &p_Src;
    else
      sub_1403DF590(v3, v9);
  }
  return v8;
}

// --- End Function: sub_1475F8550 (0x1475F8550) ---

// --- Function: sub_1475F8620 (0x1475F8620) ---
bool __fastcall sub_1475F8620(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  int v4; // ebp
  __int64 v5; // rsi
  signed __int32 v6; // r8d

  v3 = a1 + 0x1E8 * (a2 & 0xFFF);
  sub_1475FF440(a1, v3 + 0x30);
  v4 = *(_DWORD *)(v3 + 0xC0);
  v5 = *(_QWORD *)(v3 + 0x30);
  v6 = _InterlockedDecrement((volatile signed __int32 *)(v3 + 0xC4));
  if ( !(_WORD)v6 && (v6 & 0xFF000000) != 0 )
    qword_149C78FD8(v3 + 0xC4);
  return !v4 || v5 != a2;
}

// --- End Function: sub_1475F8620 (0x1475F8620) ---

// --- Function: sub_1475F88D0 (0x1475F88D0) ---
const ULONG_PTR *__fastcall sub_1475F88D0(_QWORD *a1, int a2, __int64 a3)
{
  __int64 v3; // rsi
  int v4; // r12d
  _QWORD *v5; // r13
  __int64 v6; // r8
  unsigned __int64 v7; // rax
  const ULONG_PTR *p_p_Src; // rax
  unsigned __int64 v9; // rdx
  __int64 v10; // r8
  unsigned __int64 v11; // r9
  const ULONG_PTR *p_p_Src_2; // rcx
  _QWORD *epi64; // r15
  __int64 *v14; // rbx
  ULONG_PTR p_Src; // rdi
  unsigned __int64 v16; // r11
  unsigned __int64 v17; // r14
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rsi
  unsigned __int64 v20; // r8
  __int64 v23; // rcx
  __int64 v27; // r10
  __int64 v28; // rcx
  __int64 v29; // rcx
  __int64 v32; // rdx
  __int64 v33; // r8
  _QWORD *v34; // rsi
  _OWORD *v35; // rcx
  __int128 v36; // xmm0
  __int64 v37; // rcx
  __int64 v38; // r14
  __int64 v39; // r15
  _OWORD *v40; // r8
  _OWORD *v41; // rdx
  _OWORD *i; // rcx
  __int64 v43; // rcx
  _OWORD *v44; // r12
  void *v45; // rsi
  char *v46; // rdi
  signed __int64 v47; // r14
  unsigned __int64 v48; // r12
  unsigned __int64 v49; // rcx
  unsigned __int64 v50; // rdx
  __int64 v51; // rax
  __int64 v52; // r13
  char *v53; // r15
  char *v54; // rcx
  const void *v55; // rdx
  char *Size; // r8
  char *v57; // rax
  char *j; // rbx
  unsigned __int64 n0x200000; // rax
  __int64 v60; // [rsp+20h] [rbp-B9h]
  int v61; // [rsp+28h] [rbp-B1h]
  void *Src[2]; // [rsp+40h] [rbp-99h] BYREF
  char *v63; // [rsp+50h] [rbp-89h]
  _QWORD *v64; // [rsp+58h] [rbp-81h]
  const ULONG_PTR *p_p_Src_1; // [rsp+60h] [rbp-79h]
  const ULONG_PTR *p_p_Src_4; // [rsp+68h] [rbp-71h]
  __int64 v67; // [rsp+70h] [rbp-69h]
  ULONG_PTR *p_p_Src_3; // [rsp+78h] [rbp-61h] BYREF
  __int128 *v69; // [rsp+80h] [rbp-59h] BYREF
  __int128 v70; // [rsp+88h] [rbp-51h]
  __int64 v71; // [rsp+98h] [rbp-41h] BYREF
  _QWORD *v72; // [rsp+A0h] [rbp-39h]
  ULONG_PTR p_Src_1; // [rsp+A8h] [rbp-31h] BYREF
  __int128 v74; // [rsp+B0h] [rbp-29h] BYREF
  __int64 v75; // [rsp+C0h] [rbp-19h]
  __int64 v76; // [rsp+C8h] [rbp-11h]
  __int64 v77; // [rsp+D0h] [rbp-9h]
  __m128i v78; // [rsp+D8h] [rbp-1h] BYREF
  __int64 v81; // [rsp+150h] [rbp+77h] BYREF
  int v82; // [rsp+158h] [rbp+7Fh]

  v81 = a3;
  v3 = (__int64)(a1 + 0x40014);
  *(_OWORD *)Src = 0;
  v63 = 0;
  v4 = a2;
  v67 = (__int64)(a1 + 0x40014);
  v5 = a1;
  v6 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
  v7 = _InterlockedCompareExchange64((volatile signed __int64 *)v3, 0x200000, 0);
  if ( v7 )
    sub_1403E1120(v3, v7, v6, "CBatchWorkerManager::NotifyBatchLockWaiter", "m_BatchLockMapLock", 1);
  else
    *(_QWORD *)(v3 + 8) = v6;
  p_p_Src = (const ULONG_PTR *)sub_1475E8870(v5 + 0x4001D, &v71, &v81);
  if ( v71 == v5[0x4001D] + v5[0x40020] )
    goto LABEL_52;
  p_p_Src = *(const ULONG_PTR **)(*v72 + 8LL);
  p_p_Src_2 = *(const ULONG_PTR **)(*v72 + 0x10LL);
  p_p_Src_1 = p_p_Src;
  p_p_Src_4 = p_p_Src_2;
  if ( p_p_Src == p_p_Src_2 )
  {
    v46 = (char *)Src[1];
    goto LABEL_50;
  }
  epi64 = v72;
  v14 = v5 + 0x40016;
  v64 = v72;
  do
  {
    p_Src = *p_p_Src;
    v16 = v14[3];
    v17 = 0x100000001B3LL
        * (HIBYTE(*p_p_Src)
         ^ (0x100000001B3LL
          * ((unsigned __int8)BYTE6(*p_p_Src)
           ^ (0x100000001B3LL
            * ((unsigned __int8)((unsigned __int16)WORD2(*p_p_Src) >> 8)
             ^ (0x100000001B3LL
              * ((unsigned __int8)BYTE4(*p_p_Src)
               ^ (0x100000001B3LL
                * (BYTE3(*p_p_Src)
                 ^ (0x100000001B3LL
                  * ((unsigned __int8)BYTE2(*p_p_Src)
                   ^ (0x100000001B3LL
                    * ((0x100000001B3LL * ((unsigned __int8)*p_p_Src ^ 0xCBF29CE484222325uLL))
                     ^ (unsigned __int8)BYTE1(*p_p_Src))))))))))))));
    v76 = (v17 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40;
    v18 = (__PAIR128__(v17, v17) * 0xDE5FB9D2630458E9uLL) >> 0x40;
    v19 = 0;
    v20 = v16 & (v18 >> 7);
    _XMM2 = v18 & 0x7F;
    __asm { vpshufb xmm2, xmm2, xmm0 }
    while ( 1 )
    {
      v23 = *v14;
      _XMM1 = *(_OWORD *)(*v14 + v20);
      __asm
      {
        vpcmpeqb xmm0, xmm2, xmm1
        vpmovmskb eax, xmm0
      }
      if ( _EAX )
        break;
LABEL_13:
      __asm
      {
        vpcmpeqb xmm1, xmm1, cs:xmmword_1482B5BB0
        vpmovmskb eax, xmm1
      }
      if ( _EAX )
      {
        v32 = v23;
        v33 = v23 + v16;
        goto LABEL_18;
      }
      v19 += 0x10LL;
      v20 = v16 & (v19 + v20);
      if ( v19 > v16 )
        __debugbreak();
    }
    v27 = v14[1];
    while ( 1 )
    {
      _BitScanForward((unsigned int *)&v28, _EAX);
      v82 = v28;
      v29 = v16 & (v20 + v28);
      if ( **(_QWORD **)(v27 + 8 * v29) == p_Src )
        break;
      _EAX &= _EAX - 1;
      if ( !_EAX )
      {
        v23 = *v14;
        goto LABEL_13;
      }
    }
    v32 = *v14;
    epi64 = (_QWORD *)(v27 + 8 * v29);
    v64 = epi64;
    v33 = v32 + v29;
LABEL_18:
    if ( v33 == v32 + v5[0x40019] )
    {
      p_Src_1 = p_Src;
      p_p_Src_3 = &p_Src_1;
      v75 = 0;
      v69 = &v74;
      v74 = 0;
      v77 = (v17 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40;
      sub_1475E84D0(
        (_DWORD)v14,
        (unsigned int)&v78,
        (unsigned int)&p_Src_1,
        (__PAIR128__(v17, v17) * 0xDE5FB9D2630458E9uLL) >> 0x40,
        (unsigned int)&byte_1482B5141,
        (__int64)&p_p_Src_3,
        (__int64)&v69);
      if ( (_QWORD)v74 )
        sub_1402A6590(v74);
      epi64 = (_QWORD *)_mm_extract_epi64(v78, 1);
      v64 = epi64;
    }
    v34 = (_QWORD *)*epi64;
    LODWORD(v70) = v4;
    *((_QWORD *)&v70 + 1) = v81;
    v35 = (_OWORD *)v34[2];
    if ( (unsigned __int64)v35 < v34[3] )
    {
      v36 = v70;
      v34[2] = v35 + 1;
      *v35 = v36;
      goto LABEL_34;
    }
    v37 = ((__int64)v35 - v34[1]) >> 4;
    if ( !v37 )
    {
      v38 = 1;
LABEL_28:
      v61 = 0;
      v60 = 0;
      v39 = sub_1402A65A0(0x10 * v38);
      goto LABEL_29;
    }
    v38 = 2 * v37;
    if ( 2 * v37 )
      goto LABEL_28;
    v39 = 0;
LABEL_29:
    v40 = (_OWORD *)v34[2];
    v41 = (_OWORD *)v39;
    for ( i = (_OWORD *)v34[1]; i != v40; ++i )
      *v41++ = *i;
    *v41 = v70;
    v43 = v34[1];
    v44 = v41 + 1;
    if ( v43 )
      sub_1402A6590(v43);
    v34[1] = v39;
    v34[3] = v39 + 0x10 * v38;
    v34[2] = v44;
LABEL_34:
    v45 = Src[1];
    if ( Src[1] == v63 )
    {
      v47 = ((char *)Src[1] - (char *)Src[0]) >> 3;
      if ( v47 == 0x1FFFFFFFFFFFFFFFLL )
        unknown_libname_10();
      v48 = v47 + 1;
      v49 = (v63 - (char *)Src[0]) >> 3;
      v50 = v49 >> 1;
      if ( v49 <= 0x1FFFFFFFFFFFFFFFLL - (v49 >> 1) )
      {
        v51 = v49 + v50;
        if ( v49 + v50 < v48 )
          v51 = v47 + 1;
      }
      else
      {
        v51 = 0x1FFFFFFFFFFFFFFFLL;
      }
      v52 = 8 * v51;
      v53 = (char *)sub_140394E70((__int64)Src, 8 * v51);
      v54 = v53;
      *(_QWORD *)&v53[8 * v47] = p_Src;
      v55 = Src[0];
      if ( v45 == Src[1] )
      {
        Size = (char *)((char *)Src[1] - (char *)Src[0]);
      }
      else
      {
        memmove(v53, Src[0], (size_t)v45 - (unsigned __int64)Src[0]);
        v54 = &v53[8 * v47 + 8];
        Size = (char *)((char *)Src[1] - (char *)v45);
        v55 = v45;
      }
      memmove(v54, v55, (size_t)Size);
      if ( Src[0] )
        sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], (v63 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
      v57 = &v53[v52];
      Src[0] = v53;
      v5 = a1;
      v46 = &v53[8 * v48];
      v63 = v57;
    }
    else
    {
      *(_QWORD *)Src[1] = p_Src;
      v46 = (char *)Src[1] + 8;
    }
    v9 = 0xDE5FB9D2630458E9uLL;
    epi64 = v64;
    p_p_Src = p_p_Src_1 + 1;
    v10 = 0x100000001B3LL;
    v4 = a2;
    v11 = 0xCBF29CE484222325uLL;
    Src[1] = v46;
    p_p_Src_1 = p_p_Src;
  }
  while ( p_p_Src != p_p_Src_4 );
  v3 = v67;
LABEL_50:
  for ( j = (char *)Src[0]; j != v46; j += 8 )
    p_p_Src = (const ULONG_PTR *)sub_1403C8400(*(_QWORD *)j, v9, v10, v11, v60, v61);
LABEL_52:
  if ( v3 )
  {
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v3, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      p_p_Src = &::p_Src;
      *(_QWORD *)(v3 + 8) = &::p_Src;
    }
    else
    {
      p_p_Src = rw_lock_handle_write_release_contention(v3, n0x200000);
    }
  }
  if ( Src[0] )
    return (const ULONG_PTR *)sub_1403A6820(
                                (__int64)Src,
                                (unsigned __int64)Src[0],
                                (v63 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
  return p_p_Src;
}

// --- End Function: sub_1475F88D0 (0x1475F88D0) ---

// --- Function: sub_1475F8E60 (0x1475F8E60) ---
char __fastcall sub_1475F8E60(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 (__fastcall *v7)(_QWORD); // r8
  int v8; // edi
  _QWORD *v9; // r14
  bool v10; // zf
  int v11; // eax
  __int64 v12; // r8

  if ( !*(_DWORD *)(a2 + 0x90)
    || *(_QWORD *)(a2 + 0x70) != 0xFFFFFFFFFFFFFFFFuLL
    || *(_WORD *)(a2 + 0x9C)
    || *(_BYTE *)(a2 + 0xB4) )
  {
    return 0;
  }
  *(_BYTE *)(a2 + 0xB4) = 1;
  sub_1476073D0(a1, *(_QWORD *)(a2 + 0xA8));
  if ( *(_DWORD *)(a2 + 0x90) == 1 )
    return 1;
  v7 = *(__int64 (__fastcall **)(_QWORD))(a2 + 0x10);
  v8 = 0;
  *(_DWORD *)(a2 + 0x98) = 0;
  if ( v7 )
  {
    v9 = (_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE50LL);
    v10 = *(_QWORD *)(a2 + 0x18) == 1;
    *v9 = *(_QWORD *)a2;
    if ( v10 )
      v11 = v7(a3);
    else
      v11 = ((__int64 (__fastcall *)(__int64, _QWORD))v7)(a2 + 0x10, a3);
    *v9 = 0;
    v8 = v11;
    *(_DWORD *)(a2 + 0x98) = v11;
  }
  *(_DWORD *)(a2 + 0x90) = 1;
  if ( v8 )
  {
    *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4LL) = v8;
    *(_DWORD *)(*(_QWORD *)(a2 + 8) + 8LL) = *(_DWORD *)(a2 + 0x98);
    return 1;
  }
  else
  {
    *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE30LL) = *(_QWORD *)(a2 + 0xA8);
    sub_1403E79B0((volatile signed __int64 *)(a1 + 0x20), *(_QWORD **)(a2 + 8));
    LOBYTE(v12) = 1;
    sub_1475F91B0(a1, *(_QWORD *)a2, v12, a3);
    return 0;
  }
}

// --- End Function: sub_1475F8E60 (0x1475F8E60) ---

// --- Function: sub_1475F8FE0 (0x1475F8FE0) ---
__int64 __fastcall sub_1475F8FE0(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  unsigned int v3; // ebx
  __int64 v7; // r15
  volatile signed __int32 *v8; // rdi
  unsigned int i; // eax
  unsigned int v10; // esi
  unsigned __int64 v11; // r9
  volatile signed __int64 *v12; // rcx
  signed __int64 v13; // rdx
  signed __int64 v14; // rax
  int n0x1D00; // [rsp+30h] [rbp-78h] BYREF
  __int64 v17; // [rsp+34h] [rbp-74h]
  int v18; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v19; // [rsp+40h] [rbp-68h]
  unsigned __int64 v20; // [rsp+48h] [rbp-60h]
  __int64 v21; // [rsp+50h] [rbp-58h]
  __int64 v22; // [rsp+58h] [rbp-50h]
  unsigned int v23; // [rsp+B0h] [rbp+8h] BYREF

  v3 = 0;
  n0x1D00 = 0x1D00;
  v18 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v17 = 1;
  v19 = __rdtsc();
  qword_149C89AA0(
    &n0x1D00,
    &word_151752594,
    "CBatchWorkerManager::OnBatchDone",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\JobManager/BatchWorker.cpp",
    0x424);
  HIWORD(n0x1D00) = word_151752594;
  v7 = a1 + 0x1E8 * (a2 & 0xFFF);
  v8 = (volatile signed __int32 *)(v7 + 0xE8);
  i = _InterlockedExchange((volatile __int32 *)(v7 + 0xE8), 0);
  if ( !i )
  {
    for ( i = _InterlockedCompareExchange(v8, 0x80000000, 0); (i & 0x7FFFFFFF) == 0; i = *v8 )
    {
      v23 = 0x80000000;
      qword_149C78FC8(v7 + 0xE8, &v23, 4, 0xFFFFFFFFLL);
    }
  }
  v10 = __popcnt(i);
  if ( i )
  {
    do
    {
      v11 = (unsigned __int64)*(unsigned int *)(v7 + 4LL * v3 + 0xEC) >> 0xC;
      v12 = (volatile signed __int64 *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x1E8038) + 8LL * v3)
                                      + 0x18LL * (*(_DWORD *)(v7 + 4LL * v3 + 0xEC) & 0xFFF));
      v13 = (v11 + 1) | 0x7FFFFFFFFE000000LL;
      v14 = _InterlockedCompareExchange64(v12, v13, ((a2 & 0x3FFFFFFFFFLL) << 0x19) | v11 & 0xFFFFFF | 0x1000000);
      if ( v14 < 0 )
      {
        _InterlockedCompareExchange64(v12, v13, v14);
        qword_149C78FD8(v12);
      }
      ++v3;
    }
    while ( v3 != v10 );
  }
  sub_1475F91B0(a1, a2, 0, a3);
  v20 = __rdtsc();
  return qword_149C89AA8(&n0x1D00);
}

// --- End Function: sub_1475F8FE0 (0x1475F8FE0) ---

// --- Function: sub_1475F91B0 (0x1475F91B0) ---
__int64 __fastcall sub_1475F91B0(__int64 a1, unsigned __int64 a2, char a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // r12
  __int16 v6; // bx
  __int64 v8; // rbx
  void (*v9)(void); // rax
  void (__fastcall *n2)(__int64, __int64); // rax
  void (__fastcall *n2_1)(__int64, __int64); // rax
  void (__fastcall *n2_2)(__int64, __int64); // rax
  __int64 v13; // rcx
  const void *v14; // rdx
  __int64 v15; // rdi
  size_t Size; // r8
  __int64 v17; // rax
  void *v18; // rsp
  __int64 v19; // rsi
  volatile signed __int32 *v20; // rbx
  signed __int32 n0x10000; // eax
  signed __int32 n0x10000_3; // edx
  signed __int32 n0x10000_4; // eax
  signed __int32 n0x10000_9; // r8d
  unsigned __int64 v25; // r14
  unsigned __int64 i; // rdi
  __int64 v27; // rbx
  char v28; // si
  volatile signed __int32 *v29; // r9
  signed __int32 n0x10000_1; // eax
  signed __int32 n0x10000_5; // edx
  signed __int32 n0x10000_6; // eax
  signed __int32 n0x10000_10; // r8d
  volatile signed __int32 *v34; // rbx
  int v35; // edi
  unsigned int v36; // eax
  __int64 **v37; // rsi
  unsigned __int64 v38; // r8
  __int64 v39; // r11
  __int64 *v40; // rdi
  __int64 v41; // rcx
  char *v42; // rdi
  char *v43; // rsi
  __int64 v44; // rcx
  __int64 v45; // rdx
  __int64 *v46; // rax
  __int64 *v47; // r15
  __int64 v48; // r12
  __int64 v49; // r14
  unsigned __int64 v50; // rcx
  unsigned __int64 v51; // rdx
  __int64 v52; // rax
  char *v53; // rcx
  char *v54; // rdx
  char *Size_1; // r8
  int v57; // eax
  unsigned __int32 v58; // eax
  __int64 v59; // rbx
  char v60; // r14
  volatile signed __int32 *v61; // r9
  signed __int32 n0x10000_2; // eax
  signed __int32 n0x10000_7; // edx
  signed __int32 n0x10000_8; // eax
  signed __int32 n0x10000_11; // r8d
  __int64 v66; // rdi
  unsigned __int64 v67; // rbx
  _BYTE v69[8]; // [rsp+30h] [rbp+0h] BYREF
  void *Src[2]; // [rsp+38h] [rbp+8h] BYREF
  char *v71; // [rsp+48h] [rbp+18h]
  __int128 v72; // [rsp+50h] [rbp+20h] BYREF
  __int64 v73; // [rsp+60h] [rbp+30h]
  __int64 v74; // [rsp+68h] [rbp+38h]
  __int64 *v75; // [rsp+70h] [rbp+40h]
  __int64 v76; // [rsp+78h] [rbp+48h]
  int n0x1D00; // [rsp+80h] [rbp+50h] BYREF
  __int64 v78; // [rsp+84h] [rbp+54h]
  int v79; // [rsp+8Ch] [rbp+5Ch]
  unsigned __int64 v80; // [rsp+90h] [rbp+60h]
  unsigned __int64 v81; // [rsp+98h] [rbp+68h]
  __int64 v82; // [rsp+A0h] [rbp+70h]
  __int64 v83; // [rsp+A8h] [rbp+78h]
  _QWORD v84[3]; // [rsp+D0h] [rbp+A0h] BYREF
  char v85[24]; // [rsp+E8h] [rbp+B8h] BYREF
  unsigned __int64 v86; // [rsp+148h] [rbp+118h] BYREF

  v86 = a2;
  v69[0] = a4;
  v79 = 0;
  v4 = a4;
  v81 = 0;
  v82 = 0;
  v6 = a2;
  v83 = 0;
  n0x1D00 = 0x1D00;
  v78 = 1;
  v80 = __rdtsc();
  qword_149C89AA0(
    &n0x1D00,
    &word_151752598,
    "CBatchWorkerManager::OnBatchDone_MarkBatchAsDone",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\JobManager/BatchWorker.cpp",
    0x45C);
  HIWORD(n0x1D00) = word_151752598;
  v8 = a1 + 0x1E8LL * (v6 & 0xFFF);
  v9 = *(void (**)(void))(v8 + 0x70);
  if ( v9 )
  {
    if ( *(_QWORD *)(v8 + 0x78) == 1 )
      v9();
    else
      ((void (__fastcall *)(__int64))v9)(v8 + 0x70);
  }
  n2 = *(void (__fastcall **)(__int64, __int64))(v8 + 0x48);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, v8 + 0x40);
    *(_QWORD *)(v8 + 0x48) = 0;
  }
  *(_QWORD *)(v8 + 0x40) = 0;
  n2_1 = *(void (__fastcall **)(__int64, __int64))(v8 + 0x60);
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, v8 + 0x58);
    *(_QWORD *)(v8 + 0x60) = 0;
  }
  *(_QWORD *)(v8 + 0x58) = 0;
  n2_2 = *(void (__fastcall **)(__int64, __int64))(v8 + 0x78);
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, v8 + 0x70);
    *(_QWORD *)(v8 + 0x78) = 0;
  }
  *(_QWORD *)(v8 + 0x70) = 0;
  sub_147607320(a1, *(_QWORD *)(v8 + 0xD8));
  *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE30LL) = 0;
  if ( !a3 )
    sub_147608AD0(a1, v8 + 0x30);
  *(_QWORD *)(v8 + 0x38) = 0;
  v13 = *(_QWORD *)(v8 + 0x88);
  if ( (*(_QWORD *)(v8 + 0x90) - v13) >> 3 )
    *(_QWORD *)(v8 + 0x90) = v13;
  v14 = *(const void **)(v8 + 0xA8);
  v15 = (__int64)(*(_QWORD *)(v8 + 0xB0) - (_QWORD)v14) >> 3;
  Size = (unsigned int)(8 * v15);
  v17 = Size + 0xF;
  if ( Size + 0xF <= Size )
    v17 = 0xFFFFFFFFFFFFFF0LL;
  v18 = alloca(v17 & 0xFFFFFFFFFFFFFFF0uLL);
  memcpy(v69, v14, Size);
  std::vector<float *>::resize((__int64 *)(v8 + 0xA8), 0);
  v19 = v8 + 0xC0;
  *(_DWORD *)(v8 + 0xC0) = 0;
  if ( !a3 )
  {
    v20 = (volatile signed __int32 *)(v8 + 0xC4);
    n0x10000 = _InterlockedCompareExchange(v20, 0, 0x10000);
    n0x10000_3 = n0x10000;
    if ( n0x10000 != 0x10000 )
    {
      n0x10000_4 = _InterlockedCompareExchange(v20, n0x10000 & 0xFF00FFFF, n0x10000);
      if ( n0x10000_3 != n0x10000_4 )
      {
        do
        {
          n0x10000_9 = n0x10000_4;
          n0x10000_4 = _InterlockedCompareExchange(v20, n0x10000_4 & 0xFF00FFFF, n0x10000_4);
        }
        while ( n0x10000_9 != n0x10000_4 );
      }
      qword_149C78FD8(v20);
    }
  }
  qword_149C78FD8(v19);
  v73 = 0;
  v72 = 0;
  v25 = (unsigned int)v15;
  sub_140507C10((__int64)&v72, (unsigned int)v15);
  for ( i = 0; i < v25; ++i )
  {
    v27 = *(_QWORD *)&v69[8 * i];
    sub_147608AD0(a1, v27);
    _InterlockedDecrement16((volatile signed __int16 *)(v27 + 0x9C));
    v28 = sub_1475F8E60(a1, v27, v4);
    v29 = (volatile signed __int32 *)(v27 + 0x94);
    n0x10000_1 = _InterlockedCompareExchange((volatile signed __int32 *)(v27 + 0x94), 0, 0x10000);
    n0x10000_5 = n0x10000_1;
    if ( n0x10000_1 != 0x10000 )
    {
      n0x10000_6 = _InterlockedCompareExchange(v29, n0x10000_1 & 0xFF00FFFF, n0x10000_1);
      if ( n0x10000_5 != n0x10000_6 )
      {
        do
        {
          n0x10000_10 = n0x10000_6;
          n0x10000_6 = _InterlockedCompareExchange(v29, n0x10000_6 & 0xFF00FFFF, n0x10000_6);
        }
        while ( n0x10000_10 != n0x10000_6 );
      }
      qword_149C78FD8(v27 + 0x94);
    }
    if ( v28 )
      sub_1475FD330(
        a1,
        *(_QWORD *)v27,
        *(_DWORD *)(v27 + 0x98) / (unsigned int)*(unsigned __int8 *)(v27 + 0xB0) + 1,
        &v72);
  }
  v34 = (volatile signed __int32 *)(a1 + 0x1E8040);
  *(_OWORD *)Src = 0;
  v71 = 0;
  v35 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x1E8050) == v35 )
  {
    ++*(_DWORD *)(a1 + 0x1E8054);
  }
  else
  {
    v36 = _InterlockedCompareExchange(v34, 1, 0);
    if ( v36 )
      sub_1403C6E80(a1 + 0x1E8040, v36, (__int64)"CBatchWorkerManager::OnBatchDone_MarkBatchAsDone", 1);
    else
      *(_QWORD *)(a1 + 0x1E8048) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x1E8050) = v35;
  }
  v37 = (__int64 **)(a1 + 0x200060);
  v38 = *(_QWORD *)(a1 + 0x200080);
  v39 = *(_QWORD *)(a1 + 0x200078);
  if ( a1 == 0xFFFFFFFFFFDFFFA0uLL )
  {
    v40 = 0;
  }
  else
  {
    v40 = *v37;
    if ( *v37 )
    {
      v41 = *v40;
      goto LABEL_41;
    }
  }
  v41 = 0;
LABEL_41:
  while ( (__int64)v38 > 0 )
  {
    if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v41 + 8) + 8
                                                      * ((*(_QWORD *)(v41 + 0x10) - 1LL) & (((v38 >> 1) + v39) >> 1)))
                   + 8LL * (((unsigned __int8)(v38 >> 1) + (_BYTE)v39) & 1)) >= v86 )
    {
      v38 >>= 1;
    }
    else
    {
      v39 += (v38 >> 1) + 1;
      v38 += 0xFFFFFFFFFFFFFFFFuLL - (v38 >> 1);
    }
  }
  v84[1] = 0;
  v84[0] = v40;
  v84[2] = v39;
  sub_147609D40(a1 + 0x200060, v85, v84, &v86);
  v42 = (char *)Src[1];
  v43 = (char *)Src[0];
  if ( *(_QWORD *)(a1 + 0x200080) )
  {
    while ( 1 )
    {
      v44 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x200068)
                                  + 8 * ((*(_QWORD *)(a1 + 0x200070) - 1LL) & (*(_QWORD *)(a1 + 0x200078) >> 1)))
                      + 8 * (*(_QWORD *)(a1 + 0x200078) & 1LL));
      if ( *(_QWORD *)(a1 + 0x1E8058) + 1LL != v44 )
        break;
      v45 = a1 + 8 * ((v44 & 0xFFF) + 2 * ((v44 & 0xFFF) + 0x1E806));
      v76 = v45;
      v46 = *(__int64 **)(v45 + 8);
      v47 = *(__int64 **)v45;
      v75 = v46;
      if ( v47 != v46 )
      {
        do
        {
          v48 = *v47;
          if ( v42 == v71 )
          {
            v49 = (v42 - v43) >> 3;
            if ( v49 == 0x1FFFFFFFFFFFFFFFLL )
              unknown_libname_10();
            v50 = (v71 - v43) >> 3;
            v51 = v50 >> 1;
            if ( v50 <= 0x1FFFFFFFFFFFFFFFLL - (v50 >> 1) )
            {
              v52 = v51 + v50;
              if ( v51 + v50 < v49 + 1 )
                v52 = v49 + 1;
            }
            else
            {
              v52 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v74 = 8 * v52;
            v43 = (char *)sub_140394E70((__int64)Src, 8 * v52);
            v53 = v43;
            *(_QWORD *)&v43[8 * v49] = v48;
            v54 = (char *)Src[0];
            if ( v42 == Src[1] )
            {
              Size_1 = (char *)((char *)Src[1] - (char *)Src[0]);
            }
            else
            {
              memmove(v43, Src[0], v42 - (char *)Src[0]);
              v53 = &v43[8 * v49 + 8];
              Size_1 = (char *)((char *)Src[1] - (char *)v42);
              v54 = v42;
            }
            memmove(v53, v54, (size_t)Size_1);
            if ( Src[0] )
              sub_1403A6820((__int64)Src, (unsigned __int64)Src[0], (v71 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
            Src[0] = v43;
            v71 = &v43[v74];
            v42 = &v43[8 * v49 + 8];
            v46 = v75;
          }
          else
          {
            *(_QWORD *)v42 = v48;
            v43 = (char *)Src[0];
            v42 = (char *)Src[1] + 8;
          }
          ++v47;
          Src[1] = v42;
        }
        while ( v47 != v46 );
        v45 = v76;
      }
      if ( (__int64)(*(_QWORD *)(v45 + 8) - *(_QWORD *)v45) >> 3 )
      {
        *(_QWORD *)(v45 + 8) = *(_QWORD *)v45;
        v42 = (char *)Src[1];
        v43 = (char *)Src[0];
      }
      if ( (*(_QWORD *)(a1 + 0x200080))-- == 1 )
      {
        *(_QWORD *)(a1 + 0x200078) = 0;
        ++*(_QWORD *)(a1 + 0x1E8058);
        break;
      }
      ++*(_QWORD *)(a1 + 0x200078);
      ++*(_QWORD *)(a1 + 0x1E8058);
    }
    v4 = v69[0];
  }
  v57 = *(_DWORD *)(a1 + 0x1E8054);
  if ( v57 )
  {
    *(_DWORD *)(a1 + 0x1E8054) = v57 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x1E8050) = 0xFFFFFFFF;
    v58 = _InterlockedCompareExchange(v34, 0, 1);
    if ( v58 == 1 )
      *(_QWORD *)(a1 + 0x1E8048) = &p_Src;
    else
      sub_1403DF590(a1 + 0x1E8040, v58);
    v43 = (char *)Src[0];
    v42 = (char *)Src[1];
  }
  if ( v43 != v42 )
  {
    do
    {
      v59 = *(_QWORD *)v43;
      sub_147608AD0(a1, *(_QWORD *)v43);
      *(_QWORD *)(v59 + 0x70) = 0xFFFFFFFFFFFFFFFFuLL;
      v60 = sub_1475F8E60(a1, v59, v4);
      v61 = (volatile signed __int32 *)(v59 + 0x94);
      n0x10000_2 = _InterlockedCompareExchange((volatile signed __int32 *)(v59 + 0x94), 0, 0x10000);
      n0x10000_7 = n0x10000_2;
      if ( n0x10000_2 != 0x10000 )
      {
        n0x10000_8 = _InterlockedCompareExchange(v61, n0x10000_2 & 0xFF00FFFF, n0x10000_2);
        if ( n0x10000_7 != n0x10000_8 )
        {
          do
          {
            n0x10000_11 = n0x10000_8;
            n0x10000_8 = _InterlockedCompareExchange(v61, n0x10000_8 & 0xFF00FFFF, n0x10000_8);
          }
          while ( n0x10000_11 != n0x10000_8 );
        }
        qword_149C78FD8(v59 + 0x94);
      }
      if ( v60 )
        sub_1475FD330(
          a1,
          *(_QWORD *)v59,
          *(_DWORD *)(v59 + 0x98) / (unsigned int)*(unsigned __int8 *)(v59 + 0xB0) + 1,
          &v72);
      v43 += 8;
    }
    while ( v43 != v42 );
    v43 = (char *)Src[0];
  }
  v66 = *((_QWORD *)&v72 + 1);
  v67 = v72;
  if ( (_QWORD)v72 != *((_QWORD *)&v72 + 1) )
  {
    do
    {
      if ( *(_QWORD *)v67 )
        qword_149C78FD8(*(_QWORD *)v67);
      else
        ReleaseSemaphore(**(HANDLE **)(v67 + 8), *(_DWORD *)(v67 + 0x10), 0);
      v67 += 0x18LL;
    }
    while ( v67 != v66 );
    v67 = v72;
    v43 = (char *)Src[0];
  }
  if ( v43 )
  {
    sub_1403A6820((__int64)Src, (unsigned __int64)v43, (v71 - v43) & 0xFFFFFFFFFFFFFFF8uLL);
    v67 = v72;
    *(_OWORD *)Src = 0;
    v71 = 0;
  }
  if ( v67 )
  {
    sub_1403A6820((__int64)&v72, v67, 0x18 * ((__int64)(v73 - v67) / 0x18));
    v72 = 0;
    v73 = 0;
  }
  v81 = __rdtsc();
  return qword_149C89AA8(&n0x1D00);
}

// --- End Function: sub_1475F91B0 (0x1475F91B0) ---

// --- Function: sub_1475FD330 (0x1475FD330) ---
__int64 __fastcall sub_1475FD330(__int64 a1, __int64 a2, int a3, unsigned __int64 *a4)
{
  int v4; // ebx
  unsigned __int64 *v5; // rsi
  __int64 v7; // r8
  unsigned int v8; // r9d
  unsigned __int64 v9; // r15
  __int64 v10; // r13
  unsigned __int64 v11; // r12
  unsigned __int64 v12; // rsi
  __int64 v13; // rdi
  signed __int64 v14; // rbx
  signed __int64 v15; // rax
  __int64 v16; // rcx
  signed __int64 v17; // rtt
  bool v18; // zf
  unsigned __int64 v19; // r15
  __int64 v20; // rdi
  signed __int64 v21; // rax
  unsigned __int64 v22; // rdx
  int n0x40; // eax
  unsigned __int64 v24; // rcx
  int n0x40_1; // ecx
  __int64 v26; // rdx
  unsigned int v27; // r10d
  __int64 v28; // r9
  volatile signed __int32 *v29; // rdx
  signed __int32 v30; // eax
  signed __int32 v31; // ett
  int v32; // ecx
  signed __int64 v33; // rtt
  int v34; // eax
  unsigned __int8 lReleaseCount; // al
  HANDLE *v36; // rdi
  int v37; // eax
  int v39; // [rsp+30h] [rbp-D0h]
  int v42; // [rsp+48h] [rbp-B8h] BYREF
  unsigned int v43; // [rsp+4Ch] [rbp-B4h]
  int n0x1600; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v45; // [rsp+54h] [rbp-ACh]
  int v46; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v47; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v48; // [rsp+68h] [rbp-98h]
  __int64 v49; // [rsp+70h] [rbp-90h]
  __int64 v50; // [rsp+78h] [rbp-88h]
  int n0x1D00; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v52; // [rsp+A4h] [rbp-5Ch]
  int v53; // [rsp+ACh] [rbp-54h]
  unsigned __int64 v54; // [rsp+B0h] [rbp-50h]
  unsigned __int64 v55; // [rsp+B8h] [rbp-48h]
  __int64 v56; // [rsp+C0h] [rbp-40h]
  __int64 v57; // [rsp+C8h] [rbp-38h]
  _QWORD v58[2]; // [rsp+F0h] [rbp-10h] BYREF
  int lReleaseCount_1; // [rsp+100h] [rbp+0h]
  _QWORD v60[2]; // [rsp+108h] [rbp+8h] BYREF
  int v61; // [rsp+118h] [rbp+18h]

  v4 = a3;
  v53 = 0;
  v39 = a3;
  v5 = a4;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  n0x1D00 = 0x1D00;
  v52 = 1;
  v54 = __rdtsc();
  qword_149C89AA0(
    &n0x1D00,
    &word_151752588,
    "CBatchWorkerManager::PushIntoReadyQueue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\JobManager/BatchWorker.cpp",
    0x2A7);
  HIWORD(n0x1D00) = word_151752588;
  qword_149C89AF0((unsigned int)v4, &unk_15175258C, "Needed Workers");
  v7 = a2;
  v8 = 0;
  v9 = 0;
  v10 = a1 + 0x1E8 * (a2 & 0xFFF);
  if ( !*(_DWORD *)(a1 + 0x10) )
    goto LABEL_15;
  do
  {
    if ( v4 <= 0 )
      break;
    v11 = _InterlockedExchangeAdd64((volatile signed __int64 *)(*(_QWORD *)(a1 + 0x1E8030) + 8 * v9), 1u);
    v12 = v11 >> 0xC;
    v43 = v8 + 1;
    *(_DWORD *)(v10 + 4LL * v8 + 0xEC) = v11;
    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 0x1E8038) + 8 * v9) + 0x18 * (v11 & 0xFFF);
    v14 = (v11 >> 0xC) & 0xFFFFFF | ((v7 & 0x3FFFFFFFFFLL) << 0x19) | 0x1000000;
    v15 = _InterlockedCompareExchange64(
            (volatile signed __int64 *)v13,
            v14,
            (v11 >> 0xC) & 0xFFFFFF | 0x7FFFFFFFFE000000LL);
    if ( ((v11 >> 0xC) & 0xFFFFFF | 0x7FFFFFFFFE000000LL) == v15 )
    {
      v4 = v39;
      v37 = v12 + 1;
      v5 = a4;
      _InterlockedExchange((volatile __int32 *)(v13 + 8), v37 << 8);
      goto LABEL_11;
    }
    while ( 1 )
    {
      while ( (v15 & 0xFFFFFF) != v12 )
        v15 = *(_QWORD *)v13;
      v16 = ((unsigned __int64)v15 >> 0x19) & 0x3FFFFFFFFFLL;
      if ( v15 < 0 )
        break;
      if ( v16 == 0x3FFFFFFFFFLL )
      {
        v17 = v15;
        v15 = _InterlockedCompareExchange64((volatile signed __int64 *)v13, v14, v15);
        if ( v17 == v15 )
        {
          v4 = v39;
          v5 = a4;
          goto LABEL_10;
        }
      }
      else
      {
LABEL_30:
        v32 = v15;
        v33 = v15;
        v15 = _InterlockedCompareExchange64((volatile signed __int64 *)v13, v15 | 0x8000000000000000uLL, v15);
        if ( v33 == v15 )
        {
          v42 = v32;
          qword_149C78FC8(v13, &v42, 4, 0xFFFFFFFFLL);
          v15 = *(_QWORD *)v13;
        }
      }
    }
    if ( v16 != 0x3FFFFFFFFFLL )
      goto LABEL_30;
    _InterlockedCompareExchange64((volatile signed __int64 *)v13, v14, v15);
    v4 = v39;
    v34 = v12 + 1;
    v5 = a4;
    lReleaseCount = _InterlockedExchange((volatile __int32 *)(v13 + 8), v34 << 8);
    if ( lReleaseCount )
    {
      v4 = v39 - lReleaseCount;
      v36 = (HANDLE *)(v13 + 0x10);
      v39 = v4;
      if ( a4 )
      {
        lReleaseCount_1 = lReleaseCount;
        v58[0] = 0;
        v58[1] = v36;
        sub_1405F1C30(a4, (__int64)v58);
      }
      else
      {
        ReleaseSemaphore(*v36, lReleaseCount, 0);
      }
    }
LABEL_10:
    v7 = a2;
LABEL_11:
    if ( !v9 && *(_BYTE *)(v10 + 0xE5) )
      sub_1475F88D0((_QWORD *)a1, v11, v7);
    ++v9;
    v7 = a2;
    v8 = v43;
  }
  while ( v9 < *(unsigned int *)(a1 + 0x10) );
LABEL_15:
  if ( _InterlockedExchange((volatile __int32 *)(v10 + 0xE8), (1 << v8) - 1) == 0x80000000 )
    qword_149C78FD8(v10 + 0xE8);
  n0x1600 = 0x1600;
  v45 = 0;
  v46 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v47 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_151752590,
    "WakeUp ExtraWork Waiter",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\JobManager/BatchWorker.cpp",
    0x33B);
  v18 = *(_QWORD *)(a1 + 0x200120) == 0;
  v19 = 0;
  HIWORD(n0x1600) = word_151752590;
  if ( !v18 )
  {
    v20 = 0;
    while ( v4 > 0 )
    {
LABEL_20:
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 0x200128) + 8 * v19);
      while ( v21 )
      {
        v22 = v21 & ~(v21 - 1);
        n0x40 = 0x40;
        _BitScanReverse64(&v24, v22);
        n0x40_1 = v24 ^ 0x3F;
        v18 = v22 == 0;
        v26 = *(_QWORD *)(a1 + 0x200128);
        if ( !v18 )
          n0x40 = n0x40_1;
        v27 = 0x3F - n0x40;
        v28 = 1LL << (0x3F - (unsigned __int8)n0x40);
        _m_prefetchw((const void *)(v26 + 8 * v19));
        v21 = _InterlockedAnd64((volatile signed __int64 *)(v26 + 8 * v19), ~v28);
        if ( (v28 & v21) != 0 )
        {
          --v4;
          v29 = *(volatile signed __int32 **)(*(_QWORD *)(a1 + 0x200130) + 8 * (v20 + v27));
          v30 = *v29;
          if ( (*v29 & 0x40000000) != 0 )
          {
            while ( 1 )
            {
              v31 = v30;
              v30 = _InterlockedCompareExchange(v29, v30 & 0xBFFFFFFF, v30);
              if ( v31 == v30 )
                break;
              if ( (v30 & 0x40000000) == 0 )
                goto LABEL_40;
            }
            if ( v5 )
            {
              v60[0] = v29;
              v60[1] = 0;
              v61 = 0;
              sub_1405F1C30(v5, (__int64)v60);
            }
            else
            {
              qword_149C78FD8(v29);
            }
          }
LABEL_40:
          if ( v4 > 0 )
            goto LABEL_20;
          break;
        }
      }
      ++v19;
      v20 += 0x40;
      if ( v19 >= *(_QWORD *)(a1 + 0x200120) )
        break;
    }
  }
  v48 = __rdtsc();
  qword_149C89AA8(&n0x1600);
  v55 = __rdtsc();
  return qword_149C89AA8(&n0x1D00);
}

// --- End Function: sub_1475FD330 (0x1475FD330) ---

// --- Function: sub_1475FF440 (0x1475FF440) ---
__int64 __fastcall sub_1475FF440(__int64 a1, __int64 a2)
{
  signed __int32 *v2; // rdi
  signed __int32 i; // ebx
  __int64 result; // rax
  signed __int32 v5[4]; // [rsp+30h] [rbp-68h] BYREF
  int n0x1D00; // [rsp+40h] [rbp-58h] BYREF
  __int64 v7; // [rsp+44h] [rbp-54h]
  int n2; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v9; // [rsp+50h] [rbp-48h]
  unsigned __int64 v10; // [rsp+58h] [rbp-40h]
  __int64 v11; // [rsp+60h] [rbp-38h]
  __int64 v12; // [rsp+68h] [rbp-30h]

  v2 = (signed __int32 *)(a2 + 0x94);
  for ( i = _InterlockedIncrement((volatile signed __int32 *)(a2 + 0x94));
        (i & 0xFF0000) != 0;
        result = qword_149C89AA8(&n0x1D00) )
  {
    n0x1D00 = 0x1D00;
    v7 = 1;
    n2 = 2;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v9 = __rdtsc();
    qword_149C89AA0(
      &n0x1D00,
      &word_151752580,
      "CBatchWorkerManager::RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\JobManager/BatchWorker.cpp",
      0x257);
    HIWORD(n0x1D00) = word_151752580;
    v5[0] = i;
    qword_149C78FC8(v2, v5, 4, 0xFFFFFFFFLL);
    i = *v2;
    v10 = __rdtsc();
  }
  return result;
}

// --- End Function: sub_1475FF440 (0x1475FF440) ---

// --- Function: sub_147601360 (0x14760166C) ---
void __fastcall __noreturn sub_147601360(__int64 *a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // r8
  _BYTE *v5; // rax
  unsigned __int8 v6; // cl
  unsigned __int64 v7; // rdi
  unsigned __int8 v8; // r12
  __int64 v9; // r14
  __int64 n0xE98; // rdx
  int v11; // eax
  __int64 i; // rsi
  __int64 v13; // rbp
  __int64 v14; // rsi
  __int64 n8; // r8
  __int64 v16; // rdx
  __int64 v17; // rax
  volatile signed __int64 *v18; // rdx
  signed __int64 v19; // rax
  volatile signed __int64 v20; // rtt
  __int64 n8_1; // rbp
  __int64 *v22; // rsi
  unsigned __int8 v23; // [rsp+30h] [rbp-D8h]
  int v24; // [rsp+34h] [rbp-D4h]
  unsigned __int64 v25; // [rsp+50h] [rbp-B8h] BYREF
  _QWORD v26[15]; // [rsp+58h] [rbp-B0h] BYREF

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  *(_BYTE *)(v2 + 0xE29) = 1;
  v3 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v3 )
    v5 = (_BYTE *)(v3 + 0x42);
  else
    v5 = (_BYTE *)(NtCurrentTeb_w() + 0x12E);
  *v5 = 1;
  v6 = 0;
  v7 = 0;
  v8 = *((_BYTE *)a1 + 0xC);
  v9 = *((unsigned int *)a1 + 2);
  n0xE98 = 0xE98;
  v23 = 0;
  v24 = *(_DWORD *)(*a1 + 0x14);
  *(_BYTE *)(v2 + 0xE28) = v8;
  v11 = *(_DWORD *)(v2 + 0xE98);
  if ( (v11 & 1) == 0 )
  {
    *(_DWORD *)(v2 + 0xE98) = v11 | 1;
    _tlregdtor(byte_14828D0F0);
    v6 = 0;
  }
  for ( i = 8 * v9; ; i = 8 * v9 )
  {
    if ( !v6 && qword_149C8DF40 )
    {
      v23 = 1;
      (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)qword_149C8DF40 + 0x20LL))(
        qword_149C8DF40,
        n0xE98,
        v4,
        0x3FFFFFFFFFLL);
    }
    v13 = *a1;
    v25 = 0;
    memset(v26, 0, sizeof(v26));
    v14 = *(_QWORD *)(i + *(_QWORD *)(v13 + 0x1E8038));
    while ( 1 )
    {
      n8 = 0;
      do
      {
        if ( (*(_QWORD *)(v14 + 0x18 * (v7 & 0xFFF)) & 0xFFFFFFLL) == v7 >> 0xC )
        {
          v16 = (*(_QWORD *)(v14 + 0x18 * (v7 & 0xFFF)) >> 0x19) & 0x3FFFFFFFFFLL;
          if ( v16 == 0x3FFFFFFFFFLL )
            break;
          v17 = 2LL * (unsigned int)n8;
          n8 = (unsigned int)(n8 + 1);
          v26[v17 - 1] = v16;
          v26[v17] = v7;
        }
        ++v7;
      }
      while ( (unsigned int)n8 < 8 );
      if ( (_DWORD)n8 )
        break;
      v18 = (volatile signed __int64 *)(v14 + 0x18 * (v7 & 0xFFF));
      v19 = *v18;
      if ( (*v18 & 0xFFFFFF) == v7 >> 0xC && (v19 & 0x7FFFFFFFFE000000LL) == 0x7FFFFFFFFE000000LL )
      {
        if ( v19 < 0 || (v20 = *v18, v20 == _InterlockedCompareExchange64(v18, v19 | 0x8000000000000000uLL, v19)) )
          sub_1475F6800(v13, v7, v7 >> 0xC, v9);
      }
    }
    n8_1 = (unsigned int)n8;
    sub_146D257F0(&v25, (char *)&v26[2 * (unsigned int)n8 - 1], n8, v23);
    v22 = (__int64 *)&v25;
    do
    {
      sub_1475F3500(*v22, v8, v24, *a1, v7, 0);
      v22 += 2;
      --n8_1;
    }
    while ( n8_1 );
    v6 = v23;
  }
}

// --- End Function: sub_147601360 (0x14760166C) ---

// --- Function: sub_1476040E0 (0x1476040E0) ---
__int64 __fastcall sub_1476040E0(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // rbx
  __int64 v5; // rax
  _BYTE *v6; // rax
  __int64 v7; // rsi
  unsigned __int8 v8; // di
  unsigned __int64 n0x1000; // rcx
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rdx
  __int64 *v12; // rax
  unsigned int v13; // edx
  __int64 v14; // r9
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // r8
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // r12
  __int64 *v20; // r15
  __int64 v21; // rbp
  __int64 v22; // rbx
  bool v23; // di
  signed __int32 v24; // edx
  _BYTE *v25; // rax
  _QWORD *v26; // r14
  __int64 v27; // rax
  __int64 v28; // rsi
  __int64 v29; // rbx
  _BYTE *v30; // rax
  __int64 v31; // [rsp+30h] [rbp-A8h]
  __int64 v32; // [rsp+38h] [rbp-A0h]
  _QWORD v33[2]; // [rsp+40h] [rbp-98h] BYREF
  int n0x1D00; // [rsp+50h] [rbp-88h] BYREF
  __int64 v35; // [rsp+54h] [rbp-84h]
  int n2; // [rsp+5Ch] [rbp-7Ch]
  unsigned __int64 v37; // [rsp+60h] [rbp-78h]
  unsigned __int64 v38; // [rsp+68h] [rbp-70h]
  __int64 v39; // [rsp+70h] [rbp-68h]
  __int64 v40; // [rsp+78h] [rbp-60h]
  unsigned __int8 v42; // [rsp+F0h] [rbp+18h]
  int v43; // [rsp+F8h] [rbp+20h]

  result = a2 - 1;
  v3 = a2;
  if ( a2 - 1 <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    if ( !*(_BYTE *)(NtCurrentTeb_w() + 0x12D) )
    {
      v5 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
      v6 = (_BYTE *)(v5 ? v5 + 0x42 : NtCurrentTeb_w() + 0x12E);
      if ( !*v6 )
        LogFatalError("SyncBarrier is only allowed from the MainThread or Batchworker");
    }
    v43 = *(_DWORD *)(a1 + 0x14);
    result = sub_1475F8550(a1, v3);
    if ( !(_BYTE)result )
    {
      v38 = 0;
      v39 = 0;
      v40 = 0;
      n0x1D00 = 0x1D00;
      v35 = 1;
      n2 = 2;
      v37 = __rdtsc();
      qword_149C89AA0(
        &n0x1D00,
        &word_15175259C,
        "SyncBarrier - Processing all previous queued jobs",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\JobManager/BatchWorker.cpp",
        0x5B1);
      HIWORD(n0x1D00) = word_15175259C;
      v7 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v31 = v7;
      v8 = *(_BYTE *)(v7 + 0xE28);
      n0x1000 = **(_QWORD **)(a1 + 0x1E8030);
      v10 = *(_QWORD *)(v7 + 0xE88);
      v42 = v8;
      v11 = n0x1000 - 0x1000;
      if ( n0x1000 <= 0x1000 )
        v11 = 0;
      if ( v10 < v11 )
        v10 = v11;
      *(_QWORD *)(v7 + 0xE88) = v10;
      while ( !sub_1475F8550(a1, v3) )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x38LL))(qword_149C8DFE0);
        v12 = *(__int64 **)(a1 + 0x1E8038);
        v13 = 0;
        v32 = 0;
        v33[0] = 0;
        v14 = *v12;
        do
        {
          v15 = *(_QWORD *)(v7 + 0xE88) >> 0xC;
          v16 = *(_QWORD *)(v14 + 0x18 * (*(_QWORD *)(v7 + 0xE88) & 0xFFFLL)) & 0xFFFFFFLL;
          if ( v16 >= v15 )
          {
            if ( v16 == v15 )
            {
              v17 = (*(_QWORD *)(v14 + 0x18 * (*(_QWORD *)(v7 + 0xE88) & 0xFFFLL)) >> 0x19) & 0x3FFFFFFFFFLL;
              if ( v17 == 0x3FFFFFFFFFLL )
                break;
              v18 = 2LL * v13++;
              v33[v18 - 1] = v17;
              v33[v18] = *(_QWORD *)(v7 + 0xE88);
            }
            ++*(_QWORD *)(v7 + 0xE88);
          }
          else
          {
            _mm_pause();
          }
        }
        while ( !v13 );
        v19 = v13;
        if ( v13 )
        {
          v20 = v33;
          do
          {
            v21 = v20[0xFFFFFFFF];
            v22 = a1 + 0x1E8 * (v21 & 0xFFF);
            sub_1475FF440(a1, v22 + 0x30);
            v23 = *(_QWORD *)(v22 + 0x30) == v21
               && *(_DWORD *)(v22 + 0xC0)
               && v8 < *(_BYTE *)(v22 + 0xE2)
               && *(_BYTE *)(v22 + 0xE1) != 1;
            v24 = _InterlockedDecrement((volatile signed __int32 *)(v22 + 0xC4));
            if ( !(_WORD)v24 && (v24 & 0xFF000000) != 0 )
              qword_149C78FD8(v22 + 0xC4);
            if ( v23 )
            {
              v25 = (_BYTE *)sub_1475F6510();
              ++*v25;
              v26 = (_QWORD *)(v7 + 0xE30);
              v27 = *v20;
              v28 = *(_QWORD *)(v7 + 0xE30);
              *v26 = 0;
              v29 = *(_QWORD *)(v31 + 0xE38);
              sub_1475F3500(v21, v42, v43, a1, v27, 0);
              *(_QWORD *)(v31 + 0xE38) = v29;
              *v26 = v28;
              v30 = (_BYTE *)sub_1475F6510();
              v7 = v31;
              --*v30;
            }
            v8 = v42;
            v20 += 2;
            --v19;
          }
          while ( v19 );
          v3 = a2;
        }
        else
        {
          _mm_pause();
        }
      }
      v38 = __rdtsc();
      return qword_149C89AA8(&n0x1D00);
    }
  }
  return result;
}

// --- End Function: sub_1476040E0 (0x1476040E0) ---

// --- Function: sub_1476044B0 (0x1476044B0) ---
char __fastcall sub_1476044B0(__int64 a1, __int64 a2)
{
  char result; // al
  __int64 v5; // rax
  _BYTE *v6; // rax
  __int64 v7; // rsi
  volatile signed __int32 *v8; // rbx
  signed __int32 v9; // ecx
  const void *v10; // r8
  __int64 v11; // r9
  unsigned __int64 v12; // r14
  char v13; // r15
  signed __int32 v14; // ecx
  _QWORD *v15; // rdi
  _QWORD *i; // rbx
  unsigned __int64 v17; // r14
  __int64 v18; // rbx
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rbx
  __int64 v22; // rax
  _BYTE *v23; // rax
  __int64 v24; // rsi
  _QWORD *v25; // rax
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // rax
  __int64 v28; // rax
  int *j; // r15
  volatile signed __int32 *v30; // r13
  int v31; // ebx
  unsigned __int64 v32; // rdi
  signed __int32 v33; // ecx
  __int64 *v34; // rax
  __int64 v35; // r10
  unsigned int v36; // edx
  __int64 v37; // r9
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // r8
  __int64 v40; // rax
  __int64 v41; // rcx
  unsigned __int64 v42; // r15
  __int64 *v43; // rax
  __int64 v44; // r12
  __int64 v45; // rbx
  bool v46; // di
  signed __int32 v47; // edx
  int v48; // r8d
  _QWORD *v49; // r14
  __int64 *v50; // rdi
  __int64 v51; // rsi
  __int64 v52; // rbx
  int v53; // ebx
  unsigned __int64 v54; // rdi
  signed __int32 v55; // ecx
  __int64 v56; // rax
  _BYTE *v57; // rax
  unsigned __int64 *v58; // [rsp+38h] [rbp-89h]
  __int64 v59; // [rsp+40h] [rbp-81h] BYREF
  int v60; // [rsp+48h] [rbp-79h] BYREF
  int *v61; // [rsp+50h] [rbp-71h]
  __int64 v62; // [rsp+58h] [rbp-69h]
  __int64 v63; // [rsp+60h] [rbp-61h] BYREF
  __int64 v64; // [rsp+68h] [rbp-59h]
  __int128 v65; // [rsp+70h] [rbp-51h] BYREF
  __int64 v66; // [rsp+80h] [rbp-41h]
  _BYTE v67[2]; // [rsp+88h] [rbp-39h] BYREF
  __int16 v68; // [rsp+8Ah] [rbp-37h]
  __int64 v69; // [rsp+8Ch] [rbp-35h]
  int n2; // [rsp+94h] [rbp-2Dh]
  unsigned __int64 v71; // [rsp+98h] [rbp-29h]
  unsigned __int64 v72; // [rsp+A0h] [rbp-21h]
  __int64 v73; // [rsp+A8h] [rbp-19h]
  __int64 v74; // [rsp+B0h] [rbp-11h]
  unsigned __int8 v77; // [rsp+138h] [rbp+77h]
  __int16 v78; // [rsp+140h] [rbp+7Fh] BYREF

  result = a2 - 1;
  if ( (unsigned __int64)(a2 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    if ( !*(_BYTE *)(NtCurrentTeb_w() + 0x12D) )
    {
      v5 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
      v6 = (_BYTE *)(v5 ? v5 + 0x42 : NtCurrentTeb_w() + 0x12E);
      if ( !*v6 )
        LogFatalError("SyncBatchJobs is only allowed from the MainThread or Batchworker");
    }
    HIDWORD(v59) = *(_DWORD *)(a1 + 0x14);
    v7 = a1 + 0x1E8 * (a2 & 0xFFF);
    result = sub_1475FF440(a1, v7 + 0x30);
    v8 = (volatile signed __int32 *)(v7 + 0xC4);
    if ( *(_QWORD *)(v7 + 0x30) == a2 )
    {
      v10 = *(const void **)(v7 + 0x88);
      v11 = *(_QWORD *)(v7 + 0x90) - (_QWORD)v10;
      v65 = 0;
      v66 = 0;
      sub_1471EA320((unsigned __int64 *)&v65, 0, v10, v11 >> 3);
      v12 = *(_QWORD *)(v7 + 0xA0);
      v13 = *(_BYTE *)(v7 + 0xD0);
      v14 = _InterlockedDecrement(v8);
      if ( !(_WORD)v14 && (v14 & 0xFF000000) != 0 )
        qword_149C78FD8(v7 + 0xC4);
      v15 = (_QWORD *)*((_QWORD *)&v65 + 1);
      for ( i = (_QWORD *)v65; i != v15; ++i )
        sub_1476044B0(a1, *i);
      sub_1476040E0(a1, v12);
      v17 = a2;
      result = sub_1475F8620(a1, a2);
      if ( !result )
      {
        v18 = qword_149C8E080;
        v19 = *(_QWORD *)qword_149C8E080;
        v20 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E080 + 0x140LL))(
                qword_149C8E080,
                *(unsigned __int16 *)(v7 + 0xCE));
        v78 = *(_WORD *)(*(__int64 (**)(__int64, __int64 *, const char *, ...))(v19 + 0x138))(
                          v18,
                          &v59,
                          "SyncBatchJobs on %s - Processing queued jobs",
                          v20);
        v68 = 0;
        v69 = 1;
        n2 = 2;
        v72 = 0;
        v73 = 0;
        v74 = 0;
        v67[1] = v13;
        v71 = __rdtsc();
        v67[0] = 0;
        qword_149C89AA0(v67, &v78, &p_Src, &p_Src, 0);
        v68 = v78;
        v21 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
        v62 = v21;
        v77 = *(_BYTE *)(v21 + 0xE28);
        v22 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
        if ( v22 )
          v23 = (_BYTE *)(v22 + 0x42);
        else
          v23 = (_BYTE *)(NtCurrentTeb_w() + 0x12E);
        ++*v23;
        v24 = a1;
        v25 = *(_QWORD **)(a1 + 0x1E8030);
        v26 = *v25 - 0x1000LL;
        if ( *v25 <= 0x1000u )
          v26 = 0;
        v27 = *(_QWORD *)(v21 + 0xE80);
        if ( v27 < v26 )
          v27 = v26;
        *(_QWORD *)(v21 + 0xE80) = v27;
        v28 = a1 + 0x1E8 * (a2 & 0xFFF) + 0x30;
        v58 = (unsigned __int64 *)v28;
        j = (int *)(v28 + 0x90);
        v61 = (int *)(v28 + 0x90);
        v30 = (volatile signed __int32 *)(v28 + 0x94);
        while ( 1 )
        {
LABEL_26:
          sub_1475FF440(v24, v28);
          v31 = *j;
          v32 = *v58;
          v33 = _InterlockedDecrement(v30);
          if ( !(_WORD)v33 && (v33 & 0xFF000000) != 0 )
            qword_149C78FD8(v30);
          if ( !v31 || v32 != v17 )
            break;
          v34 = *(__int64 **)(v24 + 0x1E8038);
          v35 = v62;
          v36 = 0;
          v63 = 0;
          v64 = 0;
          v37 = *v34;
          do
          {
            v38 = *(_QWORD *)(v35 + 0xE80) >> 0xC;
            v39 = *(_QWORD *)(v37 + 0x18 * (*(_QWORD *)(v35 + 0xE80) & 0xFFFLL)) & 0xFFFFFFLL;
            if ( v39 >= v38 )
            {
              if ( v39 == v38 )
              {
                v40 = (*(_QWORD *)(v37 + 0x18 * (*(_QWORD *)(v35 + 0xE80) & 0xFFFLL)) >> 0x19) & 0x3FFFFFFFFFLL;
                if ( v40 == 0x3FFFFFFFFFLL )
                  break;
                v41 = 2LL * v36++;
                *(&v63 + v41) = v40;
                *(&v64 + v41) = *(_QWORD *)(v35 + 0xE80);
              }
              ++*(_QWORD *)(v35 + 0xE80);
            }
            else
            {
              _mm_pause();
            }
          }
          while ( !v36 );
          v24 = a1;
          v42 = 0;
          if ( v36 )
          {
            v43 = &v63;
            while ( 1 )
            {
              v44 = *v43;
              if ( *v43 == v17 )
                break;
              ++v42;
              v43 += 2;
              if ( v42 >= v36 )
              {
                j = v61;
                v28 = (__int64)v58;
                goto LABEL_26;
              }
            }
            v45 = a1 + 0x1E8 * (*v43 & 0xFFF);
            sub_1475FF440(a1, v45 + 0x30);
            v46 = *(_QWORD *)(v45 + 0x30) == v44
               && *(_DWORD *)(v45 + 0xC0)
               && v77 < *(_BYTE *)(v45 + 0xE2)
               && *(_BYTE *)(v45 + 0xE1) != 1;
            v47 = _InterlockedDecrement((volatile signed __int32 *)(v45 + 0xC4));
            if ( !(_WORD)v47 && (v47 & 0xFF000000) != 0 )
              qword_149C78FD8(v45 + 0xC4);
            if ( v46 )
            {
              v48 = HIDWORD(v59);
              v49 = (_QWORD *)(v62 + 0xE30);
              v50 = (__int64 *)(v62 + 0xE38);
              v51 = *(_QWORD *)(v62 + 0xE30);
              *(_QWORD *)(v62 + 0xE30) = 0;
              v52 = *v50;
              sub_1475F3500(v44, v77, v48, a1, *(&v64 + 2 * v42), 0);
              *v49 = v51;
              v17 = a2;
              v24 = a1;
              *v50 = v52;
            }
            for ( j = v61; ; qword_149C78FC8(j, &v60, 4, 0xFFFFFFFFLL) )
            {
              sub_1475FF440(v24, (__int64)v58);
              v53 = *j;
              v54 = *v58;
              v55 = _InterlockedDecrement(v30);
              if ( !(_WORD)v55 && (v55 & 0xFF000000) != 0 )
                qword_149C78FD8(v30);
              v28 = (__int64)v58;
              if ( !v53 || v54 < v17 )
                break;
              v60 = v53;
            }
          }
          else
          {
            _mm_pause();
            j = v61;
            v28 = (__int64)v58;
          }
        }
        v56 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
        if ( v56 )
          v57 = (_BYTE *)(v56 + 0x42);
        else
          v57 = (_BYTE *)(NtCurrentTeb_w() + 0x12E);
        --*v57;
        v72 = __rdtsc();
        result = qword_149C89AA8(v67);
      }
      if ( (_QWORD)v65 )
        return sub_1403A6820((__int64)&v65, v65, (v66 - v65) & 0xFFFFFFFFFFFFFFF8uLL);
    }
    else
    {
      v9 = _InterlockedDecrement(v8);
      if ( !(_WORD)v9 && (v9 & 0xFF000000) != 0 )
        return qword_149C78FD8(v7 + 0xC4);
    }
  }
  return result;
}

// --- End Function: sub_1476044B0 (0x1476044B0) ---

// --- Function: sub_1476044B0 (0x14760461B) ---
char __fastcall sub_1476044B0(__int64 a1, __int64 a2)
{
  char result; // al
  __int64 v5; // rax
  _BYTE *v6; // rax
  __int64 v7; // rsi
  volatile signed __int32 *v8; // rbx
  signed __int32 v9; // ecx
  const void *v10; // r8
  __int64 v11; // r9
  unsigned __int64 v12; // r14
  char v13; // r15
  signed __int32 v14; // ecx
  _QWORD *v15; // rdi
  _QWORD *i; // rbx
  unsigned __int64 v17; // r14
  __int64 v18; // rbx
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rbx
  __int64 v22; // rax
  _BYTE *v23; // rax
  __int64 v24; // rsi
  _QWORD *v25; // rax
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // rax
  __int64 v28; // rax
  int *j; // r15
  volatile signed __int32 *v30; // r13
  int v31; // ebx
  unsigned __int64 v32; // rdi
  signed __int32 v33; // ecx
  __int64 *v34; // rax
  __int64 v35; // r10
  unsigned int v36; // edx
  __int64 v37; // r9
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // r8
  __int64 v40; // rax
  __int64 v41; // rcx
  unsigned __int64 v42; // r15
  __int64 *v43; // rax
  __int64 v44; // r12
  __int64 v45; // rbx
  bool v46; // di
  signed __int32 v47; // edx
  int v48; // r8d
  _QWORD *v49; // r14
  __int64 *v50; // rdi
  __int64 v51; // rsi
  __int64 v52; // rbx
  int v53; // ebx
  unsigned __int64 v54; // rdi
  signed __int32 v55; // ecx
  __int64 v56; // rax
  _BYTE *v57; // rax
  unsigned __int64 *v58; // [rsp+38h] [rbp-89h]
  __int64 v59; // [rsp+40h] [rbp-81h] BYREF
  int v60; // [rsp+48h] [rbp-79h] BYREF
  int *v61; // [rsp+50h] [rbp-71h]
  __int64 v62; // [rsp+58h] [rbp-69h]
  __int64 v63; // [rsp+60h] [rbp-61h] BYREF
  __int64 v64; // [rsp+68h] [rbp-59h]
  __int128 v65; // [rsp+70h] [rbp-51h] BYREF
  __int64 v66; // [rsp+80h] [rbp-41h]
  _BYTE v67[2]; // [rsp+88h] [rbp-39h] BYREF
  __int16 v68; // [rsp+8Ah] [rbp-37h]
  __int64 v69; // [rsp+8Ch] [rbp-35h]
  int n2; // [rsp+94h] [rbp-2Dh]
  unsigned __int64 v71; // [rsp+98h] [rbp-29h]
  unsigned __int64 v72; // [rsp+A0h] [rbp-21h]
  __int64 v73; // [rsp+A8h] [rbp-19h]
  __int64 v74; // [rsp+B0h] [rbp-11h]
  unsigned __int8 v77; // [rsp+138h] [rbp+77h]
  __int16 v78; // [rsp+140h] [rbp+7Fh] BYREF

  result = a2 - 1;
  if ( (unsigned __int64)(a2 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    if ( !*(_BYTE *)(NtCurrentTeb_w() + 0x12D) )
    {
      v5 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
      v6 = (_BYTE *)(v5 ? v5 + 0x42 : NtCurrentTeb_w() + 0x12E);
      if ( !*v6 )
        LogFatalError("SyncBatchJobs is only allowed from the MainThread or Batchworker");
    }
    HIDWORD(v59) = *(_DWORD *)(a1 + 0x14);
    v7 = a1 + 0x1E8 * (a2 & 0xFFF);
    result = sub_1475FF440(a1, v7 + 0x30);
    v8 = (volatile signed __int32 *)(v7 + 0xC4);
    if ( *(_QWORD *)(v7 + 0x30) == a2 )
    {
      v10 = *(const void **)(v7 + 0x88);
      v11 = *(_QWORD *)(v7 + 0x90) - (_QWORD)v10;
      v65 = 0;
      v66 = 0;
      sub_1471EA320((unsigned __int64 *)&v65, 0, v10, v11 >> 3);
      v12 = *(_QWORD *)(v7 + 0xA0);
      v13 = *(_BYTE *)(v7 + 0xD0);
      v14 = _InterlockedDecrement(v8);
      if ( !(_WORD)v14 && (v14 & 0xFF000000) != 0 )
        qword_149C78FD8(v7 + 0xC4);
      v15 = (_QWORD *)*((_QWORD *)&v65 + 1);
      for ( i = (_QWORD *)v65; i != v15; ++i )
        sub_1476044B0(a1, *i);
      sub_1476040E0(a1, v12);
      v17 = a2;
      result = sub_1475F8620(a1, a2);
      if ( !result )
      {
        v18 = qword_149C8E080;
        v19 = *(_QWORD *)qword_149C8E080;
        v20 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E080 + 0x140LL))(
                qword_149C8E080,
                *(unsigned __int16 *)(v7 + 0xCE));
        v78 = *(_WORD *)(*(__int64 (**)(__int64, __int64 *, const char *, ...))(v19 + 0x138))(
                          v18,
                          &v59,
                          "SyncBatchJobs on %s - Processing queued jobs",
                          v20);
        v68 = 0;
        v69 = 1;
        n2 = 2;
        v72 = 0;
        v73 = 0;
        v74 = 0;
        v67[1] = v13;
        v71 = __rdtsc();
        v67[0] = 0;
        qword_149C89AA0(v67, &v78, &p_Src, &p_Src, 0);
        v68 = v78;
        v21 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
        v62 = v21;
        v77 = *(_BYTE *)(v21 + 0xE28);
        v22 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
        if ( v22 )
          v23 = (_BYTE *)(v22 + 0x42);
        else
          v23 = (_BYTE *)(NtCurrentTeb_w() + 0x12E);
        ++*v23;
        v24 = a1;
        v25 = *(_QWORD **)(a1 + 0x1E8030);
        v26 = *v25 - 0x1000LL;
        if ( *v25 <= 0x1000u )
          v26 = 0;
        v27 = *(_QWORD *)(v21 + 0xE80);
        if ( v27 < v26 )
          v27 = v26;
        *(_QWORD *)(v21 + 0xE80) = v27;
        v28 = a1 + 0x1E8 * (a2 & 0xFFF) + 0x30;
        v58 = (unsigned __int64 *)v28;
        j = (int *)(v28 + 0x90);
        v61 = (int *)(v28 + 0x90);
        v30 = (volatile signed __int32 *)(v28 + 0x94);
        while ( 1 )
        {
LABEL_26:
          sub_1475FF440(v24, v28);
          v31 = *j;
          v32 = *v58;
          v33 = _InterlockedDecrement(v30);
          if ( !(_WORD)v33 && (v33 & 0xFF000000) != 0 )
            qword_149C78FD8(v30);
          if ( !v31 || v32 != v17 )
            break;
          v34 = *(__int64 **)(v24 + 0x1E8038);
          v35 = v62;
          v36 = 0;
          v63 = 0;
          v64 = 0;
          v37 = *v34;
          do
          {
            v38 = *(_QWORD *)(v35 + 0xE80) >> 0xC;
            v39 = *(_QWORD *)(v37 + 0x18 * (*(_QWORD *)(v35 + 0xE80) & 0xFFFLL)) & 0xFFFFFFLL;
            if ( v39 >= v38 )
            {
              if ( v39 == v38 )
              {
                v40 = (*(_QWORD *)(v37 + 0x18 * (*(_QWORD *)(v35 + 0xE80) & 0xFFFLL)) >> 0x19) & 0x3FFFFFFFFFLL;
                if ( v40 == 0x3FFFFFFFFFLL )
                  break;
                v41 = 2LL * v36++;
                *(&v63 + v41) = v40;
                *(&v64 + v41) = *(_QWORD *)(v35 + 0xE80);
              }
              ++*(_QWORD *)(v35 + 0xE80);
            }
            else
            {
              _mm_pause();
            }
          }
          while ( !v36 );
          v24 = a1;
          v42 = 0;
          if ( v36 )
          {
            v43 = &v63;
            while ( 1 )
            {
              v44 = *v43;
              if ( *v43 == v17 )
                break;
              ++v42;
              v43 += 2;
              if ( v42 >= v36 )
              {
                j = v61;
                v28 = (__int64)v58;
                goto LABEL_26;
              }
            }
            v45 = a1 + 0x1E8 * (*v43 & 0xFFF);
            sub_1475FF440(a1, v45 + 0x30);
            v46 = *(_QWORD *)(v45 + 0x30) == v44
               && *(_DWORD *)(v45 + 0xC0)
               && v77 < *(_BYTE *)(v45 + 0xE2)
               && *(_BYTE *)(v45 + 0xE1) != 1;
            v47 = _InterlockedDecrement((volatile signed __int32 *)(v45 + 0xC4));
            if ( !(_WORD)v47 && (v47 & 0xFF000000) != 0 )
              qword_149C78FD8(v45 + 0xC4);
            if ( v46 )
            {
              v48 = HIDWORD(v59);
              v49 = (_QWORD *)(v62 + 0xE30);
              v50 = (__int64 *)(v62 + 0xE38);
              v51 = *(_QWORD *)(v62 + 0xE30);
              *(_QWORD *)(v62 + 0xE30) = 0;
              v52 = *v50;
              sub_1475F3500(v44, v77, v48, a1, *(&v64 + 2 * v42), 0);
              *v49 = v51;
              v17 = a2;
              v24 = a1;
              *v50 = v52;
            }
            for ( j = v61; ; qword_149C78FC8(j, &v60, 4, 0xFFFFFFFFLL) )
            {
              sub_1475FF440(v24, (__int64)v58);
              v53 = *j;
              v54 = *v58;
              v55 = _InterlockedDecrement(v30);
              if ( !(_WORD)v55 && (v55 & 0xFF000000) != 0 )
                qword_149C78FD8(v30);
              v28 = (__int64)v58;
              if ( !v53 || v54 < v17 )
                break;
              v60 = v53;
            }
          }
          else
          {
            _mm_pause();
            j = v61;
            v28 = (__int64)v58;
          }
        }
        v56 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
        if ( v56 )
          v57 = (_BYTE *)(v56 + 0x42);
        else
          v57 = (_BYTE *)(NtCurrentTeb_w() + 0x12E);
        --*v57;
        v72 = __rdtsc();
        result = qword_149C89AA8(v67);
      }
      if ( (_QWORD)v65 )
        return sub_1403A6820((__int64)&v65, v65, (v66 - v65) & 0xFFFFFFFFFFFFFFF8uLL);
    }
    else
    {
      v9 = _InterlockedDecrement(v8);
      if ( !(_WORD)v9 && (v9 & 0xFF000000) != 0 )
        return qword_149C78FD8(v7 + 0xC4);
    }
  }
  return result;
}

// --- End Function: sub_1476044B0 (0x14760461B) ---

// --- Function: sub_1476044B0 (0x14760494F) ---
char __fastcall sub_1476044B0(__int64 a1, __int64 a2)
{
  char result; // al
  __int64 v5; // rax
  _BYTE *v6; // rax
  __int64 v7; // rsi
  volatile signed __int32 *v8; // rbx
  signed __int32 v9; // ecx
  const void *v10; // r8
  __int64 v11; // r9
  unsigned __int64 v12; // r14
  char v13; // r15
  signed __int32 v14; // ecx
  _QWORD *v15; // rdi
  _QWORD *i; // rbx
  unsigned __int64 v17; // r14
  __int64 v18; // rbx
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rbx
  __int64 v22; // rax
  _BYTE *v23; // rax
  __int64 v24; // rsi
  _QWORD *v25; // rax
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // rax
  __int64 v28; // rax
  int *j; // r15
  volatile signed __int32 *v30; // r13
  int v31; // ebx
  unsigned __int64 v32; // rdi
  signed __int32 v33; // ecx
  __int64 *v34; // rax
  __int64 v35; // r10
  unsigned int v36; // edx
  __int64 v37; // r9
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // r8
  __int64 v40; // rax
  __int64 v41; // rcx
  unsigned __int64 v42; // r15
  __int64 *v43; // rax
  __int64 v44; // r12
  __int64 v45; // rbx
  bool v46; // di
  signed __int32 v47; // edx
  int v48; // r8d
  _QWORD *v49; // r14
  __int64 *v50; // rdi
  __int64 v51; // rsi
  __int64 v52; // rbx
  int v53; // ebx
  unsigned __int64 v54; // rdi
  signed __int32 v55; // ecx
  __int64 v56; // rax
  _BYTE *v57; // rax
  unsigned __int64 *v58; // [rsp+38h] [rbp-89h]
  __int64 v59; // [rsp+40h] [rbp-81h] BYREF
  int v60; // [rsp+48h] [rbp-79h] BYREF
  int *v61; // [rsp+50h] [rbp-71h]
  __int64 v62; // [rsp+58h] [rbp-69h]
  __int64 v63; // [rsp+60h] [rbp-61h] BYREF
  __int64 v64; // [rsp+68h] [rbp-59h]
  __int128 v65; // [rsp+70h] [rbp-51h] BYREF
  __int64 v66; // [rsp+80h] [rbp-41h]
  _BYTE v67[2]; // [rsp+88h] [rbp-39h] BYREF
  __int16 v68; // [rsp+8Ah] [rbp-37h]
  __int64 v69; // [rsp+8Ch] [rbp-35h]
  int n2; // [rsp+94h] [rbp-2Dh]
  unsigned __int64 v71; // [rsp+98h] [rbp-29h]
  unsigned __int64 v72; // [rsp+A0h] [rbp-21h]
  __int64 v73; // [rsp+A8h] [rbp-19h]
  __int64 v74; // [rsp+B0h] [rbp-11h]
  unsigned __int8 v77; // [rsp+138h] [rbp+77h]
  __int16 v78; // [rsp+140h] [rbp+7Fh] BYREF

  result = a2 - 1;
  if ( (unsigned __int64)(a2 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    if ( !*(_BYTE *)(NtCurrentTeb_w() + 0x12D) )
    {
      v5 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
      v6 = (_BYTE *)(v5 ? v5 + 0x42 : NtCurrentTeb_w() + 0x12E);
      if ( !*v6 )
        LogFatalError("SyncBatchJobs is only allowed from the MainThread or Batchworker");
    }
    HIDWORD(v59) = *(_DWORD *)(a1 + 0x14);
    v7 = a1 + 0x1E8 * (a2 & 0xFFF);
    result = sub_1475FF440(a1, v7 + 0x30);
    v8 = (volatile signed __int32 *)(v7 + 0xC4);
    if ( *(_QWORD *)(v7 + 0x30) == a2 )
    {
      v10 = *(const void **)(v7 + 0x88);
      v11 = *(_QWORD *)(v7 + 0x90) - (_QWORD)v10;
      v65 = 0;
      v66 = 0;
      sub_1471EA320((unsigned __int64 *)&v65, 0, v10, v11 >> 3);
      v12 = *(_QWORD *)(v7 + 0xA0);
      v13 = *(_BYTE *)(v7 + 0xD0);
      v14 = _InterlockedDecrement(v8);
      if ( !(_WORD)v14 && (v14 & 0xFF000000) != 0 )
        qword_149C78FD8(v7 + 0xC4);
      v15 = (_QWORD *)*((_QWORD *)&v65 + 1);
      for ( i = (_QWORD *)v65; i != v15; ++i )
        sub_1476044B0(a1, *i);
      sub_1476040E0(a1, v12);
      v17 = a2;
      result = sub_1475F8620(a1, a2);
      if ( !result )
      {
        v18 = qword_149C8E080;
        v19 = *(_QWORD *)qword_149C8E080;
        v20 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E080 + 0x140LL))(
                qword_149C8E080,
                *(unsigned __int16 *)(v7 + 0xCE));
        v78 = *(_WORD *)(*(__int64 (**)(__int64, __int64 *, const char *, ...))(v19 + 0x138))(
                          v18,
                          &v59,
                          "SyncBatchJobs on %s - Processing queued jobs",
                          v20);
        v68 = 0;
        v69 = 1;
        n2 = 2;
        v72 = 0;
        v73 = 0;
        v74 = 0;
        v67[1] = v13;
        v71 = __rdtsc();
        v67[0] = 0;
        qword_149C89AA0(v67, &v78, &p_Src, &p_Src, 0);
        v68 = v78;
        v21 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
        v62 = v21;
        v77 = *(_BYTE *)(v21 + 0xE28);
        v22 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
        if ( v22 )
          v23 = (_BYTE *)(v22 + 0x42);
        else
          v23 = (_BYTE *)(NtCurrentTeb_w() + 0x12E);
        ++*v23;
        v24 = a1;
        v25 = *(_QWORD **)(a1 + 0x1E8030);
        v26 = *v25 - 0x1000LL;
        if ( *v25 <= 0x1000u )
          v26 = 0;
        v27 = *(_QWORD *)(v21 + 0xE80);
        if ( v27 < v26 )
          v27 = v26;
        *(_QWORD *)(v21 + 0xE80) = v27;
        v28 = a1 + 0x1E8 * (a2 & 0xFFF) + 0x30;
        v58 = (unsigned __int64 *)v28;
        j = (int *)(v28 + 0x90);
        v61 = (int *)(v28 + 0x90);
        v30 = (volatile signed __int32 *)(v28 + 0x94);
        while ( 1 )
        {
LABEL_26:
          sub_1475FF440(v24, v28);
          v31 = *j;
          v32 = *v58;
          v33 = _InterlockedDecrement(v30);
          if ( !(_WORD)v33 && (v33 & 0xFF000000) != 0 )
            qword_149C78FD8(v30);
          if ( !v31 || v32 != v17 )
            break;
          v34 = *(__int64 **)(v24 + 0x1E8038);
          v35 = v62;
          v36 = 0;
          v63 = 0;
          v64 = 0;
          v37 = *v34;
          do
          {
            v38 = *(_QWORD *)(v35 + 0xE80) >> 0xC;
            v39 = *(_QWORD *)(v37 + 0x18 * (*(_QWORD *)(v35 + 0xE80) & 0xFFFLL)) & 0xFFFFFFLL;
            if ( v39 >= v38 )
            {
              if ( v39 == v38 )
              {
                v40 = (*(_QWORD *)(v37 + 0x18 * (*(_QWORD *)(v35 + 0xE80) & 0xFFFLL)) >> 0x19) & 0x3FFFFFFFFFLL;
                if ( v40 == 0x3FFFFFFFFFLL )
                  break;
                v41 = 2LL * v36++;
                *(&v63 + v41) = v40;
                *(&v64 + v41) = *(_QWORD *)(v35 + 0xE80);
              }
              ++*(_QWORD *)(v35 + 0xE80);
            }
            else
            {
              _mm_pause();
            }
          }
          while ( !v36 );
          v24 = a1;
          v42 = 0;
          if ( v36 )
          {
            v43 = &v63;
            while ( 1 )
            {
              v44 = *v43;
              if ( *v43 == v17 )
                break;
              ++v42;
              v43 += 2;
              if ( v42 >= v36 )
              {
                j = v61;
                v28 = (__int64)v58;
                goto LABEL_26;
              }
            }
            v45 = a1 + 0x1E8 * (*v43 & 0xFFF);
            sub_1475FF440(a1, v45 + 0x30);
            v46 = *(_QWORD *)(v45 + 0x30) == v44
               && *(_DWORD *)(v45 + 0xC0)
               && v77 < *(_BYTE *)(v45 + 0xE2)
               && *(_BYTE *)(v45 + 0xE1) != 1;
            v47 = _InterlockedDecrement((volatile signed __int32 *)(v45 + 0xC4));
            if ( !(_WORD)v47 && (v47 & 0xFF000000) != 0 )
              qword_149C78FD8(v45 + 0xC4);
            if ( v46 )
            {
              v48 = HIDWORD(v59);
              v49 = (_QWORD *)(v62 + 0xE30);
              v50 = (__int64 *)(v62 + 0xE38);
              v51 = *(_QWORD *)(v62 + 0xE30);
              *(_QWORD *)(v62 + 0xE30) = 0;
              v52 = *v50;
              sub_1475F3500(v44, v77, v48, a1, *(&v64 + 2 * v42), 0);
              *v49 = v51;
              v17 = a2;
              v24 = a1;
              *v50 = v52;
            }
            for ( j = v61; ; qword_149C78FC8(j, &v60, 4, 0xFFFFFFFFLL) )
            {
              sub_1475FF440(v24, (__int64)v58);
              v53 = *j;
              v54 = *v58;
              v55 = _InterlockedDecrement(v30);
              if ( !(_WORD)v55 && (v55 & 0xFF000000) != 0 )
                qword_149C78FD8(v30);
              v28 = (__int64)v58;
              if ( !v53 || v54 < v17 )
                break;
              v60 = v53;
            }
          }
          else
          {
            _mm_pause();
            j = v61;
            v28 = (__int64)v58;
          }
        }
        v56 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
        if ( v56 )
          v57 = (_BYTE *)(v56 + 0x42);
        else
          v57 = (_BYTE *)(NtCurrentTeb_w() + 0x12E);
        --*v57;
        v72 = __rdtsc();
        result = qword_149C89AA8(v67);
      }
      if ( (_QWORD)v65 )
        return sub_1403A6820((__int64)&v65, v65, (v66 - v65) & 0xFFFFFFFFFFFFFFF8uLL);
    }
    else
    {
      v9 = _InterlockedDecrement(v8);
      if ( !(_WORD)v9 && (v9 & 0xFF000000) != 0 )
        return qword_149C78FD8(v7 + 0xC4);
    }
  }
  return result;
}

// --- End Function: sub_1476044B0 (0x14760494F) ---

// --- Function: sub_147607320 (0x147607320) ---
__int64 __fastcall sub_147607320(volatile signed __int32 *a1, __int64 a2)
{
  __int64 *v2; // r8
  __int64 n4; // rax
  __int64 v4; // rax
  _QWORD v5[4]; // [rsp+0h] [rbp-38h] BYREF
  __int64 v6; // [rsp+20h] [rbp-18h] BYREF

  v5[0] = 1;
  v2 = v5;
  v5[1] = 2;
  v5[2] = 4;
  v5[3] = 8;
  do
  {
    n4 = *v2;
    if ( (*v2 & a2) != 0 )
    {
      if ( --n4 )
      {
        v4 = n4 - 1;
        if ( v4 )
        {
          n4 = v4 - 2;
          if ( n4 )
          {
            if ( n4 == 4 )
              n4 = (unsigned int)_InterlockedExchange(a1 + 0x80051, 0);
          }
          else
          {
            n4 = (unsigned int)_InterlockedDecrement(a1 + 0x80050);
            if ( (unsigned int)n4 > 0xF0000000 )
              __debugbreak();
          }
        }
        else
        {
          n4 = (unsigned int)_InterlockedExchange(a1 + 0x8004F, 0);
        }
      }
      else
      {
        _InterlockedDecrement(a1 + 0x8004E);
      }
    }
    ++v2;
  }
  while ( v2 != &v6 );
  return n4;
}

// --- End Function: sub_147607320 (0x147607320) ---

// --- Function: sub_1476073D0 (0x1476073D0) ---
_QWORD *__fastcall sub_1476073D0(volatile signed __int32 *a1, __int64 a2)
{
  _QWORD *v2; // r8
  _QWORD *result; // rax
  _QWORD v4[4]; // [rsp+0h] [rbp-38h] BYREF
  _QWORD v5[3]; // [rsp+20h] [rbp-18h] BYREF

  v4[0] = 1;
  v2 = v4;
  v4[1] = 2;
  v4[2] = 4;
  v4[3] = 8;
  do
  {
    if ( (*v2 & a2) != 0 )
    {
      switch ( *v2 )
      {
        case 1LL:
          while ( *((_DWORD *)a1 + 0x8004F) )
            _mm_pause();
          _InterlockedIncrement(a1 + 0x8004E);
          break;
        case 2LL:
          while ( *((_DWORD *)a1 + 0x8004E) )
            _mm_pause();
          _InterlockedExchange(a1 + 0x8004F, 1);
          break;
        case 4LL:
          _InterlockedIncrement(a1 + 0x80050);
          break;
        case 8LL:
          _InterlockedExchange(a1 + 0x80051, 1);
          break;
      }
    }
    ++v2;
    result = v5;
  }
  while ( v2 != v5 );
  return result;
}

// --- End Function: sub_1476073D0 (0x1476073D0) ---

// --- Function: sub_147608AD0 (0x147608AD0) ---
__int64 __fastcall sub_147608AD0(__int64 a1, __int64 a2)
{
  volatile signed __int32 *v2; // rdi
  __int64 result; // rax
  signed __int32 v4; // ebx
  signed __int32 v5; // eax
  signed __int32 v6[4]; // [rsp+30h] [rbp-68h] BYREF
  int n0x1D00; // [rsp+40h] [rbp-58h] BYREF
  __int64 v8; // [rsp+44h] [rbp-54h]
  int n2; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v10; // [rsp+50h] [rbp-48h]
  unsigned __int64 v11; // [rsp+58h] [rbp-40h]
  __int64 v12; // [rsp+60h] [rbp-38h]
  __int64 v13; // [rsp+68h] [rbp-30h]

  v2 = (volatile signed __int32 *)(a2 + 0x94);
  result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a2 + 0x94), 0x10000, 0);
  v4 = result;
  if ( (_DWORD)result )
  {
    while ( 1 )
    {
      while ( (v4 & 0xFFFFFF) != 0 )
      {
        v5 = _InterlockedCompareExchange(v2, v4 + 0x1000000, v4);
        if ( v4 == v5 )
        {
          n0x1D00 = 0x1D00;
          v8 = 1;
          n2 = 2;
          v11 = 0;
          v12 = 0;
          v13 = 0;
          v10 = __rdtsc();
          qword_149C89AA0(
            &n0x1D00,
            &word_151752584,
            "CBatchWorkerManager::RLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\JobManager/BatchWorker.cpp",
            0x289);
          HIWORD(n0x1D00) = word_151752584;
          v6[0] = v4 + 0x1000000;
          qword_149C78FC8(v2, v6, 4, 0xFFFFFFFFLL);
          v4 = _InterlockedExchangeAdd(v2, 0xFF000000) - 0x1000000;
          v11 = __rdtsc();
          qword_149C89AA8(&n0x1D00);
        }
        else
        {
          v4 = v5;
        }
      }
      result = (unsigned int)_InterlockedCompareExchange(v2, v4 | 0x10000, v4);
      if ( v4 == (_DWORD)result )
        break;
      v4 = result;
    }
  }
  return result;
}

// --- End Function: sub_147608AD0 (0x147608AD0) ---

// --- Function: sub_147609D40 (0x147609D40) ---
__int64 **__fastcall sub_147609D40(__int64 **a1, __int64 **a2, __int64 a3, __int64 *a4)
{
  __int64 *v5; // rdx
  __int64 *v7; // rcx
  unsigned __int64 v8; // rsi
  __int64 *v10; // rdx
  __int64 v11; // r15
  __int64 v12; // r12
  unsigned __int64 v13; // r14
  __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 v16; // rcx
  __int64 *v17; // rdx
  unsigned __int64 v18; // r15
  __int64 v19; // r14
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 *v22; // rdx
  __int64 *v23; // rax
  __int64 *v24; // rcx
  __int64 **result; // rax
  __int64 *v26; // [rsp+20h] [rbp-60h] BYREF
  __int64 v27; // [rsp+28h] [rbp-58h]
  unsigned __int64 v28; // [rsp+30h] [rbp-50h]
  __int64 *v29; // [rsp+38h] [rbp-48h] BYREF
  __int64 v30; // [rsp+40h] [rbp-40h]
  __int64 v31; // [rsp+48h] [rbp-38h]
  __int64 *v32; // [rsp+50h] [rbp-30h] BYREF
  __int64 v33; // [rsp+58h] [rbp-28h]
  __int64 v34; // [rsp+60h] [rbp-20h]
  __int64 *v35[3]; // [rsp+68h] [rbp-18h] BYREF

  v5 = a1[3];
  v7 = a1[4];
  v8 = *(_QWORD *)(a3 + 0x10) - (_QWORD)v5;
  if ( v8 > (unsigned __int64)v7 >> 1 )
  {
    if ( (((_BYTE)v5 + (_BYTE)v7) & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v7 + 2) >> 1 )
      sub_1402E2EE0(a1, 1u);
    v17 = a1[2];
    a1[3] = (__int64 *)((2LL * (_QWORD)v17 - 1) & (unsigned __int64)a1[3]);
    v18 = (unsigned __int64)a1[3] + (_QWORD)a1[4];
    v19 = ((unsigned __int64)v17 + 0xFFFFFFFF) & (v18 >> 1);
    if ( !a1[1][v19] )
      a1[1][v19] = sub_1402A65A0(0x10u);
    v20 = *a4;
    v21 = a1[1][v19];
    v33 = 0;
    v30 = 0;
    v27 = 0;
    *(_QWORD *)(v21 + 8 * (v18 & 1)) = v20;
    a1[4] = (__int64 *)((char *)a1[4] + 1);
    v22 = a1[3];
    v23 = a1[4];
    v32 = *a1;
    v34 = (__int64)v23 + (_QWORD)v22;
    v31 = (__int64)v23 + (_QWORD)v22 - 1;
    v29 = v32;
    v26 = v32;
    v28 = (unsigned __int64)v22 + v8;
    sub_1475E8960(v35, (__int64)&v26, &v29, (__int64)&v32);
  }
  else
  {
    if ( ((unsigned __int8)v5 & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v7 + 2) >> 1 )
      sub_1402E2EE0(a1, 1u);
    v10 = a1[2];
    v11 = (unsigned __int64)a1[3] & (2LL * (_QWORD)v10 - 1);
    a1[3] = (__int64 *)v11;
    if ( !v11 )
      v11 = 2LL * (_QWORD)v10;
    v12 = v11 - 1;
    v13 = ((unsigned __int64)v10 + 0xFFFFFFFF) & ((unsigned __int64)(v11 - 1) >> 1);
    if ( !a1[1][v13] )
      a1[1][v13] = sub_1402A65A0(0x10u);
    v14 = *a4;
    v15 = a1[1];
    v31 = v11;
    v34 = v11 - 1;
    v16 = v15[v13];
    v27 = 0;
    v30 = 0;
    v33 = 0;
    *(_QWORD *)(v16 + 8 * (v12 & 1)) = v14;
    a1[3] = (__int64 *)v12;
    a1[4] = (__int64 *)((char *)a1[4] + 1);
    v26 = *a1;
    v29 = v26;
    v32 = v26;
    v28 = v11 + v8;
    sub_1475E8960(v35, (__int64)&v32, &v29, (__int64)&v26);
  }
  v24 = a1[3];
  *a2 = *a1;
  result = a2;
  a2[2] = (__int64 *)((char *)v24 + v8);
  a2[1] = 0;
  return result;
}

// --- End Function: sub_147609D40 (0x147609D40) ---

// --- Function: WaitForSingleObject_w (0x147609F80) ---
DWORD __fastcall sub_147609F80(HANDLE *a1)
{
  return WaitForSingleObject(*a1, 0xFFFFFFFF);
}

// --- End Function: WaitForSingleObject_w (0x147609F80) ---

// --- Function: sub_147667110 (0x147667110) ---
__int64 sub_147667110()
{
  __int64 result; // rax

  if ( qword_149C8DFE8 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE8 + 0x28LL))(qword_149C8DFE8);
  return result;
}

// --- End Function: sub_147667110 (0x147667110) ---

// --- Function: sub_14769C360 (0x14769C360) ---
__int64 __fastcall sub_14769C360(__int64 a1, __int64 *a2, __int64 a3)
{
  double v3; // xmm0_8
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int128 v9; // xmm11
  __int128 v10; // xmm12
  __int128 v11; // xmm13
  unsigned __int64 v13; // rdi
  unsigned __int64 *v14; // r9
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // r13
  unsigned __int64 v18; // r12
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // r15
  unsigned __int64 v21; // r14
  unsigned __int64 v22; // rbp
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rsi
  unsigned __int64 v25; // r8
  unsigned __int64 v26; // rdi
  unsigned __int64 v27; // rbx
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // r11
  bool v30; // cf
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r8
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rdx
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // rdx
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rdx
  unsigned __int64 v44; // rax
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rax
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // rdx
  unsigned __int64 v50; // rax
  unsigned __int64 v51; // rcx
  unsigned __int64 v52; // r10
  unsigned __int64 v53; // r9
  unsigned __int64 v54; // rdx
  unsigned __int64 v55; // rax
  unsigned __int64 v56; // r8
  unsigned __int64 v57; // rcx
  unsigned __int64 v58; // rdx
  unsigned __int64 v59; // rax
  unsigned __int64 v60; // rcx
  unsigned __int64 v61; // rdx
  unsigned __int64 v62; // rax
  unsigned __int64 v63; // r13
  unsigned __int64 v64; // rcx
  __int64 v65; // rcx
  unsigned __int64 v66; // r13
  bool v67; // zf
  unsigned __int64 v68; // r13
  unsigned __int64 v69; // rbp
  unsigned __int64 v70; // r12
  unsigned __int64 v71; // rdi
  unsigned __int64 *v72; // r8
  unsigned __int64 v73; // rsi
  __int64 n8; // r9
  unsigned __int64 v75; // rax
  unsigned __int64 v76; // rcx
  unsigned __int64 v77; // rdx
  unsigned __int64 v78; // rax
  unsigned __int64 v79; // rcx
  unsigned __int64 v80; // rdx
  unsigned __int64 v81; // rax
  unsigned __int64 v82; // rcx
  unsigned __int64 v83; // rdx
  unsigned __int64 v84; // rax
  unsigned __int64 v85; // rcx
  unsigned __int64 v86; // rdx
  unsigned __int64 v87; // rax
  unsigned __int64 v88; // rcx
  unsigned __int64 v89; // rbx
  unsigned __int64 *v90; // r8
  unsigned __int64 v91; // rdx
  __int64 n2_1; // r15
  unsigned __int64 v93; // r12
  unsigned __int64 v94; // rax
  unsigned __int64 v95; // rcx
  unsigned __int64 v96; // rdx
  unsigned __int64 v97; // rax
  unsigned __int64 v98; // rcx
  unsigned __int64 v99; // rdx
  unsigned __int64 v100; // rax
  unsigned __int64 v101; // rcx
  unsigned __int64 v102; // rdx
  unsigned __int64 v103; // rax
  unsigned __int64 v104; // rcx
  unsigned __int64 v105; // rdx
  unsigned __int64 v106; // rax
  unsigned __int64 v107; // rcx
  __int64 v108; // r14
  double v109; // xmm13_8
  double v110; // xmm12_8
  double v111; // xmm11_8
  double v112; // xmm10_8
  double v113; // xmm9_8
  double v114; // xmm8_8
  double v115; // xmm7_8
  double v116; // xmm6_8
  double v117; // xmm0_8
  float v118; // xmm2_4
  const char *v120; // [rsp+38h] [rbp-150h]
  double v121; // [rsp+40h] [rbp-148h]
  __int64 v122; // [rsp+90h] [rbp-F8h]
  __int64 n2; // [rsp+98h] [rbp-F0h]
  unsigned __int64 v124; // [rsp+A0h] [rbp-E8h]
  unsigned __int64 v125; // [rsp+A8h] [rbp-E0h]
  __int128 v126[9]; // [rsp+B0h] [rbp-D8h] BYREF
  _QWORD *v130; // [rsp+1A8h] [rbp+20h]

  v126[8] = v4;
  v126[7] = v5;
  v126[6] = v6;
  v126[5] = v7;
  v126[4] = v8;
  v126[3] = v9;
  v126[2] = v10;
  v126[1] = v11;
  v13 = *(_QWORD *)(a1 + 8LL * ((*(_DWORD *)(a1 + 0x890) + 0x1F) % 0x20) + 8);
  (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)a3 + 0xD0LL))(a3, v13);
  v14 = (unsigned __int64 *)(a1 + 0x10);
  v122 = 0;
  v130 = (_QWORD *)(a1 + 0x10);
  v15 = v13;
  n2 = 2;
  while ( 1 )
  {
    v16 = v14[0xFFFFFFFF];
    v17 = v14[2];
    v18 = v14[3];
    v19 = v16;
    if ( v16 >= v13 )
      v19 = v13;
    v20 = v14[4];
    v21 = v14[5];
    v22 = v14[6];
    v23 = v14[0xFFFFFFFF];
    if ( v15 >= v16 )
      v23 = v15;
    v24 = v14[7];
    v25 = *v14;
    v26 = v14[8];
    v27 = v14[9];
    v28 = *v14;
    if ( *v14 >= v19 )
      v28 = v19;
    v29 = v14[0xA];
    v30 = v23 < v25;
    *(_QWORD *)&v126[0] = v14[2];
    v31 = v25;
    v32 = v14[1];
    if ( !v30 )
      v31 = v23;
    v33 = v14[1];
    if ( v32 >= v28 )
      v33 = v28;
    v34 = v14[1];
    if ( v31 >= v32 )
      v34 = v31;
    v35 = v17;
    if ( v17 >= v33 )
      v35 = v33;
    v36 = v17;
    if ( v34 >= v17 )
      v36 = v34;
    v37 = v18;
    if ( v18 >= v35 )
      v37 = v35;
    v38 = v18;
    if ( v36 >= v18 )
      v38 = v36;
    v39 = v20;
    if ( v20 >= v37 )
      v39 = v37;
    v40 = v20;
    if ( v38 >= v20 )
      v40 = v38;
    v41 = v21;
    if ( v21 >= v39 )
      v41 = v39;
    v42 = v21;
    if ( v40 >= v21 )
      v42 = v40;
    v43 = v22;
    if ( v22 >= v41 )
      v43 = v41;
    v44 = v22;
    if ( v42 >= v22 )
      v44 = v42;
    v45 = v24;
    if ( v24 >= v43 )
      v45 = v43;
    v46 = v24;
    if ( v44 >= v24 )
      v46 = v44;
    v47 = v26;
    if ( v26 >= v45 )
      v47 = v45;
    v48 = v26;
    if ( v46 >= v26 )
      v48 = v46;
    v49 = v27;
    if ( v27 >= v47 )
      v49 = v47;
    v50 = v27;
    if ( v48 >= v27 )
      v50 = v48;
    v51 = v29;
    if ( v29 >= v49 )
      v51 = v49;
    v52 = v14[0xB];
    v53 = v14[0xC];
    v54 = v29;
    if ( v50 >= v29 )
      v54 = v50;
    v55 = v52;
    v56 = v130[0xD];
    if ( v52 >= v51 )
      v55 = v51;
    v57 = v52;
    if ( v54 >= v52 )
      v57 = v54;
    v58 = v53;
    if ( v53 >= v55 )
      v58 = v55;
    v59 = v53;
    if ( v57 >= v53 )
      v59 = v57;
    v60 = v130[0xD];
    if ( v56 >= v58 )
      v60 = v58;
    v61 = v130[0xD];
    if ( v59 >= v56 )
      v61 = v59;
    v62 = v130[0xE];
    v63 = v62;
    if ( v62 >= v60 )
      v63 = v60;
    v125 = v63;
    v64 = v130[0xE];
    if ( v61 >= v62 )
      v64 = v61;
    v124 = v64;
    v65 = *v130
        + v130[0xFFFFFFFF]
        + v130[1]
        + *(_QWORD *)&v126[0]
        + v18
        + v20
        + v21
        + v22
        + v24
        + v26
        + v27
        + v29
        + v52
        + v53
        + v62
        + v56;
    v14 = v130 + 0x10;
    v66 = v65 + v122;
    v130 += 0x10;
    v67 = n2-- == 1;
    v122 += v65;
    if ( v67 )
      break;
    v13 = v125;
    v15 = v124;
  }
  v68 = v66 >> 5;
  v69 = 0;
  v70 = 0;
  v71 = *(_QWORD *)(a1 + 0x108);
  v72 = (unsigned __int64 *)(a1 + 0x308);
  v73 = *(_QWORD *)(a1 + 0x308);
  n8 = 8;
  do
  {
    v75 = v72[0xFFFFFFC0];
    v76 = *v72;
    v77 = v72[0xFFFFFFC1];
    v72 += 8;
    if ( v75 >= v71 )
      v75 = v71;
    v71 = v72[0xFFFFFFBF];
    if ( v73 >= v76 )
      v76 = v73;
    v73 = v72[0xFFFFFFFF];
    if ( v77 >= v75 )
      v77 = v75;
    v78 = v72[0xFFFFFFF9];
    if ( v76 >= v78 )
      v78 = v76;
    v79 = v72[0xFFFFFFBA];
    if ( v79 >= v77 )
      v79 = v77;
    v80 = v72[0xFFFFFFFA];
    if ( v78 >= v80 )
      v80 = v78;
    v81 = v72[0xFFFFFFBB];
    if ( v81 >= v79 )
      v81 = v79;
    v82 = v72[0xFFFFFFFB];
    if ( v80 >= v82 )
      v82 = v80;
    v83 = v72[0xFFFFFFBC];
    if ( v83 >= v81 )
      v83 = v81;
    v84 = v72[0xFFFFFFFC];
    if ( v82 >= v84 )
      v84 = v82;
    v85 = v72[0xFFFFFFBD];
    if ( v85 >= v83 )
      v85 = v83;
    v86 = v72[0xFFFFFFFD];
    if ( v84 >= v86 )
      v86 = v84;
    v87 = v72[0xFFFFFFBE];
    if ( v87 >= v85 )
      v87 = v85;
    v88 = v72[0xFFFFFFFE];
    if ( v86 >= v88 )
      v88 = v86;
    if ( v71 >= v87 )
      v71 = v87;
    if ( v88 >= v73 )
      v73 = v88;
    v70 += v72[0x38] + v72[0x39] + v72[0x3A] + v72[0x3B] + v72[0x3C] + v72[0x3D] + v72[0x3E] + v72[0x3F];
    --n8;
  }
  while ( n8 );
  v89 = *(_QWORD *)(a1 + 0x708);
  v90 = (unsigned __int64 *)(a1 + 0x788);
  v91 = *(_QWORD *)(a1 + 0x788);
  n2_1 = 2;
  v93 = v70 >> 6;
  do
  {
    v94 = v90[0xFFFFFFF0];
    v95 = *v90;
    v90 += 8;
    if ( v94 >= v89 )
      v94 = v89;
    v89 = v90[0xFFFFFFEF];
    if ( v91 >= v95 )
      v95 = v91;
    v96 = v90[0xFFFFFFE9];
    if ( v96 >= v94 )
      v96 = v94;
    v97 = v90[0xFFFFFFF9];
    if ( v95 >= v97 )
      v97 = v95;
    v98 = v90[0xFFFFFFEA];
    if ( v98 >= v96 )
      v98 = v96;
    v99 = v90[0xFFFFFFFA];
    if ( v97 >= v99 )
      v99 = v97;
    v100 = v90[0xFFFFFFEB];
    if ( v100 >= v98 )
      v100 = v98;
    v101 = v90[0xFFFFFFFB];
    if ( v99 >= v101 )
      v101 = v99;
    v102 = v90[0xFFFFFFEC];
    if ( v102 >= v100 )
      v102 = v100;
    v103 = v90[0xFFFFFFFC];
    if ( v101 >= v103 )
      v103 = v101;
    v104 = v90[0xFFFFFFED];
    if ( v104 >= v102 )
      v104 = v102;
    v105 = v90[0xFFFFFFFD];
    if ( v103 >= v105 )
      v105 = v103;
    v106 = v90[0xFFFFFFEE];
    if ( v106 >= v104 )
      v106 = v104;
    v107 = v90[0xFFFFFFFE];
    if ( v105 >= v107 )
      v107 = v105;
    v91 = v90[0xFFFFFFFF];
    if ( v89 >= v106 )
      v89 = v106;
    if ( v107 >= v91 )
      v91 = v107;
    v69 += v90[8] + v90[9] + v90[0xA] + v90[0xB] + v90[0xC] + v90[0xD] + v90[0xE] + v90[0xF];
    --n2_1;
  }
  while ( n2_1 );
  v108 = a3;
  *(double *)(a1 + 0x8A0) = v3 * 0.1111111111111111 + *(double *)(a1 + 0x8A0) * 0.8888888888888888;
  v109 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)a3 + 0xD0LL))(a3, v91);
  v110 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v69 >> 4);
  v111 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v89);
  v112 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v73);
  v113 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v93);
  v114 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v71);
  v115 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v124);
  v116 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v68);
  v117 = (*(double (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v108 + 0xD0LL))(v108, v125);
  v118 = *(float *)(a1 + 0x8A8);
  v121 = *(double *)(a1 + 0x8A0);
  v120 = *(const char **)a1;
  v126[0] = xmmword_1482F0B30;
  return sub_1402C7510(
           a2,
           10.0,
           v118,
           1.3,
           v126,
           0,
           (__int64)"%s: %4.1f  %3.1f |%3.1f| %3.1f [%3.1f |%3.1f| %3.1f] [[%3.1f |%3.1f| %3.1f]]ms",
           v120,
           v121,
           v117,
           v116,
           v115,
           v114,
           v113,
           v112,
           v111,
           v110,
           v109);
}

// --- End Function: sub_14769C360 (0x14769C360) ---

// --- Function: sub_1476AEAA0 (0x1476AEAA0) ---
__int64 __fastcall sub_1476AEAA0(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 v4; // rdx
  __int64 v5; // rax
  int n0x2800; // [rsp+60h] [rbp-9h] BYREF
  __int64 v8; // [rsp+64h] [rbp-5h]
  int v9; // [rsp+6Ch] [rbp+3h]
  unsigned __int64 v10; // [rsp+70h] [rbp+7h]
  unsigned __int64 v11; // [rsp+78h] [rbp+Fh]
  __int64 v12; // [rsp+80h] [rbp+17h]
  __int64 v13; // [rsp+88h] [rbp+1Fh]

  v9 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  n0x2800 = 0x2800;
  v8 = 1;
  v10 = __rdtsc();
  qword_149C89AA0(
    &n0x2800,
    &word_1517F95AC,
    "CPhysicsThreadTask::EnsureStepDone",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
    0x423);
  HIWORD(n0x2800) = word_1517F95AC;
  *(_QWORD *)(a1 + 0x30) = 0;
  if ( *(_DWORD *)(a1 + 0xC) )
  {
    while ( *(float *)(a1 + 0x10) > 0.00000011920929 || *(_DWORD *)(a1 + 0x14) )
    {
      LOBYTE(v2) = 7;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E080 + 0x120LL))(qword_149C8E080, v2);
      LOBYTE(v3) = 0x28;
      sub_1403DAC90((_DWORD *)(a1 + 0x60), v3, (__int64)"Physics Ensure Done");
      LOBYTE(v4) = 7;
      v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E080 + 0x128LL))(qword_149C8E080, v4);
      *(_QWORD *)(a1 + 0x30) += v5;
      sub_147705E60(a1 + 0x88, v5);
    }
    if ( *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0xF0LL))(qword_149C8DF40) + 0x208) )
    {
      sub_14769C360(a1 + 0x88, (__int64 *)qword_149C8E018, qword_149C8E080);
      sub_14769C360(a1 + 0x938, (__int64 *)qword_149C8E018, qword_149C8E080);
    }
  }
  v11 = __rdtsc();
  return qword_149C89AA8(&n0x2800);
}

// --- End Function: sub_1476AEAA0 (0x1476AEAA0) ---

// --- Function: sub_1476C4AD0 (0x1476C4AD0) ---
int __fastcall sub_1476C4AD0(char *Buffer, size_t BufferCount, unsigned __int64 n0x40000000)
{
  const char *p_%u.%u_MB; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-A8h]
  int v11; // [rsp+28h] [rbp-A0h]
  __m256 DstBuf_; // [rsp+40h] [rbp-88h] BYREF
  __m256 DstBuf__1; // [rsp+60h] [rbp-68h] BYREF
  __m256 v14; // [rsp+80h] [rbp-48h]

  DstBuf_ = (__m256)0LL;
  if ( n0x40000000 >= 0x10000000000LL )
  {
    p_%u.%u_MB = "%u.%u TB";
    v7 = (0xA * (n0x40000000 & 0xFFFFFFFFFFLL)) >> 0x28;
    v8 = n0x40000000 >> 0x28;
LABEL_7:
    v11 = v7;
    v10 = v8;
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, p_%u.%u_MB, v10, v11);
    goto LABEL_11;
  }
  if ( n0x40000000 >= 0x40000000 )
  {
    p_%u.%u_MB = "%u.%u GB";
    v7 = (0xA * (n0x40000000 & 0x3FFFFFFF)) >> 0x1E;
    v8 = n0x40000000 >> 0x1E;
    goto LABEL_7;
  }
  if ( n0x40000000 >= 0x100000 )
  {
    p_%u.%u_MB = "%u.%u MB";
    v7 = (0xA * (n0x40000000 & 0xFFFFF)) >> 0x14;
    v8 = n0x40000000 >> 0x14;
    goto LABEL_7;
  }
  if ( n0x40000000 < 0x400 )
  {
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, "%u byte(s)", n0x40000000);
  }
  else
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf_,
      0x20u,
      0xFFFFFFFFFFFFFFFFuLL,
      "%u.%u KB",
      n0x40000000 >> 0xA,
      (0xA * (n0x40000000 & 0x3FF)) >> 0xA);
  }
LABEL_11:
  DstBuf__1 = (__m256)0LL;
  v14 = (__m256)0LL;
  if ( byte_1517F765B )
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf__1,
      0x40u,
      0xFFFFFFFFFFFFFFFFuLL,
      " (Started with < %u GB of available system memory.)",
      8);
  }
  __asm { vzeroupper }
  return snprintf_s(
           Buffer,
           BufferCount,
           0xFFFFFFFFFFFFFFFFuLL,
           "Out of system memory. Failed to allocate %s (%zu).%s",
           (const char *)&DstBuf_,
           n0x40000000,
           (const char *)&DstBuf__1);
}

// --- End Function: sub_1476C4AD0 (0x1476C4AD0) ---

// --- Function: sub_1476EAA00 (0x1476EAA00) ---
__int64 __fastcall sub_1476EAA00(__int64 a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)qword_149C8DF40;
  if ( *(_DWORD *)(a1 + 0xC) )
  {
    *(_DWORD *)((*(__int64 (**)(void))(v2 + 0xF0))() + 0x288) = 0;
    *(_DWORD *)(a1 + 0xC) = 0;
    while ( *(_DWORD *)(a1 + 0x14) )
      Sleep(0);
    return 1;
  }
  else
  {
    *(_DWORD *)((*(__int64 (**)(void))(v2 + 0xF0))() + 0x288) = 0;
    return 0;
  }
}

// --- End Function: sub_1476EAA00 (0x1476EAA00) ---

// --- Function: sub_1476EF200 (0x1476EF200) ---
void __fastcall sub_1476EF200(__int64 a1)
{
  HWND hWnd_1; // rcx
  HWND hwnd; // rbx
  HWND hWnd; // rax
  HACCEL hAccTable; // rdx
  int n0x1600_1; // [rsp+30h] [rbp-79h] BYREF
  __int64 v7; // [rsp+34h] [rbp-75h]
  int v8; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v9; // [rsp+40h] [rbp-69h]
  unsigned __int64 v10; // [rsp+48h] [rbp-61h]
  __int64 v11; // [rsp+50h] [rbp-59h]
  __int64 v12; // [rsp+58h] [rbp-51h]
  int n0x1600; // [rsp+80h] [rbp-29h] BYREF
  __int64 v14; // [rsp+84h] [rbp-25h]
  int v15; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v16; // [rsp+90h] [rbp-19h]
  unsigned __int64 v17; // [rsp+98h] [rbp-11h]
  __int64 v18; // [rsp+A0h] [rbp-9h]
  __int64 v19; // [rsp+A8h] [rbp-1h]
  struct tagMSG Msg; // [rsp+D0h] [rbp+27h] BYREF

  hWnd_1 = *(HWND *)(a1 + 0x930);
  if ( hWnd_1 && IsWindow(hWnd_1) )
  {
    v15 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    n0x1600 = 0x1600;
    v14 = 1;
    v16 = __rdtsc();
    qword_149C89AA0(
      &n0x1600,
      &word_1517F95D8,
      "CSystem::PumpMessages",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
      0x95E);
    hwnd = *(HWND *)(a1 + 0x930);
    HIWORD(n0x1600) = word_1517F95D8;
    while ( PeekMessageA(&Msg, hwnd, 0, 0, PM_REMOVE) )
    {
      hWnd = GetAncestor(hwnd, GA_ROOT);
      hAccTable = *(HACCEL *)(a1 + 0x4088);
      if ( !hAccTable || !TranslateAcceleratorA(hWnd, hAccTable, &Msg) )
      {
        n0x1600_1 = 0x1600;
        v7 = 1;
        v8 = 0;
        v10 = 0;
        v11 = 0;
        v12 = 0;
        v9 = __rdtsc();
        qword_149C89AA0(
          &n0x1600_1,
          &word_1517F95DC,
          "TranslateMessage",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
          0x96D);
        HIWORD(n0x1600_1) = word_1517F95DC;
        qword_149C89AF0(Msg.message, &unk_1517F95E0, "Message");
        TranslateMessage(&Msg);
        v10 = __rdtsc();
        qword_149C89AA8(&n0x1600_1);
        n0x1600_1 = 0x1600;
        v7 = 1;
        v8 = 0;
        v10 = 0;
        v11 = 0;
        v12 = 0;
        v9 = __rdtsc();
        qword_149C89AA0(
          &n0x1600_1,
          &word_1517F95E4,
          "DispatchMessage",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
          0x973);
        HIWORD(n0x1600_1) = word_1517F95E4;
        qword_149C89AF0(Msg.message, &unk_1517F95E8, "Message");
        DispatchMessageA(&Msg);
        v10 = __rdtsc();
        qword_149C89AA8(&n0x1600_1);
      }
    }
    v17 = __rdtsc();
    qword_149C89AA8(&n0x1600);
  }
}

// --- End Function: sub_1476EF200 (0x1476EF200) ---

// --- Function: sub_1476EFE10 (0x1476EFE10) ---
void __fastcall sub_1476EFE10(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1476C4AD0(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1476EFE10 (0x1476EFE10) ---

// --- Function: sub_147700A00 (0x147700A00) ---
__int64 __fastcall sub_147700A00(float *a1, __int64 a2)
{
  float v2; // xmm1_4
  __int64 v4; // r14
  float v5; // xmm9_4
  __int64 v6; // rdx
  __int128 v10; // kr00_16
  __int128 v13; // kr00_16
  LARGE_INTEGER v15; // rsi
  __int64 v16; // rdi
  float (__fastcall *v17)(__int64, LONGLONG); // rbx
  LARGE_INTEGER v18; // rax
  _QWORD *v19; // rax
  __int64 v22; // rax
  __int64 result; // rax
  __int64 v24; // [rsp+A0h] [rbp+8h] BYREF
  char v25; // [rsp+B0h] [rbp+18h] BYREF
  __int64 v26; // [rsp+B8h] [rbp+20h] BYREF

  LOBYTE(a2) = 3;
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E080 + 0x120LL))(qword_149C8E080, a2);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0xF0LL))(qword_149C8DF40);
  v5 = 0.89999998 * *(float *)(v4 + 0xE0);
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v24);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0xA0LL))(qword_149C8DFB8);
  if ( v2 > 0.00000011920929 )
    *a1 = v2 + *a1;
  do
  {
    _XMM0 = *(unsigned int *)a1;
    if ( *(float *)&_XMM0 <= 0.00000011920929 )
      break;
    if ( *(_DWORD *)(v4 + 0xEC) )
    {
      __asm { vminss  xmm6, xmm0, dword ptr [r14+0E0h] }
      v10 = *(unsigned int *)a1;
      *(float *)&v10 = *(float *)&_XMM0 - *(float *)&_XMM6;
      _XMM0 = v10;
      __asm { vmaxss  xmm0, xmm0, xmm7 }
      *a1 = *(float *)&_XMM0;
      *(_DWORD *)(v4 + 0x28C) = 1;
      if ( *(float *)&_XMM6 <= 0.0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF40 + 0x1C8LL))(qword_149C8DF40, 1);
    }
    else
    {
      *(float *)&_XMM6 = *a1;
      v13 = *(unsigned int *)a1;
      *(float *)&v13 = *(float *)&_XMM0 - *(float *)&_XMM0;
      _XMM0 = v13;
      __asm { vmaxss  xmm0, xmm0, xmm7 }
      *a1 = *(float *)&_XMM0;
      *(_DWORD *)(v4 + 0x28C) = 1;
    }
    v15 = sub_1403E7AE0();
    (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)qword_149C8DF40 + 0x190LL))(
      qword_149C8DF40,
      *(_QWORD *)qword_149C8DF40,
      0x19F);
    v16 = qword_149C8DF80;
    v17 = *(float (__fastcall **)(__int64, LONGLONG))(*(_QWORD *)qword_149C8DF80 + 0xC0LL);
    v18 = sub_1403E7AE0();
    if ( v17(v16, v18.QuadPart - v15.QuadPart) <= (float)(*(float *)&_XMM6 * 0.89999998) )
      a1[1] = 0.0;
    else
      ++*((_DWORD *)a1 + 1);
    v19 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(
                      qword_149C8DF80,
                      &v25);
    sub_14059CA60(v19, &v26, &v24);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  }
  while ( *(float *)&_XMM1 <= v5 );
  LOBYTE(v6) = 3;
  v22 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E080 + 0x128LL))(qword_149C8E080, v6);
  sub_147705E60(a1 + 4, v22);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0xF0LL))(qword_149C8DF40);
  if ( *(_DWORD *)(result + 0x208) )
    return sub_14769C360((__int64)(a1 + 4), (__int64 *)qword_149C8E018, qword_149C8E080);
  return result;
}

// --- End Function: sub_147700A00 (0x147700A00) ---

// --- Function: sub_1477014D0 (0x1477014D0) ---
void __fastcall sub_1477014D0(__int64 a1)
{
  LARGE_INTEGER v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // rcx
  LARGE_INTEGER v5; // rax

  v2 = sub_1403E7AE0();
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 0x18) + 0x20LL);
  if ( v3 )
  {
    if ( *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0xF0LL))(v3) + 0x384) )
    {
      v4 = *(_QWORD *)(a1 + 0xAB0);
      if ( v4 )
        sub_1476AEAA0(v4);
    }
  }
  v5 = sub_1403E7AE0();
  *(float *)(a1 + 0x2ADC) = (*(float (__fastcall **)(__int64, LONGLONG))(*(_QWORD *)qword_149C8DF80 + 0xC0LL))(
                              qword_149C8DF80,
                              v5.QuadPart - v2.QuadPart);
}

// --- End Function: sub_1477014D0 (0x1477014D0) ---

// --- Function: sub_147703E00 (0x1477045F0) ---
__int64 __fastcall sub_147703E00(char *a1, unsigned int a2, int a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm8
  int v5; // r13d
  unsigned int v6; // r15d
  char *v7; // rsi
  __int64 v8; // rdi
  void (__fastcall *v9)(__int64); // rbx
  _LocaleUpdate *v12; // rdi
  void (__fastcall *v13)(_LocaleUpdate *, void **); // rbx
  __int64 v14; // rcx
  __int64 v15; // rcx
  int n2_1; // eax
  __int64 *v17; // r12
  __int64 *v18; // r14
  __int64 v19; // rbx
  HANDLE hThread; // rdi
  __int64 v21; // r12
  __int64 v22; // rcx
  __int64 v23; // rax
  float v24; // xmm7_4
  __int64 v25; // rdi
  unsigned int v26; // eax
  float v27; // xmm1_4
  float v28; // kr00_4
  __int64 v29; // rcx
  __int64 v30; // rcx
  char v31; // r14
  __int64 v32; // rcx
  char v33; // al
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  int v37; // ebx
  char *v38; // rax
  char i; // cl
  __int64 v40; // rbx
  void (__fastcall *v41)(__int64, __m256 *); // rdi
  int v42; // edx
  __m256 *v43; // rax
  LARGE_INTEGER v44; // rbx
  __int64 v45; // rcx
  __int64 v46; // rcx
  LARGE_INTEGER v47; // rax
  __int64 v48; // rcx
  __int64 v49; // rax
  __int64 v50; // rdi
  void (__fastcall *v51)(__int64, __int64); // rbx
  __int64 v52; // rax
  __int64 v53; // rcx
  __int64 v54; // rax
  __int64 v55; // rcx
  __int64 v56; // rcx
  __int64 v57; // rcx
  __int64 v58; // rcx
  __int64 v59; // rcx
  __int64 v60; // rcx
  __int64 v61; // rdx
  __int64 v62; // rcx
  __int64 v63; // rcx
  __int64 v64; // rax
  __int64 v65; // rdi
  void (__fastcall *v66)(__int64); // rbx
  __int64 v69; // rdi
  void (__fastcall *v70)(__int64); // rbx
  __int64 v73; // r12
  __int64 v76; // rcx
  __int64 v77; // rcx
  __int64 v78; // rcx
  __int64 v79; // rdi
  void (__fastcall *v80)(__int64); // rbx
  void (__fastcall ***v83)(_QWORD); // rcx
  void (__fastcall ***v84)(_QWORD); // rax
  __int64 v85; // r8
  __int64 v86; // r9
  void (__fastcall ***v87)(_QWORD); // rdi
  void (__fastcall *v88)(_QWORD); // rbx
  __int64 v91; // rcx
  __int64 v92; // rax
  __int64 v93; // rdi
  void (__fastcall *v94)(__int64); // rbx
  __int64 v97; // rcx
  __int64 v98; // rcx
  float v99; // xmm6_4
  __int64 v100; // rbx
  __int64 v105; // rdx
  __int64 n0x19F; // r8
  __int64 *v107; // rcx
  __int64 v108; // rax
  __int64 v109; // r8
  __int64 v110; // rax
  __int64 v111; // rdi
  void (__fastcall *v112)(__int64); // rbx
  __int64 v115; // rcx
  __int64 v116; // rcx
  __int64 v117; // rcx
  float *v118; // rbx
  __int64 v121; // rdx
  __int64 v122; // rdx
  __int64 v123; // rcx
  char *v124; // rbx
  __int64 v125; // rax
  _QWORD *v126; // rax
  __int64 v127; // rcx
  __int64 v128; // rcx
  LONGLONG v129; // rbx
  LARGE_INTEGER v130; // rdi
  char *v131; // rdi
  char *v132; // rbx
  _QWORD *v133; // rax
  char *v134; // rdx
  char *v135; // r10
  signed __int64 v136; // r8
  signed __int64 v137; // r9
  char *v138; // rcx
  __m128 v139; // xmm0
  __int128 v141; // kr00_16
  _BYTE *v142; // rdx
  __int64 v144; // rcx
  __int64 v145; // rcx
  unsigned __int64 v146; // rbx
  __int64 v147; // rcx
  __int64 v148; // rdi
  __int64 v149; // rax
  unsigned int n0x80; // eax
  __int64 v151; // rdx
  __int64 v152; // rdi
  __int64 v155; // rax
  void (__fastcall *v156)(__int64, void *, __int64); // rbx
  void (__fastcall *v157)(__int64, void *, __int64); // rbx
  void (__fastcall *v158)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v159)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v160)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v161)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v162)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v163)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v164)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v165)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v166)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v167)(__int64, void *, __int64); // rbx
  void (__fastcall *v168)(__int64, void *, __int64); // rbx
  void (__fastcall *v169)(__int64, void *, __int64); // rbx
  void (__fastcall *v170)(__int64, void *, __int64); // rbx
  void (__fastcall *v171)(__int64, void *, __int64); // rbx
  void (__fastcall *v172)(__int64, char *, __int64); // rbx
  const void *v174; // [rsp+48h] [rbp-C0h] BYREF
  __int64 n2_2; // [rsp+50h] [rbp-B8h]
  void *v176; // [rsp+58h] [rbp-B0h] BYREF
  char *v177; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v178; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v179; // [rsp+70h] [rbp-98h] BYREF
  void *v180; // [rsp+78h] [rbp-90h] BYREF
  void *v181; // [rsp+80h] [rbp-88h] BYREF
  void *v182; // [rsp+88h] [rbp-80h] BYREF
  void *v183; // [rsp+90h] [rbp-78h] BYREF
  void *v184; // [rsp+98h] [rbp-70h] BYREF
  void *v185; // [rsp+A0h] [rbp-68h] BYREF
  void *v186; // [rsp+A8h] [rbp-60h] BYREF
  void *v187; // [rsp+B0h] [rbp-58h] BYREF
  void *v188; // [rsp+B8h] [rbp-50h] BYREF
  void *v189; // [rsp+C0h] [rbp-48h] BYREF
  void *v190; // [rsp+C8h] [rbp-40h] BYREF
  void *v191; // [rsp+D0h] [rbp-38h] BYREF
  void *v192; // [rsp+D8h] [rbp-30h] BYREF
  void *v193; // [rsp+E0h] [rbp-28h] BYREF
  void *v194; // [rsp+E8h] [rbp-20h] BYREF
  void *v195; // [rsp+F0h] [rbp-18h] BYREF
  char n5; // [rsp+F8h] [rbp-10h]
  __int64 v197; // [rsp+100h] [rbp-8h] BYREF
  void (__fastcall *n2)(__int64, __int64 *, _QWORD); // [rsp+108h] [rbp+0h]
  __int64 v199; // [rsp+110h] [rbp+8h]
  __int64 v200; // [rsp+118h] [rbp+10h]
  int n0x10000; // [rsp+120h] [rbp+18h]
  __int64 v202; // [rsp+128h] [rbp+20h]
  __int64 v203; // [rsp+130h] [rbp+28h]
  __int64 v204; // [rsp+138h] [rbp+30h]
  __int64 v205; // [rsp+140h] [rbp+38h]
  __int64 v206; // [rsp+148h] [rbp+40h]
  __int64 v207; // [rsp+150h] [rbp+48h]
  __int64 v208; // [rsp+158h] [rbp+50h]
  __int64 v209; // [rsp+160h] [rbp+58h]
  __int64 v210; // [rsp+168h] [rbp+60h]
  __int64 v211; // [rsp+170h] [rbp+68h]
  __int64 v212; // [rsp+178h] [rbp+70h]
  __int64 v213; // [rsp+180h] [rbp+78h]
  __int64 v214; // [rsp+188h] [rbp+80h]
  __int64 v215; // [rsp+190h] [rbp+88h]
  __int64 v216; // [rsp+198h] [rbp+90h]
  __int64 v217; // [rsp+1A0h] [rbp+98h]
  __int64 v218; // [rsp+1A8h] [rbp+A0h]
  __int64 v219; // [rsp+1B0h] [rbp+A8h]
  __int64 v220; // [rsp+1B8h] [rbp+B0h]
  __int64 v221; // [rsp+1C0h] [rbp+B8h]
  __int64 v222; // [rsp+1C8h] [rbp+C0h]
  __int64 v223; // [rsp+1D0h] [rbp+C8h]
  __int64 v224; // [rsp+1D8h] [rbp+D0h]
  __int64 v225; // [rsp+1E0h] [rbp+D8h]
  __int64 v226; // [rsp+1E8h] [rbp+E0h]
  __int64 v227; // [rsp+1F0h] [rbp+E8h]
  __int64 v228; // [rsp+1F8h] [rbp+F0h]
  __int64 v229; // [rsp+200h] [rbp+F8h]
  __int64 v230; // [rsp+208h] [rbp+100h]
  __int64 v231; // [rsp+210h] [rbp+108h]
  __int64 j; // [rsp+218h] [rbp+110h] BYREF
  __int64 v233; // [rsp+220h] [rbp+118h] BYREF
  __int128 v234; // [rsp+228h] [rbp+120h] BYREF
  int n0x1600_4; // [rsp+238h] [rbp+130h] BYREF
  __int64 v236; // [rsp+23Ch] [rbp+134h]
  int v237; // [rsp+244h] [rbp+13Ch]
  unsigned __int64 v238; // [rsp+248h] [rbp+140h]
  unsigned __int64 v239; // [rsp+250h] [rbp+148h]
  __int64 v240; // [rsp+258h] [rbp+150h]
  __int64 v241; // [rsp+260h] [rbp+158h]
  int n0x1600_1; // [rsp+288h] [rbp+180h] BYREF
  __int64 v243; // [rsp+28Ch] [rbp+184h]
  int v244; // [rsp+294h] [rbp+18Ch]
  unsigned __int64 v245; // [rsp+298h] [rbp+190h]
  unsigned __int64 v246; // [rsp+2A0h] [rbp+198h]
  __int64 v247; // [rsp+2A8h] [rbp+1A0h]
  __int64 v248; // [rsp+2B0h] [rbp+1A8h]
  int n0x1600_2; // [rsp+2D8h] [rbp+1D0h] BYREF
  __int64 v250; // [rsp+2DCh] [rbp+1D4h]
  int v251; // [rsp+2E4h] [rbp+1DCh]
  unsigned __int64 v252; // [rsp+2E8h] [rbp+1E0h]
  unsigned __int64 v253; // [rsp+2F0h] [rbp+1E8h]
  __int64 v254; // [rsp+2F8h] [rbp+1F0h]
  __int64 v255; // [rsp+300h] [rbp+1F8h]
  int n0x1600_3; // [rsp+328h] [rbp+220h] BYREF
  __int64 v257; // [rsp+32Ch] [rbp+224h]
  int v258; // [rsp+334h] [rbp+22Ch]
  unsigned __int64 v259; // [rsp+338h] [rbp+230h]
  unsigned __int64 v260; // [rsp+340h] [rbp+238h]
  __int64 v261; // [rsp+348h] [rbp+240h]
  __int64 v262; // [rsp+350h] [rbp+248h]
  int n0x1600; // [rsp+378h] [rbp+270h] BYREF
  __int64 v264; // [rsp+37Ch] [rbp+274h]
  int v265; // [rsp+384h] [rbp+27Ch]
  unsigned __int64 v266; // [rsp+388h] [rbp+280h]
  unsigned __int64 v267; // [rsp+390h] [rbp+288h]
  __int64 v268; // [rsp+398h] [rbp+290h]
  __int64 v269; // [rsp+3A0h] [rbp+298h]
  __int64 v270; // [rsp+3C8h] [rbp+2C0h] BYREF
  char v271[8]; // [rsp+3D0h] [rbp+2C8h] BYREF
  char v272[8]; // [rsp+3D8h] [rbp+2D0h] BYREF
  char v273[8]; // [rsp+3E0h] [rbp+2D8h] BYREF
  char v274[8]; // [rsp+3E8h] [rbp+2E0h] BYREF
  char v275[8]; // [rsp+3F0h] [rbp+2E8h] BYREF
  char v276[8]; // [rsp+3F8h] [rbp+2F0h] BYREF
  char v277[8]; // [rsp+400h] [rbp+2F8h] BYREF
  char v278[8]; // [rsp+408h] [rbp+300h] BYREF
  char v279[8]; // [rsp+410h] [rbp+308h] BYREF
  char v280[8]; // [rsp+418h] [rbp+310h] BYREF
  __int64 v281; // [rsp+420h] [rbp+318h] BYREF
  __int64 v282; // [rsp+428h] [rbp+320h] BYREF
  _QWORD v283[7]; // [rsp+438h] [rbp+330h] BYREF
  __int64 v284; // [rsp+470h] [rbp+368h]
  __int64 v285; // [rsp+478h] [rbp+370h]
  __int64 v286; // [rsp+490h] [rbp+388h]
  __int64 v287; // [rsp+498h] [rbp+390h]
  __int64 v288; // [rsp+4A0h] [rbp+398h]
  __int64 v289; // [rsp+4A8h] [rbp+3A0h]
  _QWORD v290[3]; // [rsp+4B8h] [rbp+3B0h] BYREF
  __int64 (*p_sub_147667110)(); // [rsp+4D0h] [rbp+3C8h] BYREF
  unsigned __int64 n2_3; // [rsp+4D8h] [rbp+3D0h]
  __int64 v293; // [rsp+4E0h] [rbp+3D8h]
  int v294; // [rsp+500h] [rbp+3F8h]
  char v295; // [rsp+528h] [rbp+420h]
  struct _CONTEXT Context; // [rsp+578h] [rbp+470h] BYREF
  __m256 v297; // [rsp+A48h] [rbp+940h] BYREF
  __m256 v298; // [rsp+A68h] [rbp+960h]
  __m256 v299; // [rsp+A88h] [rbp+980h]
  __m256 v300; // [rsp+AA8h] [rbp+9A0h]
  __int128 v301; // [rsp+AD8h] [rbp+9D0h]
  __int128 v302; // [rsp+AF8h] [rbp+9F0h]

  v302 = v3;
  v301 = v4;
  LODWORD(v174) = a3;
  v209 = 0;
  v5 = a3;
  v210 = 0;
  v6 = a2;
  v211 = 0;
  v7 = a1;
  v212 = 0;
  v213 = 0;
  v265 = 0;
  v267 = 0;
  v268 = 0;
  v269 = 0;
  LODWORD(v176) = a2;
  v177 = a1;
  v208 = 0;
  n0x1600 = 0x1600;
  v264 = 1;
  v266 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_1517F95C0,
    "CSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
    0x641);
  v8 = *((_QWORD *)v7 + 0x128);
  HIWORD(n0x1600) = word_1517F95C0;
  v9 = *(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 8LL);
  v178 = *(_QWORD *)(*((_QWORD *)v7 + 4) + 0x80LL);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  v9(v8);
  ++*((_QWORD *)v7 + 0x55A);
  if ( !sub_1403C3450((_QWORD *)v7 + 0x7F) )
  {
    v12 = qword_149C8E018;
    v13 = *(void (__fastcall **)(_LocaleUpdate *, void **))(*(_QWORD *)qword_149C8E018 + 0x1E0LL);
    sub_14035DE10(&v195, (const void **)v7 + 0x7F);
    n5 = 5;
    v197 = 0;
    n2 = 0;
    v199 = 0;
    v200 = 0;
    n0x10000 = 0x10000;
    v13(v12, &v195);
    if ( (unsigned __int64)n2 >= 2 )
    {
      n2(2, &v197, 0);
      n2 = 0;
    }
    v197 = 0;
    sub_140373CC0(&v195);
    sub_1403E8680((void **)v7 + 0x7F);
  }
  v14 = *((_QWORD *)v7 + 0x125);
  if ( v14 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x48LL))(v14);
  if ( *((_QWORD *)v7 + 0x55E) )
  {
    v15 = *((_QWORD *)v7 + 0x10E);
    if ( v15 )
    {
      if ( (*(int (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x10LL))(v15) > 0 && !BYTE1(qword_149C8E516) )
        sub_1475E1D10(*((__int64 ***)v7 + 0x55E));
    }
  }
  if ( dword_149C3D1F4 != dword_149C3DA84 )
  {
    n2_1 = sub_1403E7A80(dword_149C3DA84);
    sub_1403E7140(n2_1);
    LODWORD(n2_2) = sub_1403E7A80(dword_149C3DA84);
    AcquireSRWLockShared(&SRWLock);
    v17 = (__int64 *)xmmword_1517F83A8;
    v18 = (__int64 *)qword_1517F83A0;
    if ( qword_1517F83A0 != (void *)xmmword_1517F83A8 )
    {
      do
      {
        v19 = *v18;
        if ( *(_DWORD *)v19 != GetCurrentThreadId() && !*(_DWORD *)(v19 + 4) )
        {
          while ( _InterlockedCompareExchange((volatile signed __int32 *)(v19 + 0xC), 1, 0) )
            _mm_pause();
          if ( !*(_DWORD *)(v19 + 8) )
          {
            hThread = OpenThread(0x1Au, 0, *(_DWORD *)v19);
            if ( hThread )
            {
              memset(&Context, 0, sizeof(Context));
              Context.ContextFlags = 0x100008;
              SuspendThread(hThread);
              if ( GetThreadContext(hThread, &Context) )
              {
                Context.FltSave.ControlWord = 0x27F;
                Context.MxCsr = sub_1403E7AA0(n2_2, Context.MxCsr);
                Context.ContextFlags = 0x100008;
                SetThreadContext(hThread, &Context);
              }
              ResumeThread(hThread);
              CloseHandle(hThread);
            }
          }
          _InterlockedCompareExchange((volatile signed __int32 *)(v19 + 0xC), 0, 1);
        }
        ++v18;
      }
      while ( v18 != v17 );
      v7 = v177;
      v6 = (unsigned int)v176;
      v5 = (int)v174;
    }
    ReleaseSRWLockShared(&SRWLock);
    dword_149C3D1F4 = dword_149C3DA84;
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v233);
  sub_1402B3B60((__int64)v290, 0x23, 4, "ICharacterManager::Update()");
  v294 = 1;
  v295 = 1;
  if ( n2_3 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (**)()))n2_3)(2, &p_sub_147667110);
  v293 = 0;
  p_sub_147667110 = sub_147667110;
  n2_3 = 1;
  v21 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, v290);
  v22 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xD0LL);
  if ( v22 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 0xB0LL))(v22);
  v23 = sub_1475F6540();
  if ( v23 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x38LL))(v23);
  if ( !(_BYTE)qword_149C8E516 )
  {
    if ( (v24 = *((float *)v7 + 0x49),
          v25 = (*(unsigned int (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x178LL))(qword_149C8E018),
          v26 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x180LL))(qword_149C8E018),
          v27 = (float)v26,
          v27 > 0.0)
      && (v28 = (float)v25, (float)(v28 / v27) != v24)
      || *((_DWORD *)v7 + 0x47) != (_DWORD)v25
      || *((_DWORD *)v7 + 0x48) != v26 )
    {
      sub_140414FE0(
        (__int64)(v7 + 0x28),
        v25,
        v26,
        *((float *)v7 + 0x46),
        *((float *)v7 + 0x4C),
        *((float *)v7 + 0x52),
        1.0);
    }
  }
  v29 = *((_QWORD *)v7 + 0x7F4);
  if ( v29 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x10LL))(v29);
  v30 = *((_QWORD *)v7 + 0x7F6);
  if ( v30 )
    sub_1475869C0(v30);
  v31 = 0;
  v7[0x2ACC] = v5 != 0;
  v32 = *((_QWORD *)v7 + 0x111);
  if ( v32 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x10LL))(v32) )
  {
    v31 = 1;
    v6 = 1;
  }
  v33 = v7[0x3D0];
  v7[0x2ACE] = v31;
  if ( !v33 )
  {
    sub_1476EF200((__int64)v7);
    v34 = **((_QWORD **)v7 + 3);
    if ( v34 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x30LL))(v34);
    v35 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL);
    if ( v35 && dword_149C3DAA4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 8LL))(v35);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x318LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
    if ( *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL) )
    {
      v36 = *((_QWORD *)v7 + 0xF7);
      v297 = (__m256)0LL;
      v298 = (__m256)0LL;
      v299 = (__m256)0LL;
      v300 = (__m256)0LL;
      v37 = 0;
      __asm { vzeroupper }
      v38 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x28LL))(v36);
      for ( i = *v38; i; ++v38 )
      {
        switch ( i )
        {
          case 'A':
            v37 |= 0x40u;
            break;
          case 'H':
            v37 |= 0x4000u;
            break;
          case 'R':
            v37 |= 4u;
            break;
          case 'S':
            v37 |= 0x400u;
            break;
          case 'W':
            v37 |= 8u;
            break;
        }
        i = v38[1];
      }
      if ( v37 != *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                            + 0x370) )
      {
        v40 = *((_QWORD *)v7 + 0xF7);
        v41 = *(void (__fastcall **)(__int64, __m256 *))(*(_QWORD *)v40 + 0x40LL);
        v42 = *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                        + 0x370);
        if ( (v42 & 4) != 0 )
          LOBYTE(v297.m256_f32[0]) = 0x52;
        v43 = &v297;
        if ( (v42 & 4) != 0 )
          v43 = (__m256 *)((char *)v297.m256_f32 + 1);
        if ( (v42 & 0x40) != 0 )
        {
          LOBYTE(v43->m256_f32[0]) = 0x41;
          v43 = (__m256 *)((char *)v43 + 1);
        }
        if ( (v42 & 0x400) != 0 )
        {
          LOBYTE(v43->m256_f32[0]) = 0x53;
          v43 = (__m256 *)((char *)v43 + 1);
        }
        if ( (v42 & 8) != 0 )
        {
          LOBYTE(v43->m256_f32[0]) = 0x57;
          v43 = (__m256 *)((char *)v43 + 1);
        }
        if ( (v42 & 0x4000) != 0 )
          LOBYTE(v43->m256_f32[0]) = 0x48;
        v41(v40, &v297);
      }
    }
    if ( !*(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                    + 0x380) )
    {
      v44 = sub_1403E7AE0();
      v45 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL);
      if ( v45 )
      {
        if ( *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 0xF0LL))(v45) + 0x384) )
        {
          v46 = *((_QWORD *)v7 + 0x156);
          if ( v46 )
            sub_1476AEAA0(v46);
        }
      }
      v47 = sub_1403E7AE0();
      *((float *)v7 + 0xAB7) = (*(float (__fastcall **)(__int64, LONGLONG))(*(_QWORD *)qword_149C8DF80 + 0xC0LL))(
                                 qword_149C8DF80,
                                 v47.QuadPart - v44.QuadPart);
    }
    v48 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x198LL);
    if ( v48 )
    {
      v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x28LL))(v48);
      sub_1403CE280(v49);
    }
    v50 = qword_149C8E038;
    v51 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x68LL);
    v52 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x728LL))(gEnv);
    v51(v50, v52);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x730LL))(gEnv);
    v53 = **((_QWORD **)v7 + 3);
    if ( v53 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x58LL))(v53);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x20LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x38LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
    v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB0 + 0x88LL))(qword_149C8DFB0);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v54 + 0x20LL))(v54);
    v55 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x10LL);
    if ( v55 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x48LL))(v55);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x90LL) + 0x18LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL));
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x90LL) + 0x28LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL));
    v56 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x70LL);
    if ( v56 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v56 + 0x10LL))(v56);
    v57 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x130LL);
    if ( v57 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v57 + 0x18LL))(v57);
    v58 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x188LL);
    if ( v58 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x68LL))(v58);
    v59 = *((_QWORD *)v7 + 3);
    if ( !*(_BYTE *)(v59 + 0x5F6) )
    {
      v60 = *(_QWORD *)(v59 + 0x78);
      if ( v60 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v60 + 0x20LL))(v60);
    }
    v202 = 0;
    v203 = 0;
    v204 = 0;
    v205 = 0;
    v206 = 0;
    v207 = 0;
    v243 = 0;
    v244 = 0;
    v246 = 0;
    v247 = 0;
    v248 = 0;
    n0x1600_1 = 0x1600;
    v245 = __rdtsc();
    qword_149C89AA0(
      &n0x1600_1,
      &word_1517F95B8,
      "CSystem::CheckUpdateInputSystem",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
      0x545);
    HIWORD(n0x1600_1) = word_1517F95B8;
    if ( *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x30LL) )
    {
      LOBYTE(v61) = GetForegroundWindow() == *((HWND *)v7 + 0x126) || v7[0x3D9];
      (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x30LL) + 0xD8LL))(
        *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x30LL),
        v61);
    }
    v246 = __rdtsc();
    qword_149C89AA8(&n0x1600_1);
    if ( *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xB0LL) )
    {
      v214 = 0;
      v215 = 0;
      v216 = 0;
      v217 = 0;
      v218 = 0;
      v219 = 0;
      n0x1600_2 = 0x1600;
      v250 = 1;
      v251 = 0;
      v253 = 0;
      v254 = 0;
      v255 = 0;
      v252 = __rdtsc();
      qword_149C89AA0(
        &n0x1600_2,
        &word_1517F95C4,
        "SysUpdate::Console",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
        0x701);
      HIWORD(n0x1600_2) = word_1517F95C4;
      if ( (v6 & 2) == 0 )
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xB0LL) + 0x108LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xB0LL));
      v253 = __rdtsc();
      qword_149C89AA8(&n0x1600_2);
    }
    v62 = *((_QWORD *)v7 + 3);
    if ( !*(_BYTE *)(v62 + 0x5F9) )
    {
      v63 = *(_QWORD *)(v62 + 0x98);
      if ( v63 )
      {
        if ( (v6 & 2) != 0 && !v31 && v5 != 1 )
        {
          v64 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v63 + 0xA0LL))(v63);
          if ( v64 )
          {
            v65 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v64 + 0x130LL))(v64);
            v66 = *(void (__fastcall **)(__int64))(*(_QWORD *)v65 + 0x90LL);
            (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
              *((_QWORD *)v7 + 4),
              v273,
              0);
            _XMM0 = sub_14059CC00();
            __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
            v66(v65);
          }
          v69 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x98LL);
          v70 = *(void (__fastcall **)(__int64))(*(_QWORD *)v69 + 0x30LL);
          (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
            *((_QWORD *)v7 + 4),
            v272,
            0);
          _XMM0 = sub_14059CC00();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          v70(v69);
        }
      }
    }
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x48LL))(qword_149C8E038, v21);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x68LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
    v73 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
    *(_DWORD *)(v73 + 0x2D0) = 0;
    if ( *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                   + 0x380) == 1 )
      sub_1477014D0((__int64)v7);
    (*(void (__fastcall **)(_QWORD, char *, __int64))(**((_QWORD **)v7 + 4) + 0x60LL))(*((_QWORD *)v7 + 4), v271, 1);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm7, xmm0, xmm0 }
    v220 = 0;
    v221 = 0;
    v222 = 0;
    v223 = 0;
    v224 = 0;
    v225 = 0;
    n0x1600_3 = 0x1600;
    v257 = 1;
    v258 = 0;
    v260 = 0;
    v261 = 0;
    v262 = 0;
    v259 = __rdtsc();
    qword_149C89AA0(
      &n0x1600_3,
      &word_1517F95C8,
      "PrePhysicsUpdate",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
      0x734);
    v76 = *((_QWORD *)v7 + 0x11B);
    HIWORD(n0x1600_3) = word_1517F95C8;
    if ( v76 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v76 + 0x10LL))(v76) != 1 )
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x38LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
      v226 = 0;
      v227 = 0;
      v228 = 0;
      v229 = 0;
      v230 = 0;
      v231 = 0;
      n0x1600_4 = 0x1600;
      v236 = 1;
      v237 = 0;
      v239 = 0;
      v240 = 0;
      v241 = 0;
      v238 = __rdtsc();
      qword_149C89AA0(
        &n0x1600_4,
        &word_1517F95CC,
        "PumpLoggedEvents",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
        0x73A);
      HIWORD(n0x1600_4) = word_1517F95CC;
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x350LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
      v77 = **((_QWORD **)v7 + 3);
      if ( v77 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v77 + 0x108LL))(v77);
      v239 = __rdtsc();
      qword_149C89AA8(&n0x1600_4);
    }
    if ( v5 == 1 )
    {
      if ( !(_BYTE)qword_149C8E516 || BYTE3(qword_149C8E516) )
      {
        v78 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL);
LABEL_132:
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v78 + 0x48LL))(v78);
      }
    }
    else
    {
      v78 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL);
      if ( v78 && !v31 && dword_149C3DAAC )
        goto LABEL_132;
    }
    v79 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL);
    if ( v79 && dword_149C3DAA4 )
    {
      v80 = *(void (__fastcall **)(__int64))(*(_QWORD *)v79 + 0x10LL);
      (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, v280, 0);
      _XMM0 = sub_14059CC00();
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      v80(v79);
    }
    v83 = *(void (__fastcall ****)(_QWORD))(*((_QWORD *)v7 + 3) + 0x1A8LL);
    if ( v83 )
      (**v83)(v83);
    if ( qword_149C8DFC0 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x70LL))(qword_149C8DFC0);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x98LL))(qword_149C8DFC0);
    }
    v84 = (void (__fastcall ***)(_QWORD))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0x180LL))(qword_149C8DFB8);
    v87 = v84;
    if ( v84 )
    {
      v88 = **v84;
      (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, v274, 0);
      _XMM0 = sub_14059CC00();
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      v88(v87);
    }
    v91 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x98LL);
    if ( v91 )
    {
      v92 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v91 + 0xA0LL))(v91);
      v93 = v92;
      if ( v92 )
      {
        v94 = *(void (__fastcall **)(__int64))(*(_QWORD *)v92 + 0xE8LL);
        (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(
          qword_149C8DF80,
          v275,
          0);
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        v94(v93);
      }
    }
    if ( !v31 )
    {
      LOBYTE(v86) = 1;
      sub_147706F10(v7, v6, v85, v86);
    }
    v97 = *((_QWORD *)v7 + 0x11B);
    if ( v97 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v97 + 0x10LL))(v97) != 1 )
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x50LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
      if ( (*(unsigned int (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0x11B) + 0x10LL))(*((_QWORD *)v7 + 0x11B)) )
      {
        v117 = *((_QWORD *)v7 + 0x11B);
        if ( v117 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v117 + 0x10LL))(v117) == 2 )
        {
          if ( v5 == 1 || (v6 & 1) != 0 )
          {
            *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0xF0LL))(qword_149C8DF40)
                      + 0x288) = 0;
            (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x1C8LL))(
              *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
              1);
            (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x30LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
            if ( !(_BYTE)qword_149C8E516 || *(_WORD *)((char *)&qword_149C8E516 + 3) )
              (*(void (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x190LL))(
                *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
                v122,
                0x19F);
            else
              (*(void (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x190LL))(
                *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
                v122,
                0x40019F);
          }
          else
          {
            (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0x30LL))(qword_149C8DF40);
            v118 = (float *)*((_QWORD *)v7 + 0x157);
            (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
              *((_QWORD *)v7 + 4),
              v278,
              0);
            _XMM0 = sub_14059CC00();
            __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
            sub_147700A00(v118, v121);
          }
        }
      }
      else if ( v5 == 1 || (v6 & 1) != 0 || (_BYTE)qword_149C8E516 && !*(_WORD *)((char *)&qword_149C8E516 + 3) )
      {
        sub_1476EAA00(*((_QWORD *)v7 + 0x156));
        (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x1C8LL))(
          *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
          1);
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x30LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
        if ( !(_BYTE)qword_149C8E516 || *(_WORD *)((char *)&qword_149C8E516 + 3) )
        {
          n0x19F = 0x19F;
          v107 = *(__int64 **)(*((_QWORD *)v7 + 3) + 0x20LL);
          v108 = *v107;
        }
        else
        {
          n0x19F = 0x40019F;
          v107 = *(__int64 **)(*((_QWORD *)v7 + 3) + 0x20LL);
          v108 = *v107;
        }
        (*(void (__fastcall **)(__int64 *, __int64, __int64))(v108 + 0x190))(v107, v105, n0x19F);
      }
      else
      {
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x30LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
        v98 = *((_QWORD *)v7 + 0x156);
        if ( !*(_DWORD *)(v98 + 0xC) )
          *(_DWORD *)(v98 + 0xC) = 1;
        v99 = *(float *)(*((_QWORD *)v7 + 0x156) + 0x10LL);
        v100 = *((_QWORD *)v7 + 0x156);
        (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(*((_QWORD *)v7 + 4), v276, 0);
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        if ( *(_DWORD *)(v100 + 0xC) && *(float *)&_XMM1 > 0.00000011920929 )
        {
          *(float *)(v100 + 0x10) = *(float *)&_XMM1 + *(float *)(v100 + 0x10);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0x460LL))(qword_149C8DF40);
          sub_1403DAB30(v100 + 0x38);
        }
        if ( *(_DWORD *)(v100 + 0x14) )
        {
          (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
            *((_QWORD *)v7 + 4),
            v277,
            0);
          _XMM0 = sub_14059CC00();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          *(float *)(v73 + 0x2D0) = *(float *)&_XMM1 + v99;
        }
      }
    }
    v260 = __rdtsc();
    qword_149C89AA8(&n0x1600_3);
    if ( Parameter_0 )
    {
      v110 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(
               Parameter_0,
               0x10000006);
      v111 = v110;
      if ( v110 )
      {
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v110 + 0x28LL))(v110) )
        {
          v112 = *(void (__fastcall **)(__int64))(*(_QWORD *)v111 + 0x20LL);
          (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
            *((_QWORD *)v7 + 4),
            v279,
            0);
          _XMM0 = sub_14059CC00();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          v112(v111);
        }
      }
    }
    v115 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL);
    if ( v115 && dword_149C3DAA4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v115 + 0x38LL))(v115);
    v116 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL);
    if ( v31 )
    {
LABEL_193:
      v123 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x10LL);
      if ( v123 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v123 + 0x50LL))(v123);
      if ( qword_149C8DFE8 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE8 + 0x80LL))(qword_149C8DFE8);
      v124 = v7 + 0x18;
      if ( (v6 & 2) == 0 )
      {
        v124 = v7 + 0x18;
        if ( !v31 )
        {
          v125 = (*(__int64 (__fastcall **)(_QWORD))(***((_QWORD ***)v7 + 3) + 0x518LL))(**((_QWORD **)v7 + 3));
          if ( v125 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v125 + 0x60LL))(v125);
          v126 = (_QWORD *)*((_QWORD *)v7 + 3);
          if ( *v126 )
          {
            (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v126 + 0x68LL))(*v126);
            v126 = (_QWORD *)*((_QWORD *)v7 + 3);
          }
          v124 = v7 + 0x18;
          if ( v5 != 1 )
          {
            v124 = v7 + 0x18;
            if ( *v126 )
            {
              (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v126 + 0x50LL))(*v126);
              v124 = v7 + 0x18;
            }
          }
        }
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x4D0LL))(qword_149C8DF28);
      v127 = *(_QWORD *)(*(_QWORD *)v124 + 0x128LL);
      if ( v127 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v127 + 8LL))(v127);
      v128 = *(_QWORD *)(*(_QWORD *)v124 + 0x138LL);
      if ( v128 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v128 + 0x30LL))(v128);
      if ( (*(int (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0x120) + 0x10LL))(*((_QWORD *)v7 + 0x120)) > 0 )
      {
        v129 = (*(int (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0x120) + 0x10LL))(*((_QWORD *)v7 + 0x120));
        v130 = sub_1403E7AE0();
        while ( *(_QWORD *)&sub_1403E7AE0() - v130.QuadPart < v129 )
          ;
      }
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v179);
      v131 = (char *)*((_QWORD *)v7 + 0x7FD);
      v132 = (char *)*((_QWORD *)v7 + 0x7FE);
      for ( j = (unsigned int)(int)(float)(*(float *)&dword_149C3DAB4 * 10000000.0); v131 != v132; v131 += 0x10 )
      {
        v133 = sub_14059CA60(&v179, &v281, v131);
        if ( sub_14059CAD0(v133, &j) )
          break;
      }
      v134 = (char *)*((_QWORD *)v7 + 0x7FD);
      if ( v131 != v134 )
      {
        v135 = (char *)*((_QWORD *)v7 + 0x7FE);
        if ( v131 != v135 )
        {
          v136 = v131 - v134;
          v137 = v134 - v131;
          do
          {
            v138 = &v131[v137];
            *(_QWORD *)v134 = *(_QWORD *)v131;
            v131 += 0x10;
            v134 += 0x10;
            *((_DWORD *)v138 + 2) = *(_DWORD *)&v138[v136 + 8];
          }
          while ( v131 != v135 );
        }
        *((_QWORD *)v7 + 0x7FE) = v134;
      }
      sub_14059CA60(&v179, &v282, &v233);
      v139 = sub_14059CC00();
      *((_QWORD *)&v141 + 1) = v139.m128_u64[1];
      *(double *)&v141 = *(double *)v139.m128_u64 * 1000.0;
      _XMM0 = v141;
      v142 = (_BYTE *)*((_QWORD *)v7 + 0x7FE);
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      *((float *)&v234 + 2) = *(float *)&_XMM1;
      *(_QWORD *)&v234 = v179;
      if ( v142 == *((_BYTE **)v7 + 0x7FF) )
      {
        sub_14030A470((__int64 *)v7 + 0x7FD, v142, &v234);
      }
      else
      {
        *(_OWORD *)v142 = v234;
        *((_QWORD *)v7 + 0x7FE) += 0x10LL;
      }
      v144 = *((_QWORD *)v7 + 0x7F9);
      if ( v144 && !v5 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v144 + 0x30LL))(v144);
      v145 = *((_QWORD *)v7 + 0xFF);
      if ( v145 )
        sub_1475CF5F0(v145);
      v146 = (unsigned __int64)*((unsigned int *)v7 + 0xAB2) << 6;
      if ( *((_QWORD *)v7 + 0x156) || *((_QWORD *)v7 + 0x157) )
      {
        v147 = *((_QWORD *)v7 + 0x11B);
        if ( v147 && (*(int (__fastcall **)(__int64))(*(_QWORD *)v147 + 0x10LL))(v147) < 2 )
        {
          v148 = *(_QWORD *)(*((_QWORD *)v7 + 0x156) + 0x20LL);
          v149 = *((_QWORD *)v7 + 0x156);
          qword_1517FACD8 = *(_QWORD *)(v149 + 0x28);
          qword_1517FACE0 = *(_QWORD *)(v149 + 0x30);
        }
        else
        {
          v148 = *(_QWORD *)(*((_QWORD *)v7 + 0x157) + 8LL);
          qword_1517FACD8 = 0;
          qword_1517FACE0 = 0;
        }
        qword_1517FACD0 = *(_QWORD *)&sub_1403E7AE0() - qword_1517FACD0;
        *(_QWORD *)&v7[v146 + 0xAD0] = qword_1517FACD0;
        *(_QWORD *)&v7[v146 + 0xAE8] = qword_1517FACD8;
        *(_QWORD *)&v7[v146 + 0xAF0] = qword_1517FACE0;
        *(_QWORD *)&v7[v146 + 0xAD8] = v148;
        *(_DWORD *)&v7[v146 + 0xAC8] = 0;
      }
      n0x80 = *((_DWORD *)v7 + 0xAB2) + 1;
      *((_DWORD *)v7 + 0xAB2) = n0x80;
      if ( n0x80 >= 0x80 )
        *((_DWORD *)v7 + 0xAB2) = 0;
      (*(void (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0xF9) + 0x20LL))(*((_QWORD *)v7 + 0xF9));
      if ( qword_149C8DFB8 )
      {
        if ( !(_BYTE)qword_149C8E516 || BYTE3(qword_149C8E516) )
        {
LABEL_243:
          if ( *((_DWORD *)v7 + 0x1005) == 0x19 )
          {
            LOBYTE(v151) = 1;
            (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF58 + 0x308LL))(qword_149C8DF58, v151);
          }
        }
      }
      else if ( !(_BYTE)qword_149C8E516 )
      {
        goto LABEL_243;
      }
      if ( BYTE1(qword_149C8E516) )
      {
        if ( qword_149C8E050 )
        {
          v152 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E050 + 0xA8LL))(qword_149C8E050);
          if ( v152 )
          {
            (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v178);
            sub_14059CA60(&v178, &v270, &qword_1517F95D0);
            _XMM0 = sub_14059CC00();
            __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
            if ( *(float *)&_XMM1 > 10.0 )
            {
              qword_1517F95D0 = v178;
              sub_14035E090(&v174);
              (*(void (__fastcall **)(__int64, const void **))(*(_QWORD *)v152 + 0x20LL))(v152, &v174);
              v155 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x268LL))(qword_149C8DFE0);
              (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v155 + 8LL))(v155, v283);
              v156 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v176, &v174);
              sub_140387CB0((__int64)&v176, (__int64)"system.total.used");
              v156(v152, v176, v284);
              sub_140373CC0(&v176);
              v157 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v180, &v174);
              sub_140387CB0((__int64)&v180, (__int64)"system.total.committed");
              v157(v152, v180, v284);
              sub_140373CC0(&v180);
              v158 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v181, &v174);
              sub_140387CB0((__int64)&v181, (__int64)"system.bucket.used");
              v158(v152, v181, 0);
              sub_140373CC0(&v181);
              v159 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v182, &v174);
              sub_140387CB0((__int64)&v182, (__int64)"system.bucket.committed");
              v159(v152, v182, 0);
              sub_140373CC0(&v182);
              v160 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v183, &v174);
              sub_140387CB0((__int64)&v183, (__int64)"system.mem.page_fault_count");
              v160(v152, v183, v283[0]);
              sub_140373CC0(&v183);
              v161 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v184, &v174);
              sub_140387CB0((__int64)&v184, (__int64)"system.mem.peak_working_set_size");
              v161(v152, v184, v283[1]);
              sub_140373CC0(&v184);
              v162 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v185, &v174);
              sub_140387CB0((__int64)&v185, (__int64)"system.mem.working_set_size");
              v162(v152, v185, v283[2]);
              sub_140373CC0(&v185);
              v163 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v186, &v174);
              sub_140387CB0((__int64)&v186, (__int64)"system.mem.quota_peak_paged_pool_size");
              v163(v152, v186, v283[3]);
              sub_140373CC0(&v186);
              v164 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v187, &v174);
              sub_140387CB0((__int64)&v187, (__int64)"system.mem.quota_paged_pool_size");
              v164(v152, v187, v283[4]);
              sub_140373CC0(&v187);
              v165 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v188, &v174);
              sub_140387CB0((__int64)&v188, (__int64)"system.mem.quota_peak_non_paged_pool_size");
              v165(v152, v188, v283[5]);
              sub_140373CC0(&v188);
              v166 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v189, &v174);
              sub_140387CB0((__int64)&v189, (__int64)"system.mem.quota_non_paged_pool_size");
              v166(v152, v189, v283[6]);
              sub_140373CC0(&v189);
              v167 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v190, &v174);
              sub_140387CB0((__int64)&v190, (__int64)"system.mem.page_file_usage");
              v167(v152, v190, v284);
              sub_140373CC0(&v190);
              v168 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v191, &v174);
              sub_140387CB0((__int64)&v191, (__int64)"system.mem.peak_page_file_usage");
              v168(v152, v191, v285);
              sub_140373CC0(&v191);
              v169 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v192, &v174);
              sub_140387CB0((__int64)&v192, (__int64)"system.mem.total_physical_memory");
              v169(v152, v192, v286);
              sub_140373CC0(&v192);
              v170 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v193, &v174);
              sub_140387CB0((__int64)&v193, (__int64)"system.mem.free_physical_memory");
              v170(v152, v193, v287);
              sub_140373CC0(&v193);
              v171 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v194, &v174);
              sub_140387CB0((__int64)&v194, (__int64)"system.mem.total_video_memory");
              v171(v152, v194, v288);
              sub_140373CC0(&v194);
              v172 = *(void (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10((void **)&v177, &v174);
              sub_140387CB0((__int64)&v177, (__int64)"system.mem.free_video_memory");
              v172(v152, v177, v289);
              sub_140373CC0(&v177);
              sub_140373CC0(&v174);
            }
          }
        }
      }
      goto LABEL_250;
    }
    if ( v116 && dword_149C3DAAC )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v116 + 0x58LL))(v116);
      if ( qword_149C8DFB8 )
      {
        if ( (_BYTE)qword_149C8E516 && !BYTE3(qword_149C8E516) )
        {
LABEL_190:
          if ( (v6 & 8) == 0 )
            (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0xB0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
        }
      }
      else if ( (_BYTE)qword_149C8E516 )
      {
        goto LABEL_190;
      }
    }
    sub_147706F10(v7, v6, v109, 0);
    goto LABEL_193;
  }
LABEL_250:
  sub_1402B6C70(v290);
  v267 = __rdtsc();
  return qword_149C89AA8(&n0x1600);
}

// --- End Function: sub_147703E00 (0x1477045F0) ---

// --- Function: sub_147703E00 (0x147704F5A) ---
__int64 __fastcall sub_147703E00(char *a1, unsigned int a2, int a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm8
  int v5; // r13d
  unsigned int v6; // r15d
  char *v7; // rsi
  __int64 v8; // rdi
  void (__fastcall *v9)(__int64); // rbx
  _LocaleUpdate *v12; // rdi
  void (__fastcall *v13)(_LocaleUpdate *, void **); // rbx
  __int64 v14; // rcx
  __int64 v15; // rcx
  int n2_1; // eax
  __int64 *v17; // r12
  __int64 *v18; // r14
  __int64 v19; // rbx
  HANDLE hThread; // rdi
  __int64 v21; // r12
  __int64 v22; // rcx
  __int64 v23; // rax
  float v24; // xmm7_4
  __int64 v25; // rdi
  unsigned int v26; // eax
  float v27; // xmm1_4
  float v28; // kr00_4
  __int64 v29; // rcx
  __int64 v30; // rcx
  char v31; // r14
  __int64 v32; // rcx
  char v33; // al
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  int v37; // ebx
  char *v38; // rax
  char i; // cl
  __int64 v40; // rbx
  void (__fastcall *v41)(__int64, __m256 *); // rdi
  int v42; // edx
  __m256 *v43; // rax
  LARGE_INTEGER v44; // rbx
  __int64 v45; // rcx
  __int64 v46; // rcx
  LARGE_INTEGER v47; // rax
  __int64 v48; // rcx
  __int64 v49; // rax
  __int64 v50; // rdi
  void (__fastcall *v51)(__int64, __int64); // rbx
  __int64 v52; // rax
  __int64 v53; // rcx
  __int64 v54; // rax
  __int64 v55; // rcx
  __int64 v56; // rcx
  __int64 v57; // rcx
  __int64 v58; // rcx
  __int64 v59; // rcx
  __int64 v60; // rcx
  __int64 v61; // rdx
  __int64 v62; // rcx
  __int64 v63; // rcx
  __int64 v64; // rax
  __int64 v65; // rdi
  void (__fastcall *v66)(__int64); // rbx
  __int64 v69; // rdi
  void (__fastcall *v70)(__int64); // rbx
  __int64 v73; // r12
  __int64 v76; // rcx
  __int64 v77; // rcx
  __int64 v78; // rcx
  __int64 v79; // rdi
  void (__fastcall *v80)(__int64); // rbx
  void (__fastcall ***v83)(_QWORD); // rcx
  void (__fastcall ***v84)(_QWORD); // rax
  __int64 v85; // r8
  __int64 v86; // r9
  void (__fastcall ***v87)(_QWORD); // rdi
  void (__fastcall *v88)(_QWORD); // rbx
  __int64 v91; // rcx
  __int64 v92; // rax
  __int64 v93; // rdi
  void (__fastcall *v94)(__int64); // rbx
  __int64 v97; // rcx
  __int64 v98; // rcx
  float v99; // xmm6_4
  __int64 v100; // rbx
  __int64 v105; // rdx
  __int64 n0x19F; // r8
  __int64 *v107; // rcx
  __int64 v108; // rax
  __int64 v109; // r8
  __int64 v110; // rax
  __int64 v111; // rdi
  void (__fastcall *v112)(__int64); // rbx
  __int64 v115; // rcx
  __int64 v116; // rcx
  __int64 v117; // rcx
  float *v118; // rbx
  __int64 v121; // rdx
  __int64 v122; // rdx
  __int64 v123; // rcx
  char *v124; // rbx
  __int64 v125; // rax
  _QWORD *v126; // rax
  __int64 v127; // rcx
  __int64 v128; // rcx
  LONGLONG v129; // rbx
  LARGE_INTEGER v130; // rdi
  char *v131; // rdi
  char *v132; // rbx
  _QWORD *v133; // rax
  char *v134; // rdx
  char *v135; // r10
  signed __int64 v136; // r8
  signed __int64 v137; // r9
  char *v138; // rcx
  __m128 v139; // xmm0
  __int128 v141; // kr00_16
  _BYTE *v142; // rdx
  __int64 v144; // rcx
  __int64 v145; // rcx
  unsigned __int64 v146; // rbx
  __int64 v147; // rcx
  __int64 v148; // rdi
  __int64 v149; // rax
  unsigned int n0x80; // eax
  __int64 v151; // rdx
  __int64 v152; // rdi
  __int64 v155; // rax
  void (__fastcall *v156)(__int64, void *, __int64); // rbx
  void (__fastcall *v157)(__int64, void *, __int64); // rbx
  void (__fastcall *v158)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v159)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v160)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v161)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v162)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v163)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v164)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v165)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v166)(__int64, void *, _QWORD); // rbx
  void (__fastcall *v167)(__int64, void *, __int64); // rbx
  void (__fastcall *v168)(__int64, void *, __int64); // rbx
  void (__fastcall *v169)(__int64, void *, __int64); // rbx
  void (__fastcall *v170)(__int64, void *, __int64); // rbx
  void (__fastcall *v171)(__int64, void *, __int64); // rbx
  void (__fastcall *v172)(__int64, char *, __int64); // rbx
  const void *v174; // [rsp+48h] [rbp-C0h] BYREF
  __int64 n2_2; // [rsp+50h] [rbp-B8h]
  void *v176; // [rsp+58h] [rbp-B0h] BYREF
  char *v177; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v178; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v179; // [rsp+70h] [rbp-98h] BYREF
  void *v180; // [rsp+78h] [rbp-90h] BYREF
  void *v181; // [rsp+80h] [rbp-88h] BYREF
  void *v182; // [rsp+88h] [rbp-80h] BYREF
  void *v183; // [rsp+90h] [rbp-78h] BYREF
  void *v184; // [rsp+98h] [rbp-70h] BYREF
  void *v185; // [rsp+A0h] [rbp-68h] BYREF
  void *v186; // [rsp+A8h] [rbp-60h] BYREF
  void *v187; // [rsp+B0h] [rbp-58h] BYREF
  void *v188; // [rsp+B8h] [rbp-50h] BYREF
  void *v189; // [rsp+C0h] [rbp-48h] BYREF
  void *v190; // [rsp+C8h] [rbp-40h] BYREF
  void *v191; // [rsp+D0h] [rbp-38h] BYREF
  void *v192; // [rsp+D8h] [rbp-30h] BYREF
  void *v193; // [rsp+E0h] [rbp-28h] BYREF
  void *v194; // [rsp+E8h] [rbp-20h] BYREF
  void *v195; // [rsp+F0h] [rbp-18h] BYREF
  char n5; // [rsp+F8h] [rbp-10h]
  __int64 v197; // [rsp+100h] [rbp-8h] BYREF
  void (__fastcall *n2)(__int64, __int64 *, _QWORD); // [rsp+108h] [rbp+0h]
  __int64 v199; // [rsp+110h] [rbp+8h]
  __int64 v200; // [rsp+118h] [rbp+10h]
  int n0x10000; // [rsp+120h] [rbp+18h]
  __int64 v202; // [rsp+128h] [rbp+20h]
  __int64 v203; // [rsp+130h] [rbp+28h]
  __int64 v204; // [rsp+138h] [rbp+30h]
  __int64 v205; // [rsp+140h] [rbp+38h]
  __int64 v206; // [rsp+148h] [rbp+40h]
  __int64 v207; // [rsp+150h] [rbp+48h]
  __int64 v208; // [rsp+158h] [rbp+50h]
  __int64 v209; // [rsp+160h] [rbp+58h]
  __int64 v210; // [rsp+168h] [rbp+60h]
  __int64 v211; // [rsp+170h] [rbp+68h]
  __int64 v212; // [rsp+178h] [rbp+70h]
  __int64 v213; // [rsp+180h] [rbp+78h]
  __int64 v214; // [rsp+188h] [rbp+80h]
  __int64 v215; // [rsp+190h] [rbp+88h]
  __int64 v216; // [rsp+198h] [rbp+90h]
  __int64 v217; // [rsp+1A0h] [rbp+98h]
  __int64 v218; // [rsp+1A8h] [rbp+A0h]
  __int64 v219; // [rsp+1B0h] [rbp+A8h]
  __int64 v220; // [rsp+1B8h] [rbp+B0h]
  __int64 v221; // [rsp+1C0h] [rbp+B8h]
  __int64 v222; // [rsp+1C8h] [rbp+C0h]
  __int64 v223; // [rsp+1D0h] [rbp+C8h]
  __int64 v224; // [rsp+1D8h] [rbp+D0h]
  __int64 v225; // [rsp+1E0h] [rbp+D8h]
  __int64 v226; // [rsp+1E8h] [rbp+E0h]
  __int64 v227; // [rsp+1F0h] [rbp+E8h]
  __int64 v228; // [rsp+1F8h] [rbp+F0h]
  __int64 v229; // [rsp+200h] [rbp+F8h]
  __int64 v230; // [rsp+208h] [rbp+100h]
  __int64 v231; // [rsp+210h] [rbp+108h]
  __int64 j; // [rsp+218h] [rbp+110h] BYREF
  __int64 v233; // [rsp+220h] [rbp+118h] BYREF
  __int128 v234; // [rsp+228h] [rbp+120h] BYREF
  int n0x1600_4; // [rsp+238h] [rbp+130h] BYREF
  __int64 v236; // [rsp+23Ch] [rbp+134h]
  int v237; // [rsp+244h] [rbp+13Ch]
  unsigned __int64 v238; // [rsp+248h] [rbp+140h]
  unsigned __int64 v239; // [rsp+250h] [rbp+148h]
  __int64 v240; // [rsp+258h] [rbp+150h]
  __int64 v241; // [rsp+260h] [rbp+158h]
  int n0x1600_1; // [rsp+288h] [rbp+180h] BYREF
  __int64 v243; // [rsp+28Ch] [rbp+184h]
  int v244; // [rsp+294h] [rbp+18Ch]
  unsigned __int64 v245; // [rsp+298h] [rbp+190h]
  unsigned __int64 v246; // [rsp+2A0h] [rbp+198h]
  __int64 v247; // [rsp+2A8h] [rbp+1A0h]
  __int64 v248; // [rsp+2B0h] [rbp+1A8h]
  int n0x1600_2; // [rsp+2D8h] [rbp+1D0h] BYREF
  __int64 v250; // [rsp+2DCh] [rbp+1D4h]
  int v251; // [rsp+2E4h] [rbp+1DCh]
  unsigned __int64 v252; // [rsp+2E8h] [rbp+1E0h]
  unsigned __int64 v253; // [rsp+2F0h] [rbp+1E8h]
  __int64 v254; // [rsp+2F8h] [rbp+1F0h]
  __int64 v255; // [rsp+300h] [rbp+1F8h]
  int n0x1600_3; // [rsp+328h] [rbp+220h] BYREF
  __int64 v257; // [rsp+32Ch] [rbp+224h]
  int v258; // [rsp+334h] [rbp+22Ch]
  unsigned __int64 v259; // [rsp+338h] [rbp+230h]
  unsigned __int64 v260; // [rsp+340h] [rbp+238h]
  __int64 v261; // [rsp+348h] [rbp+240h]
  __int64 v262; // [rsp+350h] [rbp+248h]
  int n0x1600; // [rsp+378h] [rbp+270h] BYREF
  __int64 v264; // [rsp+37Ch] [rbp+274h]
  int v265; // [rsp+384h] [rbp+27Ch]
  unsigned __int64 v266; // [rsp+388h] [rbp+280h]
  unsigned __int64 v267; // [rsp+390h] [rbp+288h]
  __int64 v268; // [rsp+398h] [rbp+290h]
  __int64 v269; // [rsp+3A0h] [rbp+298h]
  __int64 v270; // [rsp+3C8h] [rbp+2C0h] BYREF
  char v271[8]; // [rsp+3D0h] [rbp+2C8h] BYREF
  char v272[8]; // [rsp+3D8h] [rbp+2D0h] BYREF
  char v273[8]; // [rsp+3E0h] [rbp+2D8h] BYREF
  char v274[8]; // [rsp+3E8h] [rbp+2E0h] BYREF
  char v275[8]; // [rsp+3F0h] [rbp+2E8h] BYREF
  char v276[8]; // [rsp+3F8h] [rbp+2F0h] BYREF
  char v277[8]; // [rsp+400h] [rbp+2F8h] BYREF
  char v278[8]; // [rsp+408h] [rbp+300h] BYREF
  char v279[8]; // [rsp+410h] [rbp+308h] BYREF
  char v280[8]; // [rsp+418h] [rbp+310h] BYREF
  __int64 v281; // [rsp+420h] [rbp+318h] BYREF
  __int64 v282; // [rsp+428h] [rbp+320h] BYREF
  _QWORD v283[7]; // [rsp+438h] [rbp+330h] BYREF
  __int64 v284; // [rsp+470h] [rbp+368h]
  __int64 v285; // [rsp+478h] [rbp+370h]
  __int64 v286; // [rsp+490h] [rbp+388h]
  __int64 v287; // [rsp+498h] [rbp+390h]
  __int64 v288; // [rsp+4A0h] [rbp+398h]
  __int64 v289; // [rsp+4A8h] [rbp+3A0h]
  _QWORD v290[3]; // [rsp+4B8h] [rbp+3B0h] BYREF
  __int64 (*p_sub_147667110)(); // [rsp+4D0h] [rbp+3C8h] BYREF
  unsigned __int64 n2_3; // [rsp+4D8h] [rbp+3D0h]
  __int64 v293; // [rsp+4E0h] [rbp+3D8h]
  int v294; // [rsp+500h] [rbp+3F8h]
  char v295; // [rsp+528h] [rbp+420h]
  struct _CONTEXT Context; // [rsp+578h] [rbp+470h] BYREF
  __m256 v297; // [rsp+A48h] [rbp+940h] BYREF
  __m256 v298; // [rsp+A68h] [rbp+960h]
  __m256 v299; // [rsp+A88h] [rbp+980h]
  __m256 v300; // [rsp+AA8h] [rbp+9A0h]
  __int128 v301; // [rsp+AD8h] [rbp+9D0h]
  __int128 v302; // [rsp+AF8h] [rbp+9F0h]

  v302 = v3;
  v301 = v4;
  LODWORD(v174) = a3;
  v209 = 0;
  v5 = a3;
  v210 = 0;
  v6 = a2;
  v211 = 0;
  v7 = a1;
  v212 = 0;
  v213 = 0;
  v265 = 0;
  v267 = 0;
  v268 = 0;
  v269 = 0;
  LODWORD(v176) = a2;
  v177 = a1;
  v208 = 0;
  n0x1600 = 0x1600;
  v264 = 1;
  v266 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_1517F95C0,
    "CSystem::Update",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
    0x641);
  v8 = *((_QWORD *)v7 + 0x128);
  HIWORD(n0x1600) = word_1517F95C0;
  v9 = *(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 8LL);
  v178 = *(_QWORD *)(*((_QWORD *)v7 + 4) + 0x80LL);
  _XMM0 = sub_14059CC00();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  v9(v8);
  ++*((_QWORD *)v7 + 0x55A);
  if ( !sub_1403C3450((_QWORD *)v7 + 0x7F) )
  {
    v12 = qword_149C8E018;
    v13 = *(void (__fastcall **)(_LocaleUpdate *, void **))(*(_QWORD *)qword_149C8E018 + 0x1E0LL);
    sub_14035DE10(&v195, (const void **)v7 + 0x7F);
    n5 = 5;
    v197 = 0;
    n2 = 0;
    v199 = 0;
    v200 = 0;
    n0x10000 = 0x10000;
    v13(v12, &v195);
    if ( (unsigned __int64)n2 >= 2 )
    {
      n2(2, &v197, 0);
      n2 = 0;
    }
    v197 = 0;
    sub_140373CC0(&v195);
    sub_1403E8680((void **)v7 + 0x7F);
  }
  v14 = *((_QWORD *)v7 + 0x125);
  if ( v14 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x48LL))(v14);
  if ( *((_QWORD *)v7 + 0x55E) )
  {
    v15 = *((_QWORD *)v7 + 0x10E);
    if ( v15 )
    {
      if ( (*(int (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x10LL))(v15) > 0 && !BYTE1(qword_149C8E516) )
        sub_1475E1D10(*((__int64 ***)v7 + 0x55E));
    }
  }
  if ( dword_149C3D1F4 != dword_149C3DA84 )
  {
    n2_1 = sub_1403E7A80(dword_149C3DA84);
    sub_1403E7140(n2_1);
    LODWORD(n2_2) = sub_1403E7A80(dword_149C3DA84);
    AcquireSRWLockShared(&SRWLock);
    v17 = (__int64 *)xmmword_1517F83A8;
    v18 = (__int64 *)qword_1517F83A0;
    if ( qword_1517F83A0 != (void *)xmmword_1517F83A8 )
    {
      do
      {
        v19 = *v18;
        if ( *(_DWORD *)v19 != GetCurrentThreadId() && !*(_DWORD *)(v19 + 4) )
        {
          while ( _InterlockedCompareExchange((volatile signed __int32 *)(v19 + 0xC), 1, 0) )
            _mm_pause();
          if ( !*(_DWORD *)(v19 + 8) )
          {
            hThread = OpenThread(0x1Au, 0, *(_DWORD *)v19);
            if ( hThread )
            {
              memset(&Context, 0, sizeof(Context));
              Context.ContextFlags = 0x100008;
              SuspendThread(hThread);
              if ( GetThreadContext(hThread, &Context) )
              {
                Context.FltSave.ControlWord = 0x27F;
                Context.MxCsr = sub_1403E7AA0(n2_2, Context.MxCsr);
                Context.ContextFlags = 0x100008;
                SetThreadContext(hThread, &Context);
              }
              ResumeThread(hThread);
              CloseHandle(hThread);
            }
          }
          _InterlockedCompareExchange((volatile signed __int32 *)(v19 + 0xC), 0, 1);
        }
        ++v18;
      }
      while ( v18 != v17 );
      v7 = v177;
      v6 = (unsigned int)v176;
      v5 = (int)v174;
    }
    ReleaseSRWLockShared(&SRWLock);
    dword_149C3D1F4 = dword_149C3DA84;
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v233);
  sub_1402B3B60((__int64)v290, 0x23, 4, "ICharacterManager::Update()");
  v294 = 1;
  v295 = 1;
  if ( n2_3 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (**)()))n2_3)(2, &p_sub_147667110);
  v293 = 0;
  p_sub_147667110 = sub_147667110;
  n2_3 = 1;
  v21 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149C8E038 + 0x28LL))(qword_149C8E038, v290);
  v22 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xD0LL);
  if ( v22 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 0xB0LL))(v22);
  v23 = sub_1475F6540();
  if ( v23 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x38LL))(v23);
  if ( !(_BYTE)qword_149C8E516 )
  {
    if ( (v24 = *((float *)v7 + 0x49),
          v25 = (*(unsigned int (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x178LL))(qword_149C8E018),
          v26 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149C8E018 + 0x180LL))(qword_149C8E018),
          v27 = (float)v26,
          v27 > 0.0)
      && (v28 = (float)v25, (float)(v28 / v27) != v24)
      || *((_DWORD *)v7 + 0x47) != (_DWORD)v25
      || *((_DWORD *)v7 + 0x48) != v26 )
    {
      sub_140414FE0(
        (__int64)(v7 + 0x28),
        v25,
        v26,
        *((float *)v7 + 0x46),
        *((float *)v7 + 0x4C),
        *((float *)v7 + 0x52),
        1.0);
    }
  }
  v29 = *((_QWORD *)v7 + 0x7F4);
  if ( v29 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x10LL))(v29);
  v30 = *((_QWORD *)v7 + 0x7F6);
  if ( v30 )
    sub_1475869C0(v30);
  v31 = 0;
  v7[0x2ACC] = v5 != 0;
  v32 = *((_QWORD *)v7 + 0x111);
  if ( v32 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x10LL))(v32) )
  {
    v31 = 1;
    v6 = 1;
  }
  v33 = v7[0x3D0];
  v7[0x2ACE] = v31;
  if ( !v33 )
  {
    sub_1476EF200((__int64)v7);
    v34 = **((_QWORD **)v7 + 3);
    if ( v34 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x30LL))(v34);
    v35 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL);
    if ( v35 && dword_149C3DAA4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 8LL))(v35);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x318LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
    if ( *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL) )
    {
      v36 = *((_QWORD *)v7 + 0xF7);
      v297 = (__m256)0LL;
      v298 = (__m256)0LL;
      v299 = (__m256)0LL;
      v300 = (__m256)0LL;
      v37 = 0;
      __asm { vzeroupper }
      v38 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x28LL))(v36);
      for ( i = *v38; i; ++v38 )
      {
        switch ( i )
        {
          case 'A':
            v37 |= 0x40u;
            break;
          case 'H':
            v37 |= 0x4000u;
            break;
          case 'R':
            v37 |= 4u;
            break;
          case 'S':
            v37 |= 0x400u;
            break;
          case 'W':
            v37 |= 8u;
            break;
        }
        i = v38[1];
      }
      if ( v37 != *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                            + 0x370) )
      {
        v40 = *((_QWORD *)v7 + 0xF7);
        v41 = *(void (__fastcall **)(__int64, __m256 *))(*(_QWORD *)v40 + 0x40LL);
        v42 = *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                        + 0x370);
        if ( (v42 & 4) != 0 )
          LOBYTE(v297.m256_f32[0]) = 0x52;
        v43 = &v297;
        if ( (v42 & 4) != 0 )
          v43 = (__m256 *)((char *)v297.m256_f32 + 1);
        if ( (v42 & 0x40) != 0 )
        {
          LOBYTE(v43->m256_f32[0]) = 0x41;
          v43 = (__m256 *)((char *)v43 + 1);
        }
        if ( (v42 & 0x400) != 0 )
        {
          LOBYTE(v43->m256_f32[0]) = 0x53;
          v43 = (__m256 *)((char *)v43 + 1);
        }
        if ( (v42 & 8) != 0 )
        {
          LOBYTE(v43->m256_f32[0]) = 0x57;
          v43 = (__m256 *)((char *)v43 + 1);
        }
        if ( (v42 & 0x4000) != 0 )
          LOBYTE(v43->m256_f32[0]) = 0x48;
        v41(v40, &v297);
      }
    }
    if ( !*(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                    + 0x380) )
    {
      v44 = sub_1403E7AE0();
      v45 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL);
      if ( v45 )
      {
        if ( *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 0xF0LL))(v45) + 0x384) )
        {
          v46 = *((_QWORD *)v7 + 0x156);
          if ( v46 )
            sub_1476AEAA0(v46);
        }
      }
      v47 = sub_1403E7AE0();
      *((float *)v7 + 0xAB7) = (*(float (__fastcall **)(__int64, LONGLONG))(*(_QWORD *)qword_149C8DF80 + 0xC0LL))(
                                 qword_149C8DF80,
                                 v47.QuadPart - v44.QuadPart);
    }
    v48 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x198LL);
    if ( v48 )
    {
      v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x28LL))(v48);
      sub_1403CE280(v49);
    }
    v50 = qword_149C8E038;
    v51 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x68LL);
    v52 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x728LL))(gEnv);
    v51(v50, v52);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x730LL))(gEnv);
    v53 = **((_QWORD **)v7 + 3);
    if ( v53 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x58LL))(v53);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x20LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x38LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
    v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB0 + 0x88LL))(qword_149C8DFB0);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v54 + 0x20LL))(v54);
    v55 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x10LL);
    if ( v55 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x48LL))(v55);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x90LL) + 0x18LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL));
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x90LL) + 0x28LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL));
    v56 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x70LL);
    if ( v56 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v56 + 0x10LL))(v56);
    v57 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x130LL);
    if ( v57 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v57 + 0x18LL))(v57);
    v58 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x188LL);
    if ( v58 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x68LL))(v58);
    v59 = *((_QWORD *)v7 + 3);
    if ( !*(_BYTE *)(v59 + 0x5F6) )
    {
      v60 = *(_QWORD *)(v59 + 0x78);
      if ( v60 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v60 + 0x20LL))(v60);
    }
    v202 = 0;
    v203 = 0;
    v204 = 0;
    v205 = 0;
    v206 = 0;
    v207 = 0;
    v243 = 0;
    v244 = 0;
    v246 = 0;
    v247 = 0;
    v248 = 0;
    n0x1600_1 = 0x1600;
    v245 = __rdtsc();
    qword_149C89AA0(
      &n0x1600_1,
      &word_1517F95B8,
      "CSystem::CheckUpdateInputSystem",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
      0x545);
    HIWORD(n0x1600_1) = word_1517F95B8;
    if ( *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x30LL) )
    {
      LOBYTE(v61) = GetForegroundWindow() == *((HWND *)v7 + 0x126) || v7[0x3D9];
      (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x30LL) + 0xD8LL))(
        *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x30LL),
        v61);
    }
    v246 = __rdtsc();
    qword_149C89AA8(&n0x1600_1);
    if ( *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xB0LL) )
    {
      v214 = 0;
      v215 = 0;
      v216 = 0;
      v217 = 0;
      v218 = 0;
      v219 = 0;
      n0x1600_2 = 0x1600;
      v250 = 1;
      v251 = 0;
      v253 = 0;
      v254 = 0;
      v255 = 0;
      v252 = __rdtsc();
      qword_149C89AA0(
        &n0x1600_2,
        &word_1517F95C4,
        "SysUpdate::Console",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
        0x701);
      HIWORD(n0x1600_2) = word_1517F95C4;
      if ( (v6 & 2) == 0 )
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xB0LL) + 0x108LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xB0LL));
      v253 = __rdtsc();
      qword_149C89AA8(&n0x1600_2);
    }
    v62 = *((_QWORD *)v7 + 3);
    if ( !*(_BYTE *)(v62 + 0x5F9) )
    {
      v63 = *(_QWORD *)(v62 + 0x98);
      if ( v63 )
      {
        if ( (v6 & 2) != 0 && !v31 && v5 != 1 )
        {
          v64 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v63 + 0xA0LL))(v63);
          if ( v64 )
          {
            v65 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v64 + 0x130LL))(v64);
            v66 = *(void (__fastcall **)(__int64))(*(_QWORD *)v65 + 0x90LL);
            (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
              *((_QWORD *)v7 + 4),
              v273,
              0);
            _XMM0 = sub_14059CC00();
            __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
            v66(v65);
          }
          v69 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x98LL);
          v70 = *(void (__fastcall **)(__int64))(*(_QWORD *)v69 + 0x30LL);
          (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
            *((_QWORD *)v7 + 4),
            v272,
            0);
          _XMM0 = sub_14059CC00();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          v70(v69);
        }
      }
    }
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x48LL))(qword_149C8E038, v21);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x68LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
    v73 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
    *(_DWORD *)(v73 + 0x2D0) = 0;
    if ( *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0xF0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL))
                   + 0x380) == 1 )
      sub_1477014D0((__int64)v7);
    (*(void (__fastcall **)(_QWORD, char *, __int64))(**((_QWORD **)v7 + 4) + 0x60LL))(*((_QWORD *)v7 + 4), v271, 1);
    _XMM0 = sub_14059CC00();
    __asm { vcvtsd2ss xmm7, xmm0, xmm0 }
    v220 = 0;
    v221 = 0;
    v222 = 0;
    v223 = 0;
    v224 = 0;
    v225 = 0;
    n0x1600_3 = 0x1600;
    v257 = 1;
    v258 = 0;
    v260 = 0;
    v261 = 0;
    v262 = 0;
    v259 = __rdtsc();
    qword_149C89AA0(
      &n0x1600_3,
      &word_1517F95C8,
      "PrePhysicsUpdate",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
      0x734);
    v76 = *((_QWORD *)v7 + 0x11B);
    HIWORD(n0x1600_3) = word_1517F95C8;
    if ( v76 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v76 + 0x10LL))(v76) != 1 )
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x38LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
      v226 = 0;
      v227 = 0;
      v228 = 0;
      v229 = 0;
      v230 = 0;
      v231 = 0;
      n0x1600_4 = 0x1600;
      v236 = 1;
      v237 = 0;
      v239 = 0;
      v240 = 0;
      v241 = 0;
      v238 = __rdtsc();
      qword_149C89AA0(
        &n0x1600_4,
        &word_1517F95CC,
        "PumpLoggedEvents",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
        0x73A);
      HIWORD(n0x1600_4) = word_1517F95CC;
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x350LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
      v77 = **((_QWORD **)v7 + 3);
      if ( v77 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v77 + 0x108LL))(v77);
      v239 = __rdtsc();
      qword_149C89AA8(&n0x1600_4);
    }
    if ( v5 == 1 )
    {
      if ( !(_BYTE)qword_149C8E516 || BYTE3(qword_149C8E516) )
      {
        v78 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL);
LABEL_132:
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v78 + 0x48LL))(v78);
      }
    }
    else
    {
      v78 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL);
      if ( v78 && !v31 && dword_149C3DAAC )
        goto LABEL_132;
    }
    v79 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL);
    if ( v79 && dword_149C3DAA4 )
    {
      v80 = *(void (__fastcall **)(__int64))(*(_QWORD *)v79 + 0x10LL);
      (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, v280, 0);
      _XMM0 = sub_14059CC00();
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      v80(v79);
    }
    v83 = *(void (__fastcall ****)(_QWORD))(*((_QWORD *)v7 + 3) + 0x1A8LL);
    if ( v83 )
      (**v83)(v83);
    if ( qword_149C8DFC0 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x70LL))(qword_149C8DFC0);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFC0 + 0x98LL))(qword_149C8DFC0);
    }
    v84 = (void (__fastcall ***)(_QWORD))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFB8 + 0x180LL))(qword_149C8DFB8);
    v87 = v84;
    if ( v84 )
    {
      v88 = **v84;
      (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(qword_149C8DF80, v274, 0);
      _XMM0 = sub_14059CC00();
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      v88(v87);
    }
    v91 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x98LL);
    if ( v91 )
    {
      v92 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v91 + 0xA0LL))(v91);
      v93 = v92;
      if ( v92 )
      {
        v94 = *(void (__fastcall **)(__int64))(*(_QWORD *)v92 + 0xE8LL);
        (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)qword_149C8DF80 + 0x60LL))(
          qword_149C8DF80,
          v275,
          0);
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        v94(v93);
      }
    }
    if ( !v31 )
    {
      LOBYTE(v86) = 1;
      sub_147706F10(v7, v6, v85, v86);
    }
    v97 = *((_QWORD *)v7 + 0x11B);
    if ( v97 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v97 + 0x10LL))(v97) != 1 )
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0x50LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
      if ( (*(unsigned int (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0x11B) + 0x10LL))(*((_QWORD *)v7 + 0x11B)) )
      {
        v117 = *((_QWORD *)v7 + 0x11B);
        if ( v117 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v117 + 0x10LL))(v117) == 2 )
        {
          if ( v5 == 1 || (v6 & 1) != 0 )
          {
            *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0xF0LL))(qword_149C8DF40)
                      + 0x288) = 0;
            (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x1C8LL))(
              *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
              1);
            (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x30LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
            if ( !(_BYTE)qword_149C8E516 || *(_WORD *)((char *)&qword_149C8E516 + 3) )
              (*(void (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x190LL))(
                *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
                v122,
                0x19F);
            else
              (*(void (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x190LL))(
                *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
                v122,
                0x40019F);
          }
          else
          {
            (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0x30LL))(qword_149C8DF40);
            v118 = (float *)*((_QWORD *)v7 + 0x157);
            (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
              *((_QWORD *)v7 + 4),
              v278,
              0);
            _XMM0 = sub_14059CC00();
            __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
            sub_147700A00(v118, v121);
          }
        }
      }
      else if ( v5 == 1 || (v6 & 1) != 0 || (_BYTE)qword_149C8E516 && !*(_WORD *)((char *)&qword_149C8E516 + 3) )
      {
        sub_1476EAA00(*((_QWORD *)v7 + 0x156));
        (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x1C8LL))(
          *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL),
          1);
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x30LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
        if ( !(_BYTE)qword_149C8E516 || *(_WORD *)((char *)&qword_149C8E516 + 3) )
        {
          n0x19F = 0x19F;
          v107 = *(__int64 **)(*((_QWORD *)v7 + 3) + 0x20LL);
          v108 = *v107;
        }
        else
        {
          n0x19F = 0x40019F;
          v107 = *(__int64 **)(*((_QWORD *)v7 + 3) + 0x20LL);
          v108 = *v107;
        }
        (*(void (__fastcall **)(__int64 *, __int64, __int64))(v108 + 0x190))(v107, v105, n0x19F);
      }
      else
      {
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0x20LL) + 0x30LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0x20LL));
        v98 = *((_QWORD *)v7 + 0x156);
        if ( !*(_DWORD *)(v98 + 0xC) )
          *(_DWORD *)(v98 + 0xC) = 1;
        v99 = *(float *)(*((_QWORD *)v7 + 0x156) + 0x10LL);
        v100 = *((_QWORD *)v7 + 0x156);
        (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(*((_QWORD *)v7 + 4), v276, 0);
        _XMM0 = sub_14059CC00();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        if ( *(_DWORD *)(v100 + 0xC) && *(float *)&_XMM1 > 0.00000011920929 )
        {
          *(float *)(v100 + 0x10) = *(float *)&_XMM1 + *(float *)(v100 + 0x10);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF40 + 0x460LL))(qword_149C8DF40);
          sub_1403DAB30(v100 + 0x38);
        }
        if ( *(_DWORD *)(v100 + 0x14) )
        {
          (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
            *((_QWORD *)v7 + 4),
            v277,
            0);
          _XMM0 = sub_14059CC00();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          *(float *)(v73 + 0x2D0) = *(float *)&_XMM1 + v99;
        }
      }
    }
    v260 = __rdtsc();
    qword_149C89AA8(&n0x1600_3);
    if ( Parameter_0 )
    {
      v110 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_0 + 0x48LL))(
               Parameter_0,
               0x10000006);
      v111 = v110;
      if ( v110 )
      {
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v110 + 0x28LL))(v110) )
        {
          v112 = *(void (__fastcall **)(__int64))(*(_QWORD *)v111 + 0x20LL);
          (*(void (__fastcall **)(_QWORD, char *, _QWORD))(**((_QWORD **)v7 + 4) + 0x60LL))(
            *((_QWORD *)v7 + 4),
            v279,
            0);
          _XMM0 = sub_14059CC00();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          v112(v111);
        }
      }
    }
    v115 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x90LL);
    if ( v115 && dword_149C3DAA4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v115 + 0x38LL))(v115);
    v116 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL);
    if ( v31 )
    {
LABEL_193:
      v123 = *(_QWORD *)(*((_QWORD *)v7 + 3) + 0x10LL);
      if ( v123 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v123 + 0x50LL))(v123);
      if ( qword_149C8DFE8 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE8 + 0x80LL))(qword_149C8DFE8);
      v124 = v7 + 0x18;
      if ( (v6 & 2) == 0 )
      {
        v124 = v7 + 0x18;
        if ( !v31 )
        {
          v125 = (*(__int64 (__fastcall **)(_QWORD))(***((_QWORD ***)v7 + 3) + 0x518LL))(**((_QWORD **)v7 + 3));
          if ( v125 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v125 + 0x60LL))(v125);
          v126 = (_QWORD *)*((_QWORD *)v7 + 3);
          if ( *v126 )
          {
            (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v126 + 0x68LL))(*v126);
            v126 = (_QWORD *)*((_QWORD *)v7 + 3);
          }
          v124 = v7 + 0x18;
          if ( v5 != 1 )
          {
            v124 = v7 + 0x18;
            if ( *v126 )
            {
              (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v126 + 0x50LL))(*v126);
              v124 = v7 + 0x18;
            }
          }
        }
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DF28 + 0x4D0LL))(qword_149C8DF28);
      v127 = *(_QWORD *)(*(_QWORD *)v124 + 0x128LL);
      if ( v127 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v127 + 8LL))(v127);
      v128 = *(_QWORD *)(*(_QWORD *)v124 + 0x138LL);
      if ( v128 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v128 + 0x30LL))(v128);
      if ( (*(int (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0x120) + 0x10LL))(*((_QWORD *)v7 + 0x120)) > 0 )
      {
        v129 = (*(int (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0x120) + 0x10LL))(*((_QWORD *)v7 + 0x120));
        v130 = sub_1403E7AE0();
        while ( *(_QWORD *)&sub_1403E7AE0() - v130.QuadPart < v129 )
          ;
      }
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v179);
      v131 = (char *)*((_QWORD *)v7 + 0x7FD);
      v132 = (char *)*((_QWORD *)v7 + 0x7FE);
      for ( j = (unsigned int)(int)(float)(*(float *)&dword_149C3DAB4 * 10000000.0); v131 != v132; v131 += 0x10 )
      {
        v133 = sub_14059CA60(&v179, &v281, v131);
        if ( sub_14059CAD0(v133, &j) )
          break;
      }
      v134 = (char *)*((_QWORD *)v7 + 0x7FD);
      if ( v131 != v134 )
      {
        v135 = (char *)*((_QWORD *)v7 + 0x7FE);
        if ( v131 != v135 )
        {
          v136 = v131 - v134;
          v137 = v134 - v131;
          do
          {
            v138 = &v131[v137];
            *(_QWORD *)v134 = *(_QWORD *)v131;
            v131 += 0x10;
            v134 += 0x10;
            *((_DWORD *)v138 + 2) = *(_DWORD *)&v138[v136 + 8];
          }
          while ( v131 != v135 );
        }
        *((_QWORD *)v7 + 0x7FE) = v134;
      }
      sub_14059CA60(&v179, &v282, &v233);
      v139 = sub_14059CC00();
      *((_QWORD *)&v141 + 1) = v139.m128_u64[1];
      *(double *)&v141 = *(double *)v139.m128_u64 * 1000.0;
      _XMM0 = v141;
      v142 = (_BYTE *)*((_QWORD *)v7 + 0x7FE);
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      *((float *)&v234 + 2) = *(float *)&_XMM1;
      *(_QWORD *)&v234 = v179;
      if ( v142 == *((_BYTE **)v7 + 0x7FF) )
      {
        sub_14030A470((__int64 *)v7 + 0x7FD, v142, &v234);
      }
      else
      {
        *(_OWORD *)v142 = v234;
        *((_QWORD *)v7 + 0x7FE) += 0x10LL;
      }
      v144 = *((_QWORD *)v7 + 0x7F9);
      if ( v144 && !v5 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v144 + 0x30LL))(v144);
      v145 = *((_QWORD *)v7 + 0xFF);
      if ( v145 )
        sub_1475CF5F0(v145);
      v146 = (unsigned __int64)*((unsigned int *)v7 + 0xAB2) << 6;
      if ( *((_QWORD *)v7 + 0x156) || *((_QWORD *)v7 + 0x157) )
      {
        v147 = *((_QWORD *)v7 + 0x11B);
        if ( v147 && (*(int (__fastcall **)(__int64))(*(_QWORD *)v147 + 0x10LL))(v147) < 2 )
        {
          v148 = *(_QWORD *)(*((_QWORD *)v7 + 0x156) + 0x20LL);
          v149 = *((_QWORD *)v7 + 0x156);
          qword_1517FACD8 = *(_QWORD *)(v149 + 0x28);
          qword_1517FACE0 = *(_QWORD *)(v149 + 0x30);
        }
        else
        {
          v148 = *(_QWORD *)(*((_QWORD *)v7 + 0x157) + 8LL);
          qword_1517FACD8 = 0;
          qword_1517FACE0 = 0;
        }
        qword_1517FACD0 = *(_QWORD *)&sub_1403E7AE0() - qword_1517FACD0;
        *(_QWORD *)&v7[v146 + 0xAD0] = qword_1517FACD0;
        *(_QWORD *)&v7[v146 + 0xAE8] = qword_1517FACD8;
        *(_QWORD *)&v7[v146 + 0xAF0] = qword_1517FACE0;
        *(_QWORD *)&v7[v146 + 0xAD8] = v148;
        *(_DWORD *)&v7[v146 + 0xAC8] = 0;
      }
      n0x80 = *((_DWORD *)v7 + 0xAB2) + 1;
      *((_DWORD *)v7 + 0xAB2) = n0x80;
      if ( n0x80 >= 0x80 )
        *((_DWORD *)v7 + 0xAB2) = 0;
      (*(void (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 0xF9) + 0x20LL))(*((_QWORD *)v7 + 0xF9));
      if ( qword_149C8DFB8 )
      {
        if ( !(_BYTE)qword_149C8E516 || BYTE3(qword_149C8E516) )
        {
LABEL_243:
          if ( *((_DWORD *)v7 + 0x1005) == 0x19 )
          {
            LOBYTE(v151) = 1;
            (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8DF58 + 0x308LL))(qword_149C8DF58, v151);
          }
        }
      }
      else if ( !(_BYTE)qword_149C8E516 )
      {
        goto LABEL_243;
      }
      if ( BYTE1(qword_149C8E516) )
      {
        if ( qword_149C8E050 )
        {
          v152 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E050 + 0xA8LL))(qword_149C8E050);
          if ( v152 )
          {
            (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149C8DF80 + 0x48LL))(qword_149C8DF80, &v178);
            sub_14059CA60(&v178, &v270, &qword_1517F95D0);
            _XMM0 = sub_14059CC00();
            __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
            if ( *(float *)&_XMM1 > 10.0 )
            {
              qword_1517F95D0 = v178;
              sub_14035E090(&v174);
              (*(void (__fastcall **)(__int64, const void **))(*(_QWORD *)v152 + 0x20LL))(v152, &v174);
              v155 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x268LL))(qword_149C8DFE0);
              (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v155 + 8LL))(v155, v283);
              v156 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v176, &v174);
              sub_140387CB0((__int64)&v176, (__int64)"system.total.used");
              v156(v152, v176, v284);
              sub_140373CC0(&v176);
              v157 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v180, &v174);
              sub_140387CB0((__int64)&v180, (__int64)"system.total.committed");
              v157(v152, v180, v284);
              sub_140373CC0(&v180);
              v158 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v181, &v174);
              sub_140387CB0((__int64)&v181, (__int64)"system.bucket.used");
              v158(v152, v181, 0);
              sub_140373CC0(&v181);
              v159 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 8LL);
              sub_14035DE10(&v182, &v174);
              sub_140387CB0((__int64)&v182, (__int64)"system.bucket.committed");
              v159(v152, v182, 0);
              sub_140373CC0(&v182);
              v160 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v183, &v174);
              sub_140387CB0((__int64)&v183, (__int64)"system.mem.page_fault_count");
              v160(v152, v183, v283[0]);
              sub_140373CC0(&v183);
              v161 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v184, &v174);
              sub_140387CB0((__int64)&v184, (__int64)"system.mem.peak_working_set_size");
              v161(v152, v184, v283[1]);
              sub_140373CC0(&v184);
              v162 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v185, &v174);
              sub_140387CB0((__int64)&v185, (__int64)"system.mem.working_set_size");
              v162(v152, v185, v283[2]);
              sub_140373CC0(&v185);
              v163 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v186, &v174);
              sub_140387CB0((__int64)&v186, (__int64)"system.mem.quota_peak_paged_pool_size");
              v163(v152, v186, v283[3]);
              sub_140373CC0(&v186);
              v164 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v187, &v174);
              sub_140387CB0((__int64)&v187, (__int64)"system.mem.quota_paged_pool_size");
              v164(v152, v187, v283[4]);
              sub_140373CC0(&v187);
              v165 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v188, &v174);
              sub_140387CB0((__int64)&v188, (__int64)"system.mem.quota_peak_non_paged_pool_size");
              v165(v152, v188, v283[5]);
              sub_140373CC0(&v188);
              v166 = *(void (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v189, &v174);
              sub_140387CB0((__int64)&v189, (__int64)"system.mem.quota_non_paged_pool_size");
              v166(v152, v189, v283[6]);
              sub_140373CC0(&v189);
              v167 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v190, &v174);
              sub_140387CB0((__int64)&v190, (__int64)"system.mem.page_file_usage");
              v167(v152, v190, v284);
              sub_140373CC0(&v190);
              v168 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v191, &v174);
              sub_140387CB0((__int64)&v191, (__int64)"system.mem.peak_page_file_usage");
              v168(v152, v191, v285);
              sub_140373CC0(&v191);
              v169 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v192, &v174);
              sub_140387CB0((__int64)&v192, (__int64)"system.mem.total_physical_memory");
              v169(v152, v192, v286);
              sub_140373CC0(&v192);
              v170 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v193, &v174);
              sub_140387CB0((__int64)&v193, (__int64)"system.mem.free_physical_memory");
              v170(v152, v193, v287);
              sub_140373CC0(&v193);
              v171 = *(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10(&v194, &v174);
              sub_140387CB0((__int64)&v194, (__int64)"system.mem.total_video_memory");
              v171(v152, v194, v288);
              sub_140373CC0(&v194);
              v172 = *(void (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v152 + 0x18LL);
              sub_14035DE10((void **)&v177, &v174);
              sub_140387CB0((__int64)&v177, (__int64)"system.mem.free_video_memory");
              v172(v152, v177, v289);
              sub_140373CC0(&v177);
              sub_140373CC0(&v174);
            }
          }
        }
      }
      goto LABEL_250;
    }
    if ( v116 && dword_149C3DAAC )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v116 + 0x58LL))(v116);
      if ( qword_149C8DFB8 )
      {
        if ( (_BYTE)qword_149C8E516 && !BYTE3(qword_149C8E516) )
        {
LABEL_190:
          if ( (v6 & 8) == 0 )
            (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(*((_QWORD *)v7 + 3) + 0xA0LL) + 0xB0LL))(*(_QWORD *)(*((_QWORD *)v7 + 3) + 0xA0LL));
        }
      }
      else if ( (_BYTE)qword_149C8E516 )
      {
        goto LABEL_190;
      }
    }
    sub_147706F10(v7, v6, v109, 0);
    goto LABEL_193;
  }
LABEL_250:
  sub_1402B6C70(v290);
  v267 = __rdtsc();
  return qword_149C89AA8(&n0x1600);
}

// --- End Function: sub_147703E00 (0x147704F5A) ---

// --- Function: sub_147705E60 (0x147705E60) ---
void __fastcall sub_147705E60(_DWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 *v3; // r9
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r13
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // r8
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // rdx
  unsigned __int64 v32; // rax
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rdx
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // r10
  unsigned __int64 v41; // r9
  unsigned __int64 v42; // rdx
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // r8
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rax
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // rdx
  unsigned __int64 v50; // rax
  unsigned __int64 v51; // r13
  unsigned __int64 v52; // rcx
  _QWORD *v53; // rdx
  unsigned __int64 v54; // rcx
  unsigned __int64 v55; // rcx
  unsigned __int64 v56; // rdx
  bool v57; // zf
  unsigned __int64 v58; // r11
  unsigned __int64 *v59; // rax
  unsigned __int64 v60; // r10
  __int64 n8; // rbx
  unsigned __int64 v62; // rcx
  unsigned __int64 v63; // rdx
  unsigned __int64 v64; // r8
  unsigned __int64 v65; // rcx
  unsigned __int64 v66; // rdx
  unsigned __int64 v67; // r8
  unsigned __int64 v68; // rcx
  unsigned __int64 v69; // rdx
  unsigned __int64 v70; // r8
  unsigned __int64 v71; // rcx
  unsigned __int64 v72; // rdx
  unsigned __int64 v73; // r8
  unsigned __int64 v74; // rcx
  unsigned __int64 v75; // rdx
  __int64 n2; // [rsp+0h] [rbp-68h]
  unsigned __int64 v77; // [rsp+8h] [rbp-60h]
  unsigned __int64 v78; // [rsp+10h] [rbp-58h]
  _QWORD *v80; // [rsp+80h] [rbp+18h]
  unsigned __int64 v81; // [rsp+88h] [rbp+20h]

  if ( a2 )
  {
    v2 = a2;
    *(_QWORD *)&a1[2 * a1[0x224]++ + 2] = a2;
    if ( a1[0x224] == 0x20 )
    {
      v3 = (unsigned __int64 *)(a1 + 4);
      v4 = a2;
      v81 = 0;
      v80 = a1 + 4;
      n2 = 2;
      while ( 1 )
      {
        v5 = v3[0xFFFFFFFF];
        v6 = v3[2];
        v7 = v3[3];
        v8 = v5;
        if ( v5 >= v2 )
          v8 = v2;
        v9 = v3[4];
        v10 = *v3;
        v11 = v3[5];
        v12 = v3[0xFFFFFFFF];
        if ( v4 >= v5 )
          v12 = v4;
        v13 = v3[6];
        v14 = v3[7];
        v15 = v3[8];
        v16 = *v3;
        if ( v10 >= v8 )
          v16 = v8;
        v17 = v3[9];
        v18 = v3[0xA];
        v19 = *v3;
        v78 = v3[2];
        if ( v12 >= v10 )
          v19 = v12;
        v20 = v3[1];
        v21 = v20;
        if ( v20 >= v16 )
          v21 = v16;
        v22 = v3[1];
        if ( v19 >= v20 )
          v22 = v19;
        v23 = v3[2];
        if ( v6 >= v21 )
          v23 = v21;
        v24 = v3[2];
        if ( v22 >= v6 )
          v24 = v22;
        v25 = v3[3];
        if ( v7 >= v23 )
          v25 = v23;
        v26 = v3[3];
        if ( v24 >= v7 )
          v26 = v24;
        v27 = v3[4];
        if ( v9 >= v25 )
          v27 = v25;
        v28 = v3[4];
        if ( v26 >= v9 )
          v28 = v26;
        v29 = v3[5];
        if ( v11 >= v27 )
          v29 = v27;
        v30 = v3[5];
        if ( v28 >= v11 )
          v30 = v28;
        v31 = v3[6];
        if ( v13 >= v29 )
          v31 = v29;
        v32 = v3[6];
        if ( v30 >= v13 )
          v32 = v30;
        v33 = v3[7];
        if ( v14 >= v31 )
          v33 = v31;
        v34 = v3[7];
        if ( v32 >= v14 )
          v34 = v32;
        v35 = v3[8];
        if ( v15 >= v33 )
          v35 = v33;
        v36 = v3[8];
        if ( v34 >= v15 )
          v36 = v34;
        v37 = v3[9];
        if ( v17 >= v35 )
          v37 = v35;
        v38 = v3[9];
        if ( v36 >= v17 )
          v38 = v36;
        v39 = v3[0xA];
        if ( v18 >= v37 )
          v39 = v37;
        v40 = v3[0xB];
        v41 = v3[0xC];
        v42 = v18;
        if ( v38 >= v18 )
          v42 = v38;
        v43 = v40;
        v44 = v80[0xD];
        if ( v40 >= v39 )
          v43 = v39;
        v45 = v40;
        if ( v42 >= v40 )
          v45 = v42;
        v46 = v41;
        if ( v41 >= v43 )
          v46 = v43;
        v47 = v41;
        if ( v45 >= v41 )
          v47 = v45;
        v48 = v80[0xD];
        if ( v44 >= v46 )
          v48 = v46;
        v49 = v80[0xD];
        if ( v47 >= v44 )
          v49 = v47;
        v50 = v80[0xE];
        v51 = v50;
        if ( v50 >= v48 )
          v51 = v48;
        v52 = v80[0xE];
        if ( v49 >= v50 )
          v52 = v49;
        v53 = v80;
        v77 = v52;
        v54 = v44 + v50 + *v80;
        v2 = v51;
        v55 = v41 + v54;
        v3 = v80 + 0x10;
        v80 += 0x10;
        v56 = v53[0xFFFFFFFF] + v53[1] + v78 + v7 + v9 + v11 + v13 + v14 + v15 + v17 + v18 + v40 + v55 + v81;
        v57 = n2-- == 1;
        v81 = v56;
        if ( v57 )
          break;
        v4 = v77;
      }
      *(_QWORD *)&a1[2 * a1[0x225] + 0x42] = v51;
      *(_QWORD *)&a1[2 * a1[0x225] + 0xC2] = v77;
      *(_QWORD *)&a1[2 * a1[0x225]++ + 0x142] = v56 >> 5;
      if ( a1[0x225] == 0x40 )
      {
        v58 = 0;
        v59 = (unsigned __int64 *)(a1 + 0xC2);
        v60 = v51;
        n8 = 8;
        do
        {
          v62 = v59[0xFFFFFFC0];
          v63 = *v59;
          v59 += 8;
          if ( v62 >= v2 )
            v62 = v2;
          v64 = v59[0xFFFFFFB9];
          if ( v60 >= v63 )
            v63 = v60;
          v60 = v59[0xFFFFFFFF];
          if ( v64 >= v62 )
            v64 = v62;
          v65 = v59[0xFFFFFFF9];
          if ( v63 >= v65 )
            v65 = v63;
          v66 = v59[0xFFFFFFBA];
          if ( v66 >= v64 )
            v66 = v64;
          v67 = v59[0xFFFFFFFA];
          if ( v65 >= v67 )
            v67 = v65;
          v68 = v59[0xFFFFFFBB];
          if ( v68 >= v66 )
            v68 = v66;
          v69 = v59[0xFFFFFFFB];
          if ( v67 >= v69 )
            v69 = v67;
          v70 = v59[0xFFFFFFBC];
          if ( v70 >= v68 )
            v70 = v68;
          v71 = v59[0xFFFFFFFC];
          if ( v69 >= v71 )
            v71 = v69;
          v72 = v59[0xFFFFFFBD];
          if ( v72 >= v70 )
            v72 = v70;
          v73 = v59[0xFFFFFFFD];
          if ( v71 >= v73 )
            v73 = v71;
          v74 = v59[0xFFFFFFBE];
          if ( v74 >= v72 )
            v74 = v72;
          v75 = v59[0xFFFFFFFE];
          if ( v73 >= v75 )
            v75 = v73;
          v2 = v59[0xFFFFFFBF];
          if ( v2 >= v74 )
            v2 = v74;
          if ( v75 >= v60 )
            v60 = v75;
          v58 += v59[0x38] + v59[0x39] + v59[0x3A] + v59[0x3B] + v59[0x3C] + v59[0x3D] + v59[0x3E] + v59[0x3F];
          --n8;
        }
        while ( n8 );
        *(_QWORD *)&a1[2 * a1[0x226] + 0x1C2] = v2;
        *(_QWORD *)&a1[2 * a1[0x226] + 0x1E2] = v60;
        *(_QWORD *)&a1[2 * a1[0x226] + 0x202] = v58 >> 6;
        a1[0x226] = (a1[0x226] + 1) % 0x10;
        a1[0x225] = 0;
      }
      a1[0x224] = 0;
    }
  }
}

// --- End Function: sub_147705E60 (0x147705E60) ---

// --- Function: sub_147706F10 (0x147706F10) ---
__int64 __fastcall sub_147706F10(__int64 a1, char a2, __int64 a3, char a4)
{
  __int128 v4; // xmm6
  __int64 v8; // rax
  int n0x1600; // [rsp+30h] [rbp-68h] BYREF
  __int64 v11; // [rsp+34h] [rbp-64h]
  int v12; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v13; // [rsp+40h] [rbp-58h]
  unsigned __int64 v14; // [rsp+48h] [rbp-50h]
  __int64 v15; // [rsp+50h] [rbp-48h]
  __int64 v16; // [rsp+58h] [rbp-40h]
  __int128 v17; // [rsp+80h] [rbp-18h]

  n0x1600 = 0x1600;
  v11 = 1;
  v12 = 0;
  v17 = v4;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v13 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_1517F95F8,
    "CSystem::UpdateMovieSystem",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\System.cpp",
    0x9D4);
  HIWORD(n0x1600) = word_1517F95F8;
  if ( *(_QWORD *)(*(_QWORD *)(a1 + 0x18) + 0xE0LL)
    && ((*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_149C8DFE0 + 0x48LL))(qword_149C8DFE0)
     || (a2 & 2) == 0) )
  {
    if ( dword_149C3DAB0 )
    {
      v8 = **(_QWORD **)(*(_QWORD *)(a1 + 0x18) + 0xE0LL);
      if ( a4 )
        (*(void (**)(void))(v8 + 0xE0))();
      else
        (*(void (**)(void))(v8 + 0xE8))();
    }
  }
  v14 = __rdtsc();
  return qword_149C89AA8(&n0x1600);
}

// --- End Function: sub_147706F10 (0x147706F10) ---

// --- Function: sub_147712830 (0x147712830) ---
__int64 __fastcall sub_147712830(__int64 a1)
{
  return sub_147712840(a1, 0);
}

// --- End Function: sub_147712830 (0x147712830) ---

// --- Function: sub_147712FD0 (0x147712FD0) ---
__int64 __fastcall sub_147712FD0(__int64 a1, struct _exception *profilerInfo, __int64 a3)
{
  return sub_147712FE0(a1, profilerInfo, a3, 0);
}

// --- End Function: sub_147712FD0 (0x147712FD0) ---

// --- Function: sub_147712FE0 (0x147712FE0) ---
unsigned __int64 __fastcall sub_147712FE0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n0x20; // eax
  unsigned int n0x20_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147713170(&qword_151842240, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n0x20 = 0x20;
    n0x20_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n0x20 = n0x20_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(0x20 - n0x20) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148E9B950[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 0x10 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xF00;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 0xC);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147714510((char *)&unk_151842250 + 0x20 * v12);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1477133A0(&qword_151842240, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_1518434D0;
  if ( qword_1518434D0 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_1518433D0;
    if ( qword_1518433D0 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_147712FE0 (0x147712FE0) ---

// --- Function: sub_147713170 (0x147713170) ---
__int64 __fastcall sub_147713170(__int64 a1, unsigned __int64 n0xE000)
{
  unsigned __int64 n0xE000_2; // r13
  unsigned __int64 n0xE000_3; // rcx
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // rbx
  unsigned __int64 v6; // r12
  __int64 v7; // r15
  __int64 v8; // rax
  _QWORD *v9; // rdx
  __int64 v10; // rsi
  unsigned __int64 v11; // r14
  __int64 v12; // r8
  __int64 v13; // rsi
  __int64 v14; // rax
  __int128 v16; // [rsp+30h] [rbp-40h] BYREF
  double v17; // [rsp+40h] [rbp-30h]
  __int64 v18; // [rsp+48h] [rbp-28h] BYREF
  __int128 v19; // [rsp+50h] [rbp-20h]
  double v20; // [rsp+60h] [rbp-10h]
  double v21; // [rsp+B0h] [rbp+40h] BYREF
  unsigned __int64 n0xE000_1; // [rsp+B8h] [rbp+48h]
  __int64 v23; // [rsp+C0h] [rbp+50h]

  n0xE000_1 = n0xE000;
  n0xE000_2 = n0xE000;
  n0xE000_3 = n0xE000;
  LOBYTE(n0xE000) = 1;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
  v6 = sub_147713900(n0xE000_3, n0xE000);
  v7 = ~(*(unsigned int *)(a1 + 0x1284) - 1LL) & (*(unsigned int *)(a1 + 0x1284) + n0xE000_2 - 1);
  v23 = v7;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x12C0));
  v21 = 0.0;
  v8 = sub_147712CF0(a1, v6, &v21);
  v9 = *(_QWORD **)(v8 + 8);
  if ( v9 )
  {
    *(_QWORD *)(v8 + 8) = *v9;
    v10 = v9[1];
    v9[1] = 0;
    *v9 = *(_QWORD *)(a1 + 0x12B8);
    *(_QWORD *)(a1 + 0x12B8) = v9;
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 0x1290);
    if ( 0x4000000000LL - *(_QWORD *)(v11 + 8) < v6 )
    {
      do
      {
        v12 = *(unsigned int *)(a1 + 0x12AC);
        v13 = (v12 + 0x17) & ~(v12 - 1);
        *(__m256i *)(a1 + 0x1298) = *(__m256i *)sub_140572D50((__int64)&v18, 0x8000000000LL, v12, &off_148E9B948, 1, 0);// "StarAlloc-Large"
        v11 = (*(_QWORD *)(a1 + 0x1298) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
        __asm { vzeroupper }
        sub_140572BD0(a1 + 0x1298, v11, v13);
        *(_WORD *)(v11 + 0x15) = 0;
        *(_BYTE *)(v11 + 0x17) = 0;
        *(_QWORD *)v11 = 0;
        *(_DWORD *)(v11 + 0x10) = 0x1337;
        *(_BYTE *)(v11 + 0x14) = 0;
        *(_QWORD *)(v11 + 8) = v13;
        *(_QWORD *)v11 = *(_QWORD *)(a1 + 0x1290);
        *(_QWORD *)(a1 + 0x1290) = v11;
      }
      while ( 0x4000000000LL - *(_QWORD *)(v11 + 8) < v6 );
      v7 = v23;
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
      n0xE000_2 = n0xE000_1;
    }
    v14 = *(_QWORD *)(v11 + 8);
    v10 = v14 + v11;
    *(_QWORD *)(v11 + 8) = v6 + v14;
  }
  sub_140572BD0(a1 + 0x1270, v10, v7);
  v17 = v21;
  *(_QWORD *)&v16 = n0xE000_2;
  *((_QWORD *)&v16 + 1) = v7;
  v20 = v21;
  v18 = v10;
  v19 = v16;
  sub_1477143E0(a1 + 0x1228, &v16, &v18);
  LeaveCriticalSection(lpCriticalSection);
  return v10;
}

// --- End Function: sub_147713170 (0x147713170) ---

// --- Function: sub_1477133A0 (0x1477133A0) ---
unsigned __int64 __fastcall sub_1477133A0(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 n0x10)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 i; // rax
  __int64 v9; // r11
  signed __int32 v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rbp
  unsigned __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r12
  unsigned __int64 v16; // r15
  unsigned __int64 v17; // rax
  _QWORD *v18; // r8
  unsigned __int64 v19; // rax
  __int64 v20; // r9
  _QWORD *v21; // rdx
  int n2_1; // [rsp+20h] [rbp-48h] BYREF
  __int64 v24; // [rsp+28h] [rbp-40h]
  int n2; // [rsp+78h] [rbp+10h] BYREF
  __int64 v27; // [rsp+80h] [rbp+18h]

  v27 = a3;
  v4 = *(unsigned int *)(a1 + 0x11AC);
  v24 = v4;
  v5 = 0x20 * a3 + a1 + 0x10;
  v6 = a3;
  for ( i = sub_147714510(v5); !i; i = sub_147714510(v5) )
  {
    v10 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 1, 0) - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        n2 = 2;
        qword_149C78FC8(v5 + 0x18, &n2, 4, 0xFFFFFFFFLL);
      }
      else
      {
        v11 = *(_QWORD *)(v5 + 0x10);
        if ( !v11 || 0x2000000LL - *(_QWORD *)(v11 + 0x20) - v4 < a2 )
        {
          sub_147712170(v9, a2, v6);
          v9 = a1;
        }
        v12 = *(_QWORD *)(v5 + 0x10);
        v13 = v12 - v4 + 0x2000000;
        v14 = *(_QWORD *)(v12 + 0x20);
        v15 = v14 + v12;
        if ( v12 + v14 + 0x20 * a2 < v13 )
          v13 = v12 + v14 + 0x20 * a2;
        v16 = ~(v24 - 1) & (v13 - v12 + v4 - 1);
        v17 = *(_QWORD *)(v12 + 0x18);
        if ( v16 > v17 )
        {
          sub_140572BD0(v9 + 0x1198, v17 + v12, v16 - v17);
          *(_QWORD *)(v12 + 0x18) = v16;
        }
        *(_QWORD *)(v12 + 0x20) = v13 - v12;
        v18 = (_QWORD *)(v15 + a2 - 8);
        v19 = v15 + 2 * a2;
        v20 = 1;
        v21 = v18;
        for ( *v18 = 0; v19 <= v13; v19 += a2 )
        {
          *(_QWORD *)(v19 - 8) = v21;
          ++v20;
          v21 = (_QWORD *)(v19 - 8);
        }
        sub_1477146E0(v5, v21, v18, v20);
        if ( _InterlockedExchange((volatile __int32 *)(v5 + 0x18), 0) == 2 )
          qword_149C78FD8(v5 + 0x18);
        v6 = v27;
        v4 = v24;
      }
    }
    else if ( (unsigned int)(_InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 2, 1) - 1) <= 1 )
    {
      n2_1 = 2;
      qword_149C78FC8(v5 + 0x18, &n2_1, 4, 0xFFFFFFFFLL);
    }
  }
  return i - a2 + 8;
}

// --- End Function: sub_1477133A0 (0x1477133A0) ---

// --- Function: sub_147714510 (0x147714510) ---
__int64 __fastcall sub_147714510(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __int32 v5; // edx
  __m128i v6; // rt0
  signed __int64 v8; // [rsp+18h] [rbp-40h]
  __m128i v9; // [rsp+30h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    LODWORD(v8) = epi64 + 1;
    HIDWORD(v8) = HIDWORD(epi64) - 1;
    v6.m128i_i64[0] = v2.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v8, *(_QWORD *)v2.m128i_i64[0], v6.m128i_i64);
    v4 = v6.m128i_i64[0];
    v5 = v6.m128i_i32[2];
    v9 = v6;
    if ( v6.m128i_i64[0] == v2.m128i_i64[0] && v5 == (_DWORD)epi64 )
      break;
    v2 = v9;
    if ( !v4 )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_147714510 (0x147714510) ---

// --- Function: sub_1477151F0 (0x1477151F0) ---
__int64 __fastcall sub_1477151F0(unsigned __int64 n0x6400000)
{
  _BYTE pExceptionObject[16]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6B00; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_15184388C == 1 )
  {
    sub_14185AD70(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149C8E1E4 = 1;
  ::n0x6400000 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1476EFE10(n0x6400000);
  n0x6B00 = 0x6B00;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149C89AA0(
    &n0x6B00,
    &word_151843940,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    0xA7);
  HIWORD(n0x6B00) = word_151843940;
  sub_1476EFE10(n0x6400000);
  v8 = __rdtsc();
  return qword_149C89AA8(&n0x6B00);
}

// --- End Function: sub_1477151F0 (0x1477151F0) ---

// --- Function: sub_147715880 (0x147715880) ---
__int64 __fastcall sub_147715880(const void *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( qword_149C8E0F8 && qword_149C8DF28 && a1 == (const void *)qword_149C8DF28 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149C3E3B8
      || (result = qword_149C3E3B8 + 0x8000000000LL, (unsigned __int64)a1 >= qword_149C3E3B8 + 0x8000000000LL) )
    {
      if ( (unsigned __int64)a1 >= qword_149C3E398 && (unsigned __int64)a1 < qword_149C3E398 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      return sub_147712830(a1);
    }
  }
  return result;
}

// --- End Function: sub_147715880 (0x147715880) ---

// --- Function: allocWithProfilerInfo (0x147715930) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  unsigned __int8 v5; // bl
  __int64 v6; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1475EE1F0();
    v5 = sub_14056F960(v4);
    v6 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_147712FD0(v6 + allocSize, profilerInfo, v5);
    if ( result )
      return result;
    sub_1477151F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147715930) ---

// --- Function: sub_1477159A0 (0x1477159A0) ---
__int64 __fastcall sub_1477159A0(const void *a1, unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  __int64 result; // rax
  char v7; // al
  unsigned __int8 v8; // bl
  __int64 v9; // rax

  if ( !a1 )
    return allocWithProfilerInfo(allocSize, profilerInfo);
  if ( !allocSize )
  {
    if ( qword_149C8E0F8 && qword_149C8DF28 && a1 == (const void *)qword_149C8DF28 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149C3E3B8 || (unsigned __int64)a1 >= qword_149C3E3B8 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149C3E398 && (unsigned __int64)a1 < qword_149C3E398 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147712830((__int64)a1);
      return 0;
    }
    return 0;
  }
  if ( qword_149C8E0F8 && qword_149C8DF28 && a1 == (const void *)qword_149C8DF28 )
    __debugbreak();
  if ( (unsigned __int64)a1 >= qword_149C3E3B8 && (unsigned __int64)a1 < qword_149C3E3B8 + 0x8000000000LL )
    LogFatalError("Address %p was allocated by streaming malloc and cannot be reallocated!", a1);
  if ( (unsigned __int64)a1 >= qword_149C3E398 && (unsigned __int64)a1 < qword_149C3E398 + 0x200000000LL )
    LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
  v7 = sub_1475EE1F0();
  v8 = sub_14056F960(v7);
  v9 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
  result = sub_147713660(a1, v9 + allocSize, profilerInfo, v8);
  if ( !result )
  {
    sub_1477151F0(allocSize);
    return 0;
  }
  return result;
}

// --- End Function: sub_1477159A0 (0x1477159A0) ---

// --- Function: sub_14772E870 (0x14772E870) ---
__int64 __fastcall sub_14772E870(__int64 a1, unsigned int n2, int a3, _BYTE *a4)
{
  __int64 v4; // rdi
  __int64 v5; // rcx
  __int64 v6; // r15
  signed __int64 Size; // rbp
  signed int v8; // r8d
  signed int v9; // eax
  int v10; // r9d
  signed __int64 Size_4; // r13
  int v12; // r12d
  int v13; // r14d
  unsigned __int8 v14; // si
  __int64 Size_1; // r14
  signed __int64 Size_3; // r11
  int Size_2; // edi
  unsigned __int8 v18; // r9
  int n7; // r10d
  __int64 result; // rax
  int v21; // ebx
  __int64 v22; // rcx
  __int64 v23; // rsi
  __int64 v24; // r12
  _BYTE *v25; // rbp
  __int64 v26; // r14
  __int64 v27; // r15
  unsigned __int8 v28; // bl
  _BYTE *v29; // r9
  signed __int64 Size_5; // rdi
  unsigned __int8 v31; // al
  int n7_1; // r10d
  _BYTE *v33; // r8
  __int64 v34; // rdx
  _BYTE *v35; // rcx
  signed __int64 Size_7; // rcx
  _BYTE *v37; // rdx
  int v38; // [rsp+20h] [rbp-C8h]
  int v39; // [rsp+24h] [rbp-C4h]
  int v40; // [rsp+28h] [rbp-C0h]
  __int64 v41; // [rsp+30h] [rbp-B8h]
  __int64 v43; // [rsp+40h] [rbp-A8h]
  __int64 v44; // [rsp+48h] [rbp-A0h]
  __int64 v45; // [rsp+58h] [rbp-90h]
  _BYTE *v46; // [rsp+60h] [rbp-88h]
  signed __int64 Size_6; // [rsp+68h] [rbp-80h]
  __int64 v48; // [rsp+70h] [rbp-78h]
  _BYTE v49[32]; // [rsp+78h] [rbp-70h] BYREF

  v4 = a1;
  v41 = a1;
  v5 = (int)n2 + 0x29LL * a3;
  v6 = byte_148E9E060[v5 + 0xB0];
  Size = byte_148E9E060[v5];
  v8 = 0x10 * (n2 * (n2 + 8) + 4);
  v9 = v8;
  if ( (int)n2 < 2 || (v9 = v8 - (n2 / 7 + 2) * (0x19 * (n2 / 7 + 2) - 0xA) + 0x37, (int)n2 < 7) )
  {
    v10 = v9 / 8;
    if ( (int)n2 >= 2 )
      v8 = v8 - (n2 / 7 + 2) * (0x19 * (n2 / 7 + 2) - 0xA) + 0x37;
  }
  else
  {
    v10 = (int)(v8 - (n2 / 7 + 2) * (0x19 * (n2 / 7 + 2) - 0xA) + 0x13) / 8;
    v8 = v8 - (n2 / 7 + 2) * (0x19 * (n2 / 7 + 2) - 0xA) + 0x13;
  }
  Size_6 = byte_148E9E060[v5];
  Size_4 = Size_6;
  v12 = v8 / 8 - v6 * Size;
  v13 = v6 - v10 % (int)v6;
  v39 = v13;
  v40 = v10 / (int)v6 - Size;
  memset(v49, 0, Size);
  v49[Size - 1] = 1;
  v14 = 1;
  if ( (int)Size > 0 )
  {
    Size_1 = (unsigned int)Size;
    do
    {
      Size_3 = 0;
      Size_2 = 1;
      do
      {
        v18 = 0;
        for ( n7 = 7; n7 >= 0; --n7 )
          v18 = (2 * v18) ^ (0x1D * (v18 >> 7)) ^ (v49[Size_3] * ((v14 >> n7) & 1));
        v49[Size_3] = v18;
        if ( Size_2 < (int)Size )
          v49[Size_3] = v49[Size_3 + 1] ^ v18;
        ++Size_2;
        ++Size_3;
      }
      while ( Size_3 < Size );
      v14 = (0x1D * (v14 >> 7)) ^ (2 * v14);
      --Size_1;
    }
    while ( Size_1 );
    v4 = v41;
    v13 = v39;
  }
  result = v40;
  v21 = 0;
  v38 = 0;
  v44 = v6;
  if ( (int)v6 > 0 )
  {
    v22 = v12;
    v23 = v6;
    v24 = v6;
    v48 = v22;
    v45 = v13;
    v25 = (_BYTE *)(v22 + v4);
    v43 = v6;
    v46 = (_BYTE *)(v22 + v4);
    do
    {
      memset(v25, 0, Size_4);
      v26 = 0;
      result = v40 + (unsigned int)(v21 >= v39);
      v27 = (int)result;
      if ( (int)result <= 0 )
      {
        v33 = a4;
      }
      else
      {
        do
        {
          v28 = *v25 ^ *(_BYTE *)(v26 + v4);
          memmove(v25, v25 + 1, Size_4 - 1);
          v25[Size_4 - 1] = 0;
          if ( Size_4 > 0 )
          {
            v29 = v25;
            Size_5 = Size_4;
            do
            {
              v31 = 0;
              for ( n7_1 = 7; n7_1 >= 0; --n7_1 )
                v31 = (2 * v31) ^ (0x1D * (v31 >> 7)) ^ (v29[v49 - v25] * ((v28 >> n7_1) & 1));
              *v29++ ^= v31;
              --Size_5;
            }
            while ( Size_5 );
            v4 = v41;
          }
          ++v26;
        }
        while ( v26 < v27 );
        v33 = a4;
        v34 = 0;
        v24 = v44;
        v35 = a4;
        do
        {
          if ( v34 == v40 )
            v35 -= v45;
          result = *(unsigned __int8 *)(v34 + v4);
          ++v34;
          *v35 = result;
          v35 += v44;
        }
        while ( v34 < v27 );
        v25 = v46;
        Size_4 = Size_6;
        v21 = v38;
        v23 = v43;
      }
      Size_7 = 0;
      if ( Size_4 > 0 )
      {
        v37 = &v33[v48];
        do
        {
          result = (unsigned __int8)v25[Size_7++];
          *v37 = result;
          v37 += v24;
        }
        while ( Size_7 < Size_4 );
      }
      v4 += v27;
      ++v21;
      v41 = v4;
      --v23;
      v38 = v21;
      v43 = v23;
      a4 = v33 + 1;
    }
    while ( v23 );
  }
  return result;
}

// --- End Function: sub_14772E870 (0x14772E870) ---

// --- Function: sub_14772EC60 (0x14772EC60) ---
void __fastcall sub_14772EC60(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // esi
  int v4; // r10d
  int v7; // r8d
  int v8; // r11d
  char v9; // r9
  bool v10; // r9
  char v11; // dl
  __int64 v12; // r14
  int v13; // ebp
  int v14; // eax

  v3 = (unsigned __int8)*a2;
  v4 = 0;
  if ( *a2 )
  {
    do
    {
      v7 = 0;
      v8 = 0;
      do
      {
        if ( ((a1[((__int64)(v7 + v4 * (unsigned __int8)*a1) >> 3) + 1] >> ((v7 + v4 * *a1) & 7)) & 1) == 0 )
        {
          switch ( a3 )
          {
            case 0:
              v9 = v7 + v4;
              goto LABEL_13;
            case 1:
              v9 = v4;
              goto LABEL_13;
            case 2:
              v10 = v7 == 3 * (v7 / 3);
              goto LABEL_14;
            case 3:
              v10 = v7 + v4 == 3 * ((v7 + v4) / 3);
              goto LABEL_14;
            case 4:
              v9 = v4 / 2 + v7 / 3;
              goto LABEL_13;
            case 5:
              v10 = v8 % 2 + v8 % 3 == 0;
              goto LABEL_14;
            case 6:
              v9 = v8 % 2 + v8 % 3;
              goto LABEL_13;
            case 7:
              v9 = v8 % 3 + (v7 + v4) % 2;
LABEL_13:
              v10 = (v9 & 1) == 0;
LABEL_14:
              v11 = (v7 + v4 * *a2) & 7;
              v12 = (__int64)(v7 + v4 * (unsigned __int8)*a2) >> 3;
              v13 = (unsigned __int8)a2[v12 + 1];
              if ( (((unsigned __int8)v13 >> v11) & 1) == v10 )
                LOBYTE(v14) = v13 & ~(1 << v11);
              else
                v14 = v13 | (1 << v11);
              a2[v12 + 1] = v14;
              break;
            default:
              return;
          }
        }
        ++v7;
        v8 += v4;
      }
      while ( v7 < v3 );
      ++v4;
    }
    while ( v4 < v3 );
  }
}

// --- End Function: sub_14772EC60 (0x14772EC60) ---

// --- Function: sub_14772EEA0 (0x14772EEA0) ---
__int64 __fastcall sub_14772EEA0(int n7, unsigned __int64 n0x7FFF)
{
  int n0x7FFF_1; // edx

  if ( n0x7FFF > 0x7FFF )
    return 0xFFFFFFFFLL;
  switch ( n7 )
  {
    case 1:
      n0x7FFF_1 = (0xA * (int)n0x7FFF + 2) / 3;
      break;
    case 2:
      n0x7FFF_1 = (0xB * (int)n0x7FFF + 1) / 2;
      break;
    case 4:
      n0x7FFF_1 = 8 * n0x7FFF;
      break;
    case 8:
      n0x7FFF_1 = 0xD * n0x7FFF;
      break;
    default:
      if ( n7 != 7 || n0x7FFF )
        return 0xFFFFFFFFLL;
      return 0x18;
  }
  if ( n0x7FFF_1 > 0x7FFF )
    return 0xFFFFFFFFLL;
  return (unsigned int)n0x7FFF_1;
}

// --- End Function: sub_14772EEA0 (0x14772EEA0) ---

// --- Function: sub_14772EF20 (0x14772EF20) ---
__int64 __fastcall sub_14772EF20(__int64 a1, int a2, unsigned __int8 *a3)
{
  int v3; // r13d
  __int64 result; // rax
  int n5; // ebx
  int v8; // r10d
  unsigned __int8 v9; // r8
  int v10; // edi
  int v11; // r9d
  __int64 v12; // rsi
  int v13; // r11d
  char v14; // r9
  int v15; // ecx
  int v16; // r9d
  __int64 v17; // rdi
  int v18; // r11d
  char v19; // r9
  int v20; // ecx

  v3 = *a3;
  result = 0;
  for ( n5 = v3 - 1; n5 >= 1; n5 -= 2 )
  {
    if ( n5 == 6 )
      n5 = 5;
    v8 = 0;
    if ( v3 )
    {
      do
      {
        v9 = *a3;
        v10 = v3 - v8 - 1;
        if ( ((n5 + 1) & 2) != 0 )
          v10 = v8;
        v11 = n5 + v10 * *a3;
        v12 = (__int64)v11 >> 3;
        v13 = a3[v12 + 1];
        if ( (((unsigned __int8)v13 >> (v11 & 7)) & 1) == 0 && (int)result < 8 * a2 )
        {
          v14 = v11 & 7;
          if ( ((*(_BYTE *)(((__int64)(int)result >> 3) + a1) >> (7 - (result & 7))) & 1) != 0 )
            v15 = v13 | (1 << v14);
          else
            LOBYTE(v15) = v13 & ~(1 << v14);
          a3[v12 + 1] = v15;
          result = (unsigned int)(result + 1);
          v9 = *a3;
        }
        v16 = n5 + v10 * v9 - 1;
        v17 = (__int64)v16 >> 3;
        v18 = a3[v17 + 1];
        if ( (((unsigned __int8)v18 >> (v16 & 7)) & 1) == 0 && (int)result < 8 * a2 )
        {
          v19 = v16 & 7;
          if ( ((*(_BYTE *)(((__int64)(int)result >> 3) + a1) >> (7 - (result & 7))) & 1) != 0 )
            v20 = v18 | (1 << v19);
          else
            LOBYTE(v20) = v18 & ~(1 << v19);
          a3[v17 + 1] = v20;
          result = (unsigned int)(result + 1);
        }
        ++v8;
      }
      while ( v8 < v3 );
    }
  }
  return result;
}

// --- End Function: sub_14772EF20 (0x14772EF20) ---

// --- Function: sub_14772F0D0 (0x14772F0D0) ---
int __fastcall sub_14772F0D0(int a1, int a2, unsigned __int8 *a3)
{
  int v3; // r10d
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // r10d
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  unsigned __int64 v11; // rbx
  char v12; // cl
  int v13; // r9d
  char v14; // r11
  int v15; // eax
  unsigned __int64 v16; // rbx
  char v17; // cl
  int v18; // r9d
  char v19; // di
  int v20; // eax
  int v21; // eax
  unsigned __int64 v22; // rbx
  char v23; // r9
  int v24; // ecx
  char v25; // si
  int v26; // eax
  unsigned __int64 v27; // rbx
  char v28; // cl
  int v29; // r9d
  char v30; // bp
  int v31; // eax
  int v32; // eax
  unsigned __int64 v33; // rbx
  char v34; // r9
  int v35; // ecx
  char v36; // r15
  int v37; // eax
  char v38; // cl
  unsigned __int64 v39; // rbx
  int v40; // r9d
  char v41; // r12
  int v42; // eax
  unsigned __int64 v43; // r9
  unsigned __int8 v44; // cl
  char v45; // r14
  unsigned __int8 v46; // al
  __int64 v47; // r9
  unsigned __int8 v48; // cl
  unsigned __int8 *v49; // r9
  unsigned __int8 v50; // al
  unsigned __int64 v51; // rbx
  char v52; // cl
  int v53; // r9d
  char v54; // r13
  int v55; // eax
  char v56; // cl
  int v57; // ebx
  int v58; // eax
  char v59; // cl
  int v60; // ebx
  int v61; // eax
  char v62; // cl
  int v63; // ebx
  int v64; // eax
  char v65; // cl
  int v66; // ebx
  int v67; // eax
  __int64 v68; // r9
  unsigned __int8 v69; // cl
  unsigned __int8 *v70; // r9
  char v71; // r10
  unsigned __int8 v72; // al
  int v73; // r9d
  char v74; // cl
  int v75; // ebx
  int v76; // eax
  char v77; // bl
  int v78; // ecx
  int v79; // eax
  int v80; // eax
  __int64 v81; // rbx
  char v82; // r11
  int v83; // ecx
  int v84; // eax
  int v85; // eax
  __int64 v86; // rbx
  char v87; // r11
  int v88; // ecx
  int v89; // eax
  int v90; // eax
  __int64 v91; // rbx
  char v92; // r11
  int v93; // ecx
  int v94; // eax
  int v95; // eax
  __int64 v96; // rbx
  char v97; // r11
  int v98; // ecx
  int v99; // eax
  int v100; // eax
  __int64 v101; // rbx
  char v102; // r11
  int v103; // ecx
  int v104; // eax
  __int64 v105; // rbx
  char v106; // r11
  int v107; // ecx
  int v108; // eax
  int v109; // eax
  __int64 v110; // rbx
  char v111; // r11
  int v112; // ecx
  int v113; // eax
  int v114; // eax
  __int64 v115; // rbx
  char v116; // r11
  int v117; // ecx
  int v118; // eax
  int v119; // eax
  __int64 v120; // rbx
  char v121; // r11
  int v122; // ecx
  int v123; // eax
  int v124; // eax
  __int64 v125; // rbx
  char v126; // r11
  int v127; // ecx
  int v128; // eax
  int v129; // eax
  __int64 v130; // rbx
  char v131; // r11
  int v132; // ecx
  int v133; // eax
  int v134; // eax
  __int64 v135; // rbx
  char v136; // r11
  int v137; // ecx
  int v138; // eax
  __int64 v139; // rcx
  char v140; // r11
  int v141; // eax
  int v142; // edx
  __int64 v143; // rcx
  int result; // eax
  char v145; // [rsp+0h] [rbp-68h]
  unsigned __int8 *v146; // [rsp+8h] [rbp-60h]
  char v147; // [rsp+8h] [rbp-60h]
  unsigned __int8 *v148; // [rsp+10h] [rbp-58h]
  unsigned __int8 *v149; // [rsp+10h] [rbp-58h]
  unsigned __int8 *v150; // [rsp+10h] [rbp-58h]
  char v151; // [rsp+70h] [rbp+8h]
  char v152; // [rsp+80h] [rbp+18h]
  char v153; // [rsp+88h] [rbp+20h]

  v3 = a2 | (8 * dword_148E9E1B8[a1]);
  v4 = (2 * ((2 * ((2 * v3) ^ (0x537 * (v3 >> 9)))) ^ (0x537 * (((2 * v3) ^ (0x537 * (v3 >> 9))) >> 9))))
     ^ (0x537 * (((2 * ((2 * v3) ^ (0x537 * (v3 >> 9)))) ^ (0x537 * (((2 * v3) ^ (0x537 * (v3 >> 9))) >> 9))) >> 9));
  v5 = (2 * ((2 * v4) ^ (0x537 * (v4 >> 9)))) ^ (0x537 * (((2 * v4) ^ (0x537 * (v4 >> 9))) >> 9));
  v6 = (2 * ((2 * v5) ^ (0x537 * (v5 >> 9)))) ^ (0x537 * (((2 * v5) ^ (0x537 * (v5 >> 9))) >> 9));
  v7 = (2 * ((2 * v6) ^ (0x537 * (v6 >> 9)))) ^ (0x537 * (((2 * v6) ^ (0x537 * (v6 >> 9))) >> 9));
  v8 = ((2 * v7) ^ (0x537 * (v7 >> 9)) | (v3 << 0xA)) ^ 0x5412;
  v151 = v8 & 1;
  v9 = a3[2];
  if ( (v8 & 1) != 0 )
    v10 = v9 | 1;
  else
    v10 = v9 & 0xFE;
  a3[2] = v10;
  v11 = (unsigned __int64)((unsigned int)*a3 + 8) >> 3;
  v12 = (*a3 + 8) & 7;
  v13 = a3[v11 + 1];
  v14 = (v8 >> 1) & 1;
  if ( v14 )
    v15 = v13 | (1 << v12);
  else
    LOBYTE(v15) = v13 & ~(1 << v12);
  a3[v11 + 1] = v15;
  v16 = (unsigned __int64)(2 * (unsigned int)*a3 + 8) >> 3;
  v17 = (2 * *a3 + 8) & 7;
  v18 = a3[v16 + 1];
  v19 = (v8 >> 2) & 1;
  if ( v19 )
    v20 = v18 | (1 << v17);
  else
    LOBYTE(v20) = v18 & ~(1 << v17);
  a3[v16 + 1] = v20;
  v21 = *a3;
  v22 = (unsigned __int64)(unsigned int)(v21 + 2 * (v21 + 4)) >> 3;
  v23 = (v21 + 2 * (v21 + 4)) & 7;
  v24 = a3[v22 + 1];
  v25 = (v8 >> 3) & 1;
  if ( v25 )
    v26 = v24 | (1 << v23);
  else
    LOBYTE(v26) = v24 & ~(1 << v23);
  a3[v22 + 1] = v26;
  v27 = (unsigned __int64)(4 * (unsigned int)*a3 + 8) >> 3;
  v28 = (4 * *a3 + 8) & 7;
  v29 = a3[v27 + 1];
  v30 = (v8 >> 4) & 1;
  if ( v30 )
    v31 = v29 | (1 << v28);
  else
    LOBYTE(v31) = v29 & ~(1 << v28);
  a3[v27 + 1] = v31;
  v32 = *a3;
  v33 = (unsigned __int64)(unsigned int)(v32 + 4 * (v32 + 2)) >> 3;
  v34 = (v32 + 4 * (v32 + 2)) & 7;
  v35 = a3[v33 + 1];
  v36 = (v8 >> 5) & 1;
  if ( v36 )
    v37 = v35 | (1 << v34);
  else
    LOBYTE(v37) = v35 & ~(1 << v34);
  a3[v33 + 1] = v37;
  v38 = (7 * *a3 + 8) & 7;
  v39 = (unsigned __int64)(7 * (unsigned int)*a3 + 8) >> 3;
  v40 = a3[v39 + 1];
  v41 = (v8 >> 6) & 1;
  if ( v41 )
    v42 = v40 | (1 << v38);
  else
    LOBYTE(v42) = v40 & ~(1 << v38);
  a3[v39 + 1] = v42;
  v43 = (unsigned __int64)(8 * (unsigned int)*a3 + 8) >> 3;
  v44 = a3[v43 + 1];
  v45 = (v8 >> 7) & 1;
  if ( v45 )
    v46 = v44 | 1;
  else
    v46 = v44 & 0xFE;
  a3[v43 + 1] = v46;
  v47 = *a3 + 1LL;
  v48 = a3[v47];
  v49 = &a3[v47];
  if ( (v8 & 0x100) != 0 )
    v50 = v48 | 0x80;
  else
    v50 = v48 & 0x7F;
  *v49 = v50;
  v51 = (unsigned __int64)(8 * (unsigned int)*a3 + 5) >> 3;
  v52 = (8 * *a3 + 5) & 7;
  v53 = a3[v51 + 1];
  v54 = (v8 >> 9) & 1;
  if ( v54 )
    v55 = v53 | (1 << v52);
  else
    LOBYTE(v55) = v53 & ~(1 << v52);
  a3[v51 + 1] = v55;
  v152 = (v8 >> 0xA) & 1;
  v56 = (8 * *a3 + 4) & 7;
  v57 = a3[((unsigned __int64)(8 * (unsigned int)*a3 + 4) >> 3) + 1];
  if ( v152 )
    v58 = v57 | (1 << v56);
  else
    LOBYTE(v58) = v57 & ~(1 << v56);
  v153 = (v8 >> 0xB) & 1;
  a3[((unsigned __int64)(8 * (unsigned int)*a3 + 4) >> 3) + 1] = v58;
  v59 = (8 * *a3 + 3) & 7;
  v146 = &a3[((unsigned __int64)(8 * (unsigned int)*a3 + 3) >> 3) + 1];
  v60 = *v146;
  if ( v153 )
    v61 = v60 | (1 << v59);
  else
    LOBYTE(v61) = v60 & ~(1 << v59);
  v145 = (v8 >> 0xC) & 1;
  *v146 = v61;
  v62 = (8 * *a3 + 2) & 7;
  v63 = a3[((unsigned __int64)(8 * (unsigned int)*a3 + 2) >> 3) + 1];
  if ( v145 )
    v64 = v63 | (1 << v62);
  else
    LOBYTE(v64) = v63 & ~(1 << v62);
  v147 = (v8 >> 0xD) & 1;
  a3[((unsigned __int64)(8 * (unsigned int)*a3 + 2) >> 3) + 1] = v64;
  v65 = (8 * *a3 + 1) & 7;
  v148 = &a3[((unsigned __int64)(8 * (unsigned int)*a3 + 1) >> 3) + 1];
  v66 = *v148;
  if ( v147 )
    v67 = v66 | (1 << v65);
  else
    LOBYTE(v67) = v66 & ~(1 << v65);
  *v148 = v67;
  v68 = *a3 + 1LL;
  v69 = a3[v68];
  v70 = &a3[v68];
  v71 = (v8 >> 0xE) & 1;
  if ( v71 )
    v72 = v69 | 1;
  else
    v72 = v69 & 0xFE;
  *v70 = v72;
  v73 = *a3;
  v74 = (v73 + 8 * v73 - 1) & 7;
  v149 = &a3[((__int64)(v73 + 8 * v73 - 1) >> 3) + 1];
  v75 = *v149;
  if ( v151 )
    v76 = v75 | (1 << v74);
  else
    LOBYTE(v76) = v75 & ~(1 << v74);
  *v149 = v76;
  v77 = (v73 + 8 * *a3 - 2) & 7;
  v150 = &a3[((__int64)(v73 + 8 * *a3 - 2) >> 3) + 1];
  v78 = *v150;
  if ( v14 )
    v79 = v78 | (1 << v77);
  else
    LOBYTE(v79) = v78 & ~(1 << v77);
  *v150 = v79;
  v80 = *a3;
  v81 = (__int64)(v73 + 8 * v80 - 3) >> 3;
  v82 = (v73 + 8 * v80 - 3) & 7;
  v83 = a3[v81 + 1];
  if ( v19 )
    v84 = v83 | (1 << v82);
  else
    LOBYTE(v84) = v83 & ~(1 << v82);
  a3[v81 + 1] = v84;
  v85 = *a3;
  v86 = (__int64)(v73 + 8 * v85 - 4) >> 3;
  v87 = (v73 + 8 * v85 - 4) & 7;
  v88 = a3[v86 + 1];
  if ( v25 )
    v89 = v88 | (1 << v87);
  else
    LOBYTE(v89) = v88 & ~(1 << v87);
  a3[v86 + 1] = v89;
  v90 = *a3;
  v91 = (__int64)(v73 + 8 * v90 - 5) >> 3;
  v92 = (v73 + 8 * v90 - 5) & 7;
  v93 = a3[v91 + 1];
  if ( v30 )
    v94 = v93 | (1 << v92);
  else
    LOBYTE(v94) = v93 & ~(1 << v92);
  a3[v91 + 1] = v94;
  v95 = *a3;
  v96 = (__int64)(v73 + 8 * v95 - 6) >> 3;
  v97 = (v73 + 8 * v95 - 6) & 7;
  v98 = a3[v96 + 1];
  if ( v36 )
    v99 = v98 | (1 << v97);
  else
    LOBYTE(v99) = v98 & ~(1 << v97);
  a3[v96 + 1] = v99;
  v100 = *a3;
  v101 = (__int64)(v73 + 8 * v100 - 7) >> 3;
  v102 = (v73 + 8 * v100 - 7) & 7;
  v103 = a3[v101 + 1];
  if ( v41 )
    v104 = v103 | (1 << v102);
  else
    LOBYTE(v104) = v103 & ~(1 << v102);
  a3[v101 + 1] = v104;
  v105 = (__int64)(v73 + 8 * (*a3 - 1)) >> 3;
  v106 = (v73 + 8 * (*a3 - 1)) & 7;
  v107 = a3[v105 + 1];
  if ( v45 )
    v108 = v107 | (1 << v106);
  else
    LOBYTE(v108) = v107 & ~(1 << v106);
  a3[v105 + 1] = v108;
  v109 = *a3;
  v110 = (__int64)(v109 * (v73 - 7) + 8) >> 3;
  v111 = (v109 * (v73 - 7) + 8) & 7;
  v112 = a3[v110 + 1];
  if ( (v8 & 0x100) != 0 )
    v113 = v112 | (1 << v111);
  else
    LOBYTE(v113) = v112 & ~(1 << v111);
  a3[v110 + 1] = v113;
  v114 = *a3;
  v115 = (__int64)(v114 * (v73 - 6) + 8) >> 3;
  v116 = (v114 * (v73 - 6) + 8) & 7;
  v117 = a3[v115 + 1];
  if ( v54 )
    v118 = v117 | (1 << v116);
  else
    LOBYTE(v118) = v117 & ~(1 << v116);
  a3[v115 + 1] = v118;
  v119 = *a3;
  v120 = (__int64)(v119 * (v73 - 5) + 8) >> 3;
  v121 = (v119 * (v73 - 5) + 8) & 7;
  v122 = a3[v120 + 1];
  if ( v152 )
    v123 = v122 | (1 << v121);
  else
    LOBYTE(v123) = v122 & ~(1 << v121);
  a3[v120 + 1] = v123;
  v124 = *a3;
  v125 = (__int64)(v124 * (v73 - 4) + 8) >> 3;
  v126 = (v124 * (v73 - 4) + 8) & 7;
  v127 = a3[v125 + 1];
  if ( v153 )
    v128 = v127 | (1 << v126);
  else
    LOBYTE(v128) = v127 & ~(1 << v126);
  a3[v125 + 1] = v128;
  v129 = *a3;
  v130 = (__int64)(v129 * (v73 - 3) + 8) >> 3;
  v131 = (v129 * (v73 - 3) + 8) & 7;
  v132 = a3[v130 + 1];
  if ( v145 )
    v133 = v132 | (1 << v131);
  else
    LOBYTE(v133) = v132 & ~(1 << v131);
  a3[v130 + 1] = v133;
  v134 = *a3;
  v135 = (__int64)(v134 * (v73 - 2) + 8) >> 3;
  v136 = (v134 * (v73 - 2) + 8) & 7;
  v137 = a3[v135 + 1];
  if ( v147 )
    v138 = v137 | (1 << v136);
  else
    LOBYTE(v138) = v137 & ~(1 << v136);
  a3[v135 + 1] = v138;
  v139 = (__int64)(*a3 * (v73 - 1) + 8) >> 3;
  v140 = (*a3 * (v73 - 1) + 8) & 7;
  v141 = a3[v139 + 1];
  if ( v71 )
    v142 = v141 | (1 << v140);
  else
    LOBYTE(v142) = v141 & ~(1 << v140);
  a3[v139 + 1] = v142;
  v143 = (__int64)(*a3 * (v73 - 8) + 8) >> 3;
  result = a3[v143 + 1] | (1 << ((*a3 * (v73 - 8) + 8) & 7));
  a3[v143 + 1] = result;
  return result;
}

// --- End Function: sub_14772F0D0 (0x14772F0D0) ---

// --- Function: sub_14772F920 (0x14772F920) ---
char __fastcall sub_14772F920(_BYTE *a1, int n0x20)
{
  int v2; // r14d
  int n7; // r8d
  int n0x20_1; // ebp
  int n7_1; // ebx
  __int64 v7; // rcx
  int v8; // eax
  int v9; // r9d
  int v10; // r8d
  int v11; // r11d
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int n0x1A; // eax
  int n6; // edi
  signed int v19; // r9d
  __int64 v20; // rdx
  int i; // r8d
  __int64 v22; // rdx
  int n0x1A_3; // ecx
  __int64 v24; // r13
  int n0x1A_2; // r12d
  __int64 v26; // r14
  int v27; // r15d
  int v28; // r11d
  int v29; // ebp
  int v30; // eax
  int v31; // ebx
  int v32; // edx
  __int64 v33; // r10
  char v34; // r8
  int v35; // r9d
  int v36; // ecx
  int v37; // r8d
  __int64 v38; // r10
  char v39; // r9
  int v40; // edx
  int v41; // ecx
  int v42; // r8d
  __int64 v43; // r10
  char v44; // r9
  int v45; // edx
  int v46; // ecx
  int n0x20_2; // edx
  __int64 n0xC; // r8
  int n0x20_3; // ecx
  int v50; // r10d
  int v51; // ebp
  int v52; // r11d
  int v53; // ebx
  __int64 v54; // r9
  char v55; // dl
  int v56; // ecx
  int v57; // eax
  __int64 v58; // r9
  char v59; // cl
  int v60; // edx
  int v61; // eax
  int v62; // ebp
  __int64 v63; // r9
  char v64; // dl
  int v65; // ecx
  int v66; // eax
  __int64 v67; // r9
  char v68; // cl
  int v69; // edx
  int v70; // eax
  int v71; // ebp
  __int64 v72; // r9
  char v73; // dl
  int v74; // ecx
  int v75; // eax
  __int64 v76; // r9
  char v77; // cl
  int v78; // edx
  int n0x1A_4; // [rsp+0h] [rbp-68h]
  int n0x1A_1; // [rsp+4h] [rbp-64h]
  int v83; // [rsp+Ch] [rbp-5Ch]
  __int64 v84; // [rsp+10h] [rbp-58h]
  _BYTE v85[8]; // [rsp+18h] [rbp-50h]

  v2 = (unsigned __int8)*a1;
  n7 = 7;
  n0x20_1 = n0x20;
  v83 = v2;
  for ( n7_1 = v2 - 7; n7 < n7_1; a1[((__int64)v8 >> 3) + 1] &= ~(1 << (v8 & 7)) )
  {
    v7 = (__int64)(n7 * (unsigned __int8)*a1 + 6) >> 3;
    a1[v7 + 1] &= ~(1 << ((n7 * *a1 + 6) & 7));
    v8 = n7 + 6 * (unsigned __int8)*a1;
    n7 += 2;
  }
  v9 = 0xFFFFFFFF;
  do
  {
    v10 = 0xFFFFFFFF;
    v11 = 3 - v9;
    if ( 3 - v9 < 0 )
      v11 = v9 - 3;
    do
    {
      v12 = 3 - v10;
      if ( 3 - v10 < 0 )
        v12 = v10 - 3;
      if ( v11 > v12 )
        v12 = v11;
      if ( ((v12 - 2) & 0xFFFFFFFD) == 0 )
      {
        v13 = (unsigned __int8)*a1;
        if ( v10 >= 0 && v10 < v13 && v9 >= 0 && v9 < v13 )
          a1[((__int64)(v10 + v9 * v13) >> 3) + 1] &= ~(1 << ((v10 + v9 * v13) & 7));
        v14 = (unsigned __int8)*a1;
        if ( n7_1 + v10 >= 0 && n7_1 + v10 < v14 && v9 >= 0 && v9 < v14 )
          a1[((__int64)(v2 + v10 - 3 + v9 * v14 - 4) >> 3) + 1] &= ~(1 << ((v2 + v10 - 3 + v9 * v14 - 4) & 7));
        v15 = (unsigned __int8)*a1;
        if ( v10 >= 0 && v10 < v15 )
        {
          v16 = n7_1 + v9;
          if ( n7_1 + v9 >= 0 && v16 < v15 )
            a1[((__int64)(v10 + v15 * v16) >> 3) + 1] &= ~(1 << ((v10 + v15 * v16) & 7));
        }
      }
      ++v10;
    }
    while ( v10 - 3 <= 4 );
    LOBYTE(n0x1A) = ++v9 - 3;
  }
  while ( v9 - 3 <= 4 );
  n6 = 0;
  if ( n0x20 == 1 )
  {
    v19 = 0;
  }
  else
  {
    v19 = ((int)((unsigned __int64)(0x92492493LL * n0x20) >> 0x20) >> 2)
        + ((unsigned int)((unsigned __int64)(0x92492493LL * n0x20) >> 0x20) >> 0x1F)
        + 2;
    if ( n0x20 == 0x20 )
      n0x1A = 0x1A;
    else
      n0x1A = 2 * ((2 * (v19 + 2 * n0x20) + 1) / (2 * v19 - 2));
    v20 = v19 - 1;
    for ( i = 4 * n0x20_1 + 0xA; v20 >= 1; i -= n0x1A )
      v85[v20--] = i;
    v85[0] = 6;
  }
  v22 = v19;
  n0x1A_3 = 0;
  n0x1A_4 = 0;
  v84 = v19;
  if ( v19 > 0 )
  {
    n0x1A = v19 - 1;
    v24 = 0;
    n0x1A_1 = v19 - 1;
    do
    {
      n0x1A_2 = 0;
      v26 = 0;
      do
      {
        if ( (v24 || v26 && n0x1A_2 != n0x1A) && (n0x1A_3 != n0x1A || v26) )
        {
          v27 = (unsigned __int8)v85[v26];
          v28 = 0xFFFFFFFF;
          v29 = (unsigned __int8)v85[v24];
          do
          {
            v30 = 0xFFFFFFFF;
            v31 = v27 + v28;
            do
            {
              if ( v30 || (v32 = 1, v28) )
                v32 = 0;
              v33 = (__int64)(v30 + v29 + v31 * (unsigned __int8)*a1) >> 3;
              v34 = (v30 + v29 + v31 * *a1) & 7;
              v35 = (unsigned __int8)a1[v33 + 1];
              if ( v32 )
                v36 = v35 | (1 << v34);
              else
                LOBYTE(v36) = v35 & ~(1 << v34);
              a1[v33 + 1] = v36;
              if ( v30 != 0xFFFFFFFF || (v37 = 1, v28) )
                v37 = 0;
              v38 = (__int64)(v30 + v29 + v31 * (unsigned __int8)*a1 + 1) >> 3;
              v39 = (v30 + v29 + v31 * *a1 + 1) & 7;
              v40 = (unsigned __int8)a1[v38 + 1];
              if ( v37 )
                v41 = v40 | (1 << v39);
              else
                LOBYTE(v41) = v40 & ~(1 << v39);
              a1[v38 + 1] = v41;
              if ( v30 != 0xFFFFFFFE || (v42 = 1, v28) )
                v42 = 0;
              v43 = (__int64)(v30 + v29 + v31 * (unsigned __int8)*a1 + 2) >> 3;
              v44 = (v30 + v29 + v31 * *a1 + 2) & 7;
              v45 = (unsigned __int8)a1[v43 + 1];
              if ( v42 )
                v46 = v45 | (1 << v44);
              else
                LOBYTE(v46) = v45 & ~(1 << v44);
              v30 += 3;
              a1[v43 + 1] = v46;
            }
            while ( v30 <= 1 );
            ++v28;
          }
          while ( v28 <= 1 );
          n0x1A = n0x1A_1;
          n0x1A_3 = n0x1A_4;
          v22 = v84;
        }
        ++n0x1A_2;
        ++v26;
      }
      while ( v26 < v22 );
      ++n0x1A_3;
      ++v24;
      n0x1A_4 = n0x1A_3;
    }
    while ( v24 < v22 );
    n0x20_1 = n0x20;
    v2 = v83;
  }
  if ( n0x20_1 >= 7 )
  {
    n0x20_2 = n0x20_1;
    n0xC = 0xC;
    do
    {
      n0x20_3 = (2 * n0x20_2) ^ (0x1F25 * (n0x20_2 >> 0xB));
      n0x20_2 = n0x20_3;
      --n0xC;
    }
    while ( n0xC );
    v50 = v2 - 0xB;
    v51 = n0x20_3 | (n0x20_1 << 0xC);
    v52 = v2 - 0xA;
    v53 = v2 - 9;
    do
    {
      v54 = (__int64)(v2 + n6 * (unsigned __int8)*a1 - 0xB) >> 3;
      v55 = (v2 + n6 * *a1 - 0xB) & 7;
      v56 = (unsigned __int8)a1[v54 + 1];
      if ( (v51 & 1) != 0 )
        v57 = v56 | (1 << v55);
      else
        LOBYTE(v57) = v56 & ~(1 << v55);
      a1[v54 + 1] = v57;
      v58 = (__int64)(n6 + v50 * (unsigned __int8)*a1) >> 3;
      v59 = (n6 + v50 * *a1) & 7;
      v60 = (unsigned __int8)a1[v58 + 1];
      if ( (v51 & 1) != 0 )
        v61 = v60 | (1 << v59);
      else
        LOBYTE(v61) = v60 & ~(1 << v59);
      a1[v58 + 1] = v61;
      v62 = v51 >> 1;
      v63 = (__int64)(v2 + n6 * (unsigned __int8)*a1 - 0xA) >> 3;
      v64 = (v2 + n6 * *a1 - 0xA) & 7;
      v65 = (unsigned __int8)a1[v63 + 1];
      if ( (v62 & 1) != 0 )
        v66 = v65 | (1 << v64);
      else
        LOBYTE(v66) = v65 & ~(1 << v64);
      a1[v63 + 1] = v66;
      v67 = (__int64)(n6 + v52 * (unsigned __int8)*a1) >> 3;
      v68 = (n6 + v52 * *a1) & 7;
      v69 = (unsigned __int8)a1[v67 + 1];
      if ( (v62 & 1) != 0 )
        v70 = v69 | (1 << v68);
      else
        LOBYTE(v70) = v69 & ~(1 << v68);
      a1[v67 + 1] = v70;
      v71 = v62 >> 1;
      v72 = (__int64)(v2 + n6 * (unsigned __int8)*a1 - 9) >> 3;
      v73 = (v2 + n6 * *a1 - 9) & 7;
      v74 = (unsigned __int8)a1[v72 + 1];
      if ( (v71 & 1) != 0 )
        v75 = v74 | (1 << v73);
      else
        LOBYTE(v75) = v74 & ~(1 << v73);
      a1[v72 + 1] = v75;
      v76 = (__int64)(n6 + v53 * (unsigned __int8)*a1) >> 3;
      v77 = (n6 + v53 * *a1) & 7;
      v78 = (unsigned __int8)a1[v76 + 1];
      if ( (v71 & 1) != 0 )
        n0x1A = v78 | (1 << v77);
      else
        LOBYTE(n0x1A) = v78 & ~(1 << v77);
      v51 = v71 >> 1;
      ++n6;
      a1[v76 + 1] = n0x1A;
    }
    while ( n6 < 6 );
  }
  return n0x1A;
}

// --- End Function: sub_14772F920 (0x14772F920) ---

// --- Function: sub_14772FEF0 (0x14772FEF0) ---
__int64 __fastcall sub_14772FEF0(unsigned __int8 *a1)
{
  unsigned int Src_3; // r12d
  __int64 v2; // rax
  unsigned __int8 *v3; // r11
  int v4; // ebx
  int Src_5; // r13d
  unsigned int Src_4; // r15d
  char v7; // r14
  unsigned __int8 n5; // di
  __int64 v9; // r12
  int v10; // r15d
  char v11; // si
  BOOL v12; // ecx
  int v13; // eax
  int v14; // edi
  int Src_1; // eax
  __int64 v16; // r12
  char v17; // r14
  unsigned __int8 n5_1; // bl
  int Src_6; // r15d
  char v20; // si
  BOOL v21; // eax
  int v22; // r15d
  int v23; // r13d
  int v24; // r9d
  int v25; // r14d
  int v26; // r8d
  int v27; // esi
  char v28; // r10
  int v29; // r11d
  int v30; // ecx
  int v31; // r14d
  int v32; // r10d
  __int64 Src_7; // r11
  int v34; // r8d
  __int64 Src_8; // r9
  int v36; // eax
  int v37; // r12d
  int v38; // eax
  int Src_2; // [rsp+20h] [rbp-30h]
  int v41; // [rsp+20h] [rbp-30h]
  __int64 v43; // [rsp+30h] [rbp-20h]
  int Src; // [rsp+38h] [rbp-18h] BYREF
  __int16 v45; // [rsp+3Ch] [rbp-14h]
  unsigned __int8 v46; // [rsp+3Eh] [rbp-12h]
  int v47; // [rsp+40h] [rbp-10h] BYREF
  __int16 v48; // [rsp+44h] [rbp-Ch]
  unsigned __int8 v49; // [rsp+46h] [rbp-Ah]

  Src_3 = *a1;
  v2 = *a1;
  v3 = a1;
  v43 = v2;
  v4 = 0;
  Src_5 = 0;
  Src_2 = Src_3;
  if ( *a1 )
  {
    do
    {
      Src_4 = Src_3;
      v7 = 0;
      Src = 0;
      n5 = 0;
      v45 = 0;
      v46 = 0;
      v9 = v2;
      v10 = Src_5 * Src_4;
      do
      {
        v11 = (v3[((__int64)v10 >> 3) + 1] >> (v10 & 7)) & 1;
        if ( v11 == v7 )
        {
          if ( ++n5 == 5 )
          {
            v4 += 3;
          }
          else if ( n5 > 5u )
          {
            ++v4;
          }
        }
        else
        {
          memmove((char *)&Src + 1, &Src, 6u);
          LOBYTE(Src) = n5;
          if ( !v7
            && BYTE1(Src)
            && BYTE2(Src) == BYTE1(Src)
            && (_BYTE)v45 == BYTE1(Src)
            && HIBYTE(v45) == BYTE1(Src)
            && HIBYTE(Src) == 3 * BYTE1(Src)
            && (n5 >= 4 * (unsigned int)BYTE1(Src) || v46 >= 4 * (unsigned int)BYTE1(Src)) )
          {
            v4 += 0x28;
          }
          v3 = a1;
          v7 = v11;
          n5 = 1;
        }
        ++v10;
        --v9;
      }
      while ( v9 );
      memmove((char *)&Src + 1, &Src, 6u);
      LOBYTE(Src) = n5;
      if ( v7 )
      {
        memmove((char *)&Src + 1, &Src, 6u);
        n5 = 0;
      }
      v12 = BYTE1(Src)
         && BYTE2(Src) == BYTE1(Src)
         && (_BYTE)v45 == BYTE1(Src)
         && HIBYTE(v45) == BYTE1(Src)
         && HIBYTE(Src) == 3 * BYTE1(Src)
         && (n5 >= 4 * (unsigned int)BYTE1(Src) || v46 >= 4 * (unsigned int)BYTE1(Src));
      Src_3 = Src_2;
      v13 = v4 + 0x28;
      v3 = a1;
      if ( !v12 )
        v13 = v4;
      ++Src_5;
      v4 = v13;
      v2 = v43;
    }
    while ( Src_5 < Src_2 );
    v14 = v4;
    Src = 0;
    Src_1 = 0;
    do
    {
      v16 = v43;
      v17 = 0;
      v47 = 0;
      v48 = 0;
      n5_1 = 0;
      v49 = 0;
      Src_6 = Src_1;
      do
      {
        v20 = (a1[((__int64)Src_6 >> 3) + 1] >> (Src_6 & 7)) & 1;
        if ( v20 == v17 )
        {
          if ( ++n5_1 == 5 )
          {
            v14 += 3;
          }
          else if ( n5_1 > 5u )
          {
            ++v14;
          }
        }
        else
        {
          memmove((char *)&v47 + 1, &v47, 6u);
          LOBYTE(v47) = n5_1;
          if ( !v17
            && BYTE1(v47)
            && BYTE2(v47) == BYTE1(v47)
            && (_BYTE)v48 == BYTE1(v47)
            && HIBYTE(v48) == BYTE1(v47)
            && HIBYTE(v47) == 3 * BYTE1(v47)
            && (n5_1 >= 4 * (unsigned int)BYTE1(v47) || v49 >= 4 * (unsigned int)BYTE1(v47)) )
          {
            v14 += 0x28;
          }
          v17 = v20;
          n5_1 = 1;
        }
        Src_6 += (unsigned __int8)Src_2;
        --v16;
      }
      while ( v16 );
      memmove((char *)&v47 + 1, &v47, 6u);
      LOBYTE(v47) = n5_1;
      if ( v17 )
      {
        memmove((char *)&v47 + 1, &v47, 6u);
        n5_1 = 0;
      }
      v21 = BYTE1(v47)
         && BYTE2(v47) == BYTE1(v47)
         && (_BYTE)v48 == BYTE1(v47)
         && HIBYTE(v48) == BYTE1(v47)
         && HIBYTE(v47) == 3 * BYTE1(v47)
         && (n5_1 >= 4 * (unsigned int)BYTE1(v47) || v49 >= 4 * (unsigned int)BYTE1(v47));
      Src_3 = Src_2;
      v4 = v14 + 0x28;
      if ( !v21 )
        v4 = v14;
      Src_1 = Src + 1;
      Src = Src_1;
      v14 = v4;
    }
    while ( Src_1 < Src_2 );
    v3 = a1;
  }
  v22 = Src_3 - 1;
  if ( (int)(Src_3 - 1) > 0 )
  {
    v23 = *v3;
    v24 = v4;
    v25 = 0;
    do
    {
      v26 = v25 * v23;
      do
      {
        v27 = v26 + 1;
        v28 = (v3[((__int64)v26 >> 3) + 1] >> (v26 & 7)) & 1;
        if ( v28 == ((v3[((__int64)(v26 + 1) >> 3) + 1] >> ((v26 + 1) & 7)) & 1) )
        {
          v29 = v26 + v23 * (v25 + 1) - v25 * v23;
          if ( v28 == ((a1[((__int64)v29 >> 3) + 1] >> ((v26 + v23 * (v25 + 1) - v25 * v23) & 7)) & 1) )
          {
            v30 = v29 + 1;
            v3 = a1;
            if ( v28 == ((a1[((__int64)v30 >> 3) + 1] >> (v30 & 7)) & 1) )
              v24 += 3;
          }
          else
          {
            v3 = a1;
          }
        }
        v4 = v24;
        ++v26;
      }
      while ( v27 - v25 * v23 < v22 );
      ++v25;
    }
    while ( v25 < v22 );
    Src_3 = *v3;
  }
  v31 = 0;
  if ( Src_3 )
  {
    v32 = 0;
    v41 = *v3;
    Src_7 = Src_3;
    do
    {
      v34 = v32;
      Src_8 = Src_3;
      do
      {
        v36 = v31 + 1;
        if ( ((a1[((__int64)v34 >> 3) + 1] >> (v34 & 7)) & 1) == 0 )
          v36 = v31;
        ++v34;
        v31 = v36;
        --Src_8;
      }
      while ( Src_8 );
      v32 += v41;
      --Src_7;
    }
    while ( Src_7 );
  }
  v37 = Src_3 * Src_3;
  v38 = 0xFFFFFFF6 * (2 * v31 - v37);
  if ( v38 < 0 )
    v38 = 0xA * (2 * v31 - v37);
  return (unsigned int)(v4 + 0xA * ((v37 + v38 - 1) / v37 - 1));
}

// --- End Function: sub_14772FEF0 (0x14772FEF0) ---

// --- Function: sub_1477303B0 (0x1477303B0) ---
int __fastcall sub_1477303B0(int n0x20_1, _BYTE *a2)
{
  int v3; // edi
  int n0x20; // ebp
  int v5; // r15d
  int n6; // r14d
  int i; // r8d
  int v8; // eax
  int j; // r8d
  int v10; // eax
  int n9; // r8d
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  int v20; // eax
  int n9_1; // r8d
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rcx
  __int64 v25; // rcx
  __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // rcx
  char v29; // dl
  int v30; // r8d
  __int64 n8; // r9
  __int64 v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  __int64 v37; // rcx
  __int64 v38; // rcx
  __int64 v39; // rcx
  int v40; // eax
  __int64 v41; // rcx
  int n0x1A; // eax
  signed int v43; // esi
  __int64 v44; // rdx
  int k; // r8d
  int v46; // r12d
  __int64 m; // rbp
  int v48; // edi
  __int64 n; // r10
  __int64 n5; // r11
  int v51; // r9d
  int v52; // r8d
  __int64 v53; // rcx
  __int64 v54; // rcx
  __int64 v55; // rcx
  __int64 v56; // rcx
  char v57; // dl
  __int64 v58; // rcx
  __int64 v59; // rcx
  __int64 v60; // rcx
  int v61; // r15d
  __int64 n3; // r8
  __int64 v63; // rcx
  __int64 v64; // rcx
  __int64 v65; // rcx
  __int64 v66; // rcx
  __int64 v67; // rcx
  int v68; // eax
  __int64 v69; // rcx
  _BYTE v71[12]; // [rsp+24h] [rbp-54h]

  v3 = 4 * n0x20_1;
  n0x20 = n0x20_1;
  v5 = 4 * n0x20_1 + 0x11;
  memset(a2, 0, (v5 * v5 + 7) / 8 + 1);
  n6 = 0;
  *a2 = v5;
  for ( i = 0; i < v5; a2[((__int64)(v8 + 6) >> 3) + 1] |= 1 << ((v8 + 6) & 7) )
  {
    v8 = i * (unsigned __int8)*a2;
    ++i;
  }
  for ( j = 0; j < v5; a2[((__int64)v10 >> 3) + 1] |= 1 << (v10 & 7) )
  {
    v10 = j + 6 * (unsigned __int8)*a2;
    ++j;
  }
  for ( n9 = 0; n9 < 9; ++n9 )
  {
    v12 = (__int64)(n9 * (unsigned __int8)*a2) >> 3;
    a2[v12 + 1] |= 1 << ((n9 * *a2) & 7);
    v13 = (__int64)(n9 * (unsigned __int8)*a2 + 1) >> 3;
    a2[v13 + 1] |= 1 << ((n9 * *a2 + 1) & 7);
    v14 = (__int64)(n9 * (unsigned __int8)*a2 + 2) >> 3;
    a2[v14 + 1] |= 1 << ((n9 * *a2 + 2) & 7);
    v15 = (__int64)(n9 * (unsigned __int8)*a2 + 3) >> 3;
    a2[v15 + 1] |= 1 << ((n9 * *a2 + 3) & 7);
    v16 = (__int64)(n9 * (unsigned __int8)*a2 + 4) >> 3;
    a2[v16 + 1] |= 1 << ((n9 * *a2 + 4) & 7);
    v17 = (__int64)(n9 * (unsigned __int8)*a2 + 5) >> 3;
    a2[v17 + 1] |= 1 << ((n9 * *a2 + 5) & 7);
    v18 = (__int64)(n9 * (unsigned __int8)*a2 + 6) >> 3;
    a2[v18 + 1] |= 1 << ((n9 * *a2 + 6) & 7);
    v19 = (__int64)(n9 * (unsigned __int8)*a2 + 7) >> 3;
    a2[v19 + 1] |= 1 << ((n9 * *a2 + 7) & 7);
    v20 = n9 * (unsigned __int8)*a2 + 8;
    a2[((__int64)v20 >> 3) + 1] |= 1 << (v20 & 7);
  }
  for ( n9_1 = 0; n9_1 < 9; ++n9_1 )
  {
    v22 = (__int64)(v5 + n9_1 * (unsigned __int8)*a2 - 8) >> 3;
    a2[v22 + 1] |= 1 << ((v5 + n9_1 * *a2 - 8) & 7);
    v23 = (__int64)(v5 + n9_1 * (unsigned __int8)*a2 - 7) >> 3;
    a2[v23 + 1] |= 1 << ((v5 + n9_1 * *a2 - 7) & 7);
    v24 = (__int64)(v5 + n9_1 * (unsigned __int8)*a2 - 6) >> 3;
    a2[v24 + 1] |= 1 << ((v5 + n9_1 * *a2 - 6) & 7);
    v25 = (__int64)(v5 + n9_1 * (unsigned __int8)*a2 - 5) >> 3;
    a2[v25 + 1] |= 1 << ((v5 + n9_1 * *a2 - 5) & 7);
    v26 = (__int64)(v5 + n9_1 * (unsigned __int8)*a2 - 4) >> 3;
    a2[v26 + 1] |= 1 << ((v5 + n9_1 * *a2 - 4) & 7);
    v27 = (__int64)(v5 + n9_1 * (unsigned __int8)*a2 - 3) >> 3;
    a2[v27 + 1] |= 1 << ((v5 + n9_1 * *a2 - 3) & 7);
    v28 = (__int64)(v5 + n9_1 * (unsigned __int8)*a2 - 2) >> 3;
    a2[v28 + 1] |= 1 << ((v5 + n9_1 * *a2 - 2) & 7);
    LODWORD(v28) = v5 + n9_1 * (unsigned __int8)*a2 - 1;
    v29 = v5 + n9_1 * *a2 - 1;
    a2[((__int64)(int)v28 >> 3) + 1] |= 1 << (v29 & 7);
  }
  v30 = v5 - 8;
  n8 = 8;
  do
  {
    v32 = (__int64)(v30 * (unsigned __int8)*a2) >> 3;
    a2[v32 + 1] |= 1 << ((v30 * *a2) & 7);
    v33 = (__int64)(v30 * (unsigned __int8)*a2 + 1) >> 3;
    a2[v33 + 1] |= 1 << ((v30 * *a2 + 1) & 7);
    v34 = (__int64)(v30 * (unsigned __int8)*a2 + 2) >> 3;
    a2[v34 + 1] |= 1 << ((v30 * *a2 + 2) & 7);
    v35 = (__int64)(v30 * (unsigned __int8)*a2 + 3) >> 3;
    a2[v35 + 1] |= 1 << ((v30 * *a2 + 3) & 7);
    v36 = (__int64)(v30 * (unsigned __int8)*a2 + 4) >> 3;
    a2[v36 + 1] |= 1 << ((v30 * *a2 + 4) & 7);
    v37 = (__int64)(v30 * (unsigned __int8)*a2 + 5) >> 3;
    a2[v37 + 1] |= 1 << ((v30 * *a2 + 5) & 7);
    v38 = (__int64)(v30 * (unsigned __int8)*a2 + 6) >> 3;
    a2[v38 + 1] |= 1 << ((v30 * *a2 + 6) & 7);
    v39 = (__int64)(v30 * (unsigned __int8)*a2 + 7) >> 3;
    a2[v39 + 1] |= 1 << ((v30 * *a2 + 7) & 7);
    v40 = v30 * (unsigned __int8)*a2 + 8;
    ++v30;
    v41 = (__int64)v40 >> 3;
    n0x1A = (unsigned __int8)a2[v41 + 1] | (1 << (v40 & 7));
    a2[v41 + 1] = n0x1A;
    --n8;
  }
  while ( n8 );
  if ( n0x20 == 1 )
  {
    v43 = 0;
  }
  else
  {
    v43 = ((int)((unsigned __int64)(0x92492493LL * n0x20) >> 0x20) >> 2)
        + ((unsigned int)((unsigned __int64)(0x92492493LL * n0x20) >> 0x20) >> 0x1F)
        + 2;
    if ( n0x20 == 0x20 )
      n0x1A = 0x1A;
    else
      n0x1A = 2 * ((2 * (v43 + 2 * n0x20) + 1) / (2 * v43 - 2));
    v44 = v43 - 1;
    for ( k = v3 + 0xA; v44 >= 1; k -= n0x1A )
      v71[v44--] = k;
    v71[0] = 6;
  }
  v46 = 0;
  if ( v43 > 0 )
  {
    for ( m = 0; m < v43; ++m )
    {
      v48 = 0;
      for ( n = 0; n < v43; ++n )
      {
        if ( m || n && (n0x1A = v43 - 1, v48 != v43 - 1) )
        {
          n0x1A = v43 - 1;
          if ( v46 != v43 - 1 || n )
          {
            n5 = 5;
            v51 = (unsigned __int8)v71[m];
            v52 = (unsigned __int8)v71[n] - 2;
            do
            {
              v53 = (__int64)(v51 + v52 * (unsigned __int8)*a2 - 2) >> 3;
              a2[v53 + 1] |= 1 << ((v51 + v52 * *a2 - 2) & 7);
              v54 = (__int64)(v51 + v52 * (unsigned __int8)*a2 - 1) >> 3;
              a2[v54 + 1] |= 1 << ((v51 + v52 * *a2 - 1) & 7);
              v55 = (__int64)(v51 + v52 * (unsigned __int8)*a2) >> 3;
              a2[v55 + 1] |= 1 << ((v51 + v52 * *a2) & 7);
              v56 = (__int64)(v51 + v52 * (unsigned __int8)*a2 + 1) >> 3;
              a2[v56 + 1] |= 1 << ((v51 + v52 * *a2 + 1) & 7);
              LODWORD(v56) = v52 * (unsigned __int8)*a2;
              ++v52;
              LODWORD(v56) = v51 + v56 + 2;
              v57 = v56;
              v58 = (__int64)(int)v56 >> 3;
              n0x1A = (unsigned __int8)a2[v58 + 1] | (1 << (v57 & 7));
              a2[v58 + 1] = n0x1A;
              --n5;
            }
            while ( n5 );
          }
        }
        ++v48;
      }
      ++v46;
    }
    n0x20 = n0x20_1;
  }
  if ( n0x20 >= 7 )
  {
    do
    {
      v59 = (__int64)(v5 + n6 * (unsigned __int8)*a2 - 0xB) >> 3;
      a2[v59 + 1] |= 1 << ((v5 + n6 * *a2 - 0xB) & 7);
      v60 = (__int64)(v5 + n6 * (unsigned __int8)*a2 - 0xA) >> 3;
      a2[v60 + 1] |= 1 << ((v5 + n6 * *a2 - 0xA) & 7);
      LODWORD(v60) = n6 * (unsigned __int8)*a2;
      ++n6;
      a2[((__int64)(v5 + (int)v60 - 9) >> 3) + 1] |= 1 << ((v5 + v60 - 9) & 7);
    }
    while ( n6 < 6 );
    v61 = v5 - 0xB;
    n3 = 3;
    do
    {
      v63 = (__int64)(v61 * (unsigned __int8)*a2) >> 3;
      a2[v63 + 1] |= 1 << ((v61 * *a2) & 7);
      v64 = (__int64)(v61 * (unsigned __int8)*a2 + 1) >> 3;
      a2[v64 + 1] |= 1 << ((v61 * *a2 + 1) & 7);
      v65 = (__int64)(v61 * (unsigned __int8)*a2 + 2) >> 3;
      a2[v65 + 1] |= 1 << ((v61 * *a2 + 2) & 7);
      v66 = (__int64)(v61 * (unsigned __int8)*a2 + 3) >> 3;
      a2[v66 + 1] |= 1 << ((v61 * *a2 + 3) & 7);
      v67 = (__int64)(v61 * (unsigned __int8)*a2 + 4) >> 3;
      a2[v67 + 1] |= 1 << ((v61 * *a2 + 4) & 7);
      v68 = v61 * (unsigned __int8)*a2;
      ++v61;
      v68 += 5;
      v69 = (__int64)v68 >> 3;
      n0x1A = (unsigned __int8)a2[v69 + 1] | (1 << (v68 & 7));
      a2[v69 + 1] = n0x1A;
      --n3;
    }
    while ( n3 );
  }
  return n0x1A;
}

// --- End Function: sub_1477303B0 (0x1477303B0) ---

// --- Function: sub_147730BA0 (0x147730BA0) ---
char __fastcall sub_147730BA0(
        __int64 a1,
        unsigned __int64 a2,
        int n2_2,
        int n7_3,
        int n7_1,
        int n8_3,
        char a7,
        _BYTE *a8,
        _BYTE *a9)
{
  int n7; // esi
  __int64 v12; // rdi
  int v13; // r14d
  int n8; // ebp
  int v15; // r8d
  int v16; // r11d
  unsigned int v17; // ecx
  int n0x7FFF; // r9d
  unsigned __int64 v19; // r10
  int n0x7FFF_1; // ebx
  _DWORD *v21; // r8
  int v22; // edx
  int v23; // ecx
  int n3; // r15d
  int v25; // edx
  unsigned int v26; // ecx
  int n2; // r10d
  int v28; // kr00_4
  int v29; // edx
  unsigned int v30; // ecx
  int v31; // kr04_4
  int v32; // edx
  unsigned int v33; // ecx
  int v34; // r8d
  _DWORD *v35; // rbx
  int v36; // r14d
  int v37; // r10d
  __int64 v38; // rdx
  int v39; // r10d
  int v40; // r10d
  unsigned int j; // r11d
  __int64 v42; // r9
  char v43; // dl
  int i; // r11d
  __int64 v45; // rdx
  char v46; // cl
  __int64 v47; // r10
  char v48; // al
  int v49; // r9d
  unsigned int v50; // ecx
  int v51; // ebx
  int v52; // eax
  int k; // ecx
  unsigned __int8 m; // r11
  int n7_2; // r10d
  __int64 v56; // r9
  char v57; // dl
  int v58; // r8d
  unsigned int v59; // edx
  int n8_2; // r14d
  int n0x7FFFFFFF; // esi
  int n0x7FFFFFFF_1; // ebx
  int n0x7FFFFFFF_2; // eax
  int n8_1; // ecx
  int n2_1; // [rsp+70h] [rbp+18h]
  int v68; // [rsp+78h] [rbp+20h]

  n2_1 = n2_2;
  n7 = n7_3;
  v12 = n7_3 + 0x29LL * n2_2;
  v13 = 0x10 * (n7_3 + 8);
  n8 = 0;
  while ( 1 )
  {
    v15 = n7 * v13 + 0x40;
    v68 = v15;
    v16 = v15;
    if ( n7 >= 2 )
    {
      v17 = ((int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 2)
          + 2
          + ((unsigned int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 0x1F);
      v15 += 0x37 - v17 * (0x19 * v17 - 0xA);
      if ( n7 >= 7 )
        v15 -= 0x24;
    }
    n0x7FFF = 0;
    v19 = 0;
    n0x7FFF_1 = 8 * (v15 / 8 - byte_148E9E060[v12] * byte_148E9E060[v12 + 0xB0]);
    if ( a2 )
    {
      v21 = (_DWORD *)(a1 + 0x10);
      v22 = (n7 + 7) / 0x11;
      do
      {
        switch ( v21[0xFFFFFFFC] )
        {
          case 1:
            v23 = dword_148E9E1C8[v22];
            break;
          case 2:
            v23 = dword_148E9E1D8[v22];
            break;
          case 4:
            v23 = dword_148E9E1E8[v22];
            break;
          case 7:
            v23 = 0;
            break;
          case 8:
            v23 = dword_148E9E1F8[v22];
            break;
          default:
            v23 = 0xFFFFFFFF;
            break;
        }
        if ( v21[0xFFFFFFFD] >= 1 << v23 )
          goto LABEL_24;
        n0x7FFF += v23 + *v21 + 4;
        if ( n0x7FFF > 0x7FFF )
          goto LABEL_24;
        ++v19;
        v21 += 6;
      }
      while ( v19 < a2 );
      v16 = n7 * v13 + 0x40;
    }
    if ( n0x7FFF != 0xFFFFFFFF && n0x7FFF <= n0x7FFF_1 )
      break;
LABEL_24:
    if ( n7 >= n7_1 )
    {
      *a9 = 0;
      return 0;
    }
    ++n7;
    v13 += 0x10;
    ++v12;
  }
  n3 = 3;
  if ( a7 )
  {
    v25 = v16;
    if ( n7 >= 2 )
    {
      v26 = ((int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 2)
          + 2
          + ((unsigned int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 0x1F);
      v25 = 0x10 * n7 * (n7 + 8) - v26 * (0x19 * v26 - 0xA) + 0x77;
      if ( n7 >= 7 )
        v25 = 0x10 * n7 * (n7 + 8) - v26 * (0x19 * v26 - 0xA) + 0x53;
    }
    n2 = 1;
    v28 = v25;
    v29 = v16;
    if ( n0x7FFF > 8 * (v28 / 8 - byte_148E9E060[n7 + 0xD9] * byte_148E9E060[n7 + 0x29]) )
      n2 = n2_2;
    if ( n7 >= 2 )
    {
      v30 = ((int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 2)
          + 2
          + ((unsigned int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 0x1F);
      v29 = 0x10 * n7 * (n7 + 8) - v30 * (0x19 * v30 - 0xA) + 0x77;
      if ( n7 >= 7 )
        v29 = 0x10 * n7 * (n7 + 8) - v30 * (0x19 * v30 - 0xA) + 0x53;
    }
    v31 = v29;
    v32 = v16;
    if ( n0x7FFF <= 8 * (v31 / 8 - byte_148E9E060[n7 + 0x102] * byte_148E9E060[n7 + 0x52]) )
      n2 = 2;
    if ( n7 >= 2 )
    {
      v33 = ((int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 2)
          + 2
          + ((unsigned int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 0x1F);
      v32 = 0x10 * n7 * (n7 + 8) - v33 * (0x19 * v33 - 0xA) + 0x77;
      if ( n7 >= 7 )
        v32 = 0x10 * n7 * (n7 + 8) - v33 * (0x19 * v33 - 0xA) + 0x53;
    }
    if ( n0x7FFF <= 8 * (v32 / 8 - byte_148E9E060[n7 + 0x12B] * byte_148E9E060[n7 + 0x7B]) )
      n2 = 3;
    n2_1 = n2;
  }
  memset(a9, 0, ((4 * n7 + 0x11) * (4 * n7 + 0x11) + 7) / 8 + 1);
  v34 = 0;
  if ( a2 )
  {
    v35 = (_DWORD *)(a1 + 0x10);
    v36 = (n7 + 7) / 0x11;
    while ( 1 )
    {
      v37 = v35[0xFFFFFFFC];
      a9[(__int64)v34 >> 3] |= ((v37 & 8) != 0) << (7 - (v34 & 7));
      a9[(v34 + 1LL) >> 3] |= ((v37 & 4) != 0) << (7 - ((v34 + 1) & 7));
      a9[(v34 + 2LL) >> 3] |= ((v37 & 2) != 0) << (7 - ((v34 + 2) & 7));
      v38 = (v34 + 3LL) >> 3;
      LOBYTE(v37) = (v37 & 1) << (7 - ((v34 + 3) & 7));
      v34 += 4;
      a9[v38] |= v37;
      if ( v35[0xFFFFFFFC] == 1 )
        break;
      switch ( v35[0xFFFFFFFC] )
      {
        case 2:
          v39 = dword_148E9E1D8[v36];
          goto LABEL_53;
        case 4:
          v39 = dword_148E9E1E8[v36];
          goto LABEL_53;
        case 8:
          v39 = dword_148E9E1F8[v36];
          goto LABEL_53;
      }
LABEL_55:
      for ( i = 0; i < *v35; a9[v47] |= ((*(_BYTE *)(v45 + *((_QWORD *)v35 + 0xFFFFFFFF)) >> v46) & 1) << (7 - v48) )
      {
        v45 = (__int64)i >> 3;
        v46 = 7 - (i & 7);
        v47 = (__int64)v34 >> 3;
        ++i;
        v48 = v34++ & 7;
      }
      v35 += 6;
      if ( !--a2 )
      {
        n3 = 3;
        goto LABEL_59;
      }
    }
    v39 = dword_148E9E1C8[v36];
LABEL_53:
    v40 = v39 - 1;
    for ( j = v35[0xFFFFFFFD]; v40 >= 0; --v40 )
    {
      v42 = (__int64)v34 >> 3;
      v43 = 7 - (v34++ & 7);
      a9[v42] |= ((j >> v40) & 1) << v43;
    }
    goto LABEL_55;
  }
LABEL_59:
  v49 = v68;
  if ( n7 >= 2 )
  {
    v50 = ((int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 2)
        + 2
        + ((unsigned int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 0x1F);
    v49 = 0x37 - v50 * (0x19 * v50 - 0xA) + v68;
    if ( n7 >= 7 )
      v49 -= 0x24;
  }
  v51 = 8 * (v49 / 8 - byte_148E9E060[0x29 * n2_1 + n7] * byte_148E9E060[0x29 * n2_1 + 0xB0 + n7]);
  v52 = v51 - v34;
  if ( v51 - v34 > 4 || (n3 = v52 - 1, v52 - 1 >= 0) )
  {
    do
    {
      ++v34;
      --n3;
    }
    while ( n3 >= 0 );
  }
  for ( k = (8 - v34 % 8) % 8 - 1; k >= 0; --k )
    ++v34;
  for ( m = 0xEC; v34 < v51; m ^= 0xFDu )
  {
    for ( n7_2 = 7; n7_2 >= 0; --n7_2 )
    {
      v56 = (__int64)v34 >> 3;
      v57 = 7 - (v34++ & 7);
      a9[v56] |= ((m >> n7_2) & 1) << v57;
    }
  }
  sub_14772E870((__int64)a9, n7, n2_1, a8);
  sub_1477303B0(n7, a9);
  v58 = 0x10 * (n7 * (n7 + 8) + 4);
  if ( n7 >= 2 )
  {
    v59 = ((unsigned int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 0x1F)
        + 2
        + ((int)((unsigned __int64)(0x92492493LL * n7) >> 0x20) >> 2);
    v58 += 0x37 - v59 * (0x19 * v59 - 0xA);
    if ( n7 >= 7 )
      v58 -= 0x24;
  }
  sub_14772EF20((__int64)a8, v58 / 8, a9);
  sub_14772F920(a9, n7);
  sub_1477303B0(n7, a8);
  n8_2 = n8_3;
  if ( n8_3 == 0xFFFFFFFF )
  {
    n0x7FFFFFFF = 0x7FFFFFFF;
    do
    {
      n0x7FFFFFFF_1 = n0x7FFFFFFF;
      sub_14772EC60(a8, a9, n8);
      sub_14772F0D0(n2_1, n8, a9);
      n0x7FFFFFFF_2 = sub_14772FEF0(a9);
      n8_1 = n8;
      if ( n0x7FFFFFFF_2 < n0x7FFFFFFF )
        n0x7FFFFFFF = n0x7FFFFFFF_2;
      if ( n0x7FFFFFFF_2 >= n0x7FFFFFFF_1 )
        n8_1 = n8_2;
      n8_2 = n8_1;
      sub_14772EC60(a8, a9, n8++);
    }
    while ( n8 < 8 );
  }
  sub_14772EC60(a8, a9, n8_2);
  sub_14772F0D0(n2_1, n8_2, a9);
  return 1;
}

// --- End Function: sub_147730BA0 (0x147730BA0) ---

// --- Function: sub_147731320 (0x147731320) ---
char __fastcall sub_147731320(_BYTE *a1, _BYTE *a2, _BYTE *a3, int n2, int n7, int n0x28, int n8, char a8)
{
  unsigned __int64 n0x7FFF_3; // rbp
  unsigned __int64 n0x7FFF; // rbx
  char Val; // cl
  _BYTE *v16; // rdx
  unsigned __int64 n0x7FFF_2; // r15
  char Val_1; // al
  int n0x18000; // ecx
  __int64 v20; // rax
  __int128 v21; // xmm0
  _BYTE *v22; // rdi
  int n0x10000; // eax
  int v24; // eax
  _BYTE *v25; // rcx
  __int64 v26; // rsi
  unsigned __int64 n0x7FFF_1; // rdx
  int v28[4]; // [rsp+50h] [rbp-58h] BYREF
  __int64 v29; // [rsp+60h] [rbp-48h]
  _BYTE v30[64]; // [rsp+68h] [rbp-40h] BYREF

  n0x7FFF_3 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x7FFF = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0x7FFF;
  while ( a1[n0x7FFF] );
  if ( !n0x7FFF )
    return sub_147730BA0(0, 0, n2, n7, n0x28, n8, a8, a2, a3);
  Val = *a1;
  v16 = a1;
  n0x7FFF_2 = ((4 * n0x28 + 0x11) * (4 * n0x28 + 0x11) + 7) / 8 + 1;
  if ( Val )
  {
    Val_1 = Val;
    while ( (unsigned __int8)(Val_1 - 0x30) <= 9u )
    {
      Val_1 = *++v16;
      if ( !Val_1 )
        goto LABEL_9;
    }
    v22 = a1;
    while ( strchr(
              off_149C3E418,                    // "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
              Val) )
    {
      Val = *++v22;
      if ( !Val )
      {
        if ( n0x7FFF <= 0x7FFF )
        {
          n0x10000 = 0xB * n0x7FFF + 1;
          if ( n0x10000 < 0x10000 )
          {
            v24 = n0x10000 / 2;
            if ( v24 != 0xFFFFFFFF )
              n0x7FFF_3 = (unsigned __int64)(v24 + 7LL) >> 3;
          }
        }
        if ( n0x7FFF_3 <= n0x7FFF_2 )
        {
          v20 = sub_1477315E0(v30, a1, a2);
          goto LABEL_15;
        }
        goto LABEL_31;
      }
    }
    if ( n0x7FFF <= n0x7FFF_2 )
    {
      v25 = a2;
      v26 = a1 - a2;
      n0x7FFF_1 = n0x7FFF;
      do
      {
        *v25 = v25[v26];
        ++v25;
        --n0x7FFF_1;
      }
      while ( n0x7FFF_1 );
      v28[0] = 4;
      LODWORD(v29) = sub_14772EEA0(4, n0x7FFF);
      if ( (_DWORD)v29 != 0xFFFFFFFF )
      {
        v28[1] = n0x7FFF;
        *(_QWORD *)&v28[2] = a2;
        return sub_147730BA0((__int64)v28, 1u, n2, n7, n0x28, n8, a8, a2, a3);
      }
    }
    goto LABEL_31;
  }
LABEL_9:
  if ( n0x7FFF <= 0x7FFF )
  {
    n0x18000 = 0xA * n0x7FFF + 2;
    if ( n0x18000 < 0x18000 && n0x18000 / 3 != 0xFFFFFFFF )
      n0x7FFF_3 = (unsigned __int64)(n0x18000 / 3 + 7LL) >> 3;
  }
  if ( n0x7FFF_3 > n0x7FFF_2 )
  {
LABEL_31:
    *a3 = 0;
    return 0;
  }
  v20 = sub_147731960(v30, a1, a2);
LABEL_15:
  v21 = *(_OWORD *)v20;
  v29 = *(_QWORD *)(v20 + 0x10);
  *(_OWORD *)v28 = v21;
  return sub_147730BA0((__int64)v28, 1u, n2, n7, n0x28, n8, a8, a2, a3);
}

// --- End Function: sub_147731320 (0x147731320) ---

// --- Function: sub_1477315A0 (0x1477315A0) ---
bool __fastcall sub_1477315A0(unsigned __int8 *a1, int a2, int a3)
{
  int v4; // ecx

  v4 = *a1;
  return a2 >= 0
      && a2 < v4
      && a3 >= 0
      && a3 < v4
      && ((a1[((__int64)(a2 + a3 * v4) >> 3) + 1] >> ((a2 + a3 * v4) & 7)) & 1) != 0;
}

// --- End Function: sub_1477315A0 (0x1477315A0) ---

// --- Function: sub_1477315E0 (0x1477315E0) ---
__int64 __fastcall sub_1477315E0(__int64 a1, char *a2, void *a3)
{
  char *v4; // rdi
  unsigned __int64 n0x7FFF; // r9
  int v7; // eax
  int v8; // r9d
  __int16 v9; // si
  char Val; // al
  int n2; // ebp
  const char *v12; // r9
  unsigned __int16 v13; // ax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 result; // rax

  v4 = a2;
  n0x7FFF = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0x7FFF;
  while ( a2[n0x7FFF] );
  *(_DWORD *)a1 = 2;
  v7 = sub_14772EEA0(2, n0x7FFF);
  *(_DWORD *)(a1 + 4) = v8;
  if ( v7 > 0 )
    memset(a3, 0, (unsigned __int64)(v7 + 7LL) >> 3);
  *(_DWORD *)(a1 + 0x10) = 0;
  v9 = 0;
  Val = *v4;
  n2 = 0;
  if ( *v4 )
  {
    v12 = off_149C3E418;                        // "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
    do
    {
      v13 = (unsigned __int16)strchr(v12, Val);
      v12 = off_149C3E418;                      // "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
      ++n2;
      v9 = v13 + 0x2D * v9 - (_WORD)off_149C3E418;// "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
      if ( n2 == 2 )
      {
        *((_BYTE *)a3 + ((__int64)*(int *)(a1 + 0x10) >> 3)) |= ((v9 & 0x400) != 0) << (7 - (*(_DWORD *)(a1 + 0x10) & 7));
        v14 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v14 + 1;
        *((_BYTE *)a3 + ((v14 + 1) >> 3)) |= ((v9 & 0x200) != 0) << (7 - ((v14 + 1) & 7));
        v15 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v15 + 1;
        *((_BYTE *)a3 + ((v15 + 1) >> 3)) |= (HIBYTE(v9) & 1) << (7 - ((v15 + 1) & 7));
        v16 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v16 + 1;
        *((_BYTE *)a3 + ((v16 + 1) >> 3)) |= ((v9 & 0x80) != 0) << (7 - ((v16 + 1) & 7));
        v17 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v17 + 1;
        *((_BYTE *)a3 + ((v17 + 1) >> 3)) |= ((v9 & 0x40) != 0) << (7 - ((v17 + 1) & 7));
        v18 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v18 + 1;
        *((_BYTE *)a3 + ((v18 + 1) >> 3)) |= ((v9 & 0x20) != 0) << (7 - ((v18 + 1) & 7));
        v19 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v19 + 1;
        *((_BYTE *)a3 + ((v19 + 1) >> 3)) |= ((v9 & 0x10) != 0) << (7 - ((v19 + 1) & 7));
        v20 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v20 + 1;
        *((_BYTE *)a3 + ((v20 + 1) >> 3)) |= ((v9 & 8) != 0) << (7 - ((v20 + 1) & 7));
        v21 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v21 + 1;
        *((_BYTE *)a3 + ((v21 + 1) >> 3)) |= ((v9 & 4) != 0) << (7 - ((v21 + 1) & 7));
        v22 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v22 + 1;
        *((_BYTE *)a3 + ((v22 + 1) >> 3)) |= ((v9 & 2) != 0) << (7 - ((v22 + 1) & 7));
        v23 = *(int *)(a1 + 0x10) + 1LL;
        *(_DWORD *)(a1 + 0x10) = v23;
        *((_BYTE *)a3 + (v23 >> 3)) |= (v9 & 1) << (7 - (v23 & 7));
        v9 = 0;
        ++*(_DWORD *)(a1 + 0x10);
        n2 = 0;
      }
      Val = *++v4;
    }
    while ( Val );
    if ( n2 > 0 )
    {
      *((_BYTE *)a3 + ((__int64)*(int *)(a1 + 0x10) >> 3)) |= ((v9 & 0x20) != 0) << (7 - (*(_DWORD *)(a1 + 0x10) & 7));
      v24 = *(int *)(a1 + 0x10);
      *(_DWORD *)(a1 + 0x10) = v24 + 1;
      *((_BYTE *)a3 + ((v24 + 1) >> 3)) |= ((v9 & 0x10) != 0) << (7 - ((v24 + 1) & 7));
      v25 = *(int *)(a1 + 0x10);
      *(_DWORD *)(a1 + 0x10) = v25 + 1;
      *((_BYTE *)a3 + ((v25 + 1) >> 3)) |= ((v9 & 8) != 0) << (7 - ((v25 + 1) & 7));
      v26 = *(int *)(a1 + 0x10);
      *(_DWORD *)(a1 + 0x10) = v26 + 1;
      *((_BYTE *)a3 + ((v26 + 1) >> 3)) |= ((v9 & 4) != 0) << (7 - ((v26 + 1) & 7));
      v27 = *(int *)(a1 + 0x10);
      *(_DWORD *)(a1 + 0x10) = v27 + 1;
      *((_BYTE *)a3 + ((v27 + 1) >> 3)) |= ((v9 & 2) != 0) << (7 - ((v27 + 1) & 7));
      v28 = *(int *)(a1 + 0x10);
      *(_DWORD *)(a1 + 0x10) = v28 + 1;
      *((_BYTE *)a3 + ((v28 + 1) >> 3)) |= (v9 & 1) << (7 - ((v28 + 1) & 7));
      ++*(_DWORD *)(a1 + 0x10);
    }
    result = a1;
    *(_QWORD *)(a1 + 8) = a3;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = a3;
    return a1;
  }
  return result;
}

// --- End Function: sub_1477315E0 (0x1477315E0) ---

// --- Function: sub_147731960 (0x147731960) ---
__int64 __fastcall sub_147731960(__int64 a1, char *a2, void *a3)
{
  char *v4; // rdi
  unsigned __int64 n0x7FFF; // r9
  int v7; // eax
  int v8; // r9d
  unsigned int v9; // r9d
  char v10; // al
  int n3; // edx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  int i; // r10d

  v4 = a2;
  n0x7FFF = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0x7FFF;
  while ( a2[n0x7FFF] );
  *(_DWORD *)a1 = 1;
  v7 = sub_14772EEA0(1, n0x7FFF);
  *(_DWORD *)(a1 + 4) = v8;
  if ( v7 > 0 )
    memset(a3, 0, (unsigned __int64)(v7 + 7LL) >> 3);
  *(_DWORD *)(a1 + 0x10) = 0;
  v9 = 0;
  v10 = *v4;
  n3 = 0;
  if ( *v4 )
  {
    do
    {
      ++n3;
      v9 = v10 + 2 * (5 * v9 - 0x18);
      if ( n3 == 3 )
      {
        *((_BYTE *)a3 + ((__int64)*(int *)(a1 + 0x10) >> 3)) |= ((v9 & 0x200) != 0) << (7 - (*(_DWORD *)(a1 + 0x10) & 7));
        v12 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v12 + 1;
        *((_BYTE *)a3 + ((v12 + 1) >> 3)) |= (BYTE1(v9) & 1) << (7 - ((v12 + 1) & 7));
        v13 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v13 + 1;
        *((_BYTE *)a3 + ((v13 + 1) >> 3)) |= ((v9 & 0x80) != 0) << (7 - ((v13 + 1) & 7));
        v14 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v14 + 1;
        *((_BYTE *)a3 + ((v14 + 1) >> 3)) |= ((v9 & 0x40) != 0) << (7 - ((v14 + 1) & 7));
        v15 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v15 + 1;
        *((_BYTE *)a3 + ((v15 + 1) >> 3)) |= ((v9 & 0x20) != 0) << (7 - ((v15 + 1) & 7));
        v16 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v16 + 1;
        *((_BYTE *)a3 + ((v16 + 1) >> 3)) |= ((v9 & 0x10) != 0) << (7 - ((v16 + 1) & 7));
        v17 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v17 + 1;
        *((_BYTE *)a3 + ((v17 + 1) >> 3)) |= ((v9 & 8) != 0) << (7 - ((v17 + 1) & 7));
        v18 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v18 + 1;
        *((_BYTE *)a3 + ((v18 + 1) >> 3)) |= ((v9 & 4) != 0) << (7 - ((v18 + 1) & 7));
        v19 = *(int *)(a1 + 0x10);
        *(_DWORD *)(a1 + 0x10) = v19 + 1;
        *((_BYTE *)a3 + ((v19 + 1) >> 3)) |= ((v9 & 2) != 0) << (7 - ((v19 + 1) & 7));
        v20 = *(int *)(a1 + 0x10) + 1LL;
        *(_DWORD *)(a1 + 0x10) = v20;
        *((_BYTE *)a3 + (v20 >> 3)) |= (v9 & 1) << (7 - (v20 & 7));
        v9 = 0;
        ++*(_DWORD *)(a1 + 0x10);
        n3 = 0;
      }
      v10 = *++v4;
    }
    while ( v10 );
    if ( n3 > 0 )
    {
      for ( i = 3 * n3; i >= 0; --i )
        *((_BYTE *)a3 + ((__int64)*(int *)(a1 + 0x10) >> 3)) |= ((v9 >> i) & 1) << (7 - ((*(_DWORD *)(a1 + 0x10))++ & 7));
    }
  }
  *(_QWORD *)(a1 + 8) = a3;
  return a1;
}

// --- End Function: sub_147731960 (0x147731960) ---

// --- Function: unknown_libname_249 (0x148142C40) ---
// Microsoft VisualC v14 64bit runtime
const __m128i *__fastcall unknown_libname_249(const __m128i *a1, const __m128i *a2, unsigned int a3)
{
  signed __int64 v3; // r9
  const __m128i *v8; // r10
  unsigned __int64 v11; // r9
  const __m128i *v12; // r10
  __m128i v13; // xmm1
  __int64 v14; // rax

  v3 = (char *)a2 - (char *)a1;
  if ( (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL) != 0 && (dword_149C5AA54 & 0x20) != 0 )
  {
    _XMM2 = a3;
    _YMM2 = (__m256i)a3;
    __asm
    {
      vpshufd xmm2, xmm2, 0
      vinsertf128 ymm2, ymm2, xmm2, 1
    }
    v8 = (const __m128i *)((char *)a1 + (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL));
    while ( 1 )
    {
      __asm
      {
        vpcmpeqd ymm1, ymm2, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        break;
      a1 += 2;
      if ( a1 == v8 )
      {
        v3 &= 0x1Fu;
        __asm { vzeroupper }
        goto LABEL_7;
      }
    }
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
LABEL_7:
    v11 = v3 & 0xFFFFFFFFFFFFFFF0uLL;
    if ( v11 )
    {
      v12 = (const __m128i *)((char *)a1 + v11);
      v13 = _mm_shuffle_epi32(_mm_cvtsi32_si128(a3), 0);
      while ( 1 )
      {
        LODWORD(v14) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_loadu_si128(a1), v13));
        if ( (_DWORD)v14 )
          break;
        if ( ++a1 == v12 )
          goto LABEL_11;
      }
      _BitScanForward((unsigned int *)&v14, v14);
      return (const __m128i *)((char *)a1 + v14);
    }
    else
    {
LABEL_11:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i32[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 4);
      }
      return a1;
    }
  }
}

// --- End Function: unknown_libname_249 (0x148142C40) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14814323E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14814323E) ---

// --- Function: ?_Xout_of_range@std@@YAXPEBD@Z (0x148143244) ---
// attributes: thunk
void __fastcall std::_Xout_of_range(const char *a1)
{
  __imp_?_Xout_of_range@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xout_of_range@std@@YAXPEBD@Z (0x148143244) ---

// --- Function: ?_Xbad_function_call@std@@YAXXZ (0x14814324A) ---
// attributes: thunk
void std::_Xbad_function_call(void)
{
  __imp_?_Xbad_function_call@std@@YAXXZ();
}

// --- End Function: ?_Xbad_function_call@std@@YAXXZ (0x14814324A) ---

// --- Function: ?_Xinvalid_argument@std@@YAXPEBD@Z (0x1481433B2) ---
// attributes: thunk
void __fastcall std::_Xinvalid_argument(const char *a1)
{
  __imp_?_Xinvalid_argument@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xinvalid_argument@std@@YAXPEBD@Z (0x1481433B2) ---

// --- Function: _onexit (0x14814406C) ---
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)(); // rdx

  if ( Table._first == (_PVFV *)0xFFFFFFFFFFFFFFFFLL )
    v2 = crt_atexit((_PVFV)Func);
  else
    v2 = register_onexit_function(&Table, Func);
  v3 = 0;
  if ( !v2 )
    return Func;
  return v3;
}

// --- End Function: _onexit (0x14814406C) ---

// --- Function: atexit (0x1481440A8) ---
int __cdecl atexit(void (__cdecl *Func)())
{
  return (onexit((_onexit_t)Func) != 0) - 1;
}

// --- End Function: atexit (0x1481440A8) ---

// --- Function: __alloca_probe (0x148144150) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x148144150) ---

// --- Function: __security_check_cookie (0x1481441B0) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x1481441B0) ---

// --- Function: __tlregdtor (0x148144278) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 0x18B0);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 0x18C0);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 0x18B0) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 0x1E )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 0x18B0);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x148144278) ---

// --- Function: __raise_securityfailure (0x148144378) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x148144378) ---

// --- Function: __report_gsfailure (0x1481443AC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151877A00 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1518779F0 = 0xC0000409;
  dword_1518779F4 = 1;
  dword_151877A08 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1481443AC) ---

// --- Function: __report_rangecheckfailure (0x148144480) ---
void __noreturn _report_rangecheckfailure()
{
  _report_securityfailure(8);
}

// --- End Function: __report_rangecheckfailure (0x148144480) ---

// --- Function: __report_securityfailure (0x148144494) ---
void __fastcall __noreturn _report_securityfailure(unsigned int n2_1)
{
  DWORD64 retaddr; // [rsp+28h] [rbp+0h]
  unsigned int n2; // [rsp+30h] [rbp+8h] BYREF

  n2 = n2_1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(n2);
  capture_current_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&n2;
  qword_151877A00 = retaddr;
  dword_1518779F0 = 0xC0000409;
  dword_1518779F4 = 1;
  dword_151877A08 = 1;
  n2_3 = n2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_securityfailure (0x148144494) ---

// --- Function: capture_current_context (0x148144530) ---
struct _RUNTIME_FUNCTION *__fastcall capture_current_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rdi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+50h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+58h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+60h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
  if ( FunctionEntry )
    return (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                         0,
                                         ImageBase,
                                         ControlPc,
                                         FunctionEntry,
                                         ContextRecord,
                                         &HandlerData,
                                         &EstablisherFrame,
                                         0);
  return FunctionEntry;
}

// --- End Function: capture_current_context (0x148144530) ---

// --- Function: __libm_sse2_sincosf_ (0x1481446C0) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall _libm_sse2_sincosf_(double a1, __int64 a2, double a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm1
  __m128 result; // xmm0

  *(float *)&a3 = *(float *)&a1;
  v3 = (__m128)_mm_and_si128(*(__m128i *)&a3, (__m128i)xmmword_1494915B0);
  if ( v3.m128_f32[0] < 0.00012207031 )
  {
    return _mm_unpacklo_ps(
             *(__m128 *)&a1,
             _mm_sub_ps((__m128)0x3F800000u, _mm_mul_ps(_mm_mul_ps(v3, v3), (__m128)xmmword_1494915D0)));
  }
  else
  {
    v4 = 0;
    v4.m128_f32[0] = v3.m128_f32[0] + 1.5707964;
    result = _mm_unpacklo_ps(*(__m128 *)&a1, v4);
    _vdecl_sinf4();
  }
  return result;
}

// --- End Function: __libm_sse2_sincosf_ (0x1481446C0) ---

// --- Function: memcpy (0x148192BDB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x148192BDB) ---

// --- Function: memmove (0x148192BE1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148192BE1) ---

// --- Function: memset (0x148192BE7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148192BE7) ---

// --- Function: strchr (0x148192BF3) ---
// attributes: thunk
char *__cdecl strchr(const char *Str, int Val)
{
  return __imp_strchr(Str, Val);
}

// --- End Function: strchr (0x148192BF3) ---

// --- Function: strstr (0x148192BF9) ---
// attributes: thunk
char *__cdecl strstr(const char *Str, const char *SubStr)
{
  return __imp_strstr(Str, SubStr);
}

// --- End Function: strstr (0x148192BF9) ---

// --- Function: memcmp (0x148192C05) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148192C05) ---

// --- Function: _CxxThrowException (0x148192C2F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x148192C2F) ---

// --- Function: free_0 (0x148192CA7) ---
// attributes: thunk
void __cdecl free_0(void *Block)
{
  free(Block);
}

// --- End Function: free_0 (0x148192CA7) ---

// --- Function: malloc_0 (0x148192CAD) ---
// attributes: thunk
void *__cdecl malloc_0(size_t Size)
{
  return malloc(Size);
}

// --- End Function: malloc_0 (0x148192CAD) ---

// --- Function: atan2f (0x148192CDD) ---
// attributes: thunk
float __cdecl atan2f(float Y, float X)
{
  return __imp_atan2f(Y, X);
}

// --- End Function: atan2f (0x148192CDD) ---

// --- Function: powf (0x148192CEF) ---
// attributes: thunk
float __cdecl powf(float X, float Y)
{
  return __imp_powf(X, Y);
}

// --- End Function: powf (0x148192CEF) ---

// --- Function: tanf (0x148192D25) ---
// attributes: thunk
float __cdecl tanf(float X)
{
  return __imp_tanf(X);
}

// --- End Function: tanf (0x148192D25) ---

// --- Function: _register_onexit_function (0x148192DD9) ---
// attributes: thunk
int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function)
{
  return _register_onexit_function(Table, Function);
}

// --- End Function: _register_onexit_function (0x148192DD9) ---

// --- Function: _crt_atexit (0x148192DDF) ---
// attributes: thunk
int __cdecl crt_atexit(_PVFV Function)
{
  return _crt_atexit(Function);
}

// --- End Function: _crt_atexit (0x148192DDF) ---

// --- Function: sub_1481CE000 (0x1481CE000) ---
__int64 sub_1481CE000()
{
  __int64 v0; // rax

  v0 = NtCurrentTeb_w();
  return sub_1402A6590(**(_QWORD **)(v0 + 0x10));
}

// --- End Function: sub_1481CE000 (0x1481CE000) ---

// --- Function: nullsub_13 (0x1481CE9F0) ---
void __fastcall nullsub_13()
{
  ;
}

// --- End Function: nullsub_13 (0x1481CE9F0) ---

// --- Function: nullsub_14 (0x1481CEA00) ---
void __fastcall nullsub_14()
{
  ;
}

// --- End Function: nullsub_14 (0x1481CEA00) ---

// --- Function: sub_1481CF6E0 (0x1481CF6E0) ---
__int64 sub_1481CF6E0()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = NtCurrentTeb_w();
  sub_1402A6590(*(_QWORD *)(*(_QWORD *)(v0 + 0x10) + 0x18LL));
  result = NtCurrentTeb_w();
  *(_QWORD *)(*(_QWORD *)(result + 0x10) + 0x18LL) = 0;
  return result;
}

// --- End Function: sub_1481CF6E0 (0x1481CF6E0) ---

// --- Function: nullsub_16 (0x1481D0550) ---
void __fastcall nullsub_16()
{
  ;
}

// --- End Function: nullsub_16 (0x1481D0550) ---

// --- Function: sub_148246980 (0x148246980) ---
void __fastcall sub_148246980()
{
  sub_140373CC0(&qword_149F58E90);
}

// --- End Function: sub_148246980 (0x148246980) ---

// --- Function: sub_148246A10 (0x148246A10) ---
void __fastcall sub_148246A10()
{
  sub_140465FA0((__int64)qword_149F56F20);
}

// --- End Function: sub_148246A10 (0x148246A10) ---

// --- Function: nullsub_122 (0x14827B290) ---
void __fastcall nullsub_122()
{
  ;
}

// --- End Function: nullsub_122 (0x14827B290) ---

// --- Function: sub_148284620 (0x148284620) ---
void __fastcall sub_148284620()
{
  sub_1413B53B0((__int64)&qword_1516F2288, (__int64)&qword_1516F2288, *(__int64 **)(qword_1516F2288 + 8));
  sub_1402A6590(qword_1516F2288);
}

// --- End Function: sub_148284620 (0x148284620) ---

// --- Function: sub_148286160 (0x148286160) ---
void __fastcall sub_148286160()
{
  sub_140375900(&qword_1516FA790);
}

// --- End Function: sub_148286160 (0x148286160) ---

// --- Function: sub_14828CDF0 (0x14828CDF0) ---
void __fastcall sub_14828CDF0()
{
  sub_140373CC0(&qword_151750520);
}

// --- End Function: sub_14828CDF0 (0x14828CDF0) ---

