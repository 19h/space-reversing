// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1444989E0 (sub_1444989E0)
// Caller Depth: 0
// Callee/Ref Depth: 4
// Total Functions Found: 235
// ------------------------------------------------------------

// --- Function: identity (0x1402A24F0) ---
// A simple passthrough function that returns its input argument unchanged.
__int64 __fastcall identity(__int64 input_value)
{
  return input_value;
}

// --- End Function: identity (0x1402A24F0) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: sub_1402A2B70 (0x1402A2B70) ---
_QWORD *__fastcall sub_1402A2B70(_QWORD *a1)
{
  _QWORD *result; // rax

  result = (_QWORD *)*a1;
  *(_QWORD *)*a1 = 0xFFFFFFFFFFFFFFFFuLL;
  return result;
}

// --- End Function: sub_1402A2B70 (0x1402A2B70) ---

// --- Function: sub_1402A2B80 (0x1402A2B80) ---
__int64 __fastcall sub_1402A2B80(__int64 a1, __int64 a2)
{
  return a2;
}

// --- End Function: sub_1402A2B80 (0x1402A2B80) ---

// --- Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---
bool __fastcall AK::WriteBytesCount::Reserve(AK::WriteBytesCount *this)
{
  return 0;
}

// --- End Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---

// --- Function: ?do_is_equal@_Identity_equal_resource@pmr@std@@MEBA_NAEBVmemory_resource@23@@Z (0x1402A3450) ---
bool __fastcall std::pmr::_Identity_equal_resource::do_is_equal(
        std::pmr::_Identity_equal_resource *this,
        const struct std::pmr::memory_resource *this_1)
{
  return this == this_1;
}

// --- End Function: ?do_is_equal@_Identity_equal_resource@pmr@std@@MEBA_NAEBVmemory_resource@23@@Z (0x1402A3450) ---

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall sub_1402A3D30(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
// // A wrapper function for allocWithProfilerInfo that allocates memory // without
// providing specific profiler information. It simply forwards // the allocation
// size to the main allocation function with a null // profiler context. // //
// Parameters: //   allocSize: The size of memory in bytes to allocate. // //
// Returns: //   A pointer to the newly allocated memory block, or nullptr if
// allocation fails.
__int64 __fastcall allocWithProfilerInfo_w(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---
_QWORD *__fastcall std::_Allocate<16,std::_Default_allocate_traits,0>(unsigned __int64 _Bytes)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  _QWORD *result; // rax

  if ( _Bytes < 0x1000 )
  {
    if ( _Bytes )
      return (_QWORD *)allocWithProfilerInfo_w(_Bytes);
    else
      return 0;
  }
  else
  {
    if ( _Bytes + 0x27 < _Bytes )
      sub_1402E1170();
    v1 = allocWithProfilerInfo_w(_Bytes + 0x27);
    v2 = v1;
    if ( !v1 )
      invalid_parameter_noinfo_noreturn();
    result = (_QWORD *)((v1 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    result[0xFFFFFFFF] = v2;
  }
  return result;
}

// --- End Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall sub_1402A6760(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 0x28;
    if ( v6 + 0x28 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v15[0xFFFFFFFF] = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - v17[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v17 = (_QWORD *)v17[0xFFFFFFFF];
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: sub_1402ABD50 (0x1402ABD50) ---
// attributes: thunk
void __fastcall sub_1402ABD50(_QWORD *pManagedObjectPtr)
{
  sub_140370D10(pManagedObjectPtr);
}

// --- End Function: sub_1402ABD50 (0x1402ABD50) ---

// --- Function: sub_1402AE3D0 (0x1402AE3D0) ---
__int64 *__fastcall sub_1402AE3D0(__int64 *a1, const char *a2, __int64 a3, char a4)
{
  *a1 = a3;
  sub_1402CD240(a3, a2, a4);
  return a1;
}

// --- End Function: sub_1402AE3D0 (0x1402AE3D0) ---

// --- Function: sub_1402AE400 (0x1402AE400) ---
__int64 __fastcall sub_1402AE400(__int64 a1, const char *a2, __int64 a3, char a4, char a5, const char *a6)
{
  *(_BYTE *)(a1 + 8) = a4;
  *(_QWORD *)a1 = a3;
  if ( a4 )
    sub_1402D2710(a3, a2, a6, a5);
  return a1;
}

// --- End Function: sub_1402AE400 (0x1402AE400) ---

// --- Function: sub_1402AE480 (0x1402AE480) ---
__int64 __fastcall sub_1402AE480(__int64 a1, const char *a2, __int64 a3, char a4, char a5, const char *a6)
{
  *(_BYTE *)(a1 + 8) = a4;
  *(_QWORD *)a1 = a3;
  if ( a4 )
    sub_1402DE3A0(a3, a2, a6, a5);
  return a1;
}

// --- End Function: sub_1402AE480 (0x1402AE480) ---

// --- Function: sub_1402B15B0 (0x1402B15B0) ---
_QWORD *__fastcall sub_1402B15B0(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return a1;
}

// --- End Function: sub_1402B15B0 (0x1402B15B0) ---

// --- Function: sub_1402B1670 (0x1402B1670) ---
_QWORD *__fastcall sub_1402B1670(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

// --- End Function: sub_1402B1670 (0x1402B1670) ---

// --- Function: sub_1402B1820 (0x1402B1820) ---
const ULONG_PTR *__fastcall sub_1402B1820(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v4; // eax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 0x14);
  if ( v2 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v4 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v1, v4);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402B1820 (0x1402B1820) ---

// --- Function: sub_1402B1860 (0x1402B1860) ---
unsigned __int64 __fastcall sub_1402B1860(__int64 a1)
{
  unsigned __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) )
    return rw_lock_release_read_lock(*(_QWORD *)a1);
  return result;
}

// --- End Function: sub_1402B1860 (0x1402B1860) ---

// --- Function: sub_1402B1870 (0x1402B1870) ---
const ULONG_PTR *__fastcall sub_1402B1870(const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source_1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source; // rcx
  int v3; // eax
  unsigned __int64 n0x200000; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
  p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source = *p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
  if ( p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source && *((_BYTE *)p_p_p_p_p_p_p_p_p_p_p_p_Source + 8) )
  {
    v3 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x14);
    if ( v3 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v3 - 1);
      *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(
                    (volatile signed __int64 *)p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
                    0,
                    0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return rw_lock_handle_write_release_contention(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source, n0x200000);
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402B1870 (0x1402B1870) ---

// --- Function: LogTraceConditional (0x1402C1000) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( gEnv && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
        qword_149B4FCB0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C1000) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: sub_1402CD240 (0x1402CD240) ---
__int64 __fastcall sub_1402CD240(__int64 a1, const char *a2, char a3)
{
  __int64 result; // rax
  int v7; // edi
  unsigned __int32 v8; // eax

  result = get_thread_context_ptr();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v8 )
    {
      result = sub_1403C33A0(a1, v8, a2, a3);
    }
    else
    {
      result = get_thread_context_ptr();
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v7;
  }
  return result;
}

// --- End Function: sub_1402CD240 (0x1402CD240) ---

// --- Function: sub_1402D2710 (0x1402D2710) ---
// Acquires a read lock on a read-write lock. It handles recursive read lock
// acquisitions by the same thread by incrementing a recursive count. For non-
// recursive acquisitions, it atomically increments the lock state. If the
// incremented value indicates a pending write lock, it dispatches to a more
// detailed acquisition function, potentially for profiling or contention handling.
double __fastcall sub_1402D2710(__int64 rw_lock_ptr, const char *a2, const char *a3, char a4)
{
  signed __int64 v8; // rdx
  double result; // xmm0_8

  if ( *(_DWORD *)(rw_lock_ptr + 0x10) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(rw_lock_ptr + 0x14);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)rw_lock_ptr);
    if ( (v8 & 0x200000) != 0 )
      return rw_lock_acquire_read_lock_dispatch(rw_lock_ptr, v8, a2, a3, a4);
  }
  return result;
}

// --- End Function: sub_1402D2710 (0x1402D2710) ---

// --- Function: rw_lock_release_read_lock (0x1402D2790) ---
// Releases a read lock on a read-write lock. If the current thread is the
// recursive owner, it decrements the recursive count. Otherwise, it atomically
// decrements the main lock state. If the lock state transitions to indicate no
// more readers and pending write locks, it dispatches to a contention handler.
unsigned __int64 __fastcall rw_lock_release_read_lock(__int64 p_rw_lock_state)
{
  unsigned __int64 thread_context_ptr; // rax
  unsigned __int64 lock_state_after_decrement; // rdx

  thread_context_ptr = get_thread_context_ptr();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(thread_context_ptr + 0x18)
    && (thread_context_ptr = *(unsigned int *)(p_rw_lock_state + 0x14), (_DWORD)thread_context_ptr) )
  {
    thread_context_ptr = (unsigned int)(thread_context_ptr - 1);
    *(_DWORD *)(p_rw_lock_state + 0x14) = thread_context_ptr;
  }
  else
  {
    lock_state_after_decrement = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (lock_state_after_decrement & 0x3FF) == 0 )
    {
      thread_context_ptr = 0xFFFF0000FFC00000uLL;
      if ( (lock_state_after_decrement & 0xFFFF0000FFC00000uLL) != 0 )
        return rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, lock_state_after_decrement);
    }
  }
  return thread_context_ptr;
}

// --- End Function: rw_lock_release_read_lock (0x1402D2790) ---

// --- Function: sub_1402DE3A0 (0x1402DE3A0) ---
unsigned __int64 __fastcall sub_1402DE3A0(__int64 a1, const char *a2, const char *a3, char a4)
{
  unsigned __int64 result; // rax
  int v9; // edi
  __int64 v10; // r8

  result = get_thread_context_ptr();
  v9 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v9 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v10 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0x200000, 0);
    if ( result )
      result = sub_1403DCD60(a1, result, v10, a2, a3, a4);
    else
      *(_QWORD *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 0x10) = v9;
  }
  return result;
}

// --- End Function: sub_1402DE3A0 (0x1402DE3A0) ---

// --- Function: sub_1402DE4A0 (0x1402DE4A0) ---
const ULONG_PTR *__fastcall sub_1402DE4A0(__int64 a1)
{
  int v1; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int64 n0x200000; // rax

  v1 = *(_DWORD *)(a1 + 0x14);
  if ( v1 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v1 - 1);
    *(_DWORD *)(a1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return rw_lock_handle_write_release_contention(a1, n0x200000);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402DE4A0 (0x1402DE4A0) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)get_thread_context_ptr() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n0x16; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n0x16 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 0xF;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    v10[0xFFFFFFFF] = v9;
    goto LABEL_17;
  }
  n0x16 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n0x16 = 0x16;
  if ( n0x16 + 1 >= 0x1000 )
  {
    allocSize = n0x16 + 0x28;
    if ( n0x16 + 0x28 < n0x16 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n0x16 == 0xFFFFFFFFFFFFFFFFuLL )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n0x16 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n0x16;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n0x100; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n0x100 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 0x50) < *(_QWORD *)(*(_QWORD *)v8 + 0x50LL) )
          {
            n0x100 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i + 0xFFFFFFFF);
              i += 0xFFFFFFF8;
              n0x100 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n0x100 )
              {
                if ( *(_QWORD *)(v14 + 8) != n0x100 )
                  break;
                n0x100 = *(_QWORD *)(v17 + 0x50);
                if ( *(_QWORD *)(v14 + 0x50) >= (unsigned __int64)n0x100 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n0x100 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 0x50) < *(_QWORD *)(v25 + 0x50) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 0x50) >= *(_QWORD *)(v21 + 0x50)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n0x100 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30 - v8) >> 3, &v33);
        v30 += 0xFFFFFFFF;
        n0x100 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n0x100 >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: unknown_libname_475 (0x1402FEF90) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
_QWORD *__fastcall unknown_libname_475(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  *a1 = a2;
  result = a1;
  a1[1] = a3;
  return result;
}

// --- End Function: unknown_libname_475 (0x1402FEF90) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    memset(&Src, 0, sizeof(Src));
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 0x20) = 0;
      *(_QWORD *)(v23 + 0x28) = 0;
      *(__m256 *)(v23 + 0x10) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 0xF;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x10LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x28LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(__int64 a1, _QWORD *a2, __int64 a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  unsigned __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  unsigned __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(a3 + 0x24));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(a3 + 0x20);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(a3 + 8);
  v18 = *(_QWORD *)a3;
  v31 = v16;
  if ( (v17 - *(_QWORD *)a3) / 0x70 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 0x58) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 0x40))();
        v18 += 0x70;
      }
      while ( v18 != v17 );
      *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
    }
    sub_1402FDB90((__int64 *)a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 0x30;
    v23 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v29 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v16 )
    {
      v20 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 0x18)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 0x70LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 0x30),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)a3));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v26 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 0x38)
          && *(_QWORD *)(v26 + 0x20) )
        {
          if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 0x70LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)a3;
          if ( *(_BYTE *)(v27 + 0x58) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 0x40))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 0x38))(*(_QWORD *)(v26 - 0x10));
          v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 0x10) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 0x18) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 0x20) = *(_QWORD *)(v26 + 0x10);
          *(_QWORD *)(v27 + 0x30) = *(_QWORD *)(v26 + 0x20);
          *(_QWORD *)(v27 + 0x28) = *(_QWORD *)(v26 + 0x18);
          *(_QWORD *)(v27 + 0x38) = *(_QWORD *)(v26 + 0x28);
          *(_QWORD *)(v27 + 0x40) = *(_QWORD *)(v26 + 0x30);
          *(_QWORD *)(v27 + 0x48) = *(_QWORD *)(v26 + 0x38);
          *(_QWORD *)(v27 + 0x50) = *(_QWORD *)(v26 + 0x40);
          *(_QWORD *)(v27 + 0x60) = *(_QWORD *)(v26 + 0x50);
          *(_QWORD *)(v27 + 0x68) = *(_QWORD *)(v26 + 0x58);
          *(_BYTE *)(v27 + 0x58) = 1;
          *(_BYTE *)(v27 + 0x59) = *(_BYTE *)(v26 + 0x49);
        }
        ++_Newcapacity_2;
        v26 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(a3 + 0x18) = a1;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", v3 - 0x3E8 * v7) + 0x13);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 status_bits; // rax

  if ( qword_149B3B1F0 )
    status_bits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    status_bits = 1;
  if ( !qword_149B3B208 )
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)status_bits & 0xFFFFFFF7;
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *event_data_ptr,
        _BYTE *Src,
        char *a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *event_data_ptr;
  if ( !((event_data_ptr[1] - *event_data_ptr) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *event_data_ptr;
  }
  while ( v62 < (event_data_ptr[1] - *event_data_ptr) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *event_data_ptr,
        char *a7,
        char *a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *event_data_ptr_1; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *event_data_ptr_3; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *event_data_ptr_2; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  event_data_ptr_1 = event_data_ptr;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 0x80;
  n0xF_5[0] = n4;
  event_data_ptr_2 = event_data_ptr;
  n0xF_17 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    event_data_ptr_1 = event_data_ptr_2;
LABEL_57:
    n0xF_25 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  event_data_ptr_1 = event_data_ptr_2;
  n0xF_25 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              v162,
              v161,
              n4_1,
              v166,
              event_data_ptr_1,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (a18 & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_356;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_26 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_96;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_18 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_97;
  }
LABEL_96:
  v47 = 1;
LABEL_97:
  event_data_ptr_3 = event_data_ptr_2;
  v59 = event_data_ptr_2[1];
  v60 = *event_data_ptr_2;
  v61 = (v59 - *event_data_ptr_2) >> 2;
  if ( !v61 )
    goto LABEL_146;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_135;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_132;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_132;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_106:
      invalid_parameter_noinfo();
      goto LABEL_107;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_106;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_107:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_130:
      n0xF_3 = n0xF + 0x80;
LABEL_131:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      event_data_ptr_3 = event_data_ptr_2;
      goto LABEL_132;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_112;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_120;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_120;
        *errno() = 0x22;
      }
      else
      {
LABEL_112:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_120:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_130;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_131;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_128;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_128:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    event_data_ptr_3 = event_data_ptr_2;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_133;
    }
LABEL_132:
    v47 = 1;
LABEL_133:
    v59 = event_data_ptr_3[1];
    ++v62;
    v60 = *event_data_ptr_3;
    v75 = v59 - *event_data_ptr_3;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_135:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_149;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_158;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_142;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_142:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_158:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_147;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_146:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_149:
    v47 = 1;
  }
  else
  {
LABEL_147:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_149;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_164;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_164:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 0xB;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_172:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_172;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_186;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_186:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_209:
    v47 = 1;
    goto LABEL_210;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_200:
        ++n0xF_2;
        goto LABEL_201;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_200;
  }
  v47 = 1;
LABEL_201:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_209;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_208;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_208:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_210:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            v164,
            __Val_0___1,
            _Newcapacity,
            a11,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_224;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_224:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_16 = n0xF_2;
              goto LABEL_250;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_238;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_238:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_249:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_250:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_285;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_257;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_257:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_282;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_263;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_271;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_263:
                  *errno() = 0x16;
                  goto LABEL_270;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_270:
                  invalid_parameter_noinfo();
                }
LABEL_271:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_282:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_279;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_279:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_286;
                }
              }
              v105 = v160;
            }
LABEL_285:
            v47 = 1;
LABEL_286:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_294;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_294:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_308:
                Buffer_3 = Buffer;
                goto LABEL_309;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_308;
          }
LABEL_284:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_285;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_284;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_16 = n0xF_2;
          goto LABEL_250;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_247;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_247:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_249;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_308;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_308;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_309;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_309:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_316;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_316:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_317;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_333;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_333:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_317:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_338;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_338:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( a19 <= 1 )
  {
LABEL_345:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_347;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_345;
    }
LABEL_347:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_353;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_353:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_356:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 event_data_ptr_2,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_371;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_370;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_368;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_368:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_371:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_370:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    v147 = v161;
    qword_149B3B210(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      event_data_ptr_2,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
// A comprehensive function for logging and dispatching telemetry events. It
// captures system time, generates unique identifiers, formats event data
// (including parameters and tags) into a buffer, and conditionally outputs to
// console or dispatches to various logging handlers based on configuration and
// event type. It also handles dynamic memory allocation and deallocation for event
// data structures.
void __fastcall sub_1403045C0(
        unsigned int event_severity_level,
        __int64 *event_data_ptr,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 v84; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char v89; // cl
  int v90; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v94; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  const void *Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *v110; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v112; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int v116; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v128; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v132; // [rsp+118h] [rbp+78h]
  char *v133; // [rsp+120h] [rbp+80h]
  __int64 *event_data_ptr_1; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v132 = a4;
  v133 = a3;
  event_data_ptr_1 = event_data_ptr;
  n4 = event_severity_level;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  v128 = v12;
  if ( v11 && !sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity) )
    return;
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v20 = v117;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v147[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400_1 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400_1 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            sub_1402A6760(v14, _Whereptr, __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        sub_1402A6760(v14, _Whereptr_1, (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)__Val_0___1 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v142, __Val_0___1);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)__Val_0___1, &v130, &__Val_0___4);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      __Val_0___5 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v48 = *(_QWORD **)__Val_0___7;
        v49 = **(_QWORD ***)__Val_0___7;
        if ( v49 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        __Val_0___7 = __Val_0___6;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          __Val_0___3 = __Val_0___5;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        __Val_0___3 = __Val_0___5;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v57;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              sub_1402A6760(v14, _Whereptr_2, __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          sub_1402A6760(v14, _Whereptr_3, &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    __Val_0___1 = __Val_0___2;
    v29 = v143;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[__Val_0___4];
    v124 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 0x70);
    v69 = v120;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 0xA) = v29;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * n0x400], (__int64)(8 * n0x400) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v76 = *(_QWORD *)&v71[8 * n0x400_3];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_130;
    }
  }
  v84 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v84 = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(v84 & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_130:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(v128, n4, v133, event_data_ptr_1, v132, __Val_0__, _Newcapacity, v146, n0x10_1, &a8);
    v123[0] = v87;
  }
  v89 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&FileTime,
            v128,
            (__int64)String,
            n4,
            event_data_ptr_1,
            v133,
            v132,
            __Val_0__,
            _Newcapacity,
            a7,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &a8);
    v89 = a8;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (v89 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v83);
    v89 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v89 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v83);
    n2_126 = ::n2_126;
  }
  v83[v88] = 0;
  v94 = a8;
  v95 = (a8 & 1) != 0 && n2_125 == 2;
  v96 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = (const void *)Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v117;
LABEL_166:
    v116 = v123[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v128,
      Buffer,
      String,
      n4,
      event_data_ptr_1,
      v133,
      v132,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v71,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      a8,
      v116);
    sub_1402A3D30(Buffer_3);
    v94 = a8;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v94 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v94 = a8;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (v94 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    v110 = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = v110[5];
        v112 = (_QWORD *)*v110;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)v110[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_190;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        v110[4] = 0;
        v110[5] = 0xF;
        *((_BYTE *)v110 + 0x10) = 0;
        sub_1402A3D30(v110);
        v110 = v112;
      }
      while ( v112 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *handle_ptr)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *handle_ptr;
  if ( !*handle_ptr )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)get_thread_context_ptr() )
    return sub_14031FE20(handle_ptr) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_desc_ptr)
{
  unsigned __int64 entity_desc_val; // r9
  __int64 entity_base_addr_or_id; // r10
  unsigned __int64 entity_type_flags; // r9
  __int64 align_mask; // rax
  __int64 aligned_base_addr_or_id; // r10
  __int64 entity_header_ptr; // rbx
  bool is_privileged_or_bypass; // al

  entity_desc_val = *entity_desc_ptr;
  if ( !*entity_desc_ptr )
    return 0;
  entity_base_addr_or_id = entity_desc_val & 0xFFFFFFFFFFFFLL;
  entity_type_flags = HIWORD(entity_desc_val);
  if ( (entity_type_flags & 0xF000) != 0 )
  {
    align_mask = map_flag_to_mask(0x2000u);
    entity_header_ptr = aligned_base_addr_or_id & ~(align_mask - 1);
  }
  else
  {
    entity_header_ptr = entity_base_addr_or_id - 6;
  }
  if ( *(_WORD *)(entity_header_ptr + 2) != (entity_type_flags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || (is_privileged_or_bypass = is_thread_privileged_or_bypass_mode()) )
    is_privileged_or_bypass = 1;
  return *(_WORD *)(entity_header_ptr + 4) == 2 && is_privileged_or_bypass
      || validate_entity_descriptor_detailed_access(entity_desc_ptr) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *qword_ptr)
{
  return *qword_ptr & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: sub_1403235B0 (0x1403235B0) ---
_WORD *__fastcall sub_1403235B0(_WORD *a1, __int16 a2)
{
  *a1 = a2;
  return a1;
}

// --- End Function: sub_1403235B0 (0x1403235B0) ---

// --- Function: sub_1403239F0 (0x1403239F0) ---
char __fastcall sub_1403239F0(__int64 a1, const void **a2)
{
  char result; // al
  __int64 v5; // rcx
  __int64 v6; // rax

  if ( !*(_BYTE *)(a1 + 0x28) || (result = sub_14037F680((unsigned __int16 **)(a1 + 0x48), a2)) != 0 )
  {
    sub_140378020((void **)(a1 + 0x48), a2);
    result = *(_BYTE *)(a1 + 0x2A);
    *(_BYTE *)(a1 + 0x28) = 1;
    v5 = *(_QWORD *)(a1 + 0x18);
    if ( v5 && *(_DWORD *)(v5 + 8) )
    {
      if ( !result )
      {
        *(_BYTE *)(a1 + 0x2A) = 1;
        if ( *(_BYTE *)(a1 + 0x2B) )
        {
          v6 = sub_14030ED10(a1 + 8);
          return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x18LL))(v6, *(unsigned int *)(a1 + 8));
        }
      }
    }
    else if ( !result )
    {
      *(_BYTE *)(a1 + 0x2A) = 1;
    }
  }
  return result;
}

// --- End Function: sub_1403239F0 (0x1403239F0) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int result_mask; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        result_mask = 0;
        if ( input_flag == 0x6000 )
          return 0x4000000;
        return result_mask;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_1403335B0 (0x1403335B0) ---
__int64 __fastcall sub_1403335B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_1403335B0 (0x1403335B0) ---

// --- Function: sub_14033B1A0 (0x14033B1A0) ---
_QWORD *__fastcall sub_14033B1A0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_35;
  if ( n0xFFFF_35 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v9,
                          "IVehicle");
    n0xFFFF_35 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033B1A0 (0x14033B1A0) ---

// --- Function: sub_140351340 (0x140351340) ---
signed __int64 __fastcall sub_140351340(volatile signed __int64 *a1, void **a2)
{
  void **v4; // rbx
  _BYTE *v5; // rdx
  unsigned __int64 Size; // rax
  signed __int64 v7; // rsi

  if ( *a1 )
    return *a1;
  v4 = (void **)allocWithProfilerInfo_w(8u);
  if ( v4 )
  {
    *v4 = (char *)&qword_149B3B33C + 4;
    v5 = *a2;
    if ( *a2 )
    {
      Size = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++Size;
      while ( v5[Size] );
      sub_1403DE230(v4, v5, (int)Size);
    }
    else
    {
      sub_1403DE230(v4, 0, 0);
    }
  }
  else
  {
    v4 = 0;
  }
  v7 = _InterlockedCompareExchange64(a1, (signed __int64)v4, 0);
  if ( !v7 )
    return *a1;
  if ( v4 )
  {
    if ( *((int *)*v4 + 0xFFFFFFFF) > 0 )
      sub_147605980((char *)*v4 + 0xFFFFFFF8);
    sub_1402A3D30(v4);
  }
  return v7;
}

// --- End Function: sub_140351340 (0x140351340) ---

// --- Function: sub_140356FD0 (0x140356FD0) ---
__int64 __fastcall sub_140356FD0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  const char *p_null_1; // rax
  const char *p_null; // rdx
  unsigned __int64 v7; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Name";
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_1 = (const char *)a2[1];
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  v7 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v7;
  while ( p_null[v7] );
  *(_QWORD *)(a1 + 0x68) = v7;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "EntityId";
  *(_BYTE *)(a1 + 0xC9) = 1;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4C70;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  *(_QWORD *)(a1 + 0xD8) = 0x17;
  return sub_140356B50(a1 + 0xE0, a4, a5) + 2;
}

// --- End Function: sub_140356FD0 (0x140356FD0) ---

// --- Function: sub_140359B80 (0x140359B80) ---
__int64 __fastcall sub_140359B80(unsigned int a1)
{
  return a1;
}

// --- End Function: sub_140359B80 (0x140359B80) ---

// --- Function: sub_14035AE10 (0x14035AE10) ---
_QWORD *__fastcall sub_14035AE10(_QWORD *a1)
{
  *a1 = &off_1481AF038;
  return a1;
}

// --- End Function: sub_14035AE10 (0x14035AE10) ---

// --- Function: sub_14035B410 (0x14035B410) ---
void **__fastcall sub_14035B410(void **a1, const void **a2)
{
  __int64 v4; // rdi

  *a1 = &unk_149B3E478;
  v4 = *((int *)*a2 + 0xFFFFFFFE);
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
  {
    sub_1403DE120(a1, *((int *)*a2 + 0xFFFFFFFE));
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, 2 * v4);
  }
  return a1;
}

// --- End Function: sub_14035B410 (0x14035B410) ---

// --- Function: sub_14035C680 (0x14035C680) ---
__int64 __fastcall sub_14035C680(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = *a2;
  result = a1;
  *(_QWORD *)a1 = a3;
  *(_BYTE *)(a1 + 0x10) = 0;
  return result;
}

// --- End Function: sub_14035C680 (0x14035C680) ---

// --- Function: sub_14035C7B0 (0x14035C7B0) ---
_QWORD *__fastcall sub_14035C7B0(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  *a1 = a3;
  result = a1;
  a1[1] = a2;
  a1[2] = 0;
  return result;
}

// --- End Function: sub_14035C7B0 (0x14035C7B0) ---

// --- Function: sub_14035F010 (0x14035F010) ---
_QWORD *__fastcall sub_14035F010(_QWORD *a1, unsigned __int8 **a2)
{
  void **v4; // rax
  _QWORD *v5; // rax
  __int64 v6; // rdx
  unsigned __int8 *v7; // r8
  __int64 v8; // r9
  int v9; // eax
  int v10; // ecx
  __int64 v11; // rax

  *a1 = &unk_149B3E478;
  v4 = (void **)sub_1403AE5D0();
  v5 = (_QWORD *)sub_140351340(&unk_149B3E230, v4);
  v7 = *a2;
  v8 = *v5 - (_QWORD)*a2;
  do
  {
    v9 = v7[v8];
    v10 = *v7 - v9;
    if ( v10 )
      break;
    ++v7;
  }
  while ( v9 );
  if ( v10 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)qword_149B4FCA0 + 0x4E0LL))(
            qword_149B4FCA0,
            v6,
            v7);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD *, _QWORD))(*(_QWORD *)v11 + 0xA8LL))(v11, *a2, a1, 0);
  }
  return a1;
}

// --- End Function: sub_14035F010 (0x14035F010) ---

// --- Function: sub_1403624E0 (0x1403624E0) ---
__int64 __fastcall sub_1403624E0(__int64 dest_obj_state_ptr, __int64 a2)
{
  *(_QWORD *)dest_obj_state_ptr = *(_QWORD *)a2;
  *(_QWORD *)(dest_obj_state_ptr + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(dest_obj_state_ptr + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(dest_obj_state_ptr + 0x18) = *(_QWORD *)(a2 + 0x18);
  *(_QWORD *)(dest_obj_state_ptr + 0x20) = *(_QWORD *)(a2 + 0x20);
  *(_DWORD *)(dest_obj_state_ptr + 0x28) = *(_DWORD *)(a2 + 0x28);
  *(_QWORD *)(dest_obj_state_ptr + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_QWORD *)(dest_obj_state_ptr + 0x38) = &off_1481B0218;
  *(_OWORD *)(dest_obj_state_ptr + 0x40) = *(_OWORD *)(a2 + 0x40);
  *(double *)(dest_obj_state_ptr + 0x50) = *(double *)(a2 + 0x50);
  *(_DWORD *)(dest_obj_state_ptr + 0x58) = *(_DWORD *)(a2 + 0x58);
  *(_DWORD *)(dest_obj_state_ptr + 0x5C) = *(_DWORD *)(a2 + 0x5C);
  *(_DWORD *)(dest_obj_state_ptr + 0x60) = *(_DWORD *)(a2 + 0x60);
  *(_DWORD *)(dest_obj_state_ptr + 0x64) = *(_DWORD *)(a2 + 0x64);
  *(_DWORD *)(dest_obj_state_ptr + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(dest_obj_state_ptr + 0x6C) = *(_DWORD *)(a2 + 0x6C);
  *(_DWORD *)(dest_obj_state_ptr + 0x70) = *(_DWORD *)(a2 + 0x70);
  *(_DWORD *)(dest_obj_state_ptr + 0x74) = *(_DWORD *)(a2 + 0x74);
  *(_DWORD *)(dest_obj_state_ptr + 0x78) = *(_DWORD *)(a2 + 0x78);
  *(_DWORD *)(dest_obj_state_ptr + 0x7C) = *(_DWORD *)(a2 + 0x7C);
  *(_BYTE *)(dest_obj_state_ptr + 0x80) = *(_BYTE *)(a2 + 0x80);
  *(_QWORD *)(dest_obj_state_ptr + 0x88) = *(_QWORD *)(a2 + 0x88);
  *(_OWORD *)(dest_obj_state_ptr + 0x90) = *(_OWORD *)(a2 + 0x90);
  *(double *)(dest_obj_state_ptr + 0xA0) = *(double *)(a2 + 0xA0);
  *(double *)(dest_obj_state_ptr + 0xA8) = *(double *)(a2 + 0xA8);
  *(_DWORD *)(dest_obj_state_ptr + 0xB0) = *(_DWORD *)(a2 + 0xB0);
  *(double *)(dest_obj_state_ptr + 0xB4) = *(double *)(a2 + 0xB4);
  *(_DWORD *)(dest_obj_state_ptr + 0xBC) = *(_DWORD *)(a2 + 0xBC);
  *(double *)(dest_obj_state_ptr + 0xC0) = *(double *)(a2 + 0xC0);
  *(_DWORD *)(dest_obj_state_ptr + 0xC8) = *(_DWORD *)(a2 + 0xC8);
  *(_DWORD *)(dest_obj_state_ptr + 0xD8) = *(_DWORD *)(a2 + 0xD8);
  *(_DWORD *)(dest_obj_state_ptr + 0xCC) = *(_DWORD *)(a2 + 0xCC);
  *(_DWORD *)(dest_obj_state_ptr + 0xD0) = *(_DWORD *)(a2 + 0xD0);
  *(_DWORD *)(dest_obj_state_ptr + 0xD4) = *(_DWORD *)(a2 + 0xD4);
  *(_DWORD *)(dest_obj_state_ptr + 0xDC) = *(_DWORD *)(a2 + 0xDC);
  *(_DWORD *)(dest_obj_state_ptr + 0xE0) = *(_DWORD *)(a2 + 0xE0);
  *(_BYTE *)(dest_obj_state_ptr + 0xE4) = *(_BYTE *)(a2 + 0xE4);
  *(_BYTE *)(dest_obj_state_ptr + 0xE5) = *(_BYTE *)(a2 + 0xE5);
  *(_BYTE *)(dest_obj_state_ptr + 0xE6) = *(_BYTE *)(a2 + 0xE6);
  *(_BYTE *)(dest_obj_state_ptr + 0xE7) = *(_BYTE *)(a2 + 0xE7);
  *(_BYTE *)(dest_obj_state_ptr + 0xE8) = *(_BYTE *)(a2 + 0xE8);
  *(_BYTE *)(dest_obj_state_ptr + 0xE9) = *(_BYTE *)(a2 + 0xE9);
  *(_BYTE *)(dest_obj_state_ptr + 0xEA) = *(_BYTE *)(a2 + 0xEA);
  *(_BYTE *)(dest_obj_state_ptr + 0xEB) = *(_BYTE *)(a2 + 0xEB);
  *(_BYTE *)(dest_obj_state_ptr + 0xEC) = *(_BYTE *)(a2 + 0xEC);
  *(_BYTE *)(dest_obj_state_ptr + 0xED) = *(_BYTE *)(a2 + 0xED);
  *(_QWORD *)(dest_obj_state_ptr + 0xF0) = *(_QWORD *)(a2 + 0xF0);
  *(_DWORD *)(dest_obj_state_ptr + 0xF8) = *(_DWORD *)(a2 + 0xF8);
  *(_OWORD *)(dest_obj_state_ptr + 0xFC) = *(_OWORD *)(a2 + 0xFC);
  *(_QWORD *)(dest_obj_state_ptr + 0x110) = &off_1481B0218;
  *(_OWORD *)(dest_obj_state_ptr + 0x118) = *(_OWORD *)(a2 + 0x118);
  *(double *)(dest_obj_state_ptr + 0x128) = *(double *)(a2 + 0x128);
  *(_DWORD *)(dest_obj_state_ptr + 0x130) = *(_DWORD *)(a2 + 0x130);
  *(_DWORD *)(dest_obj_state_ptr + 0x134) = *(_DWORD *)(a2 + 0x134);
  *(_DWORD *)(dest_obj_state_ptr + 0x138) = *(_DWORD *)(a2 + 0x138);
  *(_BYTE *)(dest_obj_state_ptr + 0x13C) = *(_BYTE *)(a2 + 0x13C);
  *(_BYTE *)(dest_obj_state_ptr + 0x13D) = *(_BYTE *)(a2 + 0x13D);
  *(_DWORD *)(dest_obj_state_ptr + 0x140) = *(_DWORD *)(a2 + 0x140);
  *(_OWORD *)(dest_obj_state_ptr + 0x144) = *(_OWORD *)(a2 + 0x144);
  *(_WORD *)(dest_obj_state_ptr + 0x154) = *(_WORD *)(a2 + 0x154);
  *(_QWORD *)(dest_obj_state_ptr + 0x158) = *(_QWORD *)(a2 + 0x158);
  return dest_obj_state_ptr;
}

// --- End Function: sub_1403624E0 (0x1403624E0) ---

// --- Function: sub_1403627A0 (0x1403627A0) ---
__int64 __fastcall sub_1403627A0(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        float a6,
        int a7,
        int a8,
        int a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  __int64 result; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a4;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x28) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x38) = &off_1481B0218;
  *(_OWORD *)(a1 + 0x40) = *(_OWORD *)(a5 + 8);
  *(double *)(a1 + 0x50) = *(double *)(a5 + 0x18);
  *(_DWORD *)(a1 + 0x70) = a7;
  *(_DWORD *)(a1 + 0x74) = a9;
  *(_DWORD *)(a1 + 0x78) = a8;
  *(_QWORD *)(a1 + 0x88) = a10;
  *(float *)(a1 + 0x64) = a6;
  *(float *)(a1 + 0x68) = a6;
  *(_DWORD *)(a1 + 0x58) = 0x3F800000;
  *(_QWORD *)(a1 + 0x5C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x6C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x7C) = 0;
  *(_BYTE *)(a1 + 0x80) = 0;
  *(_OWORD *)(a1 + 0x90) = *(_OWORD *)a11;
  *(double *)(a1 + 0xA0) = *(double *)(a11 + 0x10);
  *(double *)(a1 + 0xA8) = *(double *)a12;
  *(_DWORD *)(a1 + 0xB0) = *(_DWORD *)(a12 + 8);
  *(double *)(a1 + 0xB4) = *(double *)a13;
  *(_DWORD *)(a1 + 0xBC) = *(_DWORD *)(a13 + 8);
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_DWORD *)(a1 + 0xD8) = 0x3F800000;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_BYTE *)(a1 + 0x108) = 1;
  *(_QWORD *)(a1 + 0xDC) = 0;
  *(_QWORD *)(a1 + 0xE4) = 0;
  *(_WORD *)(a1 + 0xEC) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x110) = &off_1481B0218;
  *(_QWORD *)(a1 + 0x130) = 0;
  *(_DWORD *)(a1 + 0x138) = 0;
  *(_WORD *)(a1 + 0x13C) = 0;
  *(_DWORD *)(a1 + 0x140) = 0;
  *(_DWORD *)(a1 + 0x144) = 0x800000;
  *(_DWORD *)(a1 + 0x148) = 0x800000;
  *(_DWORD *)(a1 + 0x14C) = 0x800000;
  *(_DWORD *)(a1 + 0x150) = 0x800000;
  sub_1403B3F00((_WORD *)(a1 + 0x154), a2);
  result = a1;
  *(_QWORD *)(a1 + 0x158) = 0;
  return result;
}

// --- End Function: sub_1403627A0 (0x1403627A0) ---

// --- Function: sub_14036BDC0 (0x14036BDC0) ---
__int64 __fastcall sub_14036BDC0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 8) = 0x47C34F80;
  *(_DWORD *)(a1 + 0xC) = 0x47C34F80;
  *(_DWORD *)(a1 + 0x10) = 0x47C34F80;
  *(_DWORD *)(a1 + 0x14) = 0x47C34F80;
  *(_DWORD *)(a1 + 0x18) = 0x47C34F80;
  *(_QWORD *)a1 = &off_1481B0218;
  result = a1;
  *(_DWORD *)(a1 + 0x1C) = 0x47C34F80;
  return result;
}

// --- End Function: sub_14036BDC0 (0x14036BDC0) ---

// --- Function: sub_140370D10 (0x140370D10) ---
// // Decrements a reference count associated with a managed object and //
// deallocates the object's memory if the reference count is still positive. //
// This pattern is characteristic of shared pointer or reference-counted // memory
// management, where the reference count is stored in a control block // located
// just before the actual data pointed to by *a1. // // Parameters: //
// pManagedObjectPtr: A pointer to a QWORD, where the QWORD itself points //
// to the managed data. The reference count is expected //                      at
// an offset of -8 bytes from this data pointer.
void __fastcall sub_140370D10(_QWORD *pManagedObjectPtr)
{
  int *v1; // rcx

  v1 = (int *)(*pManagedObjectPtr - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140370F70 (0x140370F70) ---
void __fastcall sub_140370F70(__int64 a1)
{
  sub_1402A3D30(*(const void **)(a1 + 0x10));
}

// --- End Function: sub_140370F70 (0x140370F70) ---

// --- Function: sub_140372D50 (0x140372D50) ---
// Initializes specific pointers within a structure to point to a default module
// implementation or a vtable for a base class. This is typically part of an
// object's construction or reset process.
void *(__fastcall **__fastcall sub_140372D50(__int64 struct_ptr))(FDefaultModuleImpl *__hidden this, unsigned int)
{
  void *(__fastcall **result)(FDefaultModuleImpl *__hidden, unsigned int); // rax

  result = &off_1481A0DB8;
  *(_QWORD *)(struct_ptr + 0x110) = &off_1481A0DB8;
  *(_QWORD *)(struct_ptr + 0x38) = &off_1481A0DB8;
  return result;
}

// --- End Function: sub_140372D50 (0x140372D50) ---

// --- Function: sub_140377FE0 (0x140377FE0) ---
void **__fastcall sub_140377FE0(void **a1, void **a2)
{
  void *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E98E0(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377FE0 (0x140377FE0) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
         pEntitySystem,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)get_thread_context_ptr() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: ?Count@WriteBytesMem@AK@@UEBAHXZ (0x14037FC60) ---
__int64 __fastcall AK::WriteBytesMem::Count(AK::WriteBytesMem *this)
{
  return *((unsigned int *)this + 6);
}

// --- End Function: ?Count@WriteBytesMem@AK@@UEBAHXZ (0x14037FC60) ---

// --- Function: sub_140380630 (0x140380630) ---
bool __fastcall sub_140380630(unsigned __int64 a1, unsigned __int64 a2)
{
  return a1 < a2;
}

// --- End Function: sub_140380630 (0x140380630) ---

// --- Function: p_p_p_p_p_sub_140384A94 (0x140384A94) ---
void __fastcall p_p_p_p_p_sub_140384A94(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
}

// --- End Function: p_p_p_p_p_sub_140384A94 (0x140384A94) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_thread_context_ptr() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = pEntitySystem;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(pEntitySystem, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: validate_entity_descriptor_detailed_access (0x140392020) ---
// Performs detailed access validation for an entity descriptor. It extracts the
// entity's base address or ID from the descriptor. It then determines a pointer to
// entity metadata based on the highest bit of the descriptor (either by masking or
// by applying a -6 offset to the base address/ID). The function then dispatches to
// different validation logic based on the value of a status/type field at
// `entity_metadata_ptr + 4`: - If 0, returns false. - If 1, calls
// `check_thread_list_contains_value` with the entity's base address/ID. - If 2,
// checks for a privileged/bypass state (via `get_thread_context_ptr + 0x12D` or
// `is_thread_privileged_or_bypass_mode`). If privileged, returns true; otherwise,
// calls `validate_access_with_virtual_calls`. - If 3 or 4, checks thread data from
// `get_thread_context_ptr`. If a specific thread status is 1, it returns true if
// the entity's base address/ID is NOT equal to the magic value `0x13374770CLL`. -
// For any other status/type, returns false.
char __fastcall validate_entity_descriptor_detailed_access(_QWORD *entity_descriptor_ptr)
{
  _QWORD *entity_base_addr_or_id; // rbx
  __int64 entity_metadata_ptr; // rax
  __int64 thread_data_ptr; // rax

  entity_base_addr_or_id = (_QWORD *)(*entity_descriptor_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*entity_descriptor_ptr & 0xF000000000000000uLL) != 0 )
    entity_metadata_ptr = *entity_descriptor_ptr & 0xFFFFFF000000LL;
  else
    entity_metadata_ptr = (__int64)entity_base_addr_or_id + 0xFFFFFFFA;
  if ( !*(_WORD *)(entity_metadata_ptr + 4) )
    return 0;
  if ( *(_WORD *)(entity_metadata_ptr + 4) == 1 )
    return check_thread_list_contains_value((__int64)entity_base_addr_or_id);
  if ( *(_WORD *)(entity_metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(entity_metadata_ptr + 4) - 3 <= 1 )
    {
      thread_data_ptr = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
      if ( thread_data_ptr )
      {
        if ( *(_DWORD *)(thread_data_ptr + 8) == 1 )
          return *entity_base_addr_or_id != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)entity_base_addr_or_id);
}

// --- End Function: validate_entity_descriptor_detailed_access (0x140392020) ---

// --- Function: sub_14039F0F0 (0x14039F0F0) ---
void **sub_14039F0F0(void **a1, const wchar_t **a2, ...)
{
  _QWORD *v4; // rax
  unsigned __int64 v5; // rcx
  wchar_t Buffer[4096]; // [rsp+30h] [rbp-2028h] BYREF
  va_list va; // [rsp+2070h] [rbp+18h] BYREF

  va_start(va, a2);
  *a1 = &unk_149B3E478;
  v4 = sub_1402A4380();
  _stdio_common_vswprintf(*v4 | 1LL, Buffer, 0x1000u, *a2, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1403DE2D0(a1, Buffer, (int)v5);
  return a1;
}

// --- End Function: sub_14039F0F0 (0x14039F0F0) ---

// --- Function: sub_14039F1C0 (0x14039F1C0) ---
void **sub_14039F1C0(void **a1, const wchar_t *Format, ...)
{
  _QWORD *v4; // rax
  unsigned __int64 v5; // rcx
  wchar_t Buffer[4096]; // [rsp+30h] [rbp-2028h] BYREF
  va_list va; // [rsp+2070h] [rbp+18h] BYREF

  va_start(va, Format);
  *a1 = &unk_149B3E478;
  v4 = sub_1402A4380();
  _stdio_common_vswprintf(*v4 | 1LL, Buffer, 0x1000u, Format, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1403DE2D0(a1, Buffer, (int)v5);
  return a1;
}

// --- End Function: sub_14039F1C0 (0x14039F1C0) ---

// --- Function: sub_1403A3CF0 (0x1403A3CF0) ---
__int64 __fastcall sub_1403A3CF0(__int64 a1, unsigned __int8 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEngineComponentScheduler + 0xB0LL))(
           pEngineComponentScheduler,
           a1,
           a2);
}

// --- End Function: sub_1403A3CF0 (0x1403A3CF0) ---

// --- Function: sub_1403A58C0 (0x1403A58C0) ---
__int64 __fastcall sub_1403A58C0(__int64 a1, unsigned __int8 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEngineComponentScheduler + 0xA8LL))(
           pEngineComponentScheduler,
           a1,
           a2);
}

// --- End Function: sub_1403A58C0 (0x1403A58C0) ---

// --- Function: sub_1403AE5D0 (0x1403AE5D0) ---
__int64 sub_1403AE5D0()
{
  __int64 result; // rax
  _QWORD *v1; // rcx
  signed __int64 v2; // rbx

  result = qword_149B3E248;
  if ( !qword_149B3E248 )
  {
    v1 = (_QWORD *)allocWithProfilerInfo_w(8u);
    if ( v1 )
      *v1 = "@LOC_EMPTY";
    else
      v1 = 0;
    v2 = _InterlockedCompareExchange64(&qword_149B3E248, (signed __int64)v1, 0);
    if ( v2 )
    {
      sub_1402A3D30(v1);
      return v2;
    }
    else
    {
      return qword_149B3E248;
    }
  }
  return result;
}

// --- End Function: sub_1403AE5D0 (0x1403AE5D0) ---

// --- Function: sub_1403AE630 (0x1403AE630) ---
__int64 sub_1403AE630()
{
  __int64 result; // rax
  void **v1; // rbx
  signed __int64 v2; // rdi

  result = qword_149B3E278;
  if ( !qword_149B3E278 )
  {
    v1 = (void **)allocWithProfilerInfo_w(8u);
    if ( v1 )
    {
      *v1 = &unk_149B3E478;
      sub_1403DE2D0(v1, (void *)&p_p__n, 0);
    }
    else
    {
      v1 = 0;
    }
    v2 = _InterlockedCompareExchange64(&qword_149B3E278, (signed __int64)v1, 0);
    if ( v2 )
    {
      if ( v1 )
      {
        if ( *((int *)*v1 + 0xFFFFFFFF) > 0 )
          sub_147605980((char *)*v1 + 0xFFFFFFF8);
        sub_1402A3D30(v1);
      }
      return v2;
    }
    else
    {
      return qword_149B3E278;
    }
  }
  return result;
}

// --- End Function: sub_1403AE630 (0x1403AE630) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B0A70 (0x1403B0A70) ---
// Attempts to retrieve an entity's identifier or base address. It first checks if
// the provided entity descriptor is valid and accessible. If so, it calls a
// virtual method on the entity to obtain the ID; otherwise, it sets the output ID
// to zero.
_QWORD *__fastcall sub_1403B0A70(unsigned __int64 *entity_desc_ptr, _QWORD *a2)
{
  if ( is_entity_descriptor_valid_or_accessible(entity_desc_ptr) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*entity_desc_ptr & 0xFFFFFFFFFFFFLL) + 8LL))(
      *entity_desc_ptr & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B0A70 (0x1403B0A70) ---

// --- Function: sub_1403B3E60 (0x1403B3E60) ---
const char *sub_1403B3E60()
{
  return "TraceContext";
}

// --- End Function: sub_1403B3E60 (0x1403B3E60) ---

// --- Function: sub_1403B3F00 (0x1403B3F00) ---
_WORD *__fastcall sub_1403B3F00(_WORD *a1, unsigned __int64 a2)
{
  __int64 v4; // rbx
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int64 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int16 n4; // dx
  __int64 v10; // rbx
  __int64 v11; // rcx
  _BYTE v13[16]; // [rsp+20h] [rbp-38h] BYREF
  unsigned __int64 v14; // [rsp+68h] [rbp+10h] BYREF
  __int64 v15; // [rsp+70h] [rbp+18h] BYREF
  char v16; // [rsp+78h] [rbp+20h] BYREF

  v14 = a2;
  if ( !is_entity_descriptor_valid_or_accessible(&v14) )
    goto LABEL_13;
  v4 = a2 & 0xFFFFFFFFFFFFLL;
  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v4 + 0x340LL);
  n0xFFFF = n0xFFFF_29;
  if ( n0xFFFF_29 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v16,
                          "IActor");
    n0xFFFF_29 = n0xFFFF;
  }
  if ( (LOWORD(v15) = n0xFFFF, v7 = *(_QWORD *)v5(v4, v13, &v15), (v15 = v7) != 0)
    && (v8 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
               pEntitySystem,
               v7 & 0xFFFFFFFFFFFFLL,
               0),
        n4 = *(_WORD *)(v8 + 4),
        n4 != 4)
    && *(_WORD *)(v8 + 2) == (HIWORD(v7) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v15))
    && (v10 = v7 & 0xFFFFFFFFFFFFLL,
        (v11 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x758LL))(v10) + 8) & 0xFFFFFFFFFFFFLL) != 0)
    && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x20LL))(v11) )
  {
    (*(void (__fastcall **)(__int64, _WORD *))(*(_QWORD *)v10 + 0x7F8LL))(v10, a1);
    return a1;
  }
  else
  {
LABEL_13:
    *a1 = 0xFFFF;
    return a1;
  }
}

// --- End Function: sub_1403B3F00 (0x1403B3F00) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
           pEntitySystem,
           a1,
           0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: get_event_key_from_source_location (0x1403BB9D0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149B3D530;
  if ( !qword_149B3D530 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149B3D530 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BB9D0) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
        p_profiler_system,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 0x10) & (unsigned int)(v9 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
      p_profiler_system,
      &v11,
      &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: rw_lock_acquire_write_lock_profiled (0x1403DCDF0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended (e.g., by readers or another writer), it
// waits. Upon successful acquisition, it logs detailed profiling information,
// including timestamps, lock name, lock owner, and caller, using a dedicated
// profiling system. It also sets the lock owner pointer at `p_rw_lock_state + 8`.
__int64 __fastcall rw_lock_acquire_write_lock_profiled(
        __int64 p_rw_lock_state,
        unsigned __int64 rw_lock_state,
        __int64 lock_owner_ptr,
        const char *caller_name,
        const char *lock_name)
{
  __int64 p_profiler_system; // r15
  __int64 thread_context_ptr; // rax
  __int64 p_thread_data; // rsi
  unsigned int thread_id; // r14d
  const char *lock_name_1; // r13
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_3; // rax
  __int64 lock_owner_ptr_2; // rax
  unsigned __int64 new_lock_value_with_thread_id; // rdx
  signed __int64 rw_lock_state_1; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  signed __int64 rw_lock_state_2; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int profiler_event_type_1; // [rsp+30h] [rbp-91h] BYREF
  __int64 profiler_event_flags_1; // [rsp+34h] [rbp-8Dh]
  int profiler_event_level_1; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 start_timestamp_1; // [rsp+40h] [rbp-81h]
  unsigned __int64 end_timestamp_1; // [rsp+48h] [rbp-79h]
  __int64 profiler_data_ptr_1_1; // [rsp+50h] [rbp-71h]
  __int64 profiler_data_ptr_2_1; // [rsp+58h] [rbp-69h]
  int n0x1600; // [rsp+80h] [rbp-41h] BYREF
  __int64 profiler_event_flags_2; // [rsp+84h] [rbp-3Dh]
  int n2; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 start_timestamp_2; // [rsp+90h] [rbp-31h]
  unsigned __int64 end_timestamp_2; // [rsp+98h] [rbp-29h]
  __int64 profiler_data_ptr_1_2; // [rsp+A0h] [rbp-21h]
  __int64 profiler_data_ptr_2_2; // [rsp+A8h] [rbp-19h]
  _BYTE profiler_data_buffer[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char profiler_data_buffer_char; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 lock_owner_ptr_1; // [rsp+130h] [rbp+6Fh]

  lock_owner_ptr_1 = lock_owner_ptr;
  p_profiler_system = ::p_profiler_system;
  thread_context_ptr = get_thread_context_ptr();
  p_thread_data = *(_QWORD *)thread_context_ptr;
  thread_id = *(_DWORD *)(*(_QWORD *)thread_context_ptr + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
    p_profiler_system,
    profiler_data_buffer,
    &profiler_data_buffer_char);
  lock_name_1 = lock_name;
  do
  {
    while ( (rw_lock_state & 0x2003FF) != 0 )
    {
      new_lock_value_with_thread_id = (unsigned __int64)thread_id << 0x30;
      if ( (rw_lock_state & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(p_thread_data + 0x124) = HIWORD(rw_lock_state);
        rw_lock_state_1 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            new_lock_value_with_thread_id | rw_lock_state & 0xFFFFFFFFFFFFLL,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_1;
        rw_lock_state = rw_lock_state_1;
        if ( is_exchange_successful )
        {
          profiler_event_type_1 = 0x1600;
          profiler_event_flags_1 = 1;
          profiler_event_level_1 = 2;
          end_timestamp_1 = 0;
          profiler_data_ptr_1_1 = 0;
          profiler_data_ptr_2_1 = 0;
          start_timestamp_1 = __rdtsc();
          isProfileFunctionsInitialized(
            &profiler_event_type_1,
            &word_149B3E394,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(profiler_event_type_1) = word_149B3E394;
          qword_149B4B8B0("Lock: %s", lock_name_1);
          lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
          qword_149B4B8B0("Caller: %s", caller_name);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(
            p_profiler_system,
            thread_id);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          thread_id = *(_DWORD *)(p_thread_data + 0x11C);
          end_timestamp_1 = __rdtsc();
          qword_149B4B878(&profiler_event_type_1);
        }
      }
      else
      {
        *(_DWORD *)(p_thread_data + 0x124) = 0xFFFFFFFF;
        rw_lock_state_2 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            rw_lock_state | new_lock_value_with_thread_id,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_2;
        rw_lock_state = rw_lock_state_2;
        if ( is_exchange_successful )
        {
          n0x1600 = 0x1600;
          profiler_event_flags_2 = 1;
          n2 = 2;
          end_timestamp_2 = 0;
          profiler_data_ptr_1_2 = 0;
          profiler_data_ptr_2_2 = 0;
          start_timestamp_2 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E398,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600) = word_149B3E398;
          qword_149B4B8B0("Lock: %s", lock_name_1);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", caller_name);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(
            p_profiler_system,
            thread_id);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          thread_id = *(_DWORD *)(p_thread_data + 0x11C);
          end_timestamp_2 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
    }
    rw_lock_state_3 = _InterlockedCompareExchange64(
                        (volatile signed __int64 *)p_rw_lock_state,
                        rw_lock_state | 0x200000,
                        rw_lock_state);
    is_exchange_successful = rw_lock_state == rw_lock_state_3;
    rw_lock_state = rw_lock_state_3;
  }
  while ( !is_exchange_successful );
  lock_owner_ptr_2 = lock_owner_ptr_1;
  *(_QWORD *)(p_rw_lock_state + 8) = lock_owner_ptr_1;
  return lock_owner_ptr_2;
}

// --- End Function: rw_lock_acquire_write_lock_profiled (0x1403DCDF0) ---

// --- Function: rw_lock_acquire_write_lock_unprofiled (0x1403DD0B0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by readers). It then attempts to atomically set the write lock flag or
// increment a write lock count using `_InterlockedCompareExchange64`. Upon
// successful acquisition, it logs basic information about the lock, its owner, and
// the caller. This version does not include detailed performance profiling. It
// also sets the lock owner pointer at `p_rw_lock_state + 8`.
signed __int64 __fastcall rw_lock_acquire_write_lock_unprofiled(
        __int64 p_rw_lock_state,
        signed __int64 rw_lock_state,
        __int64 lock_owner_ptr,
        const char *caller_name,
        const char *lock_name)
{
  char is_write_lock_incremented; // r14
  signed __int64 new_lock_value; // rcx
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_3; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  int lock_state_val_1; // esi
  signed __int64 rw_lock_state_2; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int rw_lock_state_1; // [rsp+38h] [rbp-81h] BYREF
  _DWORD lock_state_val_3[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int profiler_event_type_1; // [rsp+48h] [rbp-71h] BYREF
  __int64 profiler_event_flags_1; // [rsp+4Ch] [rbp-6Dh]
  int profiler_event_level_1; // [rsp+54h] [rbp-65h]
  unsigned __int64 start_timestamp_1; // [rsp+58h] [rbp-61h]
  unsigned __int64 end_timestamp_1; // [rsp+60h] [rbp-59h]
  __int64 profiler_data_ptr_1_1; // [rsp+68h] [rbp-51h]
  __int64 profiler_data_ptr_2_1; // [rsp+70h] [rbp-49h]
  int n0x1600; // [rsp+98h] [rbp-21h] BYREF
  __int64 profiler_event_flags_2; // [rsp+9Ch] [rbp-1Dh]
  int n2; // [rsp+A4h] [rbp-15h]
  unsigned __int64 start_timestamp_2; // [rsp+A8h] [rbp-11h]
  unsigned __int64 end_timestamp_2; // [rsp+B0h] [rbp-9h]
  __int64 profiler_data_ptr_1_2; // [rsp+B8h] [rbp-1h]
  __int64 profiler_data_ptr_2_2; // [rsp+C0h] [rbp+7h]

  is_write_lock_incremented = 0;
  do
  {
    while ( 1 )
    {
      if ( (rw_lock_state & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)p_profiler_system + 0x128LL))(
          p_profiler_system,
          p_rw_lock_state);
      if ( (rw_lock_state & 0x2003FF) == 0 )
        break;
      if ( is_write_lock_incremented )
      {
        profiler_event_type_1 = 0x1600;
        profiler_event_flags_1 = 1;
        profiler_event_level_1 = 2;
        end_timestamp_1 = 0;
        profiler_data_ptr_1_1 = 0;
        profiler_data_ptr_2_1 = 0;
        start_timestamp_1 = __rdtsc();
        isProfileFunctionsInitialized(
          &profiler_event_type_1,
          &word_149B3E38C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(profiler_event_type_1) = word_149B3E38C;
        qword_149B4B8B0("Lock: %s", lock_name);
        lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(p_rw_lock_state + 8) )
          lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
        qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
        qword_149B4B8B0("Caller: %s", caller_name);
        rw_lock_state_1 = rw_lock_state;
        qword_149B3B480(p_rw_lock_state, &rw_lock_state_1, 4, 0xFFFFFFFFLL);
        rw_lock_state = *(_QWORD *)p_rw_lock_state;
        end_timestamp_1 = __rdtsc();
        qword_149B4B878(&profiler_event_type_1);
      }
      else
      {
        lock_state_val_1 = rw_lock_state + 0x400000;
        rw_lock_state_2 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            rw_lock_state + 0x400000,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_2;
        rw_lock_state = rw_lock_state_2;
        if ( is_exchange_successful )
        {
          is_write_lock_incremented = 1;
          n0x1600 = 0x1600;
          profiler_event_flags_2 = 1;
          n2 = 2;
          end_timestamp_2 = 0;
          profiler_data_ptr_1_2 = 0;
          profiler_data_ptr_2_2 = 0;
          start_timestamp_2 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E390,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600) = word_149B3E390;
          qword_149B4B8B0("Lock: %s", lock_name);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", caller_name);
          lock_state_val_3[0] = lock_state_val_1;
          qword_149B3B480(p_rw_lock_state, lock_state_val_3, 4, 0xFFFFFFFFLL);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          end_timestamp_2 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
    }
    new_lock_value = (rw_lock_state | 0x200000) - 0x400000;
    if ( !is_write_lock_incremented )
      new_lock_value = rw_lock_state | 0x200000;
    rw_lock_state_3 = _InterlockedCompareExchange64(
                        (volatile signed __int64 *)p_rw_lock_state,
                        new_lock_value,
                        rw_lock_state);
    is_exchange_successful = rw_lock_state == rw_lock_state_3;
    rw_lock_state = rw_lock_state_3;
  }
  while ( !is_exchange_successful );
  *(_QWORD *)(p_rw_lock_state + 8) = lock_owner_ptr;
  return rw_lock_state_3;
}

// --- End Function: rw_lock_acquire_write_lock_unprofiled (0x1403DD0B0) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403DD380) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(
        __int64 p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  unsigned __int64 new_lock_value; // rdi
  unsigned int thread_context_owner_id; // edx
  signed __int64 current_lock_value_1; // rax
  __int64 p_profiler_system; // rdi
  __int64 thread_context_ptr_1; // r8
  int thread_context_owner_id_2; // ecx
  __int64 thread_context_ptr_2; // r8
  unsigned __int64 thread_id_high_word; // rbx
  const ULONG_PTR *default_lock_owner_ptr; // rax
  int thread_context_info_1; // [rsp+70h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+78h] [rbp+10h] BYREF
  __int64 thread_context_ptr_3; // [rsp+80h] [rbp+18h] BYREF
  __int64 thread_context_ptr_4; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value & 0xFFFFFFFFFFD003FFuLL;
    if ( (current_lock_value & 0xFFFF00100000LL) != 0 )
    {
      new_lock_value = current_lock_value & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (current_lock_value & 0xFFC003FF) == 0 && (current_lock_value & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_4,
        &thread_context_info_2);
      new_lock_value = current_lock_value & 0xFFFFFFD003FFLL;
      thread_context_owner_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_2 - 1)) << 9)
                                          + thread_context_ptr_4
                                          + 0x124);
      if ( thread_context_owner_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)thread_context_owner_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value,
                             current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0x3FF) != 0 )
  {
    if ( (current_lock_value & 0x100000) != 0 )
      qword_149B3B490(p_rw_lock_state);
    if ( (current_lock_value & 0xFFFF00000000LL) != 0 )
    {
      p_profiler_system = ::p_profiler_system;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_3,
        &thread_context_info_1);
      thread_context_ptr_1 = thread_context_ptr_3
                           + ((WORD2(current_lock_value) & (unsigned __int64)(unsigned int)(thread_context_info_1 - 1)) << 9);
      LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_1 + 0x124);
      *(_DWORD *)(thread_context_ptr_1 + 0x11C) = (unsigned __int16)(WORD2(current_lock_value) + thread_context_info_1);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      while ( (_DWORD)current_lock_value != 0xFFFFFFFF )
      {
        thread_context_owner_id_2 = (unsigned __int16)(current_lock_value + thread_context_info_1);
        thread_context_ptr_2 = thread_context_ptr_3
                             + ((unsigned __int64)((unsigned int)current_lock_value & (thread_context_info_1 - 1)) << 9);
        LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_2 + 0x124);
        *(_DWORD *)(thread_context_ptr_2 + 0x11C) = thread_context_owner_id_2;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      }
    }
  }
  else if ( (current_lock_value & 0xFFC00000) != 0 )
  {
    qword_149B3B488(p_rw_lock_state);
  }
  else if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
      ::p_profiler_system,
      &thread_context_ptr_3,
      &thread_context_info_1);
    thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)thread_id_high_word & (thread_context_info_1 - 1)) << 9)
              + thread_context_ptr_3
              + 0x11C) = (unsigned __int16)(thread_id_high_word + thread_context_info_1);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::p_profiler_system + 0xD8LL))(
      ::p_profiler_system,
      (unsigned int)thread_id_high_word);
  }
  default_lock_owner_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(p_rw_lock_state + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return default_lock_owner_ptr;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403DD380) ---

// --- Function: sub_1403DE120 (0x1403DE120) ---
_WORD *__fastcall sub_1403DE120(void **a1, __int64 a2)
{
  _WORD *result; // rax
  _DWORD *v5; // rax

  if ( a2 )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(2 * a2 + 0xA, 0);
    *a1 = v5 + 2;
    *v5 = a2;
    v5[1] = a2;
    result = *a1;
    *((_WORD *)*a1 + a2) = 0;
  }
  else
  {
    result = &unk_149B3E478;
    *a1 = &unk_149B3E478;
  }
  return result;
}

// --- End Function: sub_1403DE120 (0x1403DE120) ---

// --- Function: sub_1403DE230 (0x1403DE230) ---
void *__fastcall sub_1403DE230(void **a1, void *a2, size_t Size)
{
  _BYTE *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = *a1;
  if ( Size > *((int *)v5 + 0xFFFFFFFF) )
  {
    v7 = (int *)(v5 + 0xFFFFFFF8);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = (char *)&qword_149B3B33C + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, Size);
  *((_DWORD *)*a1 + 0xFFFFFFFE) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403DE230 (0x1403DE230) ---

// --- Function: sub_1403DE2D0 (0x1403DE2D0) ---
void *__fastcall sub_1403DE2D0(void **a1, void *a2, unsigned __int64 a3)
{
  _WORD *v4; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v4 = *a1;
  if ( a3 > *((int *)v4 + 0xFFFFFFFF) )
  {
    v7 = (int *)(v4 + 0xFFFFFFFC);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = &unk_149B3E478;
    if ( a3 )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(2 * a3 + 0xA, 0);
      *a1 = v8 + 2;
      *v8 = a3;
      v8[1] = a3;
      *((_WORD *)*a1 + a3) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, 2 * a3);
  *((_DWORD *)*a1 + 0xFFFFFFFE) = a3;
  result = *a1;
  *((_WORD *)*a1 + a3) = 0;
  return result;
}

// --- End Function: sub_1403DE2D0 (0x1403DE2D0) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 allocWithProfilerInfo_ww()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4B90 (0x1403E4B90) ---
_QWORD *__fastcall sub_1403E4B90(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A3D30(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)allocWithProfilerInfo_w(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E4B90 (0x1403E4B90) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
void __fastcall sub_1403E4E60(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4E80 (0x1403E4E80) ---
void __fastcall sub_1403E4E80(const void **a1)
{
  if ( a1 )
  {
    sub_1402A3D30(a1[2]);
    sub_1402A3D30(a1);
  }
}

// --- End Function: sub_1403E4E80 (0x1403E4E80) ---

// --- Function: sub_1403E6720 (0x1403E6720) ---
__int64 __fastcall sub_1403E6720(__int64 *a1)
{
  if ( AssetMeta::HasActorSubresource(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6720 (0x1403E6720) ---

// --- Function: sub_1403E7650 (0x1403E7650) ---
bool __fastcall sub_1403E7650(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E7650 (0x1403E7650) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403E98E0 (0x1403E98E0) ---
void __fastcall sub_1403E98E0(void **a1, unsigned __int64 a2, __int16 a3)
{
  _WORD *v3; // rdi
  unsigned __int64 v5; // r9
  int *v6; // rsi
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  _WORD *v10; // rdi
  _WORD *v11; // rdi
  unsigned __int64 i; // rcx

  v3 = *a1;
  v5 = *((int *)*a1 + 0xFFFFFFFE);
  v6 = (int *)((char *)*a1 + 0xFFFFFFF8);
  if ( a2 <= v5 )
  {
    if ( a2 >= v5 )
      return;
    *v6 = a2;
    goto LABEL_17;
  }
  v8 = a2 - v5;
  if ( a2 == v5 )
    return;
  if ( a2 <= *((int *)v3 + 0xFFFFFFFF) )
  {
    v11 = &v3[v5];
    for ( i = a2 - v5; i; --i )
      *v11++ = a3;
    *((_DWORD *)*a1 + 0xFFFFFFFE) = a2;
LABEL_17:
    *((_WORD *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    return;
  }
  sub_1403DE120(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, 2LL * *v6);
  v9 = v8;
  v10 = (char *)*a1 + 2 * *v6;
  while ( v9 )
  {
    *v10++ = a3;
    --v9;
  }
  if ( v6[1] > 0 )
    sub_147605980(v6);
}

// --- End Function: sub_1403E98E0 (0x1403E98E0) ---

// --- Function: sub_1403EB0E0 (0x1403EB0E0) ---
__int64 __fastcall sub_1403EB0E0(__int64 a1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EB0E0 (0x1403EB0E0) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n12_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n0xC + a2), n12_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB580 (0x1403EB580) ---
__int64 __fastcall sub_1403EB580(__int64 a1, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB580 (0x1403EB580) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_1480BE950);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *thread_base_ctx_ptr; // rax
  unsigned __int64 *thread_base_ctx_ptr_1; // rcx
  unsigned __int64 n0xF; // rax

  thread_base_ctx_ptr = sub_1404B3EA0();
  thread_base_ctx_ptr_1 = thread_base_ctx_ptr;
  if ( !thread_base_ctx_ptr )
    return &dword_149B45F40;
  n0xF = *thread_base_ctx_ptr;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&thread_base_ctx_ptr_1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_140501090 (0x140501090) ---
__int64 __fastcall sub_140501090(__int64 *a1)
{
  if ( is_valid_handle_typeA(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_140501090 (0x140501090) ---

// --- Function: sub_1405251E0 (0x1405251E0) ---
unsigned __int64 __fastcall sub_1405251E0(__int64 a1)
{
  unsigned __int64 result; // rax

  result = (*(_QWORD *)(a1 + 8) + 0x27LL) & 0xFFFFFFFFFFFFFFF8uLL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_1405251E0 (0x1405251E0) ---

// --- Function: sub_140525360 (0x140525360) ---
unsigned __int64 __fastcall sub_140525360(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 result; // rax
  char v6; // [rsp+30h] [rbp+8h] BYREF

  if ( is_entity_descriptor_valid_or_accessible(a3) )
    (*(void (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(*a3 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a3 & 0xFFFFFFFFFFFFLL,
      &v6);
  result = (*(_QWORD *)(a1 + 8) + 0x47LL) & 0xFFFFFFFFFFFFFFF8uLL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_140525360 (0x140525360) ---

// --- Function: sub_140539D30 (0x140539D30) ---
__int64 (__fastcall *__fastcall sub_140539D30(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))getModuleFunction(0, "__InitializeThreadInfoBlock__", 0);
  if ( result )
    return (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}

// --- End Function: sub_140539D30 (0x140539D30) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 thread_data_ptr; // rcx

  thread_data_ptr = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( thread_data_ptr )
    return *(_BYTE *)(thread_data_ptr + 0x42) != 0;
  else
    return *(_BYTE *)(get_thread_context_ptr() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---

// --- Function: sub_1405975C0 (0x1405975C0) ---
// // Calculates the difference between two QWORD (64-bit unsigned integer) values.
// // The result of (operand1 - operand2) is stored in the destination QWORD. // //
// Parameters: //   pOperand1: Pointer to the first QWORD operand. //   pResult:
// Pointer to the QWORD where the calculated difference will be stored. //
// pOperand2: Pointer to the second QWORD operand. // // Returns: //   The pointer
// to the result (pResult).
_QWORD *__fastcall sub_1405975C0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_1405975C0 (0x1405975C0) ---

// --- Function: sub_140597760 (0x140597760) ---
// // Converts a QWORD value, typically a high-resolution timer tick count //
// (e.g., from __rdtsc), into a double-precision floating-point number //
// representing time in seconds (or a scaled unit). // The conversion involves
// scaling the QWORD value by a factor of 0.0000001. // // Parameters: //   None
// explicitly, but implicitly operates on a QWORD value in RCX or a global. // //
// Returns: //   An __m128 containing the scaled time value as a double.
__m128 sub_140597760()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_140597760 (0x140597760) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !gEnv || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: p_p_p_p_p_p_sub_140384A94 (0x140B13358) ---
void __fastcall p_p_p_sub_140B13358(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
}

// --- End Function: p_p_p_p_p_p_sub_140384A94 (0x140B13358) ---

// --- Function: p_sub_140B13360 (0x140B13360) ---
void __fastcall sub_140B13360(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x18LL))(a1);
}

// --- End Function: p_sub_140B13360 (0x140B13360) ---

// --- Function: sub_1411DB480 (0x1411DB480) ---
__int64 __fastcall sub_1411DB480(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))a1)(a2, *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1411DB480 (0x1411DB480) ---

// --- Function: sub_14122A290 (0x14122A290) ---
__int64 __fastcall sub_14122A290(__int64 a1, int a2, _OWORD *a3)
{
  *(_OWORD *)(a1 + 8) = *a3;
  *(_DWORD *)a1 = a2;
  return a1;
}

// --- End Function: sub_14122A290 (0x14122A290) ---

// --- Function: sub_141335460 (0x141335460) ---
__int64 __fastcall sub_141335460(__int64 a1, __int16 a2)
{
  __int64 result; // rax

  *(_WORD *)(a1 + 0x18) = a2;
  switch ( a2 )
  {
    case 1:
    case 5:
    case 6:
    case 7:
      *(_WORD *)(a1 + 0x1A) = 0x764;
      result = a1;
      break;
    case 2:
    case 3:
      *(_WORD *)(a1 + 0x1A) = 0xF60;
      result = a1;
      break;
    case 4:
      *(_WORD *)(a1 + 0x1A) = 0x3200;
      result = a1;
      break;
    default:
      *(_WORD *)(a1 + 0x1A) = 0;
      result = a1;
      break;
  }
  return result;
}

// --- End Function: sub_141335460 (0x141335460) ---

// --- Function: sub_141537140 (0x141537140) ---
__int64 __fastcall sub_141537140(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rbx
  __int64 *v4; // rbx
  __int16 v5; // dx
  __int64 v6; // rax
  __int64 result; // rax
  unsigned int v8; // ebx
  void (__fastcall *v9)(int *, unsigned __int64); // rax
  _BYTE v10[8]; // [rsp+30h] [rbp-68h] BYREF
  void *(__fastcall **v11)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+38h] [rbp-60h] BYREF
  __int64 v12; // [rsp+40h] [rbp-58h]
  _QWORD v13[2]; // [rsp+48h] [rbp-50h] BYREF
  _QWORD v14[3]; // [rsp+58h] [rbp-40h] BYREF
  int v15; // [rsp+70h] [rbp-28h] BYREF
  __int128 v16; // [rsp+78h] [rbp-20h]
  unsigned __int64 v17; // [rsp+A8h] [rbp+10h] BYREF

  v17 = a2;
  v15 = 0;
  v16 = xmmword_148424B80;
  v3 = *(_QWORD *)(a1 + 0x20);
  v10[0] = 0;
  v4 = (__int64 *)(v3 & 0xFFFFFFFFFFFFLL);
  if ( !v4 )
    return 1;
  v12 = 0;
  v11 = &off_1481AF030;
  sub_140525360((__int64)&v11, (__int64)"variable", &v17);
  v5 = *(_WORD *)(a1 + 0x28);
  v6 = *v4;
  v14[0] = sub_141565DF0;
  v14[1] = &v17;
  v13[0] = v14;
  v13[1] = sub_1411DB480;
  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, int *, __int64, _QWORD *, _BYTE *))(v6 + 8))(
             v4,
             v5 & 0x3FFF,
             &v15,
             v12,
             v13,
             v10);
  v8 = result;
  if ( v10[0] )
  {
    v9 = *(void (__fastcall **)(int *, unsigned __int64))(a1 + 8);
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
      v9(&v15, v17);
    else
      ((void (__fastcall *)(__int64, int *, unsigned __int64))v9)(a1 + 8, &v15, v17);
    return v8;
  }
  return result;
}

// --- End Function: sub_141537140 (0x141537140) ---

// --- Function: sub_141565DF0 (0x141565DF0) ---
unsigned __int64 __fastcall sub_141565DF0(__int64 a1, unsigned __int64 *a2)
{
  _QWORD v3[3]; // [rsp+20h] [rbp-18h] BYREF

  v3[1] = a1;
  v3[0] = &off_1481AF030;
  return sub_140525B80((__int64)v3, (__int64)"variable", a2);
}

// --- End Function: sub_141565DF0 (0x141565DF0) ---

// --- Function: sub_141F382E0 (0x141F382E0) ---
_QWORD *__fastcall sub_141F382E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_78;
  if ( n0xFFFF_78 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v9,
                          "IEntityAudioControllerComponent");
    n0xFFFF_78 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_141F382E0 (0x141F382E0) ---

// --- Function: sub_1425D62E0 (0x1425D62E0) ---
_QWORD *__fastcall sub_1425D62E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_31;
  if ( n0xFFFF_31 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v9,
                          "Actor");
    n0xFFFF_31 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D62E0 (0x1425D62E0) ---

// --- Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---
__int64 __fastcall std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---

// --- Function: ?deallocate@__crt_win32_buffer_no_resizing@@SAXQEAXAEBV__crt_win32_buffer_empty_debug_info@@@Z (0x1426D7AA0) ---
// Microsoft VisualC v14 64bit runtime
void __fastcall __crt_win32_buffer_no_resizing::deallocate(
        void *const a1,
        const struct __crt_win32_buffer_empty_debug_info *a2)
{
  ;
}

// --- End Function: ?deallocate@__crt_win32_buffer_no_resizing@@SAXQEAXAEBV__crt_win32_buffer_empty_debug_info@@@Z (0x1426D7AA0) ---

// --- Function: sub_1426F0230 (0x1426F0230) ---
char *__fastcall sub_1426F0230(const void *a1, __int64 a2, char *a3)
{
  size_t Size; // [rsp+28h] [rbp-40h]

  Size = a2 - (_QWORD)a1;
  memmove(a3, a1, a2 - (_QWORD)a1);
  return &a3[Size];
}

// --- End Function: sub_1426F0230 (0x1426F0230) ---

// --- Function: sub_1426F0C90 (0x1426F0C90) ---
char *__fastcall sub_1426F0C90(Parameter *Parameter, const void *src)
{
  if ( *((_QWORD *)Parameter + 1) == *((_QWORD *)Parameter + 2) )
    return sub_1426F1A90(Parameter, *((AK::WriteBytesCount **)Parameter + 1), src);
  else
    return (char *)sub_1426F08A0(Parameter, src);
}

// --- End Function: sub_1426F0C90 (0x1426F0C90) ---

// --- Function: ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@1@@Z (0x1426FC3B0) ---
Parameter *__fastcall std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
        Parameter *Parameter_1,
        __int64 a2)
{
  *(_QWORD *)Parameter_1 = a2;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@1@@Z (0x1426FC3B0) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || is_thread_privileged_or_bypass_mode() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: unknown_libname_484 (0x142739050) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
__int64 __fastcall unknown_libname_484(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: unknown_libname_484 (0x142739050) ---

// --- Function: sub_142744750 (0x142744750) ---
__int64 __fastcall sub_142744750(unsigned __int8 input_byte)
{
  return (unsigned int)input_byte + 0xC7;
}

// --- End Function: sub_142744750 (0x142744750) ---

// --- Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_2 (0x14277CFB0) ---
// Microsoft VisualC v14 64bit runtime
const char *__fastcall __crt_win32_buffer_debug_info::file_name(__crt_win32_buffer_debug_info *this)
{
  return (const char *)*((_QWORD *)this + 1);
}

// --- End Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_2 (0x14277CFB0) ---

// --- Function: sub_14277D090 (0x14277D090) ---
Parameter *__fastcall sub_14277D090(_QWORD *a1, Parameter *Parameter_1)
{
  *(_QWORD *)Parameter_1 = *a1;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_14277D090 (0x14277D090) ---

// --- Function: sub_14277D0F0 (0x14277D0F0) ---
Parameter *__fastcall sub_14277D0F0(__int64 a1, Parameter *Parameter_1)
{
  *(_QWORD *)Parameter_1 = *(_QWORD *)(a1 + 8);
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_14277D0F0 (0x14277D0F0) ---

// --- Function: sub_14277D200 (0x14277D200) ---
_BOOL8 __fastcall sub_14277D200(_QWORD *a1)
{
  return *a1 == a1[1];
}

// --- End Function: sub_14277D200 (0x14277D200) ---

// --- Function: sub_14277D6A0 (0x14277D6A0) ---
__int64 __fastcall sub_14277D6A0(_QWORD *a1)
{
  if ( Handle::IsValid(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_14277D6A0 (0x14277D6A0) ---

// --- Function: unknown_libname_492 (0x1429407B0) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
__int64 __fastcall unknown_libname_492(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x18);
}

// --- End Function: unknown_libname_492 (0x1429407B0) ---

// --- Function: ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z (0x142A90E70) ---
_BOOL8 __fastcall std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
        _QWORD *a1,
        _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z (0x142A90E70) ---

// --- Function: sub_142C0F3C0 (0x142C0F3C0) ---
_BOOL8 __fastcall sub_142C0F3C0(__int64 a1, int a2)
{
  return *(_DWORD *)(a1 + 8) != a2;
}

// --- End Function: sub_142C0F3C0 (0x142C0F3C0) ---

// --- Function: sub_142C30540 (0x142C30540) ---
_QWORD *__fastcall sub_142C30540(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  *a1 = *a3;
  a1[1] = 0;
  a1[2] = a2;
  a1[3] = 0;
  a1[4] = (__int64)(a3[1] - *a3) >> 4;
  a1[1] = *(_QWORD *)(a1[2] + 0x18LL);
  *(_QWORD *)(a1[2] + 0x18LL) = a1;
  return a1;
}

// --- End Function: sub_142C30540 (0x142C30540) ---

// --- Function: sub_142E160A0 (0x142E160A0) ---
__int64 __fastcall sub_142E160A0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 0x1D0);
}

// --- End Function: sub_142E160A0 (0x142E160A0) ---

// --- Function: sub_142ECB8B0 (0x142ECB8B0) ---
__int64 __fastcall sub_142ECB8B0(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 0x10) + 0x18 * a2;
}

// --- End Function: sub_142ECB8B0 (0x142ECB8B0) ---

// --- Function: sub_142F32590 (0x142F32590) ---
Parameter *__fastcall sub_142F32590(__int64 a1, Parameter *Parameter_1)
{
  *(_QWORD *)Parameter_1 = *(_QWORD *)(a1 + 0x60);
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_142F32590 (0x142F32590) ---

// --- Function: sub_142F33610 (0x142F33610) ---
Parameter *__fastcall sub_142F33610(__int64 a1, Parameter *Parameter_1)
{
  *(_QWORD *)Parameter_1 = *(_QWORD *)(a1 + 0x68);
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_142F33610 (0x142F33610) ---

// --- Function: sub_142FFB440 (0x142FFB440) ---
__int64 __fastcall sub_142FFB440(__int64 a1, int a2, float a3)
{
  __int64 result; // rax
  _QWORD v4[3]; // [rsp+20h] [rbp-48h] BYREF
  __int64 (__fastcall **v5)(); // [rsp+38h] [rbp-30h] BYREF
  int n3; // [rsp+40h] [rbp-28h]
  int n8; // [rsp+48h] [rbp-20h]
  int v8; // [rsp+50h] [rbp-18h]
  float v9; // [rsp+54h] [rbp-14h]
  char v10; // [rsp+58h] [rbp-10h]

  if ( a2 )
  {
    v4[1] = 0;
    v5 = off_1483E7C50;
    v8 = a2;
    v4[2] = &v5;
    v9 = a3;
    v4[0] = 1;
    n3 = 3;
    n8 = 8;
    v10 = 0;
    return (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149B4FC98 + 0x20LL))(qword_149B4FC98, v4);
  }
  return result;
}

// --- End Function: sub_142FFB440 (0x142FFB440) ---

// --- Function: sub_143068F20 (0x143068F20) ---
__int64 __fastcall sub_143068F20(
        __int64 event_param_struct_ptr,
        __int64 a2,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        _QWORD *a7)
{
  unsigned __int64 v7; // rax
  const char *p_null; // rdx

  *(_QWORD *)event_param_struct_ptr = a2;
  *(_WORD *)(event_param_struct_ptr + 0x58) = 0x100;
  *(_QWORD *)(event_param_struct_ptr + 0x10) = 0;
  *(_QWORD *)(event_param_struct_ptr + 8) = "TraceContext";
  *(_QWORD *)(event_param_struct_ptr + 0x28) = 0;
  *(_QWORD *)(event_param_struct_ptr + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(event_param_struct_ptr + 0x20) = sub_1403EB240;
  *(_QWORD *)(event_param_struct_ptr + 0x30) = sub_1403E77F0;
  *(_QWORD *)(event_param_struct_ptr + 0x40) = sub_1403E4E60;
  *(_QWORD *)(event_param_struct_ptr + 0x38) = 0;
  *(_QWORD *)(event_param_struct_ptr + 0x48) = allocWithProfilerInfo_ww;
  v7 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(event_param_struct_ptr + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(event_param_struct_ptr + 0x60) = 0xB0;
  *(_QWORD *)(event_param_struct_ptr + 0x68) = 0xA8;
  *(_QWORD *)(event_param_struct_ptr + 0x70) = a3;
  *(_QWORD *)(event_param_struct_ptr + 0x78) = "Function";
  *(_BYTE *)(event_param_struct_ptr + 0xC9) = 1;
  *(_QWORD *)(event_param_struct_ptr + 0x80) = *a3;
  *(_QWORD *)(event_param_struct_ptr + 0x88) = sub_1403EB580;
  *(_QWORD *)(event_param_struct_ptr + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(event_param_struct_ptr + 0xA0) = sub_1403E7650;
  *(_QWORD *)(event_param_struct_ptr + 0x98) = 0;
  *(_QWORD *)(event_param_struct_ptr + 0xA8) = 0;
  *(_BYTE *)(event_param_struct_ptr + 0xC8) = 0;
  p_null = "null";
  *(_QWORD *)(event_param_struct_ptr + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(event_param_struct_ptr + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(event_param_struct_ptr + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(event_param_struct_ptr + 0xD0) = 0x18;
  if ( a3[1] )
    p_null = (const char *)a3[1];
  do
    ++v7;
  while ( p_null[v7] );
  *(_QWORD *)(event_param_struct_ptr + 0xD8) = v7;
  return sub_140356FD0(event_param_struct_ptr + 0xE0, a4, a5, a6, a7) + 2;
}

// --- End Function: sub_143068F20 (0x143068F20) ---

// --- Function: sub_1432A4AD0 (0x1432A4AD0) ---
char *__fastcall sub_1432A4AD0(Parameter *Parameter, const void *src)
{
  return sub_1426F0C90(Parameter, src);
}

// --- End Function: sub_1432A4AD0 (0x1432A4AD0) ---

// --- Function: sub_143B1F350 (0x143B1F350) ---
__int64 __fastcall sub_143B1F350(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64, __int16 *); // rdi
  __int16 n0xFFFF_316; // ax
  char v4; // al
  __int64 v5; // rcx
  __int16 n0xFFFF_316_1; // [rsp+30h] [rbp+8h] BYREF
  char v8; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a1 + 8LL);
  n0xFFFF_316 = ::n0xFFFF_316;
  if ( ::n0xFFFF_316 == (__int16)0xFFFF )
  {
    n0xFFFF_316 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                     + 0x10LL))(
                              pEngineComponentScheduler,
                              &v8,
                              "GameRulesEAObjectiveControl");
    ::n0xFFFF_316 = n0xFFFF_316;
  }
  n0xFFFF_316_1 = n0xFFFF_316;
  v4 = v2(a1, &n0xFFFF_316_1);
  v5 = 0;
  if ( v4 )
    return a1;
  return v5;
}

// --- End Function: sub_143B1F350 (0x143B1F350) ---

// --- Function: sub_143E30F90 (0x143E30F90) ---
_QWORD *__fastcall sub_143E30F90(_QWORD *a1)
{
  *a1 += 0x20LL;
  return a1;
}

// --- End Function: sub_143E30F90 (0x143E30F90) ---

// --- Function: sub_143EDB400 (0x143EDB400) ---
BB_ComparisonOperatorType *__fastcall sub_143EDB400(
        AK::WriteBytesCount *a1,
        BB_ComparisonOperatorType *Parameter_1,
        char *dst_1)
{
  char *src; // [rsp+20h] [rbp-58h]
  char *dst; // [rsp+28h] [rbp-50h]
  _QWORD *v6; // [rsp+30h] [rbp-48h]
  __int64 src_1; // [rsp+40h] [rbp-38h]

  v6 = (_QWORD *)((char *)a1 + 8);
  dst = dst_1;
  src_1 = *((_QWORD *)a1 + 1);
  src = dst_1 + 0x20;
  if ( AK::WriteBytesCount::Reserve(a1) )
  {
    while ( src != (char *)src_1 )
    {
      qmemcpy(dst, src, 0x20u);
      dst += 0x20;
      src += 0x20;
    }
  }
  else
  {
    sub_1426F0230(src, src_1, dst);
  }
  *v6 -= 0x20LL;
  *(_QWORD *)Parameter_1 = dst_1;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_143EDB400 (0x143EDB400) ---

// --- Function: sub_143FF7FD0 (0x143FF7FD0) ---
__int64 __fastcall sub_143FF7FD0(__int64 a1, __int64 a2, const void *src)
{
  _BYTE dst_[40]; // [rsp+20h] [rbp-28h] BYREF

  qmemcpy(dst_, src, 0x10u);
  return sub_14402E6F0(a1, a2, dst_);
}

// --- End Function: sub_143FF7FD0 (0x143FF7FD0) ---

// --- Function: sub_143FF8240 (0x143FF8240) ---
__int64 __fastcall sub_143FF8240(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  __int64 v4; // [rsp+28h] [rbp-30h]
  __int64 v5; // [rsp+60h] [rbp+8h]

  v5 = a1;
  v4 = (a2 - a1) >> 4;
  while ( v4 > 0 )
  {
    if ( sub_140380630(*(_QWORD *)(0x10 * (v4 >> 1) + v5), *a3) )
    {
      v5 += 0x10 * (v4 >> 1) + 0x10;
      v4 -= (v4 >> 1) + 1;
    }
    else
    {
      v4 >>= 1;
    }
  }
  return v5;
}

// --- End Function: sub_143FF8240 (0x143FF8240) ---

// --- Function: sub_143FF8DC0 (0x143FF8DC0) ---
__int64 __fastcall sub_143FF8DC0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+8h] [rbp-40h]
  __int64 i; // [rsp+18h] [rbp-30h]

  v4 = a1;
  for ( i = (a2 - a1) >> 4; i > 0; --i )
  {
    *(_QWORD *)a3 = *(_QWORD *)v4;
    *(float *)(a3 + 8) = *(float *)(v4 + 8);
    v4 += 0x10;
    a3 += 0x10;
  }
  return a3;
}

// --- End Function: sub_143FF8DC0 (0x143FF8DC0) ---

// --- Function: sub_1440230D0 (0x1440230D0) ---
const ULONG_PTR *__fastcall sub_1440230D0(__int64 a1, float a2, struct std::pmr::memory_resource *src__2)
{
  const ULONG_PTR *result; // rax
  __int64 v4; // [rsp+30h] [rbp-F8h]
  __int64 v5; // [rsp+38h] [rbp-F0h]
  float *v6; // [rsp+80h] [rbp-A8h]
  float *v7; // [rsp+90h] [rbp-98h]
  float *v8; // [rsp+A0h] [rbp-88h]
  const ULONG_PTR *v9; // [rsp+C8h] [rbp-60h]
  struct std::pmr::memory_resource *src_; // [rsp+F8h] [rbp-30h] BYREF
  float v11; // [rsp+100h] [rbp-28h]
  float v13; // [rsp+138h] [rbp+10h] BYREF
  struct std::pmr::memory_resource *src__1; // [rsp+140h] [rbp+18h] BYREF

  src__1 = src__2;
  v13 = a2;
  result = (const ULONG_PTR *)*(unsigned __int8 *)(a1 + 0x88);
  if ( *(_BYTE *)(a1 + 0x88) )
  {
    sub_1402DE3A0(a1 + 0x10, "CSCActorGForce::SetRedoutOverride", "m_lock", 1);
    v4 = sub_143FF8240(*(_QWORD *)(a1 + 0x1A8), *(_QWORD *)(a1 + 0x1B0), (unsigned __int64 *)&src__1);
    result = *(const ULONG_PTR **)(a1 + 0x1B0);
    if ( (const ULONG_PTR *)v4 == result
      || (result = (const ULONG_PTR *)std::pmr::_Identity_equal_resource::do_is_equal(
                                        *(std::pmr::_Identity_equal_resource **)v4,
                                        src__1),
          !(_BYTE)result) )
    {
      if ( v13 > 0.001 )
      {
        src_ = src__1;
        v11 = v13;
        sub_143FF7FD0(a1 + 0x1A8, v4, &src_);
        if ( v13 <= *(float *)(a1 + 0x1C8) )
          v8 = (float *)(a1 + 0x1C8);
        else
          v8 = &v13;
        result = (const ULONG_PTR *)a1;
        *(float *)(a1 + 0x1C8) = *v8;
      }
    }
    else if ( v13 > 0.001 )
    {
      *(float *)(v4 + 8) = v13;
      if ( v13 <= *(float *)(a1 + 0x1C8) )
        v7 = (float *)(a1 + 0x1C8);
      else
        v7 = &v13;
      result = (const ULONG_PTR *)a1;
      *(float *)(a1 + 0x1C8) = *v7;
    }
    else
    {
      sub_14402E3D0(a1 + 0x1A8, v4);
      *(float *)(a1 + 0x1C8) = 0;
      v5 = *(_QWORD *)(a1 + 0x1A8);
      v9 = *(const ULONG_PTR **)(a1 + 0x1B0);
      while ( 1 )
      {
        result = v9;
        if ( (const ULONG_PTR *)v5 == v9 )
          break;
        if ( *(float *)(v5 + 8) <= *(float *)(a1 + 0x1C8) )
          v6 = (float *)(a1 + 0x1C8);
        else
          v6 = (float *)(v5 + 8);
        *(float *)(a1 + 0x1C8) = *v6;
        v5 += 0x10;
      }
    }
    if ( a1 != 0xFFFFFFFFFFFFFFF0uLL )
      return sub_1402DE4A0(a1 + 0x10);
  }
  return result;
}

// --- End Function: sub_1440230D0 (0x1440230D0) ---

// --- Function: sub_14402E3D0 (0x14402E3D0) ---
__int64 __fastcall sub_14402E3D0(__int64 a1, __int64 a2)
{
  if ( (unsigned __int64)(a2 + 0x10) < *(_QWORD *)(a1 + 8) )
    sub_143FF8DC0(a2 + 0x10, *(_QWORD *)(a1 + 8), a2);
  *(_QWORD *)(a1 + 8) -= 0x10LL;
  return a2;
}

// --- End Function: sub_14402E3D0 (0x14402E3D0) ---

// --- Function: sub_14402E6F0 (0x14402E6F0) ---
__int64 __fastcall sub_14402E6F0(unsigned __int64 **a1, unsigned __int64 *a2, _BYTE *dst)
{
  _QWORD v4[3]; // [rsp+50h] [rbp-18h] BYREF

  if ( (a2 == a1[1] || sub_140380630(*(_QWORD *)dst, *a2))
    && (a2 == *a1 || sub_140380630(a2[0xFFFFFFFE], *(_QWORD *)dst)) )
  {
    return sub_143FF7CD0(a1, a2, dst);
  }
  sub_143FF80A0(a1, v4, dst);
  return v4[0];
}

// --- End Function: sub_14402E6F0 (0x14402E6F0) ---

// --- Function: sub_14417A6A0 (0x14417A6A0) ---
_QWORD *__fastcall sub_14417A6A0(__int64 a1, _QWORD *a2)
{
  __int16 v3; // [rsp+20h] [rbp-38h] BYREF
  __int16 *v4; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int16 *); // [rsp+30h] [rbp-28h]
  __int64 *v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  _BYTE v8[16]; // [rsp+48h] [rbp-10h] BYREF

  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  v4 = sub_1441E2360(&v3);
  v6 = (__int64 *)v5(a1, v8, v4);
  v7 = *v6;
  *a2 = v7;
  return a2;
}

// --- End Function: sub_14417A6A0 (0x14417A6A0) ---

// --- Function: sub_1441C4B70 (0x1441C4B70) ---
_QWORD *__fastcall sub_1441C4B70(_QWORD *a1)
{
  *a1 += 0x788LL;
  return a1;
}

// --- End Function: sub_1441C4B70 (0x1441C4B70) ---

// --- Function: sub_1441DA1F0 (0x1441DA1F0) ---
__int64 sub_1441DA1F0()
{
  __int64 result; // rax

  result = (unsigned int)dword_149E39E1C;
  if ( !dword_149E39E1C )
    return get_event_key_from_source_location(
             &dword_149E39E1C,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/EA/EAEvents.h",
             0x40);
  return result;
}

// --- End Function: sub_1441DA1F0 (0x1441DA1F0) ---

// --- Function: sub_1441E20E0 (0x1441E20E0) ---
__int16 *__fastcall sub_1441E20E0(__int16 *a1)
{
  __int16 n0xFFFF_317; // cx
  __int16 *result; // rax
  char v4; // [rsp+30h] [rbp+8h] BYREF

  if ( ::n0xFFFF_317 == (__int16)0xFFFF )
  {
    n0xFFFF_317 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                     + 0x10LL))(
                              pEngineComponentScheduler,
                              &v4,
                              "EAActionItemMessage");
    result = a1;
    ::n0xFFFF_317 = n0xFFFF_317;
    *a1 = n0xFFFF_317;
  }
  else
  {
    *a1 = ::n0xFFFF_317;
    return a1;
  }
  return result;
}

// --- End Function: sub_1441E20E0 (0x1441E20E0) ---

// --- Function: sub_1441E9B40 (0x1441E9B40) ---
__int64 __fastcall sub_1441E9B40(__int64 a1, int a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  _BYTE v7[24]; // [rsp+30h] [rbp-18h] BYREF
  __int64 Parameter_; // [rsp+50h] [rbp+8h] BYREF
  __int64 Parameter__1; // [rsp+60h] [rbp+18h] BYREF

  sub_1402AE400((__int64)v7, "CEAActionItemMessage::IsActionItemTypeShowing", a1 + 0x80, 1, 1, "m_messageQueueLock");
  sub_142F32590(a1 + 0x98, (Parameter *)&Parameter_);
  sub_142F33610(a1 + 0x98, (Parameter *)&Parameter__1);
  if ( std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
         &Parameter_,
         &Parameter__1) )
  {
LABEL_5:
    v5 = 0;
  }
  else
  {
    while ( 1 )
    {
      v4 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>((__int64)&Parameter_);
      v5 = v4;
      if ( *(_BYTE *)(v4 + 0x89) )
      {
        if ( *(_DWORD *)(v4 + 0x778) == a2 )
          break;
      }
      sub_1441C4B70(&Parameter_);
      if ( std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
             &Parameter_,
             &Parameter__1) )
      {
        goto LABEL_5;
      }
    }
  }
  sub_1402B1860((__int64)v7);
  return v5;
}

// --- End Function: sub_1441E9B40 (0x1441E9B40) ---

// --- Function: sub_1442005C0 (0x1442005C0) ---
void __fastcall sub_1442005C0(__int64 a1, int a2, unsigned int a3)
{
  unsigned __int64 v4; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  const void **v9; // rax
  const wchar_t *Format; // rax
  void *v11[3]; // [rsp+20h] [rbp-18h] BYREF
  void *v12; // [rsp+58h] [rbp+20h] BYREF

  v4 = a2;
  v6 = sub_1403335B0(a1);
  if ( unknown_libname_492(v6 + 0x38) <= v4 )
  {
    v9 = (const void **)sub_1403AE630();
    sub_14035B410(&v12, v9);
  }
  else
  {
    v7 = sub_1403335B0(a1);
    v8 = sub_142ECB8B0(v7 + 0x38, v4);
    sub_14035F010(&v12, (unsigned __int8 **)(v8 + 0x10));
  }
  Format = (const wchar_t *)sub_1402A2660((__int64)&v12);
  sub_14039F1C0(v11, Format, a3);
  sub_140370D10(&v12);
  sub_1442126A0(a1, v11);
  sub_140370D10(v11);
}

// --- End Function: sub_1442005C0 (0x1442005C0) ---

// --- Function: sub_1442126A0 (0x1442126A0) ---
const ULONG_PTR *__fastcall sub_1442126A0(__int64 a1, const void **a2)
{
  __int64 v4; // rax
  ULONG_PTR p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source[3]; // [rsp+30h] [rbp-18h] BYREF
  __int64 Parameter_; // [rsp+50h] [rbp+8h] BYREF
  __int64 Parameter__1; // [rsp+60h] [rbp+18h] BYREF

  sub_1402AE480(
    (__int64)p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
    "CEAActionItemMessage::UpdateMessageString",
    a1 + 0x80,
    1,
    1,
    "m_messageQueueLock");
  sub_142F32590(a1 + 0x98, (Parameter *)&Parameter_);
  sub_142F33610(a1 + 0x98, (Parameter *)&Parameter__1);
  while ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
             &Parameter_,
             &Parameter__1) )
  {
    v4 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>((__int64)&Parameter_);
    if ( *(_BYTE *)(v4 + 0x89) )
      sub_1403239F0(v4 + 0x728, a2);
    sub_1441C4B70(&Parameter_);
  }
  return sub_1402B1870(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
}

// --- End Function: sub_1442126A0 (0x1442126A0) ---

// --- Function: sub_1442E1D40 (0x1442E1D40) ---
__int64 __fastcall sub_1442E1D40(__int64 a1)
{
  return sub_14277D6A0((_QWORD *)(a1 + 0x100));
}

// --- End Function: sub_1442E1D40 (0x1442E1D40) ---

// --- Function: sub_1442E2610 (0x1442E2610) ---
__int64 __fastcall sub_1442E2610(__int64 a1)
{
  return sub_14277D6A0((_QWORD *)(a1 + 0x118));
}

// --- End Function: sub_1442E2610 (0x1442E2610) ---

// --- Function: sub_1443EA310 (0x1443EA310) ---
__int64 __fastcall sub_1443EA310(_QWORD *pManagedObjectPtr)
{
  sub_1402ABD50(pManagedObjectPtr);
  return 0;
}

// --- End Function: sub_1443EA310 (0x1443EA310) ---

// --- Function: sub_1443EA370 (0x1443EA370) ---
__int64 __fastcall sub_1443EA370(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = sub_1402A2B80(0x10, a1);
  sub_14035B410((void **)v3, (const void **)a2);
  *(_BYTE *)(v3 + 8) = *(_BYTE *)(a2 + 8);
  result = v3;
  *(_DWORD *)(v3 + 0xC) = *(_DWORD *)(a2 + 0xC);
  return result;
}

// --- End Function: sub_1443EA370 (0x1443EA370) ---

// --- Function: sub_1443EAE30 (0x1443EAE30) ---
_QWORD *__fastcall sub_1443EAE30(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  identity((__int64)a1);
  *a1 = *a7;
  a1[1] = *a6;
  a1[2] = *a5;
  a1[3] = *a4;
  a1[4] = *a3;
  return a1;
}

// --- End Function: sub_1443EAE30 (0x1443EAE30) ---

// --- Function: sub_1443EC9D0 (0x1443EC9D0) ---
_QWORD *__fastcall sub_1443EC9D0(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  *a1 = a2;
  a1[1] = sub_1443EA2E0;
  *a3 = a1;
  return a1;
}

// --- End Function: sub_1443EC9D0 (0x1443EC9D0) ---

// --- Function: sub_1443F28D0 (0x1443F28D0) ---
void __fastcall sub_1443F28D0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  sub_1405251E0(a1);
  sub_1405253C0(a1);
  sub_140525360(a1, (__int64)"variable", a4);
  sub_1405253C0(a1);
}

// --- End Function: sub_1443F28D0 (0x1443F28D0) ---

// --- Function: sub_1443F2CE0 (0x1443F2CE0) ---
_QWORD *__fastcall sub_1443F2CE0(__int64 a1, _QWORD *a2)
{
  __int16 v3; // [rsp+20h] [rbp-38h] BYREF
  __int16 *v4; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int16 *); // [rsp+30h] [rbp-28h]
  __int64 *v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  _BYTE v8[16]; // [rsp+48h] [rbp-10h] BYREF

  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  v4 = sub_1441E20E0(&v3);
  v6 = (__int64 *)v5(a1, v8, v4);
  v7 = *v6;
  *a2 = v7;
  return a2;
}

// --- End Function: sub_1443F2CE0 (0x1443F2CE0) ---

// --- Function: sub_1443F2F80 (0x1443F2F80) ---
_QWORD *__fastcall sub_1443F2F80(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-68h]
  __int64 v4; // [rsp+28h] [rbp-60h]
  _QWORD v5[2]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v6; // [rsp+40h] [rbp-48h] BYREF
  _QWORD src_[2]; // [rsp+48h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+60h] [rbp-28h] BYREF
  unsigned __int64 v10; // [rsp+98h] [rbp+10h] BYREF

  v10 = a2;
  src_[0] = p_p_p_p_p_sub_140384A94;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  if ( is_entity_descriptor_valid_or_accessible(&v10) )
  {
    v4 = sub_14030ECF0(&v10);
    v3 = sub_14417A6A0(v4, &v6);
  }
  else
  {
    v5[0] = 0;
    v3 = v5;
  }
  v5[1] = v3;
  *a1 = *v3;
  return a1;
}

// --- End Function: sub_1443F2F80 (0x1443F2F80) ---

// --- Function: sub_1443F4180 (0x1443F4180) ---
_QWORD *__fastcall sub_1443F4180(_QWORD *a1)
{
  *a1 = "struct SEAActionItemMessageEvent";
  return a1;
}

// --- End Function: sub_1443F4180 (0x1443F4180) ---

// --- Function: sub_1443F4EA0 (0x1443F4EA0) ---
const ULONG_PTR *__fastcall sub_1443F4EA0(_QWORD *a1, void (__fastcall *a2)(_QWORD))
{
  char v3; // [rsp+30h] [rbp-198h]
  __int16 v4; // [rsp+38h] [rbp-190h] BYREF
  char v5; // [rsp+40h] [rbp-188h]
  char v6; // [rsp+41h] [rbp-187h]
  __int16 v7; // [rsp+42h] [rbp-186h]
  _QWORD *i; // [rsp+48h] [rbp-180h]
  __int64 v9; // [rsp+50h] [rbp-178h]
  _QWORD *v10; // [rsp+58h] [rbp-170h]
  double (__fastcall *isProfileFunctionsInitialized)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+60h] [rbp-168h]
  double (__fastcall *v12)(_QWORD); // [rsp+68h] [rbp-160h]
  __int64 v13; // [rsp+70h] [rbp-158h] BYREF
  _QWORD v14[3]; // [rsp+78h] [rbp-150h] BYREF
  __int64 v15; // [rsp+90h] [rbp-138h]
  __int64 v16; // [rsp+98h] [rbp-130h]
  _QWORD dst__3[10]; // [rsp+A0h] [rbp-128h] BYREF
  _QWORD buf_[6]; // [rsp+F0h] [rbp-D8h] BYREF
  _BYTE dst_[48]; // [rsp+120h] [rbp-A8h] BYREF
  _BYTE dst__1[48]; // [rsp+150h] [rbp-78h] BYREF
  _BYTE dst__2[48]; // [rsp+180h] [rbp-48h] BYREF

  sub_1402AE3D0(&v13, "SCIGListenerSet<struct IEAPlayableAreaControllerListener>::Notify", (__int64)(a1 + 4), 1);
  sub_142C30540(v14, (__int64)a1, a1);
  while ( v15 < v16 )
  {
    v9 = 0x10 * v15 + v14[0];
    v7 = *(_WORD *)(v9 + 2);
    memset(buf_, 0, sizeof(buf_));
    qmemcpy(dst_, sub_1402B15B0(buf_), sizeof(dst_));
    qmemcpy(dst__1, dst_, sizeof(dst__1));
    v3 = *(_BYTE *)v9;
    qmemcpy(dst__2, dst__1, sizeof(dst__2));
    v4 = v7;
    qmemcpy(dst__3, dst__2, 0x30u);
    dst__3[2] = __rdtsc();
    BYTE4(dst__3[1]) = 0;
    BYTE1(dst__3[0]) = v3;
    LOBYTE(dst__3[0]) = 0;
    v5 = 0;
    isProfileFunctionsInitialized = ::isProfileFunctionsInitialized;
    ::isProfileFunctionsInitialized(dst__3, &v4, &p_p_p_p_p_p_p_p_p_p_p_Source, &p_p_p_p_p_p_p_p_p_p_p_Source, 0);
    WORD1(dst__3[0]) = v4;
    a2(*(_QWORD *)(v9 + 8));
    ++v15;
    v6 = 0;
    dst__3[3] = __rdtsc();
    v12 = qword_149B4B878;
    qword_149B4B878(dst__3);
  }
  v10 = v14;
  for ( i = (_QWORD *)(v14[2] + 0x18LL); *i; i = (_QWORD *)(*i + 8LL) )
  {
    if ( (_QWORD *)*i == v10 )
    {
      *i = v10[1];
      return sub_1402B1820(&v13);
    }
  }
  return sub_1402B1820(&v13);
}

// --- End Function: sub_1443F4EA0 (0x1443F4EA0) ---

// --- Function: sub_1443F5120 (0x1443F5120) ---
const ULONG_PTR *__fastcall sub_1443F5120(_QWORD *a1, void (__fastcall *a2)(_QWORD, _QWORD), __int64 a3)
{
  char v4; // [rsp+30h] [rbp-1A8h]
  __int16 v5; // [rsp+38h] [rbp-1A0h] BYREF
  char v6; // [rsp+40h] [rbp-198h]
  char v7; // [rsp+41h] [rbp-197h]
  __int16 v8; // [rsp+42h] [rbp-196h]
  _QWORD *i; // [rsp+48h] [rbp-190h]
  __int64 v10; // [rsp+50h] [rbp-188h]
  _QWORD *v11; // [rsp+58h] [rbp-180h]
  double (__fastcall *isProfileFunctionsInitialized)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+60h] [rbp-178h]
  __int64 v13; // [rsp+68h] [rbp-170h]
  void (__fastcall *v14)(_QWORD, _QWORD); // [rsp+70h] [rbp-168h]
  double (__fastcall *v15)(_QWORD); // [rsp+78h] [rbp-160h]
  __int64 v16; // [rsp+80h] [rbp-158h] BYREF
  _QWORD v17[3]; // [rsp+88h] [rbp-150h] BYREF
  __int64 v18; // [rsp+A0h] [rbp-138h]
  __int64 v19; // [rsp+A8h] [rbp-130h]
  _QWORD dst__3[10]; // [rsp+B0h] [rbp-128h] BYREF
  _QWORD buf_[6]; // [rsp+100h] [rbp-D8h] BYREF
  _BYTE dst_[48]; // [rsp+130h] [rbp-A8h] BYREF
  _BYTE dst__1[48]; // [rsp+160h] [rbp-78h] BYREF
  _BYTE dst__2[48]; // [rsp+190h] [rbp-48h] BYREF

  sub_1402AE3D0(&v16, "SCIGListenerSet<struct IEAPlayableAreaControllerListener>::Notify", (__int64)(a1 + 4), 1);
  sub_142C30540(v17, (__int64)a1, a1);
  while ( v18 < v19 )
  {
    v10 = 0x10 * v18 + v17[0];
    v8 = *(_WORD *)(v10 + 2);
    memset(buf_, 0, sizeof(buf_));
    qmemcpy(dst_, sub_1402B15B0(buf_), sizeof(dst_));
    qmemcpy(dst__1, dst_, sizeof(dst__1));
    v4 = *(_BYTE *)v10;
    qmemcpy(dst__2, dst__1, sizeof(dst__2));
    v5 = v8;
    qmemcpy(dst__3, dst__2, 0x30u);
    dst__3[2] = __rdtsc();
    BYTE4(dst__3[1]) = 0;
    BYTE1(dst__3[0]) = v4;
    LOBYTE(dst__3[0]) = 0;
    v6 = 0;
    isProfileFunctionsInitialized = ::isProfileFunctionsInitialized;
    ::isProfileFunctionsInitialized(dst__3, &v5, &p_p_p_p_p_p_p_p_p_p_p_Source, &p_p_p_p_p_p_p_p_p_p_p_Source, 0);
    WORD1(dst__3[0]) = v5;
    v13 = *(_QWORD *)(v10 + 8);
    v14 = a2;
    a2(v13, a3);
    ++v18;
    v7 = 0;
    dst__3[3] = __rdtsc();
    v15 = qword_149B4B878;
    qword_149B4B878(dst__3);
  }
  v11 = v17;
  for ( i = (_QWORD *)(v17[2] + 0x18LL); *i; i = (_QWORD *)(*i + 8LL) )
  {
    if ( (_QWORD *)*i == v11 )
    {
      *i = v11[1];
      return sub_1402B1820(&v16);
    }
  }
  return sub_1402B1820(&v16);
}

// --- End Function: sub_1443F5120 (0x1443F5120) ---

// --- Function: sub_1443F5880 (0x1443F5880) ---
_QWORD *__fastcall sub_1443F5880(__int64 a1, _QWORD *a2)
{
  _QWORD v3[3]; // [rsp+30h] [rbp-18h] BYREF

  *a2 = *sub_1443F2CE0(a1, v3);
  return a2;
}

// --- End Function: sub_1443F5880 (0x1443F5880) ---

// --- Function: sub_1443F5A50 (0x1443F5A50) ---
_QWORD *__fastcall sub_1443F5A50(__int64 a1, _QWORD *a2)
{
  __int64 v3; // [rsp+28h] [rbp-50h] BYREF
  _QWORD src_[2]; // [rsp+38h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+50h] [rbp-28h] BYREF

  src_[0] = p_p_p_p_p_sub_140384A94;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  sub_1443F2F80(&v3, *(_QWORD *)(a1 + 8));
  *a2 = v3;
  return a2;
}

// --- End Function: sub_1443F5A50 (0x1443F5A50) ---

// --- Function: sub_1443F7380 (0x1443F7380) ---
__int64 __fastcall sub_1443F7380(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 n0x10; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  __int64 (__fastcall *p_sub_1443EA310)(_QWORD *); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1443EA370)(__int64, __int64); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_1441DA1F0();
  n0x10 = 0x10;
  v3 = sub_1443F4180(&v5);
  v9 = sub_1402A2660((__int64)v3);
  v10 = byte_149E3DFEF;
  p_sub_1443EA310 = sub_1443EA310;
  p_sub_1443EA370 = sub_1443EA370;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_1443F7380 (0x1443F7380) ---

// --- Function: sub_14440AA90 (0x14440AA90) ---
void __fastcall sub_14440AA90(
        unsigned int n5,
        __int64 *a2,
        char *p_[EAPlayableAreaController]_Boundary_Violation,
        char *p_[EAPlayableAreaController][$$]_$$:__$$__[$$]_destroyed_due_to_e,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 *ThreadLogContextSlot,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  void *v13; // rsp
  __int64 v14; // [rsp+18h] [rbp-248h]
  _BYTE v15[480]; // [rsp+30h] [rbp-230h] BYREF
  _BYTE *v16; // [rsp+260h] [rbp+0h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+268h] [rbp+8h]
  __int64 n5_1; // [rsp+270h] [rbp+10h]

  n5_1 = 5;
  v13 = alloca(0x230);
  v16 = v15;
  __Val_0__ = (vraudio::AudioBuffer *)v15;
  sub_14440AF20((unsigned int)v15, (_DWORD)ThreadLogContextSlot, a10, a11, a12, a13);
  LODWORD(v14) = a6;
  sub_1403045C0(
    n5,
    a2,
    p_[EAPlayableAreaController]_Boundary_Violation,
    p_[EAPlayableAreaController][$$]_$$:__$$__[$$]_destroyed_due_to_e,
    __Val_0__,
    5u,
    a5,
    v14,
    a7,
    a8);
}

// --- End Function: sub_14440AA90 (0x14440AA90) ---

// --- Function: sub_14440AF20 (0x14440AF20) ---
__int64 __fastcall sub_14440AF20(__int64 a1, __int64 *ThreadLogContextSlot, int a3, int a4, __int64 a5, __int64 a6)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14440C5E0((int)a1 + 0x70, a3, a4, a5, a6) + 1;
}

// --- End Function: sub_14440AF20 (0x14440AF20) ---

// --- Function: sub_14440C5E0 (0x14440C5E0) ---
__int64 __fastcall sub_14440C5E0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v6; // [rsp+20h] [rbp-48h]
  const char *p_null; // [rsp+30h] [rbp-38h]

  *(_QWORD *)a1 = identity((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E50();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v6;
  while ( p_null[v6] );
  *(_QWORD *)(a1 + 0x68) = v6;
  return sub_141DA5EC0(a1 + 0x70, a3, a4, a5) + 1;
}

// --- End Function: sub_14440C5E0 (0x14440C5E0) ---

// --- Function: sub_14440F510 (0x14440F510) ---
_QWORD *__fastcall sub_14440F510(_QWORD *a1, char *src_1, char *src_6, char a4)
{
  char v5[8]; // [rsp+20h] [rbp-68h] BYREF
  char *src; // [rsp+28h] [rbp-60h]
  char v7; // [rsp+30h] [rbp-58h]
  char v8; // [rsp+31h] [rbp-57h]
  char *src_3; // [rsp+38h] [rbp-50h]
  char *dst; // [rsp+40h] [rbp-48h]
  char *src_2; // [rsp+48h] [rbp-40h]
  char *src_5; // [rsp+50h] [rbp-38h]
  char *src_7; // [rsp+58h] [rbp-30h]
  char *src_4; // [rsp+60h] [rbp-28h]
  char v16; // [rsp+A8h] [rbp+20h] BYREF

  v16 = a4;
  src = src_1;
  src_5 = src_6;
  v7 = 1;
  v5[0] = v8;
  src_7 = src_6;
  src_2 = src_1;
  src_3 = src_1;
  src_4 = src_6;
  while ( src_3 != src_4 && !(unsigned __int8)sub_14441E350(v5, src_3) )
    src_3 += 0x20;
  src_2 = src_3;
  src = src_3;
  dst = src_3;
  if ( src_3 != src_5 )
  {
    while ( 1 )
    {
      src += 0x20;
      if ( src == src_5 )
        break;
      if ( !(unsigned __int8)sub_14441E350(&v16, src) )
      {
        qmemcpy(dst, src, 0x20u);
        dst += 0x20;
      }
    }
  }
  *a1 = dst;
  return a1;
}

// --- End Function: sub_14440F510 (0x14440F510) ---

// --- Function: is_entity_descriptor_valid_or_accessible_w (0x14441E350) ---
bool __fastcall sub_14441E350(__int64 a1, char *src)
{
  return !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)src);
}

// --- End Function: is_entity_descriptor_valid_or_accessible_w (0x14441E350) ---

// --- Function: sub_144420820 (0x144420820) ---
__int64 sub_144420820(__int64 a1, unsigned int a2, ...)
{
  _BYTE v3[8]; // [rsp+30h] [rbp-88h] BYREF
  unsigned int v4; // [rsp+38h] [rbp-80h]
  void (__fastcall **v5)(_BYTE *, _QWORD, __int64, __int64); // [rsp+40h] [rbp-78h]
  unsigned int v6; // [rsp+48h] [rbp-70h]
  __int64 v7; // [rsp+50h] [rbp-68h]
  __int64 v8; // [rsp+58h] [rbp-60h]
  void (__fastcall *v9)(_BYTE *, _QWORD, __int64, __int64); // [rsp+60h] [rbp-58h]
  void (__fastcall *v10)(_BYTE *, _QWORD, __int64, __int64); // [rsp+68h] [rbp-50h]
  __int128 dst_; // [rsp+70h] [rbp-48h] BYREF
  _BYTE v12[24]; // [rsp+80h] [rbp-38h] BYREF
  unsigned int v14; // [rsp+C8h] [rbp+10h] BYREF
  __int64 v15; // [rsp+D0h] [rbp+18h] BYREF
  va_list va; // [rsp+D0h] [rbp+18h]
  __int64 v17; // [rsp+D8h] [rbp+20h] BYREF
  va_list va1; // [rsp+D8h] [rbp+20h]
  va_list va2; // [rsp+E0h] [rbp+28h] BYREF

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v15 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v17 = va_arg(va2, _QWORD);
  v14 = a2;
  qmemcpy(&dst_, &src__10, sizeof(dst_));
  sub_14122A290((__int64)v12, 0, &dst_);
  v3[0] = 0;
  v6 = sub_144439260(a1, (unsigned int)v3, (unsigned int)v12, (unsigned int)&v14, (__int64)va, (__int64)va1);
  if ( v3[0] )
  {
    v5 = (void (__fastcall **)(_BYTE *, _QWORD, __int64, __int64))(a1 + 8);
    v7 = v17;
    v8 = v15;
    v4 = v14;
    v3[1] = 0;
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
    {
      v9 = *v5;
      v9(v12, v4, v8, v7);
    }
    else
    {
      v10 = *v5;
      ((void (__fastcall *)(void (__fastcall **)(_BYTE *, _QWORD, __int64, __int64), _BYTE *, _QWORD, __int64, __int64))v10)(
        v5,
        v12,
        v4,
        v8,
        v7);
    }
  }
  return v6;
}

// --- End Function: sub_144420820 (0x144420820) ---

// --- Function: sub_144420AD0 (0x144420AD0) ---
__int64 __fastcall sub_144420AD0(__int64 a1, __int64 a2, float a3, float a4, char a5, __int64 a6, char a7)
{
  _BYTE v8[32]; // [rsp+50h] [rbp-A8h] BYREF
  float v9; // [rsp+70h] [rbp-88h]
  float v10; // [rsp+78h] [rbp-80h]
  void (__fastcall **v11)(_BYTE *, __int64); // [rsp+80h] [rbp-78h]
  unsigned int v12; // [rsp+88h] [rbp-70h]
  __int64 v13; // [rsp+90h] [rbp-68h]
  __int64 v14; // [rsp+98h] [rbp-60h]
  void (__fastcall *v15)(_BYTE *, __int64); // [rsp+A0h] [rbp-58h]
  void (__fastcall *v16)(_BYTE *, __int64); // [rsp+A8h] [rbp-50h]
  __int128 dst_; // [rsp+B0h] [rbp-48h] BYREF
  _BYTE v18[24]; // [rsp+C0h] [rbp-38h] BYREF
  __int64 v20; // [rsp+108h] [rbp+10h] BYREF
  float v21; // [rsp+110h] [rbp+18h] BYREF
  float v22; // [rsp+118h] [rbp+20h] BYREF

  v22 = a4;
  v21 = a3;
  v20 = a2;
  qmemcpy(&dst_, &src__10, sizeof(dst_));
  sub_14122A290((__int64)v18, 0, &dst_);
  v8[0] = 0;
  v12 = sub_144439800(
          a1,
          (unsigned int)v8,
          (unsigned int)v18,
          (unsigned int)&v20,
          (__int64)&v21,
          (__int64)&v22,
          (__int64)&a5,
          (__int64)&a6,
          (__int64)&a7);
  if ( v8[0] )
  {
    v11 = (void (__fastcall **)(_BYTE *, __int64))(a1 + 8);
    v8[8] = a7;
    v13 = a6;
    v8[0x10] = a5;
    v9 = v22;
    v10 = v21;
    v14 = v20;
    v8[0x18] = 0;
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
    {
      v15 = *v11;
      v15(v18, v14);
    }
    else
    {
      v16 = *v11;
      ((void (__fastcall *)(void (__fastcall **)(_BYTE *, __int64), _BYTE *, __int64))v16)(v11, v18, v14);
    }
  }
  return v12;
}

// --- End Function: sub_144420AD0 (0x144420AD0) ---

// --- Function: sub_144435E50 (0x144435E50) ---
const char *__fastcall sub_144435E50(__int64 a1, __int64 a2)
{
  const char *v4; // rdi
  const char *result; // rax
  _QWORD src_[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = (const char *)unknown_libname_484(a1 + 0x348);
  result = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)(a1 + 0x348));
  if ( v4 == result )
  {
LABEL_4:
    src_[1] = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                           qword_149B4FC40,
                           0);
    src_[0] = a2;
    sub_1432A4AD0((Parameter *)(a1 + 0x348), src_);
    return (const char *)sub_1403A58C0(a1, 1u);
  }
  else
  {
    while ( *(_QWORD *)v4 != a2 )
    {
      v4 += 0x10;
      if ( v4 == result )
        goto LABEL_4;
    }
  }
  return result;
}

// --- End Function: sub_144435E50 (0x144435E50) ---

// --- Function: sub_144438390 (0x144438390) ---
char __fastcall sub_144438390(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rax
  Parameter *v4; // rax
  _QWORD *v5; // rax
  Parameter *v6; // rax
  const char *v7; // rax
  __int64 *v8; // rax
  __int64 v9; // r9
  ULONG_PTR p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source[2]; // [rsp+40h] [rbp-38h] BYREF
  unsigned __int64 v12; // [rsp+88h] [rbp+10h] BYREF
  char *Parameter_; // [rsp+90h] [rbp+18h] BYREF
  int Parameter__1; // [rsp+98h] [rbp+20h] BYREF

  v12 = a2;
  LOBYTE(v3) = is_entity_descriptor_valid_or_accessible(&v12);
  if ( (_BYTE)v3 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) )
    {
      sub_1402AE480(
        (__int64)p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
        "CEntityComponentEAPlayableAreaController::DisableUpdate",
        a1 + 0x2F0,
        1,
        1,
        "m_outOfBoundsLock");
      sub_14277D090((_QWORD *)(a1 + 0x2D8), (Parameter *)&Parameter_);
      v4 = sub_14277D0F0(a1 + 0x2D8, (Parameter *)&Parameter__1);
      if ( !std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
              &Parameter_,
              v4) )
      {
        while ( 1 )
        {
          v5 = (_QWORD *)unknown_libname_484((__int64)&Parameter_);
          if ( *v5 == v12 )
            break;
          sub_143E30F90(&Parameter_);
          v6 = sub_14277D0F0(a1 + 0x2D8, (Parameter *)&Parameter__1);
          if ( std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator==(
                 &Parameter_,
                 v6) )
          {
            goto LABEL_10;
          }
        }
        if ( dword_149A26690 > 0 )
        {
          v7 = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v12 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v12 & 0xFFFFFFFFFFFFLL);
          LogTraceConditional(
            "[EAPlayableAreaController][%s] Entity No Longer OutOfBounds: %s",
            "CEntityComponentEAPlayableAreaController::DisableUpdate",
            v7);
        }
        sub_143EDB400((AK::WriteBytesCount *)(a1 + 0x2D8), (BB_ComparisonOperatorType *)&Parameter__1, Parameter_);
        sub_14448D280(a1, 0, v12, 0);
      }
LABEL_10:
      sub_1402B1870(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
      sub_1402AE400(
        (__int64)p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
        "CEntityComponentEAPlayableAreaController::DisableUpdate",
        a1 + 0x2F0,
        1,
        1,
        "m_outOfBoundsLock");
      if ( sub_14277D200((_QWORD *)(a1 + 0x2D8)) )
        sub_1403A3CF0(a1, 0);
      sub_1402B1860((__int64)p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
    }
    v8 = sub_1425D62E0(v12 & 0xFFFFFFFFFFFFLL, &Parameter_);
    v3 = sub_140501090(v8);
    if ( v3 )
    {
      LOBYTE(v3) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x650LL))(v3);
      if ( (_BYTE)v3 )
      {
        sub_14448E1D0(a1, v12, 0.0, v9, 0, 0, 1);
        LOBYTE(v3) = sub_14448D660(a1, v12);
      }
    }
  }
  return v3;
}

// --- End Function: sub_144438390 (0x144438390) ---

// --- Function: sub_144439260 (0x144439260) ---
__int64 __fastcall sub_144439260(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 *va,
        unsigned __int64 *va1)
{
  unsigned int v7; // [rsp+40h] [rbp-108h]
  __int64 v8; // [rsp+48h] [rbp-100h]
  ULONG_PTR Parameter; // [rsp+50h] [rbp-F8h] BYREF
  __int64 v10; // [rsp+58h] [rbp-F0h]
  unsigned __int64 *va1_1; // [rsp+60h] [rbp-E8h] BYREF
  unsigned __int64 *va_1; // [rsp+68h] [rbp-E0h] BYREF
  _QWORD v13[5]; // [rsp+70h] [rbp-D8h] BYREF
  __int64 (__fastcall *p_sub_1444ADD40)(); // [rsp+98h] [rbp-B0h]
  unsigned __int64 **p_va1; // [rsp+A0h] [rbp-A8h]
  unsigned __int64 **p_va1_1; // [rsp+A8h] [rbp-A0h]
  unsigned __int64 **p_va; // [rsp+B0h] [rbp-98h]
  unsigned __int64 **p_va_1; // [rsp+B8h] [rbp-90h]
  __int64 *v19; // [rsp+C0h] [rbp-88h]
  __int64 *v20; // [rsp+C8h] [rbp-80h]
  _QWORD *v21; // [rsp+D0h] [rbp-78h]
  __int64 (__fastcall **p_p_sub_1444ADD40)(); // [rsp+D8h] [rbp-70h]
  __int64 v23; // [rsp+E0h] [rbp-68h]
  __int64 (__fastcall *v24)(__int64, _QWORD, __int64, __int64, _QWORD *, __int64); // [rsp+E8h] [rbp-60h]
  __int64 v25[2]; // [rsp+F0h] [rbp-58h] BYREF
  _QWORD v26[2]; // [rsp+100h] [rbp-48h] BYREF
  __int64 (__fastcall *p_sub_1444ADD40_1)(); // [rsp+110h] [rbp-38h] BYREF
  unsigned __int64 *va1_2; // [rsp+118h] [rbp-30h] BYREF
  unsigned __int64 *va_2; // [rsp+120h] [rbp-28h] BYREF
  __int64 v30; // [rsp+128h] [rbp-20h] BYREF
  __int64 v31; // [rsp+130h] [rbp-18h] BYREF

  v8 = ((__int64)(*(_QWORD *)(a1 + 0x20) << 0x10) >> 0x10) & 0xFFFFFFFFFFFFLL;
  if ( !v8 )
    return 1;
  sub_14035AE10(&Parameter);
  Parameter = (ULONG_PTR)&off_1481AF030;
  v10 = 0;
  sub_1405251E0((__int64)&Parameter);
  sub_140525360((__int64)&Parameter, (__int64)"variable", va);
  sub_140525360((__int64)&Parameter, (__int64)"variable", va1);
  v23 = v10;
  p_sub_1444ADD40 = sub_1444ADD40;
  v24 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _QWORD *, __int64))(*(_QWORD *)v8 + 8LL);
  v21 = (_QWORD *)identity((__int64)v25);
  v13[2] = va1;
  va1_1 = va1;
  p_va1 = &va1_1;
  v13[3] = va;
  va_1 = va;
  p_va = &va_1;
  v13[4] = a4;
  v13[0] = a4;
  v19 = v13;
  v13[1] = &p_sub_1444ADD40_1;
  p_sub_1444ADD40_1 = p_sub_1444ADD40;
  identity((__int64)&va1_2);
  p_va1_1 = &va1_2;
  va1_2 = *p_va1;
  p_va_1 = &va_2;
  va_2 = *p_va;
  v20 = &v30;
  v30 = *v19;
  v25[1] = (__int64)&v31;
  p_p_sub_1444ADD40 = &p_sub_1444ADD40_1;
  sub_1436BB760(v26, (__int64)&p_sub_1444ADD40_1, v21);
  v7 = v24(v8, *(_WORD *)(a1 + 0x28) & 0x3FFF, a3, v23, v26, a2);
  sub_1402A2B70(v25);
  _StarEngineModule__((ULONG_PTR)&Parameter);
  return v7;
}

// --- End Function: sub_144439260 (0x144439260) ---

// --- Function: sub_144439800 (0x144439800) ---
__int64 __fastcall sub_144439800(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        unsigned __int64 *a8,
        __int64 a9)
{
  unsigned __int8 v10; // [rsp+40h] [rbp-158h]
  unsigned int v11; // [rsp+44h] [rbp-154h]
  __int64 v12; // [rsp+50h] [rbp-148h]
  ULONG_PTR Parameter; // [rsp+58h] [rbp-140h] BYREF
  __int64 v14; // [rsp+60h] [rbp-138h]
  __int64 v15; // [rsp+68h] [rbp-130h] BYREF
  unsigned __int64 *v16; // [rsp+70h] [rbp-128h] BYREF
  __int64 v17; // [rsp+78h] [rbp-120h] BYREF
  __int64 v18; // [rsp+80h] [rbp-118h] BYREF
  __int64 v19; // [rsp+88h] [rbp-110h] BYREF
  _QWORD v20[7]; // [rsp+90h] [rbp-108h] BYREF
  __int64 (__fastcall *p_sub_1444ADE20)(int, int, int, int, __int64, __int64, __int64); // [rsp+C8h] [rbp-D0h]
  __int64 *v22; // [rsp+D0h] [rbp-C8h]
  unsigned __int64 **v23; // [rsp+D8h] [rbp-C0h]
  __int64 *v24; // [rsp+E0h] [rbp-B8h]
  __int64 *v25; // [rsp+E8h] [rbp-B0h]
  __int64 *v26; // [rsp+F0h] [rbp-A8h]
  __int64 *v27; // [rsp+F8h] [rbp-A0h]
  __int64 *v28; // [rsp+100h] [rbp-98h]
  _QWORD *v29; // [rsp+108h] [rbp-90h]
  __int64 (__fastcall **p_p_sub_1444ADE20)(int, int, int, int, __int64, __int64, __int64); // [rsp+110h] [rbp-88h]
  __int64 v31; // [rsp+118h] [rbp-80h]
  __int64 (__fastcall *v32)(__int64, _QWORD, __int64, __int64, _QWORD *, __int64); // [rsp+120h] [rbp-78h]
  __int64 v33[3]; // [rsp+128h] [rbp-70h] BYREF
  _QWORD v34[2]; // [rsp+140h] [rbp-58h] BYREF
  __int64 (__fastcall *p_sub_1444ADE20_1)(int, int, int, int, __int64, __int64, __int64); // [rsp+150h] [rbp-48h] BYREF
  __int64 v36[5]; // [rsp+158h] [rbp-40h] BYREF
  __int64 v37; // [rsp+180h] [rbp-18h] BYREF
  __int64 v38; // [rsp+188h] [rbp-10h] BYREF

  v12 = ((__int64)(*(_QWORD *)(a1 + 0x20) << 0x10) >> 0x10) & 0xFFFFFFFFFFFFLL;
  if ( !v12 )
    return 1;
  sub_14035AE10(&Parameter);
  Parameter = (ULONG_PTR)&off_1481AF030;
  v14 = 0;
  sub_140525360((__int64)&Parameter, (__int64)"variable", a4);
  sub_1405251E0((__int64)&Parameter);
  sub_1443F28D0((__int64)&Parameter, a6, a7, a8);
  v31 = v14;
  p_sub_1444ADE20 = sub_1444ADE20;
  v32 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _QWORD *, __int64))(*(_QWORD *)v12 + 8LL);
  v29 = (_QWORD *)identity((__int64)v33);
  v33[1] = a9;
  v15 = a9;
  v22 = &v15;
  v20[2] = a8;
  v16 = a8;
  v23 = &v16;
  v20[3] = a7;
  v17 = a7;
  v24 = &v17;
  v20[4] = a6;
  v18 = a6;
  v25 = &v18;
  v20[5] = a5;
  v19 = a5;
  v26 = &v19;
  v20[6] = a4;
  v20[0] = a4;
  v27 = v20;
  v20[1] = &p_sub_1444ADE20_1;
  p_sub_1444ADE20_1 = p_sub_1444ADE20;
  sub_1443EAE30(v36, v10, &v19, &v18, &v17, &v16, &v15);
  v28 = &v37;
  v37 = *v27;
  v33[2] = (__int64)&v38;
  p_p_sub_1444ADE20 = &p_sub_1444ADE20_1;
  sub_1443EC9D0(v34, (__int64)&p_sub_1444ADE20_1, v29);
  v11 = v32(v12, *(_WORD *)(a1 + 0x28) & 0x3FFF, a3, v31, v34, a2);
  sub_1402A2B70(v33);
  _StarEngineModule__((ULONG_PTR)&Parameter);
  return v11;
}

// --- End Function: sub_144439800 (0x144439800) ---

// --- Function: sub_14443A5E0 (0x14443A5E0) ---
char __fastcall sub_14443A5E0(__int64 a1, __int64 a2)
{
  __int64 v2; // r15
  __int64 v3; // rax
  __int64 *v4; // rax
  __int64 v5; // rax
  unsigned __int64 *v6; // r12
  __int64 v7; // rax
  __int64 *v8; // rax
  unsigned __int64 *v9; // r13
  _QWORD *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  _QWORD *v13; // r15
  _QWORD *v14; // r14
  _QWORD *v15; // rsi
  __int64 *ThreadLogContextSlot; // rbx
  unsigned __int64 *v17; // rax
  __int64 v18; // rbx
  unsigned __int64 v19; // rax
  void (__fastcall *v20)(unsigned __int64 *, __int64); // rsi
  __int64 v21; // rax
  __int64 v23; // rcx
  __int64 v24; // rax
  __int64 v25; // rbx
  int v26; // esi
  __int64 v28; // [rsp+70h] [rbp-90h] BYREF
  float v29; // [rsp+78h] [rbp-88h]
  int v30; // [rsp+80h] [rbp-80h]
  __int64 v31; // [rsp+88h] [rbp-78h] BYREF
  __int128 v32; // [rsp+90h] [rbp-70h] BYREF
  __int64 v33; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v34; // [rsp+A8h] [rbp-58h] BYREF
  unsigned int v35[4]; // [rsp+B0h] [rbp-50h] BYREF
  double v36; // [rsp+C0h] [rbp-40h]
  __int64 v37; // [rsp+D0h] [rbp-30h] BYREF
  __int128 v38; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v39[2]; // [rsp+F0h] [rbp-10h] BYREF
  _QWORD v40[3]; // [rsp+100h] [rbp+0h] BYREF
  _QWORD v41[3]; // [rsp+118h] [rbp+18h] BYREF
  _QWORD v42[4]; // [rsp+130h] [rbp+30h] BYREF
  __int128 v43; // [rsp+150h] [rbp+50h] BYREF
  __int64 v44; // [rsp+160h] [rbp+60h] BYREF
  int n0x26; // [rsp+168h] [rbp+68h]
  _BYTE v46[4]; // [rsp+16Ch] [rbp+6Ch] BYREF
  _QWORD v47[3]; // [rsp+170h] [rbp+70h] BYREF
  __int16 v48; // [rsp+188h] [rbp+88h]
  int v49; // [rsp+18Ah] [rbp+8Ah] BYREF
  __int16 v50; // [rsp+18Eh] [rbp+8Eh]
  unsigned __int64 v51[44]; // [rsp+190h] [rbp+90h] BYREF
  __int64 v52; // [rsp+358h] [rbp+258h] BYREF

  v52 = a2;
  v2 = a1;
  v31 = a1;
  LOBYTE(v3) = is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v52);
  if ( (_BYTE)v3 )
  {
    if ( pGame )
    {
      if ( (_BYTE)isSandboxEditor && !BYTE3(isSandboxEditor) )
        return v3;
    }
    else if ( (_BYTE)isSandboxEditor )
    {
      return v3;
    }
    if ( dword_149A26688 )
    {
      LOBYTE(v3) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v2 + 8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(v2 + 8) & 0xFFFFFFFFFFFFLL);
      if ( (_BYTE)v3 )
      {
        v4 = sub_1425D62E0(v52 & 0xFFFFFFFFFFFFLL, &v37);
        v5 = sub_140501090(v4);
        v6 = (unsigned __int64 *)v5;
        if ( v5 )
        {
          v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x6F0LL))(v5);
        }
        else
        {
          v8 = sub_14033B1A0(v52 & 0xFFFFFFFFFFFFLL, &v34);
          v7 = sub_1403E6720(v8);
        }
        v9 = (unsigned __int64 *)v7;
        LODWORD(v3) = sub_144445960(v2, v52) - 3;
        if ( (v3 & 0xFFFFFFFD) == 0 )
        {
          if ( v9 )
          {
            LOBYTE(v3) = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v9 + 0x7B8))(v9);
            if ( !(_BYTE)v3 )
            {
              v10 = (_QWORD *)sub_1443F5A50(v9, &v28);
              v3 = sub_14277D6A0(v10);
              if ( !v3 )
              {
                v44 = 0x11000000D3LL;
                n0x26 = 0x26;
                unknown_libname_475(&v43, (__int64)&v44, (__int64)v46);
                v32 = v43;
                v30 = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)&v32,
                        (__int64)"[EAPlayableAreaController] Boundary Violation",
                        "[EAPlayableAreaController][$$] $$: '$$' [$$] destroyed due to exitiing playable area");
                if ( (v30 & 0xFFFFF) != 0 )
                {
                  sub_1403B0A70(v9 + 1, &v32);
                  v44 = sub_14035C680((__int64)v47, &v32, 0);
                  if ( is_entity_descriptor_valid_or_accessible(v9 + 1) )
                    v11 = v9[1] & 0xFFFFFFFFFFFFLL;
                  else
                    v11 = 0;
                  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x70LL))(v11);
                  v13 = sub_14035C7B0(v42, v12, 0);
                  v14 = sub_14035C7B0(v41, (__int64)"CEntityComponentEAPlayableAreaController::ExitReaction", 0);
                  v15 = sub_14035C7B0(v40, (__int64)"CEntityComponentEAPlayableAreaController::ExitReaction", 0);
                  ThreadLogContextSlot = getThreadLogContextSlot();
                  sub_1402B1670(v39);
                  *(_QWORD *)&v43 = 0x11000000D3LL;
                  DWORD2(v43) = 0x26;
                  unknown_libname_475(&v38, (__int64)&v43, (__int64)&v43 + 0xC);
                  *(_OWORD *)v35 = v38;
                  sub_14440AA90(
                    5,
                    (unsigned int)v35,
                    (unsigned int)"[EAPlayableAreaController] Boundary Violation",
                    (unsigned int)"[EAPlayableAreaController][$$] $$: '$$' [$$] destroyed due to exitiing playable area",
                    1,
                    v30,
                    (__int64)v39,
                    0,
                    ThreadLogContextSlot,
                    (__int64)v15,
                    (__int64)v14,
                    (__int64)v13,
                    v44);
                  sub_140370F70((__int64)v40);
                  sub_140370F70((__int64)v41);
                  sub_140370F70((__int64)v42);
                  v2 = v31;
                }
                sub_1403B0A70(v9 + 1, &v33);
                v17 = (unsigned __int64 *)(*(__int64 (__fastcall **)(unsigned __int64 *, __int64 *))(*v9 + 0x7F0))(
                                            v9,
                                            &v31);
                sub_1403B0A70(v17, &v28);
                v18 = v33;
                v49 = 0;
                if ( v28 )
                  v18 = v28;
                v50 = 0;
                v19 = *v9;
                memset(v47, 0, sizeof(v47));
                v20 = *(void (__fastcall **)(unsigned __int64 *, __int64))(v19 + 0x7D0);
                v48 = 0;
                sub_1403235B0(&v49, 0);
                v21 = sub_141335460((__int64)v47, 1);
                *(_QWORD *)(v21 + 0x10) = v18;
                v20(v9, v21);
                LOBYTE(v3) = sub_144435E50(v2, v9[1]);
                if ( v6 )
                {
                  LOBYTE(v3) = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v6 + 0x650))(v6);
                  if ( !(_BYTE)v3 )
                    LOBYTE(v3) = sub_144435E50(v2, v52);
                }
              }
            }
          }
          else if ( v6 )
          {
            if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int64 *))(*v6 + 0x650))(v6) )
              sub_144435E50(v2, v52);
            _XMM0 = 0;
            *(float *)&v43 = 0.0;
            *((float *)&v43 + 1) = 0.0;
            *((float *)&v43 + 2) = 0.0;
            v28 = 0;
            v29 = 0.0;
            v36 = 0.0;
            __asm { vmovupd xmmword ptr [rbp+240h+var_290], xmm0 }
            if ( is_entity_descriptor_valid_or_accessible(v6 + 1) )
              v23 = v6[1] & 0xFFFFFFFFFFFFLL;
            else
              v23 = 0;
            v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x648LL))(v23);
            v25 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v24 + 0x30LL))(v24, &v34);
            v26 = sub_140359B80(0x13u);
            sub_14036BDC0((__int64)v47);
            sub_1403627A0(
              (__int64)v51,
              0,
              v52,
              v52,
              (__int64)v47,
              0.0,
              0,
              0xFFFFFFFF,
              v26,
              v25,
              (__int64)v35,
              (__int64)&v28,
              (__int64)&v43);
            LOBYTE(v3) = (unsigned __int8)sub_14646D6C0(*(_QWORD *)(v2 + 0x268), v51);
          }
        }
      }
    }
  }
  return v3;
}

// --- End Function: sub_14443A5E0 (0x14443A5E0) ---

// --- Function: sub_144445870 (0x144445870) ---
float __fastcall sub_144445870(__int64 a1, unsigned __int64 a2, char a3)
{
  __int64 *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 *v9; // rax
  __int64 v10; // rax
  unsigned __int64 v12; // [rsp+38h] [rbp+10h] BYREF
  __int64 v13; // [rsp+48h] [rbp+20h] BYREF

  v12 = a2;
  if ( is_entity_descriptor_valid_or_accessible(&v12)
    && ((v5 = sub_1425D62E0(v12 & 0xFFFFFFFFFFFFLL, &v13), (v6 = sub_140501090(v5)) == 0)
      ? (v9 = sub_14033B1A0(v12 & 0xFFFFFFFFFFFFLL, &v13), v7 = sub_1403E6720(v9))
      : (v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x6F0LL))(v6)),
        v7) )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x6E0LL))(v7) )
      v8 = sub_1403335B0(a1) + 0x38;
    else
      v8 = sub_1403335B0(a1) + 0x28;
  }
  else
  {
    v8 = sub_1403335B0(a1) + 0x18;
  }
  v10 = unknown_libname_484(v8);
  if ( a3 )
    return *(float *)(v10 + 0x1C);
  else
    return *(float *)(v10 + 0x18);
}

// --- End Function: sub_144445870 (0x144445870) ---

// --- Function: sub_144445960 (0x144445960) ---
__int64 __fastcall sub_144445960(__int64 a1, unsigned __int64 a2)
{
  __int64 *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v8; // rax
  __int64 *v9; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // [rsp+38h] [rbp+10h] BYREF
  __int64 v12; // [rsp+40h] [rbp+18h] BYREF

  v11 = a2;
  if ( is_entity_descriptor_valid_or_accessible(&v11)
    && ((v3 = sub_1425D62E0(v11 & 0xFFFFFFFFFFFFLL, &v12), (v4 = sub_140501090(v3)) == 0)
      ? (v9 = sub_14033B1A0(v11 & 0xFFFFFFFFFFFFLL, &v12), v5 = sub_1403E6720(v9))
      : (v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x6F0LL))(v4)),
        v5) )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x6E0LL))(v5) )
    {
      v6 = sub_1403335B0(a1);
      return *(unsigned int *)(unknown_libname_484(v6 + 0x38) + 8);
    }
    else
    {
      v8 = sub_1403335B0(a1);
      return *(unsigned int *)(unknown_libname_484(v8 + 0x28) + 8);
    }
  }
  else
  {
    v10 = sub_1403335B0(a1);
    return *(unsigned int *)(unknown_libname_484(v10 + 0x18) + 8);
  }
}

// --- End Function: sub_144445960 (0x144445960) ---

// --- Function: sub_14448D280 (0x14448D280) ---
char __fastcall sub_14448D280(_QWORD *a1, unsigned int n2, __int64 a3, unsigned __int64 a4)
{
  __int64 v7; // rax
  _QWORD *n2_1; // rax
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // r9
  __int64 v11; // rax
  __int64 v12; // r10
  __int64 v13; // rsi
  bool v14; // al
  const char *p_null; // rbx
  const char *v16; // rax
  unsigned int v17; // ebp
  double *v18; // rax
  void (__fastcall *p_p_p_p_p_p_sub_140384A94)(__int64); // rdx
  __int128 v28; // [rsp+30h] [rbp-A8h] BYREF
  double v29; // [rsp+40h] [rbp-98h]
  _BYTE v30[24]; // [rsp+48h] [rbp-90h] BYREF
  unsigned __int64 v31; // [rsp+60h] [rbp-78h] BYREF
  __int128 v32; // [rsp+68h] [rbp-70h]
  double v33; // [rsp+78h] [rbp-60h]
  float v34; // [rsp+80h] [rbp-58h]
  __int64 v35; // [rsp+E0h] [rbp+8h] BYREF
  unsigned __int64 v36; // [rsp+F8h] [rbp+20h] BYREF

  v36 = a4;
  v7 = sub_1464831F0(a1[0x4D]);
  if ( v7 )
  {
    LOBYTE(n2_1) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x570LL))(v7);
    if ( (_BYTE)n2_1 != 2 )
      return (char)n2_1;
  }
  LOBYTE(n2_1) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1[1] & 0xFFFFFFFFFFFFLL) + 0x720LL))(a1[1] & 0xFFFFFFFFFFFFLL);
  if ( (_BYTE)n2_1 )
  {
    if ( dword_149A26690 <= 0 )
    {
LABEL_20:
      LOBYTE(n2_1) = sub_144420820((__int64)(a1 + 0x40), n2, a3, v36);
      goto LABEL_21;
    }
    v9 = v36;
    if ( v36 )
    {
      v10 = HIWORD(v36);
      if ( (v36 & 0xF000000000000000uLL) != 0 )
      {
        v11 = map_flag_to_mask(0x2000u);
        v13 = v12 & ~(v11 - 1);
      }
      else
      {
        v13 = (v36 & 0xFFFFFFFFFFFFLL) - 6;
      }
      if ( *(_WORD *)(v13 + 2) == (v10 & 0xFFF) )
      {
        if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D)
          || (v14 = is_thread_privileged_or_bypass_mode(), v9 = v36, v14) )
        {
          v14 = 1;
        }
        if ( *(_WORD *)(v13 + 4) == 2 && v14 )
          goto LABEL_17;
        if ( validate_entity_descriptor_detailed_access(&v36) )
        {
          v9 = v36;
LABEL_17:
          p_null = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL)
                                                                             + 0x70LL))(v9 & 0xFFFFFFFFFFFFLL);
LABEL_19:
          v16 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a3 & 0xFFFFFFFFFFFFLL) + 0x70LL))(a3 & 0xFFFFFFFFFFFFLL);
          LogTraceConditional(
            "[EAPlayableAreaController][%s] ListenerType: %d Player: %s Area: %s",
            "CEntityComponentEAPlayableAreaController::RmMulticastInvokeAreaListener",
            n2,
            v16,
            p_null);
          goto LABEL_20;
        }
      }
    }
    p_null = "null";
    goto LABEL_19;
  }
LABEL_21:
  if ( !byte_149B501D5 )
    return (char)n2_1;
  n2_1 = sub_1464E72C0(qword_149E7E438, &v35);
  if ( *n2_1 != a3 )
    return (char)n2_1;
  if ( !n2 )
  {
    p_p_p_p_p_p_sub_140384A94 = p_p_p_sub_140B13358;
    goto LABEL_30;
  }
  v17 = n2 - 1;
  if ( !v17 )
  {
    p_p_p_p_p_p_sub_140384A94 = p_p_p_p_p_sub_140384A94;
LABEL_30:
    LOBYTE(n2_1) = (unsigned __int8)sub_1443F4EA0(a1 + 0x62, p_p_p_p_p_p_sub_140384A94);
    return (char)n2_1;
  }
  if ( v17 == 1 )
  {
    LOBYTE(n2_1) = is_entity_descriptor_valid_or_accessible(&v36);
    if ( (_BYTE)n2_1 )
    {
      (*(void (__fastcall **)(unsigned __int64, __int128 *, __int64))(*(_QWORD *)(v36 & 0xFFFFFFFFFFFFLL) + 0x2C8LL))(
        v36 & 0xFFFFFFFFFFFFLL,
        &v28,
        1);
      v18 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)(a3 & 0xFFFFFFFFFFFFLL) + 0x2C8LL))(
                        a3 & 0xFFFFFFFFFFFFLL,
                        v30,
                        1);
      _XMM5 = (unsigned __int64)v28;
      _XMM2 = COERCE_UNSIGNED_INT64(
                (*v18 - *(double *)&v28) * (*v18 - *(double *)&v28)
              + (v18[1] - *((double *)&v28 + 1)) * (v18[1] - *((double *)&v28 + 1))
              + (v18[2] - v29) * (v18[2] - v29));
      __asm
      {
        vmovddup xmm0, xmm2
        vsqrtpd xmm3, xmm0
        vunpcklpd xmm0, xmm5, xmm7
        vunpckhpd xmm3, xmm3, xmm3
      }
      v28 = _XMM0;
      v32 = _XMM0;
      __asm { vcvtsd2ss xmm0, xmm3, xmm3 }
      v31 = v36;
      v34 = *(float *)&_XMM0;
      v33 = v29;
      LOBYTE(n2_1) = (unsigned __int8)sub_1443F5120(
                                        a1 + 0x62,
                                        (void (__fastcall *)(_QWORD, _QWORD))sub_140B13360,
                                        (__int64)&v31);
    }
  }
  return (char)n2_1;
}

// --- End Function: sub_14448D280 (0x14448D280) ---

// --- Function: sub_14448D660 (0x14448D660) ---
char __fastcall sub_14448D660(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v3; // rax
  __int64 v4; // rdi
  void (__fastcall *v5)(__int64, _QWORD, __int64); // rbx
  __int64 v6; // rax
  unsigned int v7; // eax
  __int64 v8; // rdi
  void (__fastcall *v9)(__int64, _QWORD, __int64, __int64, char, char); // rbx
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // rbx
  __int64 v13; // rax
  char v15; // [rsp+20h] [rbp-18h]
  char v16; // [rsp+28h] [rbp-10h]
  unsigned __int64 v17; // [rsp+48h] [rbp+10h] BYREF
  __int64 v18; // [rsp+50h] [rbp+18h] BYREF

  v17 = a2;
  LOBYTE(v3) = is_entity_descriptor_valid_or_accessible(&v17);
  if ( (_BYTE)v3 )
  {
    LOBYTE(v3) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL);
    if ( (_BYTE)v3 )
      LOBYTE(v3) = sub_141537140(a1 + 0x170, v17);
    if ( byte_149B501D5 )
    {
      v3 = sub_1464E72C0(qword_149E7E438, &v18);
      if ( *v3 == v17 )
      {
        sub_141F382E0(v17 & 0xFFFFFFFFFFFFLL, &v18);
        LOBYTE(v3) = is_valid_handle_typeA(&v18);
        if ( (_BYTE)v3 )
        {
          v4 = sub_14030ECF0(&v18);
          v5 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v4 + 0x588LL);
          v6 = sub_1403335B0(a1);
          v7 = AK::WriteBytesMem::Count((AK::WriteBytesMem *)(v6 + 0x68));
          v5(v4, v7, 1);
          v8 = sub_14030ECF0(&v18);
          v9 = *(void (__fastcall **)(__int64, _QWORD, __int64, __int64, char, char))(*(_QWORD *)v8 + 0x5D0LL);
          v10 = sub_1403335B0(a1);
          v16 = 0;
          v15 = 0;
          v9(v8, *(unsigned int *)(v10 + 0xA0), v11, 1, v15, v16);
          v12 = sub_1464E7810(qword_149E7E438);
          v13 = sub_1403335B0(a1);
          LOBYTE(v3) = sub_142FFB440(v12, *(_DWORD *)(v13 + 0xC0), 3.4028235e38);
        }
      }
    }
  }
  return (char)v3;
}

// --- End Function: sub_14448D660 (0x14448D660) ---

// --- Function: sub_14448E1D0 (0x14448E1D0) ---
char __fastcall sub_14448E1D0(__int64 a1, unsigned __int64 a2, float a3, __int64 a4, char a5, __int64 a6, char a7)
{
  __int128 v7; // xmm6
  __int128 v8; // xmm7
  _QWORD *v10; // rax
  int v11; // r8d
  int v12; // r9d
  char v13; // bl
  char v14; // r14
  _QWORD *v15; // rax
  __int64 v16; // rsi
  __int64 v17; // rax
  __int64 v18; // r14
  __int64 v19; // rbx
  __int64 *v20; // rax
  char v21; // al
  unsigned __int8 **v22; // rdx
  void **v23; // rax
  __int64 *v24; // rax
  __int64 v25; // rax
  __int64 v26; // rbx
  const void **v27; // rax
  __int64 pEntitySystem_2; // rcx
  __int64 pEntitySystem_1; // rbx
  const void **v30; // rax
  __int64 v31; // rbx
  __int64 v32; // rax
  __int64 pEntitySystem; // rbx
  const void **v34; // rax
  __int64 v35; // rax
  __int64 v36; // rbx
  __int64 v37; // rdx
  __int64 v39; // [rsp+40h] [rbp-21h] BYREF
  __int64 v40; // [rsp+48h] [rbp-19h] BYREF
  void *v41; // [rsp+50h] [rbp-11h] BYREF
  char v42; // [rsp+58h] [rbp-9h]
  int n6; // [rsp+5Ch] [rbp-5h]
  __int128 v44; // [rsp+60h] [rbp-1h]
  __int128 v45; // [rsp+70h] [rbp+Fh]
  unsigned __int64 v46; // [rsp+B8h] [rbp+57h] BYREF

  v46 = a2;
  v45 = v7;
  v44 = v8;
  LOBYTE(v10) = is_entity_descriptor_valid_or_accessible(&v46);
  if ( (_BYTE)v10 )
  {
    LOBYTE(v10) = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v46 & 0xFFFFFFFFFFFFLL) + 0x50LL))(v46 & 0xFFFFFFFFFFFFLL);
    if ( (_BYTE)v10 )
    {
      if ( dword_149A26688 )
      {
        LOBYTE(v10) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL);
        v13 = a7;
        v14 = a5;
        if ( (_BYTE)v10 )
          LOBYTE(v10) = sub_144420AD0((int)a1 + 0x140, v46, v11, v12, a5, a6, a7);
        if ( byte_149B501D5 )
        {
          v10 = sub_1464E72C0(qword_149E7E438, &v40);
          if ( v46 == *v10 )
          {
            v15 = (_QWORD *)sub_1443F5880(v46 & 0xFFFFFFFFFFFFLL, &v40);
            v16 = sub_14277D6A0(v15);
            if ( !v16 )
              goto LABEL_33;
            if ( v13 )
            {
              *(_BYTE *)(a1 + 0x308) = 0;
              pEntitySystem = ::pEntitySystem;
              v34 = (const void **)sub_1403AE630();
              sub_14035B410(&v41, v34);
              v42 = 1;
              n6 = 6;
              sub_1443F7380(pEntitySystem, v16, &v41);
              sub_140370D10(&v41);
              v31 = sub_1464E7810(qword_149E7E438);
              v32 = sub_1403335B0(a1);
              a3 = 3.4028235e38;
              goto LABEL_32;
            }
            if ( !*(_BYTE *)(a1 + 0x308) )
            {
              *(_BYTE *)(a1 + 0x308) = 1;
              sub_1403A58C0(a1, 1u);
              if ( !v14 )
              {
                v22 = (unsigned __int8 **)(sub_1403335B0(a1) + 0x60);
LABEL_18:
                v23 = (void **)sub_14035F010(&v39, v22);
                sub_140377FE0((void **)(a1 + 0x360), v23);
                sub_140370D10(&v39);
                goto LABEL_19;
              }
              v17 = sub_1464822F0(*(_QWORD *)(a1 + 0x268));
              if ( v17 )
              {
                v18 = sub_143B1F350(v17);
                if ( v18 )
                {
                  v19 = *(_QWORD *)(a1 + 0x268);
                  v20 = sub_1464E73E0(qword_149E7E438, &v39);
                  v21 = sub_1464833B0(v19, *v20, 1u, 0);
                  if ( sub_144533210(v18, v21) )
                    v22 = (unsigned __int8 **)(sub_1403335B0(a1) + 0x58);
                  else
                    v22 = (unsigned __int8 **)(sub_1403335B0(a1) + 0x50);
                  goto LABEL_18;
                }
              }
            }
LABEL_19:
            if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&a6) )
              sub_14448D280(a1, 2, v46, a6);
            v24 = sub_1425D62E0(v46 & 0xFFFFFFFFFFFFLL, &v39);
            v25 = sub_140501090(v24);
            v26 = v25;
            if ( !v25 )
              goto LABEL_33;
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x5A0LL))(v25) || !sub_1465D09B0(v26) )
            {
              pEntitySystem_1 = ::pEntitySystem;
              v30 = (const void **)sub_1403AE630();
              sub_14035B410(&v41, v30);
              pEntitySystem_2 = pEntitySystem_1;
              v42 = 1;
              n6 = 6;
            }
            else
            {
              if ( sub_1441E9B40(v16, 6) )
              {
                sub_1442005C0(v16, 6, (unsigned int)(int)a3);
LABEL_30:
                v31 = sub_1464E7810(qword_149E7E438);
                v32 = sub_1403335B0(a1);
LABEL_32:
                sub_142FFB440(v31, *(_DWORD *)(v32 + 0xC0), a3);
LABEL_33:
                sub_1425D62E0(v46 & 0xFFFFFFFFFFFFLL, &v39);
                LOBYTE(v10) = is_valid_handle_typeA(&v39);
                if ( (_BYTE)v10 )
                {
                  v35 = sub_14030ECF0(&v39);
                  v36 = sub_1465EEDB0(v35);
                  sub_1403B0A70((unsigned __int64 *)(a1 + 8), &v40);
                  LOBYTE(v10) = sub_1440230D0(v36, v37, v40);
                }
                return (char)v10;
              }
              if ( !sub_1465D09B0(v26) )
                goto LABEL_30;
              v27 = (const void **)sub_14039F0F0(&v39, a1 + 0x360, (unsigned int)(int)a3);
              sub_14035B410(&v41, v27);
              v42 = 0;
              n6 = 6;
              sub_140370D10(&v39);
              pEntitySystem_2 = ::pEntitySystem;
            }
            sub_1443F7380(pEntitySystem_2, v16, &v41);
            sub_140370D10(&v41);
            goto LABEL_30;
          }
        }
      }
    }
  }
  return (char)v10;
}

// --- End Function: sub_14448E1D0 (0x14448E1D0) ---

// --- Function: sub_1444989E0 (0x1444989E0) ---
void __fastcall sub_1444989E0(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int64 v7; // rcx
  __int64 v9; // rdi
  __int64 v10; // rbx
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  __int64 *v13; // rbx
  const char *v14; // rsi
  int v15; // r8d
  int v16; // r9d
  bool v17; // zf
  _QWORD *v18; // rax
  __int64 *v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rcx
  __int64 *v25; // rax
  __int64 *v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rcx
  __int64 *v30; // rax
  __int128 v32; // kr00_16
  __int64 v34; // [rsp+48h] [rbp-C0h] BYREF
  _QWORD v35[2]; // [rsp+54h] [rbp-B4h] BYREF
  int v36; // [rsp+64h] [rbp-A4h]
  unsigned __int64 v37; // [rsp+68h] [rbp-A0h]
  unsigned __int64 v38; // [rsp+70h] [rbp-98h]
  __int64 v39; // [rsp+78h] [rbp-90h]
  __int64 v40; // [rsp+80h] [rbp-88h]
  ULONG_PTR p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source[2]; // [rsp+A8h] [rbp-60h] BYREF
  _BYTE v42[8]; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v43; // [rsp+C0h] [rbp-48h] BYREF
  __int64 v44; // [rsp+C8h] [rbp-40h] BYREF
  __int128 v45; // [rsp+D8h] [rbp-30h]
  __int128 v46; // [rsp+E8h] [rbp-20h]
  __int128 v47; // [rsp+F8h] [rbp-10h]
  __int128 v48; // [rsp+108h] [rbp+0h]
  __int64 Parameter_; // [rsp+158h] [rbp+50h] BYREF
  __int64 Parameter__1; // [rsp+168h] [rbp+60h] BYREF
  __int64 Parameter__2; // [rsp+170h] [rbp+68h] BYREF

  v48 = v2;
  v7 = *(_QWORD *)(a1 + 8);
  v47 = v3;
  v46 = v4;
  v45 = v5;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v7 & 0xFFFFFFFFFFFFLL) + 0x720LL))(v7 & 0xFFFFFFFFFFFFLL) )
    goto LABEL_30;
  sub_1402AE480(
    (__int64)p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
    "CEntityComponentEAPlayableAreaController::Update",
    a1 + 0x2F0,
    1,
    1,
    "m_outOfBoundsLock");
  v9 = *sub_14277D0F0(a1 + 0x2D8, (Parameter *)&Parameter_);
  v10 = *sub_14277D0F0(a1 + 0x2D8, (Parameter *)&Parameter__1);
  v11 = sub_14277D090((_QWORD *)(a1 + 0x2D8), (Parameter *)&Parameter__2);
  v12 = (_QWORD *)sub_14440F510(&v34, *v11, v10, (unsigned __int8)Parameter_);
  sub_1444B5F10(a1 + 0x2D8, v42, *v12, v9);
  v13 = (__int64 *)unknown_libname_484(a1 + 0x2D8);
  v14 = __crt_win32_buffer_debug_info::file_name((__crt_win32_buffer_debug_info *)(a1 + 0x2D8));
  if ( v13 == (__int64 *)v14 )
  {
LABEL_29:
    sub_1402B1870(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
LABEL_30:
    HIDWORD(v35[0]) = 0x4F00;
    v36 = 0;
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v35[1] = 1;
    v37 = __rdtsc();
    isProfileFunctionsInitialized(
      (char *)v35 + 4,
      &word_149E3E2AC,
      "CEntityComponentEAPlayableAreaController::Update",
      "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\EntityComponentEAPlayableAreaController.cpp",
      0x156);
    HIWORD(v35[0]) = word_149E3E2AC;
    v38 = __rdtsc();
    qword_149B4B878((char *)v35 + 4);
    return;
  }
  while ( 1 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(*v13 & 0xFFFFFFFFFFFFLL) + 0x50LL))(*v13 & 0xFFFFFFFFFFFFLL) )
    {
      v17 = *((_BYTE *)v13 + 0xC) == 0;
      *((float *)v13 + 2) = *((float *)v13 + 2) - *(float *)(a2 + 0x10);
      if ( !v17 && sub_144445870(a1, *v13, *((unsigned __int8 *)v13 + 0xD)) >= *((float *)v13 + 2) )
      {
        if ( !v13[2] )
          v13[2] = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                                qword_149B4FC40,
                                0);
        v18 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                          qword_149B4FC40,
                          0);
        sub_1405975C0(v18, &Parameter__1, v13 + 2);
        _XMM0 = sub_140597760();
        Parameter_ = *v13;
        __asm { vcvtsd2ss xmm7, xmm0, xmm0 }
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&Parameter_)
          && ((v21 = sub_1425D62E0(Parameter_ & 0xFFFFFFFFFFFFLL, &Parameter__2), (v22 = sub_140501090(v21)) == 0)
            ? (v25 = sub_14033B1A0(Parameter_ & 0xFFFFFFFFFFFFLL, &v34), v23 = sub_1403E6720(v25))
            : (v23 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x6F0LL))(v22)),
              v23) )
        {
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x6E0LL))(v23) )
            v24 = sub_1403335B0(a1) + 0x38;
          else
            v24 = sub_1403335B0(a1) + 0x28;
        }
        else
        {
          v24 = sub_1403335B0(a1) + 0x18;
        }
        unknown_libname_484(v24);
        Parameter_ = *v13;
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&Parameter_)
          && ((v26 = sub_1425D62E0(Parameter_ & 0xFFFFFFFFFFFFLL, &v43), (v27 = sub_140501090(v26)) == 0)
            ? (v30 = sub_14033B1A0(Parameter_ & 0xFFFFFFFFFFFFLL, &v44), v28 = sub_1403E6720(v30))
            : (v28 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x6F0LL))(v27)),
              v28) )
        {
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x6E0LL))(v28) )
            v29 = sub_1403335B0(a1) + 0x38;
          else
            v29 = sub_1403335B0(a1) + 0x28;
        }
        else
        {
          v29 = sub_1403335B0(a1) + 0x18;
        }
        v32 = _XMM7;
        *(float *)&v32 = *(float *)&_XMM7 / *(float *)(unknown_libname_484(v29) + 0x18);
        _XMM0 = v32;
        __asm { vminss  xmm6, xmm0, xmm6 }
      }
      sub_14448E1D0(a1, *v13, v15, v16, *((_BYTE *)v13 + 0xD), v13[3], 0);
      if ( *((float *)v13 + 2) <= 0.0 )
        break;
    }
    v13 += 4;
    if ( v13 == (__int64 *)v14 )
      goto LABEL_29;
  }
  sub_14443A5E0(a1, *v13);
  sub_144438390(a1, *v13);
  sub_1402B1870(p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
}

// --- End Function: sub_1444989E0 (0x1444989E0) ---

// --- Function: sub_1444ADE20 (0x1444ADE20) ---
void __fastcall sub_1444ADE20(
        __int64 a1,
        unsigned __int64 *a2,
        unsigned int *a3,
        int a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  ULONG_PTR Parameter[3]; // [rsp+30h] [rbp-18h] BYREF

  sub_14035F7D0(Parameter, a1);
  sub_140525B80((__int64)Parameter, (__int64)"variable", a2);
  sub_1405258B0((__int64)Parameter, (__int64)"variable", a3);
  sub_144402000((unsigned int)Parameter, a4, a5, a6, a7);
  _StarEngineModule__((ULONG_PTR)Parameter);
}

// --- End Function: sub_1444ADE20 (0x1444ADE20) ---

// --- Function: sub_1444B5F10 (0x1444B5F10) ---
char **__fastcall sub_1444B5F10(AK::WriteBytesCount *a1, Parameter *Parameter_1, char *dst_2, char *src_2)
{
  char *src; // [rsp+20h] [rbp-68h]
  char *dst; // [rsp+28h] [rbp-60h]
  __int64 *v7; // [rsp+30h] [rbp-58h]
  __int64 src_1; // [rsp+48h] [rbp-40h]
  char *dst_1; // [rsp+50h] [rbp-38h]

  v7 = (__int64 *)((char *)a1 + 8);
  if ( dst_2 != src_2 )
  {
    dst = dst_2;
    src_1 = *v7;
    src = src_2;
    if ( AK::WriteBytesCount::Reserve(a1) )
    {
      while ( src != (char *)src_1 )
      {
        qmemcpy(dst, src, 0x20u);
        dst += 0x20;
        src += 0x20;
      }
      dst_1 = dst;
    }
    else
    {
      dst_1 = sub_1426F0230(src_2, src_1, dst_2);
    }
    *v7 = (__int64)dst_1;
  }
  *Parameter_1 = dst_2;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_1444B5F10 (0x1444B5F10) ---

// --- Function: sub_144533210 (0x144533210) ---
bool __fastcall sub_144533210(__int64 a1, char a2)
{
  return a2 == *(_BYTE *)(a1 + 0x429);
}

// --- End Function: sub_144533210 (0x144533210) ---

// --- Function: sub_14644AD00 (0x14644AD00) ---
_QWORD *__fastcall sub_14644AD00(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x420);
  return a2;
}

// --- End Function: sub_14644AD00 (0x14644AD00) ---

// --- Function: sub_14644BB60 (0x14644BB60) ---
__int64 __fastcall sub_14644BB60(__int64 a1)
{
  return a1 + 0xED8;
}

// --- End Function: sub_14644BB60 (0x14644BB60) ---

// --- Function: sub_14645EEC0 (0x14645EEC0) ---
__int64 __fastcall sub_14645EEC0(Parameter *Parameter, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+28h] [rbp-80h]
  __int64 v4; // [rsp+78h] [rbp-30h]

  if ( *((_QWORD *)Parameter + 2) <= (unsigned __int64)(*((_QWORD *)Parameter + 4) + 1LL) )
    sub_146475360(Parameter, 1);
  *((_QWORD *)Parameter + 3) &= *((_QWORD *)Parameter + 2) - 1LL;
  v3 = (*((_QWORD *)Parameter + 2) - 1LL) & (*((_QWORD *)Parameter + 4) + *((_QWORD *)Parameter + 3));
  if ( !*(_QWORD *)(*((_QWORD *)Parameter + 1) + 8 * v3) )
    *(_QWORD *)(*((_QWORD *)Parameter + 1) + 8 * v3) = std::_Allocate<16,std::_Default_allocate_traits,0>(0x160u);
  v4 = sub_1402A2B80(0x160, *(_QWORD *)(*((_QWORD *)Parameter + 1) + 8 * v3));
  sub_1403624E0(v4, a2);
  result = *((_QWORD *)Parameter + 4) + 1LL;
  *((_QWORD *)Parameter + 4) = result;
  return result;
}

// --- End Function: sub_14645EEC0 (0x14645EEC0) ---

// --- Function: sub_146460E50 (0x146460E50) ---
__int64 __fastcall sub_146460E50(_QWORD *a1)
{
  return *(_QWORD *)(*(_QWORD *)(*a1 + 8LL) + 8 * ((*(_QWORD *)(*a1 + 0x10LL) - 1LL) & a1[1]));
}

// --- End Function: sub_146460E50 (0x146460E50) ---

// --- Function: sub_14646A350 (0x14646A350) ---
// Handles the processing of a game 'hit' event within the game rules system. This
// involves copying the hit event data, conditionally logging detailed telemetry
// information, acquiring a read-write lock for listener access, iterating through
// registered hit listeners to invoke their callbacks, and finally releasing the
// lock. It also performs cleanup or re-initialization of module pointers.
void *(__fastcall **__fastcall sub_14646A350(
        __int64 game_rules_obj_ptr,
        __int64 hit_event_data_ptr))(FDefaultModuleImpl *__hidden this, unsigned int)
{
  void *v2; // rsp
  __int64 v4; // [rsp+18h] [rbp-2B8h]
  _BYTE event_params_buffer[592]; // [rsp+30h] [rbp-2A0h] BYREF
  int log_status_bits; // [rsp+2D0h] [rbp+0h]
  BOOL v7; // [rsp+2D4h] [rbp+4h]
  __int64 *current_tree_node_iterator; // [rsp+2D8h] [rbp+8h] BYREF
  __int64 hit_listener_manager_ptr; // [rsp+2E0h] [rbp+10h]
  _DWORD log_severity_flags[2]; // [rsp+2E8h] [rbp+18h] BYREF
  char v11; // [rsp+2F0h] [rbp+20h] BYREF
  _DWORD v12[2]; // [rsp+2F8h] [rbp+28h] BYREF
  char v13; // [rsp+300h] [rbp+30h] BYREF
  __int64 src_entity_id; // [rsp+308h] [rbp+38h]
  const char *src_entity_name; // [rsp+310h] [rbp+40h]
  __int64 dest_entity_id; // [rsp+318h] [rbp+48h]
  const char *p_unknown; // [rsp+320h] [rbp+50h]
  _BYTE *p_event_params_buffer; // [rsp+328h] [rbp+58h]
  vraudio::AudioBuffer *p_event_params_buffer_1; // [rsp+330h] [rbp+60h]
  __int64 v20; // [rsp+338h] [rbp+68h]
  __int64 v21; // [rsp+340h] [rbp+70h]
  __int64 current_listener_node; // [rsp+348h] [rbp+78h]
  __int64 hit_listener_lock_ptr; // [rsp+350h] [rbp+80h]
  char is_lock_acquired; // [rsp+358h] [rbp+88h]
  __int64 v25; // [rsp+360h] [rbp+90h]
  _QWORD *src_entity_id_param; // [rsp+368h] [rbp+98h]
  _QWORD *src_entity_name_param; // [rsp+370h] [rbp+A0h]
  _QWORD *dest_entity_id_param; // [rsp+378h] [rbp+A8h]
  _QWORD *dest_entity_name_param; // [rsp+380h] [rbp+B0h]
  _QWORD *function_name_param; // [rsp+388h] [rbp+B8h]
  __int64 *ThreadLogContextSlot; // [rsp+390h] [rbp+C0h]
  const void *v32; // [rsp+398h] [rbp+C8h]
  const void *v33; // [rsp+3A0h] [rbp+D0h]
  const void *v34; // [rsp+3A8h] [rbp+D8h]
  void (__fastcall *v35)(__int64, unsigned __int64 *); // [rsp+3B0h] [rbp+E0h]
  __int64 v36; // [rsp+3B8h] [rbp+E8h]
  __int64 hit_listener_tree_root; // [rsp+3C0h] [rbp+F0h]
  __int64 v38; // [rsp+3C8h] [rbp+F8h]
  __int64 v39; // [rsp+3D0h] [rbp+100h]
  __int64 v40; // [rsp+3D8h] [rbp+108h]
  __int64 v41; // [rsp+3E0h] [rbp+110h]
  __int64 v42; // [rsp+3E8h] [rbp+118h]
  _QWORD Parameter_[2]; // [rsp+3F0h] [rbp+120h] BYREF
  void (__fastcall *listener_callback)(__int64, unsigned __int64 *); // [rsp+400h] [rbp+130h]
  __int64 *v45; // [rsp+408h] [rbp+138h]
  __int64 v46; // [rsp+410h] [rbp+140h]
  __int64 *v47; // [rsp+418h] [rbp+148h]
  _QWORD v48[2]; // [rsp+420h] [rbp+150h] BYREF
  const void *v49; // [rsp+430h] [rbp+160h]
  _QWORD v50[2]; // [rsp+438h] [rbp+168h] BYREF
  const void *v51; // [rsp+448h] [rbp+178h]
  _QWORD v52[2]; // [rsp+450h] [rbp+180h] BYREF
  const void *v53; // [rsp+460h] [rbp+190h]
  _QWORD src_[2]; // [rsp+468h] [rbp+198h] BYREF
  _QWORD src__1[2]; // [rsp+478h] [rbp+1A8h] BYREF
  _QWORD v56[2]; // [rsp+488h] [rbp+1B8h] BYREF
  _QWORD v57[2]; // [rsp+498h] [rbp+1C8h] BYREF
  char v58; // [rsp+4A8h] [rbp+1D8h]
  _QWORD v59[2]; // [rsp+4B0h] [rbp+1E0h] BYREF
  char v60; // [rsp+4C0h] [rbp+1F0h]
  __int64 v61; // [rsp+4C8h] [rbp+1F8h] BYREF
  _QWORD v62[2]; // [rsp+4D0h] [rbp+200h] BYREF
  _BYTE dst_[16]; // [rsp+4E0h] [rbp+210h] BYREF
  __int64 dst__1[2]; // [rsp+4F0h] [rbp+220h] BYREF
  unsigned __int64 src_entity_desc; // [rsp+500h] [rbp+230h] BYREF
  unsigned __int64 dest_entity_desc[43]; // [rsp+508h] [rbp+238h] BYREF

  sub_1403624E0((__int64)&src_entity_desc, hit_event_data_ptr);
  if ( *(int *)(n2_174 + 0x250) > 0 )
  {
    log_severity_flags[0] = sub_142744750(0x19u);
    log_severity_flags[1] = 0x44;
    src_[0] = log_severity_flags;
    src_[1] = &v11;
    qmemcpy(dst_, src_, sizeof(dst_));
    log_status_bits = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)dst_,
                        (__int64)"Processing Hit",
                        "$$: Handling hit from '$$' [$$] on target '$$' [$$].");
    if ( (log_status_bits & 0xFFFFF) != 0 )
    {
      v45 = sub_1403B0A70(dest_entity_desc, &v61);
      v46 = identity(*v45);
      v57[0] = 0;
      v57[1] = v46;
      v58 = 0;
      src_entity_id_param = v57;
      if ( is_entity_descriptor_valid_or_accessible(dest_entity_desc) )
      {
        src_entity_id = sub_14030ECF0(dest_entity_desc);
        src_entity_name = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)src_entity_id + 0x70LL))(src_entity_id);
      }
      else
      {
        src_entity_name = "unknown";
      }
      v52[0] = 0;
      v52[1] = src_entity_name;
      v53 = 0;
      src_entity_name_param = v52;
      v47 = sub_1403B0A70(&src_entity_desc, v62);
      v25 = identity(*v47);
      v59[0] = 0;
      v59[1] = v25;
      v60 = 0;
      dest_entity_id_param = v59;
      if ( is_entity_descriptor_valid_or_accessible(&src_entity_desc) )
      {
        dest_entity_id = sub_14030ECF0(&src_entity_desc);
        p_unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)dest_entity_id + 0x70LL))(dest_entity_id);
      }
      else
      {
        p_unknown = "unknown";
      }
      v50[0] = 0;
      v50[1] = p_unknown;
      v51 = 0;
      dest_entity_name_param = v50;
      v48[0] = 0;
      v48[1] = "CGameRules::ProcessHit";
      v49 = 0;
      function_name_param = v48;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v56[0] = 0;
      v56[1] = 0;
      v12[0] = sub_142744750(0x19u);
      v12[1] = 0x44;
      src__1[0] = v12;
      src__1[1] = &v13;
      qmemcpy(dst__1, src__1, sizeof(dst__1));
      v62[1] = 6;
      v2 = alloca(0x2A0);
      p_event_params_buffer = event_params_buffer;
      p_event_params_buffer_1 = (vraudio::AudioBuffer *)event_params_buffer;
      sub_143068F20(
        (__int64)event_params_buffer,
        (__int64)ThreadLogContextSlot,
        function_name_param,
        dest_entity_name_param,
        dest_entity_id_param,
        src_entity_name_param,
        src_entity_id_param);
      LODWORD(v4) = log_status_bits;
      sub_1403045C0(
        5u,
        dst__1,
        "Processing Hit",
        "$$: Handling hit from '$$' [$$] on target '$$' [$$].",
        p_event_params_buffer_1,
        6u,
        1,
        v4,
        v56,
        0);
      v32 = v49;
      sub_1402A3D30(v49);
      v33 = v51;
      sub_1402A3D30(v51);
      v34 = v53;
      sub_1402A3D30(v53);
    }
  }
  hit_listener_manager_ptr = sub_146481A00(game_rules_obj_ptr);
  if ( hit_listener_manager_ptr )
  {
    v35 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)hit_listener_manager_ptr + 0x570LL);
    v35(hit_listener_manager_ptr, &src_entity_desc);
  }
  hit_listener_lock_ptr = game_rules_obj_ptr + 0x388;
  is_lock_acquired = 1;
  v36 = game_rules_obj_ptr + 0x388;
  sub_1402D2710(game_rules_obj_ptr + 0x388, "CGameRules::ProcessHit", "m_hitListenerLock", 1);
  hit_listener_tree_root = game_rules_obj_ptr + 0x370;
  v20 = game_rules_obj_ptr + 0x370;
  v38 = game_rules_obj_ptr + 0x370;
  v39 = *(_QWORD *)(game_rules_obj_ptr + 0x370);
  std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
    (Parameter *)&current_tree_node_iterator,
    v39);
  while ( 1 )
  {
    v40 = game_rules_obj_ptr + 0x370;
    v21 = game_rules_obj_ptr + 0x370;
    v41 = game_rules_obj_ptr + 0x370;
    v42 = *(_QWORD *)(game_rules_obj_ptr + 0x378);
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
      (Parameter *)Parameter_,
      v42);
    v7 = current_tree_node_iterator == (__int64 *)Parameter_[0];
    if ( current_tree_node_iterator == (__int64 *)Parameter_[0] )
      break;
    Parameter_[1] = current_tree_node_iterator;
    current_listener_node = *current_tree_node_iterator;
    listener_callback = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)current_listener_node + 8LL);
    listener_callback(current_listener_node, &src_entity_desc);
    ++current_tree_node_iterator;
  }
  if ( is_lock_acquired )
    rw_lock_release_read_lock(hit_listener_lock_ptr);
  return sub_140372D50((__int64)&src_entity_desc);
}

// --- End Function: sub_14646A350 (0x14646A350) ---

// --- Function: sub_14646D6C0 (0x14646D6C0) ---
const ULONG_PTR *__fastcall sub_14646D6C0(__int64 game_rules_obj_ptr, unsigned __int64 *a2)
{
  void *v2; // rsp
  __int64 v4; // [rsp+18h] [rbp-2B8h]
  _BYTE v5[592]; // [rsp+30h] [rbp-2A0h] BYREF
  int v6; // [rsp+2D0h] [rbp+0h]
  _DWORD v8[2]; // [rsp+2D8h] [rbp+8h] BYREF
  char v9; // [rsp+2E0h] [rbp+10h] BYREF
  _DWORD v10[2]; // [rsp+2E8h] [rbp+18h] BYREF
  char v11; // [rsp+2F0h] [rbp+20h] BYREF
  __int64 v12; // [rsp+2F8h] [rbp+28h]
  const char *p_unknown; // [rsp+300h] [rbp+30h]
  __int64 v14; // [rsp+308h] [rbp+38h]
  const char *p_unknown_1; // [rsp+310h] [rbp+40h]
  _BYTE *v16; // [rsp+318h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+320h] [rbp+50h]
  ULONG_PTR Parameter; // [rsp+328h] [rbp+58h]
  __int64 v19; // [rsp+330h] [rbp+60h] BYREF
  __int64 v20; // [rsp+338h] [rbp+68h]
  unsigned __int64 *v21; // [rsp+340h] [rbp+70h]
  __int64 *v22; // [rsp+348h] [rbp+78h]
  __int64 v23; // [rsp+350h] [rbp+80h]
  _QWORD *v24; // [rsp+358h] [rbp+88h]
  _QWORD *v25; // [rsp+360h] [rbp+90h]
  _QWORD *v26; // [rsp+368h] [rbp+98h]
  _QWORD *v27; // [rsp+370h] [rbp+A0h]
  _QWORD *v28; // [rsp+378h] [rbp+A8h]
  __int64 *ThreadLogContextSlot; // [rsp+380h] [rbp+B0h]
  const void *v30; // [rsp+388h] [rbp+B8h]
  const void *v31; // [rsp+390h] [rbp+C0h]
  const void *v32; // [rsp+398h] [rbp+C8h]
  __int64 v33; // [rsp+3A0h] [rbp+D0h]
  __int64 v34; // [rsp+3A8h] [rbp+D8h]
  unsigned __int64 *v35; // [rsp+3B0h] [rbp+E0h]
  __int64 *v36; // [rsp+3B8h] [rbp+E8h]
  _QWORD v37[2]; // [rsp+3C0h] [rbp+F0h] BYREF
  const void *v38; // [rsp+3D0h] [rbp+100h]
  _QWORD v39[2]; // [rsp+3D8h] [rbp+108h] BYREF
  const void *v40; // [rsp+3E8h] [rbp+118h]
  _QWORD v41[2]; // [rsp+3F0h] [rbp+120h] BYREF
  const void *v42; // [rsp+400h] [rbp+130h]
  _QWORD src_[2]; // [rsp+408h] [rbp+138h] BYREF
  _QWORD src__1[2]; // [rsp+418h] [rbp+148h] BYREF
  _QWORD v45[2]; // [rsp+428h] [rbp+158h] BYREF
  _QWORD v46[2]; // [rsp+438h] [rbp+168h] BYREF
  char v47; // [rsp+448h] [rbp+178h]
  _QWORD v48[2]; // [rsp+450h] [rbp+180h] BYREF
  char v49; // [rsp+460h] [rbp+190h]
  __int64 n6; // [rsp+468h] [rbp+198h]
  __int64 v51; // [rsp+470h] [rbp+1A0h] BYREF
  __int64 v52; // [rsp+478h] [rbp+1A8h] BYREF
  _BYTE dst_[16]; // [rsp+480h] [rbp+1B0h] BYREF
  __int64 dst__1[2]; // [rsp+490h] [rbp+1C0h] BYREF

  sub_1402AE3D0(&v19, "CGameRules::ServerHit", game_rules_obj_ptr + 0x6E40, 1);
  if ( *(_DWORD *)(game_rules_obj_ptr + 0x6E10) )
  {
    if ( *(int *)(n2_174 + 0x250) > 0 )
    {
      v8[0] = sub_142744750(0x19u);
      v8[1] = 0x44;
      src_[0] = v8;
      src_[1] = &v9;
      qmemcpy(dst_, src_, sizeof(dst_));
      v6 = invokeGlobalCallbackAndMaskStatusBits(
             5,
             (__int64)dst_,
             (__int64)"Processing Hit",
             "$$: Queuing hit from '$$' [$$] on target '$$' [$$].");
      if ( (v6 & 0xFFFFF) != 0 )
      {
        v35 = a2 + 1;
        v36 = sub_1403B0A70(a2 + 1, &v51);
        v20 = identity(*v36);
        v48[0] = 0;
        v48[1] = v20;
        v49 = 0;
        v24 = v48;
        if ( is_entity_descriptor_valid_or_accessible(a2 + 1) )
        {
          v12 = sub_14030ECF0(a2 + 1);
          p_unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x70LL))(v12);
        }
        else
        {
          p_unknown = "unknown";
        }
        v41[0] = 0;
        v41[1] = p_unknown;
        v42 = 0;
        v25 = v41;
        v21 = a2;
        v22 = sub_1403B0A70(a2, &v52);
        v23 = identity(*v22);
        v46[0] = 0;
        v46[1] = v23;
        v47 = 0;
        v26 = v46;
        if ( is_entity_descriptor_valid_or_accessible(a2) )
        {
          v14 = sub_14030ECF0(a2);
          p_unknown_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x70LL))(v14);
        }
        else
        {
          p_unknown_1 = "unknown";
        }
        v39[0] = 0;
        v39[1] = p_unknown_1;
        v40 = 0;
        v27 = v39;
        v37[0] = 0;
        v37[1] = "CGameRules::ServerHit";
        v38 = 0;
        v28 = v37;
        ThreadLogContextSlot = getThreadLogContextSlot();
        v45[0] = 0;
        v45[1] = 0;
        v10[0] = sub_142744750(0x19u);
        v10[1] = 0x44;
        src__1[0] = v10;
        src__1[1] = &v11;
        qmemcpy(dst__1, src__1, sizeof(dst__1));
        n6 = 6;
        v2 = alloca(0x2A0);
        v16 = v5;
        __Val_0__ = (vraudio::AudioBuffer *)v5;
        sub_143068F20((__int64)v5, (__int64)ThreadLogContextSlot, v28, v27, v26, v25, v24);
        LODWORD(v4) = v6;
        sub_1403045C0(
          5u,
          dst__1,
          "Processing Hit",
          "$$: Queuing hit from '$$' [$$] on target '$$' [$$].",
          __Val_0__,
          6u,
          1,
          v4,
          v45,
          0);
        v30 = v38;
        sub_1402A3D30(v38);
        v31 = v40;
        sub_1402A3D30(v40);
        v32 = v42;
        sub_1402A3D30(v42);
      }
    }
    v33 = game_rules_obj_ptr + 0x6DE8;
    Parameter = game_rules_obj_ptr + 0x6DE8;
    _StarEngineModule__(game_rules_obj_ptr + 0x6DE8);
    sub_14645EEC0((_QWORD *)Parameter, (__int64)a2);
    return sub_1402B1820(&v19);
  }
  else
  {
    ++*(_DWORD *)(game_rules_obj_ptr + 0x6E10);
    sub_14646A350(game_rules_obj_ptr, (__int64)a2);
    while ( *(_QWORD *)(game_rules_obj_ptr + 0x6E08) != 0 )
    {
      v34 = sub_146475950(game_rules_obj_ptr + 0x6DE8);
      sub_14646A350(game_rules_obj_ptr, v34);
      sub_1464759A0((_QWORD *)(game_rules_obj_ptr + 0x6DE8));
    }
    --*(_DWORD *)(game_rules_obj_ptr + 0x6E10);
    return sub_1402B1820(&v19);
  }
}

// --- End Function: sub_14646D6C0 (0x14646D6C0) ---

// --- Function: sub_146475360 (0x146475360) ---
unsigned __int64 __fastcall sub_146475360(Parameter *Parameter, unsigned __int64 a2)
{
  __crt_strtox *v2; // rcx
  unsigned __int64 _Bytes; // rax
  unsigned __int64 result; // rax
  unsigned __int64 n8; // [rsp+20h] [rbp-B8h]
  char *v6; // [rsp+28h] [rbp-B0h]
  char *buf_1; // [rsp+28h] [rbp-B0h]
  char *buf; // [rsp+28h] [rbp-B0h]
  unsigned __int64 v9; // [rsp+30h] [rbp-A8h]
  char *buf_2; // [rsp+38h] [rbp-A0h]
  __int64 n8_2; // [rsp+40h] [rbp-98h]
  __int64 v12; // [rsp+50h] [rbp-88h] BYREF
  __int64 v13; // [rsp+58h] [rbp-80h] BYREF
  __int64 v14; // [rsp+60h] [rbp-78h]
  unsigned __int64 n8_1; // [rsp+68h] [rbp-70h]
  __int64 v16; // [rsp+70h] [rbp-68h]
  AK::WriteBytesCount *v17; // [rsp+78h] [rbp-60h]
  __int64 v18; // [rsp+80h] [rbp-58h]
  AK::WriteBytesCount *v19; // [rsp+88h] [rbp-50h]
  __int64 v20; // [rsp+90h] [rbp-48h]
  AK::WriteBytesCount *v21; // [rsp+98h] [rbp-40h]
  __int64 v22; // [rsp+A0h] [rbp-38h]
  AK::WriteBytesCount *v23; // [rsp+A8h] [rbp-30h]
  __int64 v24; // [rsp+B0h] [rbp-28h]
  _QWORD *v25; // [rsp+B8h] [rbp-20h]
  __int64 v26; // [rsp+C0h] [rbp-18h]
  __int64 v27; // [rsp+C8h] [rbp-10h]
  unsigned __int64 v30; // [rsp+E8h] [rbp+10h]

  if ( *((_QWORD *)Parameter + 2) )
    n8_2 = *((_QWORD *)Parameter + 2);
  else
    n8_2 = 1;
  for ( n8 = n8_2; ; n8 *= 2LL )
  {
    v2 = (__crt_strtox *)(n8 - *((_QWORD *)Parameter + 2));
    if ( (unsigned __int64)v2 >= a2 && n8 >= 8 )
      break;
    v12 = 0xBA2E8BA2E8BA2ELL;
    v13 = __crt_strtox::maximum_signed_value(v2);
    v14 = *unknown_libname_2(&v13, &v12);
    if ( v14 - n8 < n8 )
      unknown_libname_73();
  }
  v9 = *((_QWORD *)Parameter + 3);
  n8_1 = n8;
  _Bytes = sub_1402A8570(n8);
  buf_2 = (char *)std::_Allocate<16,std::_Default_allocate_traits,0>(_Bytes);
  v30 = n8 - *((_QWORD *)Parameter + 2);
  v16 = *((_QWORD *)Parameter + 1) + 8LL * *((_QWORD *)Parameter + 2);
  v17 = (AK::WriteBytesCount *)(*((_QWORD *)Parameter + 1) + 8 * v9);
  v6 = sub_1428CF930(v17, v16, &buf_2[8 * v9]);
  if ( v9 > v30 )
  {
    v20 = *((_QWORD *)Parameter + 1) + 8 * v30;
    v21 = (AK::WriteBytesCount *)*((_QWORD *)Parameter + 1);
    sub_1428CF930(v21, v20, v6);
    v22 = *((_QWORD *)Parameter + 1) + 8 * v9;
    v23 = (AK::WriteBytesCount *)(*((_QWORD *)Parameter + 1) + 8 * v30);
    buf = sub_1428CF930(v23, v22, buf_2);
    sub_1428CE330(buf, v30);
  }
  else
  {
    v18 = *((_QWORD *)Parameter + 1) + 8 * v9;
    v19 = (AK::WriteBytesCount *)*((_QWORD *)Parameter + 1);
    buf_1 = sub_1428CF930(v19, v18, v6);
    sub_1428CE330(buf_1, v30 - v9);
    sub_1428CE330(buf_2, v9);
  }
  if ( *((_QWORD *)Parameter + 1) )
  {
    v26 = *((_QWORD *)Parameter + 1) + 8LL * *((_QWORD *)Parameter + 2);
    v27 = *((_QWORD *)Parameter + 1);
    v24 = *((_QWORD *)Parameter + 2);
    v25 = (_QWORD *)*((_QWORD *)Parameter + 1);
    std::_Deallocate<16,0>(v25, 8 * v24);
  }
  *((_QWORD *)Parameter + 1) = buf_2;
  result = v30 + *((_QWORD *)Parameter + 2);
  *((_QWORD *)Parameter + 2) = result;
  return result;
}

// --- End Function: sub_146475360 (0x146475360) ---

// --- Function: sub_146475950 (0x146475950) ---
__int64 __fastcall sub_146475950(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp-20h]
  _QWORD v3[3]; // [rsp+30h] [rbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 0x18);
  v3[0] = a1;
  v3[1] = v2;
  return sub_146460E50(v3);
}

// --- End Function: sub_146475950 (0x146475950) ---

// --- Function: sub_1464759A0 (0x1464759A0) ---
_QWORD *__fastcall sub_1464759A0(_QWORD *a1)
{
  _QWORD *result; // rax

  sub_140372D50(*(_QWORD *)(a1[1] + 8 * ((a1[2] - 1LL) & a1[3])));
  if ( --a1[4] )
  {
    result = (_QWORD *)(a1[3] + 1LL);
    a1[3] = result;
  }
  else
  {
    result = a1;
    a1[3] = 0;
  }
  return result;
}

// --- End Function: sub_1464759A0 (0x1464759A0) ---

// --- Function: sub_146481A00 (0x146481A00) ---
// Retrieves the listener manager associated with the game rules object. It
// accesses a specific offset within the game rules object and then calls
// `sub_1442DD550` to further process or validate the retrieved pointer, returning
// 0 if the manager is not found.
__int64 __fastcall sub_146481A00(__int64 game_rules_obj_ptr)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(game_rules_obj_ptr + 0x200);
  if ( v1 )
    return sub_1442DD550(v1);
  else
    return 0;
}

// --- End Function: sub_146481A00 (0x146481A00) ---

// --- Function: sub_1464822F0 (0x1464822F0) ---
__int64 __fastcall sub_1464822F0(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x200);
  if ( v1 )
    return sub_14277D6A0((_QWORD *)(v1 + 0xB8));
  else
    return 0;
}

// --- End Function: sub_1464822F0 (0x1464822F0) ---

// --- Function: sub_1464831F0 (0x1464831F0) ---
__int64 __fastcall sub_1464831F0(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x200);
  if ( v1 )
    return sub_1442E1D40(v1);
  else
    return 0;
}

// --- End Function: sub_1464831F0 (0x1464831F0) ---

// --- Function: sub_1464833B0 (0x1464833B0) ---
char __fastcall sub_1464833B0(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __int64 v6; // rcx
  __int64 v9; // rcx

  v6 = *(_QWORD *)(a1 + 0x200);
  if ( !v6 || !sub_1442E2610(v6) )
    return 0xFF;
  v9 = *(_QWORD *)(a1 + 0x200);
  if ( v9 )
    v9 = sub_1442E2610(v9);
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v9 + 0x588LL))(v9, a2, a3, a4);
}

// --- End Function: sub_1464833B0 (0x1464833B0) ---

// --- Function: sub_1464E72C0 (0x1464E72C0) ---
_QWORD *__fastcall sub_1464E72C0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rbx
  __int64 v4; // rax
  __int16 n4; // dx
  __int64 v6; // rbx
  __int64 v7; // rax
  __int16 n4_1; // dx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 0xC08);
  v10 = v2;
  if ( v2
    && (v4 = sub_1403B4B50(v2 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v4 + 4), n4 != 4)
    && *(_WORD *)(v4 + 2) == (HIWORD(v2) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_14031FE20(&v10))
    && (v6 = *sub_14644AD00(v2 & 0xFFFFFFFFFFFFLL, &v10), (v10 = v6) != 0)
    && (v7 = sub_1403B4B50(v6 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v7 + 4), n4_1 != 4)
    && *(_WORD *)(v7 + 2) == (HIWORD(v6) & 0xFFF)
    && (n4_1 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v10)) )
  {
    *a2 = *(_QWORD *)((v6 & 0xFFFFFFFFFFFFLL) + 8);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1464E72C0 (0x1464E72C0) ---

// --- Function: sub_1464E73E0 (0x1464E73E0) ---
_QWORD *__fastcall sub_1464E73E0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v5; // [rsp+40h] [rbp+18h] BYREF

  sub_1464E72C0(a1, &v5);
  if ( is_entity_descriptor_valid_or_accessible(&v5) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 8LL))(
      v5 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = *(_QWORD *)(a1 + 0xC10);
  return a2;
}

// --- End Function: sub_1464E73E0 (0x1464E73E0) ---

// --- Function: sub_1464E7810 (0x1464E7810) ---
__int64 __fastcall sub_1464E7810(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xC38);
}

// --- End Function: sub_1464E7810 (0x1464E7810) ---

// --- Function: sub_1465D09B0 (0x1465D09B0) ---
bool __fastcall sub_1465D09B0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x8A8LL))(a1);
  if ( v3 && (v1 = sub_14644BB60(v3), (unsigned __int8)sub_142E160A0(v1)) )
    return 1;
  else
    return sub_142C0F3C0(a1 + 0x768, 0);
}

// --- End Function: sub_1465D09B0 (0x1465D09B0) ---

// --- Function: sub_1465EEDB0 (0x1465EEDB0) ---
__int64 __fastcall sub_1465EEDB0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x6CC8LL;
}

// --- End Function: sub_1465EEDB0 (0x1465EEDB0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 rotatedCookie; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  rotatedCookie = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)rotatedCookie )
  {
    StackCookie = __ROR8__(rotatedCookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 0x18B0);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 0x18C0);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 0x18B0) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 0x1E )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 0x18B0);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: sub_1480BE950 (0x1480BE950) ---
__int64 sub_1480BE950()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = get_thread_context_ptr();
  sub_1402A3D30(*(const void **)(*(_QWORD *)(v0 + 0x10) + 0x18LL));
  result = get_thread_context_ptr();
  *(_QWORD *)(*(_QWORD *)(result + 0x10) + 0x18LL) = 0;
  return result;
}

// --- End Function: sub_1480BE950 (0x1480BE950) ---

