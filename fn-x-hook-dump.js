
// Frida Hook Script generated by IDAFrida (Function Hook with Backtrace)
// Target: Function ProcessEntityPropertyOverrides in module StarCitizen.exe at IDA offset 0x68fe980
// Platform: Linux

(function () {
    console.log("[IDAFrida] Script loaded for module: StarCitizen.exe (with backtrace)");

    const MODULE_NAME = "StarCitizen.exe";
    const TARGET_OFFSET = ptr("0x02A1E30"); // Offset relative to IDA's imagebase

    // --- Helper Functions ---
    function formatArgument(addr) {
        try {
            // @ts-ignore
            if (addr != null && !addr.isNull() && Process.findRangeByAddress(addr)) {
                 // @ts-ignore
                 return addr + " (ptr)";
            }
            // @ts-ignore
            return addr.toString();
        } catch (e) {
            // @ts-ignore
            return addr + " (error: " + e.message + ")";
        }
     }

    /**
     * Performs the actual hooking logic once the module base is known.
     */
    function hookImplementation(moduleBase) {
        // @ts-ignore
        const targetAddress = moduleBase.add(TARGET_OFFSET);
        // @ts-ignore
        const relativeOffset = targetAddress.sub(moduleBase);

        console.log(`[IDAFrida] Attempting to hook fn at address ${targetAddress} (offset ${relativeOffset} from ${moduleBase})`);

        try {
            Interceptor.attach(targetAddress, {
                onEnter: function (args) {
                    this.log = [`[IDAFrida] ENTER fn @ ${targetAddress} (offset ${relativeOffset})`];
                    this.params = [];
                    const numArgs = parseInt("3", 10);

                    for (let i = 0; i < numArgs; i++) {
                        this.params.push(args[i]);
                        // @ts-ignore
                        this.log.push(`  arg[${i}]: ${formatArgument(args[i])}`);
                    }
                    console.log(this.log.join('\n'));

                    // --- Backtrace ---
                    try {
                        // @ts-ignore
                        console.log("[IDAFrida] Backtrace:\n" +
                            // @ts-ignore
                            Thread.backtrace(this.context, Backtracer.ACCURATE) // Or .FUZZY
                            // @ts-ignore
                            .map(addr => {
                                const sym = DebugSymbol.fromAddress(addr);
                                // @ts-ignore // Handle cases where symbol lookup fails
                                return sym.moduleName ? `${sym.moduleName}!${sym.name || '??'} (+0x${addr.sub(sym.address).toString(16)}) [${addr}]` : `[${addr}]`;
                            }).join("\n") + "\n");
                    } catch (btError) {
                         // @ts-ignore
                         console.error(`[IDAFrida] Error getting backtrace: ${btError.message}`);
                    }
                    // --- End Backtrace ---

                },
                onLeave: function (retval) {
                    const log = [`[IDAFrida] LEAVE ProcessEntityPropertyOverrides @ ${targetAddress} (offset ${relativeOffset})`];
                    // @ts-ignore
                    log.push(`  retval: ${formatArgument(retval)}`);
                    console.log(log.join('\n'));
                }
            });
            console.log(`[IDAFrida] Successfully hooked ProcessEntityPropertyOverrides at ${targetAddress}`);
        } catch (error) {
            // @ts-ignore
            console.error(`[IDAFrida] Failed to hook ProcessEntityPropertyOverrides at ${targetAddress}: ${error.message}`);
            // @ts-ignore
            console.error(error.stack);
        }
    }

    /**
     * Waits for the target library to be loaded if it isn't already.
     */
    function ensureModuleLoadedAndHook() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            console.log(`[IDAFrida] Module ${MODULE_NAME} already loaded at ${module.base}. Hooking now.`);
            hookImplementation(module.base);
            return; // Module found, no need to wait
        }

        // Module not loaded yet, wait for dlopen
        console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
        // @ts-ignore
        const dlopenInterceptor = Interceptor.attach(
            // @ts-ignore
            Module.findExportByName(null, "dlopen"), { // Use standard dlopen for Linux
            onEnter: function(args) {
                // @ts-ignore
                const libraryPath = args[0].readCString();
                if (libraryPath && libraryPath.includes(MODULE_NAME)) {
                    this.libraryFound = true;
                    console.log(`[IDAFrida] dlopen called for: ${libraryPath}`);
                }
            },
            onLeave: function(retval) {
                // @ts-ignore
                if (this.libraryFound && !retval.isNull()) {
                    console.log(`[IDAFrida] Module ${MODULE_NAME} loaded via dlopen.`);
                    // @ts-ignore
                    const loadedModule = Process.findModuleByName(MODULE_NAME);
                    if (loadedModule) {
                        hookImplementation(loadedModule.base);
                        dlopenInterceptor.detach(); // Stop listening once hooked
                    } else {
                         console.error(`[IDAFrida] Failed to find module ${MODULE_NAME} immediately after dlopen returned.`);
                    }
                }
                this.libraryFound = false; // Reset for next call
            }
        });
     }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(ensureModuleLoadedAndHook);

})();
